'From Cuis 6.0 [latest update: #5031] on 31 December 2021 at 3:19:41 pm'!


----QUIT----(31 December 2021 15:19:47) Cuis6.0-5031.image priorSource: 0!

----STARTUP---- (21 February 2022 14:50:15) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5031.image!


'From Cuis 5.0 [latest update: #5007] on 30 December 2021 at 4:36:42 pm'!
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 12/30/2021 16:28:15' prior: 16926919!
references: aMethodReference classVarNamed: aName

	^(aMethodReference actualClass theNonMetaClass definesClassVariableNamedInHierarchy: aName) 
		or: [ aMethodReference actualClass theMetaClass definesClassVariableNamedInHierarchy: aName ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5032-RenameClassFix-HernanWilkinson-2021Dec27-16h23m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 3 January 2022 at 8:33:41 pm'!

SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstallerWindow category: #'Tools-Packages' stamp: 'Install-5033-PackageInstaller-MarianoMontone-2022Jan03-21h00m-MM.001.cs.st 2/21/2022 14:50:20'!
SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!
!PackageInstallerWindow commentStamp: '<historical>' prior: 0!
I'm a tool for listing locally available Cuis packages and installing them.!

Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstaller category: #'Tools-Packages' stamp: 'Install-5033-PackageInstaller-MarianoMontone-2022Jan03-21h00m-MM.001.cs.st 2/21/2022 14:50:20'!
Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!
!PackageInstaller commentStamp: '<historical>' prior: 0!
                  I'm the model of PackageInstallerWindow.!
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 15:21:52'!
  buildActionsBar

	| actionsBar | 
	
	actionsBar _ LayoutMorph newRow.
	
	actionsBar addMorph:
		(PluggableButtonMorph 
				model: self 
				action: #installPackage
				label: 'Install package').
	actionsBar addMorph:
		(PluggableButtonMorph
				model: self
				action: #updatePackageList
				label: 'Update package list').
	
	actionsBar addMorph: (LabelMorph contents: 'Search: ').
	
	filterInput _ TextModelMorph textProvider: self textGetter: #filterString textSetter: #filterString:.
	filterInput acceptOnCR: true;
		askBeforeDiscardingEdits: false.
	actionsBar addMorph: filterInput layoutSpec: (LayoutSpec fixedHeight: 30).
	
	^ actionsBar! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 13:56:23'!
    buildDetailPane
	^ TextModelMorph textProvider:  self textGetter: #packageDescription! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 15:23:37'!
                   buildMorphicWindow

	|layout|
		
	layout _ LayoutMorph newRow.
	layout addMorph: self buildPackageListMorph layoutSpec: (LayoutSpec proportionalWidth: 0.5).
	layout addAdjusterAndMorph: self buildDetailPane layoutSpec: (LayoutSpec proportionalWidth: 0.5).
	self addMorph: layout layoutSpec: (LayoutSpec proportionalWidth: 1).
	self addMorph: self buildActionsBar layoutSpec: (LayoutSpec new fixedHeight: 30; proportionalWidth: 1; yourself). 
	! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 15:29:21'!
             buildPackageListMorph
	
	^ PluggableListMorph model: self listGetter: #packageListNames indexGetter: #currentIndex indexSetter: #currentIndex:.! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 12/27/2021 20:33:57' overrides: 16959063!
     windowColor
	^ Color fromHexString: '#88e6d8'! !
!PackageInstallerWindow methodsFor: 'initialization' stamp: 'MM 11/25/2021 15:18:18' overrides: 16959340!
     initialize
	super initialize.
	filterString _ ''.! !
!PackageInstallerWindow methodsFor: 'actions' stamp: 'MM 11/25/2021 19:26:26'!
                            installPackage
	self selectedPackage ifNotNil: [:package | 
		(FeatureRequirement name: package packageName)
		pathName: package fullName;
		satisfyRequirementsAndInstall]! !
!PackageInstallerWindow methodsFor: 'actions' stamp: 'MM 11/25/2021 14:04:10'!
  open
	self buildMorphicWindow.
	labelString _ 'Package Installer'.
	self openInWorld! !
!PackageInstallerWindow methodsFor: 'actions' stamp: 'MM 11/25/2021 15:30:07'!
                         updatePackageList

	model updatePackageList.
	self changed: #packageListNames! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 15:17:00'!
                              currentIndex
	^ currentIndex ifNil: [0]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 15:17:08'!
    currentIndex: index
	currentIndex _ index.
	self changed: #acceptedContents! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45'!
filterInput
	"Answer the value of filterInput"

	^ filterInput! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45'!
             filterInput: anObject
	"Set the value of filterInput"

	filterInput _ anObject! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45'!
                             filterString
	"Answer the value of filterString"

	^ filterString! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:53:16'!
          filterString: aString
	"Set the value of filterString"

	filterString _ aString.
	filterInput hasUnacceptedEdits: false.
	self currentIndex: nil.
	self changed: #packageListNames! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:18:21'!
                         filteredPackageList

	| packageList |
	
	packageList _ model packageList.
	
	^ filterString isEmpty
		ifTrue: [packageList]
		ifFalse: [packageList select: [:package | package packageName includesSubstring: filterString caseSensitive: false]]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 14:18:16'!
                         getFilter
	^ [:str :el | el printString includesSubstring: str caseSensitive: false]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45' overrides: 16911717!
   model
	"Answer the value of model"

	^ model! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45' overrides: 16911747!
           model: anObject
	"Set the value of model"

	model _ anObject! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 19:19:54'!
               packageDescription

	|package|
	
	package _ self selectedPackage.
	
	package ifNil: [^''].
	
	^ String streamContents: [:s | 
		s nextPutAll: package packageName;
			newLine.
		60 timesRepeat: [	s nextPut: $-].
		s newLine; newLine.
		
		package packageDescription ifNotEmpty: [:description |
			s nextPutAll: description;
				newLine;
				newLine].
		
		s nextPutAll: package description]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:12:17'!
      packageListNames

	^ self filteredPackageList collect: [:package | package packageName].
	
	! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:10:59'!
               selectedPackage
	currentIndex ifNil: [^nil].
	currentIndex isZero ifTrue: [^nil].
	^ self filteredPackageList at: currentIndex.! !
!PackageInstallerWindow class methodsFor: 'as yet unclassified' stamp: 'MM 11/25/2021 15:11:25'!
                            open

	^ self open: PackageInstaller new label: 'Package Installer'! !
!PackageInstallerWindow class methodsFor: 'as yet unclassified' stamp: 'MM 11/25/2021 17:15:50'!
                        worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->	'Package Installer'.
			#object 			-> 	PackageInstallerWindow.
			#selector 		-> 		#open.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for installing local Cuis packages.'.
		} asDictionary}`! !
!PackageInstaller methodsFor: 'accessing' stamp: 'MM 11/25/2021 15:12:28'!
   addPackage: aPackageSpec

	packageList add: aPackageSpec! !
!PackageInstaller methodsFor: 'accessing' stamp: 'MM 11/25/2021 14:24:04'!
                         packageList
	"Answer the value of packageList"

	^ packageList! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 11/25/2021 19:16:55'!
                     collectPackagesFromDirectory: aDirectory

	"Create a collection of PackageSpec with package files found in aDirectory."
	
	|packageFiles|
	
	packageFiles _ aDirectory fileNamesMatching: '*.pck.st'.
		
	packageFiles do: [:packageFile | | codePackage |
		codePackage _ CodePackageFile onFileEntry: (aDirectory // packageFile).
		self addPackage: codePackage]! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 11/25/2021 14:39:54'!
               collectPackagesFromDisk

	"Collect PackageSpec with package files found in Cuis packages directories."
	
	self placesToLookForPackagesDo: [:aDirectory | 
		self collectPackagesFromDirectory: aDirectory]! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 11/25/2021 14:40:18'!
         placesToLookForPackagesDo: aBlock

	| base packagesDirectory |

	"Look in Cuis image folder and reasonable subfolders"
	base _ DirectoryEntry smalltalkImageDirectory.
	aBlock value: base.
	packagesDirectory _ base / 'Packages'.
	aBlock value: packagesDirectory.
	packagesDirectory allRegularDirectoriesDo: aBlock.
	base regularDirectoriesDo: [ :child |
		child = packagesDirectory ifFalse: [
			aBlock value: child.
			child allRegularDirectoriesDo: aBlock]].
	
	"Look in parent directory and reasonable subfolders. 
	Useful when image is stored in a subdirectory of the main app directory.
	This could be the case when the package comes from a 'main' git repo, and image is copied from gitHub.
	First try directories including the word Cuis in the name. Then try others."
	base parent regularDirectoriesDo: [ :dir |
		dir ~= base ifTrue: [
			('*Cuis*' match: dir name)
				ifTrue: [aBlock value: dir. dir allRegularDirectoriesDo: aBlock]]].
	base parent regularDirectoriesDo: [ :dir |
		dir ~= base ifTrue: [
			('*Cuis*' match: dir name)
				ifFalse: [aBlock value: dir. dir allRegularDirectoriesDo: aBlock]]].

	"Also look in host OS current directory"
	(base ~= DirectoryEntry currentDirectory and: [base parent ~= DirectoryEntry currentDirectory])
		ifTrue: [
			base _ DirectoryEntry currentDirectory.
			base allRegularDirectoriesDo: aBlock ]! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 1/1/2022 18:39:02'!
               updatePackageList
	
	(PopUpMenu confirm: 'I need to scan for packages. This takes some time. Continue?')
		ifFalse: [^ OrderedCollection new].
	packageList _ OrderedCollection new.
	self collectPackagesFromDisk.
	packageList sort: [:p1 :p2 | p1 packageName < p2 packageName].
	PackageList _ packageList.
	self changed: #packageList.
	^ packageList! !
!PackageInstaller methodsFor: 'initialization' stamp: 'MM 11/25/2021 16:15:28' overrides: 16920235!
                             initialize
	packageList _ PackageList ifNil: [self updatePackageList]! !
!CodePackageFile methodsFor: '*PackageInstaller' stamp: 'MM 11/19/2021 14:30:09'!
     packageDescription
	^ description! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5033-PackageInstaller-MarianoMontone-2022Jan03-21h00m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 3 January 2022 at 8:33:44 pm'!

SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstallerWindow category: #'Tools-Packages' stamp: 'Install-5034-PackageInstallerCategory-MarianoMontone-2022Jan03-21h32m-MM.001.cs.st 2/21/2022 14:50:20'!
SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!

Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstaller category: #'Tools-Packages' stamp: 'Install-5034-PackageInstallerCategory-MarianoMontone-2022Jan03-21h32m-MM.001.cs.st 2/21/2022 14:50:20'!
Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5034-PackageInstallerCategory-MarianoMontone-2022Jan03-21h32m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 3 January 2022 at 9:19:11 pm'!
!TheWorldMenu methodsFor: 'menu' stamp: 'MM 1/3/2022 21:10:34'!
     openPackageDownloader
	"In PackageDownloader.pck"
	Smalltalk at: #PackageDownloaderWindow ifAbsent: [ 
		(PopUpMenu 
		confirm: 'The Package Downloader is not loaded', String newLineString, 'Would you like me to load it for you now?')
		ifTrue: [Feature require: #'PackageDownloader'] 
	].
	Smalltalk at: #PackageDownloaderWindow ifPresent: [ :cls | ^cls open ].
	self inform: 'Please install optional package PackageDownloader.pck.st', String newLineString, 'Feature require: #''PackageDownloader'' '! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'MM 1/3/2022 21:17:30'!
                        worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->	'Package Downloader'.
			#selector 		-> 		#openPackageDownloader.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for downloading Cuis packages from the internet.'.
		} asDictionary}`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5035-PackageDownloaderMenu-MarianoMontone-2022Jan03-22h10m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5035] on 3 January 2022 at 10:31:34 pm'!
!Theme methodsFor: 'tool colors' stamp: 'MM 1/3/2022 22:29:24'!
          packageDownloader
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color fromHexString: '#d0e973'` ]! !
!Theme methodsFor: 'tool colors' stamp: 'MM 1/3/2022 22:30:22'!
                            packageInstaller
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color fromHexString: '#88e6d8'` ]! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 1/3/2022 22:30:37' prior: 50331774 overrides: 16959063!
       windowColor
	^ Theme current packageInstaller! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5036-PackageToolsWindowsColors-MarianoMontone-2022Jan03-22h29m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 4 January 2022 at 5:06:18 pm'!
!DebuggerMethodMap methodsFor: 'private' stamp: 'HAW 1/4/2022 17:04:37'!
                    privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents ifXtraBindings: xtraBindingsBlock ifNot: notXtraBindingBlock

	| nameRefPair namesAndRefs |
	
	namesAndRefs _ self 
		privateTempRefsForContext: aContext
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents.
		
	^index <= namesAndRefs size
		ifTrue: [
			nameRefPair _ namesAndRefs
				at: index
				ifAbsent: [ aContext errorSubscriptBounds: index ].
			notXtraBindingBlock value: nameRefPair last ]
		ifFalse: [ xtraBindingsBlock value: (aContext method xtraBindings at: index - namesAndRefs size) ]! !
!DebuggerMethodMap methodsFor: 'private' stamp: 'HAW 1/4/2022 17:04:45' prior: 16839255!
           privateTempAt: index in: aContext put: aValue startpcsToBlockExtents: theContextsStartpcsToBlockExtents
	
	^self 
		privateTempAt: index 
		in: aContext 
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents 
		ifXtraBindings: [ :xtraBinding | xtraBinding value: aValue ]
		ifNot: [ :ref | self privateDereference: ref in: aContext put: aValue ]
		! !
!DebuggerMethodMap methodsFor: 'private' stamp: 'HAW 1/4/2022 17:05:12' prior: 16839270!
 privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents

	^self 
		privateTempAt: index 
		in: aContext 
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents 
		ifXtraBindings: [ :xtraBinding | xtraBinding value ] 
		ifNot: [ :ref | self privateDereference: ref in: aContext ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5037-DebuggerMethodMapFix-HernanWilkinson-2022Jan04-17h04m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 4 January 2022 at 6:08:45 pm'!

TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!classDefinition: #Inspector category: #'Tools-Inspector' stamp: 'Install-5038-InspectorScriptAreaBehavesLikeWorkspace-HernanWilkinson-2022Jan04-17h06m-HAW.001.cs.st 2/21/2022 14:50:20'!
TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!
!PluggableTextModel methodsFor: 'binding' stamp: 'HAW 1/4/2022 18:02:38' overrides: 16901683!
        bindingOf: aString

	^textProvider bindingOf: aString! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 18:06:01'!
hasBindingThatBeginsWith: aString 

	| beginsWithBlock |
	
	beginsWithBlock := [ :varName | varName beginsWith: aString ].
	
	^(self objectClass allInstVarNames anySatisfy: beginsWithBlock) or: [ bindings keys anySatisfy: beginsWithBlock ]! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 17:35:55'!
      initializeBindings
	
	bindings _ Dictionary new.
	self changed: #actualContents.
! !
!Inspector methodsFor: 'binding' stamp: 'HAW 1/4/2022 18:02:01' overrides: 16901683!
                      bindingOf: aString
	
	(bindings includesKey: aString) ifFalse: [
		aString first isUppercase
			ifTrue: [^nil]
			ifFalse: [bindings at: aString put: nil]].
		
	^bindings associationAt: aString! !
!Inspector methodsFor: 'initialization' stamp: 'HAW 1/4/2022 17:36:05' prior: 16871917 overrides: 16920235!
               initialize

	super initialize.
	acceptedContentsCache _ ''.
	selectionIndex := 0.
	self initializeEvents.
	self initializeBindings ! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 17:32:23' prior: 16872088!
  bindingNamesDo: aBlock

	self objectClass allInstVarNames do: aBlock.
	bindings keysDo: aBlock! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 17:33:50' prior: 16872093!
       hasBindingOf: aString
	^ (self objectClass allInstVarNames includes: aString) or: [ 	bindings includesKey: aString ]! !

TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!classDefinition: #Inspector category: #'Tools-Inspector' stamp: 'Install-5038-InspectorScriptAreaBehavesLikeWorkspace-HernanWilkinson-2022Jan04-17h06m-HAW.001.cs.st 2/21/2022 14:50:20'!
TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5038-InspectorScriptAreaBehavesLikeWorkspace-HernanWilkinson-2022Jan04-17h06m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5038] on 5 January 2022 at 1:18:45 pm'!
!PlacedMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:20:00'!
      categoryInNewMorphMenu
	^ 'Vector Graphics'! !
!ProgressMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:46:33' overrides: 16895515!
  initializedInstance
	| progress |
	progress _ ProgressMorph label: 'Test progress' subLabel: 'this is the subheading'.
	[
		100 timesRepeat: [
			(Delay forMilliseconds: 30) wait.
			progress incrDone: 0.01 ].
		progress delete] fork.
	^progress! !
!HaloHandleMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:22:20' overrides: 16895531!
                      includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!HaloMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:22:38' overrides: 16895531!
            includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!DraggingGuideMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:23:37' overrides: 16895531!
   includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!TextParagraphMorph class methodsFor: 'instance creation' stamp: 'jmv 1/5/2022 12:30:08' overrides: 16895515!
         initializedInstance

	^self contents:
'I am a read-only text paragraph.
I can hold several lines of text.
Even with ', ' text ' bold, 'styles.' italic, '
Try resizing me with the Halo.'! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:37:37' overrides: 16895531!
              includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!ProgressBarMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:39:28' overrides: 16895531!
     includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!MenuLineMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:25:48' overrides: 16895531!
        includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!MenuMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:25:58' overrides: 16895531!
            includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!BoxedMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:09:00' prior: 16794540 overrides: 50332277!
                           categoryInNewMorphMenu
	^ 'Basic'! !
!TheWorldMenu methodsFor: 'private' stamp: 'jmv 1/5/2022 12:53:09' prior: 16970485!
       pvtAlphaSplitListDepth
	"Split factor.  A higher number results in fewer items in each submenu"
	^ 3! !

ProgressBarMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: ProgressBarMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Widgets'!

FillInTheBlankMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: FillInTheBlankMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Widgets'!

HaloMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: HaloMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Halos'!

HaloHandleMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: HaloHandleMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Halos'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5038] on 5 January 2022 at 1:19:05 pm'!
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 1/5/2022 13:11:47' prior: 16866271!
                   grabMorph: aMorph moveUnderHand: moveUnderHand
	"Grab the given morph (i.e., add it to this hand and remove it from its current owner).
	If moveUnderHand is requested or it seems neccesary anyway, move the grabbed morph under the hand."

	| grabbed positionInHandCoordinates tx bounds |
	self releaseMouseFocus.	"Break focus"
	grabbed _ aMorph.
	aMorph owner ifNotNil: [ :o | grabbed _ o aboutToGrab: aMorph ].
	grabbed ifNil: [ ^ self ].
	grabbed _ grabbed aboutToBeGrabbedBy: self.
	grabbed ifNil: [ ^ self ].
	self hideHardwareCursor.
	self redrawNeeded.

	moveUnderHand ifTrue: [
		bounds _ nil.
		grabbed isInWorld ifTrue: [
			bounds _ (grabbed displayBounds ifNil: [grabbed fullBoundsInOwner ])
				translatedBy: grabbed morphPositionInWorld negated ].
		bounds ifNil: [ bounds _ grabbed fullBoundsInOwner ].
		positionInHandCoordinates _ (bounds center + bounds bottomRight //2) negated.
		self grabMorph: grabbed delta: positionInHandCoordinates.
		^self ].

	positionInHandCoordinates _ (grabbed isInWorld ifTrue: [grabbed] ifFalse: [aMorph])
		morphPositionInWorld - self morphPositionInWorld.

	tx _ GeometryTransformation identity.
	(grabbed isInWorld ifTrue: [grabbed] ifFalse: [aMorph]) withAllOwnersDo: [ :o |
		tx _ o location composedWith: tx ].
	self withAllOwnersReverseDo: [ :o |
		tx _ o location inverseTransformation composedWith: tx ].
	self grabMorph: grabbed delta: positionInHandCoordinates.

	grabbed location: tx.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5040-Hand-grabMorph-fix-JuanVuletich-2022Jan05-13h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5040] on 5 January 2022 at 4:26:32 pm'!
!Text methodsFor: 'attributes' stamp: 'jmv 1/5/2022 16:13:27' prior: 16964281!
hasAnyParagraphAttribute
	"Return false if there are no paragraph attributes"

	^runs values anySatisfy: [ :emphArray | emphArray anySatisfy: [ :attr | attr isParagraphAttribute ]]! !
!TextParagraphMorph methodsFor: 'accessing' stamp: 'jmv 1/5/2022 14:07:55' prior: 16969463!
            contents: aStringOrText
	textComposition textComposed ~= aStringOrText ifTrue: [
		textComposition	
			initialize;
			setModel: (TextModel withText: aStringOrText);
			extentForComposing: self extentForComposing;
			composeAll.
		extent _ textComposition usedExtent + (4 * borderWidth).
		self redrawNeeded ]! !
!TextParagraphMorph methodsFor: 'initialization' stamp: 'jmv 1/5/2022 14:10:00' prior: 16969478 overrides: 16794195!
                   initialize
	super initialize.
	extent _ `1250@1140`.
	textComposition _ TextComposition new.
	textComposition
		setModel: (TextModel withText: '');
		extentForComposing: self extentForComposing;
		composeAll.! !
!TextParagraphMorph methodsFor: 'private' stamp: 'jmv 1/5/2022 16:19:56' prior: 16969533!
                  fit
	"Adjust my height to fit the text."

	| newExtent oldExtent |
	(owner is: #ScrollPane) ifFalse: [
		^self ].
	newExtent _ extent x
		@ (textComposition usedHeight + (4 * borderWidth)
			max: FontFamily defaultLineSpacing + 2).
	extent = newExtent ifFalse: [
		oldExtent _ extent.
		extent _ newExtent.
		self extentChanged: oldExtent.
		owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
		self redrawNeeded ].! !
!TextComposition methodsFor: 'access' stamp: 'jmv 1/5/2022 16:19:07' prior: 16965514!
                           usedExtent
	"If there is any justified, rightFlush or centered text, assume all available width has been used."

	^ self usedWidth @ self usedHeight! !
!TextComposition methodsFor: 'access' stamp: 'jmv 1/5/2022 16:18:54' prior: 16965522!
                  usedWidth
	"If there is any justified, rightFlush or centered text, assume all available width has been used."

	^ maxRightX! !
!TextComposition methodsFor: 'composition' stamp: 'jmv 1/5/2022 16:18:59' prior: 16965537!
     composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY 
	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"

	| newResult composer |
	composer _ TextComposer new.
	editor ifNotNil: [
		composer editor: editor ].
	newResult _ composer
				composeLinesFrom: start
				to: stop
				delta: delta
				into: lineColl
				priorLines: priorLines
				atY: startingY
				text: model actualContents
				extentForComposing: extentForComposing.
	lines _ newResult first asArray.

	"If there is any justified, rightFlush or centered text, assume all available width has been used."
	model actualContents hasAnyParagraphAttribute ifTrue: [ ^extentForComposing x ].

	^newResult second "right border of recomposed lines (bounded by extentForComposing x)"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5041-TextParagraphMorph-fix-JuanVuletich-2022Jan05-16h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5041] on 15 January 2022 at 9:08:32 pm'!
!Mutex methodsFor: 'mutual exclusion' stamp: 'jmv 1/15/2022 21:06:47'!
                       critical: aBlock onReentry: reentryBlock
	"Evaluate aBlock protected by the receiver.
	This method allows using the receiver either as a reentrant or non-reentrant Mutex.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m critical: [ 1 print. m critical: [ 2 print ] onReentry: ['Reentry attempt!!' print]. 3 print ]. 'Done'.
	"

	| activeProcess |
	activeProcess _ Processor activeProcess.
	activeProcess == owner ifTrue: [^reentryBlock value].
	^semaphore critical: [
		owner _ activeProcess.
		aBlock ensure: [owner _ nil]].! !
!Mutex methodsFor: 'mutual exclusion' stamp: 'jmv 1/15/2022 21:05:12'!
          criticalNonReentrant: aBlock
	"Evaluate aBlock protected by the receiver.
	Provides non-reentrant mutex behavior: Raise an error if attempted to reenter from same process.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m criticalNonReentrant: [ 1 print. m criticalNonReentrant: [ 2 print ]. 3 print ]. 'Done'.
	"

	^self critical: aBlock onReentry: [ self error: 'Mutex reentry attempted' ]! !
!Mutex methodsFor: 'mutual exclusion' stamp: 'jmv 1/15/2022 21:04:14' prior: 16898828!
 critical: aBlock
	"Evaluate aBlock protected by the receiver.
	Provides reentrant mutex behavior: Allow reentry from the same process.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m critical: [ 1 print. m critical: [ 2 print ]. 3 print ]. 'Done'.
	"

	^self critical: aBlock onReentry: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5042-Mutex-AllowNonReentrantMutexes-JuanVuletich-2022Jan15-20h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5041] on 16 January 2022 at 12:34:46 pm'!
!MessageSet methodsFor: 'message list' stamp: 'jmv 1/16/2022 12:33:04' prior: 16886389!
        sortByClassHierarchy
	"Sort the message-list by class / selector. List classes in hierarchical order."
	
	| aClass bClass classes classesAndPositions i |

	classes _ Set new.
	messageList do: [ :methodReference |
		methodReference actualClass ifNotNil: [ :actualClass | classes add: actualClass ]].
	classesAndPositions _ Dictionary new.
	i _ 1.
	Smalltalk hierarchySorted: classes do: [ :each |
		classesAndPositions at: each put: i.
		i _ i + 1 ].
	
	messageList _ messageList sort: [ :a :b |
		(a classSymbol = b classSymbol and: [ b classIsMeta = b classIsMeta ])
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
			ifFalse: [
				aClass _ a actualClass.
				bClass _ b actualClass.
				aClass isNil == bClass isNil
					ifTrue: [
						aClass isNil
							ifTrue: [a classSymbol < b classSymbol]
							ifFalse: [(classesAndPositions at: aClass) < (classesAndPositions at: bClass)]]
					ifFalse: [aClass isNil]]].
	messageList do: [ :each | | d |
		d _ (each actualClass theNonMetaClass allSuperclasses select: [ :c |
			classesAndPositions includesKey: c ]) size.
		each prefixStringVersionWith: (
			String streamContents: [ :strm |
				d timesRepeat: [ strm nextPutAll: ' ---'].
				strm nextPut: Character space ]) ].
	self changed: #messageList.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5043-Better-SortByClassHierarchy-JuanVuletich-2022Jan15-21h08m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5043] on 17 January 2022 at 1:01:55 pm'!
!DisplayScreen methodsFor: 'accessing' stamp: 'jmv 1/17/2022 13:00:17' prior: 16844376!
                       getMainCanvas
	"Return a Canvas that can be used to draw onto the receiver.
	Being the sole 'main' canvas means a priviledge: Can use VectorEnginePlugin if available."

	| answer |
	answer _ [ MorphicCanvas onForm: self ]
				on: OutOfMemory
				do: [
					'Not enough memory to run VectorEngine. Using BitBltCanvas instead.' print.
					MorphicCanvas activeSubclass: BitBltCanvas.
					MorphicCanvas onForm: self ].
	^answer! !
!FontFamily class methodsFor: 'file read write' stamp: 'jmv 1/17/2022 12:01:11' prior: 16860354!
                  readAdditionalTrueTypeFonts
	Feature require: 'VectorGraphics'.
	(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
		Feature require: 'VectorEngineInSmalltalk' ].
	UISupervisor whenUIinSafeState: [
		Smalltalk at: #TrueTypeFontFamily ifPresent: [ :cls | cls readAdditionalFonts ]]! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/17/2022 12:01:06' prior: 16860413!
                             promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| selectedNameOrDirectory fontFamily |
	selectedNameOrDirectory _ self promptUserFolders.
	selectedNameOrDirectory isNil ifTrue: [ ^nil ].
	(FontFamily familyNamed: selectedNameOrDirectory)
		ifNotNil: [ :it | ^Preferences setDefaultFont: it familyName ].
	Feature require: 'VectorGraphics'.
	(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
		Feature require: 'VectorEngineInSmalltalk' ].
	UISupervisor whenUIinSafeState: [
		fontFamily _ FontFamily availableFamilies values
			detect: [ :any | any folderName = selectedNameOrDirectory name ]
			ifNone: [
				FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: selectedNameOrDirectory) anyOne ].
		Preferences setDefaultFont: fontFamily familyName ]! !
!Morph methodsFor: 'private' stamp: 'jmv 1/17/2022 12:02:09' prior: 16895209!
                             privateAddAllMorphs: aCollection atIndex: index
	"Private. Add aCollection of morphs to the receiver"
	| myWorld itsWorld otherSubmorphs |
	myWorld _ self world.
	otherSubmorphs _ submorphs copyWithoutAll: aCollection.
	(index between: 0 and: otherSubmorphs size)
		ifFalse: [^ self error: 'index out of range'].
	index = 0
		ifTrue:[	submorphs _ aCollection asArray, otherSubmorphs]
		ifFalse:[	index = otherSubmorphs size
			ifTrue:[	submorphs _ otherSubmorphs, aCollection]
			ifFalse:[	submorphs _ otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].
	aCollection do: [:m | | itsOwner |
		itsOwner _ m owner.
		itsOwner ifNotNil: [
			itsWorld _ m world.
			(itsWorld == myWorld) ifFalse: [
				itsWorld ifNotNil: [m redrawNeeded]].
			(itsOwner ~~ self) ifTrue: [
				m owner privateRemove: m.
				m owner removedMorph: m ]].
		m privateOwner: self.
		myWorld ifNotNil: [m redrawNeeded].
		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].
		itsOwner == self ifFalse: [
			self addedMorph: m.
			m noteNewOwner: self ].
	].
	self privateArrangeWantsToBeOnTop.
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'private' stamp: 'jmv 1/17/2022 12:02:35' prior: 16895264!
  privateAddMorph: aMorph atIndex: index position: aPointOrNil

	| oldIndex myWorld itsWorld oldOwner |
	((index >= 1) and: [index <= (submorphs size + 1)])
		ifFalse: [^ self error: 'index out of range'].
	myWorld _ self world.
	oldOwner _ aMorph owner.
	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue: [
		"aMorph's position changes within in the submorph chain"
		oldIndex < index ifTrue:[
			"moving aMorph to back"
			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.
			submorphs at: index-1 put: aMorph.
		] ifFalse:[
			"moving aMorph to front"
			oldIndex-1 to: index by: -1 do:[:i|
				submorphs at: i+1 put: (submorphs at: i)].
			submorphs at: index put: aMorph.
		].
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
	] ifFalse: [
		"adding a new morph"
		oldOwner ifNotNil: [
			itsWorld _ aMorph world.
			itsWorld ifNotNil: [aMorph invalidateBounds].
			oldOwner privateRemove: aMorph.
			oldOwner removedMorph: aMorph.
		].
		aMorph privateOwner: self.
		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].
	].
	myWorld ifNotNil: [
		index = 1
			ifTrue: [aMorph redrawNeeded ]
			ifFalse: [aMorph invalidateBounds]].
	self privateArrangeWantsToBeOnTop.
	self someSubmorphPositionOrExtentChanged.
	oldOwner == self ifFalse: [
		self addedMorph: aMorph.
		aMorph noteNewOwner: self ]! !

BitBltCanvas removeSelector: #canDraw:!

!methodRemoval: BitBltCanvas #canDraw: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canDraw: aMorph
	^aMorph requiresVectorCanvas not!

BitBltCanvas removeSelector: #setPluginAndForm:!

!methodRemoval: BitBltCanvas #setPluginAndForm: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
setPluginAndForm: aForm
	"No VectorEnginePlugin in BitBltCanvas."

	self setForm: aForm subPixelAntiAliasing: nil.!

MorphicCanvas class removeSelector: #withVectorEnginePluginOnForm:!

!methodRemoval: MorphicCanvas class #withVectorEnginePluginOnForm: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
withVectorEnginePluginOnForm: aForm
	"Note: Only one instance using VectorEnginePlugin should be acive at a time:
	the plugin holds numeric parameters that are not passed again on every call."

	^ self subclassToUse basicNew
		setPluginAndForm: aForm;
		initializeWithTranslation: `0@0`.!

MorphicCanvas removeSelector: #canDraw:!

!methodRemoval: MorphicCanvas #canDraw: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canDraw: aMorph
	^true!

WorldMorph removeSelector: #canHandle:!

!methodRemoval: WorldMorph #canHandle: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canHandle: aMorph

	^ canvas canDraw: aMorph!

Morph removeSelector: #canAdd:!

!methodRemoval: Morph #canAdd: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canAdd: aMorph
	self world ifNotNil: [ :w |
		^w canHandle: aMorph ].
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5044] on 18 January 2022 at 3:53:57 pm'!
!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 1/18/2022 15:53:28' prior: 16834092 overrides: 50332238!
         bindingNamesDo: aBlock
	self fieldList do: aBlock! !
!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 1/18/2022 15:53:22' prior: 16834097 overrides: 50332244!
               hasBindingOf: aString
	^ self fieldList includes: aString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5045-ContextVariablesInspector-fix-JuanVuletich-2022Jan18-15h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5045] on 25 January 2022 at 9:34:42 am'!
!Character class methodsFor: 'class initialization' stamp: 'len 12/28/2021 12:09:45' prior: 16808458!
       greekLowercaseLetters
	"Answer the lowercase greek letters included in our font within the ASCII range.
	These are considered lowercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ 'àâäãåçéèµò'! !
!Character class methodsFor: 'class initialization' stamp: 'len 12/28/2021 12:09:40' prior: 16808469!
     greekUppercaseLetters
	"Answer the uppercase greek letters included in our font within the ASCII range.
	These are considered uppercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ 'ñó'! !
!Character class methodsFor: 'class initialization' stamp: 'len 1/9/2022 07:55:43' prior: 16808581!
               initializeUnicodeCodePoints
	"
	Character initializeUnicodeCodePoints
	String streamContents: [ :strm | 28 to: 255 do: [ :i | strm nextPut: (Character numericValue: i) ]]
	"

	"Initialize the table of Unicode code points"
	UnicodeCodePoints _ Array new: 256.
	0 to: 255 do: [ :code |
		UnicodeCodePoints at: code + 1 put: code ].

	"Arrows"
	UnicodeCodePoints at: 28+1 put: 8592.		"left arrow"
	UnicodeCodePoints at: 29+1 put: 8594.		"right arrow"
	UnicodeCodePoints at: 30+1 put: 8593.		"up arrow"
	UnicodeCodePoints at: 31+1 put: 8595.		"down arrow"
	
	"The following codes are different in ISO 8859-15 from those in ISO 8859-1,
	so the character code is not equal to the Unicode code point"
	UnicodeCodePoints at: 16rA4+1 put: 16r20AC.		"euro sign"
	UnicodeCodePoints at: 16rA6+1 put: 16r160.		"latin capital letter S with caron"
	UnicodeCodePoints at: 16rA8+1 put: 16r161.		"latin small letter s with caron"
	UnicodeCodePoints at: 16rB4+1 put: 16r17D.		"latin capital letter Z with caron"
	UnicodeCodePoints at: 16rB8+1 put: 16r17E.		"latin small letter z with caron"
	UnicodeCodePoints at: 16rBC+1 put: 16r152.		"latin capital ligature OE"
	UnicodeCodePoints at: 16rBD+1 put: 16r153.		"latin small ligature oe"
	UnicodeCodePoints at: 16rBE+1 put: 16r178.		"latin capital letter Y with diaeresis"

	"Mathematical symbols (see Character>>#namedCharactersTable)"
	UnicodeCodePoints at: 16r80+1 put: 16r221E.		"infinity"
	UnicodeCodePoints at: 16r81+1 put: 16r2135.		"aleph"
	UnicodeCodePoints at: 16r82+1 put: 16r2115.		"blackboard bold N"
	UnicodeCodePoints at: 16r83+1 put: 16r2124.		"blackboard bold Z"
	UnicodeCodePoints at: 16r84+1 put: 16r211A.		"blackboard bold Q"
	UnicodeCodePoints at: 16r85+1 put: 16r211D.		"blackboard bold R"
	UnicodeCodePoints at: 16r86+1 put: 16r2102.		"blackboard bold C"
	UnicodeCodePoints at: 16r87+1 put: 16r2119.		"blackboard bold P"
	UnicodeCodePoints at: 16r88+1 put: 16r03B1.		"alpha"
	UnicodeCodePoints at: 16r89+1 put: 16r03B2.		"beta"
	UnicodeCodePoints at: 16r8A+1 put: 16r03B3.		"gamma"
	UnicodeCodePoints at: 16r8B+1 put: 16r03B4.		"delta"
	UnicodeCodePoints at: 16r8C+1 put: 16r03B5.		"epsilon"
	UnicodeCodePoints at: 16r8D+1 put: 16r03BB.		"lambda"
	UnicodeCodePoints at: 16r8E+1 put: 16r03C0.		"pi"
	UnicodeCodePoints at: 16r8F+1 put: 16r03B6.		"zeta"
	UnicodeCodePoints at: 16r90+1 put: 16r2295.		"oplus"
	UnicodeCodePoints at: 16r91+1 put: 16r2297.		"otimes"
	UnicodeCodePoints at: 16r92+1 put: 16r2218.		"circ"
	UnicodeCodePoints at: 16r93+1 put: 16r2293.		"prod"
	UnicodeCodePoints at: 16r94+1 put: 16r2294.		"coprod"
	UnicodeCodePoints at: 16r95+1 put: 16r22A5.		"perp"
	UnicodeCodePoints at: 16r96+1 put: 16r0394.		"Delta"
	UnicodeCodePoints at: 16r97+1 put: 16r0393.		"Gamma"
	UnicodeCodePoints at: 16r98+1 put: 16r03C9.		"omega"
	UnicodeCodePoints at: 16r99+1 put: 16r21A0.		"SURJECTIVE ARROW"
	UnicodeCodePoints at: 16r9A+1 put: 16r21A3.		"INJECTIVE ARROW"
	UnicodeCodePoints at: 16r9B+1 put: 16r2194.		"BIJECTIVE ARROW"
	UnicodeCodePoints at: 16r9C+1 put: 16r21AA.		"INCLUSION ARROW"
	UnicodeCodePoints at: 16r9D+1 put: 16r21A6.		"MAPPING ARROW"
	UnicodeCodePoints at: 16r9E+1 put: 16r2202.		"partial differential"
	UnicodeCodePoints at: 16r9F+1 put: 16r221A.		"sqrt"! !
!Character class methodsFor: 'constants' stamp: 'len 1/8/2022 10:53:19' prior: 16808990!
        namedCharactersTable
	"Table of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."
	^ #((left $) (right $) (up $) (down $) (oplus $ê) (otimes $ë) (times $◊) (div $˜) #(circ $í) (cdot $∑) (prod $ì) (coprod $î) (perp $ï) (alpha $à) (beta $â) (gamma $ä) (delta $ã) (epsilon $å) (lambda $ç) (mu $µ) (pi $é) (zeta $è) (Delta $ñ) (Gamma $ó) (omega $ò) (N $Ç) (Z $É) (Q $Ñ) (R $Ö) (C $Ü) (P $á) (infty $Ä) (aleph $Å) (sqrt $ü) (partial $û) (deg $∞))! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'len 8/20/2021 16:00:03' prior: 16939514!
        printIt
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."
	| rpt |
	self
		evaluateSelectionAndDo: [ :result |
			rpt _ model fullPrintIt
				ifTrue: [result printText]
				ifFalse: [result printTextLimitedTo: 10000].
			rpt _ rpt copyReplaceAll: Character lf asString with: Character lf asString, ' '.
			self afterSelectionInsertAndSelect: 
				((' ', rpt, ' ') initialFontFrom: emphasisHere)]
		ifFail: [ morph flash ]
		profiled: false.! !

Character initializeUnicodeCodePoints!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5046-MathSymbolsUpdate-LucianoEstebanNotarfrancesco-2022Jan25-09h34m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5046] on 25 January 2022 at 10:15:45 am'!
!HierarchicalListMorph methodsFor: 'events' stamp: 'len 1/25/2022 10:15:18' prior: 16867333 overrides: 16892166!
                             doubleClick: aMouseButtonEvent localPosition: localEventPosition
	doubleClickSelector ifNotNil: [^ self model perform: doubleClickSelector].
	selectedMorph ifNotNil: [self toggleExpandedState: selectedMorph]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'len 1/25/2022 10:14:08' prior: 16867364 overrides: 16911850!
                            mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [ ^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5047-DoubleClickToggleExpand-LucianoEstebanNotarfrancesco-2022Jan25-09h53m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5047] on 26 January 2022 at 4:33:58 pm'!
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 1/26/2022 16:31:14' prior: 50333101 overrides: 16892166!
                 doubleClick: aMouseButtonEvent localPosition: localEventPosition
	doubleClickSelector ifNotNil: [^ self model perform: doubleClickSelector].
	selectedMorph ifNotNil: [
		self toggleExpandedState: selectedMorph.
		self scrollSelectionIntoView ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5048-DoubleClickExpand-scrollSelectionIntoView-JuanVuletich-2022Jan26-16h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5048] on 26 January 2022 at 4:50:38 pm'!
!Object methodsFor: 'system primitives' stamp: 'jmv 1/26/2022 16:49:44' prior: 16903084!
              becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:
	"

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, '. This CompiledMethod would become invalid. #becomeForward: aborted.' ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/26/2022 16:50:06' prior: 16903114!
     becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:copyHash:
	"

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :proces :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, '. This CompiledMethod would become invalid. #becomeForward:copyHash: aborted.' ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self }
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!Array methodsFor: 'converting' stamp: 'jmv 1/26/2022 16:48:48' prior: 16780806!
                      elementsForwardIdentityTo: otherArray
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.

	 The identityHashes remain with the pointers in us rather than with the objects so that
	 the objects in the receiver should still be properly indexed in any existing hashed
	 structures after the mutation.

	Warning: This means that the identityHash of objects in otherArray will change. This
	is most likely a problem if those objects are already in any identityHashed collection!!
	See #elementsForwardIdentityTo:copyHash:.
	They should be #rehash 'ed.

	Additionally, any hashed (not identityHashed) collection with elements in the receiver
	will most likely break if the #hash message gives now a different answer!!
	They should be #rehash 'ed.

	Warning. This is a dangerous operation and it could lead to a crash if some object in
	receiver or argument is receiver of a method currently in execution.
	See #anyReceiverInStackIn: See senders."

	<primitive: 72 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	ec == #'insufficient object memory' ifTrue:
		[self error: 'The virtual machine is out-of-date.  Please upgrade.'].
	self primitiveFailed! !
!Array methodsFor: 'converting' stamp: 'jmv 1/26/2022 16:47:28' prior: 16780851!
              elementsForwardIdentityTo: otherArray copyHash: copyHash
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.

	 If copyHash is true, the identityHashes remain with the pointers in rather than with the
	 objects so that the objects in the receiver should still be properly indexed in any
	 existing hashed structures after the mutation.	
	Warning: This means that the identityHash of objects in otherArray will change. This
	is most likely a problem if those objects are already in any identityHashed collection!!

	If copyHash is false, then the hashes of the objects in otherArray remain unchanged.
	If you know what you're doing this may indeed be what you want.
	Warning: This means that any identityHashed collection with elements in otherArray
	will not be broken, but any identityHashed collection with elements in self will be!!
	They should be #rehash 'ed.

	Additionally, any hashed (not identityHashed) collection with elements in the receiver
	will most likely break if the #hash message gives now a different answer!!
	They should be #rehash 'ed.

	Warning. This is a dangerous operation and it could lead to a crash if some object in
	receiver or argument is receiver of a method currently in execution.
	See #anyReceiverInStackIn: See senders."

	<primitive: 249 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5049-become-betterComments-JuanVuletich-2022Jan26-16h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5038] on 18 January 2022 at 7:34:47 pm'!
!ContextPart methodsFor: 'private-exceptions' stamp: 'jar 1/18/2022 18:57:25'!
                         runUntilReturnFrom: aContext
	"Run the receiver (which must be a stack top context) until aContext returns. Avoid a context that cannot return. 
	Note: to avoid infinite recursion of MNU error inside unwind blocks, implement e.g. a wrapper around the message 
	sentTo: receiver in #doesNotUnderstand:. Note: This method was meant to be used exclusively by #unwindTo."

	| here unwindBottom newTop |
	here _ thisContext.
	"Avoid a context that cannot return (see Note 1 below)"
	unwindBottom _ (self findContextSuchThat: [:ctx | ctx selector = #cannotReturn:]) ifNil: [aContext].
	newTop _ aContext sender.
	"Insert ensure context under unwindBottom in self's stack (see Note 2 below)"
	unwindBottom insertSender: (self class contextEnsure: [here jump]).
	self jump.  "Control jumps to top (see Note 2 below)"
	"Control resumes here once the above inserted ensure block is executed"
	^newTop  "Return the new top context (see Note 3 below)"

	"Note 1: returning from #cannotReturn's sender would crash the VM so we install a guard ensure context right 
	above it and after returning here the unwind will continue safely. Try running and debugging this example 
	(avoid Proceeding the BCR error though; it may indeed crash the image):
	[[[] ensure: [^2]] ensure: [^42]] fork"

	"Note 2: the receiver is run by jumping directly to it (the active process abandons thisContext and executes 
	the receiver on its own stack; the receiver is its top context). However, before jumping to top we insert an ensure 
	block under unwindBottom context that will execute a jump back to thisContext when evaluated. The inserted 
	guard ensure context is removed once control jumps back to thisContext."

	"Note 3: it doesn't matter newTop is not a proper stack top context because #unwindTo will only use it as a starting 
	point in the search for the next unwind context and the computation will never return here. Cf. the pattern in 
	#runUntilErrorOrReturnFrom:: removing the inserted ensure context by stepping until popped when executing 
	non-local returns is not applicable here and would fail tests testTerminateInNestedEnsureWithReturn1 through 4."
! !
!ContextPart methodsFor: 'private-exceptions' stamp: 'jar 1/18/2022 18:55:12' prior: 16833502!
                               unwindTo: aContext

	| top ctxt outerMost |
	"If the receiver represents a block already halfways through an unwind, complete that unwind block
	first; if there are multiple such nested unwind blocks, try to complete the outer-most one; all nested 
	unwind blocks will be completed in the process; see tests in UnwindTest, testTerminationDuringUnwind. 
	Note: Halfway-through blocks have already set the complete variable (tempAt: 2) in their defining
	#ensure:/#ifCurtailed contexts from nil to true; we'll search for the bottom-most one.
	Note: #findNextUnwindContextUpTo: starts searching from the receiver's sender so we must check 
	whether the receiver itself is an unwind context as well; see testTerminateEnsureAsStackTop."
	ctxt _ top _ self.
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt:2) ifNotNil: [
			outerMost _ ctxt].
		ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	outerMost ifNotNil: [top _ (top runUntilReturnFrom: outerMost) sender].

	"By now no halfway-through unwind blocks are on the stack. Create a new top context for each 
	pending unwind block (tempAt: 1) and execute it on the unwind block's stack to execute non-local 
	returns correctly. Cf. the unwind pattern in #resume:through:. In #unwindTo, using #value instead of 
	#runUntilReturnFrom: would lead to an incorrect evaluation of non-local returns on the wrong stack. 
	Note: top points to the former outerMost sender now, i.e. to the next unexplored context."
	ctxt _ top.
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt: 2) ifNil: [
			ctxt tempAt: 2 put: true.
			top _ (ctxt tempAt: 1) asContextWithSender: ctxt.
			top runUntilReturnFrom: top].
		ctxt _ ctxt findNextUnwindContextUpTo: aContext]
! !
!Process methodsFor: 'changing process state' stamp: 'jar 1/18/2022 19:30:02' prior: 16917643!
     terminate 
	"Stop the process that the receiver represents forever. Unwind to execute pending ensure: and
	 ifCurtailed: blocks before terminating; allow all unwind blocks to run; if they are currently in
	 progress, let them finish. If the process is in the middle of a #critical: section, release it properly."
	
	"If terminating the active process, create a parallel stack and run unwinds from there;
	 if terminating a suspended process, create a parallel stack for the process being terminated
	 and resume the suspended process to complete its termination from the parallel stack. Use
	 a priority higher than the active priority to make the process that invoked the termination
	 wait for its completion."

	"If terminating a suspended process (including runnable or blocked), always suspend the 
	 terminating process first so it doesn't accidentally get woken up. Equally important is the
	 side effect of the suspension; for pre-2022 VMs #suspend returns a list the process was
	 previously waiting on; figure out if we are terminating the process while waiting in
	 Semaphore>>critical:. In this case, pop the suspendedContext so that we leave the ensure:
	 block inside Semaphore>>critical: without signaling the semaphore.
	 Execute termination wrapped in #valueEnsured to ensure it completes even if the 
	 terminator process itself gets terminated before it's finished; see testTerminateInTerminate."

	| top |
	self isActiveProcess ifTrue: [
		top _ thisContext.
		^[top unwindTo: nil. self suspend] asContext jump].

	[	| oldList |
		suspendedContext isContext ifFalse: [^self].
		oldList _ self suspend.
		(oldList class == Semaphore and:[
			suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue: [
				suspendedContext _ suspendedContext home	].
		top _ suspendedContext.
		suspendedContext _ [top unwindTo: nil. self suspend] asContext.
		self priority: Processor activePriority + 1; resume
	] valueEnsured! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5050-terminate-NewImplementation-JaromirMatas-2022Jan18-19h00m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5050] on 27 January 2022 at 3:10:23 pm'!
!Process methodsFor: 'test support' stamp: 'jar 6/1/2021 11:57:00'!
      terminateFromForkedProcess
	"Stop the process that the receiver represents forever. Unwind to execute pending ensure:/ifCurtailed: blocks before terminating.
	Process termination and exception handling in border cases has been the subject of a deep overhaul in the first months of 2021, by Jaromir Matas.
	See, for instance
		https://lists.cuis.st/mailman/archives/cuis-dev/2021-May/003171.html
		https://lists.cuis.st/mailman/archives/cuis-dev/2021-June/003187.html
	You can also look for other related mail threads in the Cuis mail list.
	Many new tests were added to BaseImageTests.pck.st
	Thank you Jaromir for this important contribution!!
	Note: This implementation was replaced by a new one, also from Jaromir, on January, 2022. This new implementation
	instead of using a separate process, use a separate, cloned stack, from the same process.
	We are keeping the 2021 approach, terminating from a new, forked process, in this method,
	just in case it proves useful too."

	| ctxt unwindBlock oldList outerMost top newTop |
	self isRunning ifTrue: [
		"If terminating the active process, suspend it first and terminate it as a suspended process."
		[self terminate] fork.
		^self suspend].

	[ "run the whole termination wrapped in #valueEnsured to ensure unwind is completed 	even if 
	the process terminating another process gets terminated - see #testTerminateInTerminate"
	"Always suspend the process first so it doesn't accidentally get woken up"
	oldList _ self suspend.
	suspendedContext ifNil: [^self]. "self is already terminated"
	"Figure out if we are terminating the process while waiting in Semaphore>>critical:
	In this case, pop the suspendedContext so that we leave the ensure: block inside
	Semaphore>>critical: without signaling the semaphore."
	(oldList class == Semaphore and:[
		suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue: [
			suspendedContext _ suspendedContext home.
	].

	top _ suspendedContext.
	suspendedContext _ nil. "disable this process while running its stack in active process below"
	"If terminating a process halfways through an unwind, try to complete that unwind block first;
	if there are multiple such nested unwind blocks, try to complete the outer-most one; nested 
	unwind blocks will be completed in the process. Halfway-through blocks have already set the 
	complete variable (tempAt: 2) in their defining #ensure:/#ifCurtailed contexts from nil to true.
	Note: #findNextUnwindContextUpTo: starts searching from the receiver's sender but the receiver 
	itself may be an unwind context."
	ctxt _ top.
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: nil].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt:2) ifNotNil: [
			outerMost _ ctxt].
		ctxt _ ctxt findNextUnwindContextUpTo: nil].
	outerMost ifNotNil: [newTop _ self complete: top to: outerMost].

	"By now no halfway-through unwind blocks are on the stack. Create a new top context for each 
	pending unwind block (tempAt: 1) and execute it on the unwind block's stack. 
	Note: using #value instead of #complete:to: would lead to incorrect evaluation of non-local returns.
	Note: newTop sender points to the former outerMost sender, i.e. the next unexplored context."
	ctxt _ newTop ifNil: [top] ifNotNil: [newTop sender].
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: nil].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt: 2) ifNil: [
			ctxt tempAt: 2 put: true.
			unwindBlock _ ctxt tempAt: 1.
			top _ unwindBlock asContextWithSender: ctxt.
			self complete: top to: top].
		ctxt _ ctxt findNextUnwindContextUpTo: nil]
	] valueEnsured! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5051-terminateFromForkedProcess-JaromirMatas-2022Jan27-15h09m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5049] on 27 January 2022 at 11:53:45 am'!
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/27/2022 11:36:54'!
                        recompileSingleRecursion: force from: oldClass to: newClass
	"Based on #recompile:from:to:mutate:
	Older behavior of that method (before January 2022) did a single BFS on the hierarchy tree,
	creating new classes when traveling downwards, and migrating instances before returning upwards.
	This was changed to build the entire hierarchy, then validate with #canUpdateFrom: and only keep
	the new classes, and migrate instances if #canUpdateFrom: answered true.
	This breaks when recompiling the instance side of the Behavior hierarchy (Behavior, ClassDescription,
	Class and Metaclass).
	This method, appropriate for these classes does a single recursion, i.e. the pre-2022 behavior.
	It uses a more restrictive check for existing instances: It will not allow recompilation if any instance is
	executing any method, regardless of it being affected by the reshaping of the class or not. For this
	reason, for other classes, we prefer the more careful check done by #canUpdateFrom:
	
	See senders."

	(newClass == oldClass and: [force not]) ifTrue:[
		^newClass].

	currentClassIndex _ 0.
	maxClassIndex _ oldClass withAllSubclasses size.

	(oldClass == newClass) ifTrue: [
		"Recompile from newClass without mutating"
		self informUserDuring: [
			newClass withAllSubclassesDo: [ :cl |
				self showProgressFor: cl.
				cl compileAll ]].
		^newClass].

	"Recompile oldClass to newClass"
	self informUserDuring: [
		self mutate: oldClass to: newClass.
	].
	^oldClass "now mutated to newClass"! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'eem 6/11/2008 16:47'!
 mutate: oldClass to: newClass
	"Mutate the old class and subclasses into newClass and subclasses.
	Note: This method is slightly different from: #mutate:toSuper: since
	here we are at the root of reshaping and have two distinct roots."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do:[:oldSubclass| | newSubclass |
		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
		self mutate: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do:[:oldSubclass| | newSubclass |
		oldSubclass ifNotNil:[
			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
			self mutate: oldSubclass to: newSubclass.
		].
	].
	self update: oldClass to: newClass.
	^newClass! !
!ProcessorScheduler methodsFor: 'services' stamp: 'jmv 1/27/2022 11:08:03'!
    anyReceiverInStackInstanceOfClassIn: anArray
	"Iterate over all methods currently in execution. Answer true if in any of them 'self class' an element of argument"
	"
	Processor anyReceiverInStackInstanceOfClassIn: { WorldMorph }
	Processor anyReceiverInStackInstanceOfClassIn: { Text }
	"
	self
		processesDo: [ :p | ]
		withStackFramestDo: [ :p :c |
			(anArray statePointsTo: c receiver class)
				ifTrue: [ ^ true ]]
		runningProcessSearchStart: nil.
	^ false! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/27/2022 11:48:17' prior: 16811187!
                name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory behaviorClasses |
	
	instVars _ Scanner new scanFieldNames: instVarString.
	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass _ Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"
	copyOfOldClass _ oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew _ self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class"
		newClass _ self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass _ oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force _ (newClass declare: classVarString) | (newClass sharing: poolString).

	"... classify ..."
	newCategory _ category withBlanksTrimmed.
	organization _ Smalltalk organization.
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	(oldClass notNil and: [oldClass includesBehavior: Behavior])
		ifTrue: [
			"This is only true for Behavior, ClassDescription, Class and Metaclass. Special treatment."
			unsafe ifFalse: [
				behaviorClasses _ (oldClass withAllSubclasses select: [ :c | c isMeta not ]) asArray.
				(Processor anyReceiverInStackInstanceOfClassIn: behaviorClasses) ifTrue: [
					self error: oldClass name,' has some subInstance running some CompiledMethod.'.
					^nil ]].
			"Please see comment at this method"
			newClass _ self recompileSingleRecursion: force from: oldClass to: newClass ]
		ifFalse: [
			"Other classes"
			newClass _ self recompile: force from: oldClass to: newClass mutate: false ].
	newClass isNil ifTrue: [ ^nil ].

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: newCategory ].
	^newClass! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5052-SpecialRecompilationForBehaviorInstanceSide-JuanVuletich-2022Jan27-11h52m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5049] on 27 January 2022 at 1:38:52 pm'!

ListItemWrapper subclass: #SystemCategoryWrapper
	instanceVariableNames: 'itemName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #SystemCategoryWrapper category: #'Tools-Browser' stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
ListItemWrapper subclass: #SystemCategoryWrapper
	instanceVariableNames: 'itemName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!
!Browser methodsFor: 'system category list' stamp: 'len 1/25/2022 08:19:55'!
      selectedSystemCategory
	"Answer the name of the selected system category or nil."

	^selectedSystemCategory! !
!Browser methodsFor: 'system category list' stamp: 'len 1/25/2022 08:48:29'!
    setSelectedSystemCategory: aString
	"Set the selected system category and update all other selections to be deselected."
	selectedSystemCategory _ aString.
	selectedClassName _ nil.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	self editSelection: (aString isNil ifTrue: [#none] ifFalse: [#newClass]).
	metaClassIndicated _ false.
	self setClassOrganizer.
	self changed: #selectedSystemCategory.
	self changed: #classList.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.
	self acceptedContentsChanged! !
!Browser methodsFor: 'system category list' stamp: 'len 1/27/2022 13:19:44'!
           setSelectedSystemCategoryTreeItem: aSystemCategoryWrapper
	aSystemCategoryWrapper ifNotNil: [self setSelectedSystemCategory: aSystemCategoryWrapper withoutListWrapper]! !
!Browser methodsFor: 'system category list' stamp: 'len 1/27/2022 13:12:19'!
        systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| subcategories roots name |
	subcategories _ Dictionary new.
	self systemCategoryList do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollection new]) add: each].
	roots _ OrderedCollection new.
	self systemCategoryList do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !
!HierarchicalListMorph methodsFor: 'accessing' stamp: 'len 6/7/2020 05:36:17'!
                  roots
	"Answer the root items. These are instances of IndentingListItemMorph and submorphs of the scroller."
	| list |
	list _ self getList collect: [:each| each withoutListWrapper].
	^ scroller submorphs select: [:each| list includes: each withoutListWrapper]! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 1/27/2022 13:13:34'!
             buildMorphicSystemCategoryList
	^(HierarchicalListMorph
		model: model
		listGetter: #systemCategoryRoots
		indexGetter: #selectedSystemCategory
		indexSetter: #setSelectedSystemCategoryTreeItem:
		mainView: self
		menuGetter: #systemCategoryMenu
		keystrokeAction: #systemCatListKey:from:)
			autoDeselect: true;
			autoExpand: true;
			yourself! !
!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'len 6/7/2020 05:02:26'!
               isAncestorOf: anObject
	^ false! !
!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'len 6/6/2020 16:29:09' overrides: 16902975!
                      printOn: aStream
	aStream nextPutAll: self asString! !
!SystemCategoryWrapper methodsFor: 'accessing' stamp: 'len 1/27/2022 13:33:52' overrides: 16881049!
     contents
	| prefix subcategories |
	(item includes: $-) ifTrue: [^ #()].
	prefix _ item, '-'.
	subcategories _ OrderedCollection new.
	model systemCategoryList do: [:each|
		(each beginsWith: prefix)
			ifTrue: [subcategories add: (each copyFrom: prefix size + 1 to: each size)]].
	^ subcategories collect: [:each| self class with: prefix, each name: each model: model]! !
!SystemCategoryWrapper methodsFor: 'testing' stamp: 'len 6/6/2020 12:48:40' overrides: 16881045!
          canBeDragged
	^ false! !
!SystemCategoryWrapper methodsFor: 'testing' stamp: 'len 1/26/2022 07:00:37' overrides: 50334027!
     isAncestorOf: aString
	^ (item includes: $-) not and: [aString beginsWith: item, '-']! !
!SystemCategoryWrapper methodsFor: 'private' stamp: 'len 6/6/2020 12:46:34'!
                          setItem: anObject name: aString model: aModel
	item _ anObject.
	model _ aModel.
	itemName _ aString! !
!SystemCategoryWrapper methodsFor: 'converting' stamp: 'len 6/6/2020 16:28:40' overrides: 16881037!
                    asString
	^ itemName! !
!SystemCategoryWrapper class methodsFor: 'instance creation' stamp: 'len 6/6/2020 12:46:06'!
           with: anObject name: aString model: aModel
	^ self new  setItem: anObject name: aString model: aModel! !
!Browser methodsFor: 'annotation' stamp: 'len 1/25/2022 08:20:16' prior: 16795128 overrides: 16820468!
                annotation
	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."

	|  aSelector aClass |
	(aClass _ self selectedClassOrMetaClass)
		ifNil: [
			self selectedSystemCategory ifNotNil: [ :sysCat |
				^self annotationForSystemCategory: sysCat ].
			^ ''].
	self editSelection == #editComment
		ifTrue: [^ self annotationForSelector: #Comment ofClass: aClass].
	self isEditingExistingClass 
		ifTrue: [^ self annotationForSelector: #Definition ofClass: aClass].
	(aSelector _ self selectedMessageName)
		ifNil: [^ ''].
	^ self annotationForSelector: aSelector ofClass: aClass! !
!Browser methodsFor: 'class functions' stamp: 'len 1/27/2022 13:12:42' prior: 16795273!
                              defineClass: defString notifying: aRequestor  
	"The receiver's textual content is a request to define a new class. The
	source code is defString. If any errors occur in compilation, notify
	aRequestor."
	| oldClass class newClassName defTokens keywdIx |
	oldClass _ self selectedClassOrMetaClass.
	defTokens _ defString findTokens: Character separators.
	keywdIx _ defTokens findFirst: [ :x | x beginsWith: 'category' ].
	keywdIx _ defTokens findFirst: [ :x | '*subclass*' match: x ].
	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.
	((oldClass isNil or: [ oldClass theNonMetaClass name asString ~= newClassName ])
		and: [ Smalltalk includesKey: newClassName asSymbol ]) ifTrue: [
			"Attempting to define new class over existing one when
				not looking at the original one in this browser..."
			(self confirm: (newClassName bold , ' is an existing class in this system.
Redefining it might cause serious problems.
Is this really what you want to do?'))
				ifFalse: [ ^ false ]].
	"ar 8/29/1999: Use oldClass superclass for defining oldClass
	since oldClass superclass knows the definerClass of oldClass."
	oldClass ifNotNil: [ oldClass _ oldClass superclass ].
	class _ Compiler
				evaluate: defString
				notifying: aRequestor
				logged: true.
	(class isKindOf: Behavior)
		ifTrue: [
				self changed: #systemCategoryRoots.
				self changed: #classList.
				self changed: #clearUserEdits.
				self setClass: class selector: nil.
				"self clearUserEditFlag; editClass."
				^ true ]
		ifFalse: [ ^ false ]! !
!Browser methodsFor: 'class list' stamp: 'len 1/27/2022 13:28:49' prior: 16795505!
              defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."

	| answer prefix |
	selectedSystemCategory ifNil: [^ #()].
	answer _ systemOrganizer listAtCategoryNamed: selectedSystemCategory.
	prefix _ selectedSystemCategory, '-'.
	systemOrganizer categories do: [:each| (each beginsWith: prefix) ifTrue: [answer _ answer, (systemOrganizer listAtCategoryNamed: each)]].
	^ answer! !
!Browser methodsFor: 'class list' stamp: 'len 1/25/2022 08:44:48' prior: 16795595!
          recent
	"Let the user select from a list of recently visited classes.  11/96 stp.
	 12/96 di:  use class name, not classes themselves.
	 : dont fall into debugger in empty case"

	| className class recentList |
	recentList _ self class recentClasses select: [:n | Smalltalk includesKey: n].
	recentList size = 0 ifTrue: [^ Smalltalk beep].
	className _ (SelectionMenu selections: recentList) startUpMenu.
	className ifNil: [^ self].
	class _ Smalltalk at: className.
	self setSelectedSystemCategory: class category.
	self selectClass: class! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:26' prior: 16796311!
                              addSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	
	| newName |
	newName _ self newSystemCategoryNameIfNone: [ ^self ].	
	systemOrganizer
		addCategory: newName
		before: selectedSystemCategory.
	self setSelectedSystemCategory: newName.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:30' prior: 16796329!
                       alphabetizeSystemCategories
	systemOrganizer sortCategories.
	self setSelectedSystemCategory: nil.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:36' prior: 16796359!
                    changeSystemCategories: aString 
	"Update the class categories by parsing the argument aString."

	systemOrganizer changeFromString: aString.
	self changed: #systemCategoryRoots.
	^ true! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/25/2022 08:41:44' prior: 16796368!
editSystemCategories
	"Retrieve the description of the class categories of the system organizer."

	self setSelectedSystemCategory: nil.
	self editSelection: #editSystemCategories.
	self changed: #editSystemCategories.
	self acceptedContentsChanged! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:48' prior: 16796390!
  moveAllToOtherSystemCategory
	"If a class category is selected, prompt user for category to move to,
	create a Confirmer so the user can verify that all the classes in current category
 	should be moved to the selected category."
	| newSystemCategory |
	selectedSystemCategory ifNil: [ ^ self ].
	newSystemCategory _ Smalltalk systemCategoryFromUserWithPrompt: 'Move classes to System Category...'.
	(newSystemCategory notNil and: [
		self classList size > 0 and: [ self confirm: 'Are you sure you want to
move classes from ' , selectedSystemCategory , ' 
to ' , newSystemCategory , '?' ]]) ifTrue: [
		"Safer this way (#classList will be a collection of strings with spaces and who knows what in the future.  So let's just get the classes we need directly)"
		(SystemOrganization classesAt: selectedSystemCategory) do: [ :eaClass |
			eaClass category: newSystemCategory ].
		self changed: #systemCategoryRoots ].! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:53' prior: 16796422!
        moveSystemCategoryBottom
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryBottom: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:58' prior: 16796431!
                        moveSystemCategoryDown
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryDown: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:03' prior: 16796440!
                            moveSystemCategoryTop
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryTop: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:07' prior: 16796449!
                              moveSystemCategoryUp
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryUp: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:13' prior: 16796493!
removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList size = 0
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:21' prior: 16796513!
                        renameSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection
	
	21-Mar-2012 jmv Note: This is not recorded appropriately in change sets.
	The easiest solution is to trigger #classRecategorized for all classes in the category.
	But this is not a real solution, as the resulting changeset would not do a rename,
	but create a new category (that would go to the bottom) with all the classes.
	
	In the meantime, disable the menu entry. This is not so important after all.
	"
	| oldName newName |
	selectedSystemCategory ifNil: [ ^ self].  "no selection"
	oldName _ selectedSystemCategory.
	newName _ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName _ aString asSymbol.
			systemOrganizer
				renameCategory: oldName
				toBe: newName.
			self setSelectedSystemCategory: newName.
			self changed: #systemCategoryRoots]! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/25/2022 08:46:41' prior: 16796549!
                      systemCategoryBrowser
	"Create a new system category browser with initial textual 
	contents set to aString."

	| newBrowser |
	selectedSystemCategory
		ifNotNil: [
			newBrowser _ Browser new.
			newBrowser setSelectedSystemCategory: self selectedSystemCategory.
			newBrowser setClass: self selectedClassOrMetaClass selector: self selectedMessageName.
			^newBrowser].
	^nil! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:26' prior: 16796564!
  updateSystemCategories
	"The class categories were changed in another browser. The receiver must 
	reorganize its lists based on these changes."

	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'initialization' stamp: 'len 1/25/2022 08:45:06' prior: 16796701!
                setClass: aBehavior selector: aSymbol
	"Set the state of a new, uninitialized Browser."

	| isMeta aClass messageCatIndex |
	aBehavior ifNil: [^ self].
	aBehavior isMeta
		ifTrue: [
			isMeta _ true.
			aClass _ aBehavior soleInstance]
		ifFalse: [
			isMeta _ false.
			aClass _ aBehavior].
	self setSelectedSystemCategory: aClass category.
	self selectClass: aClass.
	self metaClassIndicated: isMeta.
	aSymbol ifNil: [^ self].
	messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.
	self messageCategoryListIndex: (messageCatIndex > 0
		ifTrue: [messageCatIndex + 1]
		ifFalse: [0]).
	messageCatIndex = 0 ifTrue: [^ self].
	self messageListIndex: (
		(aBehavior organization listAtCategoryNumber: messageCatIndex)
			indexOf: aSymbol).! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'len 1/27/2022 13:17:22' prior: 16867924 overrides: 16795422!
                classListIndex: newIndex
	"Cause system organization to reflect appropriate category"

	| newClassName index |

	(classList isInBounds: newIndex) ifTrue: [
		newClassName _ (classList at: newIndex) withoutLeadingBlanks.
		selectedSystemCategory _ systemOrganizer categoryOfElement: newClassName].
	index _ super classListIndex: newIndex.
	self changed: #systemCategorySingleton.
	^ index! !
!Categorizer methodsFor: 'accessing' stamp: 'len 1/27/2022 13:37:32' prior: 16800846!
   listAtCategoryNamed: categoryName
	"Answer the array of elements associated with the name, categoryName."

	^ self listAtCategoryNumber: (categoryArray indexOf: categoryName ifAbsent: [^ #()])! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 8/2/2021 14:45:19' prior: 16869615!
                          drawLineToggleToTextFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	"If I am not the only item in my container, draw the line between:
		- my left edge
		- and my text left edge"

	| aMorphCenter hLineY hLineLeft rect right |
	anIndentingListItemMorph isSoleItem ifTrue: [ ^ self ].
	hasToggle ifFalse: [
		rect _ anIndentingListItemMorph toggleRectangle.
		aMorphCenter _ anIndentingListItemMorph externalize: rect center.
		right _ (anIndentingListItemMorph externalize: rect rightCenter) x.
		hLineY _ aMorphCenter y.
		hLineLeft _ aMorphCenter x - 1.
		aCanvas
			line: hLineLeft @ hLineY
			to: right @ hLineY
			width: 1
			color: lineColor ]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'len 1/23/2022 11:48:29' prior: 16869640!
            drawLinesFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor 
	anIndentingListItemMorph indentLevel > 0 ifTrue: [
		| hasToggle |
		hasToggle _ anIndentingListItemMorph hasToggle.
	
		"Draw line from toggle to text"
		self
			drawLineToggleToTextFor: anIndentingListItemMorph
			on: aCanvas
			lineColor: lineColor
			hasToggle: hasToggle.

		"Draw the line from toggle to the nextSibling's toggle"
		anIndentingListItemMorph nextSibling ifNotNil: [
			self
				drawLinesToNextSiblingFor: anIndentingListItemMorph
				on: aCanvas
				lineColor: lineColor
				hasToggle: hasToggle ]].

	"If it have children and am expanded, draw a line to its first child"
	(anIndentingListItemMorph firstChild notNil and: [
			anIndentingListItemMorph isExpanded ]) ifTrue: [
		self
			drawLinesToFirstChildFor: anIndentingListItemMorph
			on: aCanvas
			lineColor: lineColor]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 7/18/2014 09:30' prior: 16869668!
                     drawLinesOn: aCanvas 
	| lColor bottomY topY tx clipRect |
	lColor _ Theme current line.
	tx _ aCanvas currentTransformation.
	clipRect _ aCanvas clipRect.
	topY _ (tx internalizePosition: clipRect topLeft) y min: (tx internalizePosition: clipRect topRight) y.
	bottomY _ (tx internalizePosition: clipRect bottomLeft) y max: (tx internalizePosition: clipRect bottomRight) y.
	self submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(submorph morphPosition y between: topY and: bottomY) or: [
				submorph nextSibling notNil and: [
					submorph nextSibling morphPosition y between: topY and: bottomY ] ] ])
		ifTrue: [
			self
				drawLinesFor: submorph
				on: aCanvas
				lineColor: lColor ]]
	! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/20/2012 21:49' prior: 16869693!
                          drawLinesToFirstChildFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor
	"Draw line from me to next sibling"

	| vLineX vLineTop vLineBottom childCenter firstChild |
	"child in the drawn tree. it is acually our submorph"
	firstChild _ anIndentingListItemMorph firstChild.
	childCenter _ firstChild externalize: firstChild toggleRectangle center.
	vLineX _ childCenter x - 1.
	vLineTop _ (anIndentingListItemMorph
		externalize: anIndentingListItemMorph morphExtent) y.
	firstChild hasToggle
		ifTrue: [ vLineBottom _ childCenter y - 7 ]
		ifFalse: [ vLineBottom _ childCenter y ].
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @vLineBottom
		width: 1
		color: lineColor! !
!HierarchicalListMorph methodsFor: 'commands' stamp: 'len 6/7/2020 05:36:50' prior: 16867270!
                   expandAllAsPer: aBlock

	scroller submorphs isEmpty ifTrue: [^self].
	self roots do: [:each| each beFullyExpandedAsPer: aBlock].
	scroller adjustExtent.
	self setScrollDeltas! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'len 6/7/2020 05:31:21' prior: 16867700!
               privateVisualSelection: item
	"Called internally to set a new selection.
	Does not update model"
	| index |
	item isNil ifTrue: [^ self privateVisualSelectionIndex: 0].
	index _ self indexForItem: item.
	index > 0 ifFalse:
		[self expandAllAsPer: [:each| each complexContents isAncestorOf: item withoutListWrapper].
		index _ self indexForItem: item].
	self privateVisualSelectionIndex: index! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 1/27/2022 13:08:33' prior: 16797091!
                         buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCategoryList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
"	systemCatList rightSibling: classList."
	classList leftSibling: systemCatList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	classList makeItemsDraggable.
"	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategoryAt:class:
		whenOutsideList: #categorizeUnderNewCategoryClass:.
"		
	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!BrowserWindow methodsFor: 'menu commands' stamp: 'len 1/25/2022 08:21:41' prior: 16797329!
            openSystemCategoryBrowser
	"Create and schedule a new system category browser with initial textual
	contents set to aString."

	model systemCategoryBrowser ifNotNil: [ :newBrowser |
		newBrowser selectedSystemCategory ifNotNil: [ :category |
			BrowserWindow
				openNoSysCat: newBrowser
				label: 'Classes in category ', category ]]! !
!BrowserWindow methodsFor: 'updating' stamp: 'len 1/25/2022 08:20:58' prior: 16797373 overrides: 16821953!
   classAdded: addedClass

	self model selectedSystemCategory = addedClass category 
		ifTrue: [ self model changed: #classList ]! !
!BrowserWindow methodsFor: 'updating' stamp: 'len 1/25/2022 08:21:31' prior: 16797380 overrides: 16821960!
                   classRenamed: aClass from: oldClassName to: newClassName inCategory: aCategoryName

	| currentSelectedClass |
	
	self canDiscardEdits ifTrue: [
		self model selectedSystemCategory = aCategoryName ifTrue: [
			currentSelectedClass := self model selectedClass.
			currentSelectedClass ifNil: [ 
				self model originalSelectedClassName = oldClassName ifTrue: [ 
					currentSelectedClass := aClass ]].
			
		 	self model changed: #classList.
			self model selectClass: currentSelectedClass ]]! !
!BrowserWindow methodsFor: 'commands' stamp: 'len 1/25/2022 08:45:23' prior: 16797559!
                           findClass

	| scopedClassNames |
	
	scopedClassNames _ model potentialClassNames asOrderedCollection.
	
	self class 
		findClassFrom: scopedClassNames 
		ifFound: [:foundClass |
			model setSelectedSystemCategory: foundClass category.
			model selectClass: foundClass ]! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'len 1/25/2022 09:07:08' prior: 16818367 overrides: 50334569!
                        buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model setSelectedSystemCategory: model systemCategoryList first.
	sysCatList _ PluggableListMorph
			model: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:
			mainView: self
			menuGetter: #codeFileListMenu
			keystrokeAction: #codeFileListKey:from:.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList _ PluggableListMorph
			model: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:
			mainView: self
			menuGetter: #messageCategoryMenu
			keystrokeAction: nil.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.
	sysCatList rightSibling: clsList.
	clsList leftSibling: sysCatList rightSibling: msgCatList.
	msgCatList leftSibling: clsList rightSibling: msgList.
	msgList leftSibling: msgCatList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: Preferences standardCodeFont lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'commands' stamp: 'len 1/25/2022 09:08:23' prior: 16818655 overrides: 50334658!
                findClass
	| pattern foundClass classNames index foundCodeFile |
	self okToChange ifFalse: [^ self flash].
	self request: 'Class name?' do: [:aString|
		aString isEmpty ifFalse:
			[pattern _ aString asLowercase.
			classNames _ Set new.
			classNames addAll: model caseCodeSource classDictionary keys.
			classNames _ classNames asArray select: 
				[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].
			classNames isEmpty ifFalse:
				[index _ classNames size = 1
					ifTrue: [1]
					ifFalse: [(PopUpMenu labelArray: classNames lines: #()) startUpMenu].
				index = 0 ifFalse:
					[foundCodeFile _ nil.
					foundClass _ nil.
					(model caseCodeSource classDictionary includesKey: (classNames at: index))
						ifTrue:
							[foundClass _ model caseCodeSource classDictionary at: (classNames at: index).
							foundCodeFile _ model caseCodeSource].
					foundClass ifNotNil:
						[model setSelectedSystemCategory: foundCodeFile name asSymbol.
						model classListIndex: (model classList indexOf: foundClass name)]]]]]! !

BrowserWindow removeSelector: #buildMorphicSystemCatList!

!methodRemoval: BrowserWindow #buildMorphicSystemCatList stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
buildMorphicSystemCatList

	^PluggableListMorph
		model: model
		listGetter: #systemCategoryList
		indexGetter: #systemCategoryListIndex
		indexSetter: #systemCategoryListIndex:
		mainView: self
		menuGetter: #systemCategoryMenu
		keystrokeAction: #systemCatListKey:from:!

BrowserWindow removeSelector: #buildMorphicSystemCategoryTree!

Browser removeSelector: #systemCategoryTree!

Browser removeSelector: #systemCategoryListIndex:!

!methodRemoval: Browser #systemCategoryListIndex: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
systemCategoryListIndex: anInteger
	"Set the selected system category index to be anInteger. Update all other 
	selections to be deselected."
	
	| index systemCategoryList |
	
	systemCategoryList _ self systemCategoryList.
	index _ systemCategoryList ifInBounds: anInteger ifNot: 0.
	
	selectedSystemCategory _ index = 0 ifFalse: [ systemCategoryList at: index ].
	selectedClassName _ nil.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	self editSelection: ( index = 0 ifTrue: [#none] ifFalse: [#newClass]).
	metaClassIndicated _ false.
	self setClassOrganizer.
	self changed: #systemCategorySelectionChanged.
	self changed: #systemCategoryListIndex.	"update my selection"
	self changed: #classList.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.
	self acceptedContentsChanged!

Browser removeSelector: #selectedSystemCategoryName!

!methodRemoval: Browser #selectedSystemCategoryName stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
selectedSystemCategoryName
	"Answer the name of the selected system category or nil."

	^selectedSystemCategory!

Browser removeSelector: #systemCategoryListIndex!

!methodRemoval: Browser #systemCategoryListIndex stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
systemCategoryListIndex
	"Answer the index of the selected class category."

	systemOrganizer ifNil: [ ^0 ].
	selectedSystemCategory ifNil: [ ^0 ].
	^self systemCategoryList indexOf: selectedSystemCategory!

Browser removeSelector: #categorizeUnderNewCategoryClass:!

!methodRemoval: Browser #categorizeUnderNewCategoryClass: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
categorizeUnderNewCategoryClass: aClassName

	| newCategory |
	
	newCategory _ self newSystemCategoryNameIfNone: [ ^self ].
	
	systemOrganizer
		addCategory: newCategory;
		classify: aClassName withBlanksTrimmed asSymbol under: newCategory.
		
	self changed: #systemCategoryList.
	self changed: #classList.!

Browser removeSelector: #categorizeUnderCategoryAt:class:!

!methodRemoval: Browser #categorizeUnderCategoryAt:class: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
categorizeUnderCategoryAt: aSystemCategoryIndex class: aClassName 

	systemOrganizer classify: aClassName withBlanksTrimmed asSymbol under: (self systemCategoryList at: aSystemCategoryIndex).
	self changed: #classList!

Browser removeSelector: #selectCategoryForClass:!

!methodRemoval: Browser #selectCategoryForClass: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
selectCategoryForClass: theClass

	self systemCategoryListIndex: (self systemCategoryList indexOf: theClass category)
!

SystemOrganization
        renameCategory: #'Theme-Core' toBe: #'Graphics-Themes';
        renameCategory: #'System-TextAttributes' toBe: #'System-Text-Attributes';
        renameCategory: #'System-FileMan-Core' toBe: #'System-File System';
        renameCategory: #'Exceptions Kernel' toBe: #'Exceptions-Kernel';
        renameCategory: #'Exceptions Extensions' toBe: #'Exceptions-Extensions'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5053] on 31 January 2022 at 1:40:48 pm'!
!Browser methodsFor: 'class list' stamp: 'len 1/28/2022 16:21:42' prior: 50334156!
            defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	| answer |
	selectedSystemCategory ifNil: [^ #()].
	answer _ systemOrganizer listAtCategoryNamed: selectedSystemCategory.
	"If it's a top category, include the classes of all its subcategories:"
	(selectedSystemCategory includes: $-) ifFalse:
		[| prefix |
		prefix _ selectedSystemCategory, '-'.
		systemOrganizer categories do: [:each| (each beginsWith: prefix) ifTrue: [answer _ answer, (systemOrganizer listAtCategoryNamed: each)]]].
	^ answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5054-HierarchicalSystemCategories-fix-LucianoEstebanNotarfrancesco-2022Jan31-13h40m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5053] on 31 January 2022 at 1:48:30 pm'!
!MethodReference methodsFor: 'setting' stamp: 'len 1/30/2022 05:52:06'!
          indentLevel: anInteger
	self removeStringVersionPrefix.
	stringVersion _ (String streamContents: [:aStream| anInteger timesRepeat: [aStream nextPutAll: '    ']]), stringVersion! !
!MessageSet methodsFor: 'message list' stamp: 'len 1/30/2022 05:51:23' prior: 50332629!
                    sortByClassHierarchy
	"Sort the message-list by class / selector. List classes in hierarchical order."
	
	| aClass bClass classes classesAndPositions i |

	classes _ Set new.
	messageList do: [ :methodReference |
		methodReference actualClass ifNotNil: [ :actualClass | classes add: actualClass ]].
	classesAndPositions _ Dictionary new.
	i _ 1.
	Smalltalk hierarchySorted: classes do: [ :each |
		classesAndPositions at: each put: i.
		i _ i + 1 ].
	
	messageList _ messageList sort: [ :a :b |
		(a classSymbol = b classSymbol and: [ b classIsMeta = b classIsMeta ])
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
			ifFalse: [
				aClass _ a actualClass.
				bClass _ b actualClass.
				aClass isNil == bClass isNil
					ifTrue: [
						aClass isNil
							ifTrue: [a classSymbol < b classSymbol]
							ifFalse: [(classesAndPositions at: aClass) < (classesAndPositions at: bClass)]]
					ifFalse: [aClass isNil]]].
	messageList do: [ :each |
		each indentLevel:
			(each actualClass theNonMetaClass allSuperclasses select: [ :c |
				classesAndPositions includesKey: c ]) size ].
	self changed: #messageList.! !
!MethodReference methodsFor: 'setting' stamp: 'len 1/30/2022 05:49:54' prior: 16890498!
                          removeStringVersionPrefix
	| i prefixCoda |
	prefixCoda _ '] - '.
	i _ stringVersion findString: prefixCoda.
	i = 0 ifFalse: [stringVersion _ stringVersion copyFrom: i + prefixCoda size to: stringVersion size].
	stringVersion _ stringVersion withoutLeadingBlanks! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5055-MessageSet-indenting-useSpaces-LucianoEstebanNotarfrancesco-2022Jan31-13h40m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5053] on 31 January 2022 at 1:56:49 pm'!
!BitBltBoundsFinderCanvas methodsFor: 'morphic' stamp: 'len 1/31/2022 13:55:54' prior: 16789013!
              updateBoundsIn: aWorldMorph addDamageTo: aDamageRecorder

	aWorldMorph submorphsDo: [ :morph |
		self fullAddRedrawRect: morph to: aDamageRecorder ].
	self updateHandsDisplayBounds: aWorldMorph.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5056-FixSlowdownWhenUsingHalos-JuanVuletich-2022Jan31-13h49m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5056] on 1 February 2022 at 7:53:06 pm'!
!Categorizer methodsFor: 'accessing' stamp: 'len 2/1/2022 19:45:05'!
   renameCategory: oldCatString to: newCatString
	"Rename a category. No action if new name already exists, or if old name does not exist."
	
	| index newCategory |
	
	newCategory _ newCatString withBlanksTrimmed.
	"new name exists, so no action"
	(categoryArray indexOf: newCategory) > 0 ifTrue: [^ self].
	
	"old name not found, so no action"
	(index _ categoryArray indexOf: oldCatString) = 0 ifTrue: [^ self].	
	
	"need to change identity so smart list update will notice the change"
	categoryArray _ categoryArray copy.  
	categoryArray at: index put: newCategory! !
!ClassOrganizer methodsFor: 'accessing' stamp: 'len 2/1/2022 19:46:01' overrides: 50335022!
           renameCategory: oldCatString to: newCatString

	| newCategory oldElementsBefore oldElementsAfter |
	
	newCategory _ newCatString withBlanksTrimmed.
	oldElementsBefore _ self listAtCategoryNamed: oldCatString.
	SystemChangeNotifier uniqueInstance doSilently: [
		super renameCategory: oldCatString to: newCatString].
	
	oldElementsAfter _ (self listAtCategoryNamed: oldCatString) asSet.
	oldElementsBefore do: [:each | (oldElementsAfter includes: each)
		ifFalse: [self notifyOfChangedSelector: each from: oldCatString to: newCategory]].
	
	self notifyOfChangedCategoryFrom: oldCatString to: newCategory.! !
!Browser methodsFor: 'message category functions' stamp: 'len 2/1/2022 19:45:44' prior: 16795873!
                               renameCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	| oldIndex oldName newName |
	selectedClassName ifNil: [^ self].
	selectedMessageCategory ifNil: [ ^self ].
	oldIndex _ self messageCategoryListIndex.
	oldName _ self selectedMessageCategoryName.
	newName _ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName _ aString asSymbol.
			self classOrMetaClassOrganizer
				renameCategory: oldName
				to: newName.
			self classListIndex: self classListIndex.
			self messageCategoryListIndex: oldIndex.
			self changed: #messageCategoryList]! !
!Browser methodsFor: 'system category functions' stamp: 'len 2/1/2022 19:35:19' prior: 50334304!
          removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList size = 0
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			"Remove subcategories:"
			systemOrganizer removeCategoriesMatching: selectedSystemCategory, '-*'.
			"Then remove the top category (it doesn't do anything if it doesn't exist):"
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!Browser methodsFor: 'system category functions' stamp: 'len 2/1/2022 19:45:55' prior: 50334325!
   renameSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection
	
	21-Mar-2012 jmv Note: This is not recorded appropriately in change sets.
	The easiest solution is to trigger #classRecategorized for all classes in the category.
	But this is not a real solution, as the resulting changeset would not do a rename,
	but create a new category (that would go to the bottom) with all the classes.
	
	In the meantime, disable the menu entry. This is not so important after all.
	"
	| oldName newName |
	selectedSystemCategory ifNil: [^ self].  "no selection"
	oldName _ selectedSystemCategory.
	newName _ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName _ aString asSymbol.
			"If it's a top category, rename subcategories first:"
			(oldName includes: $-) ifFalse:
				[(systemOrganizer categoriesMatching: oldName, '-*')
					do: [:each| systemOrganizer renameCategory: each to: newName, (each allButFirst: oldName size)]].
			systemOrganizer renameCategory: oldName to: newName.
			self setSelectedSystemCategory: newName.
			self changed: #systemCategoryRoots]! !
!SystemCategoryWrapper methodsFor: 'accessing' stamp: 'len 2/1/2022 19:50:41' prior: 50334037 overrides: 16881049!
                    contents
	| prefix subcategories |
	(item includes: $-) ifTrue: [^ #()].
	prefix _ item, '-'.
	subcategories _ OrderedCollection new.
	model systemCategoryList do: [:each|
		(each beginsWith: prefix)
			ifTrue: [subcategories add: (each allButFirst: prefix size)]].
	^ subcategories collect: [:each| self class with: prefix, each name: each model: model]! !

ClassOrganizer removeSelector: #renameCategory:toBe:!

!methodRemoval: ClassOrganizer #renameCategory:toBe: stamp: 'Install-5057-FixRenameAndRemoveSystemCategory-LucianoEstebanNotarfrancesco-2022Feb01-19h20m-len.001.cs.st 2/21/2022 14:50:20'!
renameCategory: oldCatString toBe: newCatString

	| newCategory oldElementsBefore oldElementsAfter |
	
	newCategory _ newCatString withBlanksTrimmed.
	oldElementsBefore _ self listAtCategoryNamed: oldCatString.
	SystemChangeNotifier uniqueInstance doSilently: [
		super renameCategory: oldCatString toBe: newCatString].
	
	oldElementsAfter _ (self listAtCategoryNamed: oldCatString) asSet.
	oldElementsBefore do: [:each | (oldElementsAfter includes: each)
		ifFalse: [self notifyOfChangedSelector: each from: oldCatString to: newCategory]].
	
	self notifyOfChangedCategoryFrom: oldCatString to: newCategory.!

Categorizer removeSelector: #renameCategory:toBe:!

!methodRemoval: Categorizer #renameCategory:toBe: stamp: 'Install-5057-FixRenameAndRemoveSystemCategory-LucianoEstebanNotarfrancesco-2022Feb01-19h20m-len.001.cs.st 2/21/2022 14:50:20'!
renameCategory: oldCatString toBe: newCatString
	"Rename a category. No action if new name already exists, or if old name does not exist."
	
	| index newCategory |
	
	newCategory _ newCatString withBlanksTrimmed.
	"new name exists, so no action"
	(categoryArray indexOf: newCategory) > 0 ifTrue: [^ self].
	
	"old name not found, so no action"
	(index _ categoryArray indexOf: oldCatString) = 0 ifTrue: [^ self].	
	
	"need to change identity so smart list update will notice the change"
	categoryArray _ categoryArray copy.  
	categoryArray at: index put: newCategory!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5057-FixRenameAndRemoveSystemCategory-LucianoEstebanNotarfrancesco-2022Feb01-19h20m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5057] on 2 February 2022 at 5:03:04 pm'!
!Process class methodsFor: 'documentation' stamp: 'jmv 2/2/2022 17:02:55' prior: 16917849!
                          terminateExamples
"
This is the contents of the examples posted by Jaromir to exercise his worn on process termination and exceptions.
It was posted to the Cuis mail list at https://lists.cuis.st/mailman/archives/cuis-dev/2021-May/003171.html
(or maybe, it is a later version of edition of it if this comment is not up to date!!)

Thanks Jaromir for this great contribution!!

Workspace new
		contents: Process terminateExamples;
		openLabel: 'Jaromir Mata''s Process - terminate examples Cuis'.
"
^


'"Process - Cuis terminate examples
Some examples to illustrate the termination bugs and test the proposed rewrite of #terminate
=========================================="
"terminate suspended:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess suspend. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

".......................................
terminate runnable:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor yield] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor yield. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"
".......................................
terminate blocked:"

| p s |
s := Semaphore new.
p := [
	[
		[ ] ensure: [
			[s wait] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"


| p s |
s := Semaphore new.
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				s wait. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

".......................................
terminate active:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess terminate] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
"Two yields necessary: terminate active is a two-step procedure"
Processor yield. Processor yield.
Transcript show: p isTerminated printString

"prints x1 x2 x3"


| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess terminate. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
"Two yields necessary: terminate active is a two-step procedure"
Processor yield. Processor yield.
Transcript show: p isTerminated printString

"prints x1 x2 x3"



"==========================================
unhandled error:
Termination happens when the user hits Abandon on the Debugger window."
"cf.: prints x1 x2 x3 x4 when hit Proceed"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''.
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"

"........................
nested unhandled errors:"

| p |
p := [
	[
		[ ] ensure: [
			[self error: ''unwind test outer''] ensure: [
				self error: ''unwind test inner''.
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
"prints x1 x2 x3"


"triple nested errors:"

[self error: ''outer error''] ensure: [
    [self error: ''middle error''] ensure: [
        [self error: ''inner error''] ensure: [
            Transcript show: ''x1''].
        Transcript show: ''x2''].
    Transcript show: ''x3''].
Transcript show: ''x4''
"prints x1 x2 x3"
"same result when wrapped in fork"


[] ensure: [
[self error: ''outer error''] ensure: [
    [self error: ''middle error''] ensure: [
        [self error: ''inner error''] ensure: [
            Transcript show: ''x1''].
        Transcript show: ''x2''].
    Transcript show: ''x3''].
Transcript show: ''x4'']
"prints x1 x2 x3 x4"
"same result when wrapped in fork"



"=========================================
error and non-local return combined:"

"Termination happens when the user hits Abandon on the Debugger window."

"........................
non-local return inside inner-most halfway thru unwind block:"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			^Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''. 
			^Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3"

"........................
non-local return inside outer-most halfway thru unwind block:"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			Transcript show: ''x1'']. 
		^Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''. 
			Transcript show: ''x1'']. 
		^Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''


"prints x1 x2 x3"


"one more level..."
[
	[
		[ ] ensure: [
			[ ] ensure: [
				self error: ''unwind test''. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		^Transcript show: ''x3'']
] ensure: [
	Transcript show: ''x4'']

"prints x1 x2 x3 x4 (even if wrapped in #fork)"



".............................
non-local return outside halfway thru unwind blocks:"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	^Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''. 
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	^Transcript show: ''x3''].
Transcript show: ''x4''


"prints x1 x2 x3"


"============================================================
For comparison only:"

"The tests presented here are not affected by the new #terminate.
(A) an unhandled error unwind in the preceding examples followed the new termination logic completing all unwind blocks halfway through their execution
(B) a handled error unwind follows the traditional ''direct'' unwind path using simpler semantics - it doesn''t complete unwind blocks halfway through their execution"

".........................................
handled error:"


[
	[
		[ ] ensure: [
			[self error: ''unwind test''] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3'']
] on: Error do: [].
Transcript show: ''x4''

"prints x1 x3 x4, skips x2"

[
	[
		[ ] ensure: [
			[] ensure: [
				self error: ''unwind test''.
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3'']
] on: Error do: [].
Transcript show: ''x4''

"prints x3 x4, skips x1 x2"

"............................................
nested handled errors:"

| p |
p := [
	[
		[
			[ ] ensure: [
				[self error: ''unwind test outer''] ensure: [
					self error: ''unwind test inner''.
					Transcript show: ''x1'']. 
				Transcript show: ''x2'']
		] ensure: [
			Transcript show: ''x3'']
	] on: Error do: [].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield. Processor yield.

"prints x3 x4, skips x1 x2"



"............................................
non-local return:"

"Similarly a simple non-local return execution follows a ''direct'' unwind path logic in #resume[:through:] using simpler semantics."

[
	[ ] ensure: [
		[^1] ensure: [
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3, skips x2"


[
	[ ] ensure: [
		[] ensure: [
			^Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3, skips x2"



"==========================================
Crazies:"

"These tests explore new #teminate behavior under more extreme circumstances.
Unwind after active process termination"

[ ] ensure: [
	[Processor activeProcess terminate] ensure: [Transcript show: ''x1'']. 
	Transcript show: ''x2''
	]
"prints x1 x2 and terminates UI - recoverable via Alt+. or cmd+."


"Unwind after active process suspension during termination:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Processor activeProcess suspend. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3'']
] newProcess.
p resume.
Processor yield.
p terminate
"suspends UI and prints x1 x2 x3 after Alt+. recovery"


"Unwind after double active process termination:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess terminate] ensure: [
				Processor activeProcess terminate. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield. Processor yield.
Transcript show: p isTerminated printString
"lets UI live and prints x1 x2 x3"


| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: ''x1''. 
		Processor activeProcess terminate. Transcript show: ''x2'']. 
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield. Processor yield.
Transcript show: p isTerminated printString
"lets current UI live and prints x1 x2"


| p ap |
p := [
	[ ap := Processor activeProcess. ap terminate. Transcript show: ''x1'' ] 
		ensure: [ ap terminate. Transcript show: ''x2'' ]. 
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield.
Transcript show: p isTerminated printString
"lets current UI live and prints x2"


| p |
p := [
	[ Processor activeProcess terminate ] 
		ensure: [ Processor activeProcess terminate ]. 
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield. 
Transcript show: p isTerminated printString
"answers true, no error"



"Unwind after active process termination combined with non-local return:"

| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: ''x1''. 
		true ifTrue: [^2]. 
		Processor activeProcess terminate. Transcript show: ''x2'']
] newProcess.
p resume.
Processor yield. Processor yield. 
Transcript show: p isTerminated printString
"prints x1 and correctly raises BlockCannotReturn error"


"Unwind after BlockCannotReturn error:"

| p a |

a := Array new: 4 withAll: false.
p := [
         [
        	[ ] ensure: [
        			[Processor activeProcess suspend] ensure: [
            			^a at: 1 put: true].
        			a at: 2 put: true]
		] ensure: [a at: 3 put: true].
		a at: 4 put: true
    ] newProcess.
p resume.
Processor yield.
"make sure p is suspended and none of the unwind blocks has finished yet"
self assert: p isSuspended.
a noneSatisfy: [ :b | b ].
"now terminate the process and make sure all unwind blocks have finished"
p terminate.
self assert: p isTerminated.
self assert: a first & a third.
self assert: (a second | a fourth) not.
"--->   #(true false true false) ...OK"


"Triple nested active process terminate:"

[	x := ''''.
	[Processor activeProcess terminate] ensure: [
	    [Processor activeProcess terminate] ensure: [
	        [Processor activeProcess terminate] ensure: [
	            x:=x,''3''].
	        x:=x,''2''].
	    x:=x,''1''].
	x:=x,''0''
] fork
x
"---> ''321'' ...OK"

"Same as before but without fork:"

x := ''''.
[Processor activeProcess terminate] ensure: [
    [Processor activeProcess terminate] ensure: [
        [Processor activeProcess terminate] ensure: [
            x:=x,''3''].
        x:=x,''2''].
    x:=x,''1''].
x:=x,''0''
x
"terminates UI and answers ---> ''321'' after Alt+. recovery"
"(Squeak crashes irrecoverably)"


"Triple nested active process terminate:"

p := 
[	x := ''''.
	[] ensure: [
		[Processor activeProcess suspend] ensure: [
		    [Processor activeProcess suspend] ensure: [
		        [Processor activeProcess suspend] ensure: [
		            x:=x,''3''].
		        x:=x,''2''].
		    x:=x,''1''].
		x:=x,''0'']
] newProcess resume.
Processor yield.
p terminate
x   
"Cuis suspends UI repeatedly but answers ---> ''3210'' after repeated Alt+. recovery
Squeak answers ---> ''3210'' without suspending UI - why the difference?
Without fork Squeak suspends UI just once but Cuis 3 times, both answer x correctly"


"These behave as expected and won''t crash the image even after proceeding the BlockCannotReturn error:"

[^2] fork

[[self error: ''error''] ensure: [^2]] fork

"do-it:"
"Both statements need to be executed separately in a Workspace"
a := [true ifTrue: [^ 1] yourself]
[a value] on: BlockCannotReturn do: [:ex | ex resume]

"do-it:"
"Both statements need to be executed separately in a Workspace"
a := [true ifTrue: [^ 1]. 2]
a value

"These will deal with MessageNotUnderstood correctly and won''t crash the image or loop infinitely"

[] ensure: [self gotcha. Transcript show: ''0'']

[] ensure: [[self gotcha] ensure: [self halt. Transcript show: ''0'']]

[self error: ''error''] ensure: [[self gotcha] ensure: [Transcript show: ''0'']]

[self error: ''error''] ensure: [self gotcha. Transcript show: ''0'']

"This one freezes UI after Halt -> Proceed but recoverable via Alt+."
[[] ensure: [[self gotcha] ensure: [self halt. Transcript show: ''0'']]] fork.



"===============
Some additional unsorted examples:"

"This example should show both ZeroDivide and MessageNotUnderstood errors"

x1 := x2 := x3 := nil.
p:=[
		[
			[ ] ensure: [ "halfway through completion when suspended"
				[ ] ensure: [ "halfway through completion when suspended"
					Processor activeProcess suspend. 
					x1 := (2 / 0  "error!!") > 0]. 
				x2 := true]
		] ensure: [ "not started yet when suspended"
			x3 := true]
] newProcess resume.
Processor yield.
p terminate
{x1 . x2 . x3} --->  #(MessageNotUnderstood: ZeroDivide>>> true true) 


'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5058-terminateExamples-fixFormat-JuanVuletich-2022Feb02-16h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5058] on 2 February 2022 at 7:20:43 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 2/2/2022 19:18:58'!
                               newUIProcessIfNeeded
	"Answer is not nil only if a new process was created."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isTerminated ifTrue: [
			oldUIProcess 	animatedUI ifNotNil: [ :guiRootObject |
				self spawnNewMorphicProcessFor: guiRootObject.
				^UIProcess ]]].
	^nil! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 2/2/2022 17:15:10' prior: 16953292!
                              handleUserInterrupt
	| p |
	"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
	p _ UISupervisor newUIProcessIfNeeded.
	p ifNil: [
		p _ Sensor shiftPressed | Preferences cmdDotInterruptTakesStatistics
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	Preferences cmdDotEnabled ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		p == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(p name beginsWith: '[system]') ifTrue: [
			 ('Process {', p printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			p isTerminated
				ifTrue: [ ('Process {', p printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ UISupervisor userInterrupt: p ]] fork
		]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5059-UserInterruptCreatesUIProcessIfNone-JuanVuletich-2022Feb02-19h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5059] on 4 February 2022 at 5:00:17 pm'!
!SystemOrganizer methodsFor: 'categories' stamp: 'len 2/4/2022 05:52:38'!
                             allClassesAt: aCategoryName
	"Same as >>classesAt: but if aCategoryName is a top category it includes all classes in subcategories."
	^ (self fullListAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName]! !
!SystemOrganizer methodsFor: 'categories' stamp: 'len 2/4/2022 04:47:04' overrides: 16801145!
               classesAt: aCategoryName
	^ (self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName]! !
!SystemOrganizer methodsFor: 'categories' stamp: 'len 2/4/2022 05:44:37'!
                   fullListAtCategoryNamed: aCategoryName
	"Same as >>listAtCategoryNamed: but include subcategories if aCategoryName is a top category."
	| answer |
	answer _ self listAtCategoryNamed: aCategoryName.
	"If it's a top category, include the classes of all its subcategories:"
	(aCategoryName includes: $-) ifFalse:
		[| prefix |
		prefix _ aCategoryName, '-'.
		self categories do: [:each| (each beginsWith: prefix) ifTrue: [answer _ answer, (self listAtCategoryNamed: each)]]].
	^ answer! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 2/4/2022 16:54:25' overrides: 16801152!
                           testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]! !
!Browser methodsFor: 'class list' stamp: 'len 2/4/2022 05:45:07' prior: 50334905!
                       defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	selectedSystemCategory ifNil: [^ #()].
	^ systemOrganizer fullListAtCategoryNamed: selectedSystemCategory! !
!SystemOrganizer methodsFor: 'source code management' stamp: 'HAW 10/13/2021 09:31:11' prior: 16958859!
         classMethodCountOf: category

	^  (self classesAt: category) sum: [ :cl | cl class selectors size ] ifEmpty: 0.! !
!SystemOrganizer methodsFor: 'source code management' stamp: 'HAW 10/13/2021 09:31:23' prior: 16958866!
     instanceMethodCountOf: category

	^ (self classesAt: category) sum: [ :cl | cl selectors size ] ifEmpty: 0.! !
!SystemOrganizer methodsFor: 'source code management' stamp: 'HAW 10/13/2021 09:31:30' prior: 16958873!
         linesOfCodeOf: category
"
SystemOrganization linesOfCodeOf: #'System-Files'
"
	"An approximate measure of lines of.
	Includes comments, but excludes blank lines."

	^ (self classesAt: category) sum: [ :cl | cl linesOfCode ] ifEmpty: 0.! !
!TestSuite class methodsFor: 'instance creation' stamp: 'HAW 2/4/2022 16:59:36' prior: 16963311!
                forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer

	| testCaseClasses |

	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.

	^ testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer allClassesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !

Categorizer removeSelector: #testCaseClassesAt:!

!methodRemoval: Categorizer #testCaseClassesAt: stamp: 'Install-5060-FixRunningTestsOnTopSystemCategories-LucianoEstebanNotarfrancesco+HernanWilkinson-2022Feb04-16h47m-HAW.001.cs.st 2/21/2022 14:50:20'!
testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]!

Categorizer removeSelector: #classesAt:!

!methodRemoval: Categorizer #classesAt: stamp: 'Install-5060-FixRunningTestsOnTopSystemCategories-LucianoEstebanNotarfrancesco+HernanWilkinson-2022Feb04-16h47m-HAW.001.cs.st 2/21/2022 14:50:20'!
classesAt: aCategoryName

	^(self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName ]
		!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5060-FixRunningTestsOnTopSystemCategories-LucianoEstebanNotarfrancesco+HernanWilkinson-2022Feb04-16h47m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5060] on 4 February 2022 at 6:11:13 pm'!
!TestSuite class methodsFor: 'instance creation' stamp: 'HAW 2/4/2022 16:59:36' prior: 50335854!
                forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer

	| testCaseClasses |

	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.

	^ testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer allClassesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !
!TestSuite class methodsFor: 'instance creation - private' stamp: 'HAW 2/4/2022 18:06:52' prior: 16963350!
         forClasses: classes named: aName

	| testMethods suite classTests tests testPrintString |
	
	"I don't want repeated tests. TestCase does not redefine #= so instead of redefining it and use a Set
	I decided to keep the related tests methods in a different set and decide to add it or note base on that
	- Hernan"
	
	testMethods := Set new.
	tests := OrderedCollection new.
	
	classes do: [ :aClass |
		classTests := (self forClass: aClass) tests.
		classTests do: [ :aTest | 
				testPrintString := aTest printString.
				(testMethods includes: testPrintString) ifFalse: [ 
					testMethods add: testPrintString.
					tests add: aTest ]]].
		
	suite := self named: aName.
	suite addTests: tests.
	
	^suite
		
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5061-FindingTests-HernanWilkinson-2022Feb04-17h03m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5061] on 4 February 2022 at 6:35:06 pm'!
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/4/2022 18:33:36' prior: 16940776!
                             testSuiteForCategoryOf: aClass

	^TestSuite forSystemCategoryNamed: self codeProvider selectedSystemCategory using: SystemOrganization 
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5062-cmd+yFixWhenOnTopSystemCategory-HernanWilkinson-2022Feb04-18h33m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5062] on 7 February 2022 at 11:18:53 am'!
!Browser methodsFor: 'self-updating' stamp: 'len 2/5/2022 05:17:22' overrides: 16821313!
                               updateIfNeeded
	super updateIfNeeded.
	self changed: #systemCategoryRoots! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5063-updateSystemCategoriesWhenLoadingPackage-LucianoEstebanNotarfrancesco-2022Feb07-11h17m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5062] on 7 February 2022 at 11:23:53 am'!
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 2/4/2022 04:23:29' prior: 50334569!
       buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCategoryList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
"	classList makeItemsDraggable.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategoryAt:class:
		whenOutsideList: #categorizeUnderNewCategoryClass:.
"		
	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5064-BrowserWindowDNUFix-LucianoEstebanNotarfrancesco-2022Feb07-11h18m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5064] on 8 February 2022 at 9:29:26 am'!
!WorldMorph methodsFor: 'world menu' stamp: 'MM 2/8/2022 09:25:39' prior: 16982796!
                             findAWindowSatisfying: qualifyingBlock orMakeOneUsing: makeBlock
	"Locate a window satisfying a block, open it, and bring it to the front.  Create one if necessary, by using the makeBlock"
	| aWindow |
	submorphs do: [ :aMorph |
		(((aWindow _ aMorph) is: #SystemWindow) and: [ qualifyingBlock value: aWindow ]) ifTrue: [
			aWindow isCollapsed ifTrue: [ aWindow expand ].
			aWindow activateAndForceLabelToShow.
			^ aWindow ]].
	"None found, so create one"
	^ makeBlock value.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5065-ReturnFoundWindows-MarianoMontone-2022Feb08-09h25m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5065] on 8 February 2022 at 2:36:26 pm'!
!CodePackageFile methodsFor: 'accessing' stamp: 'HAW 2/8/2022 14:35:17' prior: 16819729 overrides: 16817357!
     description
	^String streamContents: [ :s |
		s nextPutAll: 'Code Package File: '.
		s nextPutAll: self fullName; newLine; newLine.
		s nextPutAll: 'Provides: '.
		self provides printDetailsOn: s.
		s newLine.
		self requires ifNotEmpty: [ :requirements | 
			s nextPutAll: 'Requires: '.
			(requirements sorted: [:a :b | a name < b name]) do: [ :req |
				s newLine; space.
				req printDetailsOn: s ].
			s newLine ].
		s newLine.
		sourceSystem isEmpty ifFalse:[
			s nextPutAll: sourceSystem; newLine; newLine ]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5066-CodePackageFile description-HernanWilkinson-2022Feb08-14h27m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5062] on 9 February 2022 at 11:02:38 am'!
!TheWorldMenu class methodsFor: 'help menu' stamp: 'HAW 2/9/2022 11:00:10'!
                  helpMenuOptions
	
	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#aboutThisSystem.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'current version information.'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Terse Guide to Cuis'.
				#selector 		-> 		#openTerseGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comment Browser'.
				#selector 		-> 		#openCommentGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCodeManagementInCuis.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCuisAndGitHub.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'GitHub usage pattern.'
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 	-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 	-> 		'a window full of useful expressions.'
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'VM Statistics'.
				#selector 		-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 	-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Space Left'.
				#selector 		-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 	-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 2/9/2022 11:00:35' prior: 16970015!
                              helpMenu
	"Build the help menu for the world."

	^ DynamicMenuBuilder buildTitled: 'Help...' targeting: self collectingMenuOptionsWith: #helpMenuOptions.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5067-HelpMenuMadeDynamic-HernanWilkinson-2022Feb09-10h50m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5067] on 21 February 2022 at 12:19:35 pm'!
!Feature class methodsFor: 'convenience' stamp: 'jmv 2/21/2022 12:04:19' prior: 16853099!
                       require: featureNameOrFilename
	"
	Answer whether the request is fulfilled.
	Feature require: 'StyledTextInstaller'
	Feature require: 'Sound'
	Feature require: 'Tests'
	"
	| req ext fileEntry |
	ext _ '.pck.st'.
	((featureNameOrFilename endsWith: ext) and: [
				fileEntry _ featureNameOrFilename asFileEntry.
				fileEntry exists ])
		ifTrue: [
			req _ FeatureRequirement name: (fileEntry name withoutSuffix: ext).
			req pathName: fileEntry pathName.
			]
		ifFalse: [ req _ FeatureRequirement name: featureNameOrFilename ].
	req isAlreadySatisfied ifFalse: [
		req require ].
	^req isAlreadySatisfied! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5068-require-answerSuccess-JuanVuletich-2022Feb21-12h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5067] on 21 February 2022 at 12:25:58 pm'!
!FontFamily class methodsFor: 'file read write' stamp: 'jmv 2/21/2022 12:21:16' prior: 50332701!
               readAdditionalTrueTypeFonts
	(Feature require: 'VectorGraphics') ifTrue: [
		(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
			Feature require: 'VectorEngineInSmalltalk' ].
		UISupervisor whenUIinSafeState: [
			Smalltalk at: #TrueTypeFontFamily ifPresent: [ :cls | cls readAdditionalFonts ]]].! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 2/21/2022 12:22:03' prior: 50332714!
            promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| selectedNameOrDirectory fontFamily |
	selectedNameOrDirectory _ self promptUserFolders.
	selectedNameOrDirectory isNil ifTrue: [ ^nil ].
	(FontFamily familyNamed: selectedNameOrDirectory)
		ifNotNil: [ :it | ^Preferences setDefaultFont: it familyName ].
	(Feature require: 'VectorGraphics') ifTrue: [
		(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
			Feature require: 'VectorEngineInSmalltalk' ].
		UISupervisor whenUIinSafeState: [
			fontFamily _ FontFamily availableFamilies values
				detect: [ :any | any folderName = selectedNameOrDirectory name ]
				ifNone: [
					FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: selectedNameOrDirectory) anyOne ].
			Preferences setDefaultFont: fontFamily familyName ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5069-GracefulVectorGraphicsLoadFailure-JuanVuletich-2022Feb21-12h19m-jmv.001.cs.st----!

----QUIT----(21 February 2022 14:50:27) Cuis6.0-5069.image priorSource: 74!

----STARTUP---- (16 May 2022 10:22:18) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5069.image!


'From Cuis 6.0 [latest update: #5069] on 21 February 2022 at 4:42:24 pm'!
!Morph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:03:26'!
                     layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	Please make them natural numbers.
	See implementors."

	^self valueOfProperty: #layerNumber ifAbsent: [100]! !
!Morph methodsFor: 'testing' stamp: 'jmv 2/21/2022 16:41:36'!
                         honorsLayerOrder
	"Most morphs don't go through the expense of the needed resorting."

	^false! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:33:14'!
privateFixLayerOrder
	"Ensure that morphs with smaller #layerNumber are above morphs with larger #layerNumber."

	| layerNumbers sortedSubmorphs newIndex |
	self honorsLayerOrder ifFalse: [ ^self ].
	submorphs size < 2 ifTrue: [ ^self ].
	layerNumbers _ Set new.
	submorphs do: [ :m | layerNumbers add: m layerNumber ].
	layerNumbers _ layerNumbers asArray sort.
	sortedSubmorphs _ Array new: submorphs size.
	newIndex _ 1.
	layerNumbers do: [ :layerNumber |
		submorphs withIndexDo: [ :m :i |
			m layerNumber = layerNumber ifTrue: [
				sortedSubmorphs at: newIndex put: m.
				newIndex = i ifFalse: [ m invalidateBounds ].
				newIndex _ newIndex + 1 ]]].
	submorphs _ sortedSubmorphs.! !
!PasteUpMorph methodsFor: 'testing' stamp: 'jmv 2/21/2022 16:16:13' overrides: 50336283!
                   honorsLayerOrder

	^true! !
!StringRequestMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:39:20' overrides: 50336274!
   layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30! !
!FillInTheBlankMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:39:13' overrides: 50336274!
                      layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:40:23' overrides: 50336274!
                           layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be on top."

	^10! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:38:31' overrides: 50336274!
              layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:38:39' overrides: 50336274!
                              layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:38' prior: 50332745!
                 privateAddAllMorphs: aCollection atIndex: index
	"Private. Add aCollection of morphs to the receiver"
	| myWorld itsWorld otherSubmorphs |
	myWorld _ self world.
	otherSubmorphs _ submorphs copyWithoutAll: aCollection.
	(index between: 0 and: otherSubmorphs size)
		ifFalse: [^ self error: 'index out of range'].
	index = 0
		ifTrue:[	submorphs _ aCollection asArray, otherSubmorphs]
		ifFalse:[	index = otherSubmorphs size
			ifTrue:[	submorphs _ otherSubmorphs, aCollection]
			ifFalse:[	submorphs _ otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].
	aCollection do: [:m | | itsOwner |
		itsOwner _ m owner.
		itsOwner ifNotNil: [
			itsWorld _ m world.
			(itsWorld == myWorld) ifFalse: [
				itsWorld ifNotNil: [m redrawNeeded]].
			(itsOwner ~~ self) ifTrue: [
				m owner privateRemove: m.
				m owner removedMorph: m ]].
		m privateOwner: self.
		myWorld ifNotNil: [m redrawNeeded].
		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].
		itsOwner == self ifFalse: [
			self addedMorph: m.
			m noteNewOwner: self ].
	].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:42' prior: 50332783!
          privateAddMorph: aMorph atIndex: index position: aPointOrNil

	| oldIndex myWorld itsWorld oldOwner |
	((index >= 1) and: [index <= (submorphs size + 1)])
		ifFalse: [^ self error: 'index out of range'].
	myWorld _ self world.
	oldOwner _ aMorph owner.
	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue: [
		"aMorph's position changes within in the submorph chain"
		oldIndex < index ifTrue:[
			"moving aMorph to back"
			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.
			submorphs at: index-1 put: aMorph.
		] ifFalse:[
			"moving aMorph to front"
			oldIndex-1 to: index by: -1 do:[:i|
				submorphs at: i+1 put: (submorphs at: i)].
			submorphs at: index put: aMorph.
		].
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
	] ifFalse: [
		"adding a new morph"
		oldOwner ifNotNil: [
			itsWorld _ aMorph world.
			itsWorld ifNotNil: [aMorph invalidateBounds].
			oldOwner privateRemove: aMorph.
			oldOwner removedMorph: aMorph.
		].
		aMorph privateOwner: self.
		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].
	].
	myWorld ifNotNil: [
		index = 1
			ifTrue: [aMorph redrawNeeded ]
			ifFalse: [aMorph invalidateBounds]].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged.
	oldOwner == self ifFalse: [
		self addedMorph: aMorph.
		aMorph noteNewOwner: self ]! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:45' prior: 16895395!
                           privateMoveBackMorph: aMorph

	| oldIndex myWorld index |
	myWorld _ self world.
	"aMorph's position changes within in the submorph chain"
	"moving aMorph to front"
	oldIndex _ submorphs indexOf: aMorph.
	"moving aMorph to back"
	index _ submorphs size.
	submorphs replaceFrom: oldIndex to: index-1 with: submorphs startingAt: oldIndex+1.
	submorphs at: index put: aMorph.
	myWorld ifNotNil: [aMorph redrawNeeded].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged.! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:48' prior: 16895413!
         privateMoveFrontMorph: aMorph

	| oldIndex myWorld |
	myWorld _ self world.
	"aMorph's position changes within in the submorph chain"
	"moving aMorph to front"
	oldIndex _ submorphs indexOf: aMorph.
	oldIndex-1 to: 1 by: -1 do: [ :i |
		submorphs at: i+1 put: (submorphs at: i)].
	submorphs at: 1 put: aMorph.
	myWorld ifNotNil: [aMorph redrawNeeded].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged.! !

AutoCompleterMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: AutoCompleterMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

MenuMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: MenuMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ stayUp not!

HoverHelpMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: HoverHelpMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

FillInTheBlankMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: FillInTheBlankMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

StringRequestMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: StringRequestMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

Morph removeSelector: #wantsToBeOnTop:!

!methodRemoval: Morph #wantsToBeOnTop: stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop: aBoolean
	"If true, will be above all siblings who don't."

	self privateFlagAt: 6 put: aBoolean.!

Morph removeSelector: #wantsToBeOnTop!

!methodRemoval: Morph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ self privateFlagAt: 6.!

Morph removeSelector: #privateArrangeWantsToBeOnTop!

!methodRemoval: Morph #privateArrangeWantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
privateArrangeWantsToBeOnTop
	"Ensure that all morphs who #wantsToBeOnTop (i.e. toppers) are above all morphs who not #wantsToBeOnTop.
	Do it without reordering these two subsets.
	Do it in a single pass, and exit as soon as possible."

	| firstMisplacedTopperIndex firstNonTopperIndex topper nonTopper |
	submorphs size < 2 ifTrue: [ ^self ].
	firstMisplacedTopperIndex _ 0.
	firstNonTopperIndex _ 1.
	[
		"Look for next."
		[ (submorphs at: firstNonTopperIndex) wantsToBeOnTop ] whileTrue: [
			firstNonTopperIndex _ firstNonTopperIndex + 1.
			firstNonTopperIndex = submorphs size ifTrue: [
				"All toppers until the end (at most, one non topper as last). Nothing else to do."
				^self ]].
		firstMisplacedTopperIndex _ firstMisplacedTopperIndex max: firstNonTopperIndex+1.
		[ (submorphs at: firstMisplacedTopperIndex) wantsToBeOnTop not ] whileTrue: [
			firstMisplacedTopperIndex _ firstMisplacedTopperIndex + 1.
			firstMisplacedTopperIndex > submorphs size ifTrue: [
				"No more toppers until the end. Nothing else to do."
				^self ]].

		"We have actually found a misplaced topper. Fix it!!"
		nonTopper _ submorphs at: firstNonTopperIndex.
		topper _ submorphs at: firstMisplacedTopperIndex.
		submorphs at: firstNonTopperIndex put: topper invalidateBounds.
		submorphs at: firstMisplacedTopperIndex put: nonTopper invalidateBounds.
	] repeat.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5069] on 21 February 2022 at 2:32:51 pm'!
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:44'!
            largeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences largeFonts
	"

	self defaultFontSize: 18.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:25:01'!
         veryLargeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences veryLargeFonts
	"

	self defaultFontSize: 24.! !
!Preferences class methodsFor: 'fonts' stamp: 'jmv 2/21/2022 14:27:24'!
                  defaultFontSize: pointSize
	"
	Adjust sizes for GUI elements.
	
	Preferences defaultFontSize: 5
	Preferences defaultFontSize: 6
	
	Preferences defaultFontSize: 7
	Preferences defaultFontSize: 9
	Preferences defaultFontSize: 11
	Preferences defaultFontSize: 14
	Preferences defaultFontSize: 18
	Preferences defaultFontSize: 24
	Preferences defaultFontSize: 32
	"
	| font titleFont |
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize..
	self
		setListFontTo: font;
		setMenuFontTo: font;
		setCodeFontTo: font;
		setButtonFontTo: font;
		setSystemFontTo: font.
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	self setWindowTitleFontTo: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	pointSize > 14
		ifTrue: [ Preferences enable: #biggerCursors ]
		ifFalse: [ Preferences disable: #biggerCursors ].
	Cursor defaultCursor activateCursor.
	^font! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:37' prior: 16915575!
                            hugeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences hugeFonts
	"

	self defaultFontSize: 32.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:48' prior: 16915583!
                           smallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences smallFonts
	"
	
	self defaultFontSize: 11.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:52' prior: 16915591!
                  standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	self defaultFontSize: 14.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:57' prior: 16915599!
                   tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	self defaultFontSize: 7.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:25:05' prior: 16915615!
                      verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences verySmallFonts
	"
	
	self defaultFontSize: 9.! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 2/21/2022 13:23:58' prior: 16863485!
                 topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1 max: 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 2/21/2022 13:29:28' prior: 16972017!
                        changeFontSizes

	(MenuMorph new defaultTarget: Preferences)
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		add: 'Huge' action: #hugeFonts;
		add: 'Very Large' action: #veryLargeFonts;
		add: 'Large' action: #largeFonts;
		add: 'Regular Size' action: #standardFonts;
		add: 'Small' action: #smallFonts;
		add: 'Very Small'action: #verySmallFonts;
		add: 'Tiny'action: #tinyFonts;
		popUpInWorld: self runningWorld! !

Preferences class removeSelector: #defaultFont07!

!methodRemoval: Preferences class #defaultFont07 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont07
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont07
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 7)
			(setMenuFontTo: 8)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7)
			(setSystemFontTo: 8)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont08!

!methodRemoval: Preferences class #defaultFont08 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont08
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont08
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 8)
			(setMenuFontTo: 9)
			(setWindowTitleFontTo: 10)
			(setCodeFontTo: 8)
			(setButtonFontTo: 8)
			(setSystemFontTo: 8)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #veryBigFonts!

!methodRemoval: Preferences class #veryBigFonts stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
veryBigFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences veryBigFonts
	"

	self defaultFont36!

Preferences class removeSelector: #defaultFont17!

!methodRemoval: Preferences class #defaultFont17 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont17
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences defaultFont17
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 17)
			(setMenuFontTo: 17)
			(setWindowTitleFontTo: 22)
			(setCodeFontTo: 17)
			(setButtonFontTo: 17)
			(setSystemFontTo: 17)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont22!

!methodRemoval: Preferences class #defaultFont22 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont22
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences defaultFont22
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 22)
			(setMenuFontTo: 22)
			(setWindowTitleFontTo: 28)
			(setCodeFontTo: 22)
			(setButtonFontTo: 22)
			(setSystemFontTo: 22)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont14!

!methodRemoval: Preferences class #defaultFont14 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont14
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont14
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 14)
			(setMenuFontTo: 14)
			(setWindowTitleFontTo: 17)
			(setCodeFontTo: 14)
			(setButtonFontTo: 14)
			(setSystemFontTo: 14)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont46!

!methodRemoval: Preferences class #defaultFont46 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont46
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont46
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 46)
			(setMenuFontTo: 46)
			(setWindowTitleFontTo: 60)
			(setCodeFontTo: 46)
			(setButtonFontTo: 46)
			(setSystemFontTo: 46)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont28!

!methodRemoval: Preferences class #defaultFont28 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont28
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont28
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 28)
			(setMenuFontTo: 28)
			(setWindowTitleFontTo: 36)
			(setCodeFontTo: 28)
			(setButtonFontTo: 28)
			(setSystemFontTo: 28)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont06!

!methodRemoval: Preferences class #defaultFont06 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont06
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont06
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 6)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 8)
			(setCodeFontTo: 6)
			(setButtonFontTo: 6)
			(setSystemFontTo: 7)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont60!

!methodRemoval: Preferences class #defaultFont60 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont60
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont60
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 60)
			(setMenuFontTo: 60)
			(setWindowTitleFontTo: 80)
			(setCodeFontTo: 60)
			(setButtonFontTo: 60)
			(setSystemFontTo: 60)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont11!

!methodRemoval: Preferences class #defaultFont11 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont11
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont11
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 11)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 11)
			(setButtonFontTo: 11)
			(setSystemFontTo: 11)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont12!

!methodRemoval: Preferences class #defaultFont12 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont12
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont12
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 12)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 12)
			(setButtonFontTo: 12)
			(setSystemFontTo: 12)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont10!

!methodRemoval: Preferences class #defaultFont10 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont10
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont10
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 10)
			(setMenuFontTo: 11)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 10)
			(setButtonFontTo: 10)
			(setSystemFontTo: 10)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont05!

!methodRemoval: Preferences class #defaultFont05 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont05
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont05
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 5)
			(setMenuFontTo: 6)
			(setWindowTitleFontTo: 7)
			(setCodeFontTo: 5)
			(setButtonFontTo: 5)
			(setSystemFontTo: 6)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #bigFonts!

!methodRemoval: Preferences class #bigFonts stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
bigFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences bigFonts
	"

	self defaultFont22!

Preferences class removeSelector: #defaultFont80!

!methodRemoval: Preferences class #defaultFont80 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont80
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont80
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 80)
			(setMenuFontTo: 80)
			(setWindowTitleFontTo: 80)
			(setCodeFontTo: 80)
			(setButtonFontTo: 80)
			(setSystemFontTo: 80)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont36!

!methodRemoval: Preferences class #defaultFont36 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont36
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont36
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 36)
			(setMenuFontTo: 36)
			(setWindowTitleFontTo: 46)
			(setCodeFontTo: 36)
			(setButtonFontTo: 36)
			(setSystemFontTo: 36)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont09!

!methodRemoval: Preferences class #defaultFont09 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont09
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont09
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 11)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9)
			(setSystemFontTo: 9)).
	Preferences disable: #biggerCursors.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5071] on 22 February 2022 at 10:02:30 am'!

InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit acceptOn '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #InnerTextMorph category: 'Morphic-Widgets' stamp: 'Install-5072-InnerTextMorph-acceptOn-ivarRename-JuanVuletich-2022Feb22-10h01m-jmv.001.cs.st 5/16/2022 10:22:22'!
InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit acceptOn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870378!
      acceptOnCR
	"Answer whether the receiver wants to accept when the Return key is hit"

	^ acceptOn == true! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870561!
                     processKeystrokeEvent: evt
	| action |

	(acceptOn and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action value]].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action value]].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].! !
!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870660 overrides: 16794195!
initialize
	super initialize.
	wrapFlag _ true.
	acceptOn _ false.
	hasUnacceptedEdits _ false.
	hasEditingConflicts _ false.
	askBeforeDiscardingEdits _ true.
	needsFit _ false.! !
!InnerTextMorph methodsFor: 'accept/cancel' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870947!
             acceptOnCR: trueOrFalse
	acceptOn _ trueOrFalse! !

InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOn hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #InnerTextMorph category: 'Morphic-Widgets' stamp: 'Install-5072-InnerTextMorph-acceptOn-ivarRename-JuanVuletich-2022Feb22-10h01m-jmv.001.cs.st 5/16/2022 10:22:22'!
InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOn hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5072-InnerTextMorph-acceptOn-ivarRename-JuanVuletich-2022Feb22-10h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5071] on 22 February 2022 at 10:06:47 am'!
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 2/22/2022 10:06:21'!
    keystrokeAction: aBlock
	"Sets the action to perform when user presses any key"

	self setProperty: #keyStroke: toValue: aBlock.! !
!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2022 09:44:48'!
              keystrokeAction: aBlock
	
	scroller keystrokeAction: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5073-TextMorph-keystrokeAction-JuanVuletich-2022Feb22-10h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5071] on 22 February 2022 at 10:11:26 am'!
!InnerTextMorph methodsFor: 'accept/cancel' stamp: 'jmv 2/22/2022 10:00:47'!
acceptOnAny: aBoolean
	aBoolean
		ifTrue: [ acceptOn _ #any ]
		ifFalse: [
			acceptOn = #any
				ifTrue: [ acceptOn _ #none ]].! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 2/22/2022 10:07:31' prior: 50337095!
     acceptOnCR
	"Answer whether the receiver wants to accept when the Return key is hit"

	^ acceptOn == #enter! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2022 10:09:51' prior: 50337102!
                   processKeystrokeEvent: evt
	| action |

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action value]].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action value]].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	acceptOn = #any ifTrue: [self acceptContents].! !
!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2022 10:00:57' prior: 50337122 overrides: 16794195!
      initialize
	super initialize.
	wrapFlag _ true.
	acceptOn _ #none.
	hasUnacceptedEdits _ false.
	hasEditingConflicts _ false.
	askBeforeDiscardingEdits _ true.
	needsFit _ false.! !
!InnerTextMorph methodsFor: 'accept/cancel' stamp: 'jmv 2/22/2022 10:08:16' prior: 50337131!
             acceptOnCR: aBoolean
	aBoolean
		ifTrue: [ acceptOn _ #enter ]
		ifFalse: [
			acceptOn = #enter
				ifTrue: [ acceptOn _ #none ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5074-TextMorph-acceptOnAnyKeystroke-JuanVuletich-2022Feb22-10h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5074] on 22 February 2022 at 4:59:29 pm'!
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 2/22/2022 16:57:50' prior: 50336340 overrides: 50336274!
                         layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	stayUp ifTrue: [ ^super layerNumber ].
	^20! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5075-PinnedMenusDontStayAtFront-JuanVuletich-2022Feb22-16h57m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 22 February 2022 at 5:19:27 pm'!
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 2/22/2022 17:18:57' prior: 16870457 overrides: 16892224!
                         mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	"If we don't focus, do nothing. Focus will be got at button up."
	self hasKeyboardFocus ifFalse: [
		^self ].

	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.

	self handleInteraction: [ editor mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 2/22/2022 17:19:14' prior: 16870486 overrides: 16892239!
                     mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	| mouseButton1DownHandled |

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^ aMouseButtonEvent hand newKeyboardFocus: self ].

	self pauseBlinking.

	mouseButton1DownHandled := self 
		valueOfProperty: #mouseButton1Up:localPosition:
		ifPresentDo: [ :handler | handler value: aMouseButtonEvent value: localEventPosition ]
		ifAbsent: [ false ].

	mouseButton1DownHandled ifFalse: [
		self handleInteraction: [ editor mouseButton1Up: aMouseButtonEvent  localPosition: localEventPosition ]].

	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5076-clickToFocus-requireFurtherClickToSetCursor-JuanVuletich-2022Feb22-17h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 22 February 2022 at 5:21:29 pm'!
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 2/22/2022 17:20:38' prior: 50337265 overrides: 16892224!
                mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	"If we don't focus, Get focus, and continue (i.e. position the cursor)"
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.

	self handleInteraction: [ editor mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'events' stamp: 'HAW 11/30/2021 14:54:59' prior: 50337292 overrides: 16892239!
     mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	| mouseButton1DownHandled |

	self pauseBlinking.

	mouseButton1DownHandled := self 
		valueOfProperty: #mouseButton1Up:localPosition:
		ifPresentDo: [ :handler | handler value: aMouseButtonEvent value: localEventPosition ]
		ifAbsent: [ false ].

	mouseButton1DownHandled ifFalse: [
		self handleInteraction: [ editor mouseButton1Up: aMouseButtonEvent  localPosition: localEventPosition ]].

	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5077-clickToFocus-singleClickToFocusAndSetCursor-JuanVuletich-2022Feb22-17h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 23 February 2022 at 9:14:18 am'!
!SmalltalkEditor methodsFor: 'quick action (shift+click)' stamp: 'jmv 2/23/2022 09:03:41' prior: 16941021!
                          quickPrintOfNodeUnder: aMousePosition

	| mousePositionInText |
	
	mousePositionInText := morph positionInTextOf: aMousePosition.

	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor | morph showBalloon: (self hoverHelpToShowEvaluating: aNodeUnderCursor)]
				ifAbsent: [  morph flash  ]]
		ifErrorsParsing: [ :anError | morph showBalloon: anError messageText ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:01:52' prior: 16893953!
                   showBalloon: msgString
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	self showBalloon: msgString hand: nil! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:12:43' prior: 16893963!
                       showBalloon: msgString hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	w _ self world ifNil: [^ self].
	h _ aHand ifNil: [ w activeHand ].
	balloon _ HoverHelpMorph contents: msgString.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: h ].! !

InnerTextMorph removeSelector: #showHoverHelpWith:!

!methodRemoval: InnerTextMorph #showHoverHelpWith: stamp: 'Install-5078-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h01m-jmv.001.cs.st 5/16/2022 10:22:22'!
showHoverHelpWith: msgString 
	
	| w balloon h |
	(w _ self world) ifNil: [^ self].
	h _ w activeHand.
	balloon _ HoverHelpMorph contents: msgString.
	
	"Do it in a while. In some cases, processing the event that might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [ balloon popUpForHand: h ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5078-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 23 February 2022 at 9:52:32 am'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:44:22'!
                      showBalloon: msgString hand: aHand doWordWrap: aBoolean
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	w _ self world ifNil: [^ self].
	h _ aHand ifNil: [ w activeHand ].
	balloon _ HoverHelpMorph contents: msgString doWordWrap: aBoolean.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: h ].! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:48:39'!
             contents: aString doWordWrap: aBoolean
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: true) openInHand
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: false) openInHand
	"

	^self new contents: aString wrappedTo: (aBoolean ifTrue: [FontFamily defaultLineSpacing * 13])! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:52:20' prior: 50337411!
showBalloon: msgString hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	self showBalloon: msgString hand: aHand doWordWrap: false.! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:47:55' prior: 16868413!
            contents: aString
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph') openInHand
	"

	^ self new contents: aString wrappedTo: nil! !

HoverHelpMorph class removeSelector: #contentsWrapped:!

!methodRemoval: HoverHelpMorph class #contentsWrapped: stamp: 'Install-5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st 5/16/2022 10:22:22'!
contentsWrapped: aString
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contentsWrapped: 'This is a HoverHelpMorph with a rather long contents to see how it gets wrapped. Is this long enough? Maybe a few more words are in order.') openInHand
	"

	^self new contentsWrapped: aString!

HoverHelpMorph removeSelector: #contents:!

!methodRemoval: HoverHelpMorph #contents: stamp: 'Install-5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st 5/16/2022 10:22:22'!
contents: aString

	self contents: aString wrappedTo: nil!

HoverHelpMorph removeSelector: #contents:doWordWrap:!

HoverHelpMorph removeSelector: #contentsWrapped:!

!methodRemoval: HoverHelpMorph #contentsWrapped: stamp: 'Install-5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st 5/16/2022 10:22:22'!
contentsWrapped: aString
	
	self contents: aString wrappedTo: FontFamily defaultLineSpacing * 13!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 23 February 2022 at 9:55:28 am'!
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:54:20' prior: 50337500!
                        contents: aString
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.') openInHand
	"

	^ self contents: aString doWordWrap: true! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:55:05' prior: 50337472!
      contents: aString doWordWrap: aBoolean
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: true) openInHand
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: false) openInHand
	"

	^self contents: aString wrappedTo: (aBoolean ifTrue: [FontFamily defaultLineSpacing * 13])! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5080-HoverHelpMorph-contents-doWordWrap-JuanVuletich-2022Feb23-09h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5078] on 23 February 2022 at 10:51:01 am'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 10:00:14' prior: 50337453!
       showBalloon: msgStringOrText hand: aHand doWordWrap: aBoolean
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	w _ self world ifNil: [^ self].
	h _ aHand ifNil: [ w activeHand ].
	balloon _ HoverHelpMorph contents: msgStringOrText doWordWrap: aBoolean.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: h ].! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 2/23/2022 09:59:48' prior: 16868333!
                               contents: aStringOrText wrappedTo: wordWrapWidthOrNil
	"If wordWrapWidthOrNil is nil, don't do wordwrap, and make the morph as wide as needed"

	| width |
	contents _ aStringOrText.
	width _ wordWrapWidthOrNil ifNil: [9999999].
	textComposition _ TextComposition new.
	textComposition
		setModel: (TextModel withText: contents asText);
		extentForComposing: 	width@9999999.
	textComposition composeAll.
	self morphExtent: textComposition usedExtent + 8.! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:58:59' prior: 50337552!
                contents: aStringOrText
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.') openInHand
	"

	^ self contents: aStringOrText doWordWrap: true! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:59:37' prior: 16868421!
                          contents: aStringOrText wrappedTo: wordWrapWidthOrNil
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather long contents to see how it gets wrapped. Is this long enough? Maybe a few more words are in order.'
		wrappedTo: 150) openInHand
	"

	^self new contents: aStringOrText wrappedTo: wordWrapWidthOrNil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5081-HoverHelpMorph-refactor-JuanVuletich-2022Feb23-10h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5078] on 23 February 2022 at 10:52:53 am'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 10:43:04' prior: 50337490!
  showBalloon: msgStringOrText hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| doWordWrap msg |
	doWordWrap _ true.
	msg _ msgStringOrText.
	msgStringOrText last isLineSeparator ifTrue: [
		doWordWrap _ false.
		msg _ msg allButLast ].
	self
		showBalloon: msg
		hand: aHand
		doWordWrap: doWordWrap.! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 10:30:25' prior: 50337563!
 contents: aStringOrText doWordWrap: aBoolean
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: true) openInHand
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' blue doWordWrap: false) openInHand
	"

	| widthOrNil |
	widthOrNil _ aBoolean ifTrue: [FontFamily defaultLineSpacing * (aStringOrText size sqrt * 1.5 max: 13)].
	^self contents: aStringOrText wrappedTo: widthOrNil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5082-HoverHelp-ActivateWordWrapOnRegularTooltips-JuanVuletich-2022Feb23-10h51m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5078] on 23 February 2022 at 10:53:19 am'!
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 2/23/2022 10:14:03' prior: 16821826!
     optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"

	| aList textConstructor |
	textConstructor _ [ :string :backgroundColor | 
		string asText addAttribute: (TextBackgroundColor color: backgroundColor) ].

	aList _ #(
		(10	'browse'			browseMethodFull							'view this method in a browser')
		(11	'senders' 			browseSendersOfMessages							'browse senders of...' 						browseSendersOfMethod)
		(16	'implementors'			browseMessages							'browse implementors of...' 						browseImplementors)
		(12	'versions'			browseVersions							'browse versions')), 

		(Preferences decorateBrowserButtons
			ifTrue: [
				{{13	. 'inheritance'.	 #methodInheritance. 	'Browse Method Inheritance

', (textConstructor value: 'green' value: `Color green muchLighter`),': sends to super
', (textConstructor value: 'tan' value: `Color tan`), ': has override(s)
', (textConstructor value: 'mauve' value: `Color blue muchLighter`), ': both of the above
', (textConstructor value: 'pink' value: `Color red muchLighter`), ': is an override but doesn''t call super
', (textConstructor value: 'pinkish tan' value: `Color r: 0.94 g: 0.823 b: 0.673`), ': has override(s), also is an override but doesn''t call super
'}}]
			ifFalse: [
				{#(13	'inheritance'		 methodInheritance	 'browse method inheritance')}]),

		#(
		(12	'hierarchy'			browseHierarchy							'browse class hierarchy')
		(10	'inst vars'			browseInstVarRefs							'inst var refs...')
		(11	'class vars'			browseClassVarRefs							'class var refs...')
		(10	'show...'			offerWhatToShowMenu							'menu of what to show in lower pane')).

	^ aList! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 2/23/2022 10:35:35' prior: 16807707!
            changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu isForBaseSystem |
	isForBaseSystem _ model changeSet isForBaseSystem.
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove 	icon: #fileOutIcon 	enabled: isForBaseSystem.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep 		icon: #fileOutIcon.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename 					icon: #saveAsIcon 	enabled: isForBaseSystem.
	aMenu add: 'Destroy change set (x)' 			action: #remove 					icon: #warningIcon 	enabled: isForBaseSystem.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble 			icon: #textEditorIcon.
				aMenu add: 'Remove preamble' 	action: #removePreamble 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 	action: #addPreamble 			icon: #listAddIcon ].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript 			icon: #textEditorIcon .
				aMenu add: 'Remove postscript' 	action: #removePostscript 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript 			icon: #listAddIcon ].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	(aMenu add: 'conflicts with other change sets' 	target: self 	action: #browseMethodConflicts 	icon: #emblemImportantIcon)
		setBalloonText: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	(aMenu add: 'trim history' 						action: #trimHistory 				icon: #clockIcon 		enabled: isForBaseSystem)
		setBalloonText: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.
 NOTE: can cause confusion if later filed in over an earlier version of these changes.'.

	(aMenu add: 'view affected class categories' action: #viewAffectedClassCategories icon: #packageIcon)
		setBalloonText: ' Show class categories affected by any contained change'.

	^ aMenu! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 2/23/2022 10:37:07' prior: 16882518!
           add: aString action: aSymbol icon: symbolOrFormOrNil enabled: aBoolean
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."
	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."

	^(self add: aString
		target: defaultTarget
		action: aSymbol
		argumentList: #())
			setIcon: symbolOrFormOrNil;
			isEnabled: aBoolean! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5083-MiscTooltipsTweaks-JuanVuletich-2022Feb23-10h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5083] on 23 February 2022 at 12:48:38 pm'!
!Message methodsFor: 'comparing' stamp: 'eem 11/27/2021 12:27'!
          hasIdenticalContentsAs: aMessage
	"Answer if the argument's selector and arguments are identically equal to those of the receiver.
	 It is assumed that the argument aMessage is, in fact, a message."
       selector ~~ aMessage selector ifTrue:
		[^false].
	1 to: args size do:
		[:i| (args at: i) ~~ (aMessage arguments at: i) ifTrue: [^false]].
	^true! !
!Object methodsFor: 'error handling' stamp: 'eem 11/27/2021 12:55' prior: 16902064 overrides: 16920394!
                    doesNotUnderstand: aMessage 
	 "Handle the fact that there was an attempt to send the given
	  message to the receiver but the receiver does not understand
	  this message (typically sent from the machine when a message
	  is sent to the receiver and no method is defined for that selector).

	 Raise the MessageNotUnderstood signal.  If it is caught, answer
	 the result supplied by the exception handler.  If it is not caught,
	 answer the result of resending the message within a guard for
	 infinite recursion. This allows, for example, the programmer to
	 implement the method and continue."

	"Testing: (3 activeProcess)"

	| exception resumeValue |
	(exception := MessageNotUnderstood new)
		message: aMessage;
		receiver: self.
	resumeValue := exception signal.
	^exception reachedDefaultHandler "i.e. exception was not caught..."
		ifTrue:
			[[aMessage sentTo: self]
				on: MessageNotUnderstood
				do: [:ex|
					(self == ex receiver
					and: [aMessage hasIdenticalContentsAs: ex message]) ifFalse:
						[ex pass].
					self error: 'infinite recursion in doesNotUnderstand:']]
		ifFalse: [resumeValue]! !
!MethodContext methodsFor: 'private' stamp: 'jmv 3/2/2010 17:09' prior: 16888606!
               cannotReturn: result
	closureOrNil ifNotNil: [
		^self cannotReturn: result to: sender].
	Debugger
		openContext: thisContext
		label: 'computation has been terminated'
		contents: nil! !
!Process methodsFor: 'private' stamp: 'jmv 2/23/2022 12:39:44' prior: 16917440!
                    complete: topContext to: aContext 
	"Run topContext on behalf of self on topContext's stack until aContext is popped or an unhandled 
	error is raised. Return self's new top context. Note: topContext must be a stack top context.
	Note: This method is meant to be called primarily by Process>>#terminate."

	| pair top error |
	pair _ topContext runUnwindUntilErrorOrReturnFrom: aContext.
	top _ pair first.
	error _ pair second.
	"If an error was detected jump back to the debugged process and re-signal the error;
	some errors may require a special care - see notes below."
	error ifNotNil: [
		error class == MessageNotUnderstood ifTrue: [error initialize]. "reset reachedDefaultHandler"
		top jump].
	^top

"Note: To prevent an infinite recursion of the MessageNotUnderstood error, reset reachedDefaultHandler before jumping back; this will prevent #doesNotUnderstand: from resending the unknown message."! !

Smalltalk removeClassNamed: #ProceedBlockCannotReturn!

!classRemoval: #ProceedBlockCannotReturn stamp: 'Install-5084-terminateAndFriends-JaromirMatas-EliotMiranda-2022Feb23-12h38m-jmv.001.cs.st 5/16/2022 10:22:23'!
Warning subclass: #ProceedBlockCannotReturn
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions-Kernel'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5084-terminateAndFriends-JaromirMatas-EliotMiranda-2022Feb23-12h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5084] on 23 February 2022 at 1:02:23 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 2/23/2022 12:58:56' prior: 50335722!
         newUIProcessIfNeeded
	"Answer is not nil only if a new process was created."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isSuspended ifTrue: [ oldUIProcess terminate ].
		oldUIProcess isTerminated ifTrue: [
			oldUIProcess 	animatedUI ifNotNil: [ :guiRootObject |
				self spawnNewMorphicProcessFor: guiRootObject.
				^UIProcess ]]].
	^nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5085-CmdPeriod-recoversSuspendedUIProcess-JuanVuletich-2022Feb23-12h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5084] on 23 February 2022 at 1:09:48 pm'!
!Process methodsFor: 'changing process state' stamp: 'jar 2/22/2022 22:22:22' prior: 50333499!
terminate 
	"Stop the process that the receiver represents forever. Unwind to execute pending ensure: and
	 ifCurtailed: blocks before terminating; allow all unwind blocks to run; if they are currently in
	 progress, let them finish. If the process is in the middle of a #critical: section, release it properly."
	
	"If terminating the active process, create a parallel stack and run unwinds from there;
	 if terminating a suspended process, create a parallel stack for the process being terminated
	 and resume the suspended process to complete its termination from the parallel stack. Use
	 a priority higher than the active priority to make the process that invoked the termination
	 wait for its completion."

	"If terminating a suspended process (including runnable or blocked), always suspend the 
	 terminating process first so it doesn't accidentally get woken up. Equally important is the
	 side effect of the suspension. In 2022 a new suspend semantics has been introduced:
	 the revised #suspend backs up a process waiting on a conditional variable to the send that
	 invoked the wait state, while the pre-2022 #suspend simply removed the process from
	 the conditional variable's list it was previously waiting on; figure out if we are terminating
	 the process while waiting in Semaphore>>critical:. In this case, pop the suspendedContext
	 so that we leave the ensure: block inside Semaphore>>critical: without signaling the semaphore.
	 Execute termination wrapped in #valueEnsured to ensure it completes even if the terminator
	 process itself gets terminated before it's finished; see testTerminateInTerminate."

	| context |
	self isActiveProcess ifTrue: [
		context _ thisContext.
		^[context unwindTo: nil. self suspend] asContext jump].

	[	| oldList |
		oldList _ myList.
		self suspend.
		(oldList class == Semaphore and: [
			suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue: [
				suspendedContext _ suspendedContext home	].
		context _ suspendedContext ifNil: [^self].
		suspendedContext _ [context unwindTo: nil. self suspend] asContext.
		self priority: Processor activePriority + 1; resume
	] valueEnsured! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5086-terminate-JaromirMatas-2022Feb23-13h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5086] on 23 February 2022 at 1:15:14 pm'!
!Process class methodsFor: 'documentation' stamp: 'jar 2/3/2022 12:23:58' prior: 50335236!
            terminateExamples
"
This is the contents of the examples posted by Jaromir to exercise his worn on process termination and exceptions.
It was posted to the Cuis mail list at https://lists.cuis.st/mailman/archives/cuis-dev/2021-May/003171.html
(or maybe, it is a later version of edition of it if this comment is not up to date!!)

Thanks Jaromir for this great contribution!!

Workspace new
		contents: Process terminateExamples;
		openLabel: 'Jaromir Matas''s Process - terminate examples Cuis'.
"
^


'"
The following examples illustrate the behavior and semantics of the new #terminate.
"
"
Part 1: terminate a healthy process inside an unwind block
======================================
Show that all pending unwind blocks get executed regardless whether they have already started or not.
"
"
terminate a suspended process:
....................................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess suspend. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

"
terminate a runnable process:
.................................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor yield] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor yield. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

"
terminate a blocked process:
...............................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Semaphore new wait] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Semaphore new wait. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

"
terminate the active process:
................................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess terminate] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess terminate. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"


"
Part 2: terminate a process after encountering an unhandled error inside an unwind block
===========================================================
Show that all unhandled errors inside unwind blocks get caught and all pending unwind blocks get executed as expected.
"
"
Termination happens when you hit Abandon on the Debugger window.
Note: when you hit Proceed the computation will continue normally and will print x1 x2 x3 x4
"
"
one unhandled error scenario:
.................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test.
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"

"
multiple nested unhandled errors:
........................................................
"
[
	[
		[ ] ensure: [
			[self error: #outer_error] ensure: [
				self error: #inner_error.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] fork

"prints x1 x2 x3"

[
	[
		[self error: #outer_error] ensure: [
			[self error: #middle_error] ensure: [
				self error: #inner_error.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] fork
"prints x1 x2 x3"


[self error: #outer_error] ensure: [
    [self error: #middle_error] ensure: [
        [self error: #inner_error] ensure: [
            Transcript show: #x1].
        Transcript show: #x2].
    Transcript show: #x3].
Transcript show: #x4
"prints x1 x2 x3"
"same result when wrapped in fork"


[] ensure: [
[self error: #outer_error] ensure: [
    [self error: #middle_error] ensure: [
        [self error: #inner_error] ensure: [
            Transcript show: #x1].
        Transcript show: #x2].
    Transcript show: #x3].
Transcript show: #x4]
"prints x1 x2 x3 x4"
"same result when wrapped in fork"


"
Part 3: terminate a process after encountering an unhandled error AND a non-local return inside an unwind block
==========================================================================
Show the semantics of non-local returns inside unwind blocks combined with unhandled error during termination.
"
"
Termination happens when you hit Abandon on the Debugger window.
Note: when you hit Proceed the computation will continue normally and will print x1 x2 x3 x4"
"

"
non-local return inside inner-most halfway-thru unwind block:
......................................................................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			^Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test. 
			^Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x3"

"
non-local return inside outer-most halfway-thru unwind block:
......................................................................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			Transcript show: #x1]. 
		^Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test. 
			Transcript show: #x1]. 
		^Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4


"prints x1 x2 x3"

"
one more level...:
............................
"
[
	[
		[ ] ensure: [
			[ ] ensure: [
				self error: #unwind_test. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		^Transcript show: #x3]
] ensure: [
	Transcript show: #x4].
Transcript show: #x5

"prints x1 x2 x3 x4 (even if wrapped in #fork)"

"
non-local return outside halfway-thru unwind blocks:
......................................................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	^Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test. 
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	^Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


"
Part 4: COMPARISON with the behavior when encountering a handled error or a healthy non-local return inside an unwind block
===================================================================================
Show that ONLY pending unwind blocks that have not yet started get executed during an exception or non-local return unwind.
Why? Handled exceptions and non-local returns do not use #terminate and so do not follow the new terminate semantics and use the traditional simpler semantics instead, skipping unwind blocks halfway through their execution (see #resume[:through:] methods).
"

"
one single handled error scenario:
.......................................................
"
[
	[
		[ ] ensure: [
			[self error: #unwind_test] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3]
] on: Error do: [].
Transcript show: #x4

"prints x1 x3 x4 only, skips x2"

[
	[
		[ ] ensure: [
			[] ensure: [
				self error: #unwind_test.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3]
] on: Error do: [].
Transcript show: #x4

"prints x3 x4 only, skips x1 and x2"

"
multiple nested handled errors:
...................................................
"
[
	[
		[ ] ensure: [
			[self error: #unwind_test_outer] ensure: [
				self error: #unwind_test_inner.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3]
] on: Error do: [].
Transcript show: #x4

"prints x3 x4 only, skips x1 and x2"

"
non-local return scenario:
.........................................
"
[
	[ ] ensure: [
		[^Transcript show: #x0] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x0 x1 x3 only, skips x2"


[
	[ ] ensure: [
		[] ensure: [
			^Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x3 only, skips x2"


"
Part 4: Crazies - explore new teminate behavior and semantics under more extreme circumstances:
==================================================================
Show that the system will not crash and execute all pending unwind blocks as expected.
"

"
Unwind after active process termination; run in the UI. CAUTION: save image first!!
All examples following this one can be run in the UI; forking them is for convenience.
"
[ ] ensure: [
	[Processor activeProcess terminate] ensure: [
		Transcript show: #x1]. 
	Transcript show: #x2
	]
"prints x1 x2 and suspends the UI; recover via Alt+."


"
Unwind after active process termination; run forked
"
[
	[ ] ensure: [
		[Processor activeProcess terminate] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2
		]
] forkAt: Processor activePriority + 1
"prints x1 x2"


"
Unwind after double active process termination:
"
| p |
p := [
	[Processor activeProcess terminate] 	ensure: [
		Processor activeProcess terminate. Transcript show: #x1 ]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 true"


"
Unwind after double active process termination (equivalent to previous):
"
| p ap |
p := [
	[ap := Processor activeProcess. ap terminate] 	ensure: [
		ap terminate. Transcript show: #x1]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 true"


"
Unwind after double active process termination inside the same unwind block:
"
| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: #x1. 
		Processor activeProcess terminate. Transcript show: #x2]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 x2 true"


"
Unwind after double active process termination inside nested unwind blocks:
"
| p |
p := [
	[
		[] ensure: [
			[Processor activeProcess terminate] ensure: [
				Processor activeProcess terminate. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 x2 x3 true"


"
Unwind after active process termination combined with non-local return:
"
| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: #x1. 
		true ifTrue: [^Transcript show: #x2]]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume
"prints x1 x2 and raises BlockCannotReturn error as expected"


"
Unwind after triple nested active process termination - run forked:
"
[
	[Processor activeProcess terminate] ensure: [
	    [Processor activeProcess terminate] ensure: [
	        [Processor activeProcess terminate] ensure: [
	            Transcript show: #x1].
	        Transcript show: #x2].
	    Transcript show: #x3].
	Transcript show: #x4
] forkAt: Processor activePriority + 1
"prints x1 x2 x3"


"
Unwind after triple nested active process termination - run in the UI:
"
[Processor activeProcess terminate] ensure: [
    [Processor activeProcess terminate] ensure: [
        [Processor activeProcess terminate] ensure: [
            Transcript show: #x1].
        Transcript show: #x2].
    Transcript show: #x3].
Transcript show: #x4
"prints x1 x2 x3 and suspends the UI; recover via Alt+."


"
Unwind after active process suspension during termination inside nested unwind blocks:
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Processor activeProcess suspend. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
"first terminate gets suspended inside the unwind block as expected"
p terminate.
"second terminate (or resume) then finishes the termination"
Transcript show: p isTerminated printString
"prints x1 x2 x3 true"


"
Unwind multiple nested active process suspension:
"
| p |
p := [
	[Processor activeProcess suspend] ensure: [
	    [Processor activeProcess suspend] ensure: [
	        [Processor activeProcess suspend] ensure: [
	            Transcript show: #x1].
	        Transcript show: #x2].
	    Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
"p stops at the first suspend"
p terminate.
"termiination stops at the second suspend"
p resume.
"after resuming, p stops at the next suspend"
p resume

"prints x1 x2 x3"


"
Part 5: Some additional unsorted examples
============================
Show that the system will not crash and execute all pending unwind blocks as expected.
"

"
Raise a ZeroDivide exception after 1 second.
"
| p |
p := [ [ (Delay forSeconds: 100) wait ] ensure: [ 1 / 0 ] ] newProcess resume.
(Delay forSeconds: 1) wait.
p terminate.


"
BlockCannotReturn error inside nested unwind block during termination:
(this is one of many similar test scenarios in ProcessTerminateUnwindNonLocalReturn class)
"
| p a |
a := Array new: 4 withAll: false.
p := [	[[
			[ ] ensure: [
				[Processor activeProcess suspend] ensure: [
					^a at: 1 put: true].
				a at: 2 put: true]
		] ensure: [
			a at: 3 put: true].
		a at: 4 put: true
	] ensure: [
		Transcript show: a]
] newProcess.
p resume.
Processor yield.
p terminate
"prints #(true false true false)"
"!!!!!! without fork crashes image"

"
Show the examples terminate peacefully after Abandoning the BlockCannotReturn notifications.
CAUTION: Proceeding BlockCannotReturn debugger notifications WILL crash your image !!!!!! 
Save the image first if you want to try.
"

[^2] fork

[[self error: #error] ensure: [^2]] fork

[[[] ensure: [^2]] ensure: [^42]] fork

[[] ensure: [[^2] fork]] fork

"
Guess the result of this test:
"
"Both statements need to be executed separately."
a := [true ifTrue: [^ 1]. 2]
"execute separately"
a value
"What would you say should be the right answer and why??"


"
This example will immediately crash your image !!!!!!
"
"Both statements need to be executed separately."
a := [true ifTrue: [^ 1] yourself]
"execute separately"
[a value] on: BlockCannotReturn do: [:ex | ex resume]


"
Note: The following examples require a fix in #doesNotUnderstand: preventing an infinite recursion of the MNU error.
"

"
Show both ZeroDivide and MessageNotUnderstood errors are raised and all unwind blocks executed after closing the debuggers.
"
[
	[
		[ ] ensure: [ "halfway through completion when suspended"
			[ ] ensure: [ "halfway through completion when suspended"
				Transcript show: (1 / 0) > 0]. "raise ZeroDivide AND MessageNotUnderstood errors"
			Transcript show: #x2]
	] ensure: [ "not started yet when suspended"
		Transcript show: #x3]
] fork
"prints Error: infinite recursion in doesNotUnderstand: x2 x3"


"
Show the following examples deal with MessageNotUnderstood error correctly and do nott crash or freeze the image or cycle through the MessageNotUnderstood error indefinitely. (Note: a fix in #doesNotUnderstand: preventing an infinite recursion of the MNU error needs to be applied.)
Accept gotcha when asked (it represents an unknown method) and Proceed or Abandon as you like...
"
[] ensure: [self gotcha. Transcript show: #done]

[] ensure: [[self gotcha] ensure: [self halt. Transcript show: #done]

[self error: #error] ensure: [self gotcha. Transcript show: #done]

[self error: #error] ensure: [[self gotcha] ensure: [Transcript show: #done]]

[[] ensure: [[self gotcha] ensure: [self halt. Transcript show: #done]]] fork
"This one used to freeze Cuis UI after Halt -> Proceed but recoverable via Alt+.
Latest terminate with the above mentioned #dnu fix executes as expected."


'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5087-terminateExamples-JaromirMatas-2022Feb23-13h14m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5087] on 24 February 2022 at 3:22:30 pm'!
!Morph methodsFor: 'geometry services' stamp: 'jmv 2/24/2022 15:10:48' prior: 16893458!
coversPixel: worldPoint
	"Answer true if pixel worldPoint is covered by us (or a submorph of ours), even if we are not visible a it
	because of some other morph above us also covers it.

	WARNING: Might answer nil when we simply don't know. It is generally advisable to call this method only for
	morphs where the answer is not nil:
		- BoxedMorphs. No sepecial care needed. (Senders in the base Cuis image are of this kind).
		- Morphs drawn by VectorCanvas (i.e. they #requiresVectorCanvas). See notes below.
	
	Note: If your morph #requiresVectorCanvas, and depends on this general implementation, remember to 
	`removeProperty: #bitMask` whenever it becomes invalid due to changes in your morphs. You may consider
	using #ownsPixel: if appropriate, that doesn't require any maintenance and is cheaper (in cpu and memory).
	See #bitMask.

	See #ownsPixel:
	See #includesPixel:"

	self visible ifTrue: [
		"Expensive way for morphs with arbitrary shape in VectorGraphics.
		The base Cuis System doesn't use this.
		Use this in applications if the expense of maintaining #bitMask is worth it."
		self canvas ifNotNil: [ :canvas |
			canvas canDoVectorGraphics ifTrue: [
				^(self bitMask pixelValueAt: worldPoint - self displayFullBounds topLeft) = 1 ]].

		"This is cheap and OK for unrotated Morphs with a rectangular shape.
		In general, the answer is not strictly correct.
		BoxedMorph redefines this method with an equally cheap implementation that can also handle
		rotated morphs (but assuming they are of rectangular shape)."
		self basicDisplayBounds ifNotNil: [ :r |
			(r containsPoint: worldPoint) ifFalse: [ ^false ] ]].

	"If we don't know."
	^ nil.! !
!Morph methodsFor: 'geometry services' stamp: 'jmv 2/24/2022 15:20:12' prior: 16893533!
   includesPixel: worldPoint
	"Answer true if the grabbing from the pixel argument pixel with the mouse should grab us:

	- Answer true if we own the pixel, i.e. we are the last morph drawn at worldPoint.

	- Some implementations (BoxedMorph) may also answer true if we cover but don't own the pixel,
	meaning that some other morph was drawn later, covering us.

	- For other morphs, not BoxedMorph, (i.e. they run this implementation), if VectorGraphics is not active,
	answer true for any point that lies within our bounds. If this is the case, consider using VectorGraphics: In addition to
	many other advantages, this method will always answer a strictly correct answer.

	Therefore, senders need to be aware that the answer is meaningful only when it is known that no other morph
	covers us. A common case is to find the topmost morph at some position. In that case, iterating front to back ensures
	that if any other morph covers us, it is found first.

	Note: This method is redefined by some subclasses. This implementation is only used for morphs drawn by VectorCanvas,
	either because the main canvas is a VectorCanvas, or because it is a HybridCanvas and we answer true to #requiresVectorCanvas.
	(See other implementors)

	Note: Also see #ownsPixel: and #coversPixel:"

	"Check if #ownsPixel:, if possible."
	self canvas ifNotNil: [ :canvas |
		canvas canDoVectorGraphics ifTrue: [
			^ (canvas morphIdAt: worldPoint) = self morphId ]].

	"This is cheap and OK for unrotated Morphs with a rectangular shape.
	In general, the answer is not strictly correct. (There are false positives, for submorphs or sibling morphs covering us).
	BoxedMorph redefines this method with an equally cheap implementation that can also handle
	rotated morphs (but assuming they are of rectangular shape)."
	self visible ifTrue: [
		self basicDisplayBounds ifNotNil: [ :r |
			^r containsPoint: worldPoint ]].

	^ false.! !
!BoxedMorph methodsFor: 'geometry services' stamp: 'jmv 2/24/2022 15:21:55' prior: 16794420 overrides: 50338710!
                       includesPixel: worldPoint
	"Answer true if the grabbing from the pixel argument pixel with the mouse should grab us:
	(See comment and implementation at Morph).
	Note: This implementation also answer true if we cover but don't own the pixel,
	meaning that some other morph was drawn later, covering us.
	Therefore, senders need to be aware that the answer is meaningful only when it is known that no other morph covers us.
	Note: This implementation is only used for morphs with a cheap #coversPixel:.
	(See other implementors)
	Also see #ownsPixel: and #coversPixel:"

	^ self visible and: [self coversPixel: worldPoint].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5088-TweaksToComments-JuanVuletich-2022Feb24-14h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5087] on 25 February 2022 at 11:46:13 am'!
!Morph methodsFor: 'private' stamp: 'jmv 2/25/2022 10:14:37'!
     privateDisplayBounds
	^privateDisplayBounds! !
!Morph methodsFor: 'private' stamp: 'jmv 2/25/2022 10:14:44'!
                   privateDisplayBounds: aRectangle
	privateDisplayBounds _ aRectangle! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:08'!
                   contourClearOnCurrentMorph
	"Remove knowledge of any contour."

	currentMorph setProperty: #contour toValue: nil.
	currentMorph setProperty: #contourY0 toValue: nil.
	currentMorph setProperty: #contourY1 toValue: nil.! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:24:04'!
                             displayBoundsSetOnCurrentMorph
	"At time of last draw on world canvas. nil if unknown.
		(i.e. privateDisplayBounds is not to represent morph bounds in any other context).
	Clipped appropiately if some owner clips currentMorph.
	See also #displayBoundsUpdateOn:"

	currentMorph canvas ifNotNil: [ :c |
		(self isBoundsFinderCanvas or: [c canvasToUse == self canvasToUse]) ifTrue: [
			currentMorph privateDisplayBounds: self canvasToUse boundingRectOfCurrentMorphAfterDraw ]].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:24:29'!
                          displayBoundsUpdateOnCurrentMorph
	"At time of last draw on world canvas. nil if unknown.
	Only to be used for the world canvas
		(i.e. privateDisplayBounds is not to represent morph bounds in any other context).
	Rectangle is clipped appropiately if some owner clips currentMorph.
	To be called after #postDrawOn:. See also #displayBoundsSetOn:
	This more complicated update is needed because the contour information from #drawOn: was lost
	when drawing submorphs. So, the contour from #drawOn: needs to be retrieved, and updated with the
	new contour information from #postDrawOn:"

	currentMorph canvas ifNotNil: [ :c |
		(self isBoundsFinderCanvas or: [c canvasToUse == self canvasToUse]) ifTrue: [
			currentMorph privateDisplayBounds: 
				(currentMorph privateDisplayBounds quickMerge:
					self canvasToUse boundingRectOfCurrentMorphAfterDraw) ]].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:31' prior: 16896141!
               drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBoundsForError.
	w _ r extent > `50@50`
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: `Color red`
		borderWidth: w
		borderColor: `Color yellow`.
	self line: r topLeft+1 to: r bottomRight-w width: w color: `Color yellow`.
	self line: r topRight + (w negated@1) to: r bottomLeft + (1@ w negated) width: w color: `Color yellow`.	
	self displayBoundsSetOnCurrentMorph.
	self contourClearOnCurrentMorph.! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:28' prior: 16896161!
                  drawCurrentAsOutline

	currentMorph visible ifTrue: [
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph.
		self frameReverseGlobalRect: currentMorph displayBounds borderWidth: 2 ].! !
!BitBltBoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:25:11' prior: 16788991!
                fullUpdateCurrentProtrudingBounds
	"Recursively update display bounds, for currentMorph and all submorphs,
	but only for those whose bounds may go outside owner bounds."

	self displayBoundsSetOnCurrentMorph.! !
!BitBltBoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:25:17' prior: 16789037!
           updateCurrentBounds
	"Update display bounds, for currentMorph only."

	self displayBoundsSetOnCurrentMorph.! !
!BitBltCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:23' prior: 16789851 overrides: 16896136!
        drawCurrentAndSubmorphs
	
	currentMorph visible ifTrue: [

		currentMorph drawOn: self.
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph.

		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]].

		(currentMorph postDrawOn: self) ifTrue: [
			self displayBoundsUpdateOnCurrentMorph ].

		currentMorph isHighlighted ifTrue: [
			self drawHighlight: currentMorph ].
	].! !

MorphicCanvas removeSelector: #contourOfCurrentMorphAfterDrawInto:into:!

!methodRemoval: MorphicCanvas #contourOfCurrentMorphAfterDrawInto:into: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
contourOfCurrentMorphAfterDrawInto: anArray into: aBlock
	"We don't compute contours. See other implementors."!

BoxedMorph removeSelector: #displayBoundsUpdateFrom:!

!methodRemoval: BoxedMorph #displayBoundsUpdateFrom: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsUpdateFrom: aCanvas
	"Private for framework use. NOP here. See super implementation.
	See also #knowsOwnLocalBounds and #wantsContour."!

Morph removeSelector: #displayBoundsSetFrom:!

!methodRemoval: Morph #displayBoundsSetFrom: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsSetFrom: aCanvas
	"Private for framework use.
	At time of last draw on world canvas. nil if unknown.
	Only to be used for the world canvas (i.e. this ivar is not to represent our bounds in any other context).
	Clipped appropiately if some owner clips us.
	See also #displayBoundsUpdateFrom:"

	self canvas ifNotNil: [ :c |
		(aCanvas isBoundsFinderCanvas or: [c canvasToUse == aCanvas canvasToUse]) ifTrue: [
			privateDisplayBounds _ aCanvas canvasToUse boundingRectOfCurrentMorphAfterDraw.
			self wantsContour
				ifTrue: [
					 (aCanvas canvasToUse
						contourOfCurrentMorphAfterDrawInto: (self valueOfProperty: #contour) 
						into: [ :contourArray :contourY0 :contourY1 |
							self setProperty: #contour toValue: contourArray.
							self setProperty: #contourY0 toValue: contourY0.
							self setProperty: #contourY1 toValue: contourY1 ])]
				ifFalse: [
					self setProperty: #contour toValue: nil.
					self setProperty: #contourY0 toValue: nil.
					self setProperty: #contourY1 toValue: nil ]]].!

Morph removeSelector: #displayBoundsUpdateFrom:!

!methodRemoval: Morph #displayBoundsUpdateFrom: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsUpdateFrom: aCanvas
	"Private for framework use.
	At time of last draw on world canvas. nil if unknown.
	Only to be used for the world canvas (i.e. this ivar is not to represent our bounds in any other context).
	Rectangle is clipped appropiately if some owner clips us.
	To be called after #postDrawOn:. See also #displayBoundsSetFrom:
	This more complicated update is needed because the contour information from #drawOn: was possibly
	when drawing submorphs. So, the controur from #drawOn: needs to be retrieved, and updated with the
	new contour information from #postDrawOn:"

	self canvas ifNotNil: [ :c |
		(aCanvas isBoundsFinderCanvas or: [c canvasToUse == aCanvas canvasToUse]) ifTrue: [
			privateDisplayBounds _ privateDisplayBounds
				quickMerge: aCanvas canvasToUse boundingRectOfCurrentMorphAfterDraw.
			self wantsContour ifTrue: [
				(aCanvas canvasToUse
					contourOfCurrentMorphAfterDrawUpdate: (self valueOfProperty: #contour)
					oldTop: (self valueOfProperty: #contourY0)
					oldBottom: (self valueOfProperty: #contourY1)
					into: [ :contourArray :contourY0 :contourY1 |
						self setProperty: #contour toValue: contourArray.
						self setProperty: #contourY0 toValue: contourY0.
						self setProperty: #contourY1 toValue: contourY1 ])]]].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5089] on 25 February 2022 at 12:39:21 pm'!
!Morph methodsFor: 'geometry services' stamp: 'jmv 2/25/2022 12:38:57' prior: 16893352!
           collides: aMorph
	"Answer whether the pixels used by morphs touch at least at one place.
	Morphs not in the BoxedMorph hierarchy should answer #true to wantsContour."

	privateDisplayBounds ifNil: [
		^false ].

	"Quick check with display bounds"
	aMorph displayFullBounds
		ifNil: [ ^false ]
		ifNotNil: [ :r |
			(self displayFullBounds intersects: r) ifFalse: [ ^false ]].

	"Precise check with contour, if available"
	(self valueOfProperty: #contour) ifNotNil: [ :contour | | contourTop contourBottom |
		contourTop _ self valueOfProperty: #contourY0.
		contourBottom _ self valueOfProperty: #contourY1.
		^ aMorph contourIntersects: contour top: contourTop bottom: contourBottom ].

	"If contour is not available, and both displayBounds overlap, answer true, as it is the best we can know."
	^ true! !

Morph removeSelector: #displayBoundsIntersects:!

!methodRemoval: Morph #displayBoundsIntersects: stamp: 'Install-5090-Collides-fix-JuanVuletich-2022Feb25-11h56m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsIntersects: aRectangle

	privateDisplayBounds ifNil: [
		^false ].
	^privateDisplayBounds intersects: aRectangle!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5090-Collides-fix-JuanVuletich-2022Feb25-11h56m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5090] on 3 March 2022 at 9:31:30 am'!
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:42' prior: 50336647!
          hugeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences hugeFonts
	"

	self defaultFontSize: 32.
	self setPreference: #guiElementsSize toValue:  #hugeFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:46' prior: 50336595!
largeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences largeFonts
	"

	self defaultFontSize: 18.
	self setPreference: #guiElementsSize toValue:  #largeFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:49' prior: 50336656!
                             smallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences smallFonts
	"
	
	self defaultFontSize: 11.
	self setPreference: #guiElementsSize toValue:  #smallFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:53' prior: 50336665!
                      standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	self defaultFontSize: 14.
	self setPreference: #guiElementsSize toValue:  #standardFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:56' prior: 50336674!
                    tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	self defaultFontSize: 7.
	self setPreference: #guiElementsSize toValue:  #tinyFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:10:00' prior: 50336603!
                           veryLargeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences veryLargeFonts
	"

	self defaultFontSize: 24.
	self setPreference: #guiElementsSize toValue:  #veryLargeFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:10:04' prior: 50336683!
                 verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences verySmallFonts
	"
	
	self defaultFontSize: 9.
	self setPreference: #guiElementsSize toValue:  #verySmallFonts.! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 3/3/2022 09:30:54' prior: 50336719!
                         changeFontSizes

	| options menu currentIndex |
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new defaultTarget: Preferences.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		menu add: pair first action: pair second ].
	currentIndex _ (options size / 2) ceiling.
	(Preferences preferenceAt: #guiElementsSize) ifNotNil: [ :pref |
		options withIndexDo: [ :pair :i |
			pair second = pref preferenceValue ifTrue: [ currentIndex _ i ]]].
	menu selectItem: (menu items at: currentIndex).
	menu popUpInWorld: self runningWorld.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5091-GUIElementSizeEnh-JuanVuletich-2022Mar03-09h09m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5091] on 6 March 2022 at 7:04:57 pm'!
!Morph methodsFor: '*ui-draganddrop' stamp: 'KenD 3/4/2022 12:56:00' prior: 16892094!
         wantsDroppedMorph: aMorph event: evt
	"Return true if the receiver wishes to accept the given morph, 
	 which is being dropped by a hand in response to the given event. 
	Note that for a successful drop operation both parties need to agree. 
	The symmetric check is done automatically via aMorph wantsToBeDroppedInto: self.
	 Individual Morpks may override by setting the corresponding property
	 to an appropriate two argument closure."

	^self valueOfProperty: #wantsDroppedMorph:event:
		 ifPresentDo: [ :wantsMorphEvt | wantsMorphEvt value: aMorph value: evt ]
		 ifAbsent: [ true ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5092-wantsDroppedMorphEvent-KenDickey-2022Mar06-19h04m-KenD.001.cs.st----!

'From Cuis 6.0 [latest update: #5092] on 8 March 2022 at 9:11:26 pm'!
!Morph methodsFor: 'halos and balloon help' stamp: 'HAW 3/8/2022 20:40:29' prior: 50337661!
            showBalloon: msgStringOrText hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| doWordWrap msg |
	doWordWrap _ true.
	msg _ msgStringOrText.
	(msgStringOrText notEmpty and: [ msgStringOrText last isLineSeparator ]) ifTrue: [
		doWordWrap _ false.
		msg _ msg allButLast ].
	self
		showBalloon: msg
		hand: aHand
		doWordWrap: doWordWrap.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5093-EmptyBallonStringEmpty-HernanWilkinson-2022Mar08-20h40m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5093] on 21 March 2022 at 10:46:27 am'!
!StringRequestMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:00:32' overrides: 16880172!
                             categoryInNewMorphMenu

	^ 'User Interface'! !
!PluggableButtonMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:05:05' overrides: 50332354!
                         categoryInNewMorphMenu

	^ 'User Interface'! !
!PluggableButtonMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:06:38' overrides: 16911762!
                         includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"
	
	^ true! !
!PluggableButtonMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:05:26' overrides: 16895515!
                               initializedInstance

	^ self example! !
!TextParagraphMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:15:12' overrides: 50332354!
  categoryInNewMorphMenu

	^ 'User Interface'! !
!FillInTheBlankMorph class methodsFor: 'examples' stamp: 'KenD 3/14/2022 14:51:54'!
                             example1
	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		emptyTextDisplayMessage: 'Enter answer here';
		setQuery: 'Ask Question Here'
		initialAnswer: 'Enter answer here'
		acceptOnCR: true.
	aFillInTheBlankMorph responseUponCancel: 'returnOnCancel'.
	^ aFillInTheBlankMorph.! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:55:00' overrides: 50332354!
    categoryInNewMorphMenu

	^ 'User Interface'! !
!AutoCompleterMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:16:19' overrides: 50332354!
                           categoryInNewMorphMenu

	^ 'User Interface'! !
!ProgressMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:00:20' prior: 16920078 overrides: 16880172!
                categoryInNewMorphMenu

	^ 'User Interface'! !
!UpdatingLabelMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:57:58' prior: 16976219 overrides: 16877771!
           categoryInNewMorphMenu

	^ 'User Interface'! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:34:24' prior: 16857038 overrides: 16895515!
          initializedInstance
	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		emptyTextDisplayMessage: 'Enter answer here';
		setQuery: 'Ask Question Here'
		initialAnswer: 'Enter answer here'
		acceptOnCR: true.
	aFillInTheBlankMorph responseUponCancel: 'returnOnCancel'.
	^ aFillInTheBlankMorph.! !
!HoverHelpMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:56:58' prior: 16868464 overrides: 50332354!
              categoryInNewMorphMenu

	^ 'User Interface'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5094-NewMorphCategory-KenDickey-2022Mar21-10h44m-KenD.001.cs.st----!

'From Cuis 6.0 [latest update: #5069] on 25 March 2022 at 11:37:28 am'!
!TaskbarMorph methodsFor: 'initialization' stamp: 'KLG 3/23/2022 22:49:02' overrides: 16893832!
           balloonText
	"Answer the ballon text .
	
	Done dynamicly; System might change during my lifetime."

	^ 'About this system:' bold, `String newLineString`, Smalltalk systemInformationString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5095-TaskbarMorph-BalloonText-GeraldKlix-2022Mar25-11h36m-KLG.001.cs.st----!

'From Cuis 6.0 [latest update: #5095] on 26 March 2022 at 5:15:50 pm'!
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:12:35'!
         drawTextComposition: aTextComposition at: drawingPosition extent: anExtent color: c selectionColor: sc
	"strict boolean controls whether to avoid or include the last line, if it doesn't fully fit in visibleTextBounds"

	self drawTextComposition: aTextComposition at: drawingPosition extent: anExtent color: c selectionColor: sc avoidOverhang: false! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:12:41'!
                     drawTextComposition: aTextComposition at: drawingPosition extent: anExtent color: c selectionColor: sc avoidOverhang: strict
	"strict boolean controls whether to avoid or include the last line, if it doesn't fully fit in visibleTextBounds"

	| displayScanner leftInRun line possiblyVisible firstLineIndex lastLineIndex |

	possiblyVisible _ currentTransformation boundsOfInverseTransformOf: self clipRect.
	possiblyVisible _ (possiblyVisible translatedBy: drawingPosition negated) intersect: (0@0 extent: anExtent).

	displayScanner _ MorphicScanner new
		defaultFont: aTextComposition defaultFont;
		text: aTextComposition textComposed
		foreground: c.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	firstLineIndex _ aTextComposition lineIndexForPoint: (possiblyVisible topLeft max: `0@0`).
	lastLineIndex _ aTextComposition lineIndexForPoint: (possiblyVisible bottomRight min: anExtent).
	firstLineIndex
		to: lastLineIndex
		do: [ :i |
			line _ aTextComposition lines at: i.
			(strict not or: [ line top + line baseline < possiblyVisible bottom ]) ifTrue: [
				aTextComposition
					displaySelectionInLine: line
					on: self
					textTopLeft: drawingPosition
					selectionColor: sc.
				leftInRun _ displayScanner displayLine: line textTopLeft: drawingPosition leftInRun: leftInRun ]]! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 3/26/2022 17:09:42' prior: 16974349!
                       endEntry
	| c d cb |
	c _ self contents.
	DisplayScreen isDisplayExtentOk ifFalse: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			`0@0` + (0@(d+FontFamily defaultLineSpacing)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		drawTextComposition: textComposition
		at: `4@4` + frame topLeft
		extent: Display extent
		color: `Color black`
		selectionColor: `Color blue`.
	DisplayScreen screenUpdateRequired: nil! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 3/26/2022 17:10:07' prior: 16870315 overrides: 16794207!
                       drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		drawTextComposition: self textComposition
		at: `0@0`
		extent: extent
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus).

	model actualContents isEmpty ifTrue: [
		owner
			valueOfProperty: #emptyTextDisplayMessage
			ifPresentDo: [ :msg |
				aCanvas
					drawString: msg
					at: `0@0`
					font: nil
					color: Theme current textEmptyDisplayMessage ]].! !
!TextParagraphMorph methodsFor: 'drawing' stamp: 'jmv 3/26/2022 17:08:48' prior: 16969487 overrides: 16794207!
       drawOn: aCanvas
	| b |
	b _ self morphLocalBounds insetBy: borderWidth * 2.
	aCanvas
		fillRectangle: self morphLocalBounds color: color.
	aCanvas
		drawTextComposition: textComposition
		at: b topLeft
		extent: b extent
		color: Theme current text
		selectionColor: `Color red`
		avoidOverhang: true.
	aCanvas
		frameRectangle: self morphLocalBounds
		color: borderColor
		borderWidth: borderWidth
		borderStyleSymbol: nil! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 3/26/2022 17:11:33' prior: 16868384 overrides: 16794207!
          drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		drawTextComposition: textComposition
		at: `4@4`
		extent: extent - 8
		color: `Color black`
		selectionColor: (Theme current textHighlightFocused: false).! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:14:13' prior: 16895930!
                    textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc
	"Prefer #drawTextComposition:at:extent:..."

	self drawTextComposition: aTextComposition at: boundsRect topLeft extent: boundsRect extent color: c selectionColor: sc avoidOverhang: false! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:14:36' prior: 16895939!
                     textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc avoidOverhang: strict
	"Prefer #drawTextComposition:at:extent:..."

	self drawTextComposition: aTextComposition at: boundsRect topLeft extent: boundsRect extent color: c selectionColor: sc avoidOverhang: strict! !

MorphicCanvas removeSelector: #textComposition:at:extent:color:selectionColor:!

MorphicCanvas removeSelector: #textComposition:at:extent:color:selectionColor:avoidOverhang:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5096-drawTextComposition-fix-JuanVuletich-2022Mar26-17h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5096] on 7 April 2022 at 2:16:39 pm'!
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 4/7/2022 14:15:05' prior: 16881931!
     contentsWithMarkers: aString inverse: inverse 
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString _ nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	icon _ nil.
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString _ aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`.
	marker lock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5097-MenuItemsWithToogle-fix-JuanVuletich-2022Apr07-14h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5097] on 7 April 2022 at 2:44:30 pm'!

PluggableButtonMorph removeSelector: #model:!

!methodRemoval: PluggableButtonMorph #model: stamp: 'Install-5098-PluggableButtonMorph-Fix-JuanVuletich-2022Apr07-14h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
model: anObject
	"Set my model and make me me a dependent of the given object."

	model ifNotNil: [model removeDependent: self].
	stateSelector ifNotNil: [
		anObject ifNotNil: [anObject addDependent: self]].
	model _ anObject!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5098-PluggableButtonMorph-Fix-JuanVuletich-2022Apr07-14h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5098] on 7 April 2022 at 2:48:54 pm'!
!LabelMorph methodsFor: 'accessing' stamp: 'jmv 4/7/2022 14:48:31'!
                              contentsFromPrintString: anObject

	self contents: anObject printString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5099-LabelMorph-contentsFromPrintString-JuanVuletich-2022Apr07-14h48m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5096] on 4 April 2022 at 5:43:09 pm'!
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/4/2022 17:41:25'!
                       afterCompiling: aSourceCode do: aBlock ifFail: failBlock

	| context provider receiver |
	
	provider := self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver := provider doItReceiver.
			context := provider doItContext]
		ifFalse: [
			receiver := context := nil].

	^self afterCompiling: aSourceCode do: aBlock for: receiver in: context ifFail: failBlock.
	! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/4/2022 17:42:02' prior: 16939419!
    debugIt

	self lineSelectAndEmptyCheck: [^self].
	self 
		afterCompiling: self selectionAsStream upToEnd
		do: [ :compiler :method :receiver :context | method ifNotNil: [ self debug: method receiver: receiver in: context ]]
		ifFail: [].! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/4/2022 17:42:30' prior: 16939459!
                         evaluate: aSourceCode andDo: aBlock ifFail: failBlock profiled: doProfile
	
	| result | 
	
	^ self 
		afterCompiling: aSourceCode 
		do: [ :compiler :method :receiver :context | method ifNotNil: [
			result := compiler evaluateMethod: method to: receiver logged: true profiled: doProfile.
			aBlock value: result ]]
		ifFail: failBlock.! !

SmalltalkEditor removeSelector: #afterCompiling:do:!

!methodRemoval: SmalltalkEditor #afterCompiling:do: stamp: 'Install-5100-FixWalkbackOnRecompileCancel-JuanVuletich-2022Apr04-17h41m-jmv.001.cs.st 5/16/2022 10:22:23'!
afterCompiling: aSourceCode do: aBlock

	| context provider receiver |
	
	provider := self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver := provider doItReceiver.
			context := provider doItContext]
		ifFalse: [
			receiver := context := nil].

	^self afterCompiling: aSourceCode do: aBlock for: receiver in: context ifFail: [ nil ].
	!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5100-FixWalkbackOnRecompileCancel-JuanVuletich-2022Apr04-17h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5101] on 8 April 2022 at 3:51:43 pm'!
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 4/8/2022 15:50:57'!
                          shiftClickShowsImplementors
	^ self
		valueOfFlag: #shiftClickShowsImplementors
		ifAbsent: [ false ].! !
!CodeWindow methodsFor: 'GUI building' stamp: 'KenD 3/22/2022 13:37:53' prior: 16821755!
                             buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."
	
	| codePane |
	
	codePane := self createCodePaneMorph.	
	(Preferences valueOfFlag: #shiftClickShowsImplementors)
		ifTrue: [ self addShiftClickEventHandlerFor: codePane ].
		
	^codePane! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5101-ShiftClickImplementorsPreference-KenDickey-2022Apr08-15h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5101] on 7 April 2022 at 4:24:09 pm'!
!Stream methodsFor: 'printing' stamp: 'jmv 4/7/2022 16:03:27'!
 print: anObject fractionDigits:  placesDesired
	anObject printOn: self fractionDigits:  placesDesired! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/7/2022 16:10:38'!
          formatVMParameter: aNumber
	"Format a VM parameter that may have been reported either as a Float or
	an Integer. If a VM parameter is defined in units of milliseconds but internally
	measured to microsecond precision by the VM, the VM may choose to return
	the value as a Float in order to retain full precision. Otther representations
	such as Fraction may seem more natural but are difficult to instantiate in
	the VM, hence the presumption of Float for representation of higher precision
	millisecond values."

	^ aNumber isFloat
		ifTrue: [ aNumber < 1000
			ifTrue: [ aNumber printStringFractionDigits: 5 ]
			ifFalse: [ aNumber rounded printStringWithCommas ] ]
		ifFalse: [ aNumber asInteger printStringWithCommas ].! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/7/2022 16:22:50'!
                            vmStatisticsReportOn: str
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	| params oldSpaceEnd youngSpaceEnd memorySize fullGCs fullGCTime fullGCCompactionTime incrGCs incrGCTime tenureCount upTime
	  upTime2 fullGCs2 fullGCTime2  incrGCs2 incrGCTime2 tenureCount2 freeSize youngSize used spur timeReporter idleMs idleMs2 codeCompactionTime codeCompactionsOrNil codeCompactionTime2 codeCompactions2 maxParams |
	"Pad to protect for a VM that does not answer the expected parameter array"
	maxParams := 63. "max position referenced in this method"
	params := Array streamContents: [ :strm |
				strm nextPutAll: Smalltalk getVMParameters.
				[strm position < maxParams] whileTrue: [strm nextPut: nil]].
	oldSpaceEnd			:= params at: 1.
	youngSpaceEnd		:= params at: 2.
	memorySize			:= params at: 3.
	fullGCs			:= params at: 7.
	fullGCTime			:= params at: 8.
	incrGCs			:= params at: 9.
	incrGCTime			:= params at: 10.
	tenureCount			:= params at: 11.
	fullGCCompactionTime	:= params at: 18.
	codeCompactionsOrNil	:= params at: 62.
	codeCompactionTime	:= params at: 63.
	
	upTime := (params at: 20) ~= 0 "utcMicrosecondClock at startup in later Spur VMs"
				ifTrue: [Time primUtcMicrosecondClock - (params at: 20) + 500 // 1000]
				ifFalse: [Time primMillisecondClock]. "Fall back on old microsecond clock; Good for 47.5 days"
	spur := (params at: 41)
				ifNotNil: [ :p | p anyMask: 16]
				ifNil: [false].
	timeReporter := [:time| | seconds |
					seconds := time / 1000.
					seconds >= (60*60*24)
						ifTrue:
							[str print: seconds / 60 // 60 // 24; nextPut: $d; space;
								print: seconds / 60 // 60 \\ 24; nextPut: $h; space]
						ifFalse:
							[seconds >= (60*60) ifTrue:
								[str print: (seconds / 60 // 60); nextPut: $h; space]].
					str
						print: (seconds / 60 \\ 60) asInteger; nextPut: $m; space;
						print: (seconds \\ 60) asInteger; nextPut: $s].
	str	nextPutAll: 'uptime		'.
	timeReporter value: upTime.
	(idleMs := params at: 16) ~= 0 ifTrue:
		[str tab; nextPutAll: '(runtime '.
		 idleMs := idleMs // 1000.
		 timeReporter value: upTime - idleMs.
		 str nextPutAll: ', idletime '.
		 timeReporter value: idleMs.
		 str nextPut: $)].
	str newLine.

	str	nextPutAll: 'memory			';
		nextPutAll: (self formatVMParameter: memorySize); nextPutAll: ' bytes'; newLine.
	str	nextPutAll:	'	old		';
		nextPutAll: (self formatVMParameter: oldSpaceEnd); nextPutAll: ' bytes (';
		print: oldSpaceEnd / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	spur ifTrue:
		[(youngSize := (params at: 19)  * 7 // 5) = 0 ifTrue: [params at: 44].
		 youngSize := youngSize roundUpTo: 1024.
		 str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: youngSize); nextPutAll: ' bytes (';
			print: youngSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		youngSize := youngSpaceEnd. "used eden"
		freeSize := (params at: 54) + (params at: 44) - youngSize.
		used := youngSize + oldSpaceEnd - freeSize.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: used); nextPutAll: ' bytes (';
			print: used / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: freeSize); nextPutAll: ' bytes (';
			print: freeSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine]
		ifFalse: "Earlier VM and V3 object memory"
		[str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: (youngSpaceEnd - oldSpaceEnd)); nextPutAll: ' bytes (';
			print: (youngSpaceEnd - oldSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: youngSpaceEnd); nextPutAll: ' bytes (';
			print: (youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: (memorySize - youngSpaceEnd)); nextPutAll: ' bytes (';
			print: (memorySize - youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine].

	str	nextPutAll: 'GCs					';
		nextPutAll: (self formatVMParameter: (fullGCs + incrGCs)).
	fullGCs + incrGCs > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime / (fullGCs + incrGCs) fractionDigits: 1; 
			nextPutAll: ' ms between GCs'.
		 idleMs > 0 ifTrue:
			[str
				space;
				print: upTime - idleMs / (fullGCs + incrGCs) fractionDigits: 1; 
				nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime); nextPutAll: ' ms (';
		print: fullGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime)';
		nextPutAll: ', avg '; print: (fullGCTime / (fullGCs max: 1)) fractionDigits: 1; nextPutAll: ' ms'.
	(spur and: [fullGCCompactionTime ~= 0]) ifTrue:
		[str	newLine; nextPutAll: '		marking			';
			nextPutAll: (self formatVMParameter: (fullGCTime - fullGCCompactionTime)); nextPutAll: ' ms (';
			print: (fullGCTime - fullGCCompactionTime) / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: (fullGCTime - fullGCCompactionTime / (fullGCs max: 1)) fractionDigits: 1;
			nextPutAll: ' ms,'; newLine;
			nextPutAll: '		compacting			';
			nextPutAll: (self formatVMParameter: fullGCCompactionTime); nextPutAll: ' ms (';
			print: fullGCCompactionTime / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: fullGCCompactionTime / (fullGCs max: 1) fractionDigits: 1;
			nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime); nextPutAll: ' ms (';
		print: incrGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime), avg '; print: incrGCTime / incrGCs fractionDigits: 1; nextPutAll: ' ms'; newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount).
	tenureCount = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount // (incrGCs max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs // tenureCount; nextPutAll: ' GCs/tenure)']].
	str	newLine.

	codeCompactionsOrNil ifNotNil:
		[str
			nextPutAll: '	code compactions				'.
		codeCompactionsOrNil = 0
			ifTrue: [str
				nextPutAll: codeCompactionsOrNil asString; newLine]
			ifFalse: [str
				nextPutAll: (self formatVMParameter: codeCompactionsOrNil); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime); nextPutAll: ' ms (';
				print: codeCompactionTime / (upTime - idleMs) * 100 fractionDigits: 3;
				nextPutAll: '% runtime), avg '; print: codeCompactionTime / codeCompactionsOrNil fractionDigits: 1; nextPutAll: ' ms'; newLine]].

LastStats ifNil: [LastStats := Array new: 9]
ifNotNil: [
	LastStats size < 9 ifTrue:
		[LastStats := LastStats, (Array new: 9 - LastStats size withAll: 0)].
	upTime2 := upTime - (LastStats at: 1).
	fullGCs2 := fullGCs - (LastStats at: 2).
	fullGCTime2 := fullGCTime - (LastStats at: 3).
	incrGCs2 := incrGCs - (LastStats at: 4).
	incrGCTime2 := incrGCTime - (LastStats at: 5).
	tenureCount2 := tenureCount - (LastStats at: 6).
	idleMs2 := idleMs - (LastStats at: 7).
	codeCompactionsOrNil ifNotNil:
		[codeCompactions2	:= codeCompactionsOrNil - (LastStats at: 8).
		 codeCompactionTime2	:= codeCompactionTime - (LastStats at: 9)].

	str	nextPutAll: 'GCs since last view					';
		nextPutAll: (self formatVMParameter: (fullGCs2 + incrGCs2)).
	fullGCs2 + incrGCs2 > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime2 // (fullGCs2 + incrGCs2); 
			nextPutAll: ' ms between GCs'.
			idleMs2 > 0 ifTrue:
				[str
					nextPutAll: ', ';
					print: upTime2 - idleMs2 // (fullGCs2 + incrGCs2);
					nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str	newLine.
	str	nextPutAll: '	uptime				'; print: (upTime2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, runtime ';		   print: (upTime2 - idleMs2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, idletime ';		   print: (idleMs2 / 1000.0) fractionDigits: 1; nextPutAll: ' s'; newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs2).
	fullGCs2 + fullGCTime2 > 0 ifTrue:
		[str	nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime2); nextPutAll: ' ms (';
			print: fullGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
			nextPutAll: '% runtime)'.
		 str	nextPutAll: ', avg '; print: fullGCTime2 / (fullGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime2); nextPutAll: ' ms (';
		print: incrGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
		nextPutAll: '% runtime), avg '; print: incrGCTime2 / (incrGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'.
	str	newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount2).
	tenureCount2 = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount2 // (incrGCs2 max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs2 // tenureCount2; nextPutAll: ' GCs/tenure)']].
	str	newLine.
	codeCompactionsOrNil ifNotNil:
		[str	nextPutAll: '	code compactions				';
			nextPutAll: (self formatVMParameter: codeCompactions2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime2); nextPutAll: ' ms (';
			print: codeCompactionTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 3;
			nextPutAll: '% runtime)'.
		 codeCompactions2 > 0 ifTrue:
			[str nextPutAll: ', avg '; print: codeCompactionTime2 / codeCompactions2 fractionDigits: 1; nextPutAll: ' ms'; newLine.]]
].
	LastStats := { upTime. fullGCs. fullGCTime. incrGCs. incrGCTime. tenureCount. idleMs. codeCompactionsOrNil. codeCompactionTime }.! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/7/2022 16:23:20' prior: 16977488!
    vmStatisticsReportString
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	^String streamContents: [:s| self vmStatisticsReportOn: s] estimatedSize: 2048! !

Utilities class removeSelector: #textMarkerForShortReport!

!methodRemoval: Utilities class #textMarkerForShortReport stamp: 'Install-5102-vmStatistics-fromSqueak-JuanVuletich-2022Apr07-15h42m-jmv.001.cs.st 5/16/2022 10:22:23'!
textMarkerForShortReport

	^  'Since last view	'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5102-vmStatistics-fromSqueak-JuanVuletich-2022Apr07-15h42m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5102] on 8 April 2022 at 10:02:13 am'!

PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableButtonMorph category: 'Morphic-Widgets' stamp: 'Install-5103-PluggableButtonMorph-Enhancements-JuanVuletich-2022Apr08-09h51m-jmv.001.cs.st 5/16/2022 10:22:23'!
PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/8/2022 09:53:39'!
             magnifiedIcon: aForm
	"Meaning: Don't magnify aForm to adapt it to our extent."

	icon _ nil.
	magnifiedIcon _ aForm! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/8/2022 09:54:21'!
                          mouseOverColor: aColor
	"If set, ignore #adoptWidgetsColor: for mouse over!!"

	mouseOverColor _ aColor! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 09:55:29'!
  actionArgument: actionArg

	actionArgument _ actionArg.! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/4/2022 14:20:33' overrides: 16794180!
                              defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ nil! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 09:56:23'!
                 model: anObject stateGetter: getStateSel stateArgument: getStateArg action: actionSel actionArgument: actionArg label: aString

	stateSelector _ getStateSel.
	stateArgument _ getStateArg.
	actionSelector _ actionSel.
	actionArgument _ actionArg.
	self model: anObject.
	self label: aString! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/4/2022 14:40:45'!
        stateArgument: getStateArg

	stateArgument _ getStateArg.! !
!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jmv 4/8/2022 09:56:47'!
       model: anObject stateGetter: getStateSel stateArgument: getStateArg action: actionSel actionArgument: actionArg label: aString
	^ self new
		model: anObject
		stateGetter: getStateSel
		stateArgument: getStateArg
		action: actionSel
		actionArgument: actionArg
		label: aString! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/4/2022 15:09:55' prior: 16909952 overrides: 16891474!
                     adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	mouseOverColor ifNil: [
		self color: (Theme current buttonColorFrom: paneColor) ]! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/8/2022 09:59:49' prior: 16910004!
         performAction
	"Inform the model that this button has been pressed. "
	self isEnabled ifFalse: [^ self].
	actionSelector ifNotNil: [
		actionArgument
			ifNil: [ model perform: actionSelector ]
			ifNotNil: [ model perform: actionSelector with: actionArgument ]].! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/4/2022 15:04:03' prior: 16910017!
                         draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver | self isPressed ifTrue: [
		c _ mouseOverColor ifNil: [ c lighter ]].
	c _ self enableColorWith: c.
	aCanvas
		fillRectangle: self morphLocalBounds
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: (borderColor ifNil: [ c ]).

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/4/2022 15:08:49' prior: 16910102!
               drawRoundLookOn: aCanvas
	| r colorForButton rect |
	colorForButton _ self isPressed
		ifFalse: [
			self mouseIsOver
				ifTrue: [	 mouseOverColor ifNil: [ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]]
				ifFalse: [ color ]]
		ifTrue: [ mouseOverColor ifNil: [ color adjustSaturation: 0.1 brightness: -0.1 ]].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		rect _ self morphLocalBounds insetBy: `3@3`.
		r _ r min: (rect width min: rect height) * 0.5.
		aCanvas roundRect: rect color: (self enableColorWith: colorForButton) radius: r ].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ].! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 10:01:16' prior: 16910251 overrides: 16911743!
                initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	enableSelector _ nil.
	stateSelector _ nil.
	stateArgument _ nil.
	actionSelector _ nil.
	actionArgument _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	mouseOverColor _ nil.
	actWhen _ #buttonUp.
	extent _  `20 @ 15`! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 10:01:37' prior: 16910275!
                model: anObject stateGetter: getStateSel action: actionSel label: aString

	stateSelector _ getStateSel.
	stateArgument _ nil.
	actionSelector _ actionSel.
	actionArgument _ nil.
	self model: anObject.
	self label: aString! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 4/8/2022 09:59:44' prior: 16910300!
  getState
	"Answer the result of sending the receiver's model the stateSelector message."

	^ stateSelector 
		ifNil: [false]
		ifNotNil: [
			stateArgument
				ifNil: [	model perform: stateSelector]
				ifNotNil: [	model perform: stateSelector with: stateArgument]].! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 4/4/2022 14:52:00' prior: 16910308!
                      magnifiedIcon
	| factor magnifiedExtent w h |

	magnifiedIcon ifNotNil: [ ^magnifiedIcon ].
	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		w _ icon width.
		h _ icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * extent x / w min: 1.0 * extent y / h.
			factor = 1.0 ifFalse: [
				magnifiedExtent _ (icon extent * factor) rounded.
				magnifiedIcon _ icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 4/4/2022 14:52:16' prior: 16910360 overrides: 16893120!
                             extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	super extentChanged: oldExtent.
	icon ifNotNil: [
		magnifiedIcon _ nil ]! !

PluggableButtonMorph class removeSelector: #model:stateGetter:stateArgument:action:label:!

PluggableButtonMorph removeSelector: #model:stateGetter:stateArgument:action:label:!

PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableButtonMorph category: 'Morphic-Widgets' stamp: 'Install-5103-PluggableButtonMorph-Enhancements-JuanVuletich-2022Apr08-09h51m-jmv.001.cs.st 5/16/2022 10:22:23'!
PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5103-PluggableButtonMorph-Enhancements-JuanVuletich-2022Apr08-09h51m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5103] on 8 April 2022 at 10:33:32 am'!
!MorphicCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:19:20'!
                       privateFrameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	self subclassResponsibility.! !
!MorphicCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:20:16'!
           privateFrameGlobalRect: rect borderWidth: borderWidth color: borderColor
	self subclassResponsibility.! !
!MorphicCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:21:02'!
       privateFrameReverseGlobalRect: r borderWidth: borderWidth
	self subclassResponsibility.! !
!BitBltCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:19:32' overrides: 50340354!
   privateFrameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		privateFrameAndFillGlobalRect: (10@10 extent: 300@200)
		fillColor: Color green
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"
	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth;
		combinationRule: (fillColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: fillColor;
		fillRect: (rect insetBy: borderWidth).
		! !
!BitBltCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:20:24' overrides: 50340361!
     privateFrameGlobalRect: rect borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		privateFrameGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"

	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth.! !
!BitBltCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:21:09' overrides: 50340367!
                        privateFrameReverseGlobalRect: rect borderWidth: borderWidth
	"
	(BitBltCanvas onForm: Display)
		privateFrameReverseGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	engine
		sourceForm: nil;
		fillColor: `Color gray`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !
!HaloMorph methodsFor: 'drawing' stamp: 'jmv 4/8/2022 10:20:48' prior: 16864571 overrides: 16794207!
                drawOn: aCanvas 

	| b |
	target ifNil: [^super drawOn: aCanvas].
	"Debugging aid"
	"aCanvas
		fillRectangle: haloBox
		color: (Color red alpha: 0.2).
	aCanvas
		fillRectangle: self morphLocalBounds
		color: (Color gray alpha: 0.4)."
	target haloShowsCoordinateSystem ifTrue: [
		target displayFullBounds ifNotNil: [ :fb |
			aCanvas privateFrameGlobalRect: fb borderWidth: 3 color: `Color black alpha: 0.1`.
			b _ target displayBounds.
			b = fb ifFalse: [
				aCanvas privateFrameGlobalRect: b borderWidth: 3 color: `Color black alpha: 0.1` ].
			self drawCoordinateSystemOn: aCanvas ]].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 4/8/2022 10:21:25' prior: 50338891!
                         drawCurrentAsOutline

	currentMorph visible ifTrue: [
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph.
		self privateFrameReverseGlobalRect: currentMorph displayBounds borderWidth: 2 ].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 4/8/2022 10:19:50' prior: 16896175!
                     drawHighlight: aMorph

	aMorph displayBounds ifNotNil: [ :r |
		self
			privateFrameAndFillGlobalRect: r
			fillColor: `Color pink alpha: 0.2`
			borderWidth: 4
			color: `Color black` ].! !

BitBltCanvas removeSelector: #frameGlobalRect:borderWidth:color:!

!methodRemoval: BitBltCanvas #frameGlobalRect:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameGlobalRect: rect borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		frameGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"

	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth.!

BitBltCanvas removeSelector: #frameAndFillGlobalRect:fillColor:borderWidth:color:!

!methodRemoval: BitBltCanvas #frameAndFillGlobalRect:fillColor:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		frameAndFillGlobalRect: (10@10 extent: 300@200)
		fillColor: Color green
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"
	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth;
		combinationRule: (fillColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: fillColor;
		fillRect: (rect insetBy: borderWidth).
		!

BitBltCanvas removeSelector: #frameReverseGlobalRect:borderWidth:!

!methodRemoval: BitBltCanvas #frameReverseGlobalRect:borderWidth: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameReverseGlobalRect: rect borderWidth: borderWidth
	"
	(BitBltCanvas onForm: Display)
		frameReverseGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	engine
		sourceForm: nil;
		fillColor: `Color gray`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth!

MorphicCanvas removeSelector: #frameReverseGlobalRect:borderWidth:!

!methodRemoval: MorphicCanvas #frameReverseGlobalRect:borderWidth: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameReverseGlobalRect: r borderWidth: borderWidth
	self subclassResponsibility.!

MorphicCanvas removeSelector: #frameGlobalRect:borderWidth:color:!

!methodRemoval: MorphicCanvas #frameGlobalRect:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameGlobalRect: rect borderWidth: borderWidth color: borderColor
	self subclassResponsibility.!

MorphicCanvas removeSelector: #frameAndFillGlobalRect:fillColor:borderWidth:color:!

!methodRemoval: MorphicCanvas #frameAndFillGlobalRect:fillColor:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	self subclassResponsibility.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5104] on 8 April 2022 at 4:07:29 pm'!
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 4/8/2022 16:05:32'!
                        addSelector: aSymbol

	self protected: [
		Selectors at: aSymbol ifAbsentPut: 0 ].! !
!Preferences class methodsFor: 'initialization' stamp: 'jmv 4/8/2022 16:06:06' prior: 16916067!
          compileAccessMethodForPreference: aPreference
	"Compile an accessor method for the given preference"

	self class compileSilently: (aPreference name, '
	^ self valueOfFlag: #', aPreference name, ' ifAbsent: [', aPreference defaultValue storeString, ']') classified: 'standard queries'.
	SmalltalkCompleter addSelector: aPreference name.! !
!Preferences class methodsFor: 'personalization' stamp: 'jmv 4/8/2022 16:05:45' prior: 16916261!
           compileHardCodedPref: prefName enable: aBoolean
	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"

	self class compileSilently: (prefName asString, '
	"compiled programatically -- return hard-coded preference value"
	^ ', aBoolean storeString) classified: 'hard-coded prefs'.
	SmalltalkCompleter addSelector: prefName.
	
"Preferences compileHardCodedPref: #testing enable: false"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5105-AutoPreferences-AddToSmalltalkCompleter-JuanVuletich-2022Apr08-16h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5105] on 18 April 2022 at 10:52:39 am'!
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 4/18/2022 10:51:25' prior: 16880452!
                     isProportionalHeight
	"Zero actuaqlly means fixed height."

	^ proportionalHeight notNil and: [ proportionalHeight isZero not ].! !
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 4/18/2022 10:50:58' prior: 16880456!
         isProportionalWidth
	"Zero actuaqlly means fixed width."

	^ proportionalWidth notNil and: [ proportionalWidth isZero not ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5106-LayoutWalkbackFix-JuanVuletich-2022Apr18-10h21m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5106] on 18 April 2022 at 11:07:10 am'!
!BoxedMorph methodsFor: 'window like behavior' stamp: 'jmv 4/18/2022 11:06:19'!
       fullScreen
	"Zoom Window to Full World size with possible DeskMargins"

	| left right possibleBounds |
	(self hasProperty: #originalBounds)
		ifFalse: [ "Expand"
			self setProperty: #originalBounds toValue: self displayBounds.
			left := right := 0.
			possibleBounds := (RealEstateAgent maximumUsableAreaInWorld: self world) 
				insetBy: (left @ 0 corner: right @ 0).
			possibleBounds := possibleBounds insetBy: Theme current fullScreenDeskMargin
		] 
		ifTrue: [ "Contract"
			possibleBounds := self valueOfProperty: #originalBounds.
			self removeProperty: #originalBounds.
		].
	self morphPosition: possibleBounds topLeft extent: possibleBounds extent! !
!BoxedMorph methodsFor: 'window like behavior' stamp: 'jmv 4/18/2022 11:05:48'!
                          resize: boundingBox
	(self hasProperty: #originalBounds) ifFalse: [
		self setProperty: #originalBounds toValue: self displayBounds].
	self morphPosition: boundingBox origin extent: boundingBox extent! !

SystemWindow removeSelector: #resize:!

!methodRemoval: SystemWindow #resize: stamp: 'Install-5107-Move-fullScreen-upInHierarchy-JuanVuletich-2022Apr18-11h05m-jmv.001.cs.st 5/16/2022 10:22:23'!
resize: boundingBox
	(self hasProperty: #originalBounds) ifFalse: [
		self setProperty: #originalBounds toValue: self displayBounds].
	self morphPosition: boundingBox origin extent: boundingBox extent!

SystemWindow removeSelector: #fullScreen!

!methodRemoval: SystemWindow #fullScreen stamp: 'Install-5107-Move-fullScreen-upInHierarchy-JuanVuletich-2022Apr18-11h05m-jmv.001.cs.st 5/16/2022 10:22:23'!
fullScreen
	"Zoom Window to Full World size with possible DeskMargins"

	"SystemWindow fullScreen"

	| left right possibleBounds |
	(self hasProperty: #originalBounds)
		ifFalse: [ "Expand"
			self setProperty: #originalBounds toValue: self displayBounds.
			left := right := 0.
			possibleBounds := (RealEstateAgent maximumUsableAreaInWorld: self world) 
				insetBy: (left @ 0 corner: right @ 0).
			possibleBounds := possibleBounds insetBy: Theme current fullScreenDeskMargin
		] 
		ifTrue: [ "Contract"
			possibleBounds := self valueOfProperty: #originalBounds.
			self removeProperty: #originalBounds.
		].
	self morphPosition: possibleBounds topLeft extent: possibleBounds extent!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5107-Move-fullScreen-upInHierarchy-JuanVuletich-2022Apr18-11h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5107] on 21 April 2022 at 2:14:21 pm'!
!Workspace methodsFor: 'variable declarations' stamp: 'jmv 4/21/2022 12:40:46' prior: 16981452!
                          nameForObject: object
	"Answer a name suitable for a Workspace variable"
	^ (object class name, object identityHash printString) asIdentifier: false! !
!ReferencesExplorer methodsFor: 'references' stamp: 'jmv 4/21/2022 12:40:50' prior: 16925300 overrides: 16904267!
                      getList

	| wrapper |
	wrapper _ ReferencesExplorerWrapper
		with: self finder rootNode object
		name: self rootObject identityHash printString
		model: self finder rootNode.
	wrapper finderSkipsClasses: self finder skipClasses.
	^Array with: wrapper! !
!WeightExplorer methodsFor: 'references' stamp: 'jmv 4/21/2022 12:40:54' prior: 16980762 overrides: 50340730!
                    getList

	| wrapper |
	wrapper _ WeightExplorerWrapper
		with: self finder rootNode object
		name: self rootObject identityHash printString
		model: self finder rootNode.
	wrapper finderSkipsClasses: self finder skipClasses.
	^Array with: wrapper! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 4/21/2022 12:40:58' prior: 16800225!
           openMorphicWindowForSuspendedProcess: aProcess
	| menu rule |
	menu _ MenuMorph new.
	"nickname  allow-stop  allow-debug"
	rule _ (ProcessBrowser rulesFor: aProcess) second.
	menu add: 'Dismiss this menu' target: menu action: #delete; addLine.
	menu add: 'Open Process Browser' target: ProcessBrowserWindow action: #openProcessBrowser.
	menu add: 'Resume'
		target: self
		action: #resumeProcess:fromMenu:
		argumentList: { aProcess . menu }.
	menu add: 'Terminate'
		target: self
		action: #terminateProcess:fromMenu:
		argumentList: { aProcess . menu }.
	rule ifTrue: [
		menu add: 'Debug at a lower priority'
			target: self
			action: #debugProcess:fromMenu:
			argumentList: { aProcess . menu }.
	].
	menu addTitle: aProcess identityHash printString,
		' ', aProcess name,
		' is taking too much time and has been suspended.
What do you want to do with it?'.
	menu stayUp.
	menu popUpInWorld
! !
!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 4/21/2022 12:45:28' prior: 16918550!
                               processNameList
	"since processList is a WeakArray, we have to strengthen the result"
	| tally |
	tally _ CPUWatcher current ifNotNil: [ :pw | pw tally ].
	^ (processList asOrderedCollection
		copyWithout: nil)
		collect: [:each | | percent |
			percent _ tally
				ifNotNil: [
					(((tally occurrencesOf: each) * 100.0 / tally size) rounded
						printString padded: #left to: 2 with: $ ), '% '  ]
				ifNil: [ '' ].
			percent, (each browserPrintStringFull: false)
		]! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 11:33:12' prior: 16836998!
         printHMSOn: aStream separator: aChar
	"Print just hh:mm:ss"
	aStream
		nextPutAll: (self hour printString padded: #left to: 2 with: $0);
		nextPut: aChar;
		nextPutAll: (self minute printString padded: #left to: 2 with: $0);
		nextPut: aChar;
		nextPutAll: (self second printString padded: #left to: 2 with: $0).
! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:14' prior: 16837021!
       printOn: aStream withLeadingSpace: printLeadingSpaceToo includeOffset: aBoolean
	"Print as per ISO 8601 section 5.4.2
	If printLeadingSpaceToo is false, prints either:
		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	If printLeadingSpaceToo is true, prints either:
		' YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	"

	self printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo.
	aStream nextPut: $T.
	self printHMSOn: aStream.
	self nanoSecond ~= 0 ifTrue:
		[ | z ps |
		ps := self nanoSecond printString padded: #left to: 9 with: $0.
		z := ps findLast: [ :c | c numericValue > $0 numericValue ].
		(z > 0) ifTrue: [aStream nextPut: $.].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].
	aBoolean ifTrue: [
		aStream
			nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);
			nextPutAll: (offset hours abs printString padded: #left to: 2 with: $0);
			nextPut: $:;
			nextPutAll: (offset minutes abs printString padded: #left to: 2 with: $0).
		"Note: We should check the ISO to see if the seconds part is supported by the standard
		(usually not an issue. offsets usually don't include seconds)"
		offset seconds = 0 ifFalse: [
			aStream
				nextPut: $:;
				nextPutAll: (offset seconds abs truncated printString) ]]! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:20' prior: 16837087!
               printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo
	"Print just the year, month, and day on aStream.

	If printLeadingSpaceToo is true, then print as:
		' YYYY-MM-DD' (if the year is positive) or '-YYYY-MM-DD' (if the year is negative)
	otherwise print as:
		'YYYY-MM-DD' or '-YYYY-MM-DD' "

	| year month day |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ]
		ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ]].
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPut: $-;
		nextPutAll: (month printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (day printString padded: #left to: 2 with: $0)
! !
!DateAndTime methodsFor: 'public protocol' stamp: 'jmv 4/21/2022 12:17:00' prior: 16837249!
    filenamishPrintOn: aStream
	"
	String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]
	"
	
	| year month day monthName |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ].
	monthName _ Month nameOfMonth: month.
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPutAll: (monthName copyFrom: 1 to: 3);
		nextPutAll: (day printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (self hour printString padded: #left to: 2 with: $0);
		nextPut: $h;
		nextPutAll: (self minute printString padded: #left to: 2 with: $0);
		nextPut: $m! !
!Date methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:44:30' prior: 16836364!
                      printOn: aStream format: formatArray 
	"Print a description of the receiver on aStream using the format 
	denoted the argument, formatArray: 
	
		#(item item item sep monthfmt yearfmt twoDigits) 
	
		items: 1=day 2=month 3=year will appear in the order given, 
	
		separated by sep which is eaither an ascii code or character. 
	
		monthFmt: 1=09 2=Sep 3=September 
	
		yearFmt: 1=1996 2=96 
	
		digits: (missing or)1=9 2=09. 
	
	See the examples in printOn: and mmddyy"
	| gregorian twoDigits element monthFormat |
	gregorian _ self dayMonthYearDo: [ :d :m :y | {d. m. y} ].
	twoDigits _ formatArray size > 6 and: [(formatArray at: 7) > 1].
	1 to: 3 do: 
		[ :i | 
			element := formatArray at: i.
			element = 1
				ifTrue: [twoDigits
						ifTrue: [aStream
								nextPutAll: (gregorian first printString
										padded: #left
										to: 2
										with: $0)]
						ifFalse: [gregorian first printOn: aStream]].
			element = 2
				ifTrue: [monthFormat := formatArray at: 5.
					monthFormat = 1
						ifTrue: [twoDigits
								ifTrue: [aStream
										nextPutAll: (gregorian middle printString
												padded: #left
												to: 2
												with: $0)]
								ifFalse: [gregorian middle printOn: aStream]].
					monthFormat = 2
						ifTrue: [aStream
								nextPutAll: ((Month nameOfMonth: gregorian middle)
										copyFrom: 1
										to: 3)].
					monthFormat = 3
						ifTrue: [aStream
								nextPutAll: (Month nameOfMonth: gregorian middle)]].
			element = 3
				ifTrue: [(formatArray at: 6)
							= 1
						ifTrue: [gregorian last printOn: aStream]
						ifFalse: [aStream
								nextPutAll: ((gregorian last \\ 100) printString
										padded: #left
										to: 2
										with: $0)]].
			i < 3
				ifTrue: [(formatArray at: 4)
							~= 0
						ifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]
! !
!Semaphore methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:23:17' prior: 16933187 overrides: 16823635!
                           printOn: aStream
	super printOn: aStream.
	aStream
		nextPutAll: ' with ';
		nextPutAll: excessSignals printString;
		space;
		nextPutAll: ('signal' pluralize: excessSignals ~= 1)! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/21/2022 12:38:28' prior: 16896796!
                 displayBulletTextLeft: texLeft number: bulletNumber
	"texLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber printString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ (Character numericValue: 96 + bulletNumber) asString ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ (Character numericValue: 64 + bulletNumber) asString ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + texLeft + ((font widthOf: $9) * prefix)@destY.
	canvas
		drawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 4/21/2022 12:46:41' prior: 16820393!
             deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet existingOrNewChangeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash printString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/21/2022 12:38:35' prior: 16806699!
  baseSystemNameFor: aChangeSetNumber

	^String streamContents: [ :strm |
	strm
		nextPutAll: (aChangeSetNumber printString padded: #left to: 4 with: $0);
		nextPutAll: '-CuisCore-';
"		nextPutAll: Utilities authorName asCamelCase;"
		nextPutAll: 'AuthorName';
"		nextPutAll: '-';
		nextPutAll: Utilities authorInitials asCamelCase;"
		nextPutAll: '-' ]! !
!SpaceTallyItem methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:48:02' prior: 16944083 overrides: 16902975!
                 printOn: aStream

	analyzedClassName
		ifNotNil: [ aStream nextPutAll: analyzedClassName asString]. 
	aStream nextPutAll: ' ('.
	codeSize
		ifNotNil: [ aStream nextPutAll: 'code size: ' ;  nextPutAll: codeSize printString]. 
	instanceCount
		ifNotNil: [ aStream nextPutAll: ' instance count: ' ;  nextPutAll: instanceCount printString]. 
	spaceForInstances
		ifNotNil: [ aStream nextPutAll: ' space for instances: ' ;  nextPutAll: spaceForInstances printString]. 
	aStream nextPut: $).
	! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 4/21/2022 12:42:11' prior: 16929082!
   scanPast: rangeType level: level
	"first level adds no suffix to the rangeType.
	Suffix from 1 to 7 added in cycles , ((level-2) mod(7) + 1)"
	| cycle typePlusCycle |
	
	cycle := level <= 1 
		ifTrue: [0]
		ifFalse:[ ((level - 2) \\ 7) + 1].
	typePlusCycle := cycle = 0 
		ifTrue:[rangeType]
		ifFalse:[(rangeType, cycle printString) asSymbol].
	^self scanPast: typePlusCycle
! !
!ExtractMethodApplier methodsFor: 'private - parameterizing' stamp: 'jmv 4/21/2022 12:42:59' prior: 16851319!
                      buildInitialSelectorAnswer: parseNodesToParameterize
	"builds a selector with the shape of #m1 if unary, or #m1: something m2: else if it has args"

	^ parseNodesToParameterize
		ifEmpty: [ self formatAsKeyword: 'm1' ]
		ifNotEmpty: [ parseNodesToParameterize
			inject: ''
			into: [ :partialSelector :parseNode |
				| currentKeyword |
				currentKeyword _ 'm' , (parseNodesToParameterize indexOf: parseNode) printString , ': '.
				partialSelector
				, (self formatAsKeyword: currentKeyword)
				, (self formatAsMethodArgument: parseNode name)
				, String newLineString ] ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5108-Number-printString-not-asString-JuanVuletich-2022Apr21-14h13m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5107] on 21 April 2022 at 2:27:53 pm'!
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:39' prior: 16837512 overrides: 16903961!
              readFrom: aStream

	| offset date time ch |

	date _ Date readFrom: aStream.
	[aStream peek isDigit]
		whileFalse: [aStream next].
	time _ Time readFrom: aStream.
	aStream atEnd
		ifTrue: [ offset _ self localOffset ]
		ifFalse: [
			ch _ aStream next.
			ch = $+ ifTrue: [ch _ Character space].
			offset _ Duration fromString: (String with: ch), '0:', aStream upToEnd, ':0'].
		
	^ self
		year: date yearNumber
		month: date monthIndex
		day: date dayOfMonth
		hour: time hour
		minute: time minute
		second: time second
		nanoSecond: time nanoSecond
		offset: offset


	"
		DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.02+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.003+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0004+01:01' readStream
  		DateAndTime readFrom: ' 2002-05-16T17:20:45.00005' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000006+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000007+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.00000008-01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000000009+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000000001+01:01' readStream

 		DateAndTime readFrom: ' 2002-05-16T17:20' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45+01:57' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45-02:34' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45+00:00' readStream
		DateAndTime readFrom: ' 1997-04-26T01:02:03+01:02:3' readStream
 	"! !
!Character methodsFor: 'converting' stamp: 'jmv 4/21/2022 12:18:12' prior: 16808326!
         asText
	^ (String with: self) asText! !
!EventSensor methodsFor: 'test' stamp: 'jmv 4/21/2022 12:19:09' prior: 16849504!
       printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp unicodeCodePoint |
	type _ evtBuf first.
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode _ evtBuf third.
			unicodeCodePoint _ evtBuf sixth.
			pressType _ evtBuf fourth.
			modifiers _ evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type _ #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type _ #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type _ #keystroke].
			Transcript
				newLine;
				show: type;
				show: ' macRomanCode:', macRomanCode printString, '-', 
					(Character numericValue: (Character macRomanToLatin1: macRomanCode)) asString, '-';
				show: ' unicodeCodePoint:', unicodeCodePoint printString.
			(Character iso8859s15CodeForUnicodeCodePoint: unicodeCodePoint) ifNotNil: [ :latin15 |
				Transcript show: '-', (String with: (Character numericValue: latin15)), '-' ].
			Transcript
				show: ' modifiers:', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript show: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript show: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript show: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript show: ' [shift]' ].
			].! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 12:19:48' prior: 16948165!
                               asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in out char rest did inString |

	"Hack in some minimal workaround for Unicode stuff"
	inString _ self copyReplaceAll: '‚Äô' with: (String with: $').
	"Check if we can handle this in #safeValue: in some way..."
	inString = self ifFalse: [ self halt ].
	
	in _ ReadStream on: inString.
	out _ WriteStream on: (String new: self size).
	[ in atEnd ] whileFalse: [
		in peek = $<
			ifTrue: [in unCommand] 	"Absorb <...><...>"
			ifFalse: [(char _ in next) = $&
						ifTrue: [rest _ in upTo: $;.
								did _ out position.
								rest = 'lt' ifTrue: [out nextPut: $<].
								rest = 'gt' ifTrue: [out nextPut: $>].
								rest = 'amp' ifTrue: [out nextPut: $&].
								rest = 'deg' ifTrue: [out nextPut: $°].
								rest = 'quot' ifTrue: [out nextPut: $"].
								rest first = $# ifTrue: [ out nextPut: (Character numericValue: rest findPositiveInteger) ].
								did = out position ifTrue: [
									out nextPut: $&; nextPutAll: rest.
									"self error: 'unknown encoded HTML char'."
									"Please add it to this method"]]
						ifFalse: [out nextPut: char]].
		].
	^ out contents! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 12:20:42' prior: 16948630!
                     surroundedBySingleQuotes
	"Answer the receiver with leading and trailing quotes.  "

	^ `(String with: $')`, self, `(String with: $')`! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 12:22:42' prior: 16951087!
                       internCharacter: aCharacter

	OneCharacterSymbols ifNil: [^self intern: (String with: aCharacter)].

	^OneCharacterSymbols at: aCharacter numericValue + 1
! !
!Text methodsFor: 'converting' stamp: 'jmv 4/21/2022 13:32:02' prior: 16963797!
                 withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ String crlfString detect: [ :char | (char = Character newLineCharacter) not ].
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: String crlfString with: String newLineString asTokens: false.
	(newText asString includes: wrongLineEnd) ifFalse: [ ^newText ].
	^newText copyReplaceAll: (String with: wrongLineEnd) with: String newLineString asTokens: false.! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 4/21/2022 14:10:29' prior: 16945482 overrides: 16945776!
    nextPut: aCharacter
	"Write the given character or byte to this file.
		 StdIOWriteStream stdout nextPut: $a; flush.
	"
	self nextPutAll: (String with: aCharacter).
	^aCharacter! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/21/2022 11:50:00' prior: 16846081!
              normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	self addString: (String with: aKeyboardEvent keyCharacter).
	^false! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/21/2022 12:11:06' prior: 50333069!
                         printIt
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."
	| rpt |
	self
		evaluateSelectionAndDo: [ :result |
			rpt _ model fullPrintIt
				ifTrue: [result printText]
				ifFalse: [result printTextLimitedTo: 10000].
			rpt _ rpt copyReplaceAll: String lfString with: String lfString, ' '.
			self afterSelectionInsertAndSelect: 
				((' ', rpt, ' ') initialFontFrom: emphasisHere)]
		ifFail: [ morph flash ]
		profiled: false.! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/21/2022 11:50:34' prior: 16940901 overrides: 50341338!
   normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| stopIndex startIndex string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string _ self privateCurrentString.
	stopIndex _ self pointIndex - 1.
	(stopIndex between: 2 and: string size)
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	startIndex _ stopIndex.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	[startIndex > 0 and: [stopIndex - startIndex < 7 and: [(string at: startIndex) isLetter]]] whileTrue: [startIndex _ startIndex - 1].
	(startIndex > 0 and: [(string at: startIndex) = $\])
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	key _ string copyFrom: startIndex+1 to: stopIndex.
	(Character namedCharactersTable detect: [:one| key = one first] ifNone: [])
		ifNotNil: [:aPair| self selectFrom: startIndex to: stopIndex; replaceSelectionWith: (String with: aPair second)].
	^ super normalCharacter: aKeyboardEvent! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/21/2022 12:30:58' prior: 50340983!
displayBulletTextLeft: texLeft number: bulletNumber
	"texLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber printString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ String with: (Character numericValue: 96 + bulletNumber) ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ String with: (Character numericValue: 64 + bulletNumber) ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + texLeft + ((font widthOf: $9) * prefix)@destY.
	canvas
		drawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 4/21/2022 11:36:42' prior: 16928939!
                  scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := String with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].
	(c == $: and: [d == $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (String with: d).
			self nextChar.
			^currentToken].
	(c == $| and: [d == $|])
		ifTrue: ["|| empty temp declaration"
			^currentToken].
	c _ d.
	[
		d _ self peekChar.
		c == $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken _ currentToken copyWith: c.
			c _ self nextChar ].
	^currentToken! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5109-String-with-character-not-character-asString-JuanVuletich-2022Apr21-14h14m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5109] on 22 April 2022 at 11:59:26 am'!
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:43:33'!
                     asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!Symbol methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:43:54' overrides: 50341481!
                        asPlainString
	"Answer a plain String, not a Symbol."
	| newString |
	newString _ String new: self size.
	1 to: self size do: [:index | newString at: index put: (self at: index)].
	^newString! !
!Text methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:44:03'!
                             asPlainString
	"Answer a plain String, not a Text."
	^string! !
!Object methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:12:08' prior: 16901498!
               addInstanceVarNamed: aName withValue: aValue
	"Add an instance variable named aName and give it value aValue"
	self class addInstVarName: aName asPlainString.
	self instVarAt: self class instSize put: aValue! !
!Object methodsFor: 'error handling' stamp: 'jmv 4/21/2022 12:12:44' prior: 16902188!
                       primitiveFailed: selector
	"Announce that a primitive has failed and there is no appropriate 
	Smalltalk code to run."

	self error: selector asPlainString, ' failed'! !
!Object methodsFor: 'system primitives' stamp: 'jmv 4/21/2022 12:12:17' prior: 16903149!
                             className
	"Answer a string characterizing the receiver's class, for use in list views for example"

	^ self class name asPlainString! !
!Object methodsFor: 'system primitives' stamp: 'jmv 4/21/2022 12:12:34' prior: 16903240!
                              instVarNamed: aString
	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "

	^ self instVarAt: (self class allInstVarNames indexOf: aString asPlainString)


! !
!Object methodsFor: 'system primitives' stamp: 'jmv 4/21/2022 12:12:38' prior: 16903249!
                   instVarNamed: aString put: aValue
	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "

	^ self instVarAt: (self class allInstVarNames indexOf: aString asPlainString) put: aValue
! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'jmv 4/21/2022 12:12:51' prior: 16968959!
                      saveOn: stream as: format
	"Saves the model to the given stream"
	stream binary.
	stream nextPutAll: self actualContents asPlainString.! !
!Workspace methodsFor: 'shout styling' stamp: 'jmv 4/21/2022 11:48:30' prior: 16981489!
                             toggleStyling

	shouldStyle _ self shouldStyle not.
	actualContents _ actualContents asPlainString asText.
	self changed: #actualContents! !
!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 4/21/2022 12:13:05' prior: 16821535!
                    copySelector
	"Copy the selected selector to the clipboard"

	| selector |
	(selector _ self selectedMessageName) ifNotNil: [
		Clipboard storeObject: selector asPlainString]! !
!Browser methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:55:18' prior: 16795049!
                            contents: input notifying: aRequestor
	"The retrieved information has changed and its source must now be
	 updated. The information can be a variety of things, depending on
	 the list selections (such as templates for class or message definition,
	 methods) or the user menu commands (such as definition, comment).
	Answer the result of updating the source."

	| aString aText theClass |
	aString _ input asPlainString.
	aText _ input asText.
	editSelection == #editSystemCategories ifTrue: [ ^ self changeSystemCategories: aString ].
	self isEditingClass ifTrue: [
		[
			self defineClass: aString notifying: aRequestor 
		] on: RecompilationFailure do: [ :ex |
			self inform: ex messageText.
			^ false].
		^ true].
	editSelection == #editComment
		ifTrue: [
			theClass _ self selectedClass.
			theClass
				ifNil: [
					self inform: 'You must select a class
before giving it a comment.'.
					^ false].
			theClass comment: aText stamp: Utilities changeStamp.
			self changed: #classCommentText.
			^ true].
	editSelection == #editMessageCategories ifTrue: [ ^ self changeMessageCategories: aString ].
	editSelection == #editMessage | (editSelection == #newMessage)
		ifTrue: [
			^ self okayToAccept
				ifFalse:[ false ]
				ifTrue: [
					(self compileMessage: aText notifying: aRequestor)
						ifTrue: [ self triggerEvent: #annotationChanged ];
						yourself ]].
	editSelection == #none
		ifTrue: [
			self inform: 'This text cannot be accepted
in this part of the browser.'.
			^ false].
	self error: 'unacceptable accept'! !
!Browser methodsFor: 'class comment pane' stamp: 'jmv 4/21/2022 11:51:10' prior: 16795169!
  newClassComment: aText
	"The user has just entered aText.
	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."
	| theClass |
	theClass _ self selectedClassOrMetaClass theNonMetaClass.
	theClass ifNotNil: [
		theClass classComment: aText asPlainString ].
	self changed: #classCommentText.
	^ true! !
!Browser methodsFor: 'class functions' stamp: 'jmv 4/21/2022 12:13:11' prior: 50334105!
              defineClass: defString notifying: aRequestor  
	"The receiver's textual content is a request to define a new class. The
	source code is defString. If any errors occur in compilation, notify
	aRequestor."
	| oldClass class newClassName defTokens keywdIx |
	oldClass _ self selectedClassOrMetaClass.
	defTokens _ defString findTokens: Character separators.
	keywdIx _ defTokens findFirst: [ :x | x beginsWith: 'category' ].
	keywdIx _ defTokens findFirst: [ :x | '*subclass*' match: x ].
	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.
	((oldClass isNil or: [ oldClass theNonMetaClass name asPlainString ~= newClassName ])
		and: [ Smalltalk includesKey: newClassName asSymbol ]) ifTrue: [
			"Attempting to define new class over existing one when
				not looking at the original one in this browser..."
			(self confirm: (newClassName bold , ' is an existing class in this system.
Redefining it might cause serious problems.
Is this really what you want to do?'))
				ifFalse: [ ^ false ]].
	"ar 8/29/1999: Use oldClass superclass for defining oldClass
	since oldClass superclass knows the definerClass of oldClass."
	oldClass ifNotNil: [ oldClass _ oldClass superclass ].
	class _ Compiler
				evaluate: defString
				notifying: aRequestor
				logged: true.
	(class isKindOf: Behavior)
		ifTrue: [
				self changed: #systemCategoryRoots.
				self changed: #classList.
				self changed: #clearUserEdits.
				self setClass: class selector: nil.
				"self clearUserEditFlag; editClass."
				^ true ]
		ifFalse: [ ^ false ]! !
!MessageNames methodsFor: 'search' stamp: 'jmv 4/21/2022 12:13:33' prior: 16883920!
        searchString: aString
	"Take what the user typed and find all selectors containing it"

	searchString _ aString asPlainString.
	self changed: #relabel.
	selectorList _ nil.
	self changed: #selectorList.
	self changed: #messageList.
	^ true! !
!ProtocolBrowser methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:13:43' prior: 16920513 overrides: 16886909!
                               labelString
	"Answer the string for the window title"
	
	^ 'Protocol for: ', baseClass name, ' up to: ', (selectedName ifNil: [ ProtoObject name asPlainString ])! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 4/21/2022 12:13:48' prior: 16801419!
       classDefinitionRecordFrom: tokens
	
	| classDefinition isMeta itemPosition className record fullClassName category stamp |
	
	itemPosition _ file position.
	fullClassName _ tokens second.
	isMeta _ fullClassName includesSubString: ' class'.
	className _ isMeta ifTrue: [fullClassName substrings first] ifFalse: [fullClassName].
	category _ CompiledMethod classCategoryFrom: tokens.
	stamp _ CompiledMethod stampFrom: tokens.
	classDefinition _ file nextChunk.
	
	record _ ChangeRecord new 
		file: file 
		position: itemPosition 
		type: #classDefinition 
		class: className asSymbol 
		category: category 
		meta: isMeta 
		stamp: stamp.
		
	record markAsTest: (classDefinition beginsWith: TestCase name asPlainString).
	
	^record
! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/21/2022 12:13:56' prior: 16801730!
        compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| change class s1 s2 differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	change _ changeList at: listIndex.
	((class _ change changeClass) notNil
			and: [class includesSelector: change methodSelector])
		ifTrue: [
			s1 _ (class sourceCodeAt: change methodSelector) asPlainString.
			s2 _ change string.
			s1 = s2
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords _ self shouldDiffWords.
			differDesc _ diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: s1 to: s2
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: Preferences standardCodeFont))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/21/2022 12:13:58' prior: 16802172!
      selectUnchangedMethods
	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"

	| change class |
	1 to: changeList size do: [ :i | 
		change _ changeList at: i.
		listSelections at: i put:
			((change changeType == #method and:
				[(class _ change changeClass) notNil]) and:
					[(class includesSelector: change methodSelector) and:
						[change string = (class sourceCodeAt: change methodSelector) asPlainString ]])].
	self changed: #allSelections.
	self changed: #annotation! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 4/21/2022 12:14:04' prior: 16839003!
                   openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 4/21/2022 12:14:07' prior: 16855597!
     pattern: textOrStringOrNil

	textOrStringOrNil
		ifNil: [pattern _ '*']
		ifNotNil: [pattern _ textOrStringOrNil asPlainString].
	self updateFileList.
	^ true
! !
!FileList methodsFor: 'private' stamp: 'jmv 4/21/2022 11:51:15' prior: 16855693!
            put: aText
	"Private - put the supplied text onto the file"

	| nameUsed type |
	brevityState == #fullFile ifTrue: [
		directory // fileName writeStreamDo: [ :stream |
			nameUsed _ stream name.
			stream nextPutAll: aText asPlainString ].
		fileName = nameUsed
			ifTrue: [ acceptedContentsCache _ aText asPlainString]
			ifFalse: [self updateFileList].		"user chose a different name (instead of overwriting)"
		^ true  "accepted"].

	listIndex = 0 ifTrue: [
		self inform: 'No fileName is selected'.
		^ false  "failed"].
	type _ 'These'.
	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].
	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].
	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].
	brevityState = #FileList ifTrue: [type _ 'Directory'].
	self inform: ('{1} contents cannot
meaningfully be saved at present.' format:{type}).
	^ false  "failed"
! !
!SimpleServiceEntry methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:14:12' prior: 16936592 overrides: 16902975!
                               printOn: aStream

	aStream nextPutAll: self class name; nextPutAll: ': ('.
	self provider
		ifNotNil: [ aStream nextPutAll: provider printString].
	aStream nextPutAll: ' --- '. 
	self selector
		ifNotNil: [ aStream nextPutAll: selector asPlainString].
	aStream nextPut: $)

! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 4/21/2022 12:15:27' prior: 16785905!
     firstCommentAt:  selector
	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."

	| sourceString commentStart  pos nextQuotePos |

	sourceString _ (self sourceCodeAt: selector) asPlainString.
	sourceString size = 0 ifTrue: [^ ''].
	commentStart _ sourceString findString: '"' startingAt: 1.
	commentStart = 0 ifTrue: [^ ''].
	pos _ commentStart + 1.
	[(nextQuotePos _ sourceString findString: '"' startingAt: pos) = (sourceString findString: '""' startingAt: pos)]
		whileTrue:
			[pos _ nextQuotePos + 2].
	
	commentStart = nextQuotePos ifTrue: [^ ''].  "Must have been a quote in string literal"

	^ (sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"'


"Behavior firstCommentAt: #firstCommentAt:"! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 4/21/2022 12:15:31' prior: 16786142!
     standardMethodHeaderFor: aSelector
	| args |
	args _ (1 to: aSelector numArgs)	collect:[:i| 'arg', i printString].
	args size = 0 ifTrue:[^aSelector asPlainString].
	args size = 1 ifTrue:[^aSelector,' arg1'].
	^String streamContents:[:s|
		(aSelector findTokens: ':') with: args do: [ :tok :arg |
			s nextPutAll: tok; nextPutAll:': '; nextPutAll: arg; nextPutAll:' '.
		].
	].
! !
!ClassDescription methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:51:22' prior: 16813790!
       comment: aStringOrText
	"Set the receiver's comment to be the argument, aStringOrText."

	self theNonMetaClass classComment: aStringOrText asPlainString.! !
!ClassDescription methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:51:27' prior: 16813798!
        comment: aStringOrText stamp: aStamp
	"Set the receiver's comment to be the argument, aStringOrText."

	self theNonMetaClass classComment: aStringOrText asPlainString stamp: aStamp.! !
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 4/21/2022 11:51:05' prior: 16814138!
            compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
	| methodAndNode selector isExistingMethod |
	methodAndNode _ self basicCompile: text asPlainString notifying: requestor 
							trailer: self defaultMethodTrailer ifFail: [^nil].
	selector _ methodAndNode selector.
	isExistingMethod _ self includesSelector: selector.
	isExistingMethod
		ifTrue: [
			(self theNonMetaClass isOkToChangeMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method modification not allowed']]
		ifFalse: [
			(self theNonMetaClass isOkToAddMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method addition not allowed']].
	logSource ifTrue: [
		self logMethodSource: text forMethodWithNode: methodAndNode 
			inCategory: category withStamp: changeStamp notifying: requestor.
	].
	self addAndClassifySelector: selector withMethod: methodAndNode 
		method inProtocol: category notifying: requestor.
	^ methodAndNode selector! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 12:15:51' prior: 16814593!
            fileOutMethod: selector
	"Write source code of a single method on a file.  Make up a name for the file."

	| nameBody |
	(selector == #Comment) ifTrue: [^ self inform: 'Sorry, cannot file out class comment in isolation.'].
	(self includesSelector: selector) ifFalse: [^ self error: 'Selector ', selector asPlainString, ' not found'].
	nameBody _ self name , '-' , (selector copyReplaceAll: ':' with: '').
	DirectoryEntry smalltalkImageDirectory // (nameBody asFileName, '.st') writeStreamDo: [ :fileStream |
		fileStream timeStamp.
		self printMethodChunk: selector withPreamble: true
			on: fileStream moveSource: false toFile: 0 ]! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 12:16:07' prior: 16814823!
        printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asPlainString printString]
		ifFalse: [preamble _ ''].
	method _ self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR  -  THIS METHOD IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos _ method filePosition) = 0])
	ifTrue: [
		"The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [ outStream newLine; nextPut: $!!; nextChunkPut: preamble; newLine].
		outStream nextChunkPut: method decompileString]
	ifFalse: [
		sourceFile _ SourceFiles at: method fileIndex.
		preamble size > 0
			ifTrue:    "Copy the preamble"
				[outStream copyPreamble: preamble from: sourceFile at: oldPos]
			ifFalse:
				[sourceFile position: oldPos].
		"Copy the method chunk"
		fileIndex = 0 ifFalse: [
			outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
		newPos _ outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		moveSource ifTrue: [    "Set the new method source pointer"
			endPos _ outStream position.
			method checkOKToAdd: endPos - newPos at: newPos in: method fileIndex.
			method setSourcePosition: newPos inFile: fileIndex]].
	preamble size > 0 ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream newLine! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 4/21/2022 12:15:44' prior: 16815329!
                           classThatDefinesInstanceVariable: instVarName
	(instanceVariables notNil and: [instanceVariables includes: instVarName asPlainString]) ifTrue: [^ self]. 
	^ superclass ifNotNil: [superclass classThatDefinesInstanceVariable: instVarName]! !
!ClassDescription methodsFor: 'private' stamp: 'jmv 4/21/2022 11:51:40' prior: 16815590!
                       logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor
	| priorMethodOrNil overridenMethodOrNil |
	
	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: nil.
	overridenMethodOrNil := self superclass ifNotNil: [ :aSuperclass | 
		aSuperclass lookupSelector: aCompiledMethodWithNode selector ].
	
	aCompiledMethodWithNode method 
		putSource: aText asPlainString
		fromParseNode: aCompiledMethodWithNode node
		class: self 
		category: category 
		withStamp: changeStamp 
		inFile: 2 
		priorMethod: priorMethodOrNil 
		overridesMethod: overridenMethodOrNil.! !
!Class class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 12:03:15' prior: 16811073!
    templateForSubclassOf: priorClassName category: systemCategoryName 
	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"

	^ priorClassName asPlainString, ' subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''' , systemCategoryName asPlainString , ''''! !
!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'jmv 4/21/2022 12:16:44' prior: 16812677!
                       cleanupClassHierarchyFor: aClassDescription
	
	| myName mySuperclass |
	mySuperclass _ aClassDescription superclass.
	(self isReallyObsolete: aClassDescription) ifTrue: [
		
		"Remove class >>>from SystemDictionary if it is obsolete"
		myName _ aClassDescription name asPlainString.
		Smalltalk keys do: [:each | 
			(each asPlainString = myName and: [(Smalltalk at: each) == aClassDescription])
				ifTrue: [Smalltalk removeKey: each]].

		"Make class officially obsolete if it is not"
		(aClassDescription name asPlainString beginsWith: 'AnObsolete')
			ifFalse: [aClassDescription obsolete].

		aClassDescription isObsolete 
			ifFalse: [self error: 'Something wrong!!'].

		"Add class to obsoleteSubclasses of its superclass"
		mySuperclass
			ifNil: [self error: 'Obsolete subclasses of nil cannot be stored'].
		(mySuperclass obsoleteSubclasses includes: aClassDescription)
			ifFalse: [mySuperclass addObsoleteSubclass: aClassDescription].
	] ifFalse:[
		"check if superclass has aClassDescription in its obsolete subclasses"
		mySuperclass ifNil:[mySuperclass _ Class]. "nil subclasses"
		mySuperclass removeObsoleteSubclass: aClassDescription.
	].
	"And remove its obsolete subclasses if not actual superclass"
	aClassDescription obsoleteSubclasses do:[:obs|
		obs superclass == aClassDescription ifFalse:[
			aClassDescription removeObsoleteSubclass: obs]].
! !
!ContextPart methodsFor: 'debugger access' stamp: 'jmv 4/21/2022 12:18:44' prior: 16832301!
        errorReportOn: strm
	"Write a detailed error report on the stack (above me) on a stream.  For both the error file, and emailing a bug report.  Suppress any errors while getting printStrings.  Limit the length."

	| cnt aContext startPos |
 	strm print: Date today; space; print: Time now; newLine.
	strm newLine.
	strm nextPutAll: 'VM: ';
		nextPutAll: Smalltalk platformName;
		nextPutAll: ' - ';
		nextPutAll: Smalltalk vmVersion;
		newLine.
	strm nextPutAll: 'Image: ';
		nextPutAll: Smalltalk version;
		nextPutAll: ' [';
		nextPutAll: Smalltalk lastUpdateString;
		nextPutAll: ']';
		newLine.
	strm newLine.
	
	"Note: The following is an open-coded version of ContextPart>>stackOfSize: since this method may be called during a low space condition and we might run out of space for allocating the full stack."
	cnt _ 0.  startPos _ strm position.
	aContext _ self.
	[aContext notNil and: [(cnt _ cnt + 1) < Debugger defaultDebugStackSize]] whileTrue: [
		aContext printDetails: strm.	"variable values"
		strm newLine.
		aContext _ aContext sender].

	strm newLine; nextPutAll: '--- The full stack ---'; newLine.
	aContext _ self.
	cnt _ 0.
	[aContext == nil] whileFalse: [
		cnt _ cnt + 1.
		cnt = Debugger defaultDebugStackSize ifTrue: [strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; newLine ].
		strm print: aContext; newLine.  "just class>>selector"	

		strm position > (startPos+40000) ifTrue: [strm nextPutAll: '...etc...'.
			^ self]. 	"exit early"
		cnt > 100 ifTrue: [strm nextPutAll: '-- and more not shown --'.  ^ self].
		aContext _ aContext sender].
! !
!CompiledMethod methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:05:52' prior: 16828523!
                              printPrimitiveOn: aStream
	"Print the primitive on aStream"
	| primIndex primDecl |
	(primIndex := self primitive) = 0 ifTrue:
		[^self].
	primIndex = 120 ifTrue: "External call spec"
		[^aStream print: (self literalAt: 1); newLine].
	aStream nextPutAll: '<primitive: '.
	primIndex = 117
		ifTrue: [
			primDecl := self literalAt: 1.
			(primDecl at: 2) asPlainString printOn: aStream.
			(primDecl at: 1) ifNotNil: [ :moduleName |
				aStream nextPutAll:' module: '.
				moduleName asPlainString printOn: aStream]]
		ifFalse: [
			aStream print: primIndex].
	self primitiveErrorVariableName ifNotNil: [ :primitiveErrorVariableName |
		aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].
	aStream nextPut: $>; newLine! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:23:33' prior: 16963529!
           findString: aString startingAt: start 
	"Answer the index of subString within the receiver, starting at position start.
	If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:23:37' prior: 16963539!
findString: aString startingAt: start caseSensitive: caseSensitive
	"Answer the index of subString within the receiver, starting at index 
	start. If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start caseSensitive: caseSensitive! !
!Text methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:52:11' prior: 50341308!
        withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ String crlfString detect: [ :char | (char = Character newLineCharacter) not ].
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: String crlfString with: String newLineString asTokens: false.
	(newText asPlainString includes: wrongLineEnd) ifFalse: [ ^newText ].
	^newText copyReplaceAll: (String with: wrongLineEnd) with: String newLineString asTokens: false.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/21/2022 12:27:00' prior: 16952125!
                obsoleteClasses   "Smalltalk obsoleteClasses inspect"
	"NOTE:  Also try inspecting comments below"
	| obs c |
	obs _ OrderedCollection new.  Smalltalk garbageCollect.
	Metaclass allInstancesDo:
		[:m | c _ m soleInstance.
		(c notNil and: ['AnOb*' match: c name asPlainString])
			ifTrue: [obs add: c]].
	^ obs asArray

"Likely in a ClassDict or Pool...
(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray
"
"Obsolete class refs or super pointer in last lit of a method...
| n l found |
Smalltalk browseAllSelect:
	[:m | found _ false.
	1 to: m numLiterals do:
		[:i | (((l _ m literalAt: i) isMemberOf: Association)
				and: [(l value isKindOf: Behavior)
				and: ['AnOb*' match: l value name]])
			ifTrue: [found _ true]].
	found]
"! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/21/2022 12:27:24' prior: 16952296!
     testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString _ (cls sourceCodeAt: selector) asPlainString.
					newCodeString _ cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens _ oldCodeString findTokens: Character separators.
					newTokens _ newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 4/21/2022 12:24:39' prior: 16953900!
           allMethodsSourceStringMatching: aString
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.
	Search the class comments also.
	Argument might include $*, that matches any subsequence.
	For example, try:
		ensure:*[*close*]
	"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						(aString match: (cl sourceCodeAt: sel)) ifTrue: [
							adder
								value: cl
								value: sel ]].

					(aString match: cl organization classComment) ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 4/21/2022 12:24:43' prior: 16953935!
                      allMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						((cl sourceCodeAt: sel)
							findString: aString
							startingAt: 1
							caseSensitive: caseSensitive) > 0 ifTrue: [
							adder
								value: cl
								value: sel ]].
					(cl organization classComment
						findString: aString
						startingAt: 1
						caseSensitive: caseSensitive) > 0 ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 4/21/2022 13:55:07' prior: 16954061!
                       allPrimitiveMethodsInCategories: aList
	"Answer an OrderedCollection of all the methods that are implemented by primitives in the given categories.  1/26/96 sw"

	| aColl method | 
	aColl _ OrderedCollection new: 200.
	self allBehaviorsDo: [ :aClass |
		(aList includes: (SystemOrganization categoryOfElement: aClass theNonMetaClass name asPlainString) asPlainString)
			ifTrue: [
				aClass selectorsDo: [ :sel | 
					method _ aClass compiledMethodAt: sel.
					method primitive ~= 0
						ifTrue: [
							aColl addLast: aClass name , ' ' , sel 
								, ' ' , method primitive printString]]]].
	^ aColl

"Smalltalk allPrimitiveMethodsInCategories: #('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 4/21/2022 12:26:01' prior: 16955505!
                              assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	Preferences autoNumberUserChanges ifTrue: [
		oldUserChanges _ Smalltalk defaultUserChangesName asFileEntry.
		oldUserChanges exists ifTrue: [
			directory _ oldUserChanges parent.
			oldUserChangesName _ directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine ].
	StartupStamp _ nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 4/21/2022 11:52:20' prior: 16955733!
             logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString _ aStringOrText asPlainString.
	aString firstNoBlankIndex = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			self forceChangesToDisk ]].
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString ]]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 4/21/2022 12:24:47' prior: 16956527!
                      browseClassCommentsWithString: aString
	"Smalltalk browseClassCommentsWithString: 'my instances' "
	"Launch a message list browser on all class comments containing aString as a substring."
	| caseSensitive suffix list |
	suffix _ (caseSensitive _ Sensor shiftPressed)
		ifTrue: [ ' (case-sensitive)' ]
		ifFalse: [ ' (use shift for case-sensitive)' ].
	list _ Set new.
	Smalltalk allClassesDo: [ :class |
		(class organization classComment
			findString: aString
			startingAt: 1
			caseSensitive: caseSensitive) > 0 ifTrue: [
			list add: (MethodReference class: class selector: #Comment) ]].
	^ self
		browseMessageList: list
		name: 'Class comments containing ', aString printString, suffix
		autoSelect: aString.! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/21/2022 13:55:16' prior: 16942101!
             writeClassRename: newName was: oldName
	"Write a method that tells which modern class to map instances to."
	| oldVer sel code |

	oldVer _ self versionSymbol: (structures at: oldName).
	sel _ oldName asPlainString.
	sel at: 1 put: (sel at: 1) asLowercase.
	sel _ sel, oldVer.	"i.e. #rectangleoc4"

	code _ WriteStream on: (String new: 500).
	code nextPutAll: sel; newLine.
	code newLine; tab; nextPutAll: '^ ', newName.	"Return new class"

	self class compile: code contents classified: 'conversion'.

! !
!Exception methodsFor: 'exceptionDescription' stamp: 'jmv 4/21/2022 13:55:24' prior: 16849782!
      description
	
"Return a textual description of the exception."

	| desc |
	desc := self class name asPlainString.
	^ self messageText
		ifNil: [ desc]
		ifNotNil: [ :mt | desc , ': ' , mt ]! !
!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'jmv 4/21/2022 13:53:45' prior: 16886078 overrides: 16849791!
     messageText
	"Return an exception's message text."

	^ messageText
		ifNil: [
			message
				ifNil: [super messageText]
				ifNotNil: [message lookupClass printString , '>>' , message selector asPlainString]]! !
!Compiler methodsFor: 'public access' stamp: 'jmv 4/21/2022 12:09:54' prior: 16830822!
                     evaluateMethod: method to: receiver logged: doLog profiled: doProfile
	
	"See evaluate:in:to:notifying:ifFail:logged:profiled:
	It does the same but without compiling because it recevies the result of the compilation 
	as the parameter method. 
	self should have compile method"

	| value toLog itsSelection itsSelectionString |
	
	"(jmv) Log before evaluating. This way, if the evaluation is halted by whatever reason, it is logged anyway"
	doLog ifTrue: [
		toLog _ ((requestor respondsTo: #selection)  
			and: [ (itsSelection _ requestor selection) notNil
			and: [ (itsSelectionString _ itsSelection asPlainString) isEmptyOrNil not ]])
				ifTrue: [ itsSelectionString ]
				ifFalse: [ sourceStream contents ].
		SystemChangeNotifier uniqueInstance evaluated: toLog context: context ].

	"Evaluate now."
	doProfile
		ifTrue: [
			TimeProfileBrowser onBlock: [
				value _ receiver
					withArgs: (context ifNil: [#()] ifNotNil: [{context}])
					executeMethod: method ]]
		ifFalse: [
			value _ receiver
				withArgs: (context ifNil: [#()] ifNotNil: [{context}])
				executeMethod: method ].

	^ value! !
!Compiler methodsFor: 'private' stamp: 'jmv 4/21/2022 12:06:13' prior: 16830897!
                         from: textOrStream class: aClass context: aContext notifying: req

	sourceStream _ (textOrStream is: #Stream)
		ifTrue: [ textOrStream ]
		ifFalse: [ ReadStream on: textOrStream asPlainString ].
	class _ aClass.
	context _ aContext.
	requestor _ req! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 14:07:18' prior: 16931689!
             scanMessageParts: sourceString
	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"

	| coll nonKeywords |
	coll := OrderedCollection new.
	self scan: (ReadStream on: sourceString asPlainString).
	nonKeywords := 0.
	[tokenType == #doIt] whileFalse:
		[(currentComment == nil or: [currentComment isEmpty])
			ifTrue: [coll addLast: nil]
			ifFalse: [coll addLast: currentComment removeFirst.
				[currentComment isEmpty] whileFalse:
					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
		(token numArgs < 1 or: [token = #| and: [ coll size > 1 ] ])
			ifTrue: [(nonKeywords := nonKeywords + 1) > 1 ifTrue: [^ coll]]
						"done with header"
			ifFalse: [nonKeywords := 0].
		coll addLast: token.
		self scanToken].
	(currentComment == nil or: [currentComment isEmpty])
		ifTrue: [coll addLast: nil]
		ifFalse: [coll addLast: currentComment removeFirst.
			[currentComment isEmpty] whileFalse: [
				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
	^ coll! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 11:57:10' prior: 16931727!
    scanTokenPositionsIn: textOrString into: aBlock
	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments, in textOrString."

	self initScannerForTokenization.
	source := (ReadStream on: textOrString asPlainString).
	self step.
	self step.
	self scanAllTokenPositionsInto: aBlock

	"| code |
	code := '       #( 1 2 #( 3 4 ))  16r123 123 123.0  ', (Scanner sourceCodeAt: #scanTokenPositionsIn:into:).
	Scanner new scanTokenPositionsIn: code into: [:start :end| Transcript cr; nextPut: $_; nextPutAll: (code copyFrom: start to: end); nextPut: $_; endEntry]"

	"CodeDiffBuilder buildDisplayPatchFrom:  (Scanner sourceCodeAt: #scanTokenPositionsIn:into:) to:  ((Scanner sourceCodeAt: #scanTokenPositionsIn:into:) copyReplaceAll: String crString with: '')"

	"CodeDiffBuilder buildDisplayPatchFrom:  'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]' to:'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]'"! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 11:57:14' prior: 16931760!
                       scanTokens: textOrString 
	"Answer an Array that has been tokenized as though the input text, 
	textOrString, had appeared between the array delimitors #( and ) in a 
	Smalltalk literal expression."

	self initScannerForTokenization.
	self scan: (ReadStream on: textOrString asPlainString).
	self scanLitVec.
	^token

	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 11:57:20' prior: 16931775!
      typedScanTokens: textOrString 
	"Answer an Array that has been tokenized with literals mapped to literals,
	 special characters mapped to symbols and variable names and keywords
	 to strings. This methiod accepts _ (underscore) as an assignment token
	 irrespective of whether the system prefers := as the assignment token."
	| s |
	self initScannerForTokenization.
	self scan: (ReadStream on: textOrString asPlainString).
	s := WriteStream on: (Array new: 16).
	[tokenType == #doIt] whileFalse:
		[(token == #- 
		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: 
			[self scanToken.
			 token := token negated].
		s nextPut: token.
		self scanToken].
	^s contents

	"Scanner new typedScanTokens: (Scanner sourceCodeAt: #typedScanTokens:)"! !
!Parser methodsFor: 'private' stamp: 'jmv 4/21/2022 14:07:26' prior: 16907200!
initPattern: aString notifying: req return: aBlock
	| result |
	self
		init: (ReadStream on: aString asPlainString)
		notifying: req
		failBlock: [^nil].
	encoder _ self.
	result _ aBlock value: (self pattern: false inContext: nil).
	encoder _ failBlock _ nil.  "break cycles"
	^result! !
!Parser methodsFor: 'scanning' stamp: 'jmv 4/21/2022 11:56:21' prior: 16907484!
               transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain."
	| toMakeBinary |
	toMakeBinary _ #(verticalBar upArrow colon).
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asPlainString.
	hereType := #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asPlainString.
			hereEnd := hereEnd + 1.
			self scanToken].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken].! !
!MethodNode methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:05:40' prior: 16889779!
               printPrimitiveOn: aStream
	"Print the primitive on aStream"
	| primDecl |
	primitive = 0 ifTrue:
		[^self].
	primitive = 120 ifTrue: "External call spec"
		[^aStream print: encoder literals first].
	aStream nextPutAll: '<primitive: '.
	primitive = 117
		ifTrue:
			[primDecl := encoder literals at: 1.
			 (primDecl at: 2) asPlainString printOn: aStream.
			 (primDecl at: 1) ifNotNil:
				[:moduleName|
				aStream nextPutAll:' module: '.
				moduleName asPlainString printOn: aStream]]
		ifFalse:
			[aStream print: primitive].
	self primitiveErrorVariableName ifNotNil:
		[:primitiveErrorVariableName|
		 aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].
	aStream nextPut: $>.
	((Smalltalk classNamed: #StackInterpreter) ifNil: [Smalltalk classNamed: #Interpreter]) ifNotNil:
		[:interpreterClass|
		 aStream nextPutAll: ' "', ((interpreterClass primitiveTable) at: primitive + 1), '" ']! !
!Editor methodsFor: 'menu messages' stamp: 'jmv 4/21/2022 11:52:46' prior: 16845712!
                      pasteString
	"Paste the text's string from the shared buffer over the current selection and 
	redisplay if necessary.
	Pasting a string means using destination current attributes if appropriate."

	self replaceSelectionWith: self clipboardStringOrText asPlainString! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 4/21/2022 12:09:30' prior: 16846327!
                 collectCmdShortcutsSpecUsing: anInitializationMessage

	| shortcutsSpec dynamicInitializationMessage |
	
	shortcutsSpec := self perform: anInitializationMessage.

	dynamicInitializationMessage := (self name asPlainString uncapitalized, anInitializationMessage asPlainString capitalized) asSymbol.
	(Smalltalk allClassesImplementing: dynamicInitializationMessage) do: [ :aClass | 
		shortcutsSpec := shortcutsSpec, (aClass soleInstance perform: dynamicInitializationMessage) ].

	^shortcutsSpec

! !
!DirectoryEntry methodsFor: 'actions-path' stamp: 'jmv 4/21/2022 12:07:53' prior: 16843227!
                 / pathString
	"Answer an instance of DirectoryEntry.
	If you want an instance of FileEntry, please call #//"
	^self concatPathComponentsAsDirectory: pathString asPathComponents! !
!DirectoryEntry methodsFor: 'actions-path' stamp: 'jmv 4/21/2022 12:07:59' prior: 16843236!
                // pathString
	"Answer an instance of FileEntry.
	If you want an instance of DirectoryEntry, please call #/"
	^self concatPathComponentsAsFile: pathString asPathComponents! !
!RemoteString methodsFor: 'private' stamp: 'jmv 4/21/2022 11:52:54' prior: 16925803!
                            string: aStringOrText onFileNumber: fileNumber toFile: aFileStream
	"Store this as the receiver's text if source files exist."

	| position |
	fileNumber = 0 ifFalse: [
		aFileStream padTo: SourceFiles pointerScaleForWriting put: $  ].
	position _ aFileStream position.
	self fileNumber: fileNumber position: position.
	aFileStream nextChunkPut: aStringOrText asPlainString! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 4/21/2022 13:56:44' prior: 16819321!
                    writeFeatureSpecOn: aStream
	| provides |
	provides _ featureSpec provides.
	aStream
		nextPut: $!!; 
		nextChunkPut: 'provides: ', provides name asPlainString printString, ' ', provides version printString, ' ', provides revision printString;
		newLine.
	featureSpec requires do: [ :requires |
		aStream
		nextPut: $!!; 
			nextChunkPut: 'requires: ', requires name asPlainString printString, ' ', requires minVersion printString, ' ', requires minRevision printString, ' ', requires maxVersion printString;
			newLine ]! !
!FeatureRequirement methodsFor: 'accessing' stamp: 'jmv 4/21/2022 13:56:14' prior: 16853268!
                      packageFileName
	"Answer a package name based on feature name"

	^ name asPlainString, '.pck.st'! !
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 4/21/2022 13:56:56' prior: 16853493!
 addToLoad: toLoad withMyRequirements: requirements

	"Add self to OrderedCollection 'toLoad' before any requirements I have"
	| myRequirements |
	myRequirements := self requirements.
	toLoad do: [ :featureReq | 
		(myRequirements anySatisfy: [ :req | featureReq sameNameAs: req])
		ifTrue: [
			"Transcript show: ('adding ', self name asPlainString, ' before: ', featureReq name asPlainString); newLine."
			toLoad add: self before: featureReq.
			^ toLoad
		]
	].
	"Transcript show: ('adding ', self name asPlainString); newLine."
	toLoad addLast: self.
	^ toLoad
		! !
!Preferences class methodsFor: 'personalization' stamp: 'jmv 4/21/2022 13:57:07' prior: 50340592!
   compileHardCodedPref: prefName enable: aBoolean
	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"

	self class compileSilently: (prefName asPlainString, '
	"compiled programatically -- return hard-coded preference value"
	^ ', aBoolean storeString) classified: 'hard-coded prefs'.
	SmalltalkCompleter addSelector: prefName.
	
"Preferences compileHardCodedPref: #testing enable: false"! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/21/2022 13:57:14' prior: 16894448!
               addEmbeddingMenuItemsTo: aMenu hand: aHandMorph
	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self potentialEmbeddingTargets reverseDo: [:m | 
		menu 
			add: m class name asPlainString 
			targetHighlight: m 
			action: #addMorphFrontFromWorldPosition: 
			argumentList: {self}].
	aMenu ifNotNil:[
		menu submorphCount > 0 
			ifTrue:[aMenu add:'embed into' subMenu: menu].
	].
	^menu! !
!StringRequestMorph methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:53:20' prior: 16950278!
                      response: aText
	"Sent when text pane accepts."
	response _ aText.
	validationBlock ifNotNil: [(validationBlock value: aText asPlainString) ifFalse: [self flash. ^ false]].
	[acceptBlock ifNotNil: [acceptBlock value: aText asPlainString]] ensure: [self delete].
	^ true! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 4/21/2022 11:57:45' prior: 16950327!
             addTitle: aString
	| titleMorph s pp w |
	titleMorph _ BoxedMorph new noBorder.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line |
		s _ LabelMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 24) @ (pp y).
	self addMorphKeepMorphHeight: titleMorph.
	^titleMorph morphWidth! !
!SystemWindow methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:07:36' prior: 16959735 overrides: 16894539!
                 printOn: aStream 
	aStream nextPutAll: labelString asPlainString! !
!FillInTheBlankMorph methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:53:24' prior: 16856873!
                              response: aText
	"Sent when text pane accepts."

	response _ aText asPlainString.
	done _ true.
	^ true
! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 4/21/2022 11:57:39' prior: 16882751!
                             addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w newMorph |
	
	newMorph _ BoxedMorph new noBorder.
	newMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line | | font |
		font _ Preferences standardMenuFont.
		s _ LabelMorph new
			contents: line;
			font: (titleMorph
				ifNil: [ font bold ]
				ifNotNil: [ font italic ])..
		newMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ newMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	newMorph morphExtent: (w + 16) @ (pp y).
	titleMorph
		 ifNil: [
			titleMorph _ newMorph.
			self addMorphFront: titleMorph ]
		ifNotNil: [ self addMorphBack: newMorph ].
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 14:08:24' prior: 16881653!
                           from: aPopupMenu title: titleStringOrNil
	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."

	| menu items lines selections labelString labelPlainString j emphasis |
	menu _ self new.
	titleStringOrNil ifNotNil: [
		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].
	labelString _ aPopupMenu labelString.
	labelPlainString _ labelString asPlainString.
	items _ labelPlainString lines.
	(labelString is: #Text) ifTrue: [
		"Pass along text emphasis if present"
		j _ 1.
		items _ items collect: [ :item |
			j _ labelPlainString findString: item startingAt: j.
			emphasis _ TextEmphasis new emphasisCode: (labelString emphasisAt: j).
			item asText addAttribute: emphasis]].
	lines _ aPopupMenu lineArray.
	lines ifNil: [lines _ #()].
	menu cancelValue: 0.
	menu defaultTarget: menu.
	selections _ (1 to: items size) asArray.
	1 to: items size do: [ :i |
		menu add: (items at: i) target: menu action: #selectMVCItem: argument: (selections at: i) icon: (aPopupMenu iconAt: i).
		(lines includes: i) ifTrue: [menu addLine]].
	^ menu
! !
!HaloSpec methodsFor: 'printing' stamp: 'jmv 4/21/2022 13:54:03' prior: 16865374 overrides: 16902975!
                       printOn: aStream
	"Add a textual printout representing the receiver to a stream"

	super printOn: aStream.
	aStream nextPutAll: ' (', addHandleSelector asPlainString, ' ', iconSymbol asPlainString, ')'! !
!PseudoClass methodsFor: 'class' stamp: 'jmv 4/21/2022 14:08:33' prior: 16920761!
 comment: aString
	self classComment: aString asPlainString! !
!PseudoClass methodsFor: 'methods' stamp: 'jmv 4/21/2022 13:57:19' prior: 16921171!
              removeSelector: aSelector
	| catName |
	catName := self class removedCategoryName asPlainString.
	self organization addCategory: catName before: self organization categories first.
	self organization classify: aSelector under: catName.
	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !
!TestCase class methodsFor: 'building suites' stamp: 'jmv 4/21/2022 13:57:23' prior: 16961897!
                     buildSuite
	| suite |
	suite _ TestSuite new.
	^ self isAbstract
		ifTrue: [
			suite name: self name asPlainString.
			self allSubclasses
				do: [:each | each isAbstract
						ifFalse: [each addToSuiteFromSelectors: suite]].
			suite]
		ifFalse: [self addToSuiteFromSelectors: suite]! !
!TestCase class methodsFor: 'building suites' stamp: 'jmv 4/21/2022 13:57:33' prior: 16961919!
buildSuiteFromMethods: testMethods 
	| suite |
	suite _ TestSuite new
				name: self name asPlainString;
				yourself.
	^self addToSuite: suite fromMethods: testMethods! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 4/21/2022 13:57:39' prior: 16943959!
 saveTo: aFileName
	"
	| st |
	st := SpaceTally new.
	st spaceTally: (Array with: EllipseMorph with: Point).
	st saveTo: 'spaceTally2'
	"

	DirectoryEntry smalltalkImageDirectory // aFileName forceWriteStreamDo: [ :stream |
		results do: [ :each |
				stream nextPutAll: each analyzedClassName asPlainString; 
						nextPutAll: ' '; nextPutAll: each codeSize printString; 
						nextPutAll: ' '; nextPutAll: each instanceCount printString; 
						nextPutAll: ' '; nextPutAll: each spaceForInstances printString; newLine ]]! !
!SpaceTallyItem methodsFor: 'printing' stamp: 'jmv 4/21/2022 13:57:44' prior: 50341052 overrides: 16902975!
       printOn: aStream

	analyzedClassName
		ifNotNil: [ aStream nextPutAll: analyzedClassName asPlainString]. 
	aStream nextPutAll: ' ('.
	codeSize
		ifNotNil: [ aStream nextPutAll: 'code size: ' ;  nextPutAll: codeSize printString]. 
	instanceCount
		ifNotNil: [ aStream nextPutAll: ' instance count: ' ;  nextPutAll: instanceCount printString]. 
	spaceForInstances
		ifNotNil: [ aStream nextPutAll: ' space for instances: ' ;  nextPutAll: spaceForInstances printString]. 
	aStream nextPut: $).
	! !
!SHTextStylerST80 methodsFor: 'styling' stamp: 'jmv 4/21/2022 11:53:28' prior: 16930719!
                       styleWorkspaceFrom: start to: end allowEmphasis: aBoolean
	"Style a copy of part of the model text. Then apply attributes to model text. Useful for Workspaces.
	Call #formatWorkspace: becore calling us.
	Note: classOrMetaClass is assumed to be nil.
	Note: after last call, do `textModel changed: #shoutStyled`"

	parser
		source: (formattedText asPlainString copyFrom: start to: end).
	parser parse.
	parser ranges ifNotNil: [ :ranges |
		ranges do: [ :range |
			(self attributesFor: range rangeType) ifNotNil: [ :attributes |
				attributes do: [ :each |
					"For Workspaces, avoid attributes that affect text layout: very large contents would be slow."
					(aBoolean or: [each emphasisCode noMask: 3]) ifTrue: [
						formattedText
							addAttribute: each
							from: range start +start-1
							to: range end +start-1 ]]]]].! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 4/21/2022 11:44:19' prior: 16930846!
  parseSetWorkspace: aBoolean
	"Answer a collection of SHRanges by parsing aText.
	When formatting it is not necessary to set the workspace, and this can make the parse take less time, so aBoolean specifies whether the parser should be given the workspace"
	parser ifNil: [ parser := SHParserST80 new ].
	parser
		workspace:
			(aBoolean ifTrue: [ workspace ]);
		classOrMetaClass: classOrMetaClass;
		source: formattedText asPlainString.
	parser parse.
	^ parser ranges.! !
!RemoveParameter methodsFor: 'initialization' stamp: 'jmv 4/21/2022 13:54:26' prior: 16926383!
        initializeNamed: aParameterToRemove
	ofKeywordAtIndex: aParameterIndex
	from: anOldSelector 
	creating: aNewSelector 
	implementors: implementorsCollection 
	senders: sendersCollection
	
	super initializeFrom: anOldSelector to: aNewSelector implementors: implementorsCollection senders: sendersCollection.

	parameterToRemove := aParameterToRemove.
	parameterIndex := aParameterIndex.
	senderReplacementString := newSelector isUnary ifTrue: [ newSelector asPlainString ] ifFalse: [ '' ].
	isLastParameter := oldSelector numArgs = parameterIndex 
	! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'jmv 4/21/2022 13:57:52' prior: 16927247!
                           errorMessageForGlobalNotDefined: anOldName

	^ anOldName asPlainString, ' is not defined as global variable'! !
!SafelyRemoveClass class methodsFor: 'exceptions' stamp: 'jmv 4/21/2022 13:57:58' prior: 16931267!
             errorMessageForCanNotRemove: aClassToSafelyRemove dueToReferencesToAll: referenced

	^String streamContents: [ :stream |
		stream 
			nextPutAll: aClassToSafelyRemove name asPlainString;
			nextPutAll: ' can not be removed '.
	
		referenced size = 1 
			ifTrue: [ (referenced includes: aClassToSafelyRemove) 
				ifTrue: [ stream nextPutAll: 'because it has references' ]
				ifFalse: [ stream 
					nextPutAll: 'because it subclass, ';
					nextPutAll: referenced anyOne name asPlainString;
					nextPutAll: ', has references' ]]
			ifFalse: [ (referenced includes: aClassToSafelyRemove)
				ifTrue: [ stream 
					nextPutAll: 'due to references to: ';
					nextPutAll: referenced asCommaStringAnd ]
				ifFalse: [ stream
					nextPutAll: 'due to references to its subclasses: ';
					nextPutAll: referenced asCommaStringAnd ]]]! !
!SafelyRemoveClass class methodsFor: 'warnings' stamp: 'jmv 4/21/2022 13:58:02' prior: 16931327!
                              warningMessageFor: aClassToSafelyRemove hasSubclasses: allSubclasses

	^String streamContents: [ :stream |
		stream nextPutAll: aClassToSafelyRemove name asPlainString.
		allSubclasses size = 1
			ifTrue: [ stream nextPutAll: ' has a subclass' ]
			ifFalse: [ stream 
					nextPutAll: ' has ';
					print:  allSubclasses size;
					nextPutAll: ' subclasses' ].
		stream nextPutAll: ' that will be removed'].
		
	! !
!RenameGlobalApplier methodsFor: 'refactoring - parameters request' stamp: 'jmv 4/21/2022 13:58:07' prior: 16927321!
           askNewName

	newName := self request: 'Enter new name:' initialAnswer: oldName asPlainString.
	newName := newName withBlanksTrimmed asSymbol.
	! !
!SafelyRemoveClassApplier methodsFor: 'refactoring - parameters request' stamp: 'jmv 4/21/2022 14:08:56' prior: 16931359!
                   confirmationMessageText
	
	^'Are you sure you want to remove ', classToRemove name asPlainString, '?'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5110-asPlainString-JuanVuletich-2022Apr22-11h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5110] on 22 April 2022 at 10:53:26 am'!
!Symbol methodsFor: 'converting' stamp: 'jmv 4/22/2022 10:52:24' prior: 16950728 overrides: 16948150!
            asString
	^ self asPlainString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5111-DontRepeatYourself-JuanVuletich-2022Apr22-10h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5111] on 22 April 2022 at 12:06:34 pm'!
!Symbol methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:47:23' overrides: 16948682!
                              uncapitalized
	^ self asPlainString uncapitalized asSymbol! !
!Message methodsFor: 'stub creation' stamp: 'jmv 4/21/2022 14:42:52' prior: 16883625!
            argumentNameAt: anIndex havingNamed: alreadyNamedArguments

	| argumentName |
	
	argumentName _ (self arguments at: anIndex) argumentName.
	[alreadyNamedArguments includes: argumentName] whileTrue: [argumentName _ argumentName, anIndex printString].
	alreadyNamedArguments add: argumentName.

	^argumentName! !
!EventSensor methodsFor: 'test' stamp: 'jmv 4/21/2022 14:43:09' prior: 50341177!
                        printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp unicodeCodePoint |
	type _ evtBuf first.
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode _ evtBuf third.
			unicodeCodePoint _ evtBuf sixth.
			pressType _ evtBuf fourth.
			modifiers _ evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type _ #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type _ #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type _ #keystroke].
			Transcript
				newLine;
				show: type;
				show: ' macRomanCode:', macRomanCode printString, '-', 
					(String with: (Character numericValue: (Character macRomanToLatin1: macRomanCode))), '-';
				show: ' unicodeCodePoint:', unicodeCodePoint printString.
			(Character iso8859s15CodeForUnicodeCodePoint: unicodeCodePoint) ifNotNil: [ :latin15 |
				Transcript show: '-', (String with: (Character numericValue: latin15)), '-' ].
			Transcript
				show: ' modifiers:', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript show: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript show: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript show: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript show: ' [shift]' ].
			].! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:43:55' prior: 16948102!
                         asLowercase
	"Answer a String made up from the receiver whose characters are all 
	lowercase."

	^ self copy asPlainString translateToLowercase! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:44:01' prior: 16948215!
                           asUppercase
	"Answer a String made up from the receiver whose characters are all 
	uppercase."

	^self copy asPlainString translateToUppercase! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:46:00' prior: 16948682!
                            uncapitalized
	"Answer an object like the receiver but with first character downshifted if necesary"
	"'MElViN' uncapitalized"
	"#Will uncapitalized"
	| answer |
	self isEmpty ifTrue: [^ self].
	answer _ self isString
				ifTrue: ["don't modify receiver"
					self copy]
				ifFalse: [self asPlainString].
	answer at: 1 put: (answer at: 1) asLowercase.
	^ answer! !
!Symbol methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:47:21' prior: 16950738 overrides: 16948361!
            capitalized
	^ self asPlainString capitalized asSymbol! !
!Symbol class methodsFor: 'access' stamp: 'jmv 4/21/2022 14:47:39' prior: 16950906!
                  selectorsContaining: aString
	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."

	| size selectorList ascii |

	selectorList _ OrderedCollection new.
	(size _ aString size) = 0 ifTrue: [^selectorList].

	aString size = 1 ifTrue:
		[
			ascii _ aString first numericValue.
			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]
		].

	aString first isValidInIdentifiers ifFalse:
		[
			aString size = 2 ifTrue: 
				[Symbol hasInterned: aString ifTrue:
					[:s | selectorList add: s]].
			^selectorList
		].

	selectorList _ selectorList copyFrom: 2 to: selectorList size.

	self allSymbolTablesDo: [:each |
		each size >= size ifTrue:
			[(each findSubstring: aString in: each startingAt: 1 
				matchTable: CaseInsensitiveOrder) > 0
						ifTrue: [selectorList add: each]]].

	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"
		each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]].

"Symbol selectorsContaining: 'scon'"! !
!Symbol class methodsFor: 'access' stamp: 'jmv 4/21/2022 14:47:44' prior: 16950943!
 selectorsMatching: aStringPattern
	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.
	 Does return symbols that begin with a capital letter."

	| selectorList |

	selectorList := OrderedCollection new.

	aStringPattern isEmpty ifTrue: [^selectorList].

	self allSymbolTablesDo:
		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].

	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"
		[:each | each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]]

	"Symbol selectorsMatching: 'parse:*'"! !
!ContentPack class methodsFor: 'code pack' stamp: 'jmv 4/21/2022 14:52:08' prior: 16831704!
         compilePayloadWith: contentMap

	| category |
	category _ self generatedMethodsCategory.
	self
		compile: 'contentMap' , String newLineString , '	^ ' , contentMap asString
		classified: category.

	self
		compile: 'objectCount' , String newLineString , '	^ ' , payload size asString
		classified: category.

	payload withIndexDo: [ :blob :index | | selector |
		selector _ 'object', index printString.
		self
			compile: selector, String newLineString, '	^ ', blob surroundedBySingleQuotes
			classified: category ]! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 4/21/2022 14:50:36' prior: 16941635!
                               mapClass: incoming
	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "

	| cls oldVer sel nm |

	self flag: #bobconv.	


	nm _ renamed at: incoming ifAbsent: [incoming].	"allow pre-mapping around collisions"
	(nm endsWith: ' class') 
		ifFalse: [cls _ Smalltalk at: nm ifAbsent: nil.
			cls ifNotNil: [^ cls]]  	"Known class.  It will know how to translate the instance."
		ifTrue: [cls _ Smalltalk at: nm substrings first asSymbol ifAbsent: nil.
			cls ifNotNil: [^ cls class]]. 	"Known class.  It will know how to translate the instance."
	oldVer _ self versionSymbol: (structures at: nm).
	sel _ nm asPlainString.
	sel at: 1 put: (sel at: 1) asLowercase.
	sel _ sel, oldVer.	"i.e. #rectangleoc4"
	Symbol hasInterned: sel ifTrue: [:symb | 
		(self class canUnderstand: sel asSymbol) ifTrue: [
			cls _ self perform: sel asSymbol]].	"This class will take responsibility"
	cls ifNil: [cls _ self writeClassRenameMethod: sel was: nm
					fromInstVars: (structures at: nm).
			   cls class == String ifTrue: [cls _ nil]].
	cls ifNotNil: [renamed at: nm put: cls name].
	^ cls
! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 4/21/2022 14:50:49' prior: 16942014!
     versionSymbol: instVarList
	"Create the symbolic code (like a version number) for this class in some older version.  First initials of all the inst vars, followed by the class version number.  Returns a string, caller makes it into a compound selector.  "

	| str |
	str _ instVarList size = 1 ifFalse: [''] ifTrue: ['x'].		"at least one letter"
	2 to: instVarList size do: [:ind |
		str _ str, (instVarList at: ind) first asPlainString].
	str _ str, instVarList first printString.	"the number"
	^ str

" | list | list _ (Array with: Paragraph classVersion), (Paragraph alistInstVarNames).
(SmartRefStream  on: (DummyStream on: nil)) versionSymbol: list
"! !
!Process methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:51:05' prior: 16917393!
                            browserPrintStringFull: aBoolean

	^String streamContents: [ :stream |
		aBoolean ifTrue: [
			stream
				nextPutAll: self statusString;
				space ].
		priority printOn: stream.
		stream nextPutAll: ' ('.
		self hash printOn: stream.
		stream
			nextPutAll: ') ';
			nextPutAll: self name.
		self animatedUI ifNotNil: [ :ui |
			stream nextPutAll: ' - '.
			ui printOn: stream ].
		aBoolean ifTrue: [
			stream
				nextPutAll: ': ';
				nextPutAll: suspendedContext printString ]]! !
!Parser methodsFor: 'scanning' stamp: 'jmv 4/21/2022 14:51:40' prior: 50342769!
            transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain."
	| toMakeBinary |
	toMakeBinary _ #(verticalBar upArrow colon).
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asPlainString.
	hereType := #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asPlainString.
			hereEnd := hereEnd + 1.
			self scanToken].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asPlainString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken].! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'jmv 4/21/2022 14:51:55' prior: 16841277!
                            codeInst: index

	^InstanceVariableNode new
		name: (instVars at: index + 1 ifAbsent: ['unknown', index printString])
		index: index + 1! !
!SerializableClosureDecompilerConstructor methodsFor: 'constructor' stamp: 'jmv 4/21/2022 14:52:15' prior: 16935519 overrides: 50343677!
           codeInst: index

	^ SerializableClosureInstanceVariableNode new
		name: (instVars at: index + 1 ifAbsent: ['unknown', index printString])
		index: index + 1! !
!TextEditor methodsFor: 'attributes' stamp: 'jmv 4/21/2022 14:55:04' prior: 16966411!
          offerFontStyleMenu
	"This is a user command, and generates undo"

	| emphases menuStrings entries reply code startIndex attribute |
	startIndex _ self startIndex.
	code _ model actualContents emphasisAt: startIndex.
	emphases _ #(bold italic underlined struckThrough superscript subscript withST80Glyphs).
	menuStrings _ Array streamContents: [ :strm |
		strm nextPut:(code isZero ifTrue: ['<on>'] ifFalse: ['<off>']), 'normal'.
		emphases do: [ :emph |
			strm nextPut:
				((code anyMask: (TextEmphasis perform: emph) emphasisCode)
					ifTrue: ['<on>'] ifFalse: ['<off>']),
				emph asPlainString ]].
	entries _ `#(normal)`, emphases.
	reply _ (SelectionMenu labelList: menuStrings lines: #(1) selections: entries) startUpMenu.
	reply ifNotNil: [
		attribute _ TextEmphasis perform: reply.
		((menuStrings at: (entries indexOf: reply)) beginsWith: '<on>')
			ifTrue: [ self unapplyAttributes: {attribute} ]
			ifFalse: [ self applyAttribute:  attribute ]].
	morph updateFromTextComposition.! !
!TextEditor methodsFor: 'model access' stamp: 'jmv 4/21/2022 14:55:17' prior: 16967033!
   wordUnder: aPositionInText
	
	| wordUnderCursorRange word indexOfSpace |
	
	wordUnderCursorRange := self wordRangeUnder: aPositionInText.
	word := (model actualContents copyFrom: wordUnderCursorRange first to: wordUnderCursorRange last) asPlainString.
	
	"I have to handle the edge case where the cursor is for example between a ' and the first letter of the word.
	In that case the range will include words with spaces - Hernan"
	indexOfSpace := word indexOf: $  ifAbsent: [ ^word ].
	
	^word first: indexOfSpace -1 
	
			! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'jmv 4/21/2022 14:55:41' prior: 16939347!
               withMethodNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| selectedClass methodNode |

	selectedClass := self selectedClassOrMetaClassOrUndefinedObject.
	[ 
		[ methodNode := selectedClass methodNodeFor: model actualContents asPlainString ]
			on: UndeclaredVariableWarning do: [ :ex | ex resume ]
	] on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: selectedClass.! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 4/21/2022 14:55:29' prior: 16939888!
 explainClass: symbol 
	"Is symbol a class variable or a pool variable?"
	| provider class reply classes |
	provider _ self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass)
		ifFalse: [^ nil].
	(class _ provider selectedClassOrMetaClass) ifNil: [^ nil].
	"no class is selected"
	(class isKindOf: Metaclass)
		ifTrue: [class _ class soleInstance].
	classes _ (Array with: class)
				, class allSuperclasses.
	"class variables"
	reply _ classes detect: [:each | (each classVarNames detect: [:name | symbol = name]
					ifNone: nil)
					notNil]
				ifNone: nil.
	reply ifNotNil: [
		^ String streamContents: [:str |
			str
				nextPutAll: symbol;
				nextPutAll: ' is a class variable, defined in class ';
				nextPutAll: reply printString, '\' withNewLines;
				nextPutAll: 'Smalltalk browseAllCallsOn: (';
				nextPutAll: reply printString;
				nextPutAll: ' classPool associationAt: #';
				nextPutAll: symbol;
				nextPutAll: ').']].
	"pool variables"
	classes do: [:each | (each sharedPools
			detect: [:pool | (pool includesKey: symbol)
					and: 
						[reply _ pool.
						true]]
			ifNone: nil)
			notNil].
	reply
		ifNil: [(Undeclared includesKey: symbol)
				ifTrue: [
					^ String streamContents: [:str |
						str
							nextPutAll: symbol;
							nextPutAll: ' is an undeclared variable.';
							nextPutAll: 'Smalltalk browseAllCallsOn: (Undeclared associationAt: #';
							nextPutAll: symbol;
							nextPutAll: ').']]]
		ifNotNil: 
			[classes _ Array streamContents: [ :strm |
				Smalltalk
					allBehaviorsDo: [:each | (each sharedPools
							detect: 
								[:pool | 
								pool == reply]
							ifNone: nil)
							notNil ifTrue: [strm nextPut: each]]].
			"Perhaps not print whole list of classes if too long. (unlikely)"
			^ String streamContents: [:str |
				str
					nextPutAll: symbol;
					nextPutAll: ' is a pool variable from the pool ';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ', which is used by the following classes ';
					nextPutAll: classes printString , '\' withNewLines;
					nextPutAll: 'Smalltalk browseAllCallsOn: (';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ' bindingOf: #';
					nextPutAll: symbol;
					nextPutAll: ').']].
	^ nil! !
!TextReplaceCommand methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:56:16' prior: 16969683 overrides: 16902975!
                              printOn: aStream
	old isEmpty ifTrue: [
		^aStream nextPutAll: 'typed: '; nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes].
	new isEmpty ifTrue: [
		^aStream nextPutAll: 'deleted: '; nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ].
	aStream
		nextPutAll: 'replaced: ';
		nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes;
		nextPutAll: ' with: ';
		nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ! !
!FileIOAccessor methodsFor: 'accessing' stamp: 'jmv 4/21/2022 14:56:34' prior: 16854764!
              slash
	"Given that FileMan supports $/ as path delimiter regardless of the platform,
	this method is mostly for FileMan's own use, and general usage is discouraged.
	Just use '/' "
	slash ifNil: [ slash _ String with: self pathNameDelimiter ].
	^slash! !
!Utilities class methodsFor: 'tailoring system' stamp: 'jmv 4/21/2022 14:57:58' prior: 16977374!
stripMethods: tripletList messageCode: messageString
	"Used to 'cap' methods that need to be protected for proprietary reasons, etc.; call this with a list of triplets of symbols of the form  (<class name>  <#instance or #class> <selector name>), and with a string to be produced as part of the error msg if any of the methods affected is reached"

	| aClass sel keywords codeString |
	tripletList do:
		[:triplet |  
			(aClass _ (Smalltalk at: triplet first ifAbsent: nil)) ifNotNil: [
				triplet second == #class ifTrue: [
					aClass _ aClass class].
				sel _ triplet third.
				keywords _ sel keywords.
				(keywords size = 1 and: [keywords first asSymbol isKeyword not])
					ifTrue: [
						codeString _ keywords first]
					ifFalse: [
						codeString _ ''.
						keywords withIndexDo:
							[:kwd :index |
								codeString _ codeString, ' ', (keywords at: index), ' ',
									'arg', index printString]].
				codeString _ codeString, '
	self codeStrippedOut: ', (messageString surroundedBySingleQuotes).

				aClass compile: codeString classified: 'stripped']]! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/21/2022 14:58:36' prior: 50339755!
           vmStatisticsReportOn: str
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	| params oldSpaceEnd youngSpaceEnd memorySize fullGCs fullGCTime fullGCCompactionTime incrGCs incrGCTime tenureCount upTime
	  upTime2 fullGCs2 fullGCTime2  incrGCs2 incrGCTime2 tenureCount2 freeSize youngSize used spur timeReporter idleMs idleMs2 codeCompactionTime codeCompactionsOrNil codeCompactionTime2 codeCompactions2 maxParams |
	"Pad to protect for a VM that does not answer the expected parameter array"
	maxParams := 63. "max position referenced in this method"
	params := Array streamContents: [ :strm |
				strm nextPutAll: Smalltalk getVMParameters.
				[strm position < maxParams] whileTrue: [strm nextPut: nil]].
	oldSpaceEnd			:= params at: 1.
	youngSpaceEnd		:= params at: 2.
	memorySize			:= params at: 3.
	fullGCs			:= params at: 7.
	fullGCTime			:= params at: 8.
	incrGCs			:= params at: 9.
	incrGCTime			:= params at: 10.
	tenureCount			:= params at: 11.
	fullGCCompactionTime	:= params at: 18.
	codeCompactionsOrNil	:= params at: 62.
	codeCompactionTime	:= params at: 63.
	
	upTime := (params at: 20) ~= 0 "utcMicrosecondClock at startup in later Spur VMs"
				ifTrue: [Time primUtcMicrosecondClock - (params at: 20) + 500 // 1000]
				ifFalse: [Time primMillisecondClock]. "Fall back on old microsecond clock; Good for 47.5 days"
	spur := (params at: 41)
				ifNotNil: [ :p | p anyMask: 16]
				ifNil: [false].
	timeReporter := [:time| | seconds |
					seconds := time / 1000.
					seconds >= (60*60*24)
						ifTrue:
							[str print: seconds / 60 // 60 // 24; nextPut: $d; space;
								print: seconds / 60 // 60 \\ 24; nextPut: $h; space]
						ifFalse:
							[seconds >= (60*60) ifTrue:
								[str print: (seconds / 60 // 60); nextPut: $h; space]].
					str
						print: (seconds / 60 \\ 60) asInteger; nextPut: $m; space;
						print: (seconds \\ 60) asInteger; nextPut: $s].
	str	nextPutAll: 'uptime		'.
	timeReporter value: upTime.
	(idleMs := params at: 16) ~= 0 ifTrue:
		[str tab; nextPutAll: '(runtime '.
		 idleMs := idleMs // 1000.
		 timeReporter value: upTime - idleMs.
		 str nextPutAll: ', idletime '.
		 timeReporter value: idleMs.
		 str nextPut: $)].
	str newLine.

	str	nextPutAll: 'memory			';
		nextPutAll: (self formatVMParameter: memorySize); nextPutAll: ' bytes'; newLine.
	str	nextPutAll:	'	old		';
		nextPutAll: (self formatVMParameter: oldSpaceEnd); nextPutAll: ' bytes (';
		print: oldSpaceEnd / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	spur ifTrue:
		[(youngSize := (params at: 19)  * 7 // 5) = 0 ifTrue: [params at: 44].
		 youngSize := youngSize roundUpTo: 1024.
		 str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: youngSize); nextPutAll: ' bytes (';
			print: youngSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		youngSize := youngSpaceEnd. "used eden"
		freeSize := (params at: 54) + (params at: 44) - youngSize.
		used := youngSize + oldSpaceEnd - freeSize.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: used); nextPutAll: ' bytes (';
			print: used / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: freeSize); nextPutAll: ' bytes (';
			print: freeSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine]
		ifFalse: "Earlier VM and V3 object memory"
		[str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: (youngSpaceEnd - oldSpaceEnd)); nextPutAll: ' bytes (';
			print: (youngSpaceEnd - oldSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: youngSpaceEnd); nextPutAll: ' bytes (';
			print: (youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: (memorySize - youngSpaceEnd)); nextPutAll: ' bytes (';
			print: (memorySize - youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine].

	str	nextPutAll: 'GCs					';
		nextPutAll: (self formatVMParameter: (fullGCs + incrGCs)).
	fullGCs + incrGCs > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime / (fullGCs + incrGCs) fractionDigits: 1; 
			nextPutAll: ' ms between GCs'.
		 idleMs > 0 ifTrue:
			[str
				space;
				print: upTime - idleMs / (fullGCs + incrGCs) fractionDigits: 1; 
				nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime); nextPutAll: ' ms (';
		print: fullGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime)';
		nextPutAll: ', avg '; print: (fullGCTime / (fullGCs max: 1)) fractionDigits: 1; nextPutAll: ' ms'.
	(spur and: [fullGCCompactionTime ~= 0]) ifTrue:
		[str	newLine; nextPutAll: '		marking			';
			nextPutAll: (self formatVMParameter: (fullGCTime - fullGCCompactionTime)); nextPutAll: ' ms (';
			print: (fullGCTime - fullGCCompactionTime) / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: (fullGCTime - fullGCCompactionTime / (fullGCs max: 1)) fractionDigits: 1;
			nextPutAll: ' ms,'; newLine;
			nextPutAll: '		compacting			';
			nextPutAll: (self formatVMParameter: fullGCCompactionTime); nextPutAll: ' ms (';
			print: fullGCCompactionTime / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: fullGCCompactionTime / (fullGCs max: 1) fractionDigits: 1;
			nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime); nextPutAll: ' ms (';
		print: incrGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime), avg '; print: incrGCTime / incrGCs fractionDigits: 1; nextPutAll: ' ms'; newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount).
	tenureCount = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount // (incrGCs max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs // tenureCount; nextPutAll: ' GCs/tenure)']].
	str	newLine.

	codeCompactionsOrNil ifNotNil:
		[str
			nextPutAll: '	code compactions				'.
		codeCompactionsOrNil = 0
			ifTrue: [str
				nextPutAll: codeCompactionsOrNil printString; newLine]
			ifFalse: [str
				nextPutAll: (self formatVMParameter: codeCompactionsOrNil); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime); nextPutAll: ' ms (';
				print: codeCompactionTime / (upTime - idleMs) * 100 fractionDigits: 3;
				nextPutAll: '% runtime), avg '; print: codeCompactionTime / codeCompactionsOrNil fractionDigits: 1; nextPutAll: ' ms'; newLine]].

LastStats ifNil: [LastStats := Array new: 9]
ifNotNil: [
	LastStats size < 9 ifTrue:
		[LastStats := LastStats, (Array new: 9 - LastStats size withAll: 0)].
	upTime2 := upTime - (LastStats at: 1).
	fullGCs2 := fullGCs - (LastStats at: 2).
	fullGCTime2 := fullGCTime - (LastStats at: 3).
	incrGCs2 := incrGCs - (LastStats at: 4).
	incrGCTime2 := incrGCTime - (LastStats at: 5).
	tenureCount2 := tenureCount - (LastStats at: 6).
	idleMs2 := idleMs - (LastStats at: 7).
	codeCompactionsOrNil ifNotNil:
		[codeCompactions2	:= codeCompactionsOrNil - (LastStats at: 8).
		 codeCompactionTime2	:= codeCompactionTime - (LastStats at: 9)].

	str	nextPutAll: 'GCs since last view					';
		nextPutAll: (self formatVMParameter: (fullGCs2 + incrGCs2)).
	fullGCs2 + incrGCs2 > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime2 // (fullGCs2 + incrGCs2); 
			nextPutAll: ' ms between GCs'.
			idleMs2 > 0 ifTrue:
				[str
					nextPutAll: ', ';
					print: upTime2 - idleMs2 // (fullGCs2 + incrGCs2);
					nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str	newLine.
	str	nextPutAll: '	uptime				'; print: (upTime2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, runtime ';		   print: (upTime2 - idleMs2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, idletime ';		   print: (idleMs2 / 1000.0) fractionDigits: 1; nextPutAll: ' s'; newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs2).
	fullGCs2 + fullGCTime2 > 0 ifTrue:
		[str	nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime2); nextPutAll: ' ms (';
			print: fullGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
			nextPutAll: '% runtime)'.
		 str	nextPutAll: ', avg '; print: fullGCTime2 / (fullGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime2); nextPutAll: ' ms (';
		print: incrGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
		nextPutAll: '% runtime), avg '; print: incrGCTime2 / (incrGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'.
	str	newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount2).
	tenureCount2 = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount2 // (incrGCs2 max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs2 // tenureCount2; nextPutAll: ' GCs/tenure)']].
	str	newLine.
	codeCompactionsOrNil ifNotNil:
		[str	nextPutAll: '	code compactions				';
			nextPutAll: (self formatVMParameter: codeCompactions2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime2); nextPutAll: ' ms (';
			print: codeCompactionTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 3;
			nextPutAll: '% runtime)'.
		 codeCompactions2 > 0 ifTrue:
			[str nextPutAll: ', avg '; print: codeCompactionTime2 / codeCompactions2 fractionDigits: 1; nextPutAll: ' ms'; newLine.]]
].
	LastStats := { upTime. fullGCs. fullGCTime. incrGCs. incrGCTime. tenureCount. idleMs. codeCompactionsOrNil. codeCompactionTime }.! !
!Cursor class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 14:59:41' prior: 16834708!
                               resizeForEdge: aSymbol 
	"Cursor resizeForEdge: #top"
	"Cursor resizeForEdge: #bottomLeft"

	"Do not erase this literal, as it helps 'senders' workproperly, and it protects these methods from accidental deletion"
	self nominallyUnsent: #(#resizeBottomCursor #resizeBottomLeftCursor #resizeBottomRightCursor #resizeLeftCursor #resizeRightCursor #resizeTopCursor #resizeTopLeftCursor #resizeTopRightCursor ).
	
	^ self perform: ('resize' , aSymbol capitalized, 'Cursor') asSymbol! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 4/21/2022 15:00:08' prior: 16893855!
  editBalloonHelpContent: aString
	self
		request: 'Edit the balloon help text for ' , self shortPrintString
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])
		do: [:reply|
			(reply isEmpty or: [reply asPlainString = self noHelpString])
				ifTrue: [self setBalloonText: nil]
				ifFalse: [self setBalloonText: reply]]! !
!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 4/21/2022 15:01:58' prior: 16911082!
      keyboardSearch: aChar 
	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |
	nextSelection _ oldSelection _ self getCurrentSelectionIndex.
	max _ self maximumSelection.
	milliSeconds _ Time localMillisecondClock.
	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"
		lastKeystrokes _ ''].
	lastKeystrokes _ lastKeystrokes copyWith: aChar asLowercase.
	lastKeystrokeTime _ milliSeconds.
	nextSelectionList _ OrderedCollection newFrom: (list copyFrom: oldSelection + 1 to: max).
	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).
	"Get rid of blanks and style used in some lists"
	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]
				ifNone: [^ self flash"match not found"].
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [^ self]].
	nextSelection _ list findFirst: [:a | a == nextSelectionText].
	"No change if model is locked"
	oldSelection == nextSelection ifTrue: [^ self flash].
	^ self setSelectionIndex: nextSelection! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 4/21/2022 15:03:31' prior: 16959496!
                 addTileResizerMenuTo: aMenu
	"We can look at preferences here to decide what too do"
	(Preferences tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 		action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 				action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 		action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 	action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asPlainString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].
	^aMenu.! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 4/21/2022 15:04:42' prior: 16821800!
  optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph
			model: self
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		tuple size > 3 ifTrue: [ button setBalloonText: tuple fourth ].
		tuple size > 4 ifTrue: [ button secondaryActionSelector: tuple fifth ].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row
		addMorphs: buttons
		widthProportionalTo: widths.
	^ row.! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 4/21/2022 15:04:52' prior: 16802773 overrides: 50344340!
                   optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 4/21/2022 15:05:08' prior: 16839672!
             customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollection new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 4/21/2022 15:05:23' prior: 16919065!
                            changePriority
	| newPriority rule |
	rule _ (model class rulesFor: model selectedProcess) second.
	rule
		ifFalse: [self inform: 'Nope, won''t change priority of ' , model selectedProcess name.
			^ self].
	self request: 'New priority'
		initialAnswer: model selectedProcess priority printString
		verifying: [:aString| ([aString asNumber asInteger] on: Error do: []) isInteger]
		do: [:aString|
			newPriority _ aString asNumber asInteger.
			(newPriority between: 1 and: Processor highestPriority)
			ifTrue:
				[model class setProcess: model selectedProcess toPriority: newPriority.
				model updateProcessList]
			ifFalse: [self inform: 'Bad priority']]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/21/2022 15:06:17' prior: 16782844!
              calculateWidth

	| width font |

	width _ 120.
	font _ self class listFont.

	1
		to: self entryCount
		do: [ :index | width _ width max: (font widthOfString: (completer entries at: index) asPlainString)].

	self entryCount > self itemsPerPage ifTrue: [ width _ width + ScrollBar scrollbarThickness ].

	^ width ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/21/2022 15:06:25' prior: 16782888!
         drawItemOf: index on: aCanvas width: width top: itemTop

	| rectangle entry |
	
	rectangle _ 1@itemTop extent: width@self itemHeight.
	index = self selected ifTrue: [ aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].

	entry _ completer entries at: index.
	aCanvas
		drawString: entry asPlainString
		at: rectangle topLeft
		font: self class listFont
		color: (self colorOf: entry).
	! !
!TheWorldMenu methodsFor: 'private' stamp: 'jmv 4/21/2022 15:07:11' prior: 16970504!
   pvtNewMenuForSplitLists: splitLists
| firstChar lastChar menu subMenu |
menu := MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstChar := i = 1
				ifTrue: [ $A ]
				ifFalse: [ 
					(splitLists at: i) first name first: 3 ].
			lastChar := i = splitLists size
				ifTrue: [ $Z ]
				ifFalse: [ 
					(splitLists at: i) last name first: 3 ].
			subMenu := MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					action: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: (String with: firstChar) , ' - ' , (String with: lastChar)
				subMenu: subMenu ].
	^ menu.! !
!ChangeRecord methodsFor: 'access' stamp: 'jmv 4/22/2022 12:04:22' prior: 16803213 overrides: 16802727!
          fileOutOn: aFileStream
	"File the receiver out on the given file stream"

	| aString |
	type == #method
		ifTrue: [
			aFileStream newLine; nextPut: $!!.
			aString _  class printString
							, (meta ifTrue: [' class methodsFor: ']
									ifFalse: [' methodsFor: '])
							, category asString printString.
			stamp ifNotNil: [
				aString _ aString, ' stamp: ''', stamp, ''''].
			aFileStream nextChunkPut: aString.
			aFileStream newLine ].

	type == #preamble ifTrue: [ aFileStream nextPut: $!! ].

	type == #classComment
		ifTrue: [
			aFileStream nextPut: $!!.
			aFileStream nextChunkPut: class printString, ' commentStamp: ', stamp storeString.
			aFileStream newLine ].
		
	type == #classDefinition ifTrue: [
		aFileStream nextPut: $!!.
		aFileStream nextChunkPut: 
			'classDefinition: ', 
			(self isMetaClassChange ifTrue: [self changeClassName, ' class'] ifFalse: [self changeClassName]) printString,
			' category: ', self category printString.
		aFileStream newLine ].

	aFileStream nextChunkPut: self string.
	
	type == #method ifTrue: [ aFileStream nextChunkPut: ' '; newLine ].
	type == #classComment ifTrue: [ aFileStream newLine ].
	aFileStream newLine! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 15:08:37' prior: 16806158!
                 postscriptString
	"Answer the string representing the postscript.  "

	^ postscript
		ifNil: [postscript]
		ifNotNil: [postscript actualContents asPlainString]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 15:08:40' prior: 16806172!
        preambleString
	"Answer the string representing the preamble"

	^ preamble
		ifNotNil: [ preamble actualContents asPlainString ]! !
!PseudoClass methodsFor: 'removing' stamp: 'jmv 4/21/2022 15:09:34' prior: 16920866!
       removeAllUnmodified
	| stClass |
	self exists ifFalse:[^self].
	self removeUnmodifiedMethods: self selectors.
	stClass := self realClass.
	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].
	(self hasComment and:[stClass comment asPlainString = self comment asPlainString]) ifTrue:[ self classComment: nil].
	metaClass ifNotNil: [ metaClass removeAllUnmodified]! !
!PseudoClass methodsFor: 'removing' stamp: 'jmv 4/21/2022 15:09:46' prior: 16920880!
                     removeUnmodifiedMethods: aCollection
	| stClass |
	self exists ifFalse:[^self].
	stClass := self realClass.
	aCollection do:[:sel|
		(self sourceCodeAt: sel) = (stClass sourceCodeAt: sel ifAbsent:['']) asPlainString ifTrue:[
			self removeMethod: sel.
		].
	].
	self organization removeEmptyCategories.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5112-AFewMore-JuanVuletich-2022Apr22-12h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5112] on 22 April 2022 at 12:16:44 pm'!
!LabelMorph commentStamp: '<historical>' prior: 16877578!
                    LabelMorph is a "lightweight" Morph to display a String. It supports only a single font, color, and emphasis combination. For multiple text styles, use TextModelMorph or TextParagraphMorph.

Structure:
instance var    	Type              Description 
font 			StrikeFont 		(normally nil; then the accessor #font gives back  a Font or nil #defaultFont) 
emphasis 		SmallInteger	bitmask determining character attributes (underline, bold, 	italics, struckThrough) 
contents 		String 			The text that will be displayed. 
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5113-LabelMorph-comment-JuanVuletich-2022Apr22-12h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5113] on 24 April 2022 at 2:00:40 pm'!
!TheWorldMenu methodsFor: 'private' stamp: 'jmv 4/24/2022 13:59:58' prior: 50344488!
                             pvtNewMenuForSplitLists: splitLists
	| firstPrefix lastPrefix menu subMenu |
	menu _ MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstPrefix _ i = 1
				ifTrue: [ 'A' ]
				ifFalse: [ (splitLists at: i) first name first: 3 ].
			lastPrefix _ i = splitLists size
				ifTrue: [ 'Z' ]
				ifFalse: [ (splitLists at: i) last name first: 3 ].
			subMenu _ MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					action: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: firstPrefix , ' - ' , lastPrefix
				subMenu: subMenu ].
	^ menu.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5114-FixRecentBreakage-JuanVuletich-2022Apr24-13h56m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5114] on 25 April 2022 at 11:13:18 am'!
!Object methodsFor: 'printing' stamp: 'jmv 4/25/2022 10:36:41' prior: 16903030!
                       shortPrintString
	"Answer a String whose characters are a description of the receiver.
	This is a short one, good for showing users (for example, in ObjectExplorers).
	If you want to print without a character limit, use fullPrintString.

	This description is to be meaningful for a Smalltalk programmer and usually includes
	a hint on the class of the object.

	Usually you should not reimplement this method in subclasses, but #printOn:

	See the comments at:
		#printString
		#displayStringOrText
		#asString
		#storeString"

	^ self printStringLimitedTo: 128.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5115-shortPrintString-aBitLarger-JuanVuletich-2022Apr25-10h36m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5114] on 25 April 2022 at 11:04:24 am'!
!Pragma commentStamp: 'HAW 4/25/2022 11:03:54' prior: 16914659!
                       I represent an occurrence of a pragma in a compiled method.  A pragma is a literal message pattern that occurs between angle brackets at the start of a method after any temporaries.  A common example is the primitive pragma:
	<primitive: 123 errorCode: 'errorCode'>
but one can add one's own and use them as metadata attached to a method.  Because pragmas are messages one can browse senders and implementors and perform them.  One can query a method for its pragmas by sending it the pragmas message, which answers an Array of instances of me, one for each pragma in the method.

I can provide information about the defining class, method, its selector, as well as the information about the pragma keyword and its arguments. See the two 'accessing' protocols for details. 'accessing-method' provides information about the method the pragma is found in, while 'accessing-pragma' is about the pragma itself.

Instances are retrieved using one of the pragma search methods of the 'finding' protocol on the class side.

To browse all methods with pragmas in the system evaluate
	Smalltalk browseAllSelect: [:m| m pragmas notEmpty]
and to browse all nonprimitive methods with pragmas evaluate
	Smalltalk browseAllSelect: [:m| m primitive isZero and: [m pragmas notEmpty]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5116-PragmaDocumentationFix-HernanWilkinson-2022Apr25-11h03m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5116] on 30 April 2022 at 7:35:28 pm'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 4/30/2022 19:34:06' prior: 50337402!
                              showBalloon: msgString
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	self world ifNotNil: [ :w |
		self showBalloon: msgString hand: w activeHand ].! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 4/30/2022 19:32:54' prior: 50337589!
             showBalloon: msgStringOrText hand: aHand doWordWrap: aBoolean
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| balloon |
	balloon _ HoverHelpMorph contents: msgStringOrText doWordWrap: aBoolean.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: aHand ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5117-BalloonMorph-tweaks-JuanVuletich-2022Apr30-19h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5117] on 2 May 2022 at 10:45:22 am'!
!CompiledMethod methodsFor: 'source code management' stamp: 'len 4/30/2022 18:38:39' prior: 16829062!
               getPreambleFrom: aFileStream at: position
	|  writeStream c p |
	writeStream _ String new writeStream.
	p _ position - 1.
	c _ nil.
	aFileStream position: p.
	aFileStream atEnd ifTrue: [ ^ nil ].
	[ p >= 0 and: [ c ~~ $!! ]] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		p _ p - 1 ].
	[ p >= 0] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		c == $!!
			ifTrue: [^ writeStream contents reverse ]
			ifFalse: [ writeStream nextPut: c ].
		p _ p - 1 ].
	^ nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5118-MethodPreambleFix-forExclamationMarkSelector-LucianoEstebanNotarfrancesco-2022May02-10h37m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5117] on 1 May 2022 at 1:28:07 pm'!
!Bag methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:24:53' overrides: 16823144!
                               collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. Collect the resulting values into a collection that is like the receiver and nswer the new collection."
	| answer |
	answer _ self species new.
	self withOccurrencesDo: [:each :times| answer add: (aBlock value: each) withOccurrences: times].
	^ answer! !
!Bag methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:25:01' overrides: 16823221!
                     count: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument.  Return the number that answered true."
	| count |
	count _ 0.
	self withOccurrencesDo: [:each :times| (aBlock value: each) ifTrue: [count _ count + times]].
	^ count! !
!Bag methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:22:14'!
 withOccurrencesDo: aBlock
	contents associationsDo: [:each| aBlock value: each key value: each value]! !
!Collection methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:25:40' prior: 16823221!
 count: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument.  Return the number that answered true."
	| count |
	count _ 0.
	self do: [:each| (aBlock value: each) ifTrue: [count _ count + 1]].
	^ count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5119-FasterCollectionCountAndBagCollectAndCount-LucianoEstebanNotarfrancesco-2022May01-13h21m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5119] on 2 May 2022 at 11:17:37 am'!
!Browser methodsFor: 'system category list' stamp: 'len 5/1/2022 14:21:49' prior: 50333979!
               systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories _ self systemCategoryList.
	subcategories _ Dictionary new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollection new]) add: each].
	roots _ OrderedCollection new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5120-systemCategotyRoots-fixRaceCondition-LucianoEstebanNotarfrancesco-2022May02-11h17m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5116] on 28 April 2022 at 12:03:39 pm'!
!ArrayedCollection methodsFor: 'testing' stamp: 'jmv 4/27/2022 10:28:41' overrides: 16823965!
                               isEmpty
	^self size = 0! !
!Interval methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:20:19' overrides: 16823965!
              isEmpty
	^self size = 0! !
!OrderedCollection methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:20:47' overrides: 16823965!
     isEmpty
	^self size = 0! !
!RunArray methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:24:21' overrides: 16823965!
              isEmpty
	^runs size = 0! !
!Text methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:17:59' overrides: 16823965!
                    isEmpty
	^self size = 0! !
!Object methodsFor: 'copying' stamp: 'jmv 4/27/2022 12:36:30' prior: 16901914!
                      copyForClipboard
	"The answer is used both for internal (Smalltalk) and external (Host OS) clipboard.
	Some subclasses might need specific behavior."
	^self copy! !
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 4/28/2022 11:40:04' prior: 16820527!
   annotationForSelector: aSelector ofClass: aClass 
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	^ String streamContents: [ :strm |
		Preferences methodAnnotations
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp _ self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						strm
							print: ((aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm | cm linesOfCode]);
							nextPutAll: ' lines of code' ].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount _ Smalltalk numberOfSendersOf: aSelector.
						sendersCount _ sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount _ implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp _ VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						(aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm |
							(CodePackage packageOfMethod: cm methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList _ (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ] ].! !
!CodeProvider methodsFor: 'commands' stamp: 'jmv 4/28/2022 11:40:20' prior: 16820882!
 removeClass
	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."

	| message  className classToRemove result |
	classToRemove _ self selectedClassOrMetaClass ifNil: [Smalltalk beep. ^ false].
	classToRemove _ classToRemove theNonMetaClass.
	className _ classToRemove name.
	message _ 'Are you certain that you
want to REMOVE the class ', className, '
from the system?'.
	(result _ self confirm: message)
		ifTrue: [
			classToRemove subclasses notEmpty
				ifTrue: [(self confirm: 'class has subclasses: ' , message)
					ifFalse: [^ false]].
			classToRemove removeFromSystem.
			self changed: #classList.
			true].
	^ result! !
!Browser methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:17:38' prior: 16794998 overrides: 16820774!
                       acceptedStringOrText
	"Depending on the current selection, different information is retrieved.
	Answer a string description of that information. This information is the
	method of the currently selected class and message."

	| comment theClass latestCompiledMethod |
	latestCompiledMethod _ currentCompiledMethod.
	currentCompiledMethod _ nil.

	editSelection == #none ifTrue: [^ ''].
	editSelection == #editSystemCategories 
		ifTrue: [^ systemOrganizer printString].
	self isEditingNewClass 
		ifTrue: [^ (theClass _ self selectedClass)
			ifNil: [
				Class template: selectedSystemCategory]
			ifNotNil: [
				Class templateForSubclassOf: theClass category: selectedSystemCategory]].
	self isEditingExistingClass 
		ifTrue: [^ self classDefinitionText ].
	editSelection == #editComment 
		ifTrue: [
			(theClass _ self selectedClass) ifNil: [^ ''].
			comment _ theClass comment.
			currentCompiledMethod _ theClass organization commentRemoteStr.
			^ comment isEmpty
				ifTrue: ['This class has not yet been commented.']
				ifFalse: [comment]].
	editSelection == #editMessageCategories 
		ifTrue: [^ self classOrMetaClassOrganizer printString].
	editSelection == #newMessage
		ifTrue: [
			^ (theClass _ self selectedClassOrMetaClass) 
				ifNil: ['']
				ifNotNil: [theClass sourceCodeTemplate]].
	editSelection == #editMessage
		ifTrue: [
			self showingByteCodes ifTrue: [^ self selectedBytecodes].
			currentCompiledMethod _ latestCompiledMethod.
			^ self selectedMessage].

	self error: 'Browser internal error: unknown edit selection.'! !
!Browser methodsFor: 'class list' stamp: 'jmv 4/27/2022 11:18:00' prior: 50334173!
                            recent
	"Let the user select from a list of recently visited classes.  11/96 stp.
	 12/96 di:  use class name, not classes themselves.
	 : dont fall into debugger in empty case"

	| className class recentList |
	recentList _ self class recentClasses select: [:n | Smalltalk includesKey: n].
	recentList isEmpty ifTrue: [^ Smalltalk beep].
	className _ (SelectionMenu selections: recentList) startUpMenu.
	className ifNil: [^ self].
	class _ Smalltalk at: className.
	self setSelectedSystemCategory: class category.
	self selectClass: class! !
!Browser methodsFor: 'message category functions' stamp: 'jmv 4/27/2022 11:18:05' prior: 16795849!
                              removeMessageCategory
	"If a message category is selected, create a Confirmer so the user can 
	verify that the currently selected message category should be removed
 	from the system. If so, remove it."

	| messageCategoryName |
	selectedMessageCategory ifNil: [^ self].
	messageCategoryName _ self selectedMessageCategoryName.
	(self messageList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this method category 
and all its methods?'])
		ifTrue: [
			self selectedClassOrMetaClass removeCategory: messageCategoryName.
			self messageCategoryListIndex: 0.
			self changed: #classSelectionChanged].
	self changed: #messageCategoryList.
! !
!Browser methodsFor: 'system category functions' stamp: 'jmv 4/28/2022 11:40:27' prior: 50334237!
            moveAllToOtherSystemCategory
	"If a class category is selected, prompt user for category to move to,
	create a Confirmer so the user can verify that all the classes in current category
 	should be moved to the selected category."
	| newSystemCategory |
	selectedSystemCategory ifNil: [ ^ self ].
	newSystemCategory _ Smalltalk systemCategoryFromUserWithPrompt: 'Move classes to System Category...'.
	(newSystemCategory notNil and: [
		self classList notEmpty and: [ self confirm: 'Are you sure you want to
move classes from ' , selectedSystemCategory , ' 
to ' , newSystemCategory , '?' ]]) ifTrue: [
		"Safer this way (#classList will be a collection of strings with spaces and who knows what in the future.  So let's just get the classes we need directly)"
		(SystemOrganization classesAt: selectedSystemCategory) do: [ :eaClass |
			eaClass category: newSystemCategory ].
		self changed: #systemCategoryRoots ].! !
!Browser methodsFor: 'system category functions' stamp: 'jmv 4/27/2022 11:18:09' prior: 50335092!
        removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			"Remove subcategories:"
			systemOrganizer removeCategoriesMatching: selectedSystemCategory, '-*'.
			"Then remove the top category (it doesn't do anything if it doesn't exist):"
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!MessageSet methodsFor: 'private' stamp: 'jmv 4/27/2022 11:18:12' prior: 16886626!
                  setFilteredList: newList
	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"

	newList isEmpty
		ifTrue: [
			^ self inform: 'Nothing would be left in the list if you did that'].
	newList size = messageList size
		ifTrue: [
			^ self inform: 'That leaves the list unchanged'].
	self initializeMessageList: newList.
	self changed: #relabel! !
!MessageNames methodsFor: 'search' stamp: 'jmv 4/28/2022 11:40:38' prior: 16883883!
        computeSelectorListFromSearchString
	"Compute selector list from search string"
	| sorted |
	sorted _ SortedCollection sortBlock: [ :x :y |
		x asLowercase <= y asLowercase ].
	(searchString findBetweenSubStrs: ';') do: [ :selPat | | raw n m |
		selPat notEmpty ifTrue: [
			(selPat first = $" and: [
				selPat last = $" and: [ selPat size > 2 ]])
				ifTrue: [
					Symbol
						hasInterned:
							(selPat
								copyFrom: 2
								to: selPat size - 1)
						ifTrue: [ :sym |
							sorted add: sym ]]
				ifFalse: [
					raw _ ((n _ selPat occurrencesOf: $*) > 0 | ((m _ selPat occurrencesOf: $#) > 0) and: [ selPat size > (n + m) ])
						ifTrue: [ Symbol selectorsMatching: selPat ]
						ifFalse: [ Symbol selectorsContaining: selPat ].
					sorted addAll: raw ]]].
	selectorList _ sorted asArray  select: [ :sym |
		(Smalltalk isThereAnImplementorOf: sym) or: [ Smalltalk isThereAReferenceTo: sym ]].
	^ selectorList.! !
!MessageNames methodsFor: 'selector list' stamp: 'jmv 4/28/2022 11:40:43' prior: 16883930 overrides: 16886320!
              messageList
	"Answer the receiver's message list, computing it if necessary. The way 
	to force a recomputation is to set the messageList to nil"
	messageList
		ifNil: [
			messageList _ selectedSelector
				ifNil: [#()]
				ifNotNil: [
					Smalltalk allImplementorsOf: selectedSelector].
			self initializeMessageList: messageList.
			self messageListIndex: (messageList notEmpty
				ifTrue: [1]
				ifFalse: [0])
			].
	^ messageList! !
!SinglePackageBrowser methodsFor: 'lists' stamp: 'jmv 4/27/2022 11:18:16' prior: 16936688 overrides: 50335818!
                         defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	| answer |
	answer _ selectedSystemCategory
		ifNil: [#()]
		ifNotNil: [
			(package includesSystemCategory: selectedSystemCategory)
				ifTrue: [ systemOrganizer listAtCategoryNamed: selectedSystemCategory ]
				ifFalse: [ 
					package extensionClassNamesIn: (selectedSystemCategory copyFrom: 2 to: selectedSystemCategory size) ]].
	selectedClassName ifNil: [
		answer isEmpty ifFalse: [
			selectedClassName _ answer first.
			self setClassOrganizer.
			self editSelection: #editClass ]].
	^answer! !
!SinglePackageBrowser methodsFor: 'lists' stamp: 'jmv 4/27/2022 11:18:20' prior: 16936711 overrides: 16795936!
                       messageCategoryList
	"Answer the selected category of messages."

	"Do not include the -- all -- category"
	| answer |
	answer _ self rawMessageCategoryList.
	selectedMessageCategory ifNil: [
		answer isEmpty ifFalse: [
			(package includesSystemCategory: selectedSystemCategory) ifFalse: [
				selectedMessageCategory _ answer first ]]].
	^answer! !
!SinglePackageBrowser methodsFor: 'lists' stamp: 'jmv 4/27/2022 11:18:23' prior: 16936725 overrides: 16796114!
                  messageList
	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!) (??), it is reset to zero."

	| answer |
	answer _ selectedMessageCategory
		ifNil: [ #() ]
		ifNotNil: [
			(self classOrMetaClassOrganizer listAtCategoryNamed: selectedMessageCategory) ifNil: [
				selectedMessageCategory _ nil.
				#() ]].
	selectedMessage ifNil: [
		answer isEmpty ifFalse: [
			(package includesSystemCategory: selectedSystemCategory) ifFalse: [
				selectedMessage _ answer first.
				self editSelection: #editMessage ]]].
	^answer! !
!CodeFileBrowser methodsFor: 'removing' stamp: 'jmv 4/27/2022 11:18:26' prior: 16818147 overrides: 50345145!
     removeMessageCategory
	"If a message category is selected, create a Confirmer so the user can 
	verify that the currently selected message category should be removed
 	from the system. If so, remove it."

	| messageCategoryName |
	selectedMessageCategory ifNil: [ ^self ].
	messageCategoryName _ self selectedMessageCategoryName.
	(self messageList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this method category 
and all its methods?']) ifFalse: [^ self].
	self selectedClassOrMetaClass removeCategory: messageCategoryName.
	self messageCategoryListIndex: 0.
	self changed: #messageCategoryList.! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/28/2022 11:41:06' prior: 16801795!
                             destroyCurrentCodeOfSelections
	"Actually remove from the system any in-memory methods with class and selector identical to items current selected.  This may seem rather arcane but believe me it has its great uses, when trying to split out code.  To use effectively, first file out a change set that you wish to split off.  Then open a ChangeList browser on that fileout.  Now look through the methods, and select any of them which you want to remove completely from the system, then issue this command.  For those methods where you have made changes to pre-existing versions, of course, you won't want to remove them from the system, so use this mechanism with care!!"

	|  aClass aChange aList |
	aList _ OrderedCollection new.
	1 to: changeList size do:
		[:index |
			(listSelections at: index) ifTrue:
				[aChange _ changeList at: index.
				(aChange changeType == #method
					and: [(aClass _ aChange changeClass) notNil
					and: [aClass includesSelector: aChange methodSelector]])
						ifTrue:
							[aList add: {aClass. aChange methodSelector}]]].

	aList notEmpty ifTrue: [
		(self confirm: 'Warning!! This will actually remove ', aList size printString,  ' method(s) from the system!!') ifFalse: [^ self]].
	aList do: [ :aPair |
		Transcript newLine; show: 'Removed: ', aPair first printString, '.', aPair second.
		aPair first removeSelector: aPair second ]! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/27/2022 11:18:28' prior: 16801925!
        removeNonSelections
	"Remove the unselected items from the receiver."

	| newChangeList newList |

	newChangeList _ OrderedCollection new.
	newList _ OrderedCollection new.

	1 to: changeList size do: [ :i | 
		(listSelections at: i) ifTrue: [
			newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList isEmpty ifTrue: [
		^ self inform: 'That would remove everything.
Why would you want to do that?'].

	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list

	! !
!ChangeList class methodsFor: 'public access' stamp: 'jmv 4/28/2022 11:40:57' prior: 16802548!
   browseRecentLogOn: origChangesFileEntry
	"figure out where the last snapshot or quit was, then browse the recent entries."

	| end done block positions prevBlock |
	origChangesFileEntry readStreamDo: [ :changesFile |
		positions _ SortedCollection new.
		end _ changesFile size.
		prevBlock _ end.
		block _ end - 1024 max: 0.
		done _ false.
		[ done or: [ positions notEmpty ]]
			whileFalse: [
				changesFile position: block.
				"ignore first fragment"
				changesFile nextChunk.
				[ changesFile position < prevBlock ]
					whileTrue: [
						| pos chunk |
						pos _ changesFile position.
						chunk _ changesFile nextChunk.
						((Smalltalk isQuitRecord: chunk) or: [ Smalltalk isSnapshotRecord: chunk ])
							ifTrue: [ positions add: pos ]].
				block = 0
					ifTrue: [done _ true]
					ifFalse: [
						prevBlock _ block.
						block _ block - 1024 max: 0]].
	].
	self browseRecentLogOn: origChangesFileEntry startingFrom: (positions isEmpty ifTrue: [0] ifFalse: [positions last])! !
!VersionsBrowser methodsFor: 'misc' stamp: 'jmv 4/28/2022 11:41:10' prior: 16978399 overrides: 16820451!
              addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream
	"Add an annotation detailing the prior versions count.  Specially handled here for the case of a selector no longer in the system, whose prior versions are seen in a versions browser -- in this case, the inherited version of this method will not work."

	(aClass includesSelector: aSelector) ifTrue:
		[^ super addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream].

	aStream nextPutAll: 
		((changeList notEmpty
			ifTrue:
				[changeList size = 1
					ifTrue:
						['deleted - one prior version']
					ifFalse:
						['deleted - ', changeList size printString, ' prior versions']]
			ifFalse:
				['surprisingly, no prior versions']))! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 4/27/2022 11:18:31' prior: 16807250!
       rename
	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"

	self request: 'New name for this change set' initialAnswer: myChangeSet name do: [:newName|
		(newName = myChangeSet name or: [newName isEmpty])
			ifTrue: [Smalltalk beep]
			ifFalse:
				[(ChangeSet changeSetNamed: newName) notNil
					ifTrue: [self inform: 'Sorry that name is already used']
					ifFalse:
						[myChangeSet name: newName.
						self update.
						self changed: #mainButtonName.
						self changed: #relabel]]]! !
!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 4/28/2022 11:41:16' prior: 16807489!
       contents: aString notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Create an error if the category of the selected message is unknown. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."
	| category selector class oldSelector |

	(class _ self selectedClassOrMetaClass) ifNil:
		[(myChangeSet preambleString == nil or: [aString isEmpty]) ifTrue: [ ^ false].
		(aString count: [:char | char == $"]) odd 
			ifTrue: [self inform: 'unmatched double quotes in preamble']
			ifFalse: [(Scanner new scanTokens: aString) notEmpty ifTrue: [
				self inform: 'Part of the preamble is not within double-quotes.
To put a double-quote inside a comment, type two double-quotes in a row.
(Ignore this warning if you are including a doIt in the preamble.)']].
		myChangeSet preambleString: aString.
		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"
		^ true].
	oldSelector _ self selectedMessageName.
	category _ class organization categoryOfElement: oldSelector.
	selector _ class compile: aString
				classified: category
				notifying: aRequestor.
	selector ifNil: [^ false].
	(self messageList includes: selector)
		ifTrue: [self currentSelector: selector]
		ifFalse: [self currentSelector: oldSelector].
	self update.
	^ true! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 4/27/2022 11:16:48' prior: 50341894!
           firstCommentAt:  selector
	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."

	| sourceString commentStart  pos nextQuotePos |

	sourceString _ (self sourceCodeAt: selector) asPlainString.
	sourceString isEmpty ifTrue: [^ ''].
	commentStart _ sourceString findString: '"' startingAt: 1.
	commentStart = 0 ifTrue: [^ ''].
	pos _ commentStart + 1.
	[(nextQuotePos _ sourceString findString: '"' startingAt: pos) = (sourceString findString: '""' startingAt: pos)]
		whileTrue:
			[pos _ nextQuotePos + 2].
	
	commentStart = nextQuotePos ifTrue: [^ ''].  "Must have been a quote in string literal"

	^ (sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"'


"Behavior firstCommentAt: #firstCommentAt:"! !
!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'jmv 4/28/2022 11:54:23' prior: 16813851!
removeUninstantiatedSubclassesSilently
	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"
	"Player removeUninstantiatedSubclassesSilently"

	| candidatesForRemoval  oldFree |

	oldFree _ Smalltalk garbageCollect.
	candidatesForRemoval _
		self subclasses select: [:c |
			(c instanceCount = 0) and: [c subclasses isEmpty]].
	candidatesForRemoval do: [:c | c removeFromSystem].
	^ Smalltalk garbageCollect - oldFree! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/27/2022 11:16:54' prior: 16814395!
                           classComment: aString stamp: aStamp
	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."

	| ptr header oldCommentRemoteStr |
	aString isRemote ifTrue: [
		SystemChangeNotifier uniqueInstance classCommented: self.
		^ self organization classComment: aString stamp: aStamp].

	oldCommentRemoteStr _ self organization commentRemoteStr.
	(aString isEmpty) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].
		"never had a class comment, no need to write empty string out"

	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].
	SourceFiles ifNotNil: [ | file |
		(file _ SourceFiles at: 2) ifNotNil: [
			file setToEnd; newLine; nextPut: $!!.	"directly"
			header _ String streamContents: [:strm | strm nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
				aStamp storeOn: strm.
				strm nextPutAll: ' prior: '; nextPutAll: ptr printString].
			file nextChunkPut: header]].
	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
				stream newLine; nextPut: $!!.	"directly"
				header _ String streamContents: [:strm | strm nextPutAll: self name;
					nextPutAll: ' commentStamp: '.
					aStamp storeOn: strm.
					strm nextPutAll: ' prior: '; nextPutAll: ptr printString].
				stream nextChunkPut: header.
				stream newLine; nextChunkPut: aString.
			].
	].
	SystemChangeNotifier uniqueInstance classCommented: self! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:41:33' prior: 16814778!
                  printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod overridesMethod: overridenMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		(changeStamp notNil and: [
			changeStamp notEmpty or: [priorMethod notNil]]) ifTrue: [
			strm nextPutAll: ' stamp: '; print: changeStamp].
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		overridenMethod notNil ifTrue: [
			strm nextPutAll: ' overrides: '; print: overridenMethod sourcePointer]
		]).
! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:41:36' prior: 50342018!
                             printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asPlainString printString]
		ifFalse: [preamble _ ''].
	method _ self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR  -  THIS METHOD IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos _ method filePosition) = 0])
	ifTrue: [
		"The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [ outStream newLine; nextPut: $!!; nextChunkPut: preamble; newLine].
		outStream nextChunkPut: method decompileString]
	ifFalse: [
		sourceFile _ SourceFiles at: method fileIndex.
		preamble size > 0
			ifTrue:    "Copy the preamble"
				[outStream copyPreamble: preamble from: sourceFile at: oldPos]
			ifFalse:
				[sourceFile position: oldPos].
		"Copy the method chunk"
		fileIndex = 0 ifFalse: [
			outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
		newPos _ outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		moveSource ifTrue: [    "Set the new method source pointer"
			endPos _ outStream position.
			method checkOKToAdd: endPos - newPos at: newPos in: method fileIndex.
			method setSourcePosition: newPos inFile: fileIndex]].
	preamble notEmpty ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream newLine! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 4/28/2022 11:41:28' prior: 16815270!
                           chooseInstVarThenDo: aBlock
	"Put up a menu of all the instance variables in the receiver, and when
the user chooses one, evaluate aBlock with the chosen variable as its
parameter.  If the list is 6 or larger, then offer an alphabetical
formulation as an alternative. triggered by a 'show alphabetically' item
at the top of the list."

	| lines labelStream allVars index count offerAlpha |
	(count _ self allInstVarNames size) = 0 ifTrue: 
		[ ^ self inform: 'There are no\instance variables.' withNewLines ].

	allVars _ OrderedCollection new.
	lines _ OrderedCollection new.
	labelStream _ WriteStream on: (String new: 200).

	(offerAlpha _ count > 5)
		ifTrue: [
			lines add: 1.
			allVars add: 'show alphabetically'.
			labelStream nextPutAll: allVars first; newLine].
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class instVarNames.
		vars do: [ :var |
			labelStream nextPutAll: var; newLine.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	labelStream skip: -1 "cut last CR".
	(lines notEmpty and: [ lines last = allVars size ]) ifTrue: [
		lines removeLast ].  "dispense with inelegant line beneath last item"
	index _ (PopUpMenu labels: labelStream contents lines: lines)
startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	(index = 1 and: [offerAlpha]) ifTrue: [
		^ self chooseInstVarAlphabeticallyThenDo: aBlock].
	aBlock value: (allVars at: index)! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:55:06' prior: 16800639!
  categories
	"Answer an Array of categories (names)."
	categoryArray ifNil: [^ nil].
	(categoryArray size = 1 
		and: [categoryArray first = Default & elementArray isEmpty])
		ifTrue: [^Array with: NullCategory].
	^categoryArray! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:56:23' prior: 16800761!
   classify: element under: heading suppressIfDefault: aBoolean
	"Store the argument, element, in the category named heading.   If aBoolean is true, then invoke special logic such that the classification is NOT done if the new heading is the Default and the element already had a non-Default classification -- useful for filein"

	| catName catIndex elemIndex realHeading |
	
	realHeading _ (heading = NullCategory or: [heading isNil])
		ifTrue: [Default]
		ifFalse: [heading withBlanksTrimmed ].
	
	"done if already under that category"
	(catName _ self categoryOfElement: element) = realHeading ifTrue: [^ self].  

	catName ifNotNil: [
		"return if non-Default category already assigned in memory"
		(aBoolean and: [realHeading = Default]) ifTrue: [^ self].	 
		"remove if in another category"
		self removeElement: element].

	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].

	catIndex _ categoryArray indexOf: realHeading.
	elemIndex _ catIndex > 1
		ifTrue: [categoryStops at: catIndex - 1]
		ifFalse: [0].
	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 
		and: [element >= (elementArray at: elemIndex)]] whileTrue.

	"elemIndex is now the index for inserting the element. Do the insertion before it."
	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1 with: (Array with: element).

	"add one to stops for this and later categories"
	catIndex to: categoryArray size do: [ :i |
		categoryStops at: i put: (categoryStops at: i) + 1].

	(self listAtCategoryNamed: Default) isEmpty ifTrue: [self removeCategory: Default]! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:57:18' prior: 16800936!
                 removeCategory: cat 
	"Remove the category named, cat. Create an error notificiation if the 
	category has any elements in it."

	| index lastStop |
	index _ categoryArray indexOf: cat ifAbsent: [^self].
	lastStop _ 
		index = 1
			ifTrue: [0]
			ifFalse: [categoryStops at: index - 1].
	(categoryStops at: index) - lastStop > 0 
		ifTrue: [^self error: 'cannot remove non-empty category'].
	categoryArray _ categoryArray copyReplaceFrom: index to: index with: #().
	categoryStops _ categoryStops copyReplaceFrom: index to: index with: #().
	categoryArray isEmpty
		ifTrue: [
			categoryArray _ Array with: Default.
			categoryStops _ Array with: 0]
! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:57:31' prior: 16800989!
                            removeEmptyCategories
	"Remove empty categories."

	| categoryIndex currentStop keptCategories keptStops |
	keptCategories _ WriteStream on: (Array new: 16).
	keptStops _ WriteStream on: (Array new: 16).
	currentStop _ categoryIndex _ 0.
	[(categoryIndex _ categoryIndex + 1) <= categoryArray size]
		whileTrue: 
			[(categoryStops at: categoryIndex) > currentStop
				ifTrue: 
					[keptCategories nextPut: (categoryArray at: categoryIndex).
					keptStops nextPut: (currentStop _ categoryStops at: categoryIndex)]].
	categoryArray _ keptCategories contents.
	categoryStops _ keptStops contents.
	categoryArray isEmpty
		ifTrue: [
			categoryArray _ Array with: Default.
			categoryStops _ Array with: 0]

	"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories]."! !
!Categorizer methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:54:54' prior: 16801129!
  hasAnyCategoriesSuchThat: aBlock
	"Answer an Array of categories (names)."
	categoryArray ifNil: [^ false].
	(categoryArray size = 1 
		and: [categoryArray first = Default & elementArray isEmpty])
		ifTrue: [^false].
	^categoryArray anySatisfy: aBlock! !
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:17:01' prior: 16784585!
   classComment: aString 
	"Store the comment, aString, associated with the object that refers to the 
	receiver."

	aString ifNil: [ ^classComment _ nil ].
	
	aString isRemote
		ifTrue: [classComment _ aString]
		ifFalse: [aString isEmpty
			ifTrue: [classComment _ nil]
			ifFalse: [
				self error: 'use aClass classComment:'.
				classComment _ RemoteString newString: aString onFileNumber: 2]]
				"Later add priorSource and date and initials?"! !
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:51:03' prior: 16784602!
classComment: aString  stamp: aStamp
	"Store the comment, aString, associated with the object that refers to the receiver."

	self commentStamp: aStamp.
	aString isRemote
		ifTrue: [classComment _ aString]
		ifFalse: [(aString isNil or: [aString isEmpty])
			ifTrue: [classComment _ nil]
			ifFalse:
				[self error: 'use aClass classComment:'.
				classComment _ RemoteString newString: aString onFileNumber: 2]]
				"Later add priorSource and date and initials?"! !
!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:50:53' prior: 16958717!
                 fileOutCategory: category on: aFileStream initializing: aBool
	"Store on the file associated with aFileStream, all the classes associated 
	with the category and any requested shared pools."

	| first poolSet tempClass classes |
	classes _ (self superclassOrderIn: category).
	poolSet _ Set new.
	classes do: [ :class |
		class sharedPools do: [:eachPool | poolSet add: eachPool]].
	poolSet notEmpty ifTrue: [
		tempClass _ Class new.
		tempClass shouldFileOutPools ifTrue:
			[poolSet _ poolSet select: [:aPool | tempClass shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool)].
			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].
	first _ true.
	classes do: [ :class | 
		first
			ifTrue: [first _ false]
			ifFalse: [aFileStream newLine; nextPut: Character newPage; newLine].
		class
			fileOutOn: aFileStream
			moveSource: false
			toFile: 0
			initializing: false].
	aBool ifTrue: [classes do:[:cls| cls fileOutInitializerOn: aFileStream]].! !
!MessageTally methodsFor: 'collecting leaves' stamp: 'jmv 4/28/2022 11:57:41' prior: 16887320!
        leavesInto: leafDict fromSender: senderTally

	| rcvrs |
	rcvrs _ self sonsOver: 0.
	rcvrs isEmpty
		ifTrue: [ self into: leafDict fromSender: senderTally ]
		ifFalse: [
			rcvrs do: [ :node |
				node isPrimitives
					ifTrue: [ node leavesInto: leafDict fromSender: senderTally ]
					ifFalse: [ node leavesInto: leafDict fromSender: self ]]]! !
!MessageTally methodsFor: 'comparing' stamp: 'jmv 4/28/2022 11:57:47' prior: 16887361!
             sonsOver: threshold

	| hereTally sons |
	(receivers isNil or: [ receivers isEmpty ]) ifTrue: [ ^#() ].
	hereTally _ tally.
	sons _ receivers select: [ :son | "subtract subNode tallies for primitive hits here"
		hereTally _ hereTally - son tally.
		son tally > threshold ].
	hereTally > threshold
		ifTrue: [
			| last |
			last _ MessageTally new class: class method: method.
			^sons copyWith: (last primitives: hereTally)].
	^sons! !
!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:31:06' prior: 16933587!
          first
	"Answer the first element of the receiver.
	Raise an error if the collection is empty."

	self isEmpty ifTrue: [self errorEmptyCollection].
	^ self at: 1! !
!String methodsFor: 'converting' stamp: 'jmv 4/27/2022 11:17:18' prior: 16948079!
          asIdentifier: shouldBeCapitalized
	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"

	| aString |
	aString _ self select: [ :el | el isValidInIdentifiers ].
	(aString isEmpty or: [aString first isValidStartOfIdentifiers not])
		ifTrue:	 [aString _ 'a', aString].
	^ shouldBeCapitalized ifTrue: [ aString capitalized ] ifFalse: [ aString uncapitalized ]

"
'234Fred987' asIdentifier: false
'235Fred987' asIdentifier: true
'' asIdentifier: true
'()87234' asIdentifier: false
'())z>=PPve889  U >' asIdentifier: false
"! !
!String methodsFor: 'converting' stamp: 'jmv 4/28/2022 11:58:20' prior: 16948492!
 initialIntegerOrNil
	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"
	| firstNonDigit |
	(self isEmpty or: [self first isDigit not]) ifTrue: [^ nil].
	firstNonDigit _ (self findFirst: [:m | m isDigit not]).
	firstNonDigit = 0 ifTrue: [firstNonDigit _ self size + 1].
	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber
"
'234Whoopie' initialIntegerOrNil
'wimpy' initialIntegerOrNil
'234' initialIntegerOrNil
'2N' initialIntegerOrNil
'2' initialIntegerOrNil
'  89Ten ' initialIntegerOrNil
'78 92' initialIntegerOrNil
"
! !
!String methodsFor: 'system primitives' stamp: 'jmv 4/28/2022 11:58:24' prior: 16949086!
              findSubstring: key in: body startingAt: start matchTable: matchTable
	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."
	| index |
	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>
	self var: #key declareC: 'unsigned char *key'.
	self var: #body declareC: 'unsigned char *body'.
	self var: #matchTable declareC: 'unsigned char *matchTable'.

	key isEmpty ifTrue: [^ 0].
	start to: body size - key size + 1 do:
		[:startIndex |
		index _ 1.
			[(matchTable at: (body at: startIndex+index-1) numericValue + 1)
				= (matchTable at: (key at: index) numericValue + 1)]
				whileTrue:
				[index = key size ifTrue: [^ startIndex].
				index _ index+1]].
	^ 0
"
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7
"! !
!String methodsFor: 'system primitives' stamp: 'jmv 4/28/2022 11:58:30' prior: 16949134!
   numArgs
	"Answer either the number of arguments that the receiver would take if considered a selector. 
	Answer -1 if it couldn't be a selector. 
		Note that currently this will answer -1 for anything begining with an uppercase letter even though 
		the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."
	| firstChar numColons start ix |
	self isEmpty ifTrue: [ ^ -1 ].
	"Binary messages"
	(self allSatisfy: [ :c | c isValidInBinarySelectors ])
		ifTrue: [ ^1 ].
	"Unary and keyword messages"
	firstChar _ self at: 1.
	firstChar isValidStartOfIdentifiers ifTrue: [
		"Fast reject if any chars are non-alphanumeric"
		(self
			findSubstring: '~'
			in: self
			startingAt: 1
			matchTable: Tokenish) > 0 ifTrue: [ ^ -1 ].
		"Fast colon count"
		numColons _ 0.
		start _ 1.
		[
		(ix _ self
			findSubstring: ':'
			in: self
			startingAt: start
			matchTable: CaseSensitiveOrder) > 0 ] whileTrue: [
			numColons _ numColons + 1.
			start _ ix + 1 ].
		^ numColons ].
	^ -1.! !
!Symbol methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:58:35' prior: 16950692!
precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise.  The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c _ self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last = $: ifTrue: [^ 3].
	^ 1! !
!RunArray methodsFor: 'copying' stamp: 'jmv 4/28/2022 11:32:23' prior: 16928416 overrides: 16934134!
                               , aRunArray 
	"Answer a new RunArray that is a concatenation of the receiver and
	aRunArray."

	| new newRuns answer |
	(aRunArray isMemberOf: RunArray)
		ifFalse: [
			new _ self copy.
			"attempt to be sociable"
			aRunArray do: [:each | new addLast: each].
			^new].
	self isEmpty ifTrue: [^aRunArray copy].
	aRunArray isEmpty ifTrue: [^self copy].
	(self canJoin: (values at: values size) and: (aRunArray values at: 1))
		ifFalse: [ 
			answer _ RunArray
				runs: runs , aRunArray runs
				values: values , aRunArray values.
			answer canJoinMessage: canJoinMessage.
			^answer ].
	newRuns _ runs
					copyReplaceFrom: runs size
					to: runs size
					with: aRunArray runs.
	newRuns at: runs size put: (runs at: runs size) + (aRunArray runs at: 1).
	answer _ RunArray
		runs: newRuns
		values: 
			(values
				copyReplaceFrom: values size
				to: values size
				with: aRunArray values).
	answer canJoinMessage: canJoinMessage.
	^answer! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:15:58' prior: 16963558!
                               rangeOf: attribute startingAt: index
	"Answer an interval that gives the range of attribute at index position  index. An empty interval with start value index is returned when the attribute is not present at position index."
	^ self isEmpty
		ifTrue: [ index to: index - 1 ]
		ifFalse: [
			runs
				rangeOf: attribute
				startingAt: index ].! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:14:34' prior: 16963588 overrides: 16822799!
  size
	^runs size! !
!Text methodsFor: 'emphasis' stamp: 'jmv 4/27/2022 11:15:29' prior: 16963817!
                              addAttribute: att 
	self isEmpty ifTrue: [ ^self ].
	^ self addAttribute: att from: 1 to: self size! !
!Text methodsFor: 'emphasis' stamp: 'jmv 4/27/2022 10:36:29' prior: 16963844!
           attributesAt: characterIndex
	"Answer the code for characters in the run beginning at characterIndex."

	self isEmpty
		ifTrue: [^ #()].  "null text tolerates access"
	^runs at: characterIndex! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/28/2022 11:34:00' prior: 16954570!
 removeAllUnSentMessages
	"Smalltalk removeAllUnSentMessages"
	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 
	Smalltalk removeAllUnSentMessages > 0] whileTrue."
	"Remove all implementations of unsent messages."
	| sels n |
	sels _ self allUnSentMessages.
	self presumedSentMessages
		do: [:sel | sels
				remove: sel
				ifAbsent: nil].
	sels isEmpty
		ifTrue: [^ 0].
	n _ 0.
	Smalltalk
		allBehaviorsDo: [:x | n _ n + 1].
	'Removing ' , sels size printString , ' messages . . .'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: n
		during: [:barBlock | 
			n _ 0.
			self
				allBehaviorsDo: [:class | 
					barBlock value: (n _ n + 1).
					sels
						do: [:sel | class removeSelector: sel]]].
	^ sels size! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 4/28/2022 11:43:21' prior: 16956553!
                             browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix _ caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList _ OrderedCollection new.
	Smalltalk allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList notEmpty
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/28/2022 11:59:14' prior: 16942120!
      writeClassRenameMethod: sel was: oldName fromInstVars: oldList 
	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "

	| tell choice newName answ code oldVer newList newVer instSel |
	self flag: #bobconv.
	tell := 'Reading an instance of ' , oldName 
				, '.
Which modern class should it translate to?'.
	answ := (PopUpMenu 
				labels: 'Let me type the name now
Let me think about it
Let me find a conversion file on the disk') 
					startUpWithCaption: tell.
	answ = 1 
		ifTrue: [
			tell := 'Name of the modern class {1} should translate to:' format: {oldName}.
			choice := self request: tell initialAnswer: ''.	"class name"
			choice isEmpty 
				ifTrue: [answ := 'conversion method needed']
				ifFalse: [
					newName := choice.
					answ := Smalltalk at: newName asSymbol
								ifAbsent: ['conversion method needed'].
					answ class == String 
						ifFalse: [renamed at: oldName asSymbol put: answ name]]].
	answ = 3 | (answ = 0) 
		ifTrue: [
			byteStream close.
			^'conversion method needed'].
	answ = 2 ifTrue: [answ := 'conversion method needed'].
	answ = 'conversion method needed' 
		ifTrue: [
			byteStream close.
			newName := 'PutNewClassHere'].
	answ class == String 
		ifFalse: 
			[oldVer := self versionSymbol: (structures at: oldName).
			newList := (Array with: answ classVersion) , answ allInstVarNames.
			newVer := self versionSymbol: newList.
			instSel := 'convert' , oldVer , ':' , newVer , ':'].
	code := WriteStream on: (String new: 500).
	code
		nextPutAll: sel;
		newLine.
	answ class == String 
		ifFalse: [
			code
				newLine;
				tab;
				nextPutAll: 'reshaped at: #' , oldName , ' put: #' , instSel , '.'.
			code
				newLine;
				tab;
				tab;
				nextPutAll: '"Be sure to define that conversion method in class ' 
							, answ name , '"'].
	code
		newLine;
		tab;
		nextPutAll: '^ ' , newName.	"Return new class"
	self class compile: code contents classified: 'conversion'.
	newName = 'PutNewClassHere' 
		ifTrue: [
			self 
				inform: 'Please complete the following method and 
then read-in the object file again.'.
			Smalltalk browseAllImplementorsOf: sel asSymbol].
	self flag: #violateBasicLayerPrinciples.
	"SmartRefStream should not refer to UI!!!!!!!!!! (sd)"

	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  
	If this is true for class Foo, define classVersion in Foo class.  
	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."
	^answ! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/28/2022 12:00:17' prior: 16942217!
                            writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify."

	| code newOthers oldOthers copied |

	code _ WriteStream on: (String new: 500).
	code nextPutAll: 'convertToCurrentVersion: varDict refStream: smartRefStrm'; newLine; tab.
	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollection new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code nextPutAll: '"These variables are automatically stored into the new instance '.
	code nextPutAll: copied asArray printString; nextPut: $. .
	code newLine; tab; nextPutAll: 'This method is for additional changes.'; 
		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; newLine; newLine; tab.
	newOthers isEmpty & oldOthers isEmpty ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withNewLines].
	oldOthers notEmpty ifTrue: [
		code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in some other variable?"'].

	code newLine; tab.
	code nextPutAll: '^ super convertToCurrentVersion: varDict refStream: smartRefStrm'.
	newClass compile: code contents classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/28/2022 12:01:29' prior: 16942294!
                writeConversionMethodIn: newClass fromInstVars: oldList to: newList renamedFrom: oldName
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify.  If method exists, append new info into the end."

	| code newOthers oldOthers copied newCode |

	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollection new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code _ WriteStream on: (String new: 500).
	code newLine; newLine; tab; nextPutAll: '"From ', SystemVersion current version, ' [', Smalltalk lastUpdateString;
			nextPutAll: '] on ', Date today printString, '"'; newLine.
	code tab; nextPutAll: '"These variables are automatically stored into the new instance: '.
	code nextPutAll: copied asArray printString; nextPut: $.; newLine.
	code tab; nextPutAll: 'Test for this particular conversion.'; 
		nextPutAll: '  Get values using expressions like (varDict at: ''foo'')."'; newLine; newLine.
	newOthers isEmpty & oldOthers isEmpty & oldName isNil ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"New variables: ', newOthers asArray printString, 
			'.  If a non-nil value is needed, please assign it."'; newLine].
	oldOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"These are going away ', oldOthers asArray printString, 
			'.  Possibly store their info in some other variable?"'; newLine].
	oldName ifNotNil: [
		code tab; nextPutAll: '"Test for instances of class ', oldName, '.'; newLine.
		code tab; nextPutAll: 'Instance vars with the same name have been moved here."'; newLine.
		].
	code tab; nextPutAll: '"Move your code above the ^ super...  Delete extra comments."'; newLine. 

	(newClass includesSelector: #convertToCurrentVersion:refStream:) 
		ifTrue: ["append to old methods"
			newCode _ (newClass sourceCodeAt: #convertToCurrentVersion:refStream:),
				code contents]
		ifFalse: ["new method"
			newCode _ 'convertToCurrentVersion: varDict refStream: smartRefStrm',
				code contents, 
				'	^ super convertToCurrentVersion: varDict refStream: smartRefStrm'].
	newClass compile: newCode classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 4/27/2022 11:16:07' prior: 16967238!
                       setSearchString: aKeyboardEvent
	"Establish the current selection as the current search string."

	| aString |
	self lineSelectAndEmptyCheck: [^ true].
	aString _  self selectedString.
	aString isEmpty
		ifTrue: [ self flash ]
		ifFalse: [ self setSearch: aString ].
	^ true! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 4/28/2022 12:02:31' prior: 16939767!
                  explainAnySel: symbol 
	"Is this any message selector?"

	| list reply |
	list _ Smalltalk allClassesImplementing: symbol.
	list isEmpty ifTrue: [^nil].
	list size < 12
		ifTrue: [reply _ ' is a message selector which is defined in these classes ' , list printString]
		ifFalse: [reply _ ' is a message selector which is defined in many classes'].
	^'#' , symbol , reply , '.\' withNewLines, 'Smalltalk browseAllImplementorsOf: #' , symbol! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 4/28/2022 12:02:24' prior: 16940388!
       explain
	"Try to shed some light on what kind of entity the current selection is. 
	The selection must be a single token or construct. Insert the answer after 
	the selection. Send private messages whose names begin with 'explain' 
	that return a string if they recognize the selection, else nil."

	| string tiVars cgVars selectors delimitors numbers sorry reply symbol provider |
	sorry _ 'Sorry, I can''t explain that.  Please select a single
token, construct, or special character.'.
	(string _ self selectedString) isEmpty
		ifTrue: [reply _ '']
		ifFalse: [
			string _ string withBlanksTrimmed.
			"Remove space, tab, cr"
			"Temps and Instance vars need only test strings that are all letters"
			(string detect: [:char | char isValidInIdentifiers not]
				ifNone: nil) ifNil: [
					tiVars _ (self explainTemp: string)
						ifNil: [self explainInst: string]].
					
			provider _ self codeProvider.
			(tiVars == nil and: [provider respondsTo: #explainSpecial:])
				ifTrue: [tiVars _ provider explainSpecial: string].
			tiVars _ tiVars
				ifNil: [ '']
				ifNotNil: [ tiVars , '\' withNewLines].
			"Context, Class, Pool, and Global vars, and Selectors need 
			only test symbols"
			(Symbol hasInterned: string ifTrue: [:s | symbol _ s])
				ifTrue: [
					cgVars _ (self explainCtxt: symbol) 
						ifNil: [ (self explainClass: symbol)
							ifNil: [ self explainGlobal: symbol]].
					"See if it is a Selector (sent here or not)"
					selectors _ (self explainMySel: symbol)
						ifNil: [(self explainPartSel: string)
							ifNil: [ self explainAnySel: symbol]]]
				ifFalse: [selectors _ self explainPartSel: string].
			cgVars _ cgVars
				ifNil: [ '']
				ifNotNil: [cgVars , '\' withNewLines].
			selectors _ selectors
				ifNil: [ '']
				ifNotNil: [ selectors , '\' withNewLines].
			delimitors _ string size = 1
				ifTrue: ["single special characters"
					self explainChar: string]
				ifFalse: ["matched delimitors"
					self explainDelimitor: string].
			numbers _ self explainNumber: string.
			numbers ifNil: [numbers _ ''].
			delimitors ifNil: [delimitors _ ''].
			reply _ tiVars , cgVars , selectors , delimitors , numbers].
	reply isEmpty ifTrue: [reply _ sorry].

	morph showBalloon: reply.
	self runningWorld ifNotNil: [ :w | w findATranscript ].
	reply print! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 4/27/2022 11:16:19' prior: 16940586!
    selectedSymbol
	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"

	| aString |
	self hasSelection ifFalse: [^ nil].
	aString _ self selectedString withoutSeparators.
	aString isEmpty ifTrue: [^ nil].
	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].

	^ nil! !
!AbstractFont methodsFor: 'measuring' stamp: 'jmv 4/28/2022 11:37:16' prior: 16777264!
                   approxWidthOfText: aText
	"Return the width of aText -- quickly, and a little bit dirty.
	Used by lists morphs containing Text objects to get a quick,
	fairly accurate measure of the width of a list item."
	| w |
	(aText isNil or: [ aText isEmpty ]) ifTrue: [ ^ 0 ].
	w _ self
		widthOfString: aText string
		from: 1
		to: aText size.
	"If the text has no emphasis, just return the string size.  If it is empasized, 
	just approximate the width by adding about 20% to the width"
	^ ((aText runLengthFor: 1) = aText size and: [ (aText emphasisAt: 1) = 0 ])
		ifTrue: [ w ]
		ifFalse: [ w * 6 // 5 ]! !
!Morph methodsFor: 'copying' stamp: 'jmv 4/27/2022 12:36:40' prior: 16891826 overrides: 50344903!
     copyForClipboard
	"The answer is used both for internal (Smalltalk) and external (Host OS) clipboard.
	Some subclasses might need specific behavior."

	self okayToDuplicate ifFalse: [ ^ nil ].
	^self copy! !
!Morph methodsFor: 'structure' stamp: 'jmv 4/28/2022 11:37:24' prior: 16894727!
veryLastLeaf
	"Answer the last submorph, recursively, i.e. the very last leaf of the morph tree"

	^submorphs isEmpty
		ifTrue: [ self ]
		ifFalse: [ submorphs last veryLastLeaf ]! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 4/28/2022 11:37:39' prior: 16869919 overrides: 16794207!
                              drawOn: aCanvas

	listItems isEmpty ifTrue: [ ^self ].
 
	self drawHighlightOn: aCanvas.
	self drawSelectionOn: aCanvas.

	(self topVisibleRowForCanvas: aCanvas)
		to: (self bottomVisibleRowForCanvas: aCanvas)
		do: [ :row |
			(owner itemSelectedAmongMultiple:  row) ifTrue: [
				self drawBackgroundForMulti: row on: aCanvas. ].
			self draw: (self item: row) displayStringOrText atRow: row on: aCanvas ]! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 4/28/2022 11:38:45' prior: 16822366!
             showUnreferencedClassVars
	"Search for all class variables known to the selected class, and put up a 
	list of those that have no references anywhere in the system. The 
	search includes superclasses, so that you don't need to navigate your 
	way to the class that defines each class variable in order to determine 
	whether it is unreferenced"
	| cls aList |
	(cls _ model selectedClass)
		ifNil: [^ self].
	aList _ cls allUnreferencedClassVariables.
	aList isEmpty
		ifTrue: [^ self inform: 'There are no unreferenced
class variables in
' , cls name].
	Transcript newLine; nextPutAll: 'Unreferenced class variable(s) in ', cls name; newLine.
	aList do: [:el | Transcript tab; nextPutAll: el; newLine].
	(SelectionMenu labels: aList selections: aList)
		startUpWithCaption: 'Unreferenced
class variables in 
' , cls name! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 4/28/2022 11:38:41' prior: 16822395!
              showUnreferencedInstVars
	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"

	| cls aList |
	(cls _ model selectedClassOrMetaClass) ifNil: [^ self].
	aList _ cls allUnreferencedInstanceVariables.
	aList isEmpty ifTrue: [^ self inform: 'There are no unreferenced
instance variables in
', cls name].
	Transcript newLine; nextPutAll: 'Unreferenced instance variable(s) in ', cls name; newLine.
	aList do: [ :el | Transcript tab; nextPutAll: el; newLine ].
	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferenced
instance variables in 
', cls name! !
!CodeWindow methodsFor: 'misc' stamp: 'jmv 4/28/2022 11:38:49' prior: 16822517!
           selectMessageAndEvaluate: aBlock
	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"

	| selector method messages |
	(selector _ model selectedMessageName) ifNil: [^ self].
	method _ (model selectedClassOrMetaClass ifNil: [^ self])
		compiledMethodAt: selector
		ifAbsent: nil.
	(method isNil or: [(messages _ method messages) isEmpty])
		 ifTrue: [^ aBlock value: selector].
	(messages size = 1 and: [messages includes: selector])
		ifTrue:
			[^ aBlock value: selector].  "If only one item, there is no choice"

	Smalltalk
		showMenuOf: messages
		withFirstItem: selector
		ifChosenDo: aBlock! !
!ChangeListWindow methodsFor: 'menu commands' stamp: 'jmv 4/28/2022 11:38:37' prior: 16802819!
               browseCurrentVersionsOfSelections
	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"
	| aList |

	aList _ model currentVersionsOfSelections.

	aList isEmpty ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].
	MessageSetWindow
		openMessageListUnsorted: aList 
		label: 'Current versions of selected methods in ', model file localName! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:45:06' prior: 16805858!
        fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	nameToUse _ self name.
	nameToUse _ nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse _ Preferences changeSetVersionNumbers
				ifTrue: [
					DirectoryEntry currentDirectory
						nextNameFor: nameToUse coda: '-', Utilities authorInitials
						extension: 'cs.st' ]
				ifFalse: [ (nameToUse , '.' , Utilities dateTimeSuffix , '.cs.st') asFileName ].
		
	nameToUse asFileEntry writeStreamDo: [ :stream |
		stream timeStamp.
		self fileOutPreambleOn: stream.
		self fileOutOn: stream.
		self fileOutPostscriptOn: stream ].
	
	self hasUnsavedChanges: false.
	Preferences checkForSlips
		ifFalse: [^ self].
	slips _ self checkForSlips.
	(slips notEmpty
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ]! !
!TestResult methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:45:14' prior: 16962189!
                 hasErrors

	^self errors notEmpty
			! !
!TestResult methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:45:19' prior: 16962192!
    hasFailures

	^self failures notEmpty
			! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5121-isEmpty-notEmpty-JuanVuletich-2022Apr28-11h46m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5117] on 28 April 2022 at 1:02:03 pm'!
!Editor methodsFor: 'new selection' stamp: 'jmv 4/28/2022 13:00:57' prior: 16845824!
                       wordRangeLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters startingAt: pointIndex
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter finalDelimiter direction match level string here hereChar start stop sSize |
	string _ self privateCurrentString.
	sSize _ string size.
	sSize < 2 ifTrue: [^1 to: 1].
	here _ pointIndex min: sSize max: 2.
	initialDelimiter _ string at: here - 1.
	match _ leftDelimiters indexOf: initialDelimiter.
	match > 0
		ifTrue: [
			"delimiter is on left -- match to the right"
			start _ here.
			direction _ 1.
			here _ here - 1.
			finalDelimiter _ rightDelimiters at: match]
		ifFalse: [
			initialDelimiter _ string at: here.
			match _ rightDelimiters indexOf: initialDelimiter.
			match > 0
				ifTrue: [
					"delimiter is on right -- match to the left"
					stop _ here - 1.
					direction _ -1.
					finalDelimiter _ leftDelimiters at: match]
				ifFalse: [
					"no delimiters -- select a token"
					direction _ -1]].
	level _ 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar _ string at: (here _ here + direction).
			match = 0
				ifTrue: [
					"token scan goes left, then right"
					hereChar isValidInIdentifiers 	"Consider $: as a word separator"
						ifTrue: [
							here = 1
								ifTrue: [
									start _ 1.
									"go right if hit string start"
									direction _ 1]]
						ifFalse: [
							direction < 0
								ifTrue: [
									start _ here + 1.
									"go right if hit non-token"
									direction _ 1]
								ifFalse: [level _ 0]]]
				ifFalse: [
					"delimiter match just counts nesting level"
					hereChar = finalDelimiter
						ifTrue: [level _ level - 1"leaving nest"]
						ifFalse: [
							hereChar = initialDelimiter 
								ifTrue: [level _ level + 1"entering deeper nest"]]]].
	level > 0 ifTrue: [
		leftDelimiters size + rightDelimiters size = 0 ifFalse: [
			"If we failed to find final delimiter, then just select word."
			^self wordRangeLeftDelimiters: '' rightDelimiters: '' ].
		here _ here + direction ].
	^ direction > 0
		ifTrue: [
			"If a word ends with $: (a keyword), consider it part of the word"
			hereChar = $: ifTrue: [here _ here + 1].
			start to: here - 1]
		ifFalse: [
			"But if a word starts with $: (this is the argument to a keyword), then it is not part of the word."
			here + 1 to: stop]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5122-Tweak-JuanVuletich-2022Apr28-12h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5118] on 29 April 2022 at 10:44:57 am'!
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 09:52:23'!
                   fixLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings. Replace each occurence with a single Lf.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') fixLineEndings
	('Hello ', String crString, 'World') fixLineEndings
	('Hello ', String lfString, 'World') fixLineEndings
	"
	(self includes: `Character cr`) ifFalse: [ ^self ].
	(self includesSubString: `String crlfString`) ifTrue: [ "A new instance is needed"
		^ self withLineEndings: `String newLineString` ].
	self replaceAll: `Character cr` with: `Character lf`.! !
!Text methodsFor: 'converting' stamp: 'jmv 4/29/2022 10:01:15'!
                    fixLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') asText fixLineEndings
	('Hello ', String crString, 'World') asText fixLineEndings
	('Hello ', String lfString, 'World') asText fixLineEndings
	"

	| newText |
	(string includes: `Character cr`) ifFalse: [ ^self ].
	newText _ self.
	(string includesSubString: `String crlfString`) ifTrue: [ "A new instance is needed"
		newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false ].
	newText string replaceAll: `Character cr` with: `Character lf`.
	^newText! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 10:07:10' prior: 16948729!
         withCuisLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings.
	Answer a new instance, replacing each occurence with a single Lf.
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"

	^ self withLineEndings: `String newLineString`.! !
!Text methodsFor: 'converting' stamp: 'jmv 4/29/2022 10:07:03' prior: 50342278!
      withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ `String crlfString detect: [ :char | (char = Character newLineCharacter) not ]`.
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false.
	newText string replaceAll: wrongLineEnd with: `Character newLineCharacter`.
	^newText! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5123-CuisLineEndings-tweaks-JuanVuletich-2022Apr29-10h42m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5121] on 29 April 2022 at 2:36:20 pm'!
!String methodsFor: 'accessing' stamp: 'jmv 4/26/2022 15:36:45' overrides: 16781630!
                        byteSize
	^self size! !
!String methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:10:55'!
       isLastLineSeparator
	^self last isLineSeparator! !
!String methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:51:10'!
            isLastSeparator
	^self last isSeparator! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:10:09'!
                      isLastLineSeparator
	^string isLastLineSeparator! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:51:16'!
             isLastSeparator
	^string isLastSeparator! !
!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 4/28/2022 17:14:48' prior: 16965367!
                   composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY text: argText extentForComposing: argExtentForComposing

	lines _ argLinesCollection.
	theText _ argText.
	extentForComposing _ argExtentForComposing.
	deltaCharIndex _ argDelta.
	currCharIndex _ startCharIndex _ argStart.
	stopCharIndex _ argStop.
	prevLines _ argPriorLines.
	currentY _ argStartY.
	maxRightX _ 0.
	possibleSlide _ stopCharIndex < theText size.
	nowSliding _ false.
	prevIndex _ 1.
	scanner _ CompositionScanner new text: theText.
	scanner defaultFont: self defaultFont.
	isFirstLine _ currCharIndex = 1 or: [
		 (theText at: currCharIndex-1) isLineSeparator ].
	anythingComposed _ false.
	self composeAllLines.
	(anythingComposed not or: [ theText isLastLineSeparator ])
		ifTrue: [
			self addEmptyTrailingLine: true ]
		ifFalse: [
			scanner lastLineBreakingSpace = theText size ifTrue: [
				self addEmptyTrailingLine: false ]].
	^ {lines asArray. maxRightX}

! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5124-String-Text-Tweaks-JuanVuletich-2022Apr29-14h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5120] on 29 April 2022 at 12:15:53 pm'!
!BitBlt methodsFor: 'private' stamp: 'jmv 4/26/2022 10:21:11'!
        primFaiDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta

	| ascii glyph |
	startIndex to: stopIndex do: [ :charIndex |
		ascii _ (aString at: charIndex) numericValue.
		glyph _ glyphMap at: ascii + 1.
		sourceX _ xTable at: glyph + 1.
		width _ (xTable at: glyph + 2) - sourceX.
		self copyBits.
		destX _ destX + width + kernDelta.
	].! !
!BitBlt methodsFor: 'private' stamp: 'jmv 4/26/2022 10:20:59' prior: 16788357!
           primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta

	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>
	self primFaiDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5125-BitBlt-tweak-JuanVuletich-2022Apr29-12h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5121] on 29 April 2022 at 5:08:17 pm'!
!Object methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:22:00'!
       isStringLike
	"Overridden to return true in String, and StringUtf8."
	^ false! !
!String methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:22:03' overrides: 50347215!
                            isStringLike
	^ true! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 11:25:37'!
    retrieveObject: stringClass
	"Answer whatever was last stored in the clipboard"
	| stringOrNil |

	"If the OS clipboard has the id for our contents, or the same characters, then answer the richer Smalltalk object.
	Note: if the (extended) clipboard contains a serialized object, it shouldn't contain an id, so
	it is deserialized even if ivar contents contains the object. This is done to guarantee consistency with pasting
	from another Cuis image."
	stringOrNil _ self retrieveIdOrStringFromOS: stringClass.
	(stringOrNil = (self idFor: contents) or: [ stringOrNil = contents or: [(contents is: #Text) and: [stringOrNil = contents string]]])
		ifTrue: [
			"We copy the object, because the result of each paste operation could be modified independently of the others afterwards
			(and the same clipboard contents might be pasted many times)"
			^contents copyForClipboard ].

	"If we have the ExtendedClipboardInterface, try to get an RTF or Form"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface retrieveObject ifNotNil: [ :object | ^object ]].

	"Otherwise answer the string brought by clipboard primitives,
	but if they are not present or fail, use the internal clipboard."
	^stringOrNil ifNil: [ contents copyForClipboard ]! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 11:35:19'!
                     retrieveStringOrText: stringClass
	"Answer a Text or a String. Appropriate for a Text Editor."
	| answer |
	
	answer _ self retrieveObject: stringClass.
	
	"If clipboard contents is already a Text or String, answer it."
	(answer isStringLike or: [ answer is: #Text ]) ifTrue: [
		^answer ].
	
	"If clipboard contains a Morph, answer a TextAnchor incuding it..."
	(answer is: #Morph) ifTrue: [
		^ (Text string: (stringClass with: $*) attribute: (TextAnchor new anchoredFormOrMorph: answer)) ].
	
	"If clipboard contains a Form, prepare a Text including it."
	(answer is: #Form) ifTrue: [
		^Text withForm: answer ].
	
	"Answer some string..."
	^answer ifNil: [ stringClass new ] ifNotNil: [ answer printString ]! !
!Clipboard methodsFor: 'private' stamp: 'jmv 4/29/2022 11:20:20'!
                   retrieveIdOrStringFromOS: stringClass
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| utf8Bytes classForUtf8Bytes |
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].

	utf8Bytes _ self primitiveClipboardString.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard."
	utf8Bytes isEmpty ifTrue: [ ^nil ].

	"Clipboard primitive answers an instance of String containing the UTF-8 bytes.
	If not pure ASCII, contents are invalid!! Convert it ASAP into a reasonable ByteArray or StringUtf8."
	classForUtf8Bytes _ stringClass == String ifTrue: [ ByteArray ] ifFalse: [ stringClass ].
	utf8Bytes class format = classForUtf8Bytes format  												"True unless image is in 32bit V3 format"
		ifTrue: [ classForUtf8Bytes adoptInstance: utf8Bytes ]
		ifFalse: [ utf8Bytes _ classForUtf8Bytes withAll: utf8Bytes ].
	^ (stringClass fromUtf8: utf8Bytes) fixLineEndings.! !
!Clipboard class methodsFor: 'default clipboard' stamp: 'jmv 4/29/2022 10:51:54'!
        retrieveStringOrText: stringClass
	"Answer a Text or a String. Appropriate for a Text Editor."
	^self default retrieveStringOrText: stringClass! !
!String class methodsFor: 'instance creation' stamp: 'jmv 4/29/2022 11:09:47' prior: 16949926!
              fromUtf8: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | bytes codePoint |
		bytes _ aByteArray readStream.
		[ bytes atEnd ] whileFalse: [
			codePoint _ (Character nextUnicodeCodePointFromUtf8: bytes).
			codePoint ifNotNil: [
				"Add just one char if possible, or the apropriate sequence for the NCR"
				self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ]].
		(doTrimLastNullChar and: [ codePoint = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!Editor methodsFor: 'menu messages' stamp: 'jmv 4/29/2022 11:04:30' prior: 16845671!
       clipboardStringOrText

	| clipContents |
	clipContents _ Clipboard retrieveStringOrText: self privateCurrentString class.
	^ ((clipContents is: #Text) and: [ clipContents respondsTo: #asNonStyledText ])
		ifTrue: [ clipContents asNonStyledText ]
		ifFalse: [ clipContents ]! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 11:01:29' prior: 16816278!
                       retrieveMorph
	"Answer a Morph or nil."
	| answer |
	
	answer _ self retrieveObject: String.
	
	"If clipboard contents is already a Text or String, answer it."
	(answer is: #Morph) ifTrue: [
		^ answer ].

	"If clipboard contains a Form, prepare a Morph including it."
	(answer is: #Form) ifTrue: [
		^ ImageMorph new image: answer ].

	"If clipboard contents is already a Text or String, answer it."
	(answer isString or: [ answer is: #Text ]) ifTrue: [
		^ (TextModelMorph withText: answer asText)
			embeddedInMorphicWindowLabeled: 'Text editor' ].
	
	"No useful contents"
	^nil! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 17:06:14' prior: 16816299!
   retrieveObject
	"Answer whatever was last stored in the clipboard"
	^self retrieveObject: String! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 17:07:21' prior: 16816338!
        retrieveStringOrText
	"Answer a Text or a String. Appropriate for a Text Editor."
	^self retrieveStringOrText: String! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 12:18:43' prior: 16816361!
                   storeObject: anObject
	"Set new contents on the clipboard.  Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isStringLike or: [ anObject is: #Text])
		ifTrue: [
			contents _ anObject withCuisLineEndings.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id _ self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat _ (self stringOrIdFor: contents) asUtf8: true.
	self primitiveClipboardString: primitiveFormat! !
!Clipboard methodsFor: 'private' stamp: 'jmv 4/29/2022 11:38:58' prior: 16816488!
                      stringOrIdFor: anObject
	"
	Clipboard default stringOrIdFor: Smalltalk
	"
	anObject isStringLike ifTrue: [ ^anObject ].
	(anObject is: #Text) ifTrue: [ ^anObject string ].
	^self idFor: anObject! !
!Clipboard class methodsFor: 'default clipboard' stamp: 'jmv 1/18/2011 23:40' prior: 16816541!
                           retrieveObject
	"Answer whatever was last stored in the clipboard"
	^self default retrieveObject! !
!Clipboard class methodsFor: 'default clipboard' stamp: 'jmv 4/29/2022 10:52:56' prior: 16816547!
                          retrieveStringOrText
	"Answer a Text or a String. Appropriate for a Text Editor.
	By default, use String class for Strings"

	^self retrieveStringOrText: String! !

Clipboard removeSelector: #retrieveIdOrStringFromOS!

!methodRemoval: Clipboard #retrieveIdOrStringFromOS stamp: 'Install-5126-Clipboard-StringClassAgnostic-JuanVuletich-2022Apr29-17h05m-jmv.001.cs.st 5/16/2022 10:22:24'!
retrieveIdOrStringFromOS
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| primitiveFormat |

	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].
		
	primitiveFormat _ self primitiveClipboardString asByteArray.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard.
	We prefer nil"
	primitiveFormat isEmpty ifTrue: [ ^nil ].

	"The VM uses UTF-8 for clipboard"
	^(String fromUtf8: primitiveFormat hex: false trimLastNull: true) withCuisLineEndings!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5126-Clipboard-StringClassAgnostic-JuanVuletich-2022Apr29-17h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5121] on 29 April 2022 at 2:45:16 pm'!
!Editor methodsFor: 'private' stamp: 'jmv 4/29/2022 11:43:42'!
      stringClassToUse
	^String! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 11:43:56' overrides: 50347536!
            stringClassToUse
	^self privateCurrentString class! !
!Editor methodsFor: 'menu messages' stamp: 'jmv 4/29/2022 11:44:02' prior: 50347374!
                     clipboardStringOrText

	| clipContents |
	clipContents _ Clipboard retrieveStringOrText: self stringClassToUse.
	^ ((clipContents is: #Text) and: [ clipContents respondsTo: #asNonStyledText ])
		ifTrue: [ clipContents asNonStyledText ]
		ifFalse: [ clipContents ]! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 11:55:16' prior: 16846076!
                        newLine: aKeyboardEvent

	self addString: (self stringClassToUse with: Character newLineCharacter).
	^false! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 11:48:32' prior: 50341338!
                    normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	self addString: (self stringClassToUse with: aKeyboardEvent keyCharacter).
	^false! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 12:00:04' prior: 16846089!
    returnKey: aKeyboardEvent
	"Return / Enter / key was pressed"
	"Process the various Return / Enter keystrokes"
	
	morph acceptOnCR ifTrue: [
		^ true].
	aKeyboardEvent commandAltKeyPressed ifTrue: [
		(aKeyboardEvent controlKeyPressed | aKeyboardEvent rawMacOptionKeyPressed) ifTrue: [
			self addString: self stringClassToUse crString.
			^false ].
		self addString: self stringClassToUse crlfString.
		^false ].
	^ self newLine: aKeyboardEvent! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 4/29/2022 12:00:22' prior: 16966542!
       enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (self stringClassToUse with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (self stringClassToUse with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^ true! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 4/29/2022 12:00:54' prior: 16966598!
                            inOutdent: aKeyboardEvent delta: delta
	"Add/remove a tab at the front of every line occupied by the selection. 
	Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"
	"This is a user command, and generates undo"

	| realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |

	"Operate on entire lines, but remember the real selection for re-highlighting later"
	realStart _ self startIndex.
	realStop _ self stopIndex - 1.

	"Special case: the text cursor on a line of its own, including weird case at end of paragraph"
	(realStart > realStop and: [
				realStart < 2 or: [(self privateCurrentString at: realStart - 1) isLineSeparator ]])
		ifTrue: [
			delta < 0
				ifTrue: [
					morph flash]
				ifFalse: [
					self replaceSelectionWith: Character tab asSymbol.
					self deselectAndPlaceCursorAt: realStart + 1].
			^true].

	lines _ textComposition lines.
	startLine _ textComposition lineIndexFor: realStart.
	stopLine _ textComposition lineIndexFor: (realStart max: realStop).
	start _ (lines at: startLine) first.
	stop _ (lines at: stopLine) last.
	
	"Pin the start of highlighting unless the selection starts a line"
	adjustStart _ realStart > start.

	"Find the indentation of the least-indented non-blank line; never outdent more"
	indentation _ (startLine to: stopLine) inject: 1000 into: [ :previousValue :each |
		previousValue min: (textComposition indentationOfLineIndex: each ifBlank: [ :tabs | 1000 ])].			

	size _  stop + 1 - start.
	numLines _ stopLine + 1 - startLine.
	inStream _ ReadStream on: self privateCurrentString from: start to: stop.

	newString _ self stringClassToUse new: size + ((numLines * delta) max: 0).
	outStream _ ReadWriteStream on: newString.

	"This subroutine does the actual work"
	self indent: delta fromStream: inStream toStream: outStream.

	"Adjust the range that will be highlighted later"
	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].
	realStop _ realStop + outStream position - size.

	"Prepare for another iteration"
	indentation _ indentation + delta.
	size _ outStream position.
	inStream _ outStream setFrom: 1 to: size.

	outStream
		ifNil: [ 	"tried to outdent but some line(s) were already left flush"
			morph flash]
		ifNotNil: [
			self selectInvisiblyFrom: start to: stop.
			size = newString size ifFalse: [newString _ outStream contents].
			self replaceSelectionWith: newString].
	self selectFrom: realStart to: realStop. 	"highlight only the original range"
	^ true! !
!TextEditor methodsFor: 'typing support' stamp: 'jmv 4/28/2022 17:10:31' prior: 16967347!
                 setEmphasisHereFromTextForward: f

	| i forward delta prevIsLineSeparator nextIsLineSeparator prevIsSeparator nextIsSeparator nextChar prevChar |
	i _ self pointIndex.
	"Try to set emphasisHere correctly after whitespace.
	Most important after a cr, i.e. at the start of a new line"
	prevIsLineSeparator _  i > 1 and: [ (prevChar _ model actualContents at: i-1) isLineSeparator ].
	nextIsLineSeparator _ i <= model textSize and: [ (nextChar _ model actualContents at: i) isLineSeparator ].
	prevIsSeparator _  i > 1 and: [ prevChar isSeparator ].
	nextIsSeparator _ i <= model textSize and: [ nextChar isSeparator ].
	prevIsLineSeparator & nextIsLineSeparator
		ifTrue: [
			"Empty paragraph: take emphasis from the newLine character"
			forward _ false ]
		ifFalse: [
			prevIsSeparator == nextIsSeparator
				ifTrue: [
					"Space at both sides, or non-space at both sides, take emphasis used where the cursor comes from"
					forward _ f ]
				ifFalse: [
					"Space at one side and non-space at the other, take emphasis from the non-space character"
					forward _ nextIsSeparator ]].
	delta _ forward ifTrue: [ 1 ] ifFalse: [ 0 ].
	emphasisHere _ (model actualContents attributesAt: (i - delta max: 1))
					select: [:att | att mayBeExtended].
	morph possiblyChanged! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 12:00:32' prior: 16967581!
                  firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine _ textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine _ currentLine first.
	endOfIndentation _ self privateCurrentString
		skipDelimiters: (self stringClassToUse with: Character tab)
		startingAt: beginningOfLine.
		
	stops _ OrderedCollection with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/29/2022 12:01:03' prior: 16939450!
                             doItSourceCodeFor: aSourceCode in: anEvaluationContext

	^self stringClassToUse streamContents: [ :stream |
		Scanner doItSourceCodeHeaderWithContext: anEvaluationContext notNil into: stream.
		stream nextPutAll: aSourceCode ]! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 11:48:00' prior: 16940869 overrides: 50347557!
newLine: aKeyboardEvent
	"Replace the current text selection with a newLine (i.e. LF) followed by as many tabs
	as there are leading tabs on the current line (+/- bracket count)."

	| char s i tabCount stopIndex newLineString |
	s _ self privateCurrentString.
	stopIndex _ self stopIndex.
	i _ stopIndex.
	tabCount _ 0.
	[ (i _ i-1) > 0 and: [ (char _ s at: i) isLineSeparator not ] ] whileTrue: [
		"Count brackets"
		char = $[ ifTrue: [tabCount _ tabCount + 1].
		char = $] ifTrue: [tabCount _ tabCount - 1]].
	[ (i _ i + 1) < stopIndex and: [ (char _ s at: i) isSeparator ] ] whileTrue: [
		"Count leading tabs"
		char = Character tab ifTrue: [ tabCount _ tabCount + 1 ]].
	"Now inject newline with tabCount tabs, generating a new undoable command"
	newLineString _ self stringClassToUse streamContents: [ :strm | strm newLineTab: tabCount ].
	model startNewUndoRedoCommand.
	self replaceSelectionWith: newLineString.
	^ false! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 12:01:36' prior: 50341369 overrides: 50347564!
 normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| stopIndex startIndex string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string _ self privateCurrentString.
	stopIndex _ self pointIndex - 1.
	(stopIndex between: 2 and: string size)
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	startIndex _ stopIndex.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	[startIndex > 0 and: [stopIndex - startIndex < 7 and: [(string at: startIndex) isLetter]]] whileTrue: [startIndex _ startIndex - 1].
	(startIndex > 0 and: [(string at: startIndex) = $\])
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	key _ string copyFrom: startIndex+1 to: stopIndex.
	(Character namedCharactersTable detect: [:one| key = one first] ifNone: [])
		ifNotNil: [:aPair| self selectFrom: startIndex to: stopIndex; replaceSelectionWith: (self stringClassToUse with: aPair second)].
	^ super normalCharacter: aKeyboardEvent! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5127-stringClassToUse-JuanVuletich-2022Apr29-14h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5123] on 29 April 2022 at 5:21:48 pm'!
!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 4/29/2022 16:42:11' prior: 16933908!
 replaceAll: oldObject with: newObject 
	"Replace all occurences of oldObject with newObject"
	| index |
	index _ self indexOf: oldObject startingAt: 1.
	[index = 0] whileFalse: [
		self at: index put: newObject.
		index _ self indexOf: oldObject startingAt: index + 1 ].! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 15:07:16' prior: 16948222!
                            asUtf8
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	See #fromUtf8: "

	^self asUtf8: true.! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 16:20:22' prior: 50347084!
           withCuisLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings.
	Answer a new instance, replacing each occurence with a single Lf.
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"
	^ self withLineEndings: `String newLineString`.! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 15:00:21' prior: 16948740!
     withDescriptiveLineEndings
	"
	('Hello', String newLineString, 'World') withDescriptiveLineEndings
	"
	^ self withLineEndings: '[enter]'! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 16:36:42' prior: 50347420!
storeObject: anObject
	"Set new contents on the clipboard.  Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isStringLike or: [ anObject is: #Text])
		ifTrue: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id _ self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat _ (self stringOrIdFor: contents) asUtf8: true.
	self primitiveClipboardString: primitiveFormat! !

Text removeSelector: #fixLineEndings!

!methodRemoval: Text #fixLineEndings stamp: 'Install-5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st 5/16/2022 10:22:24'!
fixLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') asText fixLineEndings
	('Hello ', String crString, 'World') asText fixLineEndings
	('Hello ', String lfString, 'World') asText fixLineEndings
	"

	| newText |
	(string includes: `Character cr`) ifFalse: [ ^self ].
	newText _ self.
	(string includesSubString: `String crlfString`) ifTrue: [ "A new instance is needed"
		newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false ].
	newText string replaceAll: `Character cr` with: `Character lf`.
	^newText!

Text removeSelector: #withCuisLineEndings!

!methodRemoval: Text #withCuisLineEndings stamp: 'Install-5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st 5/16/2022 10:22:24'!
withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ `String crlfString detect: [ :char | (char = Character newLineCharacter) not ]`.
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false.
	newText string replaceAll: wrongLineEnd with: `Character newLineCharacter`.
	^newText!

Text removeSelector: #copyReplaceTokens:with:!

!methodRemoval: Text #copyReplaceTokens:with: stamp: 'Install-5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st 5/16/2022 10:22:24'!
copyReplaceTokens: oldSubstring with: newSubstring 
	"Replace all occurrences of oldSubstring that are surrounded
	by non-alphanumeric characters"
	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true
	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5116] on 29 April 2022 at 11:09:13 pm'!

Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont '
	classVariableNames: 'ChangeText FindText '
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #TextEditor category: #'System-Text' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont'
	classVariableNames: 'ChangeText FindText'
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX selectionStartBlocks selectionStopBlocks editor showTextCursor lastTextCursorRect selectionStopBlock selectionStartBlock '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!

!classDefinition: #TextComposition category: #'Morphic-Text Support' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX selectionStartBlocks selectionStopBlocks editor showTextCursor lastTextCursorRect selectionStopBlock selectionStartBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!
!TextComposition methodsFor: 'selection' stamp: 'jmv 4/29/2022 23:08:43'!
              selectionStartBlock: startBlock selectionStopBlock: stopBlockBlock
	selectionStartBlock _ startBlock.
	selectionStopBlock _ stopBlockBlock.! !
!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/29/2022 21:27:07' prior: 16966134!
                            replaceSelectionWith: aTextOrString
	"Deselect, and replace the selection text by aText."
	"This is a user command, and generates undo"

	| start stop replacement |

	morph disablesEditing ifTrue: [
		^ self ].

	start _ self startIndex.
	stop _ self stopIndex.
	(aTextOrString isEmpty and: [stop > start]) ifTrue: [
		"If deleting, then set emphasisHere from 1st character of the deletion"
		emphasisHere _ (model actualContents attributesAt: start) select: [:att |
			att mayBeExtended]].

	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [
		replacement _ self addAttributesForPasting: aTextOrString.
		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.
		textComposition
			recomposeFrom: start
			to:  start + replacement size - 1
			delta: replacement size - (stop-start).
		self deselectAndPlaceCursorAt: start + replacement size.
		self userHasEdited  " -- note text now dirty" ].

	morph possiblyChanged! !
!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/29/2022 21:11:48' prior: 16966168!
selectionRectangle
	"Answer a rectangle that encompasses selection.
	If no selection, answer a rectangle that includes cursor."
	^ markBlock quickMerge: pointBlock! !
!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/29/2022 21:19:42' prior: 16966211!
                          hasSelection
	^ markBlock ~= pointBlock! !
!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/29/2022 21:11:09' prior: 16966256!
                      selection
	"Answer the text that is currently selected."

	| t firstIndex lastIndex |
	t _ model actualContents.
	firstIndex _ self startIndex.
	lastIndex _ self stopIndex - 1.
	(firstIndex = 1 and: [ lastIndex = t size ])
		ifTrue: [ ^t copy ].
	^t copyFrom: firstIndex to: lastIndex! !
!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/29/2022 21:11:20' prior: 16966281!
 selectionAsStream
	"Answer a ReadStream on the text that is currently  selected."

	^ReadWriteStream
		on: self privateCurrentString
		from: self startIndex
		to: self stopIndex - 1! !
!TextEditor methodsFor: 'current selection' stamp: 'jmv 4/29/2022 21:24:19' prior: 16966445!
          recomputeSelection
	"The same characters are selected but their coordinates may have changed."

	self markIndex: self markIndex pointIndex: self pointIndex.! !
!TextEditor methodsFor: 'events' stamp: 'jmv 4/29/2022 21:09:43' prior: 16966785!
              mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	| b |

	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.

	b _ textComposition characterBlockAtPoint: localEventPosition.
	(textComposition clickAt: localEventPosition) ifTrue: [
		markBlock _ b.
		pointBlock _ b.
		aMouseButtonEvent hand releaseKeyboardFocus: self.
		^ self ].
	
	aMouseButtonEvent shiftPressed
		ifFalse: [
			markBlock _ b.
			pointBlock _ b.	
			self setEmphasisHereFromText ]! !
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/29/2022 21:27:48' prior: 16966960!
             cut
	"Cut out the current selection and redisplay if necessary."
	"This is a user command, and generates undo"

	| selection |
	self lineSelectAndEmptyCheck: [^ self].
	selection _ self selection.
	self replaceSelectionWith: self nullText.
	self clipboardTextPut: selection.! !
!TextEditor methodsFor: 'new selection' stamp: 'jmv 4/29/2022 21:20:22' prior: 16967119 overrides: 16845686!
                             lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectLine.  "if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !
!TextEditor methodsFor: 'new selection' stamp: 'jmv 4/29/2022 21:09:06' prior: 16967139!
                        messageSendsRanges: aRanges
	"aRanges must be notEmpty"
	| lastRange |

	lastRange := nil.
	aRanges do: [ :range |
		( lastRange isNil or: [ range first > lastRange first ]) ifTrue: [
			lastRange _ range ]].

	self selectFrom: lastRange first to: lastRange last! !
!TextEditor methodsFor: 'new selection' stamp: 'jmv 4/29/2022 21:20:50' prior: 16967185!
                             selectLine
	"Make the receiver's selection, if currently empty, encompass the current line."
	self hasSelection ifTrue:[^self].
	self selectInterval: (model actualContents encompassLine: self selectionInterval)! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 21:23:52' prior: 16967462!
                       applyAttribute: aTextAttribute
	"The user selected aTextAttribute via shortcut, menu or other means.
	If there is a selection, apply the attribute to the selection.
	In any case use the attribute for the user input (emphasisHere)"
	"This generates undo"
	| anythingDone interval |

	morph disablesEditing ifTrue: [
		^ self ].

	anythingDone _ false.
	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.

	interval _ self selectionInterval.
	(interval notEmpty or: [ aTextAttribute isParagraphAttribute ])
		ifTrue: [
			anythingDone _ true.
			model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.
			textComposition recomposeFrom: interval first to: interval last delta: 0 ].

	anythingDone ifTrue: [
		self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
		self userHasEdited ].

	"Even if nothing done, emphasisHere might have changed"
	morph possiblyChanged.! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 21:25:57' prior: 16967513!
findAndReplaceMany: doMany
	"Subroutine of search: and again.  Use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."
	"jmvnote: We currently have no command for search&replace, but it is really easy to add, and this method supports it. See ChangeText"
	"This is a user command, and generates undo"

	|  indexStream |

	"Find and Change, recording start indices in the array"
	indexStream _ WriteStream on: (Array new: 20). "an array to store change locs"
	[(self findAndReplaceOnce: indexStream) & doMany] whileTrue. "<-- this does the work"
	"Answer whether something was found"
	^indexStream notEmpty! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 21:08:01' prior: 16967545!
                   findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where _ model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [Preferences caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 23:00:53' prior: 16967741!
                       storeSelectionInComposition
	"for proper display of selected text"

	pointBlock ifNil: [ ^self ].
	textComposition
		selectionStartBlock: self startBlock
		selectionStopBlock: self stopBlock.! !
!TextEditor methodsFor: 'initialization' stamp: 'jmv 4/29/2022 21:27:58' prior: 16968037 overrides: 16920235!
               initialize
	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.
	defaultFont _ FontFamily defaultFamilyAndPointSize! !
!TextEditor methodsFor: 'initialization' stamp: 'jmv 4/29/2022 21:28:03' prior: 16968047!
                resetState
	"Establish the initial conditions for editing the paragraph: place text cursor 
	before first character and set the emphasis to that of the first character"

	markBlock _ textComposition defaultCharacterBlock.
	pointBlock _ markBlock.! !
!TextComposition methodsFor: 'display' stamp: 'jmv 4/29/2022 23:08:30' prior: 16965626!
              displaySelectionInLine: line on: aCanvas textTopLeft: textTopLeft  selectionColor: sc

	"textTopLeft is relative to the morph currently being drawn"
	selectionStartBlock ifNotNil: [
		self
			displaySelectionStartBlock: selectionStartBlock
			stopBlock: selectionStopBlock
			InLine: line
			on: aCanvas
			textTopLeft: textTopLeft
			selectionColor: sc ].! !
!TextComposition methodsFor: 'selection' stamp: 'jmv 4/29/2022 23:05:56' prior: 16965867!
                              selectionRects
	"Return an array of rectangles representing the selection regions."
	^ Array streamContents: [ :strm |
		selectionStartBlock ifNotNil: [
			self addSelectionRectsFrom: selectionStartBlock to: selectionStopBlock to: strm ]].! !
!TextComposition methodsFor: 'initialization' stamp: 'jmv 4/29/2022 23:08:39' prior: 16965971 overrides: 16920235!
                          initialize
	showTextCursor _ false.
	selectionStartBlock _ nil.
	selectionStopBlock _ nil.! !

TextComposition removeSelector: #selectionStartBlocks:selectionStopBlocks:!

!methodRemoval: TextComposition #selectionStartBlocks:selectionStopBlocks: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectionStartBlocks: startBlocks selectionStopBlocks: stopBlockBlocks
	selectionStartBlocks _ startBlocks.
	selectionStopBlocks _ stopBlockBlocks.!

SmalltalkEditor removeSelector: #selection!

!methodRemoval: SmalltalkEditor #selection stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selection
	"Answer the text that is currently selected.
	Redefined for Smalltalk code: if there's no regular selection, and all the selectionBlocks contain the same string,
	answer that string."
	| t regularSelection allPartsEqual samePart firstIndex |
	t _ model actualContents.
	firstIndex _ self startIndex.
	lastIndex _ self stopIndex - 1.

	(firstIndex = 1 and: [ lastIndex = t size ])
		ifTrue: [ ^t copy ].

	regularSelection _ ( t copyFrom: firstIndex to: lastIndex).
	allPartsEqual _ true.
	samePart _ nil.
	^Text streamContents: [ :strm |
		"Multiple selection"
		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock | | toAppend |
			toAppend _ t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1.
			toAppend size > 0 ifTrue: [
				samePart
					ifNil: [ samePart _ toAppend ]
					ifNotNil: [
						allPartsEqual _ allPartsEqual and: [ samePart = toAppend ]].
				strm nextPutAll: toAppend.
				strm withAttributes: (toAppend attributesAt: toAppend size) do: [ strm newLine ]].
			].
		(allPartsEqual and: [ regularSelection isEmpty ]) ifTrue: [
			^samePart ifNil: [ '' asText ]].
		"Regular selection"
		strm nextPutAll: regularSelection ]!

TextEditor removeSelector: #zapMultiSelection!

!methodRemoval: TextEditor #zapMultiSelection stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
zapMultiSelection
	"This generates undo"

	| delta intervals mi pi start stop miAndPiUpdated |
	miAndPiUpdated _ false.
	mi _ self markIndex.
	pi _ self pointIndex.
	delta _ 0.
	intervals _ (selectionStartBlocks with: selectionStopBlocks
		collect: [ :strt :stp | strt stringIndex to: stp stringIndex ])
			sorted: [ :a :b | a first < b first ].
	intervals do: [ :interval |
		miAndPiUpdated not ifTrue: [
			interval first > mi
				ifTrue: [
					miAndPiUpdated _ true.
					mi _ mi + delta.
					pi _ pi + delta ]
				ifFalse: [
					interval last > mi ifTrue: [
						miAndPiUpdated _ true.
						mi _ interval first + delta.
						pi _ mi ]]].
		start _  interval first+delta.
		stop _ interval last - 1 + delta.
		model logUndoAndReplaceFrom: start to: stop with: ''.
		delta _ delta - (interval size-1).
		textComposition
			recomposeFrom: start
			to:  start - 1
			delta: delta ].

	miAndPiUpdated not ifTrue: [
		mi _ mi + delta.
		pi _ pi + delta ].
	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	self markIndex: mi pointIndex: pi!

TextEditor removeSelector: #selectInterval:!

!methodRemoval: TextEditor #selectInterval: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectInterval: anInterval
	"Deselect, then select the specified characters inclusive.
	 Be sure the selection is in view."

	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	super selectInterval: anInterval!

TextEditor removeSelector: #deselectAndPlaceCursorAt:!

!methodRemoval: TextEditor #deselectAndPlaceCursorAt: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
deselectAndPlaceCursorAt: characterIndex 
	"Deselect, then place the text cursor before the character at characterIndex.
	 Be sure it is in view."

	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	super deselectAndPlaceCursorAt: characterIndex!

TextEditor removeSelector: #selectAll!

!methodRemoval: TextEditor #selectAll stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectAll

	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	super selectAll!

TextEditor removeSelector: #selectionIntervalsDo:!

!methodRemoval: TextEditor #selectionIntervalsDo: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectionIntervalsDo: aBlock
	"Evaluate over all selections. For editors with a single selection, just evaluate over it.
	Subclasses with multi-selection redefine this method."

	"multi-selection"
	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |
		aBlock value: (startBlock stringIndex to: stopBlock stringIndex - 1) ].

	"Simple (i.e. last) selection"
	aBlock value: self selectionInterval!

Editor removeSelector: #selectionIntervalsDo:!

!methodRemoval: Editor #selectionIntervalsDo: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectionIntervalsDo: aBlock
	"Evaluate over all selections. For editors with a single selection, just evaluate over it.
	Subclasses with multi-selection redefine this method."

	aBlock value: self selectionInterval!

Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont'
	classVariableNames: 'ChangeText FindText'
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #TextEditor category: #'System-Text' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:25'!
Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont'
	classVariableNames: 'ChangeText FindText'
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX editor showTextCursor lastTextCursorRect selectionStartBlock selectionStopBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!

!classDefinition: #TextComposition category: #'Morphic-Text Support' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX editor showTextCursor lastTextCursorRect selectionStartBlock selectionStopBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5129] on 2 May 2022 at 1:16:16 pm'!
!CodePackage methodsFor: 'enumerating' stamp: 'jmv 5/2/2022 13:12:41' prior: 16818883!
                 coreMethodsOf: aClass do: aBlock
	"Evaluate aBlock with the actual method objects in this package."

	aClass organization categories do: [ :cat |
		(self isForeignClassExtension: cat) ifFalse: [
			(aClass organization listAtCategoryNamed: cat) do: [ :s |
				aBlock value: (self referenceForMethod: s ofClass: aClass) ]]].! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 5/2/2022 13:14:07' prior: 16819349!
       writeOnStream: aStream

	| sortedClasses |
	aStream
		nextChunkPut: ('Description ', description) printString;
		newLine.
	self writeFeatureSpecOn: aStream.
	self writeSystemCategoriesOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self
			write: {codePackageClass} classDefinitionsOn: aStream;
			write: {codePackageClass} classCommentsOn: aStream;
			write: {codePackageClass} methodsOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' prePackageInstall'; newLine ].

	sortedClasses _ Array streamContents: [ :strm |
		self classesInSafeOrderDo: [ :cls |
			cls == self class ifFalse: [
				strm nextPut: cls ]]].
	self
		write: sortedClasses classDefinitionsOn: aStream;
		write: sortedClasses classCommentsOn: aStream;
		write: sortedClasses methodsOn: aStream.

	self
		sortedExtensionMethodsDo:  [ :methodReference |
			methodReference isValid ifTrue: [
				self writeMethod: methodReference on: aStream ]]
		displayingProgress: 'Saving extension methods...'.
	self write: sortedClasses initializersOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self write: { codePackageClass } initializersOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' postPackageInstall'; newLine ]! !

CodePackage removeSelector: #selectorNeededForFilein:!

!methodRemoval: CodePackage #selectorNeededForFilein: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
selectorNeededForFilein: aSelector
	"Answer true if aSelector might be needed for proper filein of the remaing methods."

	^ Metaclass isScarySelector: aSelector!

CodePackage removeSelector: #coreMethodsForFileinOf:do:!

!methodRemoval: CodePackage #coreMethodsForFileinOf:do: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
coreMethodsForFileinOf: aClass do: aBlock
	"Evaluate aBlock with the actual method objects in this package.
	Only enumerate those methods that might be needed for proper filein.
	such as #compilerClass."

	aClass organization categories do: [ :cat |
		(self isForeignClassExtension: cat) ifFalse: [
			(aClass organization listAtCategoryNamed: cat) do: [ :s |
				(self selectorNeededForFilein: s) ifTrue: [
					aBlock value: (self referenceForMethod: s ofClass: aClass) ]]]]!

CodePackage removeSelector: #write:methodsForFileinOn:!

!methodRemoval: CodePackage #write:methodsForFileinOn: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
write: classes methodsForFileinOn: aStream

	classes
		do: [ :class |
			self 
				writeCoreMethodsForFileinOf: class class on: aStream;
				writeCoreMethodsForFileinOf: class on: aStream ]
		displayingProgress: 'Saving methods...'!

CodePackage removeSelector: #writeCoreMethodsForFileinOf:on:!

!methodRemoval: CodePackage #writeCoreMethodsForFileinOf:on: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
writeCoreMethodsForFileinOf: aClass on: aStream

	self coreMethodsForFileinOf: aClass do: [ :methodReference |
		methodReference isValid
			ifTrue: [
				self writeMethod: methodReference on: aStream ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5130] on 2 May 2022 at 3:23:08 pm'!
!String methodsFor: 'accessing' stamp: 'jmv 4/29/2022 20:21:29'!
                          findString: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseSensitiveOrder.! !
!BitBlt methodsFor: 'private' stamp: 'jmv 9/2/2016 11:06:18' prior: 50347197!
primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta
	| ascii glyph |
	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>
	startIndex to: stopIndex do:[:charIndex|
		ascii _ (aString at: charIndex) numericValue.
		glyph _ glyphMap at: ascii + 1.
		sourceX _ xTable at: glyph + 1.
		width _ (xTable at: glyph + 2) - sourceX.
		self copyBits.
		destX _ destX + width + kernDelta.
	].! !

BitBlt removeSelector: #primFaiDisplayString:from:to:map:xTable:kern:!

!methodRemoval: BitBlt #primFaiDisplayString:from:to:map:xTable:kern: stamp: 'Install-5131-Tweaks-JuanVuletich-2022May02-15h22m-jmv.001.cs.st 5/16/2022 10:22:25'!
primFaiDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta

	| ascii glyph |
	startIndex to: stopIndex do: [ :charIndex |
		ascii _ (aString at: charIndex) numericValue.
		glyph _ glyphMap at: ascii + 1.
		sourceX _ xTable at: glyph + 1.
		width _ (xTable at: glyph + 2) - sourceX.
		self copyBits.
		destX _ destX + width + kernDelta.
	].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5131-Tweaks-JuanVuletich-2022May02-15h22m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5131] on 2 May 2022 at 4:27:41 pm'!

BitBltCanvas removeSelector: #drawStringEmbossed:from:to:at:font:color:!

!methodRemoval: BitBltCanvas #drawStringEmbossed:from:to:at:font:color: stamp: 'Install-5132-Cleanup-JuanVuletich-2022May02-16h27m-jmv.001.cs.st 5/16/2022 10:22:25'!
drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: font color: aColor
	"Answer position to place next glyph
	Answer nil if nothing was done"
	| p1 |
	p1 _ (currentTransformation transform: aPoint roundedHAFZ) roundedHAFZ.
	engine colorMap: nil.

	aColor = `Color black` ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: `Color black`.
		font
			onBitBltCanvasEngine: engine
			displayString: aString
			from: firstIndex
			to: lastIndex
			at: p1
			color: topColor ].
	aColor = `Color white` ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: `Color white`.
		font
			onBitBltCanvasEngine: engine
			displayString: aString
			from: firstIndex
			to: lastIndex
			at: p1 + `0@2`
			color: bottomColor ].
	^font
		onBitBltCanvasEngine: engine
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: p1 + `0@1`
		color: aColor.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5132-Cleanup-JuanVuletich-2022May02-16h27m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5132] on 3 May 2022 at 12:24:17 pm'!
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 5/3/2022 12:24:14' prior: 16869862!
                   draw: item atRow: row on: canvas
	"display the given item at row row"
	| f c |
	(item is: #Text)
		ifTrue: [
			f _ font emphasized: (item emphasisAt: 1).
			c _ (item colorAt: 1) ifNil: [Theme current text]]
		ifFalse: [ 
			f _ font.
			c _  Theme current text].
	canvas
		drawString: item string
		at: 0 @ (self drawYForRow: row)
		font: f
		color: c! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5133-InnerListMorph-Fix-JuanVuletich-2022May03-12h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5133] on 3 May 2022 at 1:10:58 pm'!
!TextEditor methodsFor: 'private' stamp: 'jmv 5/3/2022 13:08:48' prior: 50347540 overrides: 50347536!
               stringClassToUse
	^self privateCurrentString asPlainString class! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5134-TextEditor-fix-JuanVuletich-2022May03-13h10m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5134] on 3 May 2022 at 5:04:08 pm'!
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 15:51:49'!
                utfBytesAndCodePointAt: byteIndex in: utf8ByteArray into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in utf8ByteArray starting at byte byteIndex.
	Evalueate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, skip it. Also skip codePoint U+FEFF (BOM, unneededly added by Win clipboard).
	But in any case, answer the number of bytes of the invalid sequence, to allow senders to update an index in an iteration.
	See senders."

	| n byte1 byte2 byte3 byte4 codePoint |
	n _ 0.
	byte1 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ n ].
	
	"At least 2 bytes"
	byte2 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^n ].
	
	"At least 3 bytes"
	byte3 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ ^n ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^n ].

	"4 bytes"
	byte4 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		].
	^n! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 17:03:05' prior: 16809138!
                            nextCodePointBytesFromUtf8: anUtf8Stream into: aBlock
	"anUtf8Stream can be over a ByteArray.
	See senders."
"Note: This method will be removed. Prefer
#utfBytesAndCodePointAt:in:into:into:
"
	| byte1 byte2 byte3 byte4 |
	byte1 _ anUtf8Stream next.
	byte1 < 128 ifTrue: [	"single byte"
		^ aBlock value: byte1 value: nil value: nil value: nil ].
	
	"At least 2 bytes"
	byte2 _ anUtf8Stream next.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		^ aBlock value: byte1 value: byte2 value: nil value: nil ].
	
	"At least 3 bytes"
	byte3 _ anUtf8Stream next.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: nil ].

	"4 bytes"
	byte4 _ anUtf8Stream next.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: byte4 ].

	^nil! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 17:02:51' prior: 16809171!
                         nextUnicodeCodePointFromUtf8: anUtf8Stream
	"anUtf8Stream can be over a ByteArray
	Answer nil if conversion not possible, because of invalid UTF-8.
	Also answer nil for codePoint U+FEFF (BOM, unneededly added by Win clipboard)"
"Note: This method will be removed. Prefer
#utfBytesAndCodePointAt:in:into:into:
"
	^ self
		nextCodePointBytesFromUtf8: anUtf8Stream
		into: [ :byte1 :byte2 :byte3 :byte4 |
			byte4 notNil
				ifTrue: [ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12) + ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63) ]
				ifFalse: [
					byte3 notNil
						ifTrue: [ | codePoint |
							codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
							codePoint = 16rFEFF
								ifFalse: [ codePoint ]
								ifTrue: [ nil ]]
						ifFalse: [
							byte2 notNil
								ifTrue: [ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ]
								ifFalse: [ byte1 ]]]]! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 17:01:56' prior: 16809201!
   unicodeCodePointOfUtf8Bytes: aByteArray

	Character utfBytesAndCodePointAt: 1 in: aByteArray
				into: nil
				into: [ :codePoint | ^ codePoint ].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 16:57:11' prior: 50347335!
            fromUtf8: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utfBytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					"Add just one char if possible, or the apropriate sequence for the NCR"
					self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
			byteIndex _ byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 16:14:35' prior: 16950004!
                             utf32FromUtf8: aByteArray
	"Convert the given string from UTF-8 to UTF-32"

	^WordArray streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utfBytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					strm nextPut: codePoint ].
			byteIndex _ byteIndex + n
		]].! !
!Clipboard methodsFor: 'private' stamp: 'jmv 5/3/2022 14:49:59' prior: 50347291!
                 retrieveIdOrStringFromOS: stringClass
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| utf8Bytes |
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].

	utf8Bytes _ self primitiveClipboardString.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard."
	utf8Bytes isEmpty ifTrue: [ ^nil ].

	"Clipboard primitive answers an instance of String containing the UTF-8 bytes.
	If not pure ASCII, contents are invalid!! Convert it ASAP into a reasonable ByteArray."
	utf8Bytes class format = ByteArray format  												"True unless image is in 32bit V3 format"
		ifTrue: [ ByteArray adoptInstance: utf8Bytes ]
		ifFalse: [ utf8Bytes _ ByteArray withAll: utf8Bytes ].
	^ (stringClass fromUtf8: utf8Bytes) fixLineEndings.! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/3/2022 16:37:12' prior: 16809753!
                    scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value. Determine
	width of each character from xTable, indexed by map.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	sourceString from: startIndex to: stopIndex do: [ :char |
		"stops are only defined for the first 256 characters.
		For Character like objects beyond those in ISO-8859-15,
		#iso8859s15Code shound answer nil!!"
		char iso8859s15Code ifNotNil: [ :code |
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOf: char).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
		destX _ nextDestX.
		lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !

String class removeSelector: #fromUtf8:hex:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5135-UTF8-Tweaks-JuanVuletich-2022May03-16h55m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5135] on 5 May 2022 at 9:32:49 am'!
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:31:43'!
           utf8BytesAndCodePointAt: byteIndex in: utf8ByteArray into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in utf8ByteArray starting at byte byteIndex.
	Evalueate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, skip it. Also skip codePoint U+FEFF (BOM, unneededly added by Win clipboard).
	But in any case, answer the number of bytes of the invalid sequence, to allow senders to update an index in an iteration.
	See senders."

	| n byte1 byte2 byte3 byte4 codePoint |
	n _ 0.
	byte1 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ n ].
	
	"At least 2 bytes"
	byte2 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^n ].
	
	"At least 3 bytes"
	byte3 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ ^n ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^n ].

	"4 bytes"
	byte4 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		].
	^n! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:32:15' prior: 50348967!
                           nextCodePointBytesFromUtf8: anUtf8Stream into: aBlock
	"anUtf8Stream can be over a ByteArray.
	See senders."
"Note: This method will be removed. Prefer
#utf8BytesAndCodePointAt:in:into:into:
"
	| byte1 byte2 byte3 byte4 |
	byte1 _ anUtf8Stream next.
	byte1 < 128 ifTrue: [	"single byte"
		^ aBlock value: byte1 value: nil value: nil value: nil ].
	
	"At least 2 bytes"
	byte2 _ anUtf8Stream next.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		^ aBlock value: byte1 value: byte2 value: nil value: nil ].
	
	"At least 3 bytes"
	byte3 _ anUtf8Stream next.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: nil ].

	"4 bytes"
	byte4 _ anUtf8Stream next.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: byte4 ].

	^nil! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:32:19' prior: 50349003!
                        nextUnicodeCodePointFromUtf8: anUtf8Stream
	"anUtf8Stream can be over a ByteArray
	Answer nil if conversion not possible, because of invalid UTF-8.
	Also answer nil for codePoint U+FEFF (BOM, unneededly added by Win clipboard)"
"Note: This method will be removed. Prefer
#utf8BytesAndCodePointAt:in:into:into:
"
	^ self
		nextCodePointBytesFromUtf8: anUtf8Stream
		into: [ :byte1 :byte2 :byte3 :byte4 |
			byte4 notNil
				ifTrue: [ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12) + ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63) ]
				ifFalse: [
					byte3 notNil
						ifTrue: [ | codePoint |
							codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
							codePoint = 16rFEFF
								ifFalse: [ codePoint ]
								ifTrue: [ nil ]]
						ifFalse: [
							byte2 notNil
								ifTrue: [ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ]
								ifFalse: [ byte1 ]]]]! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:31:56' prior: 50349036!
  unicodeCodePointOfUtf8Bytes: aByteArray

	Character utf8BytesAndCodePointAt: 1 in: aByteArray
				into: nil
				into: [ :codePoint | ^ codePoint ].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 09:32:01' prior: 50349044!
           fromUtf8: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					"Add just one char if possible, or the apropriate sequence for the NCR"
					self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
			byteIndex _ byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 09:32:05' prior: 50349086!
                            utf32FromUtf8: aByteArray
	"Convert the given string from UTF-8 to UTF-32"

	^WordArray streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					strm nextPut: codePoint ].
			byteIndex _ byteIndex + n
		]].! !

Character class removeSelector: #utfBytesAndCodePointAt:in:into:into:!

!methodRemoval: Character class #utfBytesAndCodePointAt:in:into:into: stamp: 'Install-5136-TypoFix-JuanVuletich-2022May05-09h31m-jmv.001.cs.st 5/16/2022 10:22:25'!
utfBytesAndCodePointAt: byteIndex in: utf8ByteArray into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in utf8ByteArray starting at byte byteIndex.
	Evalueate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, skip it. Also skip codePoint U+FEFF (BOM, unneededly added by Win clipboard).
	But in any case, answer the number of bytes of the invalid sequence, to allow senders to update an index in an iteration.
	See senders."

	| n byte1 byte2 byte3 byte4 codePoint |
	n _ 0.
	byte1 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ n ].
	
	"At least 2 bytes"
	byte2 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^n ].
	
	"At least 3 bytes"
	byte3 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ ^n ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^n ].

	"4 bytes"
	byte4 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		].
	^n!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5136-TypoFix-JuanVuletich-2022May05-09h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5136] on 5 May 2022 at 12:16:17 pm'!
!String methodsFor: 'converting' stamp: 'jmv 5/4/2022 17:38:46'!
               asUtf32
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	See #fromUtf32: "

	^self asUtf32: true.! !
!String methodsFor: 'converting' stamp: 'jmv 5/4/2022 17:38:55'!
                        asUtf32: convertEmbeddedNCRs
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

Copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^WordArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					outStream nextPut: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					outStream nextPut: codePoint ]]]! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:08'!
                           fromUtf32: aWordArray
	"Convert the given bytes from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf32 "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	^self fromUtf32: aWordArray hex: false trimLastNull: false! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:18:46'!
         fromUtf32: aWordArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf32:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			"Add just one char if possible, or the apropriate sequence for the NCR"
			self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
		(doTrimLastNullChar and: [ aWordArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5137-UTF32-support-JuanVuletich-2022May05-12h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5136] on 5 May 2022 at 12:17:29 pm'!
!String methodsFor: 'character scanner support' stamp: 'jmv 5/5/2022 11:14:55'!
                  scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanStringCharsFrom: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 11:19:09'!
    scanStringCharsFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	sourceString from: startIndex to: stopIndex do: [ :char |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		(stops at: char numericValue + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOf: char).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 11:15:21' prior: 50349133!
                           scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	^sourceString scanCharactersFrom: startIndex to: stopIndex with: self rightX: rightX stopConditions: stops! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5138-DoubleDispatch-JuanVuletich-2022May05-12h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5138] on 6 May 2022 at 6:57:22 am'!

WordArray removeSelector: #at:put:!

!methodRemoval: WordArray #at:put: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
at: x put: y
	^super at: x put: y!

WordArray removeSelector: #basicAt:put:!

!methodRemoval: WordArray #basicAt:put: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
basicAt: x put: y
	^super basicAt: x put: y!

WordArray removeSelector: #at:!

!methodRemoval: WordArray #at: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
at: x
	^super at: x!

WordArray removeSelector: #basicAt:!

!methodRemoval: WordArray #basicAt: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
basicAt: index 
	^super basicAt: index !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5139] on 6 May 2022 at 10:34:55 am'!
!Parser methodsFor: 'scanning' stamp: 'jmv 5/6/2022 10:34:02' prior: 50343635!
       transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain."

	| toMakeBinary |
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].

	"Note: Also include #binary, to allow stuff like #+| where a special character comes after after a regular binary operator character. "
	toMakeBinary _ #(binary verticalBar upArrow colon).
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asPlainString.
	hereType := #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asPlainString.
			hereEnd := hereEnd + 1.
			self scanToken ].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asPlainString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5140-ParserFix-JuanVuletich-2022May06-10h28m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5139] on 6 May 2022 at 10:51:54 am'!
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/6/2022 10:51:14' prior: 50341449!
                           scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := String with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].
	(c == $: and: [d == $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (String with: d).
			self nextChar.
			^currentToken].
	"|| empty temp declaration"
	"This makes || colorize as an invalid method definition.
	It is better to allow #|| as valid selector, and mark an empty temp declaration as invalid instead!!"
	"(c == $| and: [d == $|])
		ifTrue: [^currentToken]."
	c _ d.
	[
		d _ self peekChar.
		c == $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken _ currentToken copyWith: c.
			c _ self nextChar ].
	^currentToken! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5141-CodeColorizer-fix-JuanVuletich-2022May06-10h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5138] on 5 May 2022 at 5:02:49 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:26:23' prior: 16808252!
    isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ self  = $_ ]! !
!Character methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:26:27' prior: 16808260!
                            isValidStartOfIdentifiers
	"Can I be the first character of an identifier? (unary or keyword selector, or variable name)"

	^self isLetter or: [ self  = $_ ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5142-CharacterTweaks-JuanVuletich-2022May05-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5145] on 9 May 2022 at 12:02:54 pm'!
!Preferences class methodsFor: 'fonts' stamp: 'jmv 5/9/2022 12:02:27' prior: 16915702!
           loadOnlyLatinGlyphData
	^ self
		valueOfFlag: #loadOnlyLatinGlyphData
		ifAbsent: [false]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5143-LoadAllTrueType-JuanVuletich-2022May09-12h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5143] on 10 May 2022 at 3:48:54 pm'!
!Clipboard methodsFor: 'private' stamp: 'jmv 5/10/2022 15:48:42' prior: 50349101!
             retrieveIdOrStringFromOS: stringClass
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| utf8Bytes |
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].

	utf8Bytes _ self primitiveClipboardString.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard."
	utf8Bytes isEmpty ifTrue: [ ^nil ].

	"Abuse the fact that the VM provides an instance of String (although it contains UTF-8 bytes)"
	utf8Bytes _ utf8Bytes fixLineEndings.

	"Clipboard primitive answers an instance of String containing the UTF-8 bytes.
	If not pure ASCII, contents are invalid!! Convert it ASAP into a reasonable ByteArray."
	utf8Bytes class format = ByteArray format  												"True unless image is in 32bit V3 format"
		ifTrue: [ ByteArray adoptInstance: utf8Bytes ]
		ifFalse: [ utf8Bytes _ ByteArray withAll: utf8Bytes ].
	^ stringClass fromUtf8: utf8Bytes.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5144-Clipboard-fix-JuanVuletich-2022May10-15h48m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5143] on 10 May 2022 at 3:48:38 pm'!

Object subclass: #StringUtf32
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #StringUtf32 category: #'System-Text' stamp: 'Install-5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf32
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!StringUtf32 commentStamp: 'jmv 5/10/2022 15:47:34' prior: 0!
 String like objects handling Unicode code points, encoded as UTF-32 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!

Object subclass: #StringUtf8
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #StringUtf8 category: #'System-Text' stamp: 'Install-5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf8
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!StringUtf8 commentStamp: 'jmv 5/10/2022 15:47:45' prior: 0!
String like objects handling Unicode code points, encoded as UTF-8 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!

Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #UnicodeCodePoint category: #'System-Text' stamp: 'Install-5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!UnicodeCodePoint commentStamp: 'jmv 5/10/2022 15:48:21' prior: 0!
 An Unicode Code Point can behave in a somewhat similar way to a Character.!
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 12:08:53'!
           scanStringUtf32From: startIndex to: stopIndex in: aStringUtf32 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf32 words from: startIndex to: stopIndex do: [ :code |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		code < 256 ifTrue: [
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOfCodePoint: code).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 12:08:06'!
                scanStringUtf8From: startIndex to: stopIndex in: aStringUtf8 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf8 from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:16' overrides: 16901507!
                at: codePointIndex
	"Answer the UnicodeCodePoint at codePointIndex"

	^UnicodeCodePoint codePoint: (codePoints at: codePointIndex)! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:45:00'!
                     isLastLineSeparator
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12 16r0085 16r2028 16r2029) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	^false.
	! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:47:44'!
    isLastSeparator
"A few more are missing!!"
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 32]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 9]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:48:00' overrides: 16901663!
                     size
	^codePoints size! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:10'!
 words
	^codePoints! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:28:47'!
     words: aWordArray
	codePoints _ aWordArray! !
!StringUtf32 methodsFor: 'copying' stamp: 'jmv 5/4/2022 19:22:55'!
               , aStringUtf32
	^StringUtf32 withWords: codePoints, aStringUtf32 words.! !
!StringUtf32 methodsFor: 'copying' stamp: 'jmv 5/4/2022 15:34:58'!
                  copyFrom: startIndex to: endIndex 
	"Answer a copy of the receiver that contains elements from position
	startIndex to endIndex."
	
	^StringUtf32 withWords:
		(codePoints
			copyFrom: startIndex
			to: endIndex)! !
!StringUtf32 methodsFor: 'copying' stamp: 'jmv 5/4/2022 17:29:35'!
      copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ startIndex-1.
	epilogFirstIndex _ endIndex+1.
	^StringUtf32 withWords:
		(codePoints copyFrom: 1 to: prologLastIndex),
		replacement asUtf32,
		(codePoints
			copyFrom: epilogFirstIndex
			to: codePoints size)! !
!StringUtf32 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:34:05' overrides: 16901772!
                              = aStringUtf32
	"Answer whether the receiver sorts equally as aStringUtf32.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aStringUtf32 ifTrue: [ ^ true ].

	"If argument is not a aStringUtf32, maybe it is a Text?"
	aStringUtf32 class == StringUtf32 ifFalse: [
		(aStringUtf32 is: #Text) ifTrue: [ ^ self = aStringUtf32 string ].
		^ false].

	self size = aStringUtf32 size ifFalse: [
		^false ].
	
	self size > 256 ifTrue: [
		codePoints hashQuick = aStringUtf32 words hashQuick ifFalse: [ ^false ]].

	^ codePoints = aStringUtf32 words! !
!StringUtf32 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:36:15' overrides: 16901788!
  hash
	"Hash is reimplemented because = is implemented."

	^codePoints hash! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:16'!
            asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: self asUtf8! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:03'!
                  asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:46' overrides: 16901837!
                    asString
	"Answer the receiver itself."
	^self! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/4/2022 15:19:36'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:28'!
         asUtf32
	"Answer a WordArray."

	^codePoints! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:15'!
          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^codePoints! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:25'!
     asUtf8
	"Answer a ByteArray."

	^String utf8FromUtf32: codePoints! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:03'!
                     asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a ByteArray."

	^self asUtf8! !
!StringUtf32 methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 11:25:41'!
    from: start to: stop do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	start to: stop do: [ :index | aBlock value: (self at: index) ].! !
!StringUtf32 methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:36' overrides: 16903326!
                            is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!StringUtf32 methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:54'!
                    isEmpty
	^codePoints isEmpty! !
!StringUtf32 methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:36' overrides: 50347215!
         isStringLike

	^true! !
!StringUtf32 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:56:56'!
                           encompassLine: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!StringUtf32 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 15:32:57'!
               encompassParagraph: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size]).
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!StringUtf32 methodsFor: 'character scanner support' stamp: 'jmv 5/5/2022 11:13:45'!
scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanStringUtf32From: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!StringUtf32 methodsFor: 'as yet unclassified' stamp: 'jmv 5/10/2022 15:43:00' overrides: 50337880!
         doesNotUnderstand: aMessage

	{ 'StringUtf32 does not understand: '. aMessage} print! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:26'!
                     fromUtf32: words

	^self withWords: words! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:15:48'!
fromUtf8: aByteArray

	^self withWords: (String utf32FromUtf8: aByteArray).! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 17:19:49'!
                              with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf32 with: $a
	StringUtf32 with: $·
	StringUtf32 with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint).! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 17:19:31'!
         with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf32 with: $a
	StringUtf32 with: $· with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint with: otherCharacter codePoint).! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 15:49:33'!
   withWords: aWordArray
	^self new words: aWordArray ! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/6/2022 18:48:36' overrides: 16901507!
                 at: codePointIndex
	"Answer the UnicodeCodePoint at code point index codePointIndex (not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ UnicodeCodePoint codePoint: (bytes at: codePointIndex) ].
	byteIndex _ self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^UnicodeCodePoint codePoint: codePoint ].! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:50'!
                      bytes
	^bytes! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:51'!
           bytes: aByteArray
	bytes _ aByteArray! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:46:34'!
                   isLastLineSeparator
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s butButLastByte butLastByte lastByte |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	s = 1 ifTrue: [ ^false ].
	lastByte _ bytes at: s.
	butLastByte _ bytes at: s-1.
	(butLastByte = 16rC2 and: [ lastByte = 16r85 ]) ifTrue: [ ^true ]. "Next Line, NEL"
	s = 2 ifTrue: [ ^false ].
	butButLastByte _ bytes at: s-2.
	(butButLastByte = 16rE2 and: [butLastByte = 16r80 and: [ "Line Separator and Paragraph Separator"
		lastByte = 16rA8 or: [lastByte = 16rA9]]]) ifTrue: [ ^true ].
	^false.
	! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:46:58'!
                             isLastSeparator
"A few more are missing!!"
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 32]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 9]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!StringUtf8 methodsFor: 'accessing' stamp: 'svc 5/5/2022 15:51:50' overrides: 16901663!
size
	"Return how many characters I contain"
	
	self isEmpty ifTrue: [ ^ 0 ].
	count ifNil: [ self computeCountAndIndex ].
	^ count! !
!StringUtf8 methodsFor: 'copying' stamp: 'jmv 5/4/2022 19:22:52'!
                       , aStringUtf8
	^StringUtf8 withBytes: bytes, aStringUtf8 bytes.! !
!StringUtf8 methodsFor: 'copying' stamp: 'svc 5/5/2022 16:25:23'!
                           copyFrom: startIndex to: stopIndex
	"Return a new string, a copy of me from startIndex to stopIndex, both character indices.
	Signal SubscriptOutOfBounds or CollectionIsEmpty in case of illegal indices."
	
	| startByteIndex stopByteIndex substring |
	startIndex = (self size+1) ifTrue: [ ^StringUtf8 empty ].
	stopIndex = 0 ifTrue: [ ^StringUtf8 empty ].
	self boundsCheck: startIndex. 
	self boundsCheck: stopIndex. 
	startByteIndex := self byteIndexAt: startIndex.
	stopByteIndex := self byteIndexAt: stopIndex.
	stopByteIndex := stopByteIndex + (self encodedByteCountAt: stopByteIndex) - 1.
	substring := StringUtf8 withBytes: (bytes copyFrom: startByteIndex to: stopByteIndex).
	self isAscii ifTrue: [ substring beAscii ].
	^ substring! !
!StringUtf8 methodsFor: 'copying' stamp: 'jmv 5/5/2022 16:57:30'!
                       copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ (self byteIndexAt: startIndex)-1.
	epilogFirstIndex _ self byteIndexAt: endIndex+1.
	^StringUtf8 withBytes:
		(bytes copyFrom: 1 to: prologLastIndex),
		replacement asUtf8,
		(bytes
			copyFrom: epilogFirstIndex
			to: bytes size)! !
!StringUtf8 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:35:30' overrides: 16901772!
          = aStringUtf8
	"Answer whether the receiver sorts equally as aStringUtf8.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aStringUtf8 ifTrue: [ ^ true ].

	"If argument is not a aStringUtf32, maybe it is a Text?"
	aStringUtf8 class == StringUtf8 ifFalse: [
		(aStringUtf8 is: #Text) ifTrue: [ ^ self = aStringUtf8 string ].
		^ false].

	bytes size = aStringUtf8 bytes size ifFalse: [
		^false ].
	
	bytes size > 256 ifTrue: [
		bytes hashQuick = aStringUtf8 bytes hashQuick ifFalse: [ ^false ]].

	^ bytes = aStringUtf8 bytes! !
!StringUtf8 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:38:57' overrides: 16901788!
               hash
	"Hash is reimplemented because = is implemented."

	^bytes hash! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:03'!
                  asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: bytes! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:11'!
                         asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:44' overrides: 16901837!
                     asString
	"Answer the receiver itself."
	^self! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 3/13/2022 18:50:31'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:39'!
          asUtf32
	"Answer a WordArray."

	^String utf32FromUtf8: bytes! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:29'!
                          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^self asUtf32! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:32'!
    asUtf8
	"Answer a ByteArray."

	^bytes! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:10'!
                 asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-8 doesn't need them after all.
	Answer a ByteArray."

	^bytes! !
!StringUtf8 methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:33'!
            from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n cpIndex |
	byteIndex _ self byteIndexAt: startIndex.
	cpIndex _ startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (UnicodeCodePoint codePoint: codePoint).
			cpIndex _ cpIndex + 1 ].
		byteIndex _ byteIndex + n ].! !
!StringUtf8 methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:37'!
                 from: startIndex to: stopIndex doWithUtf8Bytes: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n stopByteIndex |
	byteIndex _ self byteIndexAt: startIndex.
	stopByteIndex _ self byteIndexAt: stopIndex.
	[ byteIndex <= stopByteIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: aBlock into: nil.
		byteIndex _ byteIndex + n ].! !
!StringUtf8 methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:32' overrides: 16903326!
              is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!StringUtf8 methodsFor: 'testing' stamp: 'svc 5/5/2022 16:12:43'!
                     isAscii
	"Return true when I am pure 7-bit ASCII, which means each character is encoded as one byte."

	count ifNil: [ self computeCountAndIndex ].
	^ bytes size = count! !
!StringUtf8 methodsFor: 'testing' stamp: 'jmv 5/3/2022 12:12:52'!
                 isEmpty
	^bytes isEmpty! !
!StringUtf8 methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:35:03' overrides: 50347215!
              isStringLike

	^true! !
!StringUtf8 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:00'!
                            encompassLine: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!StringUtf8 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:40'!
 encompassParagraph: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size]).
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!StringUtf8 methodsFor: 'character scanner support' stamp: 'jmv 5/5/2022 11:13:55'!
                  scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanStringUtf8From: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:53:18'!
            beAscii
	"Mark me as being pure 7-bit ASCII, which means each character is encoded as one byte"
	
	count := bytes size.
	index := #().! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 16:04:35'!
                    boundsCheck: codePointIndex
	(codePointIndex between: 1 and: self size) 
		ifFalse: [ self errorSubscriptBounds: codePointIndex ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 16:25:57'!
                         byteIndexAt: codePointIndex
	| byteIndex |
	self isAscii ifTrue: [ ^ codePointIndex ].
	codePointIndex = (self size+1) ifTrue: [
		"The position a hypotetical extra code point would start at.
		Useful to find the last byte position for some codePointIndex. See senders."
		^bytes size+1 ].
	byteIndex := codePointIndex > self stride
		ifTrue: [
			index at: codePointIndex - 1 // self stride ]
		ifFalse: [ 1 ].
	codePointIndex - 1 \\ self stride timesRepeat: [ 
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ].
	^ byteIndex! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 16:46:33'!
                            codePointIndexAt: byteIndex
	| codePointIndex byteCursor |
	self isAscii ifTrue: [ ^ byteIndex ].
	codePointIndex := byteCursor := 1.
	index ifNil: [ self computeCountAndIndex ].
	index ifNotEmpty: [  
		index 
			findBinaryIndex: [ :x | byteIndex - x ] 
			do: [ :found | ^ (found * self stride) + 1 ] 
			ifNone: [ :lower :upper |
				lower = 0 
			 		ifFalse: [ 
						byteCursor := index at: lower. 
						codePointIndex := (lower * self stride) + 1 ] ] ].
	[ byteCursor <= bytes size ] whileTrue: [
		byteCursor = byteIndex 
			ifTrue: [ ^ codePointIndex ].
		byteCursor := byteCursor + (self encodedByteCountAt: byteCursor).
		codePointIndex := codePointIndex + 1 ].
	^ 0! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:39'!
                     computeCountAndIndex
	self isEmpty ifTrue: [ count := 0. ^ self ].
	"the number of characters cannot be larger than the byte size"
	bytes size <= self stride
		ifTrue: [ self computeCountNoIndex ]
		ifFalse: [ self computeCountAndIndexFull ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:55'!
         computeCountAndIndexFull
	count := 0.
	index := Array streamContents: [ :out | | byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:18'!
                           computeCountNoIndex
	| byteIndex |
	count := 0.
	index := #().
	byteIndex := 1.
	[ byteIndex <= bytes size ] whileTrue: [
		count := count + 1.
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:50:23'!
         encodedByteCountAt: byteIndex
	| byte |
	(byte := bytes at: byteIndex) < 128 ifTrue: [ ^ 1 ].
	(byte bitAnd: 2r11100000) = 2r11000000 ifTrue: [ ^ 2 ].
	(byte bitAnd: 2r11110000) = 2r11100000 ifTrue: [ ^ 3 ].
	(byte bitAnd: 2r11111000) = 2r11110000 ifTrue: [ ^ 4 ].
	self error: 'IllegalLeadingByte '! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:54'!
               stride
	"Return the stride, the constant I use internally to build my index"
	
	^ 32! !
!StringUtf8 methodsFor: 'as yet unclassified' stamp: 'jmv 5/10/2022 15:43:04' overrides: 50337880!
     doesNotUnderstand: aMessage

	{ 'StringUtf8 does not understand: '. aMessage} print! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'svc 5/5/2022 16:25:07'!
                       empty
	"Return the empty StringUtf8 instance.
	Since my instances are readonly, this could be cached."

	^ (self withBytes: #[]) beAscii; yourself! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:16:43'!
                        fromUtf32: aWordArray

	^self withBytes: (String utf8FromUtf32: aWordArray).! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:21'!
                              fromUtf8: bytes

	^self withBytes: bytes! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 4/29/2022 15:04:19'!
 with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf8 with: $a
	StringUtf8 with: $·
	StringUtf8 with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint).! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 4/29/2022 15:04:23'!
                     with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf8 with: $a
	StringUtf8 with: $· with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint),
		(Character utf8BytesOfUnicodeCodePoint: otherCharacter codePoint).! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 12:10:29'!
         withBytes: aByteArray
	^self new bytes: aByteArray ! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 5/5/2022 15:20:14'!
                               codePoint
	^value! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 5/4/2022 16:54:26'!
 codePoint: aNumber
	value _ aNumber! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:25' overrides: 16903326!
                             is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:24:25'!
               isAlphaNumeric
	"Answer whether the receiver is a letter or a digit."
	^self isLetter or: [self isDigit]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:21:35'!
            isDigit
	"Answer whether the receiver is a digit."

	^ value between: 48 and: 57! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:23:34'!
    isLetter
	"Answer whether the receiver is a letter."
self flag: #unicodeNeedsImprovement.
	(Character codePoint: value) ifNotNil: [ :ch | ^ch isLetter ].
	^false! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 16:59:07'!
                   isLineSeparator
	"Answer whether the receiver is a line separator character:
	line feed, cr, or form feed."

	^ #(10 13 12) statePointsTo: value! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 16:59:12'!
    isSeparator
	"Answer whether the receiver is one of the separator characters
	space, tab, lf, cr, or form feed."

	^ #(32 9 10 13 12) statePointsTo: value! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:25:12'!
                          isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ $_ numericValue = value ]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:25:50'!
                        isValidStartOfIdentifiers
	"Can I be the first character of an identifier? (unary or keyword selector, or variable name)"

	^self isLetter or: [ $_ numericValue = value ]! !
!UnicodeCodePoint methodsFor: 'as yet unclassified' stamp: 'jmv 5/10/2022 15:43:13' overrides: 50337880!
         doesNotUnderstand: aMessage

	{ 'UnicodeCodePoint does not understand: '. aMessage} print! !
!UnicodeCodePoint class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 16:53:51'!
           codePoint: aNumber
	^self new codePoint: aNumber! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5145] on 11 May 2022 at 10:34:39 am'!

Object subclass: #Utf32String
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf32String category: #'System-Text' stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #Utf32String
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!Utf32String commentStamp: 'jmv 5/10/2022 15:47:34' prior: 0!
              String like objects handling Unicode code points, encoded as UTF-32 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!

Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!Utf8String commentStamp: 'jmv 5/10/2022 15:47:45' prior: 0!
                         String like objects handling Unicode code points, encoded as UTF-8 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:16' overrides: 16901507!
     at: codePointIndex
	"Answer the UnicodeCodePoint at codePointIndex"

	^UnicodeCodePoint codePoint: (codePoints at: codePointIndex)! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:10:53'!
                    isLastLineSeparator
	"
	(Utf32String withBytes: #[64 65 66]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 10]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 13]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 12]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12 16r0085 16r2028 16r2029) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	^false.
	! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:11:11'!
                            isLastSeparator
"A few more are missing!!"
	"
	(Utf32String withBytes: #[64 65 66]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 32]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 9]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 10]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 13]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 12]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 194 133]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:48:00' overrides: 16901663!
            size
	^codePoints size! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:10'!
 words
	^codePoints! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:28:47'!
     words: aWordArray
	codePoints _ aWordArray! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/11/2022 10:02:48'!
              , anUtf32String
	^Utf32String withWords: codePoints, anUtf32String words.! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:57:56'!
               copyFrom: startIndex to: endIndex 
	"Answer a copy of the receiver that contains elements from position
	startIndex to endIndex."
	
	^Utf32String withWords:
		(codePoints
			copyFrom: startIndex
			to: endIndex)! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:57:56'!
     copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ startIndex-1.
	epilogFirstIndex _ endIndex+1.
	^Utf32String withWords:
		(codePoints copyFrom: 1 to: prologLastIndex),
		replacement asUtf32,
		(codePoints
			copyFrom: epilogFirstIndex
			to: codePoints size)! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 5/11/2022 10:07:38' overrides: 16901772!
                             = anUtf32String
	"Answer whether the receiver sorts equally as anUtf32String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == anUtf32String ifTrue: [ ^ true ].

	"If argument is not a anUtf32String, maybe it is a Text?"
	anUtf32String class == Utf32String ifFalse: [
		(anUtf32String is: #Text) ifTrue: [ ^ self = anUtf32String string ].
		^ false].

	self size = anUtf32String size ifFalse: [
		^false ].

	self size > 256 ifTrue: [
		codePoints hashQuick = anUtf32String words hashQuick ifFalse: [ ^false ]].

	^ codePoints = anUtf32String words! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:36:15' overrides: 16901788!
                         hash
	"Hash is reimplemented because = is implemented."

	^codePoints hash! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:16'!
            asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: self asUtf8! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:03'!
                  asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:46' overrides: 16901837!
                    asString
	"Answer the receiver itself."
	^self! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/4/2022 15:19:36'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:28'!
         asUtf32
	"Answer a WordArray."

	^codePoints! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:15'!
          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^codePoints! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:25'!
     asUtf8
	"Answer a ByteArray."

	^String utf8FromUtf32: codePoints! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:03'!
                     asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a ByteArray."

	^self asUtf8! !
!Utf32String methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 11:25:41'!
    from: start to: stop do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	start to: stop do: [ :index | aBlock value: (self at: index) ].! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:36' overrides: 16903326!
                            is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:54'!
                    isEmpty
	^codePoints isEmpty! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:36' overrides: 50347215!
         isStringLike

	^true! !
!Utf32String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:56:56'!
                           encompassLine: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!Utf32String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 15:32:57'!
               encompassParagraph: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size]).
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!Utf32String methodsFor: 'character scanner support' stamp: 'jmv 5/11/2022 10:05:52'!
                               scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanUtf32StringFrom: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!Utf32String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:15:37'!
  edit

	self editLabel: 'UTF-32 Text Editor'! !
!Utf32String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:28'!
      editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Utf32String methodsFor: 'as yet unclassified' stamp: 'jmv 5/11/2022 10:05:22' overrides: 50337880!
              doesNotUnderstand: aMessage

	{ 'Utf32String does not understand: '. aMessage} print! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:26'!
                     fromUtf32: words

	^self withWords: words! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:15:48'!
fromUtf8: aByteArray

	^self withWords: (String utf32FromUtf8: aByteArray).! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:06:15'!
                             with: aCharacter 
	"Answer a new instance of me, containing utf words for aCharacter.
	Utf32String with: $a
	Utf32String with: $·
	Utf32String with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint).! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:06:33'!
        with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf words for aCharacter.
	Utf32String with: $a
	Utf32String with: $· with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint with: otherCharacter codePoint).! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 15:49:33'!
   withWords: aWordArray
	^self new words: aWordArray ! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/6/2022 18:48:36' overrides: 16901507!
                 at: codePointIndex
	"Answer the UnicodeCodePoint at code point index codePointIndex (not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ UnicodeCodePoint codePoint: (bytes at: codePointIndex) ].
	byteIndex _ self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^UnicodeCodePoint codePoint: codePoint ].! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:50'!
                      bytes
	^bytes! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:51'!
           bytes: aByteArray
	bytes _ aByteArray! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:10:20'!
                  isLastLineSeparator
	"
	(Utf8String withBytes: #[64 65 66]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 10]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 13]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 12]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s butButLastByte butLastByte lastByte |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	s = 1 ifTrue: [ ^false ].
	lastByte _ bytes at: s.
	butLastByte _ bytes at: s-1.
	(butLastByte = 16rC2 and: [ lastByte = 16r85 ]) ifTrue: [ ^true ]. "Next Line, NEL"
	s = 2 ifTrue: [ ^false ].
	butButLastByte _ bytes at: s-2.
	(butButLastByte = 16rE2 and: [butLastByte = 16r80 and: [ "Line Separator and Paragraph Separator"
		lastByte = 16rA8 or: [lastByte = 16rA9]]]) ifTrue: [ ^true ].
	^false.
	! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:10:34'!
                            isLastSeparator
"A few more are missing!!"
	"
	(Utf8String withBytes: #[64 65 66]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 32]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 9]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 10]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 13]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 12]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 194 133]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!Utf8String methodsFor: 'accessing' stamp: 'svc 5/5/2022 15:51:50' overrides: 16901663!
size
	"Return how many characters I contain"
	
	self isEmpty ifTrue: [ ^ 0 ].
	count ifNil: [ self computeCountAndIndex ].
	^ count! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/11/2022 10:07:03'!
                      , anUtf8String
	^Utf8String withBytes: bytes, anUtf8String bytes.! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:58:18'!
                        copyFrom: startIndex to: stopIndex
	"Return a new string, a copy of me from startIndex to stopIndex, both character indices.
	Signal SubscriptOutOfBounds or CollectionIsEmpty in case of illegal indices."
	
	| startByteIndex stopByteIndex substring |
	startIndex = (self size+1) ifTrue: [ ^Utf8String empty ].
	stopIndex = 0 ifTrue: [ ^Utf8String empty ].
	self boundsCheck: startIndex. 
	self boundsCheck: stopIndex. 
	startByteIndex := self byteIndexAt: startIndex.
	stopByteIndex := self byteIndexAt: stopIndex.
	stopByteIndex := stopByteIndex + (self encodedByteCountAt: stopByteIndex) - 1.
	substring := Utf8String withBytes: (bytes copyFrom: startByteIndex to: stopByteIndex).
	self isAscii ifTrue: [ substring beAscii ].
	^ substring! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:58:18'!
                      copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ (self byteIndexAt: startIndex)-1.
	epilogFirstIndex _ self byteIndexAt: endIndex+1.
	^Utf8String withBytes:
		(bytes copyFrom: 1 to: prologLastIndex),
		replacement asUtf8,
		(bytes
			copyFrom: epilogFirstIndex
			to: bytes size)! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 5/11/2022 10:08:06' overrides: 16901772!
         = anUtf8String
	"Answer whether the receiver sorts equally as anUtf8String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == anUtf8String ifTrue: [ ^ true ].

	"If argument is not a anUtf32String, maybe it is a Text?"
	anUtf8String class == Utf8String ifFalse: [
		(anUtf8String is: #Text) ifTrue: [ ^ self = anUtf8String string ].
		^ false].

	bytes size = anUtf8String bytes size ifFalse: [
		^false ].

	bytes size > 256 ifTrue: [
		bytes hashQuick = anUtf8String bytes hashQuick ifFalse: [ ^false ]].

	^ bytes = anUtf8String bytes! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:38:57' overrides: 16901788!
      hash
	"Hash is reimplemented because = is implemented."

	^bytes hash! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:03'!
                  asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:11'!
                         asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:44' overrides: 16901837!
                     asString
	"Answer the receiver itself."
	^self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 3/13/2022 18:50:31'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:39'!
          asUtf32
	"Answer a WordArray."

	^String utf32FromUtf8: bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:29'!
                          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^self asUtf32! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:32'!
    asUtf8
	"Answer a ByteArray."

	^bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:10'!
                 asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-8 doesn't need them after all.
	Answer a ByteArray."

	^bytes! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:33'!
            from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n cpIndex |
	byteIndex _ self byteIndexAt: startIndex.
	cpIndex _ startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (UnicodeCodePoint codePoint: codePoint).
			cpIndex _ cpIndex + 1 ].
		byteIndex _ byteIndex + n ].! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:37'!
                 from: startIndex to: stopIndex doWithUtf8Bytes: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n stopByteIndex |
	byteIndex _ self byteIndexAt: startIndex.
	stopByteIndex _ self byteIndexAt: stopIndex.
	[ byteIndex <= stopByteIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: aBlock into: nil.
		byteIndex _ byteIndex + n ].! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:32' overrides: 16903326!
              is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!Utf8String methodsFor: 'testing' stamp: 'svc 5/5/2022 16:12:43'!
                     isAscii
	"Return true when I am pure 7-bit ASCII, which means each character is encoded as one byte."

	count ifNil: [ self computeCountAndIndex ].
	^ bytes size = count! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 5/3/2022 12:12:52'!
                 isEmpty
	^bytes isEmpty! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:35:03' overrides: 50347215!
              isStringLike

	^true! !
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:00'!
                            encompassLine: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:40'!
 encompassParagraph: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size]).
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!Utf8String methodsFor: 'character scanner support' stamp: 'jmv 5/11/2022 10:07:59'!
                 scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanUtf8StringFrom: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!Utf8String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:16:02'!
    edit

	self editLabel: 'UTF-8 Text Editor'! !
!Utf8String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:31'!
        editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:53:18'!
                beAscii
	"Mark me as being pure 7-bit ASCII, which means each character is encoded as one byte"
	
	count := bytes size.
	index := #().! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 16:04:35'!
                    boundsCheck: codePointIndex
	(codePointIndex between: 1 and: self size) 
		ifFalse: [ self errorSubscriptBounds: codePointIndex ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 16:25:57'!
                         byteIndexAt: codePointIndex
	| byteIndex |
	self isAscii ifTrue: [ ^ codePointIndex ].
	codePointIndex = (self size+1) ifTrue: [
		"The position a hypotetical extra code point would start at.
		Useful to find the last byte position for some codePointIndex. See senders."
		^bytes size+1 ].
	byteIndex := codePointIndex > self stride
		ifTrue: [
			index at: codePointIndex - 1 // self stride ]
		ifFalse: [ 1 ].
	codePointIndex - 1 \\ self stride timesRepeat: [ 
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ].
	^ byteIndex! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 16:46:33'!
                            codePointIndexAt: byteIndex
	| codePointIndex byteCursor |
	self isAscii ifTrue: [ ^ byteIndex ].
	codePointIndex := byteCursor := 1.
	index ifNil: [ self computeCountAndIndex ].
	index ifNotEmpty: [  
		index 
			findBinaryIndex: [ :x | byteIndex - x ] 
			do: [ :found | ^ (found * self stride) + 1 ] 
			ifNone: [ :lower :upper |
				lower = 0 
			 		ifFalse: [ 
						byteCursor := index at: lower. 
						codePointIndex := (lower * self stride) + 1 ] ] ].
	[ byteCursor <= bytes size ] whileTrue: [
		byteCursor = byteIndex 
			ifTrue: [ ^ codePointIndex ].
		byteCursor := byteCursor + (self encodedByteCountAt: byteCursor).
		codePointIndex := codePointIndex + 1 ].
	^ 0! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:39'!
                     computeCountAndIndex
	self isEmpty ifTrue: [ count := 0. ^ self ].
	"the number of characters cannot be larger than the byte size"
	bytes size <= self stride
		ifTrue: [ self computeCountNoIndex ]
		ifFalse: [ self computeCountAndIndexFull ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:55'!
         computeCountAndIndexFull
	count := 0.
	index := Array streamContents: [ :out | | byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:18'!
                           computeCountNoIndex
	| byteIndex |
	count := 0.
	index := #().
	byteIndex := 1.
	[ byteIndex <= bytes size ] whileTrue: [
		count := count + 1.
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:50:23'!
         encodedByteCountAt: byteIndex
	| byte |
	(byte := bytes at: byteIndex) < 128 ifTrue: [ ^ 1 ].
	(byte bitAnd: 2r11100000) = 2r11000000 ifTrue: [ ^ 2 ].
	(byte bitAnd: 2r11110000) = 2r11100000 ifTrue: [ ^ 3 ].
	(byte bitAnd: 2r11111000) = 2r11110000 ifTrue: [ ^ 4 ].
	self error: 'IllegalLeadingByte '! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:54'!
               stride
	"Return the stride, the constant I use internally to build my index"
	
	^ 32! !
!Utf8String methodsFor: 'as yet unclassified' stamp: 'jmv 5/11/2022 10:10:04' overrides: 50337880!
     doesNotUnderstand: aMessage

	{ 'Utf8String does not understand: '. aMessage} print! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:10:07'!
                      empty
	"Return the empty Utf8String instance.
	Since my instances are readonly, this could be cached."

	^ (self withBytes: #[]) beAscii; yourself! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:16:43'!
                        fromUtf32: aWordArray

	^self withBytes: (String utf8FromUtf32: aWordArray).! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:21'!
                              fromUtf8: bytes

	^self withBytes: bytes! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:11:25'!
 with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	Utf8String with: $a
	Utf8String with: $·
	Utf8String with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint).! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:11:36'!
                     with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter.
	Utf8String with: $a
	Utf8String with: $· with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint),
		(Character utf8BytesOfUnicodeCodePoint: otherCharacter codePoint).! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 12:10:29'!
         withBytes: aByteArray
	^self new bytes: aByteArray ! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/11/2022 10:05:41'!
                               scanUtf32StringFrom: startIndex to: stopIndex in: anUtf32String rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	anUtf32String words from: startIndex to: stopIndex do: [ :code |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		code < 256 ifTrue: [
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOfCodePoint: code).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/11/2022 10:08:19'!
             scanUtf8StringFrom: startIndex to: stopIndex in: anUtf8String rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	anUtf8String from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!Object methodsFor: 'testing' stamp: 'jmv 5/11/2022 10:08:57' prior: 50347215!
                        isStringLike
	"Overridden to return true in String, Utf8String and Utf32String."
	^ false! !
!String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:22' prior: 16949318!
             editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Text methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:26' prior: 16964294!
                              editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !

CharacterScanner removeSelector: #scanStringUtf8From:to:in:rightX:stopConditions:!

!methodRemoval: CharacterScanner #scanStringUtf8From:to:in:rightX:stopConditions: stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
scanStringUtf8From: startIndex to: stopIndex in: aStringUtf8 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf8 from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode!

CharacterScanner removeSelector: #scanStringUtf32From:to:in:rightX:stopConditions:!

!methodRemoval: CharacterScanner #scanStringUtf32From:to:in:rightX:stopConditions: stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
scanStringUtf32From: startIndex to: stopIndex in: aStringUtf32 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf32 words from: startIndex to: stopIndex do: [ :code |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		code < 256 ifTrue: [
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOfCodePoint: code).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode!

Smalltalk removeClassNamed: #StringUtf32!

!classRemoval: #StringUtf32 stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf32
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

Smalltalk removeClassNamed: #StringUtf8!

!classRemoval: #StringUtf8 stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf8
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 10:27:09 am'!
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:05:27'!
                               readIfNeeded: nameOrDirectory
	"Read from disk if not in memory"

	(FontFamily familyNamed: nameOrDirectory)
		ifNotNil: [ :it | ^it ].
	^FontFamily availableFamilies values
		detect: [ :any | any folderName = nameOrDirectory name ]
		ifNone: [
			FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: nameOrDirectory) anyOne ]! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:06:50' prior: 16860375!
                    promptUser
	"Present a menu of font families, answer selection.
	FontFamily promptUser
	"
	^self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		self readIfNeeded: selectedNameOrDirectory ].! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:12:56' prior: 50336229!
                               promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				Preferences setDefaultFont: fontFamily familyName ]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5147-FontFamily-tweaks-JuanVuletich-2022May12-10h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5147] on 12 May 2022 at 10:40:53 am'!
!StrikeFontFamily methodsFor: 'testing' stamp: 'jmv 5/12/2022 10:36:05'!
       includesAscii
	"Answer true if we include the basic ASCII characters.
	If not, we are not suitable, for instance, for displaying Smalltalk code."
	^true! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:37:23' prior: 50352036!
                promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				fontFamily includesAscii
					ifTrue: [Preferences setDefaultFont: fontFamily familyName ]
					ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5148-DefaultFontMustIncludeASCII-JuanVuletich-2022May12-10h40m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5148] on 12 May 2022 at 2:53:39 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/12/2022 14:53:09' prior: 16952849!
                     knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 						'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 						'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 						'Fernando Olivero')
	#('FernanodOlivero' 						'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 						'Gabriel Omar Cotelli')
	#('GC' 						'GastÛn Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 						'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 						'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 						'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 						'Marcus Denker')
	#('marcus.denker' 						'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 						'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 		'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 						'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'						'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'						'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'						'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'						'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'						'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 						'Stephane Ducasse')
	#('stephaneducasse'	 					'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 						'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 						'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 						'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5149-Add-DavidFaitelson-asKnownAuthor-JuanVuletich-2022May12-14h53m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5141] on 9 May 2022 at 6:14:00 pm'!
!Fraction commentStamp: 'len 5/9/2022 18:06:15' prior: 16863542!
             Fraction provides methods for dealing with rational numbers like 1/3 as true fractions (not approximations as a Float 0.33333...). All public arithmetic operations answer reduced fractions, or Integers when the denominator is 1.

Examples: (note the parentheses required to get the right answers in Smalltalk):

(2/3) + (2/3)
(6/4)		 		"Fractions are reduced to the smallest numerator and denominator possible"
(1 / -3)			"Denominator is kept positive, the sign is always in the numerator"
(2/3) + (1/3)	"When the denominator reduces to 1, the answer is an Integer"
!
!BitBltCanvas commentStamp: '<historical>' prior: 16789070!
            origin is aPoint, and it is expressed relative to the form. Usually, the form doesn't cover the whole World, and origin is negative. For instance, if we just want to draw the part of the World in (100@100 extent: 50@50) to another form, then fom extent = 50@50, and origin = -100@ -100.

clipRect is relative to the form. For instance, if we only need to draw the part in (110@110 extent: 20@20) to the form above, then clipRect is (10@10 extent: 20@20)

All public protocol and drawing services is relative to World. The idea is that we only care about origin/form when we set them. Afterwards, we don't need to care about them. All the operations are done as if the whole World was drawn on Display.!
!Form methodsFor: 'transitions' stamp: 'len 5/9/2022 17:58:14' prior: 16862659!
                 slideImage: otherImage at: topLeft delta: delta
	"
	Display slideImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse
		at: 40@40 delta: 3@ -4
	"
	| bb nSteps clipRect |
	bb _ otherImage boundingBox.
	clipRect _ topLeft extent: otherImage extent.
	nSteps _ 1.
	delta x = 0 ifFalse: [nSteps _ nSteps max: (bb width//delta x abs) + 1].
	delta y = 0 ifFalse: [nSteps _ nSteps max: (bb height//delta y abs) + 1].
	1 to: nSteps do: [ :i | 
			self 
				copyBits: bb from: otherImage
				at: delta*(i-nSteps) + topLeft
				clippingBox: clipRect rule: Form paint.
			Display forceToScreen.
		]! !
!Form methodsFor: 'transitions' stamp: 'len 5/9/2022 17:58:26' prior: 16862702!
                            wipeImage: otherImage at: topLeft delta: delta
	"Display wipeImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse
		at: 40@40 delta: 0@ -2"

	self wipeImage: otherImage at: topLeft delta: delta clippingBox: nil.
! !
!Form class methodsFor: 'examples' stamp: 'len 5/9/2022 17:58:20' prior: 16863296!
               toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ `Color red wheel: 12`.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: `-40@ -40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!Form class methodsFor: 'examples' stamp: 'len 5/9/2022 17:58:33' prior: 16863333!
           xorHack: size  "Display restoreAfter: [Form xorHack: 256]"
	"Draw a smiley face or stick figure, and end with option-click.
	Thereafter image gets 'processed' as long as you have button down.
	If you stop at just the right time, you'll see you figure upside down,
	and at the end of a full cycle, you'll see it perfectly restored.
	Dude -- this works in color too!!"
	| rect form i bb |
	rect _ 5@5 extent: size@size.
	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.
	Display border: (rect topRight - (0@2) extent: rect extent*2 + 4) width: 2.
	Form exampleSketch.
	form _ Form fromDisplay: rect.
	bb _ form boundingBox.
	i _ 0.
	[Sensor isMouseButton2Pressed] whileFalse:
		[[Sensor isMouseButton1Pressed] whileTrue:
			[i _ i + 1.
			(Array with: 0@1 with: 0@ -1 with: 1@0 with: -1@0) do:
				[:d | form copyBits: bb from: form at: d
					clippingBox: bb rule: Form reverse ].
			form displayAt: rect topLeft.
			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].
		(form magnify: form boundingBox by: 2@2) displayAt: rect topRight + (2@0).
		Sensor waitButton].! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:38' prior: 16834435!
                               bottomLeftCursor
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1111111111111100
		2r1111111111111100
		2r0000000000000000
		2r0000000000000000)
	offset: `0@ -16`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:43' prior: 16834451!
                        bottomRightCursor
	^  Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r1111111111111100
		2r1111111111111100
		2r0000000000000000
		2r0000000000000000)
	offset: `-16@ -16`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:46' prior: 16834467!
                    cornerCursor
	"Answer the instance of me that is the shape of the bottom right corner 
	of a rectangle."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r1111111111111100
		2r1111111111111100
		2r0000000000000000
		2r0000000000000000)
	offset: `-16@ -16`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:50' prior: 16834486!
                              crossHairCursor
	"Answer the instance of me that is the shape of a cross."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0111111111111100
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:53' prior: 16834617!
                              normalCursorWithMask
	"Cursor initNormalWithMask.  Cursor normal show"
	"Next two lines work simply for any cursor..."
	"
	self initNormal.
	NormalCursor _ CursorWithMask derivedFrom: NormalCursor.
	"
	"But for a good looking cursor, you have to tweak things..."
	^ ((CursorWithMask
		small1BitExtent: `16@16`
		pixelBits: #(
			2r0000000000000000
			2r0100000000000000
			2r0110000000000000
			2r0111000000000000
			2r0111100000000000
			2r0111110000000000
			2r0111111000000000
			2r0111111100000000
			2r0111111110000000
			2r0111110000000000
			2r0110110000000000
			2r0100011000000000
			2r0000011000000000
			2r0000001100000000
			2r0000001100000000
			2r0000000000000000)
		offset: `-1@ -1`)
	setMaskForm: 
		(Form
			small1BitExtent: `16@16`
			pixelBits: #(
				2r1100000000000000
				2r1110000000000000
				2r1111000000000000
				2r1111100000000000
				2r1111110000000000
				2r1111111000000000
				2r1111111100000000
				2r1111111110000000
				2r1111111111000000
				2r1111111111100000
				2r1111111000000000
				2r1110111100000000
				2r1100111100000000
				2r1000011110000000
				2r0000011110000000
				2r0000001110000000)
			offset: `0@0`))! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:20' prior: 16834728!
                            resizeLeftCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0000010010000000
		2r0000010010000000
		2r0000010010000000
		2r0001010010100000
		2r0011010010110000
		2r0111010010111000
		2r1111110011111100
		2r0111010010111000
		2r0011010010110000
		2r0001010010100000
		2r0000010010000000
		2r0000010010000000
		2r0000010010000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:24' prior: 16834750!
          resizeTopCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000100000000
		2r0000001110000000
		2r0000011111000000
		2r0000111111100000
		2r0000000100000000
		2r0111111111111100
		2r0000000000000000
		2r0000000000000000
		2r0111111111111100
		2r0000000100000000
		2r0000111111100000
		2r0000011111000000
		2r0000001110000000
		2r0000000100000000
		2r0000000000000000
		2r0000000100000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:27' prior: 16834767!
           resizeTopLeftCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0111110000010000
		2r0111100000100000
		2r0111000001000100
		2r0110100010001000
		2r0100010100010000
		2r0000001000100000
		2r0000010001000000
		2r0000100010000000
		2r0001000101000100
		2r0010001000101100
		2r0000010000011100
		2r0000100000111100
		2r0000000001111100
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:31' prior: 16834784!
       resizeTopRightCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0001000001111100
		2r0000100000111100
		2r0100010000011100
		2r0010001000101100
		2r0001000101000100
		2r0000100010000000
		2r0000010001000000
		2r0000001000100000
		2r0100010100010000
		2r0110100010001000
		2r0111000001000000
		2r0111100000100000
		2r0111110000000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:35' prior: 16834820!
      squareCursor
	"Answer the instance of me that is the shape of a square."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000001111000000
		2r0000001111000000
		2r0000001111000000
		2r0000001111000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-8@ -8`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:38' prior: 16834838!
targetCursor
	"Answer the instance of me that is the shape of a gunsight."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000011111000000
		2r0001100100110000
		2r0010000100001000
		2r0100000100000100
		2r0100001110000100
		2r1000000100000010
		2r1000100100100010
		2r1111111011111110
		2r1000100100100010
		2r1000000100000010
		2r0100001110000100
		2r0100000100000100
		2r0010000100001000
		2r0001100100110000
		2r0000011111000000
		2r0000000000000000)
	offset: `-7@ -7`! !
!CursorWithAlpha class methodsFor: 'constants' stamp: 'len 5/9/2022 18:03:43' prior: 16835014!
                             biggerNormal
	"
	CursorWithAlpha biggerNormal show
	"

	^self constants at: #biggerNormal ifAbsentPut: [
		| form cursor packName pack |
		packName _ #GUIFormsPack.
		pack _ (Smalltalk at: packName) new.
		form _ (pack decodeContentFrom: pack contentMap) at: 'biggerNormalCursor'.
		cursor _ CursorWithAlpha extent: form extent depth: 32.
		form displayOn: cursor.
		cursor offset: -2@ -1.
		cursor preMultiplyAlpha.
		cursor ]! !
!Point methodsFor: 'point functions' stamp: 'len 5/9/2022 18:03:53' prior: 16913054!
                            eightNeighbors
	^ (Array with: self + `1@0`
		with: self + `1@1`
		with: self + `0@1`
		with: self + `-1@1`) ,
	(Array with: self + `-1@0`
		with: self + `-1@ -1`
		with: self + `0@ -1`
		with: self + `1@ -1`)! !
!Point methodsFor: 'point functions' stamp: 'len 5/9/2022 18:03:57' prior: 16913075!
                      fourNeighbors
	^ Array with: self + `1@0`
		with: self + `0@1`
		with: self + `-1@0`
		with: self + `0@ -1`! !
!Morph methodsFor: 'drawing' stamp: 'len 5/9/2022 18:04:09' prior: 16891923!
    drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."

	aCanvas
		fillRectangle: `-75 @ -70 corner: 75 @ 70`
		color: `Color blue`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5150-AtMinusFixes-LucianoEstebanNotarfrancesco-2022May09-17h58m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5150] on 12 May 2022 at 5:13:14 pm'!
!Number methodsFor: 'arithmetic' stamp: 'jmv 5/12/2022 16:59:55' prior: 16900122!
                 \\ divisor
	"Modulo operation. Remainder of the integer division #// (Floored division, truncated to minus infinity, a.k.a Knuth's division)
	Answer a Number with the same sign as divisor. 
	9\\4 = 1
	-9\\4 = 3
	9\\ -4 = -3
	0.9\\0.4 = 0.1
	See http://en.wikipedia.org/wiki/Modulo_operation
	See #\\, #rem: and #mod:
	See detailed discussion at http://mathforum.org/library/drmath/view/52343.html
	"

	^self - (self // divisor * divisor)

	"Evaluate the following:"
"
Compiler evaluate: '
	| g d |
	d _ 1.
	Feature require: ''Morphic-Widgets-Extras''.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x \\ d ] color: Color green.
	g addFunction: [ :x | x // d ] color: Color red.
	g openInWorld'
"
"
Compiler evaluate: '
	| g d |
	d _ -1.
	Feature require: ''Morphic-Widgets-Extras''.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x \\ d ] color: Color green.
	g addFunction: [ :x | x // d ] color: Color red.
	g openInWorld'
"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5151-BinaryMinusFix-JuanVuletich-2022May12-17h12m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5151] on 12 May 2022 at 5:34:51 pm'!
!Point methodsFor: 'printing' stamp: 'jmv 5/12/2022 17:24:12' prior: 16913255 overrides: 16902975!
printOn: aStream 
	"The receiver prints on aStream in terms of infix notation."

	x printOn: aStream.
	aStream nextPut: $@; space.
	y printOn: aStream! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5152-FixForDecompiledCode-JuanVuletich-2022May12-17h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5152] on 13 May 2022 at 4:26:43 pm'!

Object subclass: #PreferenceNG
	instanceVariableNames: 'name description category value type'
	classVariableNames: 'ThePreferences'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #PreferenceNG category: #'System-Support' stamp: 'Install-5153-PreferenceNG-HilaireFernandes-2022May13-16h26m-hlsf.001.cs.st 5/16/2022 10:22:26'!
Object subclass: #PreferenceNG
	instanceVariableNames: 'name description category value type'
	classVariableNames: 'ThePreferences'
	poolDictionaries: ''
	category: 'System-Support'!
!PreferenceNG commentStamp: '<historical>' prior: 0!
                    My instance is a Preference whose value is of a given class (type), or follow the description of the type instance

- name, category: symbol
- description: string
- type: a class (Boolean, String, Color, BlockClosure, etc.) or an instance (collection, intervale, etc.)
- value: an object whose class match type or the instance description of the type

Modus Operendi
- To create a Preference, invoke the instance creation class method (Preference name:description:category:type:value:). The new preference is automatically remembered. If a preference with same name already exist, its instance is updated with the new provided data and its instance returned.
- To access, invoke as dictionary (Preference at: #biggerCursors), a short cut exist (Preference biggerCursors)
- When a preference value is changed with its #value message, an event #preferenceChanged is triggered.
- Tools can listen to a specific #preferenceChanged event: 
	(Preference instanceAt: #guiElementSize) when: #preferenceChanged send: #shakeScreen: to: myTool
By default the Preference class listen to a few event to adjust the behavior of the image to some preference changes.	
!
!PreferenceNG methodsFor: 'printing' stamp: 'hlsf 5/5/2022 12:31:23' overrides: 16902975!
    printOn: aStream
	aStream nextPutAll: self class name ;
		nextPutAll: ' (#';
		nextPutAll: name ;
		nextPutAll: ' = ';
		nextPutAll: type printString;
		nextPutAll: '::';
		nextPutAll: value printString;
		nextPut: $)! !
!PreferenceNG methodsFor: 'initialization' stamp: 'hlsf 5/5/2022 12:21:27'!
                       name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
	name _ nameSymbol.
	description _ aString.
	category _ categorySymbol.
	type _ aType ifNotNil: [aType] ifNil: [self class detectType: aValue ].
	value _ 	aValue! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/10/2022 19:34:21'!
                          accept: aVisitor
	| visitMethod |
	self isTypeAClass 
		ifTrue: [ visitMethod _ ('visit', type name, 'Preference:') asSymbol ]
		ifFalse: [visitMethod _ ('visit', type species, 'Preference:') asSymbol ].
	aVisitor perform: visitMethod with: self! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:25:45'!
                               category
	^ category ! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/2/2022 22:19:11'!
category: aSymbol
	aSymbol isNil ifFalse: [category _ aSymbol ]! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:25:57'!
                     description
	^ description! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/2/2022 22:18:30'!
                           description: aString
	aString isEmptyOrNil ifFalse: [description _ aString ]! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:26:02' overrides: 16903442!
                    name
	^ name! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/4/2022 23:32:57'!
         type
	^ type! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/3/2022 21:16:04' overrides: 16902254!
                     value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value value]
		ifFalse: [value]
	! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/9/2022 22:01:23'!
              value: aValue	
	self isTypeAClass 
		ifTrue: [
			(aValue isKindOf: type) ifFalse: [self error: aValue printString, ' is not a ', type printString].
			value _ aValue ]
		ifFalse: [ "Should be handled somehow by the preference editor "
			value _ aValue].
	self triggerEvent: #preferenceChanged with: self! !
!PreferenceNG methodsFor: 'testing' stamp: 'hlsf 5/9/2022 22:01:40'!
      isTypeAClass
" is type a Class or an Instance "
	^ type class class == Metaclass ! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 21:11:22'!
                             all
	^ ThePreferences 
	! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 22:21:36' overrides: 16901507!
  at: symbolName
	^ (self instanceAt: symbolName) value! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 5/3/2022 20:47:15' overrides: 16901525!
      at: symbolName put: aValue
	| myPref |
	myPref _ self instanceAt: symbolName. 
	myPref value: aValue! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:28:57'!
          categories
	| categories |
	categories _ Set new.
	ThePreferences values do: [:aPreference | categories add: aPreference category].
	^ categories sorted! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 22:19:26'!
                      instanceAt: symbolName
	^ ThePreferences at: symbolName ifAbsent: [self error: 'Unknown preference ', symbolName ]! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:29:56'!
                            select: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]! !
!PreferenceNG class methodsFor: 'instance creation' stamp: 'hlsf 5/3/2022 19:16:59'!
              name: nameSymbol category: categorySymbol value: aValue
	self name: nameSymbol description: nil category: categorySymbol type: nil value: aValue 
! !
!PreferenceNG class methodsFor: 'instance creation' stamp: 'hlsf 5/3/2022 19:59:49'!
                     name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
"If I exist, I am updated with the newer sent data "
	(nameSymbol isSymbol or: [categorySymbol isSymbol]) ifFalse: 
		[self error: 'Preference Name & Category are not valid symbol.'].
	^ ThePreferences 
		at: nameSymbol
		ifPresent: [:thePref |
			thePref 
				description: aString;
				category: categorySymbol;
				value: aValue;
				yourself]
		ifAbsent: [ | newPref |
			newPref _ self new ::
				name: nameSymbol 
				description: aString 
				category: categorySymbol 
				type: aType 
				value: aValue.
			ThePreferences at: nameSymbol put: newPref ].
	! !
!PreferenceNG class methodsFor: 'error handling' stamp: 'hlsf 4/30/2022 22:20:35' overrides: 50337880!
           doesNotUnderstand: aMessage
	aMessage hasArguments ifTrue: [^ super doesNotUnderstand: aMessage].
	^ self at: aMessage selector! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/7/2022 18:06:54' overrides: 16904184!
                 initialize
	ThePreferences _ Dictionary new.
	#(gui font programming system) do: [: category | 
		(self perform: (#pref, category capitalized) asSymbol) do: [:aPrefArray |
			self installDefault: aPrefArray in: category] ].
	self installHaloPreferencesWith: self iconicHaloSpecifications.
	self installMiscPreferences ! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/7/2022 00:47:32'!
      installDefault: anArray in: category
" Description of preference in Array: name - value - type (optional) - event handler (optional) "
	| myPref |
	myPref _ PreferenceNG name: anArray first 				description: '' category: category 
		type: (anArray at: 3 ifAbsent: [self detectType: anArray second]) value: anArray second.
	anArray size = 4 ifTrue: [ "fourth record is an event listener hooked to Preference"
		myPref when: #preferenceChanged send: anArray fourth to: PreferenceNG.
		myPref triggerEvent: #preferenceChanged with: myPref]
	! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/4/2022 16:10:52'!
           installHaloPreferencesWith: anArray
	| aColor |
	^ PreferenceNG 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each |
			aColor _ Color.
			each fourth do: [ :sel | aColor _ aColor perform: sel].
			HaloSpec new 
				horizontalPlacement: each second
				verticalPlacement: each third 
				color: aColor
				iconSymbol: each fifth
				addHandleSelector: each first
				hoverHelp: each sixth])! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 11:35:43'!
      installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	PreferenceNG 
		name: #haloHandleSize category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 5 // 3 max: 16].
	PreferenceNG
		name: #roundedButtonRadius 	category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 8 // 14].
	PreferenceNG
		name: #roundedWindowRadius 	category: #gui value: [(PreferenceNG at: #standardListFont) pointSize].
	PreferenceNG
		name: #scrollbarThickness category: #gui 		value: [(PreferenceNG at: #windowTitleFont) pointSize + 2].
	PreferenceNG name: #classFinder category: #programming value: [ BrowserWindow findClass ].
	PreferenceNG name: #defaultAuthorName category: #programming value: [Utilities authorName].! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 5/6/2022 11:42:57'!
                               loadFrom: aFileEntry
" Load all preferences from file, update the existing preferences with the data from file "
	(SmartRefStream restoreFromFile: aFileEntry) do: [:aPref | 
		PreferenceNG 
			name: aPref name 
			description: aPref description 
			category: aPref category 
			type: aPref type 
			value: (aPref instVarNamed: #value)	 " We want the raw value "]! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 4/30/2022 22:20:56'!
   save: nameSymbol to: aFileEntry
" Save one preference to a file, even for a sole preference we save in a Dictionary"
	| myPref |
	myPref _ self instanceAt: nameSymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: {myPref name -> myPref} asDictionary! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 4/30/2022 21:58:19'!
            saveAllTo: aFileEntry
" Save all the preferences to a file "
	SmartRefStream dumpOnFile: aFileEntry object: ThePreferences! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 4/30/2022 21:57:59'!
                   saveCategory: categorySymbol to: aFileEntry
	| myPref |
	myPref _ self select: categorySymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: 	(myPref collect: [:aPref | aPref name -> aPref ]) asDictionary! !
!PreferenceNG class methodsFor: 'helpers' stamp: 'hlsf 5/12/2022 13:07:56'!
                             detectType: anObject
"When the type is not provided, we can try to deduce it "
	^ anObject class name
		caseOf: {
			[#True] -> [Boolean].
			[#False] -> [Boolean].
			[#StrikeFont] -> [AbstractFont].
			[#TrueTypeFont ] -> [AbstractFont]
		}
		otherwise: [anObject class]
! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/6/2022 23:07:40'!
   iconicHaloSpecifications
"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles 
that may be used in the iconic halo scheme"

^ #(	"selector					horiz			vert			color info				icon key"
(addDismissHandle:						left			top			(red)				haloDismissIcon 					'Remove')
(addMenuHandle:						leftCenter			top			(blue lighter)				haloMenuIcon 					'Menu')
(addGrabHandle:						center			top			(black)				haloGrabIcon 					'Pick up')
(addDragHandle:						rightCenter			top			(brown)				haloDragIcon 					'Move')
(addDupHandle:						right			top			(green)				haloDuplicateIcon     					'Duplicate')	
(addExploreHandle:						left			topCenter			(orange)				haloDebugIcon 					'Explore')
(addDebugHandle:						right			topCenter			(orange)				haloDebugIcon 					'Debug')
(addCollapseHandle:						left			center			(tan)				haloCollapseIcon 					'Collapse')
(addScaleHandle:						right			center			(blue)				haloScaleIcon 					'Change scale')
(addRotateHandle:						left			bottom			(blue)				haloRotateIcon 					'Rotate')
(addHelpHandle:						center			bottom			(lightBlue)				haloHelpIcon 					'Help')
(addResizeHandle:						right			bottom			(yellow)				haloResizeIcon 					'Change size')
	"FIXME - Currently non-functional...
	(addRecolorHandle:						right			bottomCenter			(magenta darker)						haloColorIcon 						'Change color')	"
)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/7/2022 17:54:36'!
      machineDefault
	^ #(
		#(drawKeyboardFocusIndicator true )
		#(balloonHelpEnabled true )
		#(biggerCursors false )
		#(browseWithPrettyPrint false )
		#(caseSensitiveFinds false )
		#(checkForSlips true )
		#(cmdDotEnabled true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(menuKeyboardControl true )
		#(optionalButtons true )
		#(extraDebuggerButtons true )
		#(subPixelRenderFonts true )
		#(thoroughSenders true )
		#(cheapWindowReframe false )
		#(syntaxHighlightingAsYouType true )
		#(tapAndHoldEmulatesButton2 true )
		#(clickGrabsMorphs false )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(wantsMenuIcons true )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/7/2022 17:54:24'!
       machineSlow
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
		(methodAnnotations #(timeStamp messageCategory packages changeSets) )
		(classAnnotations  #(instanceMethodsCount classMethodsCount) )
		(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount) )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/7/2022 17:54:51'!
                   machineSmalltalk80
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 10:49:26'!
        prefFont
	^ #( 
		#(aaFontsColormapDepth 4)
		#(cacheTrueTypeGlyphs true )
		#(guiElementsSize standardFonts #(tinyFonts verySmallFonts smallFonts standardFonts largeFonts veryLargeFonts hugeFonts) defaultFontSize: )
		#(loadOnlyLatinGlyphData false )
		#(properDisplayAlphaForFonts false )	
		#(subPixelRenderColorFonts true )
		#(subPixelRenderFonts true )	
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 08:48:37'!
         prefGui
	^ #( 
		#(balloonHelpEnabled true )
		#(biggerCursors false )		
		#(cacheDisplayContentWhenMovingMorphs true )
		#(cheapWindowReframe false )		
		#(clickGrabsMorphs false )	
		#(ctrlArrowsScrollHorizontally false ) 
		#(drawKeyboardFocusIndicator true )
		#(focusFollowsMouse true )
		#(focusIndicatorWidth 1)
		#(fullScreenLeavesDeskMargins true )
		#(haloEnclosesFullBounds true )
		#(halosShowCoordinateSystem true )
		#(menuKeyboardControl true )
		#(optionalButtons true )		
		#(selectiveHalos true )
		#(tapAndHoldEmulatesButton2 true )
		#(tileResizerInWindowMenu true )
		#(wantsMenuIcons true )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 12:05:02'!
            prefProgramming
	^ #(
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 11:50:23'!
            prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges false )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 00:41:45'!
         assignmentGlyph: assignmentPref
" #assignmentGliphSelector changed "
	AbstractFont withAllSubclassesDo: [ :fontClass | fontClass assignmentGlyphSelectorPreferenceChanged ]! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 00:41:12'!
                               defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	PreferenceNG name: #standardListFont category: #font value: font.
	PreferenceNG name: #standardMenuFont category: #font value: font.
	PreferenceNG name: #standardCodeFont category: #font value: font.
	PreferenceNG name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	PreferenceNG name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	PreferenceNG at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^font! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 18:08:45'!
                         machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray |
	prefArray _ self perform: (#machine, machinePref value capitalized) asSymbol.
	prefArray do: [:array | 		PreferenceNG at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]
	! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 01:09:27'!
 menuIcon: wantsMenuIconsPref
	Theme current class beCurrent! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 17:43:12'!
               pointer: pointerPref
	| enabled |
	enabled _ pointerPref value == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 		PreferenceNG at: aPref put: enabled]! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/3/2022 18:58:38'!
      fontSizes
	^ `{
		#tinyFonts -> 7 .
		#verySmallFonts -> 9 .
		#smallFonts ->11 .
		#standardFonts -> 14 .
		#largeFonts -> 18 .
		#veryLargeFonts -> 24 .
		#hugeFonts -> 32} asDictionary`
		! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/12/2022 11:53:18'!
                   setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	PreferenceNG
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (PreferenceNG at: #standardListFont) pointSize.}.
				{#standardMenuFont. (PreferenceNG at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (PreferenceNG at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (PreferenceNG at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (PreferenceNG at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/3/2022 19:39:30'!
       setDefaultFont: fontFamilyName spec: defaultFontsSpec
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font _ font emphasized: triplet third ].
		PreferenceNG at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceNG class methodsFor: 'obsolete' stamp: 'hlsf 5/4/2022 14:56:05'!
             desktopMenuTitle
"I have project to get rid of this one"
	^ 'World'   ! !

PreferenceNG initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5153-PreferenceNG-HilaireFernandes-2022May13-16h26m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 9:07:39 am'!
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 08:58:17'!
          useMenuIcons
	PreferenceNG at: #wantsMenuIcons put: true! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 08:58:40'!
                        useNoMenuIcons
	PreferenceNG at: #wantsMenuIcons put: false! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'hlsf 5/12/2022 09:00:04' prior: 16954503!
     reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	PreferenceNG at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Cursor class methodsFor: 'accessing' stamp: 'hlsf 5/12/2022 08:31:36' prior: 16834391!
          defaultCursor
	"Answer the instance of me that is the shape of an arrow slanted left."
	^ (PreferenceNG at: #biggerCursors)
		ifTrue: [ CursorWithAlpha biggerNormal ]
		ifFalse: [ self cursorAt: #normalCursorWithMask ].! !
!Cursor class methodsFor: 'current cursor' stamp: 'hlsf 5/12/2022 08:31:28' prior: 16834417!
    currentCursor: aCursor 
	"Make the instance of cursor, aCursor, be the current cursor. Display it. 
	Create an error if the argument is not a Cursor."

	CurrentCursor _ aCursor.
	(PreferenceNG at: #biggerCursors)
		ifTrue: [
			[ ^aCursor asBigCursor installCursor] 
				on: Error do: nil  "fall through "].
	aCursor installCursor! !
!Morph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:15' prior: 16892320!
    mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."

	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [evt hand releaseKeyboardFocus: self].
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: evt ].! !
!Morph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 08:39:43' prior: 16893013!
         displayBoundsForHalo
	"Answer the rectangle to be used as the inner dimension of my halos.
	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."

	^ (PreferenceNG at: #haloEnclosesFullBounds)
		ifFalse: [ self displayBounds ]
		ifTrue: [ self displayFullBounds ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 09:06:30' prior: 16893803!
           addHandlesTo: aHaloMorph box: box
	"Add halo handles to the halo.  Apply the halo filter if appropriate"

	(PreferenceNG at: #haloSpecifications) do: [ :aSpec |
		(self
			wantsHaloHandleWithSelector: aSpec addHandleSelector
			inHalo: aHaloMorph) ifTrue: [
		aHaloMorph
			perform: aSpec addHandleSelector
			with: aSpec ]].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 08:45:19' prior: 16893882!
                        haloShowsCoordinateSystem

	^PreferenceNG at: #halosShowCoordinateSystem! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 08:30:10' prior: 16894003!
                      wantsBalloon
	"Answer true if receiver wants to show a balloon help text is a few moments."

	^ (self balloonText notNil) and: [PreferenceNG at: #balloonHelpEnabled]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 08:47:56' prior: 16894015!
                         wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	(#(addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].

	(PreferenceNG at: #selectiveHalos) ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addResizeHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily | self okayToScaleEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addScaleHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToScaleEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 5/12/2022 08:49:45' prior: 16865619!
         waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel

	"Wait until the difference between click, or drag gesture is known, then inform the given morph what transpired." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: nil
			dblClick: nil
			dblClickAndHalf: nil
			tripleClick: nil
			event: evt
			sendMouseButton2Activity: (PreferenceNG at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 5/12/2022 08:49:57' prior: 16865640!
           waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel

	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (PreferenceNG at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 5/12/2022 08:50:06' prior: 16865687!
         waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel dragSel: dragSel
	
	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: dragSel
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (PreferenceNG at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 08:32:17' prior: 16866137 overrides: 16909517!
                           morphPosition: aPoint
	"Change the position of this morph. Argument is in owner's coordinates."

	| prevTranslation |
	prevTranslation _ location translation.
	location _ location withTranslation: aPoint.
	"Ask if translation effectively changed, after possible conversion to 32 bit Float in AffineTransformation. "
	location translation = prevTranslation ifFalse: [
		self isDrawnBySoftware
			ifTrue: [
				(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs)
					ifTrue: [
						"We are caching whatever is in the Display below us. Thefore, there's no need
						to do an invalidation that would trigger the redraw of everything below us."
						self needsRedraw: true ]
					ifFalse:  [
						"No caching of stuff below us. Just invalidate and redraw."
						self redrawNeeded ]]
			ifFalse: [
				lastPosition _ nil.		"Not nil if carrying morphs at that moment"
				prevFullBounds _ nil "Any saved patch is no longer relevant"]].! !
!HandMorph methodsFor: 'private events' stamp: 'hlsf 5/12/2022 08:34:34' prior: 16866442!
                        generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp mouseScrollDirection |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [
		(keyValue = 9 and: [(modifiers anyMask: 1) and: [Smalltalk platformName = 'unix']])
			ifTrue: [
				"Linux VMs don't generate shift-tab keystroke. Turn #keyUp into #keystroke"
				pressType _ EventSensor eventKeyChar ]
			ifFalse: [type _ #keyUp ]].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [ 											"Control key pressed"
			keyValue < 27 ifTrue: [ 										"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [   									"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [ 			"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96   						"shift not pressed: conver to lowercase letter" ]]]].
			"On Windows, ctrl-backSpace is reported as ctrl-forwardDelete. But keyDown is ok, so we can know and fix."
			(keyValue = 127 and: [ lastKeyDownValue = 8 ])
				ifTrue: [ keyValue _ 8 ].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]].
		(modifiers anyMask: 8) ifTrue: [ 									"CmdAlt key pressed (or Control key pressed, and #shouldControlEmulateAltFor: just answered true)"
			(modifiers anyMask: 1) ifTrue: [								"Shift pressed"
				| i |
				"It seems that for ctrl-shifted keys and cmd-shifted keys, the VM incorrectly reports the UNSHIFTED character.
				Correct this, at least for common cmd-shortcuts, and for the US keyboard... Sigh...
				(This has only been observed on Mac VMs, but seems harmless if proper shifted character is reported (as in Linux), as this wil be NOP)
				(On Windows, the situation is even worse: ctrl-{ is not even reported as a keystroke event. Only keyDown and keyUp.)"
				"#($' $, $. $9 $0 $[ $]) -> #($'' $< $> $( $) ${) $}"
				i _ #[39 44 46 57 48 91 93 ] indexOf: keyValue.
				i > 0 ifTrue: [
					keyValue _ #[34 60 62 40 41 123 125] at: i ]]]].
	buttons _ modifiers bitShift: 3.
	"Linux and Windows VM send keyboard ctrl-upArrow and ctrl-downArrow when the user tries to scroll using the mouse wheel
	Mac VM sends cmd-option-ctrl-shift-upArrow and cmd-option-ctrl-shift-downArrow for trackpad vertical scroll gestures,
		and cmd-option-ctrl-shift-leftArrow and cmd-option-ctrl-shift-rightArrow for horizontal scroll gestures.
	This way of reporting scroll events by the VM also enables scrolling using the keyboard (actually, we can't tell if user gesture was on Mouse, Trackpad or Keyboard).
	But ctrl-shift and cmdAlt-shift are needed used for selecting while moving by word, line, etc.
	Additionally, #ctrlArrowsScrollHorizontally allows chosing between keyboard horizontal scroll and moving word by word in text editors."
	mouseScrollDirection _ nil.
	"Ctrl for Keyboard or Mouse wheel gestures. All modifiers for Trackpad gestures."
	(buttons = InputSensor controlKey or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 30
			ifTrue: [mouseScrollDirection _ #up]
		ifFalse: [keyValue = 31
			ifTrue: [mouseScrollDirection _ #down]]].
	"Ctrl for Keyboard or Mouse wheel gestures, only if preference is set. All modifiers for Trackpad gestures."
	((buttons = InputSensor controlKey and: [PreferenceNG at: #ctrlArrowsScrollHorizontally]) or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 28
			ifTrue: [mouseScrollDirection _ #left]
		ifFalse: [keyValue = 29
			ifTrue: [mouseScrollDirection _ #right]]].
	mouseScrollDirection ifNotNil: [
		^ MouseScrollEvent new
			setType: #mouseScroll
			position: self morphPosition
			direction: mouseScrollDirection
			buttons: buttons
			hand: self
			stamp: stamp ].
	^ KeyboardEvent new
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!WorldMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:32:25' prior: 16981916!
                     displayWorld
	"Update this world's display."

	| deferredUpdateVMMode allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time. ?? revisar."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"Restore world canvas under hands and their carried morphs"
	Preferences cacheDisplayContentWhenMovingMorphs ifTrue: [
		hands do: [ :h | h restoreSavedPatchOn: canvas ]].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	canvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage _ canvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	canvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self handsToDrawForDamage: allDamage do: [ :h |
		(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage _ (h savePatchFrom: canvas) quickMerge: allDamage ]
			ifFalse: [ allDamage _ h displayFullBoundsForPatch quickMerge: allDamage ].
		canvas fullDrawHand: h .
		h needsRedraw: false ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		allDamage ifNotNil: [
			"Drawing was done to off-Display canvas. Copy content to Display"
			canvas showAt: self viewBox origin invalidRect: allDamage ]].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	allDamage ifNotNil: [
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: allDamage ]].! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'hlsf 5/12/2022 08:33:10' prior: 16981053 overrides: 16878712!
            adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(PreferenceNG at: #cheapWindowReframe) or: [millisecondSinceLast > 200]]) ifTrue: [
			owner displayBounds newRectFrom: [ :f |
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner morphExtentInWorld ]].! !
!StringRequestMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 08:36:26' prior: 16950396!
                              getUserResponseOrCancel: aBlock
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."
	| w delay done canceled |
	w _ self world.
	w isNil ifTrue: [^ response asString].
	done _ false.
	canceled _ false.
	(PreferenceNG at: #focusFollowsMouse) ifFalse: [self textBox focusText].
	acceptBlock _ [:aString| done _ true].
	cancelBlock _ [done _ true. canceled _ true].
	delay _ Delay forMilliseconds: 10.
	[done not and: [self isInWorld]] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	canceled ifTrue: [^ aBlock value].
	^ response asString! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'hlsf 5/12/2022 08:36:31' prior: 16950452!
                   request: queryString centeredAt: aPoint initialAnswer: defaultAnswer validationBlock: validationBlock acceptBlock: acceptBlock cancelBlock: cancelBlock
	| answer |
	answer _ self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer;
		validationBlock: validationBlock;
		acceptBlock: acceptBlock;
		cancelBlock: cancelBlock.
	self runningWorld addMorph: answer centeredNear: aPoint - self deltaToTextPane.
	(PreferenceNG at: #focusFollowsMouse) ifFalse: [answer textBox focusText].
	^ answer! !
!PluggableScrollPane methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 08:35:19' prior: 16912324 overrides: 16911743!
             initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ #showIfNeeded.

	"initialize the receiver's scrollBars"
	scrollBar _ ScrollBar new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ ScrollBar new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ PreferenceNG at: #drawKeyboardFocusIndicator.
	self addMorph: scrollBar.
	self addMorph: hScrollBar.
	self updateScrollBarsBounds.
	self innerMorphClass ifNotNil: [ :contentsClass |
		self scroller: contentsClass new ].! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:38:18' prior: 16867289 overrides: 16794207!
     drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle 
			borderWidth: (PreferenceNG at: #focusIndicatorWidth)
			color: Theme current focusIndicator ]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:37' prior: 16867406 overrides: 16892287!
                              mouseEnter: event
	super mouseEnter: event.
	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:38:23' prior: 16910553 overrides: 16794207!
          drawOn: aCanvas
	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: (PreferenceNG at: #focusIndicatorWidth)
			color: Theme current focusIndicator ].! !
!PluggableListMorph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:41' prior: 16910777 overrides: 16892287!
  mouseEnter: event
	super mouseEnter: event.
	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!TextModelMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:38:32' prior: 16969029 overrides: 16794207!
              drawOn: aCanvas
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"
	| bw bc |
	self flag: #todo.
	"Integrate this method with the Theme system. --cbr"
	super drawOn: aCanvas.
	bw _ PreferenceNG at: #focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [ "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan ]
			ifFalse: [
				scroller hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ]
					ifFalse: [
						scroller hasUnacceptedEdits ifTrue: [ bc _ Color red ]]]].
	(drawKeyboardFocusIndicator and: [ scroller hasKeyboardFocus ])
		ifTrue: [ bc ifNil: [ bc _ Theme current focusIndicator ]]
		ifFalse: [
			bc ifNotNil: [
				bc _ bc
					alphaMixed: 0.4
					with: Color white ]].
	bc ifNotNil: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: bw
			color: bc ].! !
!TextModelMorph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:45' prior: 16969138 overrides: 16892287!
                            mouseEnter: event
	super mouseEnter: event.
	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: scroller ]! !
!SystemWindow methodsFor: 'menu' stamp: 'hlsf 5/12/2022 08:53:35' prior: 50344299!
   addTileResizerMenuTo: aMenu
	"We can look at preferences here to decide what too do"
	(PreferenceNG at: #tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 		action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 				action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 		action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 	action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asPlainString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].
	^aMenu.! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:46:47' prior: 16821715!
                           buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:46:54' prior: 16796970 overrides: 50354311!
     buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code _ self buildMorphicCodePane.
	comment _ self buildMorphicCommentPane.
	separator _ LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MessageSetWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:47:00' prior: 16886978 overrides: 50354336!
            buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:47:05' prior: 16839570 overrides: 50354311!
    buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons _ LayoutMorph newColumn.
	h _ self defaultButtonPaneHeight.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		h _ self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 5/12/2022 08:55:25' prior: 16882629!
                       addItemsFromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object. If nil, use defaultTarget. If a Symbol, send it as message to defaultTarget to get real target.
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item wantsIcons |
	wantsIcons _ PreferenceNG at: #wantsMenuIcons.
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ self addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object ifAbsent: [defaultTarget].
				realTarget isSymbol ifTrue: [ realTarget _ defaultTarget perform: realTarget ].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						self
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						self
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				wantsIcons ifTrue: [
					dict
						at: #icon
						ifPresent: [ :symbolOrFormOrNil |
							item setIcon: symbolOrFormOrNil ]].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]]! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 5/12/2022 08:47:16' prior: 16882701!
                          addStayUpIcons
	| closeButton pinButton w buttonHW |
	(PreferenceNG at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW _ Theme current titleBarButtonsExtent x.
	closeButton _ PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; color: `Color transparent`.
	pinButton _ PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; color: `Color transparent`.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW);
			color: `Color transparent`;
			addMorph: closeButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'control' stamp: 'hlsf 5/12/2022 08:46:05' prior: 16882917!
       popUpAt: aPoint forHand: hand in: aWorld
	"Present this menu at the given point under control of the given hand.  Allow keyboard input into the menu."

	^ self 
		popUpAt: aPoint 
		forHand: hand 
		in: aWorld 
		allowKeyboard: (PreferenceNG at: #menuKeyboardControl)! !
!MenuMorph methodsFor: 'modal control' stamp: 'hlsf 5/12/2022 08:45:49' prior: 16883281!
                        invokeModal
	"Invoke this menu and don't return until the user has chosen a value.
	See example below on how to use modal menu morphs."
	^ self invokeModal: (PreferenceNG at: #menuKeyboardControl)

	"
	| menu sub entry |
	menu _ MenuMorph new.
	1 to: 3 do: [:i |
		entry _ 'Line', i printString.
		sub _ MenuMorph new.
		menu add: entry subMenu: sub.
		#('Item A' 'Item B' 'Item C')  do:[:subEntry|
			sub add: subEntry target: menu 
				action: #modalSelection: argument: {entry. subEntry}]].
	menu invokeModal.
	"! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'hlsf 5/12/2022 08:33:59' prior: 16897631 overrides: 16896679!
       dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt _ false.
	grabAMorph _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self) ifTrue: [
				eventHandler _ aMorph.
				aMorphHandlesIt _ true ].
			"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
			self mouseButton1Pressed ifTrue: [
				aMorph owner ifNotNil: [ :o |
					(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
						grabAMorph _ true ]]]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: (Preferences clickGrabsMorphs ifFalse: [#dragEvent:localPosition:])
						clkSel: (Preferences clickGrabsMorphs ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(PreferenceNG at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ aMorph is: #SystemWindow :: ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'hlsf 5/12/2022 08:33:20' prior: 16896183!
                  fullDraw: aMorph
	"Draw the full Morphic structure on us"
	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."

	aMorph visible ifFalse: [^ self].
	self into: aMorph.

	currentMorph layoutSubmorphsIfNeeded.

	currentMorph isKnownFailing ifTrue: [
		self canvasToUse drawCurrentAsError.
		self outOfMorph.
		^ self].

	(currentMorph isOwnedByHand and: [
			(PreferenceNG at: #cheapWindowReframe) and: [currentMorph is: #SystemWindow]]) ifTrue: [
		self drawCurrentAsOutline.
		self outOfMorph.
		^ self].

	"Draw current Morph and submorphs"	
	self canvasToUse drawCurrentAndSubmorphs.

	self outOfMorph! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 08:39:10' prior: 16971018!
                  fullScreenDeskMargin
	^ (PreferenceNG at: #fullScreenLeavesDeskMargins) ifTrue: [22] ifFalse: [0]! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 08:57:48' prior: 16972033!
                               changeIcons

	(MenuMorph new defaultTarget: self)
		addTitle: 'Menu Icons';
		addStayUpIcons;
		add: 'Use icons for menu entries' action: #useMenuIcons;
		add: 'Don''t use icons for menu entries' action: #useNoMenuIcons;
		popUpInWorld: self runningWorld! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 5/12/2022 08:46:18' prior: 16913583!
                            startUpWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self 
		startUpWithCaption: captionOrNil 
		at: Sensor mousePoint 
		allowKeyboard: (PreferenceNG at: #menuKeyboardControl)! !

TileResizeMorph class removeSelector: #initialize!

!methodRemoval: TileResizeMorph class #initialize stamp: 'Install-5154-CuisCorePreferences-p1-HilaireFernandes-2022May12-hlsf.004.cs.st 5/16/2022 10:22:26'!
initialize

	Preferences
		addPreference: #tileResizerInWindowMenu
		category: #gui 
		default: true
		balloonHelp: 'If enabled, a tile resizer morph is embedded in windows menus.' withNewLines!

HaloMorph class removeSelector: #initialize!

!methodRemoval: HaloMorph class #initialize stamp: 'Install-5154-CuisCorePreferences-p1-HilaireFernandes-2022May12-hlsf.004.cs.st 5/16/2022 10:22:26'!
initialize
	"HaloMorph initialize"
	
	Preferences preferenceAt: #haloEnclosesFullBounds ifAbsent: [
		Preferences addPreference: #haloEnclosesFullBounds
			category: #halos
			default: false
			balloonHelp: 'if true, halos will enclose the full bounds of the target Morph, rather than just the bounds'
	].
 
	Preferences resetHaloSpecifications!

HaloMorph initialize!

TileResizeMorph initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5154-CuisCorePreferences-p1-HilaireFernandes-2022May12-hlsf.004.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 10:02:08 am'!
!Workspace methodsFor: 'shout styling' stamp: 'hlsf 5/12/2022 09:38:27' prior: 16981474!
shouldStyle

	^shouldStyle ifNil: [ PreferenceNG at: #shoutInWorkspaces]! !
!Workspace methodsFor: 'user interface support' stamp: 'hlsf 5/12/2022 09:40:42' prior: 16981510 overrides: 16968885!
                              allowStylingWithEmphasis
	"Disabled by default for faster styling of large contents, as text metrics are not affected by styling."

	^ PreferenceNG at: #stylingWithEmphasisInWorkspaces! !
!Workspace methodsFor: 'user interface support' stamp: 'hlsf 5/12/2022 09:26:49' prior: 16981557 overrides: 16968910!
              fullPrintIt

	^fullPrintIt ifNil: [ PreferenceNG at: #fullPrintItInWorkspaces]! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 5/12/2022 09:21:23' prior: 16820499!
                     annotationForClassDefinitionFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Class definition for ';
			nextPutAll: aClass name.
		(PreferenceNG at: #classAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#instanceMethodsCount] -> [
					strm
						print: (aClass theNonMetaClass selectors size);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (aClass theMetaClass selectors size);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (aClass theNonMetaClass linesOfCode);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 5/12/2022 09:35:20' prior: 50344911!
                               annotationForSelector: aSelector ofClass: aClass 
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	^ String streamContents: [ :strm |
		(PreferenceNG at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp _ self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						strm
							print: ((aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm | cm linesOfCode]);
							nextPutAll: ' lines of code' ].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount _ Smalltalk numberOfSendersOf: aSelector.
						sendersCount _ sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount _ implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp _ VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						(aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm |
							(CodePackage packageOfMethod: cm methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList _ (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ] ].! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 5/12/2022 09:41:18' prior: 16820660!
                      annotationForSystemCategory: aCategory
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'System Category: ';
			nextPutAll: aCategory.
		(PreferenceNG at: #systemCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#classCount] -> [
					strm
						print: (SystemOrganization listAtCategoryNamed: aCategory) size;
						nextPutAll: ' classes' ].
				[#instanceMethodsCount] -> [
					strm
						print: (SystemOrganization instanceMethodCountOf: aCategory);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (SystemOrganization classMethodCountOf: aCategory);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (SystemOrganization linesOfCodeOf: aCategory);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'contents' stamp: 'hlsf 5/12/2022 09:17:20' prior: 16820815!
              contentsSymbol
	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"

	^ contentsSymbol ifNil: [
		contentsSymbol _ (PreferenceNG at: #browseWithPrettyPrint)
					ifTrue:
						[#prettyPrint]
					ifFalse:
						[#source]]! !
!CodeProvider methodsFor: 'diffs' stamp: 'hlsf 5/12/2022 09:26:00' prior: 16820999!
    defaultDiffsSymbol
	"Answer the code symbol to use when generically switching to diffing"

	^ (PreferenceNG at: #diffsWithPrettyPrint)
		ifTrue: [
			#prettyLineDiffs]
		ifFalse: [
			#lineDiffs]! !
!Browser methodsFor: 'class functions' stamp: 'hlsf 5/12/2022 09:29:13' prior: 16795241!
createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"
	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		aClass instVarNames do: [ :aName | | newMessage setter |
			(aClass canUnderstand: aName asSymbol) ifFalse: [
				newMessage _ aName , '
	"Answer the value of ' , aName , '"

	^ ' , aName.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ].
			(aClass canUnderstand: (setter _ aName , ':') asSymbol) ifFalse: [
				newMessage _ setter , ' anObject
	"Set the value of ' , aName , '"

	' , aName , ' ' ,
					((PreferenceNG at: #leftArrowAssignmentsInGeneratedCode)
						ifTrue: [ '_' ]
						ifFalse: [ ':=' ]) , ' anObject'.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ]]]! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 5/12/2022 09:30:51' prior: 16796883!
                           disableListClassesHierarchically
	
	^PreferenceNG at: #listClassesHierarchically put: false! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 5/12/2022 09:31:05' prior: 16796889!
       enableListClassesHierarchically
	
	^PreferenceNG at: #listClassesHierarchically put: true! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 5/12/2022 09:31:17' prior: 16796894!
         listClassesHierarchically
	
	^PreferenceNG at: #listClassesHierarchically! !
!CodeFileBrowser methodsFor: 'edit pane' stamp: 'hlsf 5/12/2022 09:17:27' prior: 16817913 overrides: 16796178!
    selectedMessage
	"Answer a copy of the source code for the selected message selector."

	| class selector answer |
	class _ self selectedClassOrMetaClass.
	selector _ self selectedMessageName.
	answer _ class sourceCodeAt: selector.
	(self classOrMetaClassOrganizer isRemoved: selector) ifTrue: [
		^ Text
			string: answer
			attribute: TextColor red ].
	(PreferenceNG at: #browseWithPrettyPrint) ifTrue: [
		answer _ class compilerClass new
						format: answer in: class notifying: nil ].
	self showingAnyKindOfDiffs ifTrue: [
		answer _ self
			methodDiffFor: answer
			selector: self selectedMessageName ].
	^ answer! !
!ChangeList methodsFor: 'initialization-release' stamp: 'hlsf 5/12/2022 09:25:35' prior: 16801399 overrides: 16920235!
                        initialize
	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"

	contentsSymbol _ (PreferenceNG at: #diffsInChangeList)
		ifTrue:
			[self defaultDiffsSymbol]
		ifFalse:
			[#source].
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	super initialize! !
!Debugger class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 09:32:24' prior: 16838869!
                             openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	<primitive: 19> "Simulation guard"

	(self errorRecursion not and: [PreferenceNG at: #logDebuggerStackToFile]) ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	ErrorRecursion ifTrue: [
		ErrorRecursion _ false.
		contentsStringOrNil
			ifNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString]
			ifNotNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString, String newLineString, contentsStringOrNil ]].
	ErrorRecursion _ true.
	[self informExistingDebugger: aContext label: aString.
	(Debugger context: aContext)
		openNotifierContents: contentsStringOrNil
		label: aString.] ensure: [ ErrorRecursion _ false ].
	Processor activeProcess suspend.
! !
!Debugger class methodsFor: 'opening' stamp: 'hlsf 5/12/2022 09:32:58' prior: 16838977!
         openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	debugger
		process: interruptedProcess
		context: interruptedProcess suspendedContext.
	debugger externalInterrupt: true.

	(PreferenceNG at: #logDebuggerStackToFile) ifTrue:
		[(aString includesSubString: 'Space') & 
			(aString includesSubString: 'low') ifTrue: [
				Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug']].

	^ debugger
		openNotifierContents: nil
		label: aString
! !
!Debugger class methodsFor: 'opening' stamp: 'hlsf 5/12/2022 09:33:28' prior: 50341792!
              openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	(PreferenceNG at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'hlsf 5/12/2022 10:01:09' prior: 16786773!
                          whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |

	(PreferenceNG at: #thoroughSenders)
		ifTrue: [ who _ self thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte ]
		ifFalse: [ 
			who _ Set new.
			self selectorsAndMethodsDo: [:sel :method |
				((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]]) ifTrue: [
					((literal isVariableBinding) not or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
						or: [(method indexOfLiteral: literal) ~= 0]]) ifTrue: [who add: sel]]]].
		
	^self rejectSelectorsFrom: who thatReferenceTo: literal byte: specialByte ! !
!Message methodsFor: 'stub creation' stamp: 'hlsf 5/12/2022 09:29:21' prior: 16883614!
                           addSetterCodeOn: stream 
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ((PreferenceNG at: #leftArrowAssignmentsInGeneratedCode)
			ifTrue: [ ' _ ' ]
			ifFalse: [ ' := ' ]);
		nextPutAll: self arguments first argumentName ! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'hlsf 5/12/2022 09:23:05' prior: 16953421!
                            logError: errMsg inContext: aContext to: baseFilename
	"Log the error message and a stack trace to the given file.
	Smalltalk logError: 'test error message' inContext: thisContext to: 'testErr.txt'
	"

	| localFilename file |
	localFilename _ (PreferenceNG at: #debugLogTimestamp)
		ifTrue: [ baseFilename, '-', Utilities dateTimeSuffix, '.log' ]
		ifFalse: [ baseFilename, '.log' ].
	file _ DirectoryEntry smalltalkImageDirectory // localFilename.
	[
		file forceWriteStreamDo: [ :stream |
	 	 	stream nextPutAll: errMsg; newLine.
			aContext errorReportOn: stream ]
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"
	[
 	 	StdIOWriteStream stdout newLine; nextPutAll: errMsg.
		StdIOWriteStream stdout newLine; nextPutAll: 'See '; nextPutAll: file pathName.
		StdIOWriteStream stdout newLine.
		aContext shortErrorReportOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout flush
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"! !
!BlockNode methodsFor: 'printing' stamp: 'hlsf 5/12/2022 09:35:47' prior: 16793104 overrides: 16906201!
      printOn: aStream indent: level
	| separateLines |
	aStream nextPut: $[.
	self
		printArgumentsOn: aStream
		indent: level.
	separateLines _ (self
		printTemporaries: temporaries
		on: aStream
		doPrior: [ aStream space ]) or: [arguments notNil and: [arguments notEmpty] ].
	(PreferenceNG at: #prettyPrintRectangularBlocks)
		ifTrue: [
			"If args+temps > 0 and statements > 1 (or just one complex statement),
			put all statements on separate lines"
			separateLines
				ifTrue: [
					(statements size > 1 or: [
						statements size = 1 and: [ statements first isComplex ]])
							ifTrue: [ aStream newLineTab: (1 max: level) ]
							ifFalse: [ aStream space ] ]
				ifFalse: [
					(statements size = 1 and: [ statements first isComplex not ])
						ifTrue: [ aStream space ]]]
		ifFalse: [
			self isComplex
				ifTrue: [ aStream newLineTab: (1 max: level) ]
				ifFalse: [ aStream space ] ].
	((self printStatementsOn: aStream indent: level) > 0 and: [ aStream peekLast ~= $] ])
		ifTrue: [ aStream space ].
	aStream nextPut: $]! !
!BlockNode methodsFor: 'testing' stamp: 'hlsf 5/12/2022 09:35:57' prior: 16793360 overrides: 16906470!
          printsInNewLine
	"Used for pretty printing to determine whether to start a new line"

	(PreferenceNG at: #prettyPrintRectangularBlocks) ifFalse: [ ^false ].
	^super printsInNewLine! !
!TempVariableNode methodsFor: 'testing' stamp: 'hlsf 5/12/2022 09:13:14' prior: 16960577 overrides: 16977637!
                          assignmentCheck: encoder at: location
	^((self isBlockArg and: [(PreferenceNG at: #allowBlockArgumentAssignment) not])
	    or: [self isMethodArg])
			ifTrue: [location]
			ifFalse: [-1]! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'hlsf 5/12/2022 09:14:00' prior: 16940352!
   browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry |
	(PreferenceNG at: #alternativeBrowseIt) ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol _ self selectedSymbol ifNil: [
		self
			evaluateSelectionAndDo: [ :result | result class name ]
			ifFail: [ ^morph flash ]
			profiled: false].

	aSymbol first isUppercase
		ifTrue: [
			anEntry _ (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry _ anEntry class].
			BrowserWindow fullOnClass: anEntry selector: nil]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !
!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'hlsf 5/12/2022 09:14:51' prior: 16946857!
                     syntheticST80Glyphs
	"Build and answer a derivative that includes ST-80 glyphs:
	a left arrow instead of the underscore, and an up arrow instead of the caret."

	| derivative |
	derivative _ self copy.
	derivative
		name: self name , 'ST80';
		perform: (PreferenceNG at: #assignmentGlyphSelector).
	^ derivative! !
!MorphicScanner methodsFor: 'scanning' stamp: 'hlsf 5/12/2022 09:16:43' prior: 16896836!
            displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos x1 |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastIndex _ line first.
	tabCount _ 0.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions.
		backgroundColor ifNotNil: [
			x1 _ destX.
			((PreferenceNG at: #backgroundColorFillsAllBackground) and: [startIndex > line last]) ifTrue: [
				x1 _ rightMargin ].
			canvas
				fillRectangle: (lastPos corner: x1 @ (line bottom + textTopLeft y))
				color: backgroundColor.
			((PreferenceNG at: #backgroundColorFillsAllBackground) and: [stopCondition = #tab]) ifTrue: [
				canvas
					fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
					color: backgroundColor ]].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !
!HaloMorph methodsFor: 'handles' stamp: 'hlsf 5/12/2022 09:22:10' prior: 16864714!
                            addDebugHandle: handleSpec

	(PreferenceNG at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doDebug:with: ]
! !
!HaloMorph methodsFor: 'handles' stamp: 'hlsf 5/12/2022 09:22:18' prior: 16864741!
                        addExploreHandle: handleSpec

	(PreferenceNG at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doExplore:with: ]
! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 09:40:03' prior: 16869745 overrides: 16794207!
               drawOn: aCanvas

	(PreferenceNG at: #showLinesInHierarchyViews) ifTrue:[
		self drawLinesOn: aCanvas ]! !
!InnerTextMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 09:41:56' prior: 16870752!
                              installEditorAndTextComposition
	"Install an editor for my textComposition. Install also the textComposition."
	| e tc |
	
	"Editor and TextComposition are assigned here atomically."
	e _ model editorClass new morph: self.
	e model: model.
	tc _ TextComposition new.
	"Keep critical section short"
	self mutex critical: [
		editor _ e.
		textComposition _ tc.
		tc
			setModel: model;
			extentForComposing: self extentForComposing.
		e textComposition: tc.
		tc editor: e ].
	e setEmphasisHereFromText.
	tc composeAll.
	e resetState.
	self fit.
	self selectionChanged.

	"Add extras. Text Styler and Autocompleter"
	self stylerClass:
		((PreferenceNG at: #syntaxHighlightingAsYouType) ifTrue: [
			model textStylerClass ]).
	self autoCompleterClass:
		model autoCompleterClass! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:05' prior: 50354311!
                          buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:38:07' prior: 50339704!
                     buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."
	
	| codePane |
	
	codePane := self createCodePaneMorph.	
	(PreferenceNG at: #shiftClickShowsImplementors)
		ifTrue: [ self addShiftClickEventHandlerFor: codePane ].
		
	^codePane! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:24:33' prior: 50337705!
  optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"

	| aList textConstructor |
	textConstructor _ [ :string :backgroundColor | 
		string asText addAttribute: (TextBackgroundColor color: backgroundColor) ].

	aList _ #(
		(10	'browse'			browseMethodFull							'view this method in a browser')
		(11	'senders' 			browseSendersOfMessages							'browse senders of...' 						browseSendersOfMethod)
		(16	'implementors'			browseMessages							'browse implementors of...' 						browseImplementors)
		(12	'versions'			browseVersions							'browse versions')), 

		((PreferenceNG at: #decorateBrowserButtons)
			ifTrue: [
				{{13	. 'inheritance'.	 #methodInheritance. 	'Browse Method Inheritance

', (textConstructor value: 'green' value: `Color green muchLighter`),': sends to super
', (textConstructor value: 'tan' value: `Color tan`), ': has override(s)
', (textConstructor value: 'mauve' value: `Color blue muchLighter`), ': both of the above
', (textConstructor value: 'pink' value: `Color red muchLighter`), ': is an override but doesn''t call super
', (textConstructor value: 'pinkish tan' value: `Color r: 0.94 g: 0.823 b: 0.673`), ': has override(s), also is an override but doesn''t call super
'}}]
			ifFalse: [
				{#(13	'inheritance'		 methodInheritance	 'browse method inheritance')}]),

		#(
		(12	'hierarchy'			browseHierarchy							'browse class hierarchy')
		(10	'inst vars'			browseInstVarRefs							'inst var refs...')
		(11	'class vars'			browseClassVarRefs							'class var refs...')
		(10	'show...'			offerWhatToShowMenu							'menu of what to show in lower pane')).

	^ aList! !
!CodeWindow methodsFor: 'updating' stamp: 'hlsf 5/12/2022 09:24:21' prior: 16821977!
                decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	(PreferenceNG at: #decorateBrowserButtons)
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		`Color tan`.							"no sends to super. there is an override in some subclass"
		`Color red`.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		`Color red`.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		`Color red muchLighter`.			"doesn't have sub; has super but doesn't call it"
		`Color r: 0.94 g: 0.823 b: 0.673`.		"has sub; has super but doesn't call it"
		`Color green muchLighter`.			"doesn't have sub; has super and callsl it"
		`Color blue muchLighter`.			"has sub; has super and callsl it"

	} at: flags + 1.
	Theme current useUniformColors
		ifTrue: [
			aButton color: (self buttonColor mixed: 0.8 with: aColor) ]
		ifFalse: [
			aButton color: aColor ]! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:16' prior: 50354336 overrides: 50355519!
                              buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code _ self buildMorphicCodePane.
	comment _ self buildMorphicCommentPane.
	separator _ LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MessageSetWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:24' prior: 50354370 overrides: 50355670!
     buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:33' prior: 50354395 overrides: 50355519!
                             buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons _ LayoutMorph newColumn.
	h _ self defaultButtonPaneHeight.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		h _ self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!Theme methodsFor: 'private - shout mappings' stamp: 'hlsf 5/12/2022 09:27:37' prior: 16971285!
        italic
	^(PreferenceNG at: #italicsInShout)
		ifTrue: [ #italic ]
		ifFalse: [ #normal ]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'hlsf 5/12/2022 09:57:15' prior: 16930863 overrides: 16930632!
                      privateFormatAndConvert
	"Perform any formatting of formattedText necessary and store or a formatted copy in formattedText"
	(PreferenceNG at: #syntaxHighlightingAsYouTypeAnsiAssignment) ifTrue: [
		self convertAssignmentsToAnsi ].
	(PreferenceNG at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) ifTrue: [
		self convertAssignmentsToLeftArrow ]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'hlsf 5/12/2022 09:27:08' prior: 16930876 overrides: 16930636!
                  privateStyle

	| alpha end start count startIndexes c hue |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	(PreferenceNG at: #highlightBlockNesting) ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 10.0 min: 1.0.
			hue _ depth * 60.
			c _ Color h: hue s: 0.2 v: 0.5 alpha: alpha.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor color: c ) 
				from: start 
				to: end ]]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'hlsf 5/12/2022 09:54:06' prior: 16930973!
             ansiAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeAnsiAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeLeftArrowAssignment
	to be turned off"
	(PreferenceNG at: #syntaxHighlightingAsYouTypeAnsiAssignment) 		ifTrue: [
		PreferenceNG at: #syntaxHighlightingAsYouTypeLeftArrowAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'hlsf 5/12/2022 09:56:26' prior: 16931068!
         leftArrowAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeLeftArrowAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeAnsiAssignment
	to be turned off"
	(PreferenceNG at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) 		ifTrue:[
		PreferenceNG at: #syntaxHighlightingAsYouTypeAnsiAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 09:58:59' prior: 16931138 overrides: 16904184!
        initialize  
	"Clear styleTable and textAttributesByPixelSize cache so that they will 
	reinitialize.	 

		SHTextStylerST80 initialize
	" 
	
	styleTable := nil.
	textAttributes := nil.	
	"We want to be  informed at preference changes"
	(PreferenceNG instanceAt: #syntaxHighlightingAsYouTypeAnsiAssignment)
		when: #preferenceChanged
		send: #ansiAssignmentPreferenceChanged
		to: self.
	(PreferenceNG instanceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment)
		when: #preferenceChanged
		send: #leftArrowAssignmentPreferenceChanged
		to: self! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'hlsf 5/12/2022 09:29:32' prior: 16852533!
              preferredAssignmentOperator

	^ (PreferenceNG at: #leftArrowAssignmentsInGeneratedCode)
		ifTrue: [ '_' ]
		ifFalse: [ ':=' ]! !

SHTextStylerST80 class removeSelector: #initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment!

!methodRemoval: SHTextStylerST80 class #initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment

	^ (Preferences preferenceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment) ifNil:[
		Preferences 
			addPreference: #syntaxHighlightingAsYouTypeLeftArrowAssignment
		 	categories: #(browsing)
			default: false 
			balloonHelp: 'If true, and syntaxHighlightingAsYouType is enabled,  all ANSI format assignments ( := ) will be converted to left arrows ( _ ) when a method is selected in a Browser. Whilst editing a method, this setting has no effect - both the left arrow and the ansi format may be used'.
			
		(Preferences preferenceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment)
			changeInformee: self 
			changeSelector: #leftArrowAssignmentPreferenceChanged ]!

SHTextStylerST80 class removeSelector: #initializeSyntaxHighlightingAsYouType!

!methodRemoval: SHTextStylerST80 class #initializeSyntaxHighlightingAsYouType stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializeSyntaxHighlightingAsYouType

	(Preferences preferenceAt: #syntaxHighlightingAsYouType) ifNil:[
		Preferences 
			disable: #browseWithPrettyPrint.
		Preferences 
			addPreference: #syntaxHighlightingAsYouType
			categories: #(browsing)
			default: true 
			balloonHelp: 'Enable, or disable, Shout - Syntax Highlighting As You Type. When enabled, code in Browsers and Workspaces is styled to reveal its syntactic structure. When the code is changed (by typing some characters, for example), the styling is changed so that it remains in sync with the modified code']!

SHTextStylerST80 class removeSelector: #initializePreferences!

!methodRemoval: SHTextStylerST80 class #initializePreferences stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializePreferences
	
	self
		initializeSyntaxHighlightingAsYouType;
		initializeSyntaxHighlightingAsYouTypeAnsiAssignment;
		initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment.!

SHTextStylerST80 class removeSelector: #initializeSyntaxHighlightingAsYouTypeAnsiAssignment!

!methodRemoval: SHTextStylerST80 class #initializeSyntaxHighlightingAsYouTypeAnsiAssignment stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializeSyntaxHighlightingAsYouTypeAnsiAssignment

	(Preferences preferenceAt: #syntaxHighlightingAsYouTypeAnsiAssignment) ifNil:[
		Preferences 
			addPreference: #syntaxHighlightingAsYouTypeAnsiAssignment
			categories: #(browsing)
			default: false 
			balloonHelp: 'If true, and syntaxHighlightingAsYouType is enabled,  all left arrow assignments ( _ ) will be converted to the ANSI format ( := ) when a method is selected in a Browser. Whilst editing a method, this setting has no effect - both the left arrow and the ansi format may be used'.
			
		(Preferences preferenceAt: #syntaxHighlightingAsYouTypeAnsiAssignment)
			changeInformee: self
			changeSelector: #ansiAssignmentPreferenceChanged]!

Parser class removeSelector: #initialize!

!methodRemoval: Parser class #initialize stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initialize
	"
	Parser initialize
	"
	Preferences
		addPreference: #allowBlockArgumentAssignment 
		category: #compiler 
		default: false
		balloonHelp: 'If enabled, the compiler will allow assignment into block arguments.\This provides backward compatibility with the pre-closure compiler.' withNewLines!

Parser initialize!

SHTextStylerST80 initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 10:40:55 am'!
!FileList methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 10:25:53' prior: 16855258!
                      initialDirectoryList

	| initialDirectoryListFromPreferences wrapperCreator |
	wrapperCreator _ [ :directoryEntry |
		FileDirectoryWrapper
			with: directoryEntry
			name: (directoryEntry name ifNil: [ '/' ])
			model: self ].
	(initialDirectoryListFromPreferences _ PreferenceNG at: #initialFileListDirectories) 
		caseOf: {
			[ #roots ] -> [ 	| dirList |
				dirList _ DirectoryEntry roots collect: wrapperCreator.
				dirList isEmpty ifTrue: [
					dirList _ Array with: (FileDirectoryWrapper 
						with: directory
						name: directory localName 
						model: self) ].
				^ dirList ].
			[ #image ] -> [ 
				^ { wrapperCreator value: DirectoryEntry smalltalkImageDirectory } ].
			[ #vm  ] -> [ 
				^ { wrapperCreator value: DirectoryEntry vmDirectory } ].
			[ #current ] -> [
				^ { wrapperCreator value: DirectoryEntry currentDirectory } ] }
		otherwise: [ ^ initialDirectoryListFromPreferences collect: wrapperCreator ]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'hlsf 5/12/2022 10:24:46' prior: 50335735!
                       handleUserInterrupt
	| p |
	"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
	p _ UISupervisor newUIProcessIfNeeded.
	p ifNil: [
		p _ Sensor shiftPressed | (PreferenceNG at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(PreferenceNG at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		p == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(p name beginsWith: '[system]') ifTrue: [
			 ('Process {', p printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			p isTerminated
				ifTrue: [ ('Process {', p printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ UISupervisor userInterrupt: p ]] fork
		]! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'hlsf 5/12/2022 10:36:58' prior: 16954413!
                       abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal _ 0.  bCount _ 0.
	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		Smalltalk allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount _ bCount + 1).
			cl selectors do: [:selector |
				m _ cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	Smalltalk allBehaviorsDo: [:b | b zapOrganization].
	Smalltalk closeSourceFiles.
	PreferenceNG at: #warnIfNoChangesFile put: false.
	PreferenceNG at: #warnIfNoSourcesFile put: false! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'hlsf 5/12/2022 10:07:51' prior: 16954770!
                               askConfirmationOnQuit
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk askConfirmationOnQuit
	"
	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSet allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges ]].
	"dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ]."
	dirtyPackages _ ChangeSet allChangeSets anySatisfy: [ :any | any codePackage notNil and: [ any hasUnsavedChanges ]].
	baseCSdirty & dirtyPackages ifTrue: [
		^self confirm: 'There are both unsaved Packages', String newLineString,
			'and unsaved Changes to Cuis core.', String newLineString,
			'If you continue, all unsaved changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	dirtyPackages ifTrue: [
		^self confirm: 'There are unsaved Packages.', String newLineString,
			'If you continue, their changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	(PreferenceNG at: #askConfirmationOnQuit) ifTrue: [
		^self confirm: 'Do you really want to exit Cuis without saving the image?' ].
	^true! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'hlsf 5/12/2022 10:15:03' prior: 16955257!
                               setPlatformPreferences
	"Set some platform specific preferences on system startup"
	| platform specs |
	(PreferenceNG at: #automaticPlatformSettings) ifFalse:[^self].
	platform _ self platformName.
	specs _ 	#(	
					(soundStopWhenDone false)
					(soundQuickStart false)
			).
	platform = 'Win32' ifTrue:[
		specs _ #(	
					(soundStopWhenDone true)
					(soundQuickStart false)
				)].
	platform = 'Mac OS' ifTrue:[
		specs _ #(	
					(soundStopWhenDone false)
					(soundQuickStart true)
				)].
	specs do: [:tuple |
		PreferenceNG name: tuple first category: #system value: (tuple last == #true) 	]
! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'hlsf 5/12/2022 10:15:33' prior: 50342466!
                           assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	(PreferenceNG at: #autoNumberUserChanges) ifTrue: [
		oldUserChanges _ Smalltalk defaultUserChangesName asFileEntry.
		oldUserChanges exists ifTrue: [
			directory _ oldUserChanges parent.
			oldUserChangesName _ directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine ].
	StartupStamp _ nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'hlsf 5/12/2022 10:39:43' prior: 16955794!
    openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or Lf/CrLf mixups."
	"Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes msg wmsg entry |
	msg _ 'Cuis cannot locate XfileRef
Please check that the file is named properly and is in the
same directory as this image.'.
	wmsg _ 'Cuis cannot write to XfileRef.

Please check that you have write permission for this file.

You won''t be able to save this image correctly until you fix this.'.

	"Do not open source files if internalized (i.e. notNil)"
	sources _ SourceFiles at: 1.
	sources ifNil: [
		entry _ Smalltalk defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry _ Smalltalk alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources _ [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ PreferenceNG at: #warnIfNoSourcesFile ])
		ifTrue: [
			Smalltalk platformName = 'Mac OS' ifTrue: [
				msg _ msg , String newLineString, 'Make sure the sources file is not an Alias.'].
			self inform: (msg copyReplaceAll: 'XfileRef' with: 'the sources file named ' , entry pathName) ].

	"Do not open source files if internalized (i.e. notNil)"
	changes _ (SourceFiles at: 2) ifNil: [ 
		entry _ Smalltalk defaultChangesName asFileEntry.
		[ entry appendStream ] on: FileWriteError do: [ nil ] ].
	(changes isNil and: [PreferenceNG at: #warnIfNoChangesFile])
		ifTrue: [self inform: (wmsg copyReplaceAll: 'XfileRef' with: 'the changes file named ' , entry pathName)].
	ChangesInitialFileSize _ changes ifNotNil: [ changes position ].

	SourceFiles _ Array with: sources with: changes! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'hlsf 5/12/2022 10:21:15' prior: 16958056!
                               hasToRestoreChanges

	^(PreferenceNG at: #checkLostChangesOnStartUp) and: [ 
		self withChangesFileDo: [ :changesFile | self hasToRestoreChangesFrom: changesFile ]].
	! !
!Exception methodsFor: 'priv handling' stamp: 'hlsf 5/12/2022 10:36:08' prior: 16849940!
                            evaluateHandlerBlock: aBlock

	| handlerEx |
	handlerBlockNotCurtailed := false.
	^[
			| answer |
			answer _ [aBlock valueWithPossibleArgument: self] on: Exception do: [:ex | handlerEx _ ex.  ex pass].
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			handlerBlockNotCurtailed _ true.
			answer
	] ifCurtailed:
		[
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			(handlerBlockNotCurtailed not and: [handlerEx isNil or: [handlerEx handlerBlockNotCurtailed not]])
				ifTrue: [
					"Please see
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000800.html
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000809.html
					Also see the rest of the tread in detail.
					This is work in progress."
					(PreferenceNG at: #allowNonLocalReturnsInExceptionHandlers)
						ifFalse: [ self error: 'Exception handler blocks must not do non local returns' ]
						ifTrue: [
							(PreferenceNG at: #warnAboutNonLocalReturnsInExceptionHandlers)
								ifTrue: [ 'It is advisable to avoid method returns (non local returns) in exception handler blocks' print ].
							handlerBlockNotCurtailed _ true ].
					]
				ifFalse: [handlerBlockNotCurtailed _ true]
		]! !
!NegativePowerError methodsFor: 'exceptionDescription' stamp: 'hlsf 5/12/2022 10:11:31' prior: 16898872 overrides: 16780646!
                   defaultAction

	"Disable this preference to have Float nan answer (if Float receiver or argument) or Error message"
	| answer |
	(PreferenceNG at: #askToInstallComplexPackage) ifTrue: [
		answer _ PopUpMenu
			withCaption:
'Square (or even) Root of a negative Number:
Complex number support is not loaded
Would you like me to load it for you now?'
			chooseFrom: #(
				'Load Complex package'
				'Do not load Complex package'
				'Do not load Complex package and don''t ask again').
		answer = 1 ifTrue: [
			Feature require: #'Complex'.
			Smalltalk at: #Complex ifPresent: [ :cplx |
				^ (cplx basicReal: receiver imaginary: 0) perform: selector withArguments: arguments ]].
		answer = 3 ifTrue: [
			(PreferenceNG at: #askToInstallComplexPackage put: false)]].
	^ super defaultAction! !
!Editor methodsFor: 'private' stamp: 'hlsf 5/12/2022 10:33:01' prior: 16846270!
                        setIndices: shiftPressed forward: forward
	"Little helper method that sets the moving and fixed indices according to some flags."
	| indices |
	indices _ Dictionary new.
	(shiftPressed and:[PreferenceNG at: #selectionsMayShrink])
		ifTrue: [
			indices at: #moving put: self pointIndex.
			indices at: #fixed put: self markIndex
		] ifFalse: [
			forward
				ifTrue:[
					indices at: #moving put: self stopIndex.
					indices at: #fixed put: self startIndex.
				] ifFalse: [
					indices at: #moving put: self startIndex.
					indices at: #fixed put: self stopIndex.
				]
		].
	^indices! !
!TextEditor methodsFor: 'private' stamp: 'hlsf 5/12/2022 10:16:35' prior: 50348311!
                           findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where _ model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [PreferenceNG at: #caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!WorldMorph methodsFor: 'update cycle' stamp: 'hlsf 5/12/2022 10:33:25' prior: 16982541!
           doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(PreferenceNG at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow.! !
!SystemWindow methodsFor: 'events' stamp: 'hlsf 5/12/2022 10:34:28' prior: 16959177 overrides: 16892107!
                       wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph"
	^aMorph isWorldMorph or:[PreferenceNG at: #systemWindowEmbedOK]! !
!SystemWindow methodsFor: 'open/close' stamp: 'hlsf 5/12/2022 10:25:09' prior: 16959667!
         closeBoxHit
	"The user clicked on the close-box control in the window title.  For Mac users only, the Mac convention of option-click-on-close-box is obeyed if the mac option key is down."

	(PreferenceNG at: #dismissAllOnOptionClose) ifTrue:
		[Sensor rawMacOptionKeyPressed ifTrue:
			[^ self world closeUnchangedWindows]].
	self delete
! !
!FileListWindow methodsFor: 'menu building' stamp: 'hlsf 5/12/2022 10:29:53' prior: 16856136!
            volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	model currentDirectorySelected
		ifNil: [ aMenu add: 'initial directory' action: #yourself :: isEnabled: false ]
		ifNotNil: [ :selectedWrapper |
	aMenu 
		add: (Preferences isInitialFileListDirectory: selectedWrapper item)
			asMenuItemTextPrefix, 'initial directory'
		action: #toggleInitialDirectory ::
			setBalloonText: 'The selected directory is an initial director for new file list windows' ].
	initialDirectoriesMenu _ MenuMorph new.
	#(
		(roots  'default roots' 'Use the usual root directories. Drives on Windows; "/" on Unix')
	   	(image 'image directory' 'Use the directory with Smalltalk image')
		(vm 'VM directory' 'Use the virtual machine directory')
		(current 'current directory' 'Use the current directory; usually the directory the VM was started in')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: PreferenceNG
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !
!MenuMorph methodsFor: 'control' stamp: 'hlsf 5/12/2022 10:34:41' prior: 16882980 overrides: 16892107!
 wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph.  A single-item MenuMorph is in effect a button rather than a menu, and as such should not be reluctant to be dropped into another object."

	^ (aMorph isWorldMorph or: [submorphs size = 1]) or:
		[PreferenceNG at: #systemWindowEmbedOK]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'hlsf 5/12/2022 10:18:30' prior: 50346889!
 fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	nameToUse _ self name.
	nameToUse _ nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse _ (PreferenceNG at: #changeSetVersionNumbers)
				ifTrue: [
					DirectoryEntry currentDirectory
						nextNameFor: nameToUse coda: '-', Utilities authorInitials
						extension: 'cs.st' ]
				ifFalse: [ (nameToUse , '.' , Utilities dateTimeSuffix , '.cs.st') asFileName ].
		
	nameToUse asFileEntry writeStreamDo: [ :stream |
		stream timeStamp.
		self fileOutPreambleOn: stream.
		self fileOutOn: stream.
		self fileOutPostscriptOn: stream ].
	
	self hasUnsavedChanges: false.
	(PreferenceNG at: #checkForSlips) 		ifFalse: [^ self].
	slips _ self checkForSlips.
	(slips notEmpty
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ]! !
!ChangeSet class methodsFor: 'services' stamp: 'hlsf 5/12/2022 10:35:05' prior: 16806870!
                          install: aFileEntry
	"File in the entire contents of the file specified by the name provided.
	Do not affect the user change sets, store changes in separate one"

	ChangeSet installing: aFileEntry name do: [ self fileIn: aFileEntry ].
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		('Installed ChangeSet: ', aFileEntry name) print]! !
!CodeFile methodsFor: 'fileIn/fileOut' stamp: 'hlsf 5/12/2022 10:35:10' prior: 16817519!
                 fileIn
	| doitsMark |
	doitsMark := 1.
	doIts isEmpty ifFalse:[doitsMark := self askForDoits].
	doitsMark = 4 ifTrue: [^nil].
	doitsMark = 2 ifTrue:[self fileInDoits].
	classOrder do:[:cls|
		cls fileInDefinition.
	].
	classes do:[:cls|
		(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
			Transcript newLine; show:'Filing in ', cls name].
		cls fileInMethods.
		cls hasMetaclass ifTrue:[cls theMetaClass fileInMethods].
	].
	doitsMark = 3 ifTrue: [ self fileInDoits ]! !
!CodePackageFile methodsFor: 'services' stamp: 'hlsf 5/12/2022 10:35:17' prior: 16819656!
           install
	"Create, install and answer a (sub)instance of CodePackage
	Replace all existing code in the possibly existing CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS _ ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS _ nil ].
		pckClass _ CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				((self packageName asIdentifier: true), 'Package') = ee name ifTrue: [
					ee fileInDefinitionAndMetaclass.
					pckClass _ Smalltalk at: ee name ]]].
		newCodePackage _ pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.

		fullName asFileEntry readStreamDo: [ :stream | stream fileInAnnouncing: 'Installing ', localName, '...' ].
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].

	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
		Smalltalk cleanOutUndeclared.
		Undeclared notEmpty ifTrue: [
			('Undeclared: ', Undeclared printString) print ]].
	^newCodePackage! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 5/12/2022 10:35:22' prior: 16962249!
                reportAboutToRun: aTestCase
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'Will run: '; print: aTestCase; newLine]! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 5/12/2022 10:35:27' prior: 16962261!
                             reportFailed: aTestCase because: anException
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript print: anException; newLine].! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 5/12/2022 10:35:31' prior: 16962268!
                             reportPassed: aTestCase
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'finished.'; newLine]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5156-CuisCorePreferences-p3-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 11:26:27 am'!
!PluggableTextModel methodsFor: 'misc' stamp: 'hlsf 5/12/2022 11:21:53' prior: 16912572 overrides: 16968693!
                 refetch
	"Answer true if actualContents was actually fetched."
	textGetter
		ifNil: [
			actualContents ifNil: [
				self actualContents: Text new ].
			^false ]
		ifNotNil: [
			self actualContents: (Text
				initialFont: (PreferenceNG at: #standardCodeFont)
				stringOrText: (textProvider perform: textGetter)).
			self changed: #refetched.
			^true ]! !
!TextProvider methodsFor: 'contents' stamp: 'hlsf 5/12/2022 11:21:57' prior: 16969572!
   acceptedContents
	^ Text
		initialFont: (PreferenceNG at: #standardCodeFont)
		stringOrText: self acceptedStringOrText! !
!Browser methodsFor: 'class functions' stamp: 'hlsf 5/12/2022 11:22:01' prior: 16795182!
             classCommentText
	"return the text to display for the comment of the currently selected class"
	| theClass |
	theClass _ self selectedClassOrMetaClass.
	^ Text
		initialFont: (PreferenceNG at: #standardCodeFont)
		stringOrText:
			((theClass notNil and: [ theClass hasComment ])
				ifTrue: [ theClass comment ]
				ifFalse: [ '' ]).! !
!ChangeList methodsFor: 'menu actions' stamp: 'hlsf 5/12/2022 11:22:06' prior: 50341736!
                      compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| change class s1 s2 differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	change _ changeList at: listIndex.
	((class _ change changeClass) notNil
			and: [class includesSelector: change methodSelector])
		ifTrue: [
			s1 _ (class sourceCodeAt: change methodSelector) asPlainString.
			s2 _ change string.
			s1 = s2
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords _ self shouldDiffWords.
			differDesc _ diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: s1 to: s2
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: (PreferenceNG at: #standardCodeFont)))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!FileList methodsFor: 'volume list and pattern' stamp: 'hlsf 5/12/2022 11:18:05' prior: 16855494!
                    fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font _ PreferenceNG at: #standardListFont.
	spaceWidth _ font widthOf: $ .
	nameStr _ entry isDirectory
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd _ namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr _ nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr _ (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits _ entry fileSize printString size.
	sizeStr _ entry fileSize printStringWithCommas.
	sizeDigitsAndCommas _ sizeStr size.
	spacesToAdd _ sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd _ spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr _ (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces _ String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .! !
!FileList methodsFor: 'volume list and pattern' stamp: 'hlsf 5/12/2022 11:18:32' prior: 16855553!
                 listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject
	"Make the list be those file names which match the patterns."

	| sizePad selected newList namePad sizeWithCommasPad font |
	directory ifNil: [^#()].
	selected _ Set new.
	patternsThatSelect do: [ :pat |
		directory childrenDo: [ :entry |
			(entry isDirectory
				ifTrue: [ showDirsInFileList ]
				ifFalse: [ self doesPattern: pat allow: entry])
					ifTrue: [ selected add: entry ]]].
	newList _ selected copy.
	patternsThatReject do: [ :pat |
		selected do: [ :entry |
			(entry isDirectory not and: [ pat match: entry name]) ifTrue: [
				newList remove: entry ]]].
		
	newList _ newList asArray sort: self sortBlock.
	font _ PreferenceNG at: #standardListFont.
	namePad _ newList inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printString size.
	sizeWithCommasPad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printStringWithCommas size.
	newList _ newList collect: [ :e |
		self fileNameFormattedFrom: e namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad ].
	^ newList! !
!Color class methodsFor: 'colormaps' stamp: 'hlsf 5/12/2022 10:51:53' prior: 16826660!
              computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: (PreferenceNG at: #aaFontsColormapDepth).
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: `Color white` ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 10:49:26' prior: 50353279!
                               prefFont
	^ #( 
		#(aaFontsColormapDepth 4)
		#(cacheTrueTypeGlyphs true )
		#(guiElementsSize standardFonts #(tinyFonts verySmallFonts smallFonts standardFonts largeFonts veryLargeFonts hugeFonts) defaultFontSize: )
		#(loadOnlyLatinGlyphData false )
		#(properDisplayAlphaForFonts false )	
		#(subPixelRenderColorFonts true )
		#(subPixelRenderFonts true )	
	)! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'hlsf 5/12/2022 11:22:21' prior: 16922726!
       standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| grid allowedArea maxLevel |
	"NOTE: following copied from strictlyStaggeredInitialFrameFor:"
	allowedArea _ self maximumUsableArea insetBy: (
		self scrollBarSetback @ self screenTopSetback extent: `0@0`
	).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
	^ ((allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) 
		min: `52@40` * (PreferenceNG at: #standardCodeFont) lineSpacing) rounded! !
!BitBltCanvasEngine methodsFor: 'private' stamp: 'hlsf 5/12/2022 10:50:53' prior: 16790430!
 setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: `Color transparent`).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			(PreferenceNG at: #subPixelRenderFonts) and: [ foregroundColor = `Color black` or: [ 
				(PreferenceNG at: #subPixelRenderColorFonts) and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= `Color black` or: [
						destDepth = 32 and: [ destForm ~~ Display or: [PreferenceNG at: #properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = `Color black` ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display."
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:23:40' prior: 50342999!
              addTitle: aString
	| titleMorph s pp w |
	titleMorph _ BoxedMorph new noBorder.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line |
		s _ LabelMorph new
			contents: line;
			font: (PreferenceNG at: #standardMenuFont) bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 24) @ (pp y).
	self addMorphKeepMorphHeight: titleMorph.
	^titleMorph morphWidth! !
!StringRequestMorph class methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:25:02' prior: 16950518!
                 deltaToTextPane
	"Answer a distance to translate an instance of the receiver by when it is opened in the world in order to have the hand be over the text pane (so the text pane has focus).
	Distance is relative to font size"
	| e |
	e _ (PreferenceNG at: #windowTitleFont) lineSpacing.
	^ (0)@(0.5 * e)! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:25:07' prior: 16960206!
                 defaultHeight

	^ ((PreferenceNG at: #windowTitleFont) lineSpacing * 2 * self scale) asInteger! !
!InnerListMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:19:03' prior: 16869763 overrides: 16794195!
           initialize
	super initialize.
	self color: `Color black`.
	font _ PreferenceNG at: #standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !
!InnerListMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:18:54' prior: 16870053 overrides: 16893209!
              fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (PreferenceNG at: #standardListFont).! !
!IndentingListItemMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:19:08' prior: 16869398 overrides: 16893209!
 fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (PreferenceNG at: #standardListFont).! !
!IndentingListItemMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:19:17' prior: 16869404!
               initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel

	| o |
	container _ hostList.
	complexContents _ anObject.
	self initWithContents: anObject asString font: (PreferenceNG at: #standardListFont) emphasis: nil.
	indentLevel _ 0.
	isExpanded _ false.
 	nextSibling _ firstChild _ nil.
	priorMorph ifNotNil: [
		priorMorph nextSibling: self.
	].
	o _ anObject withoutListWrapper.
	icon _ o ifNotNil: [ (o respondsTo: #icon) ifTrue: [ o icon ] ].
	icon isSymbol ifTrue: [ icon _ Theme current perform: icon ].
	indentLevel _ newLevel.
! !
!UpdatingLabelMorph class methodsFor: 'new-morph participation' stamp: 'hlsf 5/12/2022 11:25:12' prior: 16976224 overrides: 16895515!
initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (PreferenceNG at: #windowTitleFont)
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:23:50' prior: 16882200 overrides: 16877690!
                            initialize
	"initialize the state of the receiver"
	super initialize.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ PreferenceNG at: #standardMenuFont.
	self contents: ''.! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 11:20:32' prior: 16910132!
               fontToUse
	| fontToUse |
	fontToUse := font ifNil: [PreferenceNG at: #standardButtonFont].
	"
	Could add emphasis...
	^(emphasis isNil or: [emphasis = 0]) 
		ifTrue: [fontToUse]
		ifFalse: [fontToUse emphasized: emphasis]
	"
	^fontToUse! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:25:17' prior: 16910367 overrides: 16893272!
                             minimumExtent
	
	| unit |
	unit :=  (PreferenceNG at: #windowTitleFont) pointSize.
	^label 
		ifNil: [ (unit+2) @ (unit+2) ] "Assume title button"
		ifNotNil: [ (4 * unit) @ (3 * unit) ] "Assure some space for text."
! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:19:23' prior: 16910815 overrides: 16912008!
                  fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (PreferenceNG at: #standardListFont).! !
!SystemWindow methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 11:25:24' prior: 16959100!
drawLabelOn: aCanvas

	| x0 y0 f w availableW l |
	f _ PreferenceNG at: #windowTitleFont.
	x0 _  f lineSpacing * 5 + borderWidth.
	y0 _ borderWidth * 6 // 10.
	availableW _ extent x - x0.
	l _ labelString.
	w _ f widthOfString: l.
	[ w > availableW ] whileTrue: [
		l _ l squeezedTo: (1.0 * l size * availableW / w) truncated.
		l isEmpty ifTrue: [ ^self ].
		w _ f widthOfString: l ].
	aCanvas
		drawString: l
		at: x0@y0
		font: f
		color: Theme current windowLabel
		embossed: Theme current embossedTitles! !
!SystemWindow methodsFor: 'label' stamp: 'hlsf 5/12/2022 11:25:31' prior: 16959400!
            labelHeight
	"Answer the height for the window label."
	^ (PreferenceNG at: #windowTitleFont) lineSpacing+1! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:31' prior: 16820311 overrides: 16959689!
                         initialExtent

	^`540@400` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:37' prior: 16797138!
             buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	classList _ self buildMorphicClassList.
	classColumn _ self buildMorphicClassColumnWith: classList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (PreferenceNG at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:42' prior: 50334671 overrides: 50335981!
          buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model setSelectedSystemCategory: model systemCategoryList first.
	sysCatList _ PluggableListMorph
			model: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:
			mainView: self
			menuGetter: #codeFileListMenu
			keystrokeAction: #codeFileListKey:from:.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList _ PluggableListMorph
			model: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:
			mainView: self
			menuGetter: #messageCategoryMenu
			keystrokeAction: nil.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.
	sysCatList rightSibling: clsList.
	clsList leftSibling: sysCatList rightSibling: msgCatList.
	msgCatList leftSibling: clsList rightSibling: msgList.
	msgList leftSibling: msgCatList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (PreferenceNG at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:47' prior: 16807698 overrides: 16959689!
      initialExtent
	^`540@300` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:52' prior: 16914984 overrides: 16959689!
                         initialExtent
	^ `640 @ 320` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:58' prior: 16872376 overrides: 16959689!
                     initialExtent

	^`600@325` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:23:04' prior: 16904430 overrides: 16959689!
                  initialExtent

	^`300@500` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 5/12/2022 11:23:57' prior: 50343033!
                 addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w newMorph |
	
	newMorph _ BoxedMorph new noBorder.
	newMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line | | font |
		font _ PreferenceNG at: #standardMenuFont.
		s _ LabelMorph new
			contents: line;
			font: (titleMorph
				ifNil: [ font bold ]
				ifNotNil: [ font italic ])..
		newMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ newMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	newMorph morphExtent: (w + 16) @ (pp y).
	titleMorph
		 ifNil: [
			titleMorph _ newMorph.
			self addMorphFront: titleMorph ]
		ifNotNil: [ self addMorphBack: newMorph ].
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'hlsf 5/12/2022 11:19:30' prior: 16783186!
                    listFont

	^PreferenceNG at: #standardListFont! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:20:41' prior: 16971003!
                         buttonPaneHeight
	"Answer the user's preferred default height for button panes."

	^(PreferenceNG at: #standardButtonFont) lineSpacing * 14 // 8! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:19:41' prior: 16971024!
                       layoutAdjusterThickness

	self flag: #todo.  "Revisit this; consider moving proportional stuff out of Theme entirely."
	
	^ (PreferenceNG at: #standardListFont) pointSize // 3! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:25:37' prior: 16971067!
                        titleBarButtonsExtent
	"Answer the extent to use for close & other title bar buttons.  
	The label height is used to be proportional to the fonts preferences."
	| e |
	e _ (PreferenceNG at: #windowTitleFont) pointSize * 13 // 10.
	^e@e! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:19:49' prior: 16971112!
                            windowBorderWidth
	| w |
	w _ (PreferenceNG at: #standardListFont) pointSize / 11.
	w _ w * (self roundWindowCorners ifTrue: [4] ifFalse: [2]).
	^ w rounded max: 1! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 11:08:20' prior: 50339177!
                             changeFontSizes

	| options menu preference  |
	preference _ PreferenceNG instanceAt: #guiElementsSize.
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		(menu add: pair first target: preference action: #value: argument: pair second)
			isSelected: preference value == pair second  ].
	menu popUpInWorld: self runningWorld.! !
!PopUpMenu methodsFor: 'accessing' stamp: 'hlsf 5/12/2022 11:24:04' prior: 16913502!
      frameHeight
	"Designed to avoid the entire frame computation (includes MVC form),
	since the menu may well end up being displayed in Morphic anyway."
	| nItems |
	nItems _ 1 + labelString lineCount.
	^ (nItems * (PreferenceNG at: #standardMenuFont) lineSpacing) + 4 "border width"! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 5/12/2022 11:24:09' prior: 16913534!
  startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean
	"This menu is too big to fit comfortably on the screen.
	Break it up into smaller chunks, and manage the relative indices.
	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

"
(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; newLine]. s skip: -1])
		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'.
"
	| nLines nLinesPer allLabels from to subset subLines index |
	allLabels := labelString lines.
	nLines _ allLabels size.
	lineArray ifNil: [lineArray _ Array new].
	nLinesPer _ segmentHeight // (PreferenceNG at: #standardMenuFont) lineSpacing - 5.
	from := 1.
	[ true ] whileTrue: [
		to := (from + nLinesPer) min: nLines.
		subset := (allLabels copyFrom: from to: to) asOrderedCollection.
		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])
			before: subset first.
		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].
		subLines _ (Array with: 1) , subLines.
		index := (PopUpMenu labels: subset printStringWithNewline lines: subLines)
					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
		index = 1
			ifTrue: [from := to + 1.
					from > nLines ifTrue: [ from := 1 ]]
			ifFalse: [index = 0 ifTrue: [^ 0].
					^ from + index - 2]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5157-CuisCorePreferences-p4-HilaireFernandes-2022May12-hlsf.002.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 11:44:21 am'!
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 11:35:43' prior: 50353082!
            installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	PreferenceNG 
		name: #haloHandleSize category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 5 // 3 max: 16].
	PreferenceNG
		name: #roundedButtonRadius 	category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 8 // 14].
	PreferenceNG
		name: #roundedWindowRadius 	category: #gui value: [(PreferenceNG at: #standardListFont) pointSize].
	PreferenceNG
		name: #scrollbarThickness category: #gui 		value: [(PreferenceNG at: #windowTitleFont) pointSize + 2].
	PreferenceNG name: #classFinder category: #programming value: [ BrowserWindow findClass ].
	PreferenceNG name: #defaultAuthorName category: #programming value: [Utilities authorName].! !
!WorldMorph methodsFor: 'world menu' stamp: 'hlsf 5/12/2022 11:43:42' prior: 16982898!
                      invokeWorldMenu
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	| menu |
	menu _ (TheWorldMenu new 
		world: self
		hand: self activeHand) buildWorldMenu.
	menu addTitle: PreferenceNG desktopMenuTitle.
	menu popUpInWorld: self! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:36:53' prior: 16864851!
           addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient. Return the handle."

	| handle aPoint colorToUse form icon e |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	e _ (PreferenceNG at: #haloHandleSize) asPoint.
	handle morphPosition: aPoint-(e//2) extent: e.
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				form extent = e ifFalse: [ 
					": Non default size, scale that bugger!!"
					form _ form  ": Be as smooth as possible, these images are small."
						magnify: form boundingBox
						to: e
						smoothing: 2 ].
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^ handle! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:36:59' prior: 16864922!
     addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph verticalNamePosition namePosition nameBackground |
	nameBackground _ BoxedMorph new noBorder
		color: ((target is: #SystemWindow)
			ifTrue: [target windowColor]
			ifFalse: [`Color lightBlue alpha: 0.9`]).
	nameMorph _ LabelMorph contents: aString.
	nameMorph color: `Color black`.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	verticalNamePosition _ haloBox bottom + (PreferenceNG at: #haloHandleSize).
	namePosition _ haloBox width - nameMorph morphWidth // 2 + haloBox left @ verticalNamePosition.
	self addMorph: nameBackground.
	nameBackground morphPosition: namePosition - 2.
	self addMorph: nameMorph.
	nameMorph morphPosition: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:37:08' prior: 16865102!
      handlesBox
	"handlesBox is in local coordinates.
	We assume we are direct submorph of the world, without any scaling or rotation."

	| minSide hs c e box |
	hs _ PreferenceNG at: #haloHandleSize.
	minSide _ 4 * hs.
	e _ extent + (hs*2) max: minSide@minSide.
	c _ extent // 2 + self morphPosition.
	box _ Rectangle center: c extent: e.
	self world ifNotNil: [ :w | box _ box intersect: (w viewBox insetBy: (hs@hs corner: hs@(hs*3))) ].
	"Make it local"
	^box translatedBy: self morphPosition negated.
! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'hlsf 5/12/2022 11:41:12' prior: 16877331 overrides: 16896706!
                         sendEventTo: aMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		self isFindClassShortcut
			ifTrue: [ ^ (PreferenceNG at: #classFinder) value ].
		self isCloseWindowShortcut
			ifTrue: [ ^ self closeCurrentWindowOf: aMorph ].
		^ aMorph processKeystroke: self ].
	type == #keyDown ifTrue: [
		^ aMorph processKeyDown: self ].
	type == #keyUp ifTrue: [ 
		^ aMorph processKeyUp: self ].
	^ super sendEventTo: aMorph.! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:36:17' prior: 16971044!
             roundedButtonRadius
	"Only effective if #roundButtons answers true.
	Provide a reasonable default for subclasses."
	^ PreferenceNG at: #roundedButtonRadius! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:39:14' prior: 16971051!
            roundedWindowRadius
	"Only effective if #roundWindowCorners answers true.
	Provide a reasonable default for subclasses."
	^PreferenceNG at: #roundedWindowRadius! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:40:09' prior: 16971063!
       scrollbarThickness
	^ PreferenceNG at: #scrollbarThickness! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'hlsf 5/12/2022 11:42:06' prior: 16806187!
            preambleTemplate
	"Answer a string that will form the default contents for a change set's preamble.
	Just a first stab at what the content should be."

	^ String streamContents: [:strm |
		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."
		strm tab;tab; nextPutAll: self name.
		strm newLine; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.
		strm newLine; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: (PreferenceNG at: #defaultAuthorName).
		strm newLine; newLine; nextPutAll: '<your descriptive text goes here>"']
"
ChangeSet changeSetForBaseSystem preambleTemplate
"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5158-CuisCorePreferences-p5-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 12:06:56 pm'!
!SystemDictionary methodsFor: 'image, changes name' stamp: 'hlsf 5/12/2022 11:52:14' prior: 16952409!
                 defaultUserChangesName
	"Answer the default full path to the changes file corresponding to the image file name."
	"
	Smalltalk defaultUserChangesName
	"
	^(FileIOAccessor default baseNameFor: self imageName), 
		(PreferenceNG at: #userChangesFileNameExtension)! !
!SystemDictionary methodsFor: 'ui' stamp: 'hlsf 5/12/2022 12:06:12' prior: 16956195!
   beep
	"
	Smalltalk beep
	"
	(PreferenceNG at: #soundsEnabled) ifTrue: [
		Smalltalk
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 12:05:02' prior: 50353315!
                    prefProgramming
	^ #(
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 11:50:23' prior: 50353362!
                            prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges false )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/12/2022 11:53:18' prior: 50353472!
 setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	PreferenceNG
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (PreferenceNG at: #standardListFont) pointSize.}.
				{#standardMenuFont. (PreferenceNG at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (PreferenceNG at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (PreferenceNG at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (PreferenceNG at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!FontFamily class methodsFor: 'ui' stamp: 'hlsf 5/12/2022 11:57:49' prior: 50352071!
                           promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| selectedNameOrDirectory fontFamily |
	selectedNameOrDirectory _ self promptUserFolders.
	selectedNameOrDirectory isNil ifTrue: [ ^nil ].
	(FontFamily familyNamed: selectedNameOrDirectory)
		ifNotNil: [ :it | ^PreferenceNG setDefaultFont: it familyName ].
	(Feature require: 'VectorGraphics') ifTrue: [
		(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
			Feature require: 'VectorEngineInSmalltalk' ].
		UISupervisor whenUIinSafeState: [
			fontFamily _ FontFamily availableFamilies values
				detect: [ :any | any folderName = selectedNameOrDirectory name ]
				ifNone: [
					FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: selectedNameOrDirectory) anyOne ].
			PreferenceNG setDefaultFont: fontFamily familyName ]].! !
!WorldMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 11:58:44' prior: 50354030!
displayWorld
	"Update this world's display."

	| deferredUpdateVMMode allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time. ?? revisar."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"Restore world canvas under hands and their carried morphs"
	(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		hands do: [ :h | h restoreSavedPatchOn: canvas ]].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	canvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage _ canvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	canvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self handsToDrawForDamage: allDamage do: [ :h |
		(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage _ (h savePatchFrom: canvas) quickMerge: allDamage ]
			ifFalse: [ allDamage _ h displayFullBoundsForPatch quickMerge: allDamage ].
		canvas fullDrawHand: h .
		h needsRedraw: false ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		allDamage ifNotNil: [
			"Drawing was done to off-Display canvas. Copy content to Display"
			canvas showAt: self viewBox origin invalidRect: allDamage ]].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	allDamage ifNotNil: [
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: allDamage ]].! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'hlsf 5/12/2022 12:00:41' prior: 16915070!
                    open: model label: aString message: messageString
	
	((PreferenceNG at: #usePreDebugWindow) or: [messageString notNil])
		ifTrue: [self forceOpen: model label: aString message: messageString]
		ifFalse: [model openFullMorphicLabel: aString ]! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'hlsf 5/12/2022 12:02:28' prior: 50354563 overrides: 16896679!
                         dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt _ false.
	grabAMorph _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self) ifTrue: [
				eventHandler _ aMorph.
				aMorphHandlesIt _ true ].
			"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
			self mouseButton1Pressed ifTrue: [
				aMorph owner ifNotNil: [ :o |
					(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
						grabAMorph _ true ]]]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((PreferenceNG at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((PreferenceNG at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(PreferenceNG at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ aMorph is: #SystemWindow :: ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !

PreferenceNG class removeSelector: #import!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5159-CuisCorePreferences-p6-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5159] on 13 May 2022 at 4:46:22 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'hlsf 5/13/2022 16:45:46' prior: 50357876!
              promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				fontFamily includesAscii
					ifTrue: [PreferenceNG setDefaultFont: fontFamily familyName ]
					ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5160-CuisCorePreferences-p7-HilaireFernandes-2022May13-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5160] on 13 May 2022 at 6:50:07 pm'!
!Bag methodsFor: 'enumerating' stamp: 'len 5/3/2022 06:51:53' overrides: 16823114!
      allSatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns false for any element return false.
	Otherwise return true."

	contents keysDo: [:each | (aBlock value: each) ifFalse: [^ false]].
	^ true! !
!Bag methodsFor: 'enumerating' stamp: 'len 5/3/2022 06:52:25' overrides: 16823124!
    anySatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns true for any element return true.
	Otherwise return false"

	contents keysDo: [:each| (aBlock value: each) ifTrue: [^ true]].
	^ false! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:06:18' overrides: 16824037!
         max: aBlock
	"Answer the maximum of evaluating aBlock on all the elements of the receiver."
	| answer |
	self emptyCheck.
	contents keysDo: [:each| answer _ answer isNil ifTrue: [aBlock value: each] ifFalse: [answer max: (aBlock value: each)]].
	^ answer! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:07:06' overrides: 16824056!
            min: aBlock
	"Answer the minimum of evaluating aBlock on all the elements of the receiver."
	| answer |
	self emptyCheck.
	contents keysDo: [:each| answer _ answer isNil ifTrue: [aBlock value: each] ifFalse: [answer min: (aBlock value: each)]].
	^ answer! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:06:25' overrides: 16824073!
            product: aBlock
	| answer |
	self emptyCheck.
	self withOccurrencesDo: [:each :times| answer _ answer isNil ifTrue: [each raisedTo: times] ifFalse: [answer * (each raisedTo: times)]].
	^ answer! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:22:21' overrides: 16824111!
         sum: aBlock ifEmpty: emptyBlockOrValue
	| answer |
	self isEmpty ifTrue: [^ emptyBlockOrValue value].
	self withOccurrencesDo: [:each :times| answer _ answer isNil ifTrue: [each * times] ifFalse: [each * times + answer]].
	^ answer! !
!Collection methodsFor: 'enumerating' stamp: 'len 5/3/2022 07:34:31' prior: 16823240!
                               detect: aBlock ifFound: foundBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the evaluation of foundBlock at the first element for which aBlock evaluates to true."
	^ foundBlock value: (self detect: aBlock ifNone: [^ exceptionBlock value])! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:12:30' prior: 16824032!
                          max
	^ self max: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:12:17' prior: 16824051!
         min
	^ self min: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:11:30' prior: 16824067!
         product
	"Answer the product of all elements in the receiver."
	^ self product: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:11:43' prior: 16824089!
          sum
	"Answer the sum of all elements in the receiver."
	^ self sum: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:15:20' prior: 16824095!
                      sum: aBlock
	^ self sum: aBlock ifEmpty: [self errorEmptyCollection]! !

Bag removeSelector: #sum!

!methodRemoval: Bag #sum stamp: 'Install-5161-BagAndCollectionTweaks-LucianoEstebanNotarfrancesco-2022May13-18h47m-len.001.cs.st 5/16/2022 10:22:26'!
sum
	"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag)."
	
	| sum first |
	first := true.
	contents keysAndValuesDo: [ :value :count |
		first 
			ifTrue: [ sum := value * count. first := false ]
			ifFalse: [ sum := sum + (value * count) ] ].
	first ifTrue: [ self errorEmptyCollection ].
	^sum!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5161-BagAndCollectionTweaks-LucianoEstebanNotarfrancesco-2022May13-18h47m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5141] on 9 May 2022 at 10:43:32 am'!
!Collection methodsFor: 'accessing' stamp: 'len 5/9/2022 07:50:44'!
                       atRandom: aGenerator 
	"Answer a random element of the receiver. Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator. Causes an error if self has no  
	elements."
	| n |
	n _ self size atRandom: aGenerator.
	self do: [:each| (n _ n - 1) = 0 ifTrue: [^ each]].
	self errorEmptyCollection! !
!Bag methodsFor: 'accessing' stamp: 'len 5/9/2022 10:34:52' overrides: 50358243!
                             atRandom: aGenerator 
	"Answer a random element of the receiver. Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator. Causes an error if self has no  
	elements."
	| n |
	n _ self size atRandom: aGenerator.
	self withOccurrencesDo: [:each :times| (n _ n - times) <= 0 ifTrue: [^ each]].
	self errorEmptyCollection! !
!Collection methodsFor: 'testing' stamp: 'len 5/9/2022 07:31:47' prior: 16823776!
 identityIncludes: anObject 
	"Answer whether anObject is one of the receiver's elements."

	^ self anySatisfy: [:any| any == anObject]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5162-CollectionAtRandomAndIdentityIncludesTweaks-LucianoEstebanNotarfrancesco-2022May09-07h28m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5162] on 13 May 2022 at 8:38:50 pm'!
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/13/2022 20:37:37' prior: 50351805!
   withBytes: aByteArray
	"Remove a possible and useless BOM (byte order mark)"
	
	| bom bytesToUse |
	bom _ `Character utf8BytesOfUnicodeCodePoint: 16rFEFF`.
	bytesToUse _ (aByteArray beginsWith: bom)
		ifFalse: [aByteArray]
		ifTrue: [aByteArray copyFrom: bom size+1 to: aByteArray size].
	^self new bytes: bytesToUse ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5163-Utf8String-withBytes-removePossibleBOM-JuanVuletich-2022May13-20h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5163] on 14 May 2022 at 9:12:38 am'!
!Collection methodsFor: 'accessing' stamp: 'len 5/14/2022 09:12:04' prior: 50358243!
               atRandom: aGenerator 
	"Answer a random element of the receiver.  Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator.  Causes an error if self has no  
	elements.
	WARNING: This implementation cannot guarantee reproducibility.
	Calling twice with generators setup with the same seed can produce
	different results (for example if the collection is rehashed between calls).
	If you need reproducibility, you should convert the collection to a sequenceable
	collection first."
	| n |
	self emptyCheck.
	n _ self size atRandom: aGenerator.
	self do: [:each| (n _ n - 1) = 0 ifTrue: [^ each]].
	self error: 'collection invariants broken'! !
!Bag methodsFor: 'accessing' stamp: 'len 5/14/2022 09:11:46' prior: 50358260 overrides: 50358314!
                atRandom: aGenerator 
	"Answer a random element of the receiver.  Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator.  Causes an error if self has no  
	elements.
	WARNING: This implementation cannot guarantee reproducibility.
	Calling twice with generators setup with the same seed can produce
	different results (for example if the collection is rehashed between calls).
	If you need reproducibility, you should convert the collection to a sequenceable
	collection first."
	| n |
	self emptyCheck.
	n _ self size atRandom: aGenerator.
	self withOccurrencesDo: [:each :times| (n _ n - times) <= 0 ifTrue: [^ each]].
	self error: 'collection invariants broken'! !
!Set methodsFor: 'accessing' stamp: 'len 5/14/2022 09:11:53' prior: 16935639 overrides: 50358314!
                     atRandom: aGenerator 
	"Answer a random element of the receiver.  Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator.  Causes an error if self has no  
	elements.
	WARNING: This implementation cannot guarantee reproducibility.
	Calling twice with generators setup with the same seed can produce
	different results (for example if the collection is rehashed between calls).
	If you need reproducibility, you should convert the collection to a sequenceable
	collection first."
	self emptyCheck.
	[(array atRandom: aGenerator) ifNotNil: [:element| ^ element]] repeat! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5164-RandomTweaks-LucianoEstebanNotarfrancesco-2022May14-08h19m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5163] on 14 May 2022 at 12:37:05 pm'!
!Class class methodsFor: 'instance creation' stamp: 'jmv 5/14/2022 12:36:35' prior: 50342113!
        templateForSubclassOf: priorClass category: systemCategoryName 
	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"

	^ priorClass name asPlainString, ' subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''' , systemCategoryName asPlainString , ''''! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5165-newClassTemplate-fix-JuanVuletich-2022May14-12h36m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5160] on 13 May 2022 at 5:25:53 pm'!
!Parser methodsFor: 'scanning' stamp: 'jmv 5/13/2022 17:24:55' prior: 50349736!
             transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a series of consecutive vertical bars, up arrows, colons and regular binary selector characters.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain.
	Another special case is binary selectors ending in $-, like in
	1@-2
	This could be interpreted as `1 @ -2` or `1 @- 2`. Preference #atMinusDigitMeaning tells what to do."

	| toMakeBinary |
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	"Note: Also include #binary, to allow stuff like #+| where a special character comes after after a regular binary operator character. "
	toMakeBinary _ #(binary verticalBar upArrow colon).
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here _ here asPlainString.
	hereType _ #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			(token == #- and: [source peekBack isDigit])
				ifTrue: [
					(PreferenceNG at: #atMinusDigitMeaning) == #disabled
						"Disallow `1@-2`. Insists on some whitespace to disambiguate."
						ifTrue: [ ^self expected: 'A space character after selector' ].
					(PreferenceNG at: #atMinusDigitMeaning) == #st80
						ifTrue: [ ^self ].				"interpret `1@-2` like `1 @ -2`"
					"Assume (PreferenceNG at: #atMinusDigitMeaning) == #ansiSmalltalk
					interpret `1@-2` like `1 @- 2`, i.e. consider #@- a valid binary selector"
					].
			here _ here , token asPlainString.
			hereEnd _ hereEnd + 1.
			self scanToken ].! !
!PreferenceNG class methodsFor: 'data' stamp: 'jmv 5/13/2022 17:15:11' prior: 50357771!
     prefProgramming
	^ #(
		#(atMinusDigitMeaning st80 #(st80 ansiSmalltalk disabled) )
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PreferenceNG name: #atMinusDigitMeaning description: 'Specifies behavior for code such as `@-2`.' category: #programming type: #(st80 ansiSmalltalk disabled) value: #st80!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5166-AtMinusDigit-inSmalltalkCode-defaultTo-st80-JuanVuletich-2022May13-17h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5166] on 15 May 2022 at 12:22:37 pm'!
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 5/14/2022 11:42:57'!
     allPreferences
	^ ThePreferences 
	! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 5/15/2022 12:17:37'!
           selectCategory: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/15/2022 12:21:27' prior: 50353028 overrides: 16904184!
                              initialize
    	ThePreferences ifNil: [ThePreferences _ Dictionary new].
	#(gui font programming system) do: [: category | 
		(self perform: (#pref, category capitalized) asSymbol) do: [:aPrefArray |
			self installDefault: aPrefArray in: category] ].
	self installHaloPreferencesWith: self iconicHaloSpecifications.
	self installMiscPreferences.
	self defaultFontSize: #standardFonts.
	self setDefaultFont: FontFamily defaultFamilyName.! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 5/15/2022 12:21:53' prior: 50353143!
        saveCategory: categorySymbol to: aFileEntry
	| myPref |
	myPref _ self selectCategory: categorySymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: 	(myPref collect: [:aPref | aPref name -> aPref ]) asDictionary! !

PreferenceNG class removeSelector: #select:!

!methodRemoval: PreferenceNG class #select: stamp: 'Install-5167-TweaksFor-PreferenceNG-HilaireFernandes-2022May15-12h16m-hlsf.001.cs.st 5/16/2022 10:22:26'!
select: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]!

PreferenceNG class removeSelector: #all!

!methodRemoval: PreferenceNG class #all stamp: 'Install-5167-TweaksFor-PreferenceNG-HilaireFernandes-2022May15-12h16m-hlsf.001.cs.st 5/16/2022 10:22:26'!
all
	^ ThePreferences 
	!

PreferenceNG initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5167-TweaksFor-PreferenceNG-HilaireFernandes-2022May15-12h16m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5166] on 15 May 2022 at 8:34:54 pm'!
!WeakMessageSend methodsFor: 'private' stamp: 'jmv 5/15/2022 20:32:23' prior: 16980070!
                        collectArguments: anArgArray
	"Private"
    | staticArgs |
    staticArgs := self arguments.
    ^(anArgArray size = staticArgs size)
        ifTrue: [anArgArray]
        ifFalse:
            [(staticArgs isEmpty
                ifTrue: [ staticArgs := Array new: selector numArgs]
                ifFalse: [staticArgs asNewArray] )
                    replaceFrom: 1
                    to: (anArgArray size min: staticArgs size)
                    with: anArgArray
                    startingAt: 1]
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5168-WeakMessageSend-fix-JuanVuletich-2022May15-20h27m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5168] on 16 May 2022 at 9:11:51 am'!
!Point methodsFor: 'printing' stamp: 'jmv 5/16/2022 09:05:30' prior: 50352797 overrides: 16902975!
                          printOn: aStream 
	"The receiver prints on aStream in terms of infix notation."

	x printOn: aStream.
	aStream nextPut: $@.
	y negative ifTrue: [ aStream space ].
	y printOn: aStream! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5169-Point-printOn-NoExtraSpaceIfPositiveY-JuanVuletich-2022May16-09h11m-jmv.001.cs.st----!

----QUIT----(16 May 2022 10:22:34) Cuis6.0-5169.image priorSource: 147673!

----STARTUP---- (17 May 2022 10:40:09) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5169.image!


'From Cuis 6.0 [latest update: #5169] on 16 May 2022 at 11:17:31 am'!
!DropFilesEvent methodsFor: 'files' stamp: 'jmv 5/16/2022 11:16:19' prior: 16844864!
                 fileNamesDo: aBlock

	1 to: numberOfFiles do: [ :fileNumber | | utf8Bytes |
		(self primDropRequestFileName: fileNumber) ifNotNil: [ :primUtf8Bytes |
		utf8Bytes _ primUtf8Bytes.
		utf8Bytes class format = ByteArray format  												"True unless image is in 32bit V3 format"
			ifTrue: [ ByteArray adoptInstance: utf8Bytes ]
			ifFalse: [ utf8Bytes _ ByteArray withAll: utf8Bytes ].
		aBlock value: (String fromUtf8: utf8Bytes) ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5170-FileDrop-convertUtf8FromOS-JuanVuletich-2022May16-11h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5170] on 17 May 2022 at 10:33:52 am'!
!PreferenceNG class methodsFor: 'data' stamp: 'jmv 5/17/2022 10:29:13' prior: 50357819!
  prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!Theme methodsFor: 'other options' stamp: 'jmv 5/17/2022 10:23:52' prior: 50354683!
        fullScreenDeskMargin
	^ (PreferenceNG at: #fullScreenLeavesDeskMargins) ifTrue: [48] ifFalse: [0]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PreferenceNG at: #autoNumberUserChanges put: true.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5171-restore-AutoNumberUserChanges-JuanVuletich-2022May17-10h15m-jmv.001.cs.st----!

----QUIT----(17 May 2022 10:40:15) Cuis6.0-5171.image priorSource: 864589!

----STARTUP---- (16 June 2022 07:24:43) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5171.image!


'From Cuis 6.0 [latest update: #5172] on 18 May 2022 at 8:58:36 am'!
!MenuMorph methodsFor: 'geometry' stamp: 'jmv 5/18/2022 08:58:03' overrides: 16893209!
 fontPreferenceChanged
	super fontPreferenceChanged.
	self adjustSubmorphsLayout.! !
!LabelMorph methodsFor: 'geometry' stamp: 'jmv 5/18/2022 08:56:10' overrides: 16893209!
                    fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (PreferenceNG at: #standardListFont).
	self fitContents.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5172-FixPossibleWalkbacksWhenSettingDefautFont-JuanVuletich-2022May18-08h56m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5171] on 17 May 2022 at 9:49:40 pm'!
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/17/2022 21:49:10' prior: 50352888!
             accept: aVisitor
	| visitMethod |
	self isTypeAClass 
		ifTrue: [ visitMethod _ ('visit', type name, 'Preference:') asSymbol ]
		ifFalse: [visitMethod _ ('visit', type species asString, 'Preference:') asSymbol ].
	^ aVisitor perform: visitMethod with: self! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5173-PreferenceNG-visitor-tweak-HilaireFernandes-2022May17-21h33m-hlsf.002.cs.st----!

'From Cuis 6.0 [latest update: #5173] on 19 May 2022 at 12:00:58 pm'!
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/19/2022 11:57:58' prior: 16914363!
         backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter _ $!!.
	"Go to end of chunk, not including delimiter."
	ch _ self back.
	ch = delimiter ifTrue: [ ch _ self back ].

	count _ 1.
	prevCh _ $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count _ count + 1.
		prevCh _ ch.
		ch _ self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count _ count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition _ self position.
	answer _ String streamContents: [ :strm |
		prevCh _ $$.
		delimiterCount _ 0.
		count timesRepeat: [
			ch _ self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount _ ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !

PositionableStream removeSelector: #oldBack!

!methodRemoval: PositionableStream #oldBack stamp: 'Install-5174-PositionableStream-cleanup-JuanVuletich-2022May19-10h44m-jmv.001.cs.st 6/16/2022 07:24:48'!
oldBack
	"Go back one element and return it.  Use indirect messages in case I am a StandardFileStream"
	"The method is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. This method considers that the pointer is *on* an element. Please consider unit tests which verifies #back and #oldBack behavior. (Damien Cassou - 1 August 2007)"
	self position = 0 ifTrue: [self error: 'CantGoBack'].
	self position = 1 ifTrue: [self position: 0.  ^ nil].
	self skip: -2.
	^ self next
!

PositionableStream removeSelector: #oldPeekBack!

!methodRemoval: PositionableStream #oldPeekBack stamp: 'Install-5174-PositionableStream-cleanup-JuanVuletich-2022May19-10h44m-jmv.001.cs.st 6/16/2022 07:24:48'!
oldPeekBack
	"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream."

	| element |
	element _ self oldBack.
	self skip: 1.
	^ element!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5174-PositionableStream-cleanup-JuanVuletich-2022May19-10h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5174] on 19 May 2022 at 1:27:11 pm'!
!Utf32String methodsFor: 'testing' stamp: 'jmv 5/16/2022 17:03:13'!
 notEmpty
	"Answer whether the receiver contains any elements."

	^ self isEmpty not! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 5/16/2022 17:03:08'!
      notEmpty
	"Answer whether the receiver contains any elements."

	^ self isEmpty not! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5175-UtfStrings-notEmpty-JuanVuletich-2022May19-13h26m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5174] on 19 May 2022 at 1:27:55 pm'!
!Object methodsFor: 'testing' stamp: 'jmv 5/17/2022 16:38:18'!
  isCharacterLike
	"Overridden to return true in Character and UnicodeCodePoint."
	^ false! !
!Character methodsFor: 'testing' stamp: 'jmv 5/17/2022 16:38:27' overrides: 50358901!
              isCharacterLike
	^true! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/17/2022 16:37:43' overrides: 50358901!
         isCharacterLike
	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5176-isCharacterLike-JuanVuletich-2022May19-13h27m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5174] on 19 May 2022 at 1:30:55 pm'!
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 5/17/2022 16:39:47' overrides: 16901772!
   = aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].
	aCodePointOrCharacter isCharacterLike ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 5/19/2022 13:30:01' overrides: 16901788!
    hash
	"Hash is reimplemented because = is implemented."

	^value hash! !
!Character methodsFor: 'comparing' stamp: 'jmv 5/17/2022 16:39:43' prior: 16808133 overrides: 16901772!
               = aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].
	aCodePointOrCharacter isCharacterLike ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5177-Character-CodePoint-equality-JuanVuletich-2022May19-13h27m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5177] on 20 May 2022 at 10:36:46 am'!
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 5/20/2022 10:30:37' prior: 50344773!
           getPreambleFrom: aFileStream at: position
	|  writeStream c p |
	writeStream _ String new writeStream.
	p _ position - 1.
	c _ nil.
	aFileStream position: p.
	aFileStream atEnd ifTrue: [ ^ nil ].
	[ p >= 0 and: [ c ~~ $!! ]] whileTrue: [
		aFileStream position: p.
		c _ aFileStream next.
		p _ p - 1 ].
	[ p >= 0] whileTrue: [
		aFileStream position: p.
		c _ aFileStream next.
		c == $!!
			ifTrue: [^ writeStream contents reverse ]
			ifFalse: [ writeStream nextPut: c ].
		p _ p - 1 ].
	^ nil! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/19/2022 18:23:42' prior: 16944723 overrides: 16856289!
               next
	"Answer the next byte or character (depending on mode) from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/20/2022 10:31:01' prior: 16944854 overrides: 16914055!
               peek
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	| next |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^ nil].
	next _ self next.
	self position: self position - 1.
	^ next! !

StandardFileStream removeSelector: #basicNext!

!methodRemoval: StandardFileStream #basicNext stamp: 'Install-5178-basicNext-cleanup-JuanVuletich-2022May20-10h29m-jmv.001.cs.st 6/16/2022 07:24:48'!
basicNext
	"Answer the next byte or character (depending on mode) from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5178-basicNext-cleanup-JuanVuletich-2022May20-10h29m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5178] on 20 May 2022 at 11:19:02 am'!
!PositionableStream methodsFor: 'filein/out' stamp: 'jmv 5/20/2022 11:06:18'!
   copyPreamble: preamble oldPreamble: oldPreamble
	"Look for a changeStamp for this method.
	Write a method preamble, with that stamp if found."
	| terminator stamp i |
	terminator := $!!.

	"Look back to find stamp in old preamble, such as...
	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "
	stamp := String new.
	(i := oldPreamble 
		findLastOccurrenceOfString: 'stamp:'
		startingAt: 1) > 0 ifTrue: 
		[ stamp := (oldPreamble 
			copyFrom: i + 8
			to: oldPreamble size) copyUpTo: $' ].

	"Write the new preamble, with old stamp if any."
	self
		newLine;
		nextPut: terminator.
	self nextChunkPut: (String streamContents: 
			[ :strm | 
			strm nextPutAll: preamble.
			stamp size > 0 ifTrue: 
				[ strm
					nextPutAll: ' stamp: ';
					print: stamp ] ]).
	self newLine! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 5/20/2022 11:11:11' prior: 50345727!
                               printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble compiledMethod oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asPlainString printString]
		ifFalse: [preamble _ ''].
	compiledMethod _ self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR  -  THIS METHOD IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	((compiledMethod fileIndex = 0
		or: [(SourceFiles at: compiledMethod fileIndex) == nil])
		or: [(oldPos _ compiledMethod filePosition) = 0])
	ifTrue: [
		"The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [ outStream newLine; nextPut: $!!; nextChunkPut: preamble; newLine].
		outStream nextChunkPut: compiledMethod decompileString]
	ifFalse: [
		sourceFile _ SourceFiles at: compiledMethod fileIndex.
		preamble size > 0
			ifTrue: [   "Copy the preamble"
				outStream copyPreamble: preamble oldPreamble: compiledMethod getPreamble ].
		sourceFile position: oldPos.
		"Copy the method chunk"
		fileIndex = 0 ifFalse: [
			outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
		newPos _ outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		moveSource ifTrue: [    "Set the new method source pointer"
			endPos _ outStream position.
			compiledMethod checkOKToAdd: endPos - newPos at: newPos in: compiledMethod fileIndex.
			compiledMethod setSourcePosition: newPos inFile: fileIndex]].
	preamble notEmpty ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream newLine! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 5/20/2022 11:14:03' prior: 16829044!
           getPreamble
	| file preamble |
	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"
	file _ SourceFiles at: self fileIndex.
	file ifNil: [^ ''].  "sources file not available"
	"file does not exist happens in secure mode"
	[
		file name asFileEntry readStreamDo: [ :stream | | p |
			preamble _ ''.
			p _ 0 max: self filePosition.
			p < stream size ifTrue: [
				stream position: p.
				"Skip back blank space."
				stream backChunk.
				"Find and answer preamble chunk."
				preamble _ stream backChunk ]]
	] on: FileDoesNotExistException do: [ :ex | preamble _ '' ].
	^ preamble! !

PositionableStream removeSelector: #copyPreamble:from:at:!

!methodRemoval: PositionableStream #copyPreamble:from:at: stamp: 'Install-5179-methodPreambleFromFile-cleanup-JuanVuletich-2022May20-11h18m-jmv.001.cs.st 6/16/2022 07:24:48'!
copyPreamble: preamble from: aStream at: pos 
	"Look for a changeStamp for this method by peeking backward.
	Write a method preamble, with that stamp if found."
	| terminator last50 stamp i |
	terminator := $!!.

	"Look back to find stamp in old preamble, such as...
	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "
	aStream position: pos.
	aStream backChunk.	"to beginning of method"
	last50 := aStream backChunk.	"to get preamble"
	aStream position: pos.
	stamp := String new.
	(i := last50 
		findLastOccurrenceOfString: 'stamp:'
		startingAt: 1) > 0 ifTrue: 
		[ stamp := (last50 
			copyFrom: i + 8
			to: last50 size) copyUpTo: $' ].

	"Write the new preamble, with old stamp if any."
	self
		newLine;
		nextPut: terminator.
	self nextChunkPut: (String streamContents: 
			[ :strm | 
			strm nextPutAll: preamble.
			stamp size > 0 ifTrue: 
				[ strm
					nextPutAll: ' stamp: ';
					print: stamp ] ]).
	self newLine!

CompiledMethod removeSelector: #sourceFileStream!

!methodRemoval: CompiledMethod #sourceFileStream stamp: 'Install-5179-methodPreambleFromFile-cleanup-JuanVuletich-2022May20-11h18m-jmv.001.cs.st 6/16/2022 07:24:48'!
sourceFileStream 
	"Answer the sources file stream with position set at the beginning of my source string"

	| pos |
	(pos _ self filePosition) = 0 ifTrue: [^ nil].
	^ (RemoteString newFileNumber: self fileIndex position: pos) fileStream!

CompiledMethod removeSelector: #getPreambleFrom:at:!

!methodRemoval: CompiledMethod #getPreambleFrom:at: stamp: 'Install-5179-methodPreambleFromFile-cleanup-JuanVuletich-2022May20-11h18m-jmv.001.cs.st 6/16/2022 07:24:48'!
getPreambleFrom: aFileStream at: position
	|  writeStream c p |
	writeStream _ String new writeStream.
	p _ position - 1.
	c _ nil.
	aFileStream position: p.
	aFileStream atEnd ifTrue: [ ^ nil ].
	[ p >= 0 and: [ c ~~ $!! ]] whileTrue: [
		aFileStream position: p.
		c _ aFileStream next.
		p _ p - 1 ].
	[ p >= 0] whileTrue: [
		aFileStream position: p.
		c _ aFileStream next.
		c == $!!
			ifTrue: [^ writeStream contents reverse ]
			ifFalse: [ writeStream nextPut: c ].
		p _ p - 1 ].
	^ nil!

CompiledMethod removeSelector: #sourceClass!

!methodRemoval: CompiledMethod #sourceClass stamp: 'Install-5179-methodPreambleFromFile-cleanup-JuanVuletich-2022May20-11h18m-jmv.001.cs.st 6/16/2022 07:24:48'!
sourceClass
	"Get my receiver class (method class) from the preamble of my source.  Return nil if not found."

	^ [(Compiler evaluate: (self sourceFileStream backChunk "blank"; backChunk "preamble")) theClass] on: Error do: nil!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5179-methodPreambleFromFile-cleanup-JuanVuletich-2022May20-11h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5171] on 21 May 2022 at 7:00:18 pm'!
!PreferenceNG class methodsFor: 'as yet unclassified' stamp: 'HAW 5/21/2022 18:59:42'!
                           openPreferencesInspector
	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"
	
	self allPreferences inspectWithLabel: 'Preferences'! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 5/21/2022 18:58:42' prior: 16970148!
   preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: {
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		Preferences.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		Preferences.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#readAdditionalTrueTypeFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		PreferenceNG.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5180-SeeAllPreferences-HernanWilkinson-2022May21-18h58m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5173] on 21 May 2022 at 11:26:58 pm'!
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 5/21/2022 23:26:24'!
                             messageRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		15.
				#label 			-> 		'change keyword order...'.
				#selector 		-> 		#changeKeywordOrder.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'push down'.
				#selector 		-> 		#pushDownSelector.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		60.
				#label 			-> 		'move to instance/class method'.
				#selector 		-> 		#moveToInstanceOrClassMethod.
				#icon 			-> 		#changesIcon
			} asDictionary.
	}`.

	! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 5/21/2022 23:26:24' prior: 16797460!
                         messageRefactoringMenu

	^DynamicMenuBuilder buildTitled: 'Refactorings' targeting: self collectingMenuOptionsWith: #messageRefactoringMenuOptions.! !

RefactoringMenues class removeSelector: #messsageRefactoringMenuOptions!

!methodRemoval: RefactoringMenues class #messsageRefactoringMenuOptions stamp: 'Install-5181-TypoFix-HernanWilkinson-2022May21-23h26m-HAW.001.cs.st 6/16/2022 07:24:48'!
messsageRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		15.
				#label 			-> 		'change keyword order...'.
				#selector 		-> 		#changeKeywordOrder.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'push down'.
				#selector 		-> 		#pushDownSelector.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		60.
				#label 			-> 		'move to instance/class method'.
				#selector 		-> 		#moveToInstanceOrClassMethod.
				#icon 			-> 		#changesIcon
			} asDictionary.
	}`.

	!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5181-TypoFix-HernanWilkinson-2022May21-23h26m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5171] on 21 May 2022 at 11:59:01 pm'!
!Class class methodsFor: 'instance creation' stamp: 'HAW 5/21/2022 23:57:46' prior: 16811064!
            template: aSystemCategoryName 
	"Answer an expression that can be edited and evaluated in order to define a new class."

	^ self templateForSubclassOf: Object category: aSystemCategoryName ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5182-ClassTemplateFix-HernanWilkinson-2022May21-23h53m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5173] on 22 May 2022 at 12:52:35 am'!
!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'HAW 5/22/2022 00:50:26' prior: 16958706!
                           fileOutCategory: aCategoryRoot
	"FileOut all the classes in the named system category."

	DirectoryEntry smalltalkImageDirectory // (aCategoryRoot asFileName , '.st') writeStreamDo: [ :fileStream |
		(self categoriesMatching: aCategoryRoot,'*') do: [ :category | 
			self fileOutCategory: category on: fileStream initializing: true ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5183-SystemCategoryFileOutFix-HernanWilkinson-2022May21-23h40m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5183] on 23 May 2022 at 9:20:36 am'!
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 5/23/2022 09:18:06' prior: 16782506!
                             shouldOpenMorphWhenNoPrefixFor: currentChar 
	
	^currentChar isAlphaNumeric 
		or: [ currentChar = $]
		or: [ currentChar = $) 
		or: [ currentChar = $; ]]]! !

Character removeSelector: #isRightBracket!

!methodRemoval: Character #isRightBracket stamp: 'Install-5184-cleanup-JuanVuletich-2022May23-09h18m-jmv.001.cs.st 6/16/2022 07:24:48'!
isRightBracket

	^self = $]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5184-cleanup-JuanVuletich-2022May23-09h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5183] on 23 May 2022 at 9:40:11 am'!
!Browser methodsFor: 'class functions' stamp: 'jmv 5/21/2022 22:29:19' prior: 16795347!
                          explainSpecial: string 
	"Answer a string explaining the code pane selection if it is displaying 
	one of the special edit functions."

	| classes whole lits reply |
	self isEditingClass
		ifTrue: 
			["Selector parts in class definition"
			string last = $: ifFalse: [^nil].
			lits _ Array with:
				#subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.
			(whole _ lits detect: [:each | (each keywords
					detect: [:frag | frag = string] ifNone: nil) notNil]
						ifNone: nil) notNil
				ifTrue: [reply _ '"' , string , ' is one part of the message selector ' , whole , '.']
				ifFalse: [^nil].
			classes _ Smalltalk allClassesImplementing: whole.
			classes _ 'these classes ' , classes printString.
			^reply , '  It is defined in ' , classes , '."
Smalltalk browseAllImplementorsOf: #' , whole].

	editSelection == #editSystemCategories ifTrue: [^nil].
	editSelection == #editMessageCategories ifTrue: [^nil].
	^nil! !
!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 5/21/2022 22:29:24' prior: 50345533!
               contents: aString notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Create an error if the category of the selected message is unknown. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."
	| category selector class oldSelector |

	(class _ self selectedClassOrMetaClass) ifNil:
		[(myChangeSet preambleString == nil or: [aString isEmpty]) ifTrue: [ ^ false].
		(aString count: [:char | char = $"]) odd 
			ifTrue: [self inform: 'unmatched double quotes in preamble']
			ifFalse: [(Scanner new scanTokens: aString) notEmpty ifTrue: [
				self inform: 'Part of the preamble is not within double-quotes.
To put a double-quote inside a comment, type two double-quotes in a row.
(Ignore this warning if you are including a doIt in the preamble.)']].
		myChangeSet preambleString: aString.
		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"
		^ true].
	oldSelector _ self selectedMessageName.
	category _ class organization categoryOfElement: oldSelector.
	selector _ class compile: aString
				classified: category
				notifying: aRequestor.
	selector ifNil: [^ false].
	(self messageList includes: selector)
		ifTrue: [self currentSelector: selector]
		ifFalse: [self currentSelector: oldSelector].
	self update.
	^ true! !
!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00' prior: 16874147 overrides: 16900107!
              / aNumber
	"Refer to the comment in Number / "
	| quoRem |
	aNumber isInteger ifTrue:
		[quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"
						neg: self negative ~= aNumber negative.
		(quoRem at: 2) = 0
			ifTrue: [^ (quoRem at: 1) normalize]
			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].
	^ aNumber adaptToInteger: self andSend: #/! !
!Character methodsFor: 'fileman-testing' stamp: 'jmv 5/21/2022 22:29:28' prior: 16808404!
     isDriveSeparator
	^self = $:
	! !
!String methodsFor: 'printing' stamp: 'jmv 5/21/2022 22:29:53' prior: 16948975 overrides: 16781394!
                          storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do: [ :i |
		aStream nextPut: (x _ self at: i).
		x = $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'! !
!String methodsFor: 'private' stamp: 'jmv 5/21/2022 22:29:38' prior: 16949029!
        getEnclosedExpressionFrom: aStream 
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"
	| result currentChar |
	result := String new writeStream.

	[aStream atEnd 
		or: [(currentChar := aStream next) = $}]]
		whileFalse: [result nextPut: currentChar].

	^ result contents withBlanksTrimmed! !
!String methodsFor: 'formatting' stamp: 'jmv 5/21/2022 22:29:35' prior: 16949323!
              format: aCollection 
	"format the receiver with aCollection  
	 
	simplest example:  
	'foo {1} bar' format: {Date today}.
	 
	complete example:  
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}.  
	"
	| result stream |
	result := String new writeStream.
	stream := self readStream.

	[stream atEnd]
		whileFalse: [| currentChar | 
			currentChar := stream next.
			currentChar = ${
				ifTrue: [| expression | 
					expression := self getEnclosedExpressionFrom: stream.
					result
						nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
				ifFalse: [
					currentChar = $\
						ifTrue: [stream atEnd
								ifFalse: [result nextPut: stream next]]
						ifFalse: [result nextPut: currentChar]]].

	^ result contents! !
!Symbol class methodsFor: 'services' stamp: 'jmv 5/21/2022 22:30:35' prior: 16951184!
                           possibleSelectorsFor: misspelled 
	"Answer an ordered collection of possible corrections
	for the misspelled selector in order of likelyhood"

	| numArgs candidates lookupString best binary short long first ss |
	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"
	numArgs _ lookupString numArgs.
	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].
	first _ lookupString first.
	short _ lookupString size - (lookupString size // 4 max: 3) max: 2.
	long _ lookupString size + (lookupString size // 4 max: 3).

	"First assemble candidates for detailed scoring"
	candidates _ OrderedCollection new.
	self allSymbolTablesDo: [:s | (((ss _ s size) >= short	"not too short"
			and: [ss <= long			"not too long"
					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"
			and: [s numArgs = numArgs])	"and numArgs is the same"
			ifTrue: [candidates add: s]].

	"Then further prune these by correctAgainst:"
	best _ lookupString correctAgainst: candidates.
	((misspelled last ~= $:) and: [misspelled size > 1]) ifTrue: [
		binary _ misspelled, ':'.		"try for missing colon"
		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].
	^ best! !
!Base64MimeConverter methodsFor: 'conversion' stamp: 'jmv 5/21/2022 22:29:58' prior: 16784356!
                         nextValue
	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"
	| raw num |
	FromCharTable ifNil: [ self class initializeTables ].
	[
		raw := mimeStream next.
		raw ifNil: [^ nil].	"end of stream"
		raw = $= ifTrue: [^ nil].
		num := FromCharTable at: raw asciiValue + 1.
		num ifNotNil: [^ num].
		"else ignore space, return, tab, ..."
	] repeat! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/21/2022 22:24:35' prior: 16913920!
    nextDelimited: terminator
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator."

	| out ch |
	out _ WriteStream on: (String new: 1000).
	self atEnd ifTrue: [^ ''].
	self next = terminator ifFalse: [self skip: -1].	"absorb initial terminator"
	[(ch _ self next) == nil] whileFalse: [
		(ch = terminator) ifTrue: [
			self peek = terminator ifTrue: [
				self next.  "skip doubled terminator"
			] ifFalse: [
				^ out contents  "terminator is not doubled; we're done!!"
			].
		].
		out nextPut: ch.
	].
	^ out contents! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/21/2022 22:24:22' prior: 16914521!
              nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator out ch |
	terminator _ $!!.
	out _ WriteStream on: (String new: 1000).
	self skipSeparators.
	[(ch _ self next) == nil] whileFalse: [
		(ch = terminator) ifTrue: [
			self peek = terminator ifTrue: [
				self next.  "skip doubled terminator"
			] ifFalse: [
				^ out contents  "terminator is not doubled; we're done!!"
			].
		].
		out nextPut: ch.
	].
	^ out contents! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:26:26' prior: 16931801!
         isAt: aChar
	
	^ hereChar = aChar and: [aheadChar = aChar ifTrue: [self step. false] ifFalse: [true]]! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:26:59' prior: 16931807!
                         readUpToNext: aChar ifNotFound: aNotFoundBlock

	self step.
	buffer reset.
	
	[self isAt: aChar]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = DoItCharacter and: [source atEnd]) ifTrue: [^aNotFoundBlock value ]].
	
	self step.
	token := buffer contents.! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:30:01' prior: 16931842!
                  xColon
	"Allow := for assignment"
	
	aheadChar = $= ifTrue:
		[self step.
		tokenType := #leftArrow.
		self step.
		^ token := #':='].
	"Otherwise, just do what normal scan of colon would do"
	tokenType := #colon.
	^ token := self step asSymbol! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:38:28' prior: 16931858!
          xDigit
	"Form a number."

	tokenType := #number.
	(aheadChar = DoItCharacter and: [source atEnd
			and:  [source skip: -1. source next ~= DoItCharacter]])
		ifTrue: [source skip: -1 "Read off the end last time"]
		ifFalse: [source skip: -2].
	token := [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].
	self step; step! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:38:36' prior: 16931880!
              xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := WriteStream on: (String new: 200).
    self step.
    [hereChar = $"]
        whileFalse:
            [(hereChar = stopChar and: [source atEnd])
                ifTrue: [^self offEnd: self class unmatechedCommentQuoteErrorDescription].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollection with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:30:42' prior: 16931915!
           xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore]]] whileTrue:
			["open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
							ifTrue: [DoItCharacter "doit"]
							ifFalse: [source next]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~= $=]])
					ifTrue: 
						[buffer nextPut: self step.
						"Allow any number of embedded colons in literal symbols"
						[(self typeTableAt: hereChar) == #xColon] whileTrue:
							[buffer nextPut: self step].
						#keyword]
					ifFalse: 
						[#word].
	token := buffer contents! !
!Parser methodsFor: 'pragmas' stamp: 'jmv 5/21/2022 22:31:42' prior: 16907266!
  pragmaLiteral: selectorSoFar
	"Read a pragma literal.  As a nicety we allow a variable name (rather
	 than a literal string) as the second argument to primitive:error:"

	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])
		ifTrue: [ ^ self advance ].
	(here = $# and: [ tokenType == #word ])
		ifTrue: [ ^ self advance ].
	(here == #- and: [ tokenType == #number ])
		ifTrue: [ ^ (self advance; advance) negated ].
	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])
		ifTrue: [ ^ (Scanner new scanTokens: self advance) first ].
	"This nicety allows one to supply a primitive error
	 temp as a variable name, rather than a string."
	((selectorSoFar beginsWith: 'primitive:')
	 and: [(selectorSoFar endsWith: 'error:')
	 and: [hereType == #word]]) ifTrue:
		[^self advance].
	^self expected: 'Literal constant'! !
!Parser methodsFor: 'scanning' stamp: 'jmv 5/21/2022 22:38:43' prior: 16907462!
                             compensateTwoCharacterLookahead

	^source position - (aheadChar = DoItCharacter ifTrue: [hereChar = DoItCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2])
	! !
!Parser methodsFor: 'error correction' stamp: 'jmv 5/21/2022 22:30:51' prior: 16908331!
         correctSelector: proposedKeyword wordIntervals: aSpots exprInterval: expInt ifAbort: abortAction
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| correctSelector userSelection delta adjustedSpots |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [^proposedKeyword asSymbol].
	
	"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"
	"
	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])
		ifFalse: [ ^ proposedKeyword asSymbol ].
	"

	userSelection _ requestor selectionInterval.

	delta := self sourceDelta.
	adjustedSpots := aSpots collect: [ :interval | interval first - delta to: interval last - delta ].
	requestor selectFrom: adjustedSpots first first to: adjustedSpots last last.

	correctSelector _ UnknownSelector name: proposedKeyword.
	correctSelector ifNil: [^abortAction value].

	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	self substituteSelector: correctSelector keywords wordIntervals: adjustedSpots.
	^(proposedKeyword last ~= $:
	   and: [correctSelector last = $:])
		ifTrue: [abortAction value]
		ifFalse: [correctSelector]! !
!TextEditor methodsFor: 'private' stamp: 'jmv 5/21/2022 23:02:52' prior: 16967608!
                               indent: delta fromStream: inStream toStream: outStream
	"Append the contents of inStream to outStream, adding or deleting delta or -delta
	 tabs at the beginning, and after every NewLine except a final NewLine.  Do not add tabs
	 to totally empty lines, and be sure nothing but tabs are removed from lines."

	| ch skip tab prev atEnd |
	tab _ Character tab.
	delta > 0
		ifTrue: [
			"shift right"
			prev _ Character newLineCharacter.
			[
			ch _ (atEnd _ inStream atEnd)
				ifTrue: [ Character newLineCharacter ]
				ifFalse: [ inStream next ].
			(prev isLineSeparator and: [ ch isLineSeparator not ]) ifTrue: [ delta timesRepeat: [ outStream nextPut: tab ]].
			atEnd ] whileFalse: [
				outStream nextPut: ch.
				prev _ ch ]]
		ifFalse: [
			"shift left"
			skip _ delta.
			"a negative number"
			[ inStream atEnd ] whileFalse: [
				((ch _ inStream next) = tab and: [ skip < 0 ]) ifFalse: [ outStream nextPut: ch ].
				skip _ ch isLineSeparator
					ifTrue: [ delta ]
					ifFalse: [ skip + 1 ]]]! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 5/21/2022 22:31:49' prior: 16940182!
                    explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"
	| lits whole reply classes s msg provider |
	provider _ self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg _ provider selectedMessageName) ifNil: [^ nil].  "not in a message"
	string last = $: ifFalse: [^ nil].
	"Name of this method"
	lits _ Array with: msg.
	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: nil) notNil]
				ifNone: nil)
		ifNotNil: [
			reply _ ', which is the selector of this very method!!'.
			s _ self class plateA]
		ifNil: [ 
			"Selectors called from this method"
			lits _ (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(whole _ lits detect: [:each | (each keywords detect: [ :frag | frag = string ]
							ifNone: nil) notNil]
						ifNone: nil) notNil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply _ '.'.
			s _ self class plateB].
		classes _ Smalltalk allClassesImplementing: whole.
		classes size > 12
			ifTrue: [classes _ 'many classes']
			ifFalse: [classes _ 'these classes ' , classes printString].
		^ String streamContents: [:str |
			str
				nextPutAll: string;
				nextPutAll: ' is one part of the message selector ';
				nextPutAll: whole;
				nextPutAll: reply;
				nextPutAll: '  It is defined in ';
				nextPutAll: classes;
				nextPutAll: s]! !
!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:44' prior: 16964593!
                        analyze: aString
	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:
3+4
<3+4>
Click Here<3+4>
<3+4>Click Here
"
	"Obtain the showing text and the instructions"
	| b1 b2 trim param show |
	b1 _ aString indexOf: $<.
	b2 _ aString indexOf: $>.
	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"
		param _ self validate: aString.
		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].
	"Two parts"
	trim _ aString withBlanksTrimmed.
	trim first = $< 
		ifTrue: [ trim last = $>
			ifTrue: ["only instructions" 
				param _ self validate: (aString copyFrom: b1+1 to: b2-1).
				show _ param size = 0 ifTrue: [nil] ifFalse: [param]]
			ifFalse: ["at the front"
				param _ self validate: (aString copyFrom: b1+1 to: b2-1).
				show _ param size = 0 ifTrue: [nil] 
						ifFalse: [aString copyFrom: b2+1 to: aString size]]]
		ifFalse: [ trim last = $>
			ifTrue: ["at the end"
				param _ self validate: (aString copyFrom: b1+1 to: b2-1).
				show _ param size = 0 ifTrue: [nil] 
						ifFalse: [aString copyFrom: 1 to: b1-1]]
			ifFalse: ["Illegal -- <> has text on both sides"
				show _ nil]].
	^ Array with: param with: show
! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:32:35' prior: 16822593!
       classListKey: aChar from: view 
	"Respond to a Command key.  I am a model with a list of classes and a 
	code pane, and I also have a listView that has a list of methods.  The 
	view knows how to get the list and selection."

	aChar = $r ifTrue: [^ model recent].
	aChar = $h ifTrue: [^ self browseHierarchy].
	aChar = $x ifTrue: [^ model removeClass].
	aChar = $t ifTrue: [^ model runClassTests ].
	
	^ self messageListKey: aChar from: view! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:32:48' prior: 16822610!
     messageCatListKey: aChar from: view

	aChar = $o ifTrue: [^ model fileOutMessageCategories ].
	aChar = $t ifTrue: [^ model runMessageCategoryTests ].
	aChar = $x ifTrue: [^ model removeMessageCategory ].
	aChar = $R ifTrue: [ ^model renameCategory ].
	aChar = $n ifTrue: [^model addCategory ].
	aChar = $e ifTrue: [^model removeEmptyCategories ].
	aChar = $c ifTrue: [^model categorizeAllUncategorizedMethods ].
	aChar = $a ifTrue: [ ^ model alphabetizeMessageCategories ].
	aChar = $r ifTrue: [ ^ model editMessageCategories ]! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:38:59' prior: 16822630!
               messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	aChar = $D ifTrue: [^ model toggleDiffing].

	sel _ model selectedMessageName.
	aChar = $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar = $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	"The following require a class selection"
	(class _ model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar = $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar = $N ifTrue: [^ self browseClassRefs].
	aChar = $i ifTrue: [^ self methodInheritance].
	aChar = $h ifTrue: [^ self browseHierarchy].
	aChar = $p ifTrue: [^ self browseFullProtocol].

	sel
		ifNotNil: [
			"The following require a method selection"
			aChar = $o ifTrue: [^ model fileOutMessage].
			aChar = $c ifTrue: [^ model copySelector].
			aChar = $v ifTrue: [^ self browseVersions].
			aChar = $C ifTrue: [^ model showHomeCategory].
			aChar = $O ifTrue: [^ self openSingleMessageBrowser].
			aChar = $x ifTrue: [^ model removeMessage].
			aChar = $t ifTrue: [^ model runMethodTest].
			aChar = $r ifTrue: [^ model debugMethodTest]]
		ifNil: [
			aChar = $R ifTrue: [^ model renameClass]]! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:20' prior: 16822679!
          systemCatListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."

	aChar = $f ifTrue: [ ^ self findClass ].
	aChar = $x ifTrue: [ ^ model removeSystemCategory ].
	aChar = $t ifTrue: [ ^ model runSystemCategoryTests ].
	aChar = $a ifTrue: [ ^ model addSystemCategory ].
	aChar = $A ifTrue: [ ^ model alphabetizeSystemCategories ].
	aChar = $b ifTrue: [ ^ self openSystemCategoryBrowser ].
	aChar = $B ifTrue: [ ^ self browseAllClasses ].
	aChar = $o ifTrue: [ ^ model fileOutSystemCategory ].
	aChar = $u ifTrue: [ ^ model updateSystemCategories ].
	aChar = $R ifTrue: [ ^ model renameSystemCategory ].
	
	^ self classListKey: aChar from: view! !
!BrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:25' prior: 16797342 overrides: 50360137!
                            messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel |
	sel _ model selectedMessageName.
	sel
		ifNotNil: [
			"The following require a method selection"
			aChar = $R ifTrue: [^ self renameSelector].
			aChar = $U ifTrue: [^ self addParameter ].
			aChar = $I ifTrue: [^ self removeParameter ]].
	super messageListKey: aChar from: view! !
!BrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:29' prior: 16797361 overrides: 50360186!
                          systemCatListKey: aChar from: view

	aChar = $r ifTrue: [^ model recent ].
	
	^super systemCatListKey: aChar from: view! !
!CodeFileBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:34' prior: 16818634 overrides: 50360100!
        classListKey: aChar from: view
	aChar = $b ifTrue: [^ self browseMethodFull].
	aChar = $N ifTrue: [^ self browseClassRefs].
	self codeFileListKey: aChar from: view! !
!CodeFileBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:37' prior: 16818642!
                codeFileListKey: aChar from: view

	aChar = $f ifTrue: [^ self findClass]! !
!CodeFileBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:40' prior: 16818648 overrides: 50360215!
                      messageListKey: aChar from: view
	aChar = $b ifTrue: [^ self browseMethodFull].
	super messageListKey: aChar from: view! !
!HierarchyBrowserWindow class methodsFor: 'examples' stamp: 'jmv 5/21/2022 22:33:45' prior: 16868155!
                               example2
	"Put up a ClassListBrowser that shows all classes whose names start with the letter S"

	self forClassesNamed: (Smalltalk allClasses collect: [:c | c name] thenSelect: [:aName | aName first = $S]) title: 'All classes starting with S'

"HierarchyBrowserWindow example2"! !
!MessageNamesWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:51' prior: 16884118!
selectorListKey: aChar from: view
	"Respond to a Command key in the message-list pane."
	aChar = $n ifTrue: [ ^ self browseSenders ].
	aChar = $b ifTrue: [ ^ self browseMethodFull ].
	aChar = $m ifTrue: [ ^ self browseImplementors ].! !
!ProtocolBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:33:58' prior: 16920713!
          protocolClassListKey: aChar from: view 
	"Respond to a Command key.  I am a model with a list of 
	classes and a list of methods.  The 
	view knows how to get the list and selection."

	aChar = $b ifTrue: [^ self browseMethodFull ].
	aChar = $h ifTrue: [^ self browseHierarchy].
	
	^ nil! !
!ChangeListWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:02' prior: 16803039!
                         changeListKey: aChar from: view
	"Respond to a Command key in the list pane."

	aChar = $D ifTrue: [^ model toggleDiffing].
	aChar = $a ifTrue: [^ model selectAll]! !
!VersionsBrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:07' prior: 16978720 overrides: 50360303!
                            changeListKey: aChar from: view
	"Respond to a Command key in the list pane. of the versions browser"

	aChar = $z ifTrue: [^ model fileInSelections].
	^ self messageListKey: aChar from: view! !
!ChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:18' prior: 16807946!
                       changeSetListKey: aChar from: view
	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."

	aChar = $D ifTrue: [^ model toggleDiffing]. 
	aChar = $o ifTrue: [^ model fileOutAndRemove].
	aChar = $k ifTrue: [^ model fileOutAndKeep].
	aChar = $r ifTrue: [^ model rename].
	aChar = $x ifTrue: [^ model remove].

	^ self messageListKey: aChar from: view! !
!ChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:24' prior: 16807961 overrides: 50360100!
   classListKey: aChar from: view
	"Respond to a Command key in the class-list pane."

	aChar = $x ifTrue: [^ model removeClass].
	aChar = $d ifTrue: [^ model forgetClass]. 

	^ self messageListKey: aChar from: view "picks up b,h,p"! !
!ChangeSorterWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:28' prior: 16807971 overrides: 50360137!
                             messageListKey: aChar from: view
	"Respond to a Command key in the message-list pane."

	aChar = $d ifTrue: [^ model forget].
	super messageListKey: aChar from: view! !
!DebuggerWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:37' prior: 16839894!
                     contextStackKey: aChar from: view
	"Respond to a keystroke in the context list"

	aChar = $e ifTrue: [^ self send].
	aChar = $t ifTrue: [^ self doStep].
	aChar = $T ifTrue: [^ self stepIntoBlock].
	aChar = $p ifTrue: [^ self proceed].
	aChar = $r ifTrue: [^ self restart].
	aChar = $f ifTrue: [^ self fullStack].
	aChar = $w ifTrue: [^ self where].

	^ self messageListKey: aChar from: view! !
!DebuggerWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:47' prior: 16839925!
                    inspectorKey: aChar from: view
	"Respond to a Command key issued while the cursor is over my field list"

	aChar = $i ifTrue: [^ self inspectSelectionIn: view model ].
	aChar = $I ifTrue: [^ self exploreSelectionIn: view model ].
	aChar = $b ifTrue:[^ self browseMethodFullIn: view model ].
	aChar = $h ifTrue:[^ self browseHierarchyIn: view model].
	aChar = $p ifTrue: [^ self browseFullProtocolIn: view model].
	aChar = $N ifTrue: [^ self browseClassRefsIn: view model]! !
!FileListWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:34:54' prior: 16856187!
   fileListKey: aChar from: aView

	aChar = $x ifTrue: [ ^ aView model deleteFile ].
	aChar = $R ifTrue: [ ^ aView model renameFile ].
	aChar = $n ifTrue: [ ^ aView model addNewFile ].
	aChar = $N ifTrue: [ ^ aView model addNewDirectory ].! !
!InspectorWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:35:03' prior: 16872581!
             inspectorKey: aChar from: view
	"Respond to a Command key issued while the cursor is over my field list"

	aChar = $i ifTrue: [^ self inspectSelection].
	aChar = $I ifTrue: [^ self exploreSelection].
	aChar = $b ifTrue:[^ self browseMethodFull].
	aChar = $h ifTrue:[^ self browseHierarchy].
	aChar = $p ifTrue: [^ self browseFullProtocol].
	aChar = $N ifTrue: [^ self browseClassRefs]! !
!ObjectExplorerWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 5/21/2022 22:35:17' prior: 16904508!
                    explorerKey: aChar from: view

	model getCurrentSelection ifNotNil: [

		aChar = $i ifTrue: [^ self inspectSelection].
		aChar = $I ifTrue: [^ self exploreSelection].

		aChar = $b ifTrue: [^ self browseMethodFull].
		aChar = $h ifTrue: [^ self browseHierarchy].
		aChar = $p ifTrue: [^ self browseFullProtocol].
		aChar = $N ifTrue: [^ self browseClassRefs]]! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 5/21/2022 22:35:22' prior: 16782514!
                    shouldOpenMorphWhenPrefixAt: currentPos and: currentChar 
	
	^ model textSize >= currentPos and: [ currentChar isAlphaNumeric or: [ currentChar = $: ]] 


	! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:49:54' prior: 50349789!
              scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := String with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c = $:]) ifFalse: [^currentToken].
	(c = $: and: [d = $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (String with: d).
			self nextChar.
			^currentToken].
	"|| empty temp declaration"
	"This makes || colorize as an invalid method definition.
	It is better to allow #|| as valid selector, and mark an empty temp declaration as invalid instead!!"
	"(c = $| and: [d = $|])
		ifTrue: [^currentToken]."
	c _ d.
	[
		d _ self peekChar.
		c = $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken _ currentToken copyWith: c.
			c _ self nextChar ].
	^currentToken! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:35' prior: 16928962!
              scanComment
	| c s e |
	s := sourcePosition.
	
	[sourcePosition := sourcePosition + 1.
	(c := self currentChar) 
		ifNil: [
			self rangeType: #unfinishedComment start: s end: source size.
			^self error	": 'unfinished comment'"].
	c = $"] 
		whileFalse: [].
	e := sourcePosition.
	s < e ifTrue: [self rangeType: #comment start: s end: e].
	self nextChar.
	self scanWhitespace! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:41' prior: 16928976!
                  scanIdentifier
	| c start |
	start _ sourcePosition.
	[ (c _ self nextChar) isValidInIdentifiers ] whileTrue: [].
	(c = $: and: [(self isBinarySelectorCharacter: self peekChar) not]) 
		ifTrue: [self nextChar].
	currentToken _ source copyFrom: start to: sourcePosition - 1.
	currentTokenSourcePosition _ start! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:39:36' prior: 16929002!
                     scanNumber
	| start c nc base |
	start := sourcePosition.
	self skipDigits.
	c := self currentChar.
	('rx' includes: c)
		ifTrue: [
			base := Integer readFrom: (ReadStream on: (source copyFrom: start to: sourcePosition - 1)).
			self peekChar = $- ifTrue: [self nextChar].
			self skipBigDigits: base.
			c := self currentChar.
			c = $. 
				ifTrue: [
					(self isBigDigit: self nextChar base: base) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipBigDigits: base]].
			c := self currentChar.
			('deqp'includes: c)
				ifTrue: [
					((nc := self nextChar) isDigit or: [nc = $- and:[self peekChar isDigit]]) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			c = $s 
				ifTrue: [
					self nextChar isDigit 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c = $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits.].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c = $. 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [
					sourcePosition := sourcePosition - 1.
					currentToken := source copyFrom: start to: sourcePosition - 1.
					^currentTokenSourcePosition := start]
				ifTrue: [self skipDigits]].
	c := self currentChar.
	('deqp' includes: c)
		ifTrue: [
			((nc := self nextChar) isDigit or: [nc = $-  and:[self peekChar isDigit]]) 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	c = $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	currentToken := source copyFrom: start to: sourcePosition - 1.
	^currentTokenSourcePosition := start! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:45' prior: 16929106!
         scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c = $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'token testing' stamp: 'jmv 5/21/2022 22:35:28' prior: 16929182!
                        isBinary
	| c |
	(currentToken isNil or: [self isName or: [self isKeyword]]) 
		ifTrue: [^false].
	"Special case: '::' is not a binary selector but the Chain operator"
	(sourcePosition - currentTokenSourcePosition = 1 and: [
		(source at: currentTokenSourcePosition ifAbsent: nil) = $: and: [		
			(source at: sourcePosition ifAbsent: nil) = $: ]])
				ifTrue: [^ false ].
	1 to: currentToken size do: [ :i |
		c := currentToken at: i.
		((self isBinarySelectorCharacter: c) or: [c = $:])
			ifFalse: [^false]].
	^true! !
!SHParserST80 methodsFor: 'token testing' stamp: 'jmv 5/21/2022 22:35:32' prior: 16929201!
                           isKeyword
	^ currentTokenFirst isValidStartOfIdentifiers and: [ currentToken last = $: ]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:36' prior: 16929575!
                 parseArray
	[currentTokenFirst = $)] whileFalse: [self parseLiteralArrayElement].
	self scanPast: #arrayEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:41' prior: 16929581!
                              parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst = $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst = $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:49' prior: 16929614!
 parseBlock

	"Just read $["
	blockDepths add: blockDepth+1.
	blockDepthsStartIndexes add: sourcePosition-1.

	self enterBlock.
	self scanPast: #blockStart level: bracketDepth.
	currentTokenFirst = $: ifTrue: [self parseBlockArguments].
	currentTokenFirst = $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst = $].

	"Just read $]"
	blockDepths add: blockDepth-1.
	blockDepthsStartIndexes add: sourcePosition.

	self scanPast: #blockEnd level: bracketDepth.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:55' prior: 16929633!
                            parseBlockArguments
	[ currentTokenFirst = $: ]
		whileTrue: [
			self scanPast: #blockArgColon.
			self failUnless: self isName.
			self scanPast: #blockPatternArg ].
	currentTokenFirst = $| 
		ifTrue: [ self scanPast: #blockArgsBar ]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:59' prior: 16929643!
                              parseBlockTemporaries
	currentTokenFirst = $| 
		ifTrue: [
			self scanPast: #blockTempBar.
			[self isName] 
				whileTrue: [self scanPast: #blockPatternTempVar].
			self failUnless: currentToken = '|'.
			self scanPast: #blockTempBar]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:05' prior: 16929653!
                             parseBraceArray
	self parseStatementListForBraceArray.
	self failUnless: currentTokenFirst = $}.
	self scanPast: #rightBrace level: braceDepth.
	braceDepth := braceDepth - 1! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:12' prior: 16929661!
                            parseByteArray
	"Literal ByteArray or literal FloatArray"
	[currentTokenFirst = $]] whileFalse: [
		currentTokenFirst isDigit | (currentTokenFirst = $-)
			ifTrue: [
				"do not parse the number, can be time consuming"
				self scanPast: #number]
			ifFalse: [
				self failWhen: currentTokenFirst = $. .
				self error]].
	self scanPast: #arrayEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:15' prior: 16929675!
             parseCascadeAndChain

	self parseKeyword.
	currentTokenFirst = $; ifTrue:
		[
			self scanPast: #cascadeSeparator.
			^self parseCascadeAndChain
		].
	currentTokenFirst = $: ifTrue:
		[
			self scanPast: #chainSeparator.

			"These lines implement double colon chains"
			currentTokenFirst = $: ifFalse: [^self].
			self scanPast: #chainSeparator.
			
			^self parseCascadeAndChain
		]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:25' prior: 16929713!
        parseExternalCall
	self scanNext.
	self failWhen: currentToken isNil.
	self scanPast: #externalCallType.
	currentToken = '*' 
		ifTrue: [self scanPast: #externalCallTypePointerIndicator].
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: 	[
			self failUnless: currentTokenFirst = $'.
			self parseString].
	self failUnless: currentTokenFirst = $(.
	self scanPast: #leftParenthesis.
	[currentTokenFirst ~= $)] 
		whileTrue: [
			self failWhen: currentToken isNil.
			self scanPast: #externalCallType.
			currentToken = '*' 
				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].
	self scanPast: #rightParenthesis.
	currentToken = 'module:' 
		ifTrue: [
			self scanPast: #module.
			self failUnless: currentTokenFirst = $'.
			self parseString].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:44:55' prior: 16929780!
           parseLiteral: inArray 
	currentTokenFirst = $$ 
		ifTrue: [
			| pos |
			self failWhen: self currentChar isNil.
			self rangeType: #'$'.
			pos := currentTokenSourcePosition + 1.
			self nextChar.
			self scanPast: #character start: pos end: pos.
			^self ].
	currentTokenFirst isDigit 
		ifTrue: [
			"do not parse the number, can be time consuming"
			self scanPast: #number.
			^self ].
	currentToken = '-' 
		ifTrue: [
			| c |
			c := self currentChar.
			(inArray and: [c isNil or: [c isDigit not]]) 
				ifTrue: [
					"single - can be a symbol in an Array"
					self scanPast: #symbol.
					^self ].
			self scanPast: #-.
			self failWhen: currentToken isNil.
			"token isNil ifTrue: [self error: 'Unexpected End Of Input']."
			"do not parse the number, can be time consuming"
			self scanPast: #number.
			^self ].
	currentTokenFirst = $' ifTrue: [
		self parseString.
		^self ].
	currentTokenFirst = $# ifTrue: [
		self parseSymbol.
		^self ].
	(inArray and: [currentToken notNil]) ifTrue: [
		self scanPast: #symbol.
		^self ].
	self failWhen: currentTokenFirst = $. .
	self error	": 'argument missing'"! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:39' prior: 16929818!
             parseLiteralArrayElement
	 currentTokenFirst isValidStartOfIdentifiers ifTrue: [
		#true = currentToken ifTrue: [
			self scanPast: #true.
			^ self ].
		#false = currentToken ifTrue: [
			self scanPast: #false.
			^ self ].
		#nil = currentToken ifTrue: [
			self scanPast: #nil.
			^ self ].
		self scanPast: #symbol.
		^ self ].
	currentTokenFirst = $( ifTrue: [
		self scanPast: #arrayStart.
		self parseArray.
		^ self ].
	self parseLiteral: true! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:42' prior: 16929845!
      parseMethodTemporaries
	currentTokenFirst = $| 
		ifTrue: [
			self scanPast: #methodTempBar.
			[self isName] 
				whileTrue: [self scanPast: #patternTempVar].
			self failUnless: currentToken = '|'.
			self scanPast: #methodTempBar]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:49' prior: 16929907!
                               parsePrimitive
	self scanNext.
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: [
			self failUnless: currentTokenFirst = $'.
			self parseString.
			currentToken = 'module:' 
				ifTrue: [
					self scanPast: #module.
					self failUnless: currentTokenFirst = $'.
					self parseString]].
	currentToken = 'error:' ifTrue: [
		self scanPast: #primitive. "there's no rangeType for error"
		self isName
			ifTrue: [ self scanPast: #patternTempVar ]
			ifFalse: [ self parseStringOrSymbol ] ].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:54' prior: 16929928!
                   parseStatement
	currentTokenFirst = $^ ifTrue: [self scanPast: #return].
	self parseExpression! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:00' prior: 16929934!
           parseStatementList
	
	[[currentTokenFirst = $.] whileTrue: [self scanPast: #statementSeparator].
	(currentToken notNil and: [currentTokenFirst ~= $]]) 
		ifTrue: [self parseStatement].
	currentTokenFirst = $.] 
			whileTrue: [self scanPast: #statementSeparator]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:03' prior: 16929945!
    parseStatementListForBraceArray
	"same as parseStatementList, but does not allow empty statements e.g {...$a...}.
	A single terminating . IS allowed e.g. {$a.} "

	
	[currentTokenFirst ~= $} ifTrue: [self parseStatement].
	currentTokenFirst = $.] 
		whileTrue: [self scanPast: #statementSeparator]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:09' prior: 16929957!
parseString
	| first c last |
	first _ sourcePosition.
	[
		(c _ self currentChar) ifNil: [
			self
				rangeType: #unfinishedString
				start: first - 1
				end: source size.
			self error": 'unfinished string'" ].
		c ~= $' or: [
			self peekChar = $' and: [
				sourcePosition _ sourcePosition + 1.
				true ]]] whileTrue: [ sourcePosition _ sourcePosition + 1 ].
	last _ sourcePosition.
	self nextChar.
	self
		scanPast: #string
		start: first - 1
		end: last! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:15' prior: 16929974!
                          parseStringOrSymbol

	currentTokenFirst = $' ifTrue: [ ^self parseString ].
	currentTokenFirst = $# ifTrue: [ ^self parseSymbol ].
	self error! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:45:04' prior: 16929981!
                           parseSymbol
	| c |
	currentToken = '#' 
		ifTrue: [
			"if token is just the #, then scan whitespace and comments
			and then process the next character.
			Allows space between the # and the start of the symbol 
			e.g. # (),  #  a, #  'sym' "
			self rangeType: #symbol.
			self scanWhitespace].
	c _ self currentChar.
	self failWhen: (c isNil or: [c isSeparator]).
	c = $( 
		ifTrue: [
			self nextChar.
			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.
			^self parseArray].
	c = $' ifTrue: [
		self parseSymbolString.
		^self ].
	c = $[ ifTrue: [
			self nextChar.
			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.
			^self parseByteArray].
	(self isBinarySelectorCharacter: c) ifTrue: [
		self parseSymbolSelector.
		^self ].
	( c isValidStartOfIdentifiers or: [c = $:]) ifTrue: [
		self parseSymbolIdentifier.
		^self].
	self parseCharSymbol! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:29' prior: 16930013!
                   parseSymbolIdentifier
	| c start end |
	c _ self currentChar.
	self failUnless: ( c isValidStartOfIdentifiers or: [ c = $: ]).
	start _ sourcePosition.
	[
		c _ self nextChar.
		c isValidInIdentifiers or: [ c = $: ]
	] whileTrue: [].
	end _ sourcePosition - 1.
	self scanPast: #symbol start: start - 1 end: end! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:34' prior: 16930035!
                   parseSymbolString
	| first c last |
	first := sourcePosition.
	self nextChar.
	[
		(c := self currentChar) 
			ifNil: [
				self rangeType: #unfinishedString start: first end: source size.
				self error	": 'unfinished string'"].
		c ~= $' or: [
			self peekChar = $' 
				ifTrue: [sourcePosition := sourcePosition + 1. true] 
				ifFalse: [false]]
	] whileTrue: [sourcePosition := sourcePosition + 1].
	last := sourcePosition.
	self nextChar.
	self scanPast: #stringSymbol start: first - 1 end: last! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:45:14' prior: 16930053!
                     parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst = $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst = $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst = $[ ifTrue: [^self parseBlock].
	currentTokenFirst = $` ifTrue: [^self parseBacktick].
	currentTokenFirst = ${ 
		ifTrue: [
			braceDepth := braceDepth + 1.
			self scanPast: #leftBrace level: braceDepth.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5185-CharacterEqEqConsideredHarmful-JuanVuletich-2022May23-09h20m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5183] on 23 May 2022 at 9:54:03 am'!
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/23/2022 09:49:47'!
                             iso8859s15Code
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding.
	Any implementation of Character like object beyond ISO-8859-15 should answer nil.
	Senders, please consider that this method might answer nil.
	See #iso8859s15CodeForUnicodeCodePoint:"

	value < 128 ifTrue: [ ^value ]."Plain ASCII"
	self asCharacter ifNotNil: [ :ch | ^ch iso8859s15Code ].
	^nil! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 5/23/2022 09:49:32'!
  asCharacter
	"Might answer nil"
	^Character codePoint: value! !
!CharacterSet methodsFor: 'collection ops' stamp: 'jmv 5/23/2022 09:53:24' prior: 16809934 overrides: 16823908!
                includes: aCharacter
	aCharacter isCharacterLike ifFalse: [ ^ false ].
	^aCharacter iso8859s15Code ifNotNil: [ :index | (map at: index + 1) > 0 ].! !
!String methodsFor: 'accessing' stamp: 'jmv 5/23/2022 09:52:13' prior: 16947110 overrides: 16901525!
     at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacterLike
		ifTrue: [	
			(aCharacter is: #Character)
				ifFalse: [
					aCharacter asCharacter
						ifNotNil: [ :ch | ^self at: index put: ch ]
						ifNil: [self error: 'String only store code points in the ISO 8859-15 set']]
				ifTrue: [
					index isInteger
						ifTrue: [self errorSubscriptBounds: index]
						ifFalse: [self errorNonIntegerIndex]]]
		ifFalse: [self error: 'Strings only store Characters']! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/23/2022 09:49:40' prior: 50350874!
                     isLetter
	"Answer whether the receiver is a letter."
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isLetter ].
	^false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5186-UnicodeCodePoint-Character-compatibility-JuanVuletich-2022May23-09h40m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5183] on 23 May 2022 at 10:03:01 am'!
!String methodsFor: 'accessing' stamp: 'jmv 5/23/2022 09:56:48' prior: 16947138!
                        findAnySubStr: delimiters startingAt: start 
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min ind |
	min _ self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		delim isCharacterLike
			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [ind _ self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
			min _ min min: ind].
	^ min! !
!String methodsFor: 'accessing' stamp: 'jmv 5/23/2022 09:57:00' prior: 16947250!
                      findTokens: delimiters
	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."

	| tokens keyStart keyStop separators |

	tokens _ OrderedCollection new.
	separators _ delimiters isCharacterLike
		ifTrue: [Array with: delimiters]
		ifFalse: [delimiters].
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: separators startingAt: keyStop.
		keyStop _ self findDelimiters: separators startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!String methodsFor: 'accessing' stamp: 'jmv 5/23/2022 09:57:34' prior: 16947319 overrides: 16933668!
                          indexOf: aCharacter

	aCharacter isCharacterLike ifFalse: [^ 0].
	^ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: 1.! !
!String methodsFor: 'accessing' stamp: 'jmv 5/23/2022 09:57:56' prior: 16947326 overrides: 16933688!
        indexOf: aCharacter  startingAt: start

	aCharacter isCharacterLike ifFalse: [^ 0].
	^ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: start.! !
!String methodsFor: 'accessing' stamp: 'jmv 5/23/2022 09:58:17' prior: 16947334 overrides: 16933699!
                 indexOf: aCharacter  startingAt: start  ifAbsent: aBlock
	| ans |
	aCharacter isCharacterLike ifFalse: [ ^ aBlock value ].
	ans _ String indexOfByte: aCharacter iso8859s15Code inString: self  startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!String methodsFor: 'accessing' stamp: 'jmv 5/23/2022 09:59:24' prior: 16947450!
 skipAnySubStr: delimiters startingAt: start 
	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."
	| any this ind ii |
	ii _ start-1.
	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"
		any _ false.
		delimiters do: [ :delim |
			delim isCharacterLike
				ifTrue: [ (self at: ii) = delim ifTrue: [any _ true]]
				ifFalse: ["a substring"
					delim size > (self size - ii + 1) ifFalse: [ "Here's where the one-off error was."
						ind _ 0.
						this _ true.
						delim do: [ :dd | 
							dd = (self at: ii+ind) ifFalse: [this _ false].
							ind _ ind + 1].
						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]
							ifTrue: [any _ false] "if the delim is too big, it can't match"]].
		any ifFalse: [^ ii]].
	^ self size + 1! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5187-UnicodeCodePoint-Character-compatibility-JuanVuletich-2022May23-09h54m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5187] on 23 May 2022 at 10:26:49 am'!
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 5/23/2022 10:18:26'!
                         asciiValue
	"Answer the value of the receiver that represents its ANSI encoding.
	This is the same as the Unicode CodePoint for the first 128 characters.
	Answer nil if out of range."

	^ value < 128 ifTrue: [ value ].! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 5/23/2022 10:06:19' prior: 50340816!
      printOn: aStream withLeadingSpace: printLeadingSpaceToo includeOffset: aBoolean
	"Print as per ISO 8601 section 5.4.2
	If printLeadingSpaceToo is false, prints either:
		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	If printLeadingSpaceToo is true, prints either:
		' YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	"

	self printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo.
	aStream nextPut: $T.
	self printHMSOn: aStream.
	self nanoSecond ~= 0 ifTrue:
		[ | z ps |
		ps := self nanoSecond printString padded: #left to: 9 with: $0.
		z := ps findLast: [ :c | c codePoint > `$0 codePoint` ].
		(z > 0) ifTrue: [aStream nextPut: $.].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].
	aBoolean ifTrue: [
		aStream
			nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);
			nextPutAll: (offset hours abs printString padded: #left to: 2 with: $0);
			nextPut: $:;
			nextPutAll: (offset minutes abs printString padded: #left to: 2 with: $0).
		"Note: We should check the ISO to see if the seconds part is supported by the standard
		(usually not an issue. offsets usually don't include seconds)"
		offset seconds = 0 ifFalse: [
			aStream
				nextPut: $:;
				nextPutAll: (offset seconds abs truncated printString) ]]! !
!Character methodsFor: 'accessing' stamp: 'jmv 5/23/2022 10:17:45' prior: 16808048!
                           asciiValue
	"Answer the value of the receiver that represents its ANSI encoding.
	This is the same as ISO 8859-15 for the first 128 characters.
	Answer nil if out of range."

	| n |
	n _ self numericValue.
	^ n < 128 ifTrue: [ n ].! !
!CharacterSet methodsFor: 'collection ops' stamp: 'jmv 5/23/2022 10:11:27' prior: 16809921 overrides: 16822843!
     add: aCharacter
	map at: aCharacter iso8859s15Code+1  put: 1.! !
!CharacterSet methodsFor: 'collection ops' stamp: 'jmv 5/23/2022 10:11:42' prior: 16809941 overrides: 16823710!
               remove: aCharacter
	map at: aCharacter iso8859s15Code + 1  put: 0! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/23/2022 10:15:05' prior: 50350897!
  isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ `$_ numericValue` = value ]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/23/2022 10:15:10' prior: 50350905!
     isValidStartOfIdentifiers
	"Can I be the first character of an identifier? (unary or keyword selector, or variable name)"

	^self isLetter or: [ `$_ numericValue` = value ]! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 5/23/2022 10:09:12' prior: 50358931 overrides: 16901788!
 hash
	"Hash is reimplemented because = is implemented."

	self iso8859s15Code ifNotNil: [ :sameNumericValueAsCharacter | ^sameNumericValueAsCharacter hash ].
	^value hash! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5188-UnicodeCodePoint-Character-compatibility-JuanVuletich-2022May23-10h23m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5188] on 23 May 2022 at 11:25:43 am'!
!MorphicCanvas methodsFor: 'initialization' stamp: 'jmv 5/23/2022 10:45:27'!
       ensureCurrentMorphIsWorld
	"just in case there were some breakage due to a walkback"
	currentMorph == world ifFalse: [
		self resetCanvas.
		self into: world ]! !
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 5/23/2022 11:18:24' prior: 50356400!
     doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(PreferenceNG at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	canvas ensureCurrentMorphIsWorld.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5189-robustCanvasState-JuanVuletich-2022May23-11h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5189] on 25 May 2022 at 9:11:24 am'!
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 5/25/2022 09:11:08' prior: 16982616!
                               doOneCycleNow
	"Immediately do one cycle of the interaction loop.
	Only used for a few tests."
	"See #eventTickler"
	| hadAny |
	Cursor currentCursor = (Cursor cursorAt: #waitCursor) ifTrue: [ Cursor defaultCursor activateCursor ].
	"Repair visual damage."
	self checkForNewScreenSize.
	self displayWorldSafely.
	"Run steps, alarms and deferred UI messages"
	self runStepMethods.
	"Process user input events. Run all event triggered code."
	hadAny _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAny _ hadAny | h processEventQueue ].
	"The default is the primary hand"
	activeHand _ self hands first.
	^ hadAny.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5190-WorldMorph-fix-JuanVuletich-2022May25-09h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5189] on 25 May 2022 at 4:04:33 pm'!
!Random methodsFor: 'accessing' stamp: 'len 5/25/2022 15:55:44' prior: 16922287!
                               nextBits: anInteger
	"Answer a random integer in the interval [0, 2^anInteger - 1]"

	| remainder answer |
	anInteger negative ifTrue: [self error: 'invalid interval'].
	remainder _ anInteger \\ self nextChunkSize.
	answer _ remainder > 0
		ifTrue: [self nextChunkBits bitShift: remainder - self nextChunkSize]
		ifFalse: [0].
	anInteger // self nextChunkSize timesRepeat:
		[answer _ answer bitShift: self nextChunkSize :: bitXor: self nextChunkBits].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5191-Random-Fix-LucianoEstebanNotarfrancesco-2022May25-16h04m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5191] on 25 May 2022 at 11:10:11 pm'!
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 5/25/2022 23:10:03' prior: 50359126!
                         getPreamble
	| file preamble |
	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"
	file _ SourceFiles at: self fileIndex.
	file ifNil: [^ ''].  "sources file not available"
	"file does not exist happens in secure mode"
	[
		file name asFileEntry readStreamDo: [ :stream | | p |
			preamble _ ''.
			p _ 0 max: self filePosition.
			p < stream size ifTrue: [
				"It appears that on Linux systems, immediately after adding a new method, the OS file cache may not be updated, so contents may still not be accessible. Protect against that."
				stream position: p.
				"Skip back blank space."
				stream backChunk.
				"Find and answer preamble chunk."
				preamble _ stream backChunk ]]
	] on: FileDoesNotExistException do: [ :ex | preamble _ '' ].
	^ preamble! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5192-getPreamble-comment-JuanVuletich-2022May25-23h10m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5183] on 22 May 2022 at 7:17:34 pm'!
!ReadStream commentStamp: '<historical>' prior: 16922429!
     I represent an accessor for a sequence of objects that can only read objects from the sequence.
Instances are created on: aCollection. Its elements will be iterated by us.!
!WriteStream commentStamp: '<historical>' prior: 16982966!
                        I represent an accessor for a sequence of objects that can only store objects in the sequence.
Instances are created on: aCollection, which is considered to be empty or filled with nil. Any contents will be ovewriten.
Instances can also be create with: aCollection. In this case, new contents will be added after this initial stuff.!
!ReadWriteStream commentStamp: '<historical>' prior: 16922562!
                   I represent an accessor for a sequence of objects. My instances can both read and store objects.
Instances are created on: aCollection, which is considered to be empty or filled with nil. Any contents will be ovewriten, and are not available for reading.
Instances can also be create with: aCollection. In this case, new contents will be added after this initial stuff. Reading them is only possible if position: is set appropriately (for instance aReadWriteStream position: 1).!
!ReadWriteStream class methodsFor: 'instance creation' stamp: 'jmv 5/22/2022 19:17:17'!
        readingOn: aCollection
	"Answer an instance that can be used like a ReadStream, i.e. it is born ready to read over aCollection."

	| instance |
	instance _ self with: aCollection.
	instance position: 0.
	^instance! !
!PositionableStream methodsFor: 'private' stamp: 'jmv 5/22/2022 18:43:45' prior: 16914565!
            on: aCollection
	"Initialize the stream to read over all of aCollection.
	The collection is considered to have useful content."

	collection _ aCollection.
	readLimit _ aCollection size.
	position _ 0.
	self reset.! !
!WriteStream methodsFor: 'private' stamp: 'jmv 5/22/2022 19:15:47' prior: 16983259 overrides: 50361502!
                              on: aCollection
	"Initialize the stream to write over all of aCollection.
	The collection contents are considered useless (most likely nil).
	Overwrite them.
	In the case of ReadWriteStream, for read operations, stream appears empty until stuff is added."

	super on: aCollection.
	readLimit _ 0.
	writeLimit _ aCollection size! !
!WriteStream methodsFor: 'private' stamp: 'jmv 5/22/2022 19:17:09' prior: 16983285!
 with: aCollection
	"Initialize the stream to append after existing elements in aCollection.
	In the case of ReadWriteStream, for read operations, the stream appears empty
	until stuff is added, or position is set to before end. See #readingOn:"

	super on: aCollection.
	position _ readLimit _ writeLimit _ aCollection size! !
!WriteStream class methodsFor: 'instance creation' stamp: 'jmv 5/22/2022 19:16:56' prior: 16983344!
                     with: aCollection 
	"Answer an instance of me on the argument, aCollection, positioned to 
	store objects at the end of aCollection.
	In the case of ReadWriteStream, for read operations, the stream appears empty
	until stuff is added, or position is set to before end. See #readingOn:"

	^self basicNew with: aCollection! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5193-StreamComments-JuanVuletich-2022May22-18h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5190] on 23 May 2022 at 12:01:42 pm'!
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 5/21/2022 22:44:31'!
          browseEqEqSentToCharacterConstants
	"
	Smalltalk browseEqEqSentToCharacterConstants
	"
	| hasMatch visitor |
	hasMatch _ false.
	visitor _ ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isConstantCharacter or: [ node arguments first isConstantCharacter ]]]) ifTrue: [
						hasMatch _ true ]]
		select: [ :node |
			hasMatch not ].
	Smalltalk browseAllSelect: [ :method |
		hasMatch _ false.
		method decompile accept: visitor.
		hasMatch ].! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 5/21/2022 22:44:16'!
                         isConstantCharacter  "Overridden in LiteralNode"
	^false! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 5/21/2022 22:44:10' overrides: 50361580!
            isConstantCharacter
	^ key isCharacterLike! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5194-browseEqEqSentToCharacterConstants-JuanVuletich-2022May23-12h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5194] on 26 May 2022 at 9:18:01 am'!
!Object class methodsFor: 'instance creation' stamp: 'jmv 5/22/2022 20:36:48' prior: 16903961!
                            readFrom: aStream
	"Create an object based on the contents of aStream."

	| object ok |
	ok _ (aStream is: #Stream) or: [ aStream isStringLike ].
	(ok or: [ aStream is: #Text ]) ifFalse: [ ^ self error: 'expected String or Text' ].
	object _ Compiler evaluate: aStream.
	(object isKindOf: self) ifFalse: [ self error: self name, ' expected' ].
	^ object! !
!Number class methodsFor: 'instance creation' stamp: 'jmv 5/22/2022 20:20:38' prior: 16901356 overrides: 50361598!
        readFrom: stringOrStream 
	"Answer a number as described on aStream.  The number may
	include a leading radix specification, as in 16rFADE"
	| value base aStream sign |
	aStream _ stringOrStream isStringLike
		ifTrue: [stringOrStream readStream]
		ifFalse: [stringOrStream].
	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].
	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [aStream peekFor: $+. 1].
	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].
	base _ 10.
	aStream peek = $.
		ifTrue: [ value _ 0 ]
		ifFalse: [
			value _ Integer readFrom: aStream base: base.
			(aStream peekFor: $r)
				ifTrue: [
					"<base>r<integer>"
					(base _ value) < 2 ifTrue: [
						base = 1 ifTrue: [ ^Integer readBaseOneFrom: aStream ].
						^self error: 'Invalid radix'].
					(aStream peekFor: $-) ifTrue: [sign _ sign negated].
					value _ Integer readFrom: aStream base: base].
			(aStream peekFor: $x)
				ifTrue: [
					"0x<integer>" "Hexadecimal"
					base _ 16.
					(aStream peekFor: $-) ifTrue: [sign _ sign negated].
					value _ Integer readFrom: aStream base: base]].
	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !
!CodeFile methodsFor: 'private' stamp: 'jmv 5/23/2022 13:30:51' prior: 16817667!
                        msgClassComment: string with: chgRec
	| tokens theClass |
	tokens := Scanner new scanTokens: string.
	(tokens size = 3 and:[(tokens at: 3) isStringLike ]) ifTrue:[
		theClass := self getClass: tokens first.
		^theClass classComment: tokens last].
	(tokens size = 4 and:[(tokens at: 3) asString = 'class' and:[(tokens at: 4) isStringLike]]) ifTrue:[
		theClass := self getClass: tokens first.
		theClass theMetaClass classComment: tokens last].
! !
!CodeFile methodsFor: 'private' stamp: 'jmv 5/23/2022 13:31:05' prior: 16817684!
               possibleSystemSource: chgRec
	| tokens |
	sourceSystem isEmpty ifTrue:[
		tokens := Scanner new scanTokens: chgRec string.
		(tokens size = 1 and:[tokens first isStringLike]) ifTrue:[
			sourceSystem := tokens first.
			^self]].
	doIts add: chgRec.! !
!CodePackageFile methodsFor: 'change record types' stamp: 'jmv 5/23/2022 13:32:06' prior: 16819779!
possibleDescription: chgRec
	| tokens prefix token |
	description isEmpty ifTrue:[
		tokens _ Scanner new scanTokens: chgRec string.
		(tokens size = 1 and: [ (token _ tokens first) isStringLike]) ifTrue: [
			prefix _ 'Description '.
			(token beginsWith: prefix) ifTrue: [
				description _ token copyFrom: prefix size + 1 to: token size.
				^self ]]].
	doIts add: chgRec.! !

ReadWriteStream removeSelector: #fileNameEndsWith:!

!methodRemoval: ReadWriteStream #fileNameEndsWith: stamp: 'Install-5195-isStringLike-methodDeletions-JuanVuletich-2022May26-09h06m-jmv.001.cs.st 6/16/2022 07:24:49'!
fileNameEndsWith: aString
	"See comment in FileStream fileNameEndsWith:"

	^false!

PositionableStream removeSelector: #backUpTo:!

!methodRemoval: PositionableStream #backUpTo: stamp: 'Install-5195-isStringLike-methodDeletions-JuanVuletich-2022May26-09h06m-jmv.001.cs.st 6/16/2022 07:24:49'!
backUpTo: subCollection
	"Back up the position to he subCollection.  Position must be somewhere within the stream initially.  Leave it just after it.  Return true if succeeded.  No wildcards, and case does matter."
"Example:
	| strm | strm _ ReadStream on: 'zabc abdc'.
	strm setToEnd; backUpTo: 'abc'; position 
"

	| pattern startMatch |
	pattern _ ReadStream on: subCollection reversed.
	startMatch _ nil.
	[pattern atEnd] whileFalse: 
		[self position = 0 ifTrue: [^ false].
		self skip: -1.
		(self next) = (pattern next) 
			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]
			ifFalse: [pattern position: 0.
					startMatch ifNotNil: [
						self position: startMatch-1.
						startMatch _ nil]].
		self skip: -1].
	self position: startMatch.
	^ true

!

PositionableStream removeSelector: #isCharacters!

!methodRemoval: PositionableStream #isCharacters stamp: 'Install-5195-isStringLike-methodDeletions-JuanVuletich-2022May26-09h06m-jmv.001.cs.st 6/16/2022 07:24:49'!
isCharacters
	"Return true if the receiver is a Character stream"
	^collection class == String!

PositionableStream removeSelector: #nextDelimited:!

!methodRemoval: PositionableStream #nextDelimited: stamp: 'Install-5195-isStringLike-methodDeletions-JuanVuletich-2022May26-09h06m-jmv.001.cs.st 6/16/2022 07:24:49'!
nextDelimited: terminator
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator."

	| out ch |
	out _ WriteStream on: (String new: 1000).
	self atEnd ifTrue: [^ ''].
	self next = terminator ifFalse: [self skip: -1].	"absorb initial terminator"
	[(ch _ self next) == nil] whileFalse: [
		(ch = terminator) ifTrue: [
			self peek = terminator ifTrue: [
				self next.  "skip doubled terminator"
			] ifFalse: [
				^ out contents  "terminator is not doubled; we're done!!"
			].
		].
		out nextPut: ch.
	].
	^ out contents!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5195-isStringLike-methodDeletions-JuanVuletich-2022May26-09h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5195] on 26 May 2022 at 9:40:31 am'!
!String commentStamp: 'jmv 5/23/2022 15:16:49' prior: 16947070!
  A String is an indexed collection of Characters. In Cuis, Characters are represented in the Latin-9 (ISO 8859-15) encoding. Each character takes 1 byte.

String support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.

Here are a few useful methods to look at...
	String match:
	String contractTo:

String also inherits many useful methods from its hierarchy, such as
	SequenceableCollection ,
	SequenceableCollection copyReplaceAll:with:

Cuis includes limited support for Unicode. A ByteArray can hold any Unicode string in utf-8. There is support for converting to and from instances of String. As String can not hold all Unicode code points, (just the ISO 8859-15 subset), others are converted to NCRs. See #fromUtf8Bytes:hex:trimLastNull: and #asUtf8Bytes: .!
!String methodsFor: 'converting' stamp: 'jmv 5/26/2022 09:34:43'!
                      asUtf32Words
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	See #fromUtf32Words: "

	^self asUtf32Words: true.! !
!String methodsFor: 'converting' stamp: 'jmv 5/26/2022 09:31:45'!
        asUtf32Words: convertEmbeddedNCRs
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8Bytes:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

Copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^WordArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					outStream nextPut: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					outStream nextPut: codePoint ]]]! !
!String methodsFor: 'converting' stamp: 'jmv 5/23/2022 15:17:02'!
                             asUtf8Bytes
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	See #fromUtf8Bytes: "

	^self asUtf8Bytes: true.! !
!String methodsFor: 'converting' stamp: 'jmv 5/23/2022 15:17:06'!
            asUtf8Bytes: convertEmbeddedNCRs
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8Bytes:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

Copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^ByteArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint ]]]! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 09:35:13'!
              fromUtf32Words: aWordArray
	"Convert the given bytes from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf32Words "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	^self fromUtf32Words: aWordArray hex: false trimLastNull: false! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 09:35:24'!
                         fromUtf32Words: aWordArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf32Words:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			"Add just one char if possible, or the apropriate sequence for the NCR"
			self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
		(doTrimLastNullChar and: [ aWordArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/23/2022 15:14:19'!
           fromUtf8Bytes: aByteArray
	"Convert the given bytes from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf8Bytes "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	^self fromUtf8Bytes: aByteArray hex: false trimLastNull: false! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 09:24:46'!
                             fromUtf8Bytes: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8Bytes:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					"Add just one char if possible, or the apropriate sequence for the NCR"
					self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
			byteIndex _ byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/26/2022 09:25:00'!
         asUtf32Words
	"Answer a WordArray."

	^codePoints! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/23/2022 15:09:09'!
    asUtf8Bytes
	"Answer a ByteArray."

	^String utf8FromUtf32: codePoints! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 09:32:36'!
  fromUtf32Words: words

	^self withWords: words! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/23/2022 15:14:43'!
                          fromUtf8Bytes: aByteArray

	^self withWords: (String utf32FromUtf8: aByteArray).! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/26/2022 09:25:04'!
      asUtf32Words
	"Answer a WordArray."

	^String utf32FromUtf8: bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/23/2022 15:09:13'!
                    asUtf8Bytes
	"Answer a ByteArray."

	^bytes! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 09:32:40'!
                              fromUtf32Words: aWordArray

	^self withBytes: (String utf8FromUtf32: aWordArray).! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/23/2022 15:14:46'!
                        fromUtf8Bytes: bytes

	^self withBytes: bytes! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/23/2022 15:08:26' prior: 16949860!
                addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs
	"Convert the given Unicode codePoint to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8Bytes:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	(Character codePoint: codePoint trySimilar: true)
		ifNotNil: [ :char | strm nextPut: char]
		ifNil: [
			useHexForNCRs
				ifTrue: [
					strm nextPutAll: '&#x'.
					codePoint printOn: strm base: 16 length: 4 padded: true.
					strm nextPut: $; ]
				ifFalse: [
					strm nextPutAll: '&#'.
					codePoint printOn: strm base: 10.
					strm nextPut: $; ]]! !
!StandardFileStream methodsFor: 'open/close' stamp: 'jmv 5/26/2022 09:27:13' prior: 16944415!
       open: fileName forWrite: writeMode 
	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."
	"Changed to do a GC and retry before failing ar 3/21/98 17:25"
	fileID _ StandardFileStream retryWithGC: [ self primOpen: fileName asUtf8Bytes writable: writeMode ]
					until: [ :id | id notNil ]
					forFileNamed: fileName.
	fileID ifNil: [^ nil].  "allows sender to detect failure"
	name _ fileName.
	"jmv: Register after setting name. Name is assumed to be defined for registered objects."
	self register.
	rwmode _ writeMode.
	buffer1 _ String new: 1.
	self enableReadBuffering
! !
!StandardFileStream methodsFor: 'primitives' stamp: 'jmv 5/23/2022 15:10:52' prior: 16945041!
primOpen: fileNameAsUtf8Bytes writable: writableFlag
	"Open a file of the given name, and return the file ID obtained.
	If writableFlag is true, then
		if there is none with this name, then create one
		else prepare to overwrite the existing from the beginning
	otherwise
		if the file exists, open it read-only
		else return nil"

	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>
	^ nil
! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 5/26/2022 09:27:50' prior: 16945490 overrides: 16945788!
   nextPutAll: aStringOrUTF8Bytes
	"Write the given String (possibly including NCRs) or ByteArray (with utf-8 contents)
		 StdIOWriteStream stdout nextPutAll: '--- &#16r2713; ==='; flush.
		 StdIOWriteStream stdout nextPutAll: '--- &#10003; ==='; flush.
		 StdIOWriteStream stdout nextPutAll: #[226 156 147]; flush.
		StdIOWriteStream stdout nextPutAll: 'øEl —and˙ toma ag¸ita?', String newLineString; flush.
		StdIOWriteStream stdout nextPutAll: ('øEl —and˙ toma ag¸ita?', String newLineString) asUtf8 ; flush.
	See at the end of this method for a larger example with NCRs for arbitrary Unicode
	"
	| utf8Bytes |
	utf8Bytes _ aStringOrUTF8Bytes isStringLike
		ifTrue: [ aStringOrUTF8Bytes asUtf8Bytes ]
		ifFalse: [ aStringOrUTF8Bytes ].
	self primWrite: fileID from: utf8Bytes startingAt: 1 count: utf8Bytes size.
	^aStringOrUTF8Bytes
"
StdIOWriteStream stdout nextPutAll: '
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
Ü&#948; 	Delta 	
&#917;Ñ 	Epsilon 	
&#918;Ö 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;É 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
á&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
'; flush
"! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/26/2022 09:25:23' prior: 50351056!
             copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ startIndex-1.
	epilogFirstIndex _ endIndex+1.
	^Utf32String withWords:
		(codePoints copyFrom: 1 to: prologLastIndex),
		replacement asUtf32Words,
		(codePoints
			copyFrom: epilogFirstIndex
			to: codePoints size)! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/23/2022 15:16:00' prior: 50351105!
                           asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8Bytes: self asUtf8Bytes! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/23/2022 15:09:39' prior: 50351412!
                           copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ (self byteIndexAt: startIndex)-1.
	epilogFirstIndex _ self byteIndexAt: endIndex+1.
	^Utf8String withBytes:
		(bytes copyFrom: 1 to: prologLastIndex),
		replacement asUtf8Bytes,
		(bytes
			copyFrom: epilogFirstIndex
			to: bytes size)! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/23/2022 15:16:03' prior: 50351460!
       asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8Bytes: bytes! !
!FileIOAccessor methodsFor: 'actions' stamp: 'jmv 5/26/2022 09:28:15' prior: 16854315!
  createDirectory: fullPathName
	self primCreateDirectory: fullPathName asUtf8Bytes! !
!FileIOAccessor methodsFor: 'actions' stamp: 'jmv 5/26/2022 09:28:22' prior: 16854320!
                    deleteDirectory: fullPathName
	self primDeleteDirectory: fullPathName asUtf8Bytes! !
!FileIOAccessor methodsFor: 'actions' stamp: 'jmv 5/26/2022 09:28:31' prior: 16854330!
                    deleteFile: fullPathName ifAbsent: failBlock 
	^(self
			try: [self primDeleteFileNamed: fullPathName asUtf8Bytes]
			forFileNamed: fullPathName) 
		ifFalse: [^ failBlock value]! !
!FileIOAccessor methodsFor: 'actions' stamp: 'jmv 5/26/2022 09:28:59' prior: 16854349!
                    rename: oldFileFullName to: newFileFullName 
	| selection |
	(self try: [self primRename: oldFileFullName asUtf8Bytes to: newFileFullName asUtf8Bytes ]
			forFileNamed: oldFileFullName) ifTrue: [^ self].

	oldFileFullName asFileEntry exists ifFalse: [^ self error: 'Attempt to rename a non-existent file'].
	(newFileFullName asFileEntry exists or: [ newFileFullName asDirectoryEntry exists ])
		ifTrue: [
			selection := (PopUpMenu labels: 'delete old version
cancel')
						startUpWithCaption: 'Trying to rename a file to be
' , newFileFullName , '
and it already exists.'.
			selection = 1
				ifTrue: [self deleteFile: newFileFullName.
					^ self rename: oldFileFullName to: newFileFullName]].
	^ self error: 'Failed to rename file'! !
!FileIOAccessor methodsFor: 'actions' stamp: 'jmv 5/26/2022 09:29:13' prior: 16854375!
     renameDirectory: oldFileFullName to: newFileFullName 
	| selection |
	(self try: [self primRename: oldFileFullName asUtf8Bytes to: newFileFullName asUtf8Bytes ]
			forFileNamed: oldFileFullName) ifTrue: [^ self].

	oldFileFullName asDirectoryEntry exists ifFalse: [^ self error: 'Attempt to rename a non-existent file'].
	newFileFullName asDirectoryEntry exists
		ifTrue: [selection := (PopUpMenu labels: 'delete old version
cancel')
						startUpWithCaption: 'Trying to rename a directory to be
' , newFileFullName , '
and it already exists.'.
			selection = 1
				ifTrue: [newFileFullName asDirectoryEntry recursiveDelete.
					^ self renameDirectory: oldFileFullName to: newFileFullName]].
	^ self error: 'Failed to rename file'! !
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 5/26/2022 09:28:02' prior: 16854401!
          basicDirectoryExists: fullPathName

 	^(
		(self primLookupEntryIn: fullPathName asUtf8Bytes index: 1) 
			== #badDirectoryPath
		) not! !
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 5/26/2022 09:28:42' prior: 16854418!
                              entriesIn: parentEntryOrNil
	"
	Warning: Private. Only to be called from within FileMan.
	Accepts nil as argument, but behavior depends on platform.

Windows (nil means root)
FileIOAccessor default entriesIn: nil #(C:\ D:\)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(\$Recycle.Bin \Config.Msi \Documents and Settings \gratMusic \hiberfil.sys \Intel \pagefile.sys \PerfLogs \Program Files \Program Files (x86) \ProgramData \Python27 \Recovery \SimuloHoy \System Volume Information \totalcmd \Users \Windows)

Linux  (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(Lots of stuff in current directory)
(FileIOAccessor default entriesIn: nil) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/vmlinuz /boot /sbin /srv /lib /lib32 /tmp /sys /home /etc /initrd.img /bin /dev /opt /proc /lost+found /var /root /lib64 /mnt /usr /run /media)

MacOsX (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(/Volumes/SanDisk32-NTFS/CuisTest/2554-REVISAR-JuanVuletich-2015Oct21-16h40m-jmv.1.cs.st /Volumes/SanDisk32-NTFS/CuisTest/Cog.app /Volumes/SanDisk32-NTFS/CuisTest/Cog.app.tgz /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.changes /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.image /Volumes/SanDisk32-NTFS/CuisTest/CuisV4.sources)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/.dbfseventsd /.DocumentRevisions-V100 /.DS_Store /.file /.fseventsd /.hotfiles.btree /.Spotlight-V100 /.Trashes /.vol /Applications /bin /cores /dev /etc /home /installer.failurerequests /Library /net /Network /opt /private /sbin /System /tmp /Users /usr /var /Volumes)

	"
	| entries index done entryArray entry isDirectory lookIn |
	entries _ OrderedCollection new: 200.
	index _ 1.
	done _ false.
	lookIn _ parentEntryOrNil ifNil: [''] ifNotNil: [parentEntryOrNil pathName].
	[done] whileFalse: [
		entryArray _ self primFixedNameLookupEntryIn: lookIn asUtf8Bytes index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^#()].
		entryArray == nil
			ifTrue: [done _ true]
			ifFalse: [
				isDirectory _ entryArray at: 4.
				entry _ isDirectory ifTrue: [DirectoryEntry new] ifFalse: [FileEntry new].
				entry name: (entryArray at: 1) parent: parentEntryOrNil.
				entry updateFrom: entryArray entryInParent: index.
				entries addLast: entry ].
		index _ index + 1].

	^entries asArray! !
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 5/26/2022 09:29:52' prior: 16854516!
      updateEntry: aFileSystemEntry
	| entryArray index lookIn isDirectory |

	"If the index in aFileSystemEntry is valid, use it. No need to iterate over all entries."
	aFileSystemEntry primEntryInParent ifNotNil: [ :tentativeIndex |
		(self primFixedNameLookupEntryIn: aFileSystemEntry parent pathName asUtf8Bytes index: tentativeIndex) ifNotNil: [ :found |
	 		found == #badDirectoryPath ifFalse: [
				aFileSystemEntry name = (found at: 1) ifTrue: [
					aFileSystemEntry updateFrom: found entryInParent: tentativeIndex.
					^ self ]]]].

	"Otherwise, do a full iteration"
	lookIn _ aFileSystemEntry parent pathName.
	index _ 1.
	[
		entryArray _ self primFixedNameLookupEntryIn: lookIn asUtf8Bytes index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^ self].
		entryArray == nil ifTrue: [
			^ self].
		isDirectory _ entryArray at: 4.
		aFileSystemEntry name = (entryArray at: 1) ifTrue: [
			isDirectory == aFileSystemEntry isDirectory ifTrue: [
				aFileSystemEntry updateFrom: entryArray entryInParent: index ].
			"If found, exit even if invalid. No point to keep iterating."
			^ self ].
		index _ index + 1] repeat! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 5/23/2022 15:11:34' prior: 16854866!
                         primCreateDirectory: fullPathAsUtf8Bytes
	"Create a directory named by the given path. Fail if the path is bad or if a file or directory by that name already exists."

 	<primitive: 'primitiveDirectoryCreate' module: 'FilePlugin'>
	self primitiveFailed
! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 5/23/2022 15:11:46' prior: 16854877!
     primDeleteDirectory: fullPathAsUtf8Bytes
	"Delete the directory named by the given path. Fail if the path is bad or if a directory by that name does not exist."

 	<primitive: 'primitiveDirectoryDelete' module: 'FilePlugin'>
	self primitiveFailed
! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 5/23/2022 15:11:49' prior: 16854887!
           primDeleteFileNamed: aFileNameAsUtf8Bytes
	"Delete the file of the given name. Return self if the primitive succeeds, nil otherwise."

	<primitive: 'primitiveFileDelete' module: 'FilePlugin'>
	^ nil
! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 5/23/2022 15:16:07' prior: 16854896!
                           primFixedNameLookupEntryIn: fullPathAsUtf8Bytes index: index
	"Fix the malformed String answered by the primitive. See comment at #primLookupEntryIn:index:"

	| answer |
	answer _ self primLookupEntryIn: fullPathAsUtf8Bytes index: index.
	answer isArray ifTrue: [
		answer at: 1 put: (String fromUtf8Bytes: answer first asByteArray) ].
	^answer! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 5/23/2022 15:12:11' prior: 16854909!
          primLookupEntryIn: fullPathAsUtf8Bytes index: index
	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:

	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>

	On MacOS and Windows,  the empty string enumerates the mounted volumes/drives.
	
	On Linux, it is equivalent to '.', and lists the contents of DirectoryEntry currentDirectory.

	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad.
	
	Warning: The 'name' field is an instance of String, but in reality it contains the bytes for its UTF-8 representation.
	For instance, if the real name is 'puÒo' we'll get  'pu√±o', as
	(String withAll: ('puÒo' AsUtf8Bytes asArray collect: [ :n | Character numericValue: n ]))        =        'pu√±o'
	Senders MUST do appropriate conversion.
	
	Consider calling #primFixedNameLookupEntryIn:index: instead.
	"

 	<primitive: 'primitiveDirectoryLookup' module: 'FilePlugin'>
	^ #badDirectoryPath

! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 5/23/2022 15:12:22' prior: 16854960!
                  primRename: oldFileFullNameAsUtf8Bytes to: newFileFullNameAsUtf8Bytes
	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name.
	Changed to return nil instead of failing ar 3/21/98 18:04"

	<primitive: 'primitiveFileRename' module: 'FilePlugin'>
	^nil! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 5/26/2022 09:29:39' prior: 50347912!
                      storeObject: anObject
	"Set new contents on the clipboard.  Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isStringLike or: [ anObject is: #Text])
		ifTrue: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id _ self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat _ (self stringOrIdFor: contents) asUtf8Bytes.
	self primitiveClipboardString: primitiveFormat! !
!Clipboard methodsFor: 'private' stamp: 'jmv 5/23/2022 15:16:10' prior: 50349861!
                          retrieveIdOrStringFromOS: stringClass
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| utf8Bytes |
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].

	utf8Bytes _ self primitiveClipboardString.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard."
	utf8Bytes isEmpty ifTrue: [ ^nil ].

	"Abuse the fact that the VM provides an instance of String (although it contains UTF-8 bytes)"
	utf8Bytes _ utf8Bytes fixLineEndings.

	"Clipboard primitive answers an instance of String containing the UTF-8 bytes.
	If not pure ASCII, contents are invalid!! Convert it ASAP into a reasonable ByteArray."
	utf8Bytes class format = ByteArray format  												"True unless image is in 32bit V3 format"
		ifTrue: [ ByteArray adoptInstance: utf8Bytes ]
		ifFalse: [ utf8Bytes _ ByteArray withAll: utf8Bytes ].
	^ stringClass fromUtf8Bytes: utf8Bytes.! !
!DropFilesEvent methodsFor: 'files' stamp: 'jmv 5/23/2022 15:16:14' prior: 50358678!
                            fileNamesDo: aBlock

	1 to: numberOfFiles do: [ :fileNumber | | utf8Bytes |
		(self primDropRequestFileName: fileNumber) ifNotNil: [ :primUtf8Bytes |
		utf8Bytes _ primUtf8Bytes.
		utf8Bytes class format = ByteArray format  												"True unless image is in 32bit V3 format"
			ifTrue: [ ByteArray adoptInstance: utf8Bytes ]
			ifFalse: [ utf8Bytes _ ByteArray withAll: utf8Bytes ].
		aBlock value: (String fromUtf8Bytes: utf8Bytes) ]].! !

Utf8String class removeSelector: #fromUtf8:!

!methodRemoval: Utf8String class #fromUtf8: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf8: bytes

	^self withBytes: bytes!

Utf8String class removeSelector: #fromUtf32:!

!methodRemoval: Utf8String class #fromUtf32: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf32: aWordArray

	^self withBytes: (String utf8FromUtf32: aWordArray).!

Utf8String removeSelector: #asUtf32!

!methodRemoval: Utf8String #asUtf32 stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf32
	"Answer a WordArray."

	^String utf32FromUtf8: bytes!

Utf8String removeSelector: #asUtf8!

!methodRemoval: Utf8String #asUtf8 stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf8
	"Answer a ByteArray."

	^bytes!

Utf8String removeSelector: #asUtf8Bytes:!

Utf8String removeSelector: #asUtf8:!

!methodRemoval: Utf8String #asUtf8: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-8 doesn't need them after all.
	Answer a ByteArray."

	^bytes!

Utf8String removeSelector: #asUtf32:!

!methodRemoval: Utf8String #asUtf32: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^self asUtf32!

Utf8String removeSelector: #asUtf32Words:!

Utf32String class removeSelector: #fromUtf8:!

!methodRemoval: Utf32String class #fromUtf8: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf8: aByteArray

	^self withWords: (String utf32FromUtf8: aByteArray).!

Utf32String class removeSelector: #fromUtf32:!

!methodRemoval: Utf32String class #fromUtf32: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf32: words

	^self withWords: words!

Utf32String removeSelector: #asUtf32!

!methodRemoval: Utf32String #asUtf32 stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf32
	"Answer a WordArray."

	^codePoints!

Utf32String removeSelector: #asUtf8Bytes:!

Utf32String removeSelector: #asUtf8!

!methodRemoval: Utf32String #asUtf8 stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf8
	"Answer a ByteArray."

	^String utf8FromUtf32: codePoints!

Utf32String removeSelector: #asUtf8:!

!methodRemoval: Utf32String #asUtf8: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a ByteArray."

	^self asUtf8!

Utf32String removeSelector: #asUtf32:!

!methodRemoval: Utf32String #asUtf32: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^codePoints!

Utf32String removeSelector: #asUtf32Words:!

String class removeSelector: #fromUtf32:hex:trimLastNull:!

!methodRemoval: String class #fromUtf32:hex:trimLastNull: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf32: aWordArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf32:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			"Add just one char if possible, or the apropriate sequence for the NCR"
			self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
		(doTrimLastNullChar and: [ aWordArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].!

String class removeSelector: #fromUtf8:!

!methodRemoval: String class #fromUtf8: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf8: aByteArray
	"Convert the given bytes from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf8 "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	^self fromUtf8: aByteArray hex: false trimLastNull: false!

String class removeSelector: #fromUtf32:!

!methodRemoval: String class #fromUtf32: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf32: aWordArray
	"Convert the given bytes from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf32 "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	^self fromUtf32: aWordArray hex: false trimLastNull: false!

String class removeSelector: #fromUtf8:hex:trimLastNull:!

!methodRemoval: String class #fromUtf8:hex:trimLastNull: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
fromUtf8: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					"Add just one char if possible, or the apropriate sequence for the NCR"
					self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
			byteIndex _ byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].!

String removeSelector: #asUtf32!

!methodRemoval: String #asUtf32 stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf32
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	See #fromUtf32: "

	^self asUtf32: true.!

String removeSelector: #asUtf8!

!methodRemoval: String #asUtf8 stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf8
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	See #fromUtf8: "

	^self asUtf8: true.!

String removeSelector: #asUtf32:!

!methodRemoval: String #asUtf32: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf32: convertEmbeddedNCRs
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

Copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^WordArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					outStream nextPut: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					outStream nextPut: codePoint ]]]!

String removeSelector: #asUtf8:!

!methodRemoval: String #asUtf8: stamp: 'Install-5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
asUtf8: convertEmbeddedNCRs
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

Copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^ByteArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint ]]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5196-utf8Bytes-utf32Words-betterProtocol-JuanVuletich-2022May26-09h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5196] on 26 May 2022 at 9:46:03 am'!
!SequenceableCollection methodsFor: 'converting' stamp: 'jmv 5/22/2022 20:42:56'!
      readStreamFrom: start to: stop
	^ ReadStream on: self from: start to: stop! !
!ArrayedCollection class methodsFor: 'stream creation' stamp: 'jmv 5/22/2022 21:07:37'!
                          writeStream
	^ WriteStream on: (self new: 100)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5197-twoStreamHelpers-JuanVuletich-2022May26-09h45m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5195] on 25 May 2022 at 5:39:54 pm'!
!Scanner methodsFor: 'public access' stamp: 'jmv 5/23/2022 17:15:50' prior: 50342682!
                   scanTokenPositionsIn: textOrString into: aBlock
	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments, in textOrString."

	self initScannerForTokenization.
	source _ textOrString asPlainString readStream.
	buffer _ source collectionSpecies writeStream.
	self step.
	self step.
	self scanAllTokenPositionsInto: aBlock

	"| code |
	code := '       #( 1 2 #( 3 4 ))  16r123 123 123.0  ', (Scanner sourceCodeAt: #scanTokenPositionsIn:into:).
	Scanner new scanTokenPositionsIn: code into: [:start :end| Transcript cr; nextPut: $_; nextPutAll: (code copyFrom: start to: end); nextPut: $_; endEntry]"

	"CodeDiffBuilder buildDisplayPatchFrom:  (Scanner sourceCodeAt: #scanTokenPositionsIn:into:) to:  ((Scanner sourceCodeAt: #scanTokenPositionsIn:into:) copyReplaceAll: String crString with: '')"

	"CodeDiffBuilder buildDisplayPatchFrom:  'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]' to:'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]'"! !
!Scanner methodsFor: 'initialization' stamp: 'jmv 5/23/2022 17:11:54' prior: 16932008!
             scan: inputStream 
	"Bind the input stream, fill the character buffers and first token buffer."

	source _ inputStream.
	buffer _ source collectionSpecies writeStream.
	self step.
	self step.
	self scanToken! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5198-ParserRefactor-Part1-JuanVuletich-2022May25-17h39m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5195] on 25 May 2022 at 5:40:59 pm'!
!Scanner methodsFor: 'expression types' stamp: 'jmv 5/23/2022 17:19:34' prior: 16931542!
           scanForFindSelectorUpTo: terminator
"
Scanner findSelectorTests
"
    | s |

    s := source collectionSpecies writeStream.
    [tokenType == terminator or: [tokenType == #doIt]] whileFalse: [
        tokenType caseOf: {
            [#leftParenthesis] -> [self scanToken; scanForFindSelectorUpTo: #rightParenthesis].
            [#leftBracket] -> [self scanToken; scanForFindSelectorUpTo: #rightBracket].
            [#leftBrace] -> [self scanToken; scanForFindSelectorUpTo: #rightBrace].
            [#keyword] -> [s nextPutAll: token].
        } otherwise: [].
        self scanToken
    ].
    ^s contents! !
!Scanner methodsFor: 'expression types' stamp: 'jmv 5/23/2022 17:15:22' prior: 16931616!
   scanLitWord
	"Accumulate keywords and asSymbol the result."

	token := (source collectionSpecies streamContents: [ :stream |
		stream nextPutAll: token.
		[ (self typeTableAt: hereChar) == #xLetter ] whileTrue: [
			self xLetter.
			stream nextPutAll: token ] ]) asSymbol! !
!Scanner methodsFor: 'public access' stamp: 'jmv 5/22/2022 21:18:35' prior: 16931668!
                       scanFieldNames: stringOrArray
	"Answer an Array of Strings that are the identifiers in the input string, 
	stringOrArray. If passed an Array, just answer with that Array, i.e., 
	assume it has already been scanned."

	| strm |
	(stringOrArray isMemberOf: Array)
		ifTrue: [^stringOrArray].
	self scan: stringOrArray asString readStream.
	strm := (Array new: 10) writeStream.
	[tokenType == #doIt]
		whileFalse: 
			[tokenType == #word ifTrue: [strm nextPut: token].
			self scanToken].
	^strm contents

	"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !
!Scanner methodsFor: 'public access' stamp: 'jmv 5/22/2022 20:40:14' prior: 50342644!
             scanMessageParts: sourceString
	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"

	| coll nonKeywords |
	coll := OrderedCollection new.
	self scan: sourceString asPlainString readStream.
	nonKeywords := 0.
	[tokenType == #doIt] whileFalse:
		[(currentComment == nil or: [currentComment isEmpty])
			ifTrue: [coll addLast: nil]
			ifFalse: [coll addLast: currentComment removeFirst.
				[currentComment isEmpty] whileFalse:
					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
		(token numArgs < 1 or: [token = #| and: [ coll size > 1 ] ])
			ifTrue: [(nonKeywords := nonKeywords + 1) > 1 ifTrue: [^ coll]]
						"done with header"
			ifFalse: [nonKeywords := 0].
		coll addLast: token.
		self scanToken].
	(currentComment == nil or: [currentComment isEmpty])
		ifTrue: [coll addLast: nil]
		ifFalse: [coll addLast: currentComment removeFirst.
			[currentComment isEmpty] whileFalse: [
				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
	^ coll! !
!Scanner methodsFor: 'public access' stamp: 'jmv 5/22/2022 20:40:33' prior: 50342716!
          scanTokens: textOrString 
	"Answer an Array that has been tokenized as though the input text, 
	textOrString, had appeared between the array delimitors #( and ) in a 
	Smalltalk literal expression."

	self initScannerForTokenization.
	self scan: textOrString asPlainString readStream.
	self scanLitVec.
	^token

	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !
!Scanner methodsFor: 'public access' stamp: 'jmv 5/22/2022 21:17:43' prior: 50342731!
            typedScanTokens: textOrString 
	"Answer an Array that has been tokenized with literals mapped to literals,
	 special characters mapped to symbols and variable names and keywords
	 to strings. This methiod accepts _ (underscore) as an assignment token
	 irrespective of whether the system prefers := as the assignment token."
	| s |
	self initScannerForTokenization.
	self scan: textOrString asPlainString readStream.
	s := (Array new: 16) writeStream.
	[tokenType == #doIt] whileFalse:
		[(token == #- 
		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: 
			[self scanToken.
			 token := token negated].
		s nextPut: token.
		self scanToken].
	^s contents

	"Scanner new typedScanTokens: (Scanner sourceCodeAt: #typedScanTokens:)"! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/23/2022 17:16:04' prior: 16931830!
                           xBinary

	tokenType _ #binary.
	token _ source collectionSpecies streamContents: [ :stream |
	stream nextPut: self step.
	[	| type |
		type _ self typeTableAt: hereChar.
		type == #xBinary and: [hereChar ~= $- or: [aheadChar isDigit not]]
		] whileTrue: [
		stream nextPut: self step]].
	token _ token asSymbol! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/23/2022 17:16:31' prior: 50359834!
        xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := source collectionSpecies writeStream.
    self step.
    [hereChar = $"]
        whileFalse:
            [(hereChar = stopChar and: [source atEnd])
                ifTrue: [^self offEnd: self class unmatechedCommentQuoteErrorDescription].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollection with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!Scanner methodsFor: 'initialization' stamp: 'jmv 5/23/2022 17:12:06' prior: 16931993!
               initScanner

	typeTable := Scanner typeTable.
	isForTokenization := false.
	sentInLiterals := Set new.
	! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 5/22/2022 20:39:45' prior: 16932021!
                              findSelectorIn: aString

    | result |
    result _ Scanner new
        scan: aString readStream;
        scanForFindSelectorUpTo: #notATerminator.
    ^result! !
!Parser methodsFor: 'private' stamp: 'jmv 5/22/2022 20:41:00' prior: 50342757!
             initPattern: aString notifying: req return: aBlock
	| result |
	self
		init: aString asPlainString readStream
		notifying: req
		failBlock: [^nil].
	encoder _ self.
	result _ aBlock value: (self pattern: false inContext: nil).
	encoder _ failBlock _ nil.  "break cycles"
	^result! !
!Parser methodsFor: 'private' stamp: 'jmv 5/23/2022 17:23:59' prior: 16907211!
                      privateReadSelector
	| args selector |
	doitFlag := false.

	hereType == #word ifTrue: [
		^ here asSymbol ].

	self transformVerticalBarAndUpArrowIntoABinarySelector.

	hereType == #binary ifTrue: [
		^ here asSymbol ].

	hereType == #keyword ifTrue: [
		selector := source collectionSpecies writeStream.
		args := OrderedCollection new.
		[hereType == #keyword] whileTrue: [
			selector nextPutAll: self advance.
			args addLast: (encoder bindArg: self argumentName).
		].
		^ selector contents asSymbol ].

	^self expected: 'Message pattern'! !
!Parser methodsFor: 'private' stamp: 'jmv 5/22/2022 20:41:16' prior: 16907230!
             privateReadSelectorFrom: aMethodSource
	"Answer the message selector for the argument, aMethodSource, which should 
	 parse successfully up to the temporary declaration or the end of the 
	 method header."
	"Note: only intended to read the selector. Parser instance might be inconsistent afterwards.
	Optimized these kind of methods (compare the following):
	[ 100000 timesRepeat: [Parser new parseSelector: 'a ^#[123 123 123 123 123 123 123 123 987 987 987 987 987 987 987 987]'] ] timeToRun 4824
	[ 100000 timesRepeat: [Parser new privateReadSelectorFrom: 'a ^#[123 123 123 123 123 123 123 123 987 987 987 987 987 987 987 987]'] ] timeToRun  342
	"

	| result |
	self initScannerForTokenization.
	self
		init: aMethodSource asString readStream
		notifying: nil
		failBlock: [ ^nil ].
	encoder _ self.
	result _ self privateReadSelector.
	encoder _ failBlock _ nil.  "break cycles"
	^result! !
!Parser methodsFor: 'expression types' stamp: 'jmv 5/23/2022 17:24:44' prior: 16907902!
         keywordPattern

	| keywordRanges selector arguments |
	
	selector := source collectionSpecies writeStream.
	arguments := OrderedCollection new.
	keywordRanges := OrderedCollection new.
	
	[hereType == #keyword] whileTrue:[ 
		self addKeywordPatternPartTo: selector keywordRanges: keywordRanges arguments: arguments ].
		
	^ {selector contents asSymbol. arguments. 3. keywordRanges}
		! !
!Parser methodsFor: 'expression types' stamp: 'jmv 5/23/2022 17:25:10' prior: 16907934!
    messagePart: level repeat: repeat

	| start receiver selector args precedence words keywordStart |
	
	[receiver := parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: [
			start := self startOfNextToken.
			selector := source collectionSpecies writeStream.
			args := OrderedCollection new.
			words := OrderedCollection new.
			[hereType == #keyword]
				whileTrue: 
					[keywordStart := self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])
				ifFalse: [ selector := self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ].
			precedence := 3]
		ifFalse: [
			
			level >= 2 ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].
			((hereType == #binary )
				and: [level >= 2])
				ifTrue: 
					[start := self startOfNextToken.
					selector := self advance asSymbol.
					words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args := Array with: parseNode.
					precedence := 2]
				ifFalse: [hereType == #word
						ifTrue: 
							[start := self startOfNextToken.
							selector := self advance.
							args := #().
							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])
								ifFalse: [ selector := self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ].
							precedence := 1]
						ifFalse: [^args notNil]]].

	parseNode := MessageNode new
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken)
				keywordsRanges: words.
	repeat]
		whileTrue: [].
	^true! !
!Parser methodsFor: 'public access' stamp: 'jmv 5/22/2022 20:41:08' prior: 16908908!
                      parse: sourceStream class: class category: aCategory noPattern: noPattern doIt: doIt context: aContext notifying: aRequestor ifFail: aBlock

	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	
	| methNode repeatNeeded myStream sourceCode startPosition |
	
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		startPosition _ myStream position.
		sourceCode _ myStream upToEnd.
		myStream position: startPosition.
		self encoder init: class context: aContext notifying: self.
		"Protect against possible parsing failure"
		doIt ifTrue: [
			(sourceCode beginsWith: Scanner doItInSelector)
				ifTrue: [encoder selector: Scanner doItInSelector]
				ifFalse: [
					(sourceCode beginsWith: Scanner doItSelector)
						ifTrue: [encoder selector: Scanner doItSelector]]].
		self init: myStream notifying: aRequestor failBlock: [^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern doIt: doIt context: aContext ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ requestor text string readStream ].
		repeatNeeded
	] whileTrue: [ encoder _ self encoder class new ].

	methNode sourceText: sourceCode.
	"See #xBacktick"
	sentInLiterals do: [ :sym | encoder noteOptimizedSelector: sym ].

	^ methNode! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5199-ParserRefactor-Part2-JuanVuletich-2022May25-17h39m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5195] on 25 May 2022 at 5:47:49 pm'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/23/2022 19:45:37' prior: 16931819!
      typeTableAt: aCharacter
	^typeTable at: aCharacter iso8859s15Code ifAbsent:[#xLetter]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5200-Scanner-tweak-JuanVuletich-2022May25-17h40m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5203] on 26 May 2022 at 11:35:46 am'!
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/24/2022 11:20:42' prior: 50360444!
                  scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := source class with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c = $:]) ifFalse: [^currentToken].
	(c = $: and: [d = $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (source class with: d).
			self nextChar.
			^currentToken].
	"|| empty temp declaration"
	"This makes || colorize as an invalid method definition.
	It is better to allow #|| as valid selector, and mark an empty temp declaration as invalid instead!!"
	"(c = $| and: [d = $|])
		ifTrue: [^currentToken]."
	c _ d.
	[
		d _ self peekChar.
		c = $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken _ currentToken copyWith: c.
			c _ self nextChar ].
	^currentToken! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5201-ShoutParser-properStringClass-JuanVuletich-2022May26-11h35m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5201] on 26 May 2022 at 12:38:22 pm'!
!Character class methodsFor: 'converting' stamp: 'jmv 5/24/2022 16:10:06'!
                      utf8BytesAndCodePointFor: byte1 byte2: byte2 byte3: byte3 byte4: byte4 into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in argument bytes.
	Evaluate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, consider the first byte an ISO-8859-15 Character (i.e. Cuis Character class encoding), and answer 1.
	Skip codePoint U+FEFF (BOM, unneededly added by Win clipboard). Still, answer the number of bytes of the BOM sequence, to allow senders to update an index in an iteration.
	See senders."

	| codePoint |
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ 1 ].
	
	"At least 2 bytes"
	(byte2 notNil and: [ (byte2 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-15."
		^ self utf8BytesAndCodePointForIso8859s15: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rE0) = 16rC0  ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^2 ].
	
	"At least 3 bytes"
	(byte3 notNil and: [ (byte3 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-15."
		^ self utf8BytesAndCodePointForIso8859s15: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rF0) = 16rE0  ifTrue: [ "three bytes"
		codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ "BOM. Ignore it. Skip ti."
			^3 ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^3 ].

	"4 bytes"
	(byte4 notNil and: [ (byte4 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-15."
		^ self utf8BytesAndCodePointForIso8859s15: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rF8) = 16rF0  ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		^ 4].

	"invalid UTF-8. Assume byte1 is ISO8859-15."
	^ self utf8BytesAndCodePointForIso8859s15: byte1 into: bytesBlock into: codePointBlock.! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/24/2022 16:58:19'!
            utf8BytesAndCodePointForIso8859s15: iso8859s15 into: bytesBlock into: codePointBlock
	| codePoint |
	codePoint _ (Character numericValue: iso8859s15) codePoint.
	bytesBlock ifNotNil: [
		Character
			evaluateOnce: bytesBlock
			withUtf8BytesOfUnicodeCodePoint: codePoint ].
	codePointBlock ifNotNil: [
		codePointBlock value: codePoint ].
	^1! !
!String methodsFor: 'converting' stamp: 'jmv 5/21/2022 21:26:19'!
    asByteString
	"Answer an instance of the Byte oriented String class"
	^self! !
!String methodsFor: 'converting' stamp: 'jmv 5/23/2022 17:31:16'!
               asUtf32String
	"Answer an instance of the UTF-32 encoded String class"

	^Utf32String fromUtf8Bytes: self asUtf8Bytes! !
!String methodsFor: 'converting' stamp: 'jmv 5/23/2022 17:31:28'!
     asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	^Utf8String fromUtf8Bytes: self asUtf8Bytes! !
!String methodsFor: 'enumerating' stamp: 'jmv 5/26/2022 11:30:56'!
       collectInArray: aBlock
	"Refer to the comment in Collection|collect:."
	| result value |
	result _ Array new: self size.
	1 to: self size do: [ :index |
		value _ aBlock value: (self at: index).
		result at: index put: value].
	^ result.! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/24/2022 11:23:08'!
      isValidInBinarySelectors
	(Character codePoint: value) ifNotNil: [ :ch | ^ch isValidInBinarySelectors ].
	^false! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/24/2022 11:12:26'!
      at: codePointIndex ifAbsent: absentBlock
	"Answer the UnicodeCodePoint at codePointIndex"

	(codePointIndex between: 1 and: self size) ifFalse: [ ^absentBlock value ].
	^self at: codePointIndex! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/24/2022 11:15:42'!
                     last
	"Answer the last element of the receiver.
	Raise an error if the collection is empty."

	| size |
	(size _ self size) = 0 ifTrue: [self error: 'Empty Utf32String'].
	^ self at: size! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/26/2022 11:34:36'!
                             appendToString: aString

	^Utf32String withWords: aString asUtf32Words, codePoints! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/21/2022 22:02:37'!
      appendToText: aText

	| textStringSize |
	textStringSize := aText string size.
	^ aText replaceFrom: textStringSize + 1
			 to: textStringSize 
			 with: self asText! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/23/2022 17:31:33'!
                asUtf32String
	"Answer an instance of the UTF-32 encoded String class"

	^Utf32String fromUtf8Bytes: self asUtf8Bytes! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/23/2022 17:31:37'!
asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	^Utf8String fromUtf8Bytes: self asUtf8Bytes! !
!Utf32String methodsFor: 'enumerating' stamp: 'jmv 5/26/2022 11:31:19'!
  collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacterLike ]) ifFalse: [
		^array ].
	^Utf32String newFrom: array! !
!Utf32String methodsFor: 'enumerating' stamp: 'jmv 5/26/2022 11:30:59'!
collectInArray: aBlock
	"Refer to the comment in Collection|collect:."
	| result i |
	result _ Array new: self size.
	i _ 1.
	self do: [ :codePoint |
		result at: i put: codePoint.
		i _ i + 1 ].
	^ result.! !
!Utf32String methodsFor: 'enumerating' stamp: 'jmv 5/21/2022 21:46:51'!
      do: aBlock
	self from: 1 to: codePoints size do: aBlock! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/21/2022 21:49:44' overrides: 16903947!
                             newFrom: aSimilarObject
	^Utf32String streamContents: [ :strm |
		aSimilarObject do: [ :codePoint |
			strm nextPut: codePoint ]]! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/24/2022 11:11:27'!
                      at: codePointIndex ifAbsent: absentBlock
	"Answer the UnicodeCodePoint at code point index codePointIndex (not a byte index!!)"

	(codePointIndex between: 1 and: self size) ifFalse: [ ^absentBlock value ].
	^self at: codePointIndex! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/24/2022 11:16:33'!
                last
	"Answer the last element of the receiver.
	Raise an error if the collection is empty."

	| size |
	(size _ self size) = 0 ifTrue: [self error: 'Empty Utf8String'].
	^ self at: size! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/24/2022 18:05:15'!
                               appendToString: aString

	aString isStringLike ifFalse: [
'pufff' print.
	self halt ].
	^Utf8String withBytes: aString asUtf8Bytes, bytes! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/21/2022 22:02:34'!
                appendToText: aText

	| textStringSize |
	textStringSize := aText string size.
	^ aText replaceFrom: textStringSize + 1
			 to: textStringSize 
			 with: self asText! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/23/2022 17:31:42'!
                 asUtf32String
	"Answer an instance of the UTF-32 encoded String class"

	^Utf32String fromUtf8Bytes: self asUtf8Bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/23/2022 17:31:45'!
 asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	^Utf8String fromUtf8Bytes: self asUtf8Bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/21/2022 21:27:20'!
    contractTo: smallSize
	"return myself or a copy shortened by ellipsis to smallSize"
	| leftSize |
	self size <= smallSize
		ifTrue: [^ self].  "short enough"
	smallSize < 5
		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"
	leftSize _ smallSize-2//2.
	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"
		to: self size - (smallSize - leftSize - 3)
		with: '...'
"
	(Utf8String withBytes: 'A clear but rather long-winded summary' asUtf8) contractTo: 18
"! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/26/2022 11:33:05' overrides: 16902848!
                               displayStringOrText
	"To be used in the UI"
	"Answer the receiver itself."

	^self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/22/2022 15:23:32'!
    string
	"Answer the receiver itself.  This is for compatibility with other text classes."
	^self! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 5/26/2022 11:31:22'!
                     collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacterLike ]) ifFalse: [
		^array ].
	^Utf8String newFrom: array! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 5/26/2022 11:31:04'!
  collectInArray: aBlock
	"Refer to the comment in Collection|collect:."
	| result i |
	result _ Array new: self size.
	i _ 1.
	self do: [ :codePoint |
		result at: i put: codePoint.
		i _ i + 1 ].
	^ result.! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 5/21/2022 22:11:12'!
       do: aBlock
	"Evaluate aBlock for all elements."

	| byteIndex stopByteIndex n |
	byteIndex _ 1.
	stopByteIndex _ bytes size.
	[ byteIndex <= stopByteIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (UnicodeCodePoint codePoint: codePoint) ].
		byteIndex _ byteIndex + n ].! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/21/2022 21:48:34' overrides: 16903947!
                     newFrom: aSimilarObject
	^Utf8String streamContents: [ :strm |
		aSimilarObject do: [ :codePoint |
			strm nextPut: codePoint ]]! !
!Utf8String class methodsFor: 'services' stamp: 'jmv 5/24/2022 12:22:31'!
                  utf32FromUtf8: aByteArray
	"Convert the given string from UTF-8 to UTF-32"

	^WordArray streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					strm nextPut: codePoint ].
			byteIndex _ byteIndex + n
		]].! !
!Utf8String class methodsFor: 'services' stamp: 'jmv 5/24/2022 12:22:38'!
                       utf8FromUtf32: aWordArray
	"Convert the given string from UTF-8 to UTF-32"

	^ByteArray streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			Character
				evaluate: [ :byte | strm nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: codePoint ]]! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/24/2022 19:04:02' prior: 50349179!
    utf8BytesAndCodePointAt: byteIndex in: aByteArray into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in utf8ByteArray starting at byte byteIndex.
	Evaluate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, consider the first byte an ISO-8859-15 Character (i.e. Cuis Character class encoding), and answer 1.
	Skip codePoint U+FEFF (BOM, unneededly added by Win clipboard). Still, answer the number of bytes of the BOM sequence, to allow senders to update an index in an iteration.
	See senders."

	| i s byte1 byte2 byte3 byte4 |
	
	s _ aByteArray size.
	i _ byteIndex.
	byte1 _ aByteArray at: i.
	i _ byteIndex+1.
	byte2 _ i <= s ifTrue: [aByteArray at: i].
	i _ byteIndex+2.
	byte3 _ i <= s ifTrue: [aByteArray at: i].
	i _ byteIndex+3.
	byte4 _ i <= s ifTrue: [aByteArray at: i].

	^self
		utf8BytesAndCodePointFor: byte1
		byte2: byte2
		byte3: byte3
		byte4: byte4
		into: bytesBlock
		into: codePointBlock! !
!String methodsFor: 'converting' stamp: 'jmv 5/24/2022 14:29:34' prior: 50361902!
asUtf8Bytes
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray with a valid UTF-8 sequence.
	
	See #fromUtf8Bytes: "

	^self asUtf8Bytes: true.! !
!String methodsFor: 'enumerating' stamp: 'jmv 5/26/2022 11:31:11' prior: 16948855 overrides: 16934336!
           collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c is: #Character ]) ifFalse: [
		^array ].
	^String newFrom: array! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/26/2022 11:34:32' prior: 50351042!
                          , aString
	^Utf32String withWords: codePoints, aString asUtf32Words.! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/24/2022 14:29:54' prior: 50362107!
 asUtf8Bytes
	"Answer a ByteArray with a valid UTF-8 sequence."

	^Utf8String utf8FromUtf32: codePoints! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 11:00:12' prior: 50362117!
                  fromUtf8Bytes: aByteArray

	^self withWords: (Utf8String utf32FromUtf8: aByteArray).! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/17/2022 15:05:27' prior: 50351290 overrides: 16901507!
                               at: codePointIndex
	"Answer the UnicodeCodePoint at code point index codePointIndex (not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ UnicodeCodePoint codePoint: (bytes at: codePointIndex) ].
	byteIndex _ self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^UnicodeCodePoint codePoint: codePoint ].
	^nil "Invalid UTF-8"! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/26/2022 11:00:07' prior: 50362122!
              asUtf32Words
	"Answer a WordArray."

	^Utf8String utf32FromUtf8: bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/24/2022 14:30:01' prior: 50362127!
asUtf8Bytes
	"Answer a ByteArray with a valid UTF-8 sequence."

	^bytes! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 11:00:31' prior: 50362132!
                  fromUtf32Words: aWordArray

	^self withBytes: (Utf8String utf8FromUtf32: aWordArray).! !

String class removeSelector: #utf8FromUtf32:!

!methodRemoval: String class #utf8FromUtf32: stamp: 'Install-5202-Utf8StringNFriends-JuanVuletich-2022May26-12h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
utf8FromUtf32: aWordArray
	"Convert the given string from UTF-8 to UTF-32"

	^ByteArray streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			Character
				evaluate: [ :byte | strm nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: codePoint ]]!

String class removeSelector: #utf32FromUtf8:!

!methodRemoval: String class #utf32FromUtf8: stamp: 'Install-5202-Utf8StringNFriends-JuanVuletich-2022May26-12h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
utf32FromUtf8: aByteArray
	"Convert the given string from UTF-8 to UTF-32"

	^WordArray streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					strm nextPut: codePoint ].
			byteIndex _ byteIndex + n
		]].!

Character class removeSelector: #nextCodePointBytesFromUtf8:into:!

!methodRemoval: Character class #nextCodePointBytesFromUtf8:into: stamp: 'Install-5202-Utf8StringNFriends-JuanVuletich-2022May26-12h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
nextCodePointBytesFromUtf8: anUtf8Stream into: aBlock
	"anUtf8Stream can be over a ByteArray.
	See senders."
"Note: This method will be removed. Prefer
#utf8BytesAndCodePointAt:in:into:into:
"
	| byte1 byte2 byte3 byte4 |
	byte1 _ anUtf8Stream next.
	byte1 < 128 ifTrue: [	"single byte"
		^ aBlock value: byte1 value: nil value: nil value: nil ].
	
	"At least 2 bytes"
	byte2 _ anUtf8Stream next.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		^ aBlock value: byte1 value: byte2 value: nil value: nil ].
	
	"At least 3 bytes"
	byte3 _ anUtf8Stream next.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: nil ].

	"4 bytes"
	byte4 _ anUtf8Stream next.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: byte4 ].

	^nil!

Character class removeSelector: #nextUnicodeCodePointFromUtf8:!

!methodRemoval: Character class #nextUnicodeCodePointFromUtf8: stamp: 'Install-5202-Utf8StringNFriends-JuanVuletich-2022May26-12h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
nextUnicodeCodePointFromUtf8: anUtf8Stream
	"anUtf8Stream can be over a ByteArray
	Answer nil if conversion not possible, because of invalid UTF-8.
	Also answer nil for codePoint U+FEFF (BOM, unneededly added by Win clipboard)"
"Note: This method will be removed. Prefer
#utf8BytesAndCodePointAt:in:into:into:
"
	^ self
		nextCodePointBytesFromUtf8: anUtf8Stream
		into: [ :byte1 :byte2 :byte3 :byte4 |
			byte4 notNil
				ifTrue: [ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12) + ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63) ]
				ifFalse: [
					byte3 notNil
						ifTrue: [ | codePoint |
							codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
							codePoint = 16rFEFF
								ifFalse: [ codePoint ]
								ifTrue: [ nil ]]
						ifFalse: [
							byte2 notNil
								ifTrue: [ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ]
								ifFalse: [ byte1 ]]]]!

Character class removeSelector: #unicodeCodePointOfUtf8Bytes:!

!methodRemoval: Character class #unicodeCodePointOfUtf8Bytes: stamp: 'Install-5202-Utf8StringNFriends-JuanVuletich-2022May26-12h37m-jmv.001.cs.st 6/16/2022 07:24:49'!
unicodeCodePointOfUtf8Bytes: aByteArray

	Character utf8BytesAndCodePointAt: 1 in: aByteArray
				into: nil
				into: [ :codePoint | ^ codePoint ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5202-Utf8StringNFriends-JuanVuletich-2022May26-12h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5202] on 26 May 2022 at 4:35:15 pm'!
!PositionableStream methodsFor: 'positioning' stamp: 'jmv 5/26/2022 15:12:26'!
    skip
	"Skips one object in the receiver's future sequence values."

	self skip: 1! !
!PositionableStream methodsFor: 'positioning' stamp: 'jmv 5/26/2022 15:11:56'!
                            skipBack
	"Skips back one object in the receiver's future sequence values."

	self skip: -1.! !
!DummyStream methodsFor: 'positioning' stamp: 'jmv 5/26/2022 14:38:09'!
                        skip
	"Do nothing."! !
!DummyStream methodsFor: 'positioning' stamp: 'jmv 5/26/2022 14:51:58'!
 skipBack
	"Do nothing."! !
!TextModel methodsFor: 'undoable commands' stamp: 'jmv 5/26/2022 15:13:45' prior: 16968835!
         undoAndEvaluate: aTwoArgBlock
	| modelUpdated newCursorPos |
	modelUpdated _ false.
	undoRedoCommands position > 0 ifTrue: [
		undoRedoCommands skipBack.
		newCursorPos _ undoRedoCommands peek undoOn: self.
		modelUpdated _ true ].
	aTwoArgBlock value: modelUpdated value: newCursorPos.
	lastEditTimeStamp _ nil! !
!Number class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 15:15:32' prior: 16901396!
      readRemainderOf: integerPart from: aStream base: base withSign: sign
	"Read optional fractional part and exponent, and return the final result"
	| value fraction fracpos peekChar exp scale convertToFloat |

	convertToFloat := false.
	value := integerPart.
	(aStream peekFor: $.)
		ifTrue: [		 "<integer>.<fraction>"
			(aStream atEnd not and: [ aStream peek digitValue between: 0 and: base - 1 ])
				ifTrue:  [
					fracpos := aStream position.
					fraction := Integer readFrom: aStream base: base.
					fraction := fraction / (base raisedToInteger: aStream position - fracpos).
					value := value + fraction.
					convertToFloat := true ]
				ifFalse: [
					"oops - just <integer>."
					aStream skipBack.
					"un-gobble the period"
					^ value * sign"Number readFrom: '3r-22.2'"]].
	peekChar := aStream peek.
	('deqp' includes: peekChar)
		ifTrue: [			"<number>(e|d|q)<exponent>>" "<number>(p)<binaryExponent>>"
			aStream next.
			(aStream atEnd not and: [ (aStream peek digitValue between: 0 and: 9) or: [ '+-' includes: aStream peek ]])
				ifTrue:  [
					exp := Integer readFrom: aStream.
					scale := (peekChar = $p ifTrue: [2] ifFalse: [base]) raisedToInteger: exp.
					value := value * scale ]
				ifFalse: [
					"oops - just <number>."
					aStream skipBack.]].
	^convertToFloat
		ifTrue: [
			(value = 0.0 and: [ sign = -1 ])
				ifTrue: [ Float negativeZero ]
				ifFalse: [ (value * sign) asFloat ]]
		ifFalse: [ value * sign ]! !
!Integer class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 15:13:51' prior: 16876310!
                  readBaseOneFrom: aStream
	"Unary numeral system
	Supports positive and negative integers.
	See http://en.wikipedia.org/wiki/Unary_numeral_system
	Non-standard features of this system include:
		- The value of a digit does not depend on its position. Thus, one can easily argue that unary is not a positional system at all.
		- Introducing a radix point in this system will not enable representation of non-integer values.
		- The single numeral represents the value 1, not the value 0=b-1.
		- The value 0 cannot be represented (or is implicitly represented by an empty digit string).
	Examples (and equivalent decimal notation)
		1r1 = 10r1
		1r11 = 10r2
		1r111 = 10r3
		1r = 10r0
	"

	| digit value neg |
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	[ aStream atEnd ]
		whileFalse: [ 
			digit _ aStream next digitValue.
			digit = 1
				ifTrue: [value _ value + digit]
				ifFalse: [
					aStream skipBack.
					neg ifTrue: [^ value negated].
					^ value]].
	neg ifTrue: [ ^ value negated ].
	^ value! !
!Integer class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 15:13:54' prior: 16876355!
              readFrom: aStream base: base
	"Answer an instance of one of my concrete subclasses. Initial minus sign
	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
	allowed--use Number readFrom: for that. Raises an error if
	there are no digits."

	| digit value neg cc atLeastOneDigitRead |
	
	(aStream atEnd) ifTrue: [ self error: 'At least one digit expected here' ].
	
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	atLeastOneDigitRead _ false.
	[ aStream atEnd ]
		whileFalse: [
			cc _ aStream next.
			digit _ cc digitValue.
			(digit < 0 or: [digit >= base])
				ifTrue: [
					aStream skipBack.
					atLeastOneDigitRead ifFalse: [self error: 'At least one digit expected here'].
					^neg
						ifTrue: [value negated]
						ifFalse: [value]].
			value _ value * base + digit.
			atLeastOneDigitRead _ true ].
	neg ifTrue: [^ value negated].
	^ value! !
!Date class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 16:33:54' prior: 16836632 overrides: 50361598!
       readFrom: aStream 
	"Read a Date from the stream in any of the forms:
		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  
		<month> <day> <year>		(April 15, 1982; 4/15/82)
		<year>-<month>-<day>		(1982-04-15) (ISO8601)"
	| day month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 31])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isLetter
		ifTrue: ["MonthName-DD-YY or DD-MonthName-YY or YY-MonthName-DD"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
			firstAsNumber
				ifNil: ["MonthName DD YY"
					day := Integer readFrom: aStream]
				ifNotNil: [
					year ifNil: ["DD MonthName YY"
						day := firstAsNumber]]]
		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"
			year 
				ifNil: ["MM-DD-YY or DD-MM-YY"
					firstAsNumber > 12
						ifTrue: ["DD-MM-YY"
							day := firstAsNumber.
							month := Month nameOfMonth: (Integer readFrom: aStream)]
						ifFalse: ["MM-DD-YY"
							month := Month nameOfMonth: firstAsNumber.
							day := Integer readFrom: aStream]]
				ifNotNil: ["YY-MM-DD"
					month := Month nameOfMonth: (Integer readFrom: aStream)]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	year
		ifNil: [year := Integer readFrom: aStream]
		ifNotNil: [day := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _  year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self year: year month: month day: day! !
!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 16:33:59' prior: 16891335 overrides: 50361598!
           readFrom: aStream 
	"Read a Month from the stream in any of the forms:  
		<month> <year>			(April 1982; APR-82; 4.82; APR82)  
		<month> <year>			(April, 1982; 4/82)
		<year>-<month>			(1982-04) (ISO8601)"
	"
	Month readFrom: 'July 1998' readStream
	"
	| month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isLetter
		ifTrue: ["MonthName-YY or YY-MonthName"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip]]
		ifFalse: ["MM-YY or YY-MM"
			month _ year 
				ifNil: ["MM-YY"
					Month nameOfMonth: firstAsNumber ]
				ifNotNil: ["YY-MM"
					Month nameOfMonth: (Integer readFrom: aStream)]].

	year ifNil: [
		[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
		year := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _ year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self month: month year: year! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 15:07:01' prior: 16980685 overrides: 50361598!
                             readFrom: aStream 
	"Read a Week from the stream in any of the forms:  
		<year>-W<week>			(2009-W01) (ISO8601)"
	| weekNumber yearNumber firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [yearNumber := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream next = $W ifFalse: [
		self error: 'Invalid Format' ].

	weekNumber _ Integer readFrom: aStream.
	weekNumber < 1 ifTrue: [ self error: 'Invalid Format' ].
	(yearNumber < 100 and: [yearNumber >= 0])  ifTrue: [
		yearNumber _ yearNumber < 69 
			ifTrue: [2000 + yearNumber]
			ifFalse: [1900 + yearNumber]].

	^ self yearNumber: yearNumber weekNumber: weekNumber! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 15:07:07' prior: 16983432 overrides: 50361598!
                        readFrom: aStream 

	| year sign |
	sign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isDigit] whileFalse: [aStream skip].
	year := (Integer readFrom: aStream) * sign.
	^ self yearNumber: year! !
!InstructionPrinter methodsFor: 'printing' stamp: 'jmv 5/26/2022 15:13:56' prior: 16873142!
              print: instruction 
	"Append to the receiver a description of the bytecode, instruction." 

	| code |
	stream tab: self indent.
	printPC ifTrue: [stream print: oldPC; space].
	stream tab: (innerIndents at: oldPC).
	stream nextPut: $<.
	oldPC to: scanner pc - 1 do: 
		[:i | 
		code := (method at: i) printStringBase: 16.
		stream nextPut: 
			(code size < 2
				ifTrue: [$0]
				ifFalse: [code at: 1]).
		stream nextPut: code last; space].
	stream skipBack.
	stream nextPut: $>.
	stream space.
	stream nextPutAll: instruction.
	stream newLine.
	oldPC := scanner pc.
	"(InstructionPrinter compiledMethodAt: #print:) symbolic."
! !
!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'jmv 5/26/2022 15:13:58' prior: 16925607 overrides: 50364605!
                  print: instruction 
	"Append to the receiver a description of the bytecode, instruction." 

	| code |
	stream tab: self indent.
	labelling
		ifTrue: [stream print: oldPC - method initialPC; space]
		ifFalse: [stream tab].
	stream tab: (innerIndents at: oldPC).
	self printCode ifTrue: [
		stream nextPut: $<.
		 oldPC to: scanner pc - 1 do: [ :i |
			code := (method at: i) printStringBase: 16.
			stream
				nextPut: (code size < 2 ifTrue: [$0] ifFalse: [code at: 1]);
				nextPut: code last;
				space].
		 stream skipBack; nextPut: $>; space].
	stream nextPutAll: instruction.
	stream newLine.
	labelling ifFalse: [
		(labels at: scanner pc + 1) ~~ false ifTrue:
			[stream nextPutAll: (labels at: scanner pc + 1); nextPut: $:; newLine]].
	oldPC := scanner pc! !
!Message methodsFor: 'printing' stamp: 'jmv 5/26/2022 15:14:00' prior: 16883559 overrides: 16902975!
                             printOn: stream

	args isEmpty ifTrue: [^ stream nextPutAll: selector].
	args with: selector keywords do: [:arg :word |
		stream nextPutAll: word.
		stream nextPutAll: ' ('.
		arg printOn: stream.
		stream nextPutAll: ') '.
	].
	stream skipBack.
! !
!Pragma methodsFor: 'printing' stamp: 'jmv 5/26/2022 15:14:02' prior: 16914774 overrides: 16902975!
  printOn: aStream
	aStream nextPut: $<.
	self keyword precedence = 1
		ifTrue: [ aStream nextPutAll: self keyword ]
		ifFalse: [
			self keyword keywords with: self arguments do: [ :key :arg |
				aStream nextPutAll: key; space; print: arg; space ].
			aStream skipBack ].
	aStream nextPut: $>.! !
!Collection methodsFor: 'printing' stamp: 'jmv 5/26/2022 15:14:05' prior: 16823622!
   printElementsOn: aStream
	aStream nextPut: $(.
	self do: [:element | aStream print: element; space].
	self isEmpty ifFalse: [aStream skipBack].
	aStream nextPut: $)! !
!SequenceableCollection methodsFor: 'converting' stamp: 'jmv 5/26/2022 16:34:04' prior: 16934094!
                      printStringWithNewline
	"Convert to a string with returns between items.  Elements are usually strings.
	 Useful for labels for PopUpMenus.
	#('something' 'there') asStringWithNewline
	"
	
	^String streamContents: [ :labelStream |
		self do: [ :each |
			each isString
				ifTrue: [ labelStream nextPutAll: each; newLine ]
				ifFalse: [
					each printOn: labelStream.
					labelStream newLine ]].
		self size > 0 ifTrue: [ labelStream skipBack ]]! !
!ArrayedCollection class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 15:14:09' prior: 16781765!
                  newFromStream: s
	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."
	| len |

	self isPointers | self isWords not ifTrue: [^ super newFromStream: s].
		"super may cause an error, but will not be called."

	s next = 16r80 ifTrue:
		["A compressed format.  Could copy what BitMap does, or use a 
		special sound compression format.  Callers normally compress their own way."
		^ self error: 'not implemented'].
	s skipBack.
	len _ s nextSignedInt32BigEndian: true.
	^ s nextWordsInto: (self basicNew: len)! !
!Float32Array methodsFor: 'printing' stamp: 'jmv 5/26/2022 15:14:11' prior: 16859649 overrides: 50364680!
            printElementsOn: aStream
	"FloatArray elements are answered as 64 bit Float, but are really 32 bit Float.
	When printing, print them as 32 bit Float."
	aStream nextPut: $(.
	self do: [ :element |
		element printAsIEEE32BitPrecisionFloatOn: aStream base: 10.
		aStream space].
	self isEmpty ifFalse: [aStream skipBack].
	aStream nextPut: $)! !
!WeakSet methodsFor: 'public' stamp: 'jmv 5/26/2022 15:14:13' prior: 16980371 overrides: 50364680!
      printElementsOn: aStream
	| oldPos |
	aStream nextPut: $(.
	oldPos _ aStream position.
	self do: [:element | aStream print: element; space].
	aStream position > oldPos ifTrue: [aStream skipBack "remove the extra space"].
	aStream nextPut: $)! !
!Base64MimeConverter methodsFor: 'conversion' stamp: 'jmv 5/26/2022 15:14:16' prior: 16784316!
            mimeEncode
	"Do conversion reading from dataStream writing to mimeStream"
	"Convert from data to 6 bit characters."

	| phase1 phase2 byte nib lineLength |
	ToCharTable ifNil: [ self class initializeTables ].
	phase1 := phase2 := false.
	lineLength := 0.
	[dataStream atEnd] whileFalse: [
		(multiLine and:[lineLength >= 70]) ifTrue: [ mimeStream newLine.  lineLength := 0. ].
		data := byte := dataStream next.
		nib := (data bitAnd: 16rFC) bitShift: -2.
		mimeStream nextPut: (ToCharTable at: nib+1).
		(byte := dataStream next) ifNil: [byte := 0. phase1 := true].
		data := ((data bitAnd: 3) bitShift: 8) + byte.
		nib := (data bitAnd: 16r3F0) bitShift: -4.
		mimeStream nextPut: (ToCharTable at: nib+1).
		(byte := dataStream next) ifNil: [byte := 0. phase2 := true].
		data := ((data bitAnd: 16rF) bitShift: 8) + (byte).
		nib := (data bitAnd: 16rFC0) bitShift: -6.
		mimeStream nextPut: (ToCharTable at: nib+1).
		nib := (data bitAnd: 16r3F).
		mimeStream nextPut: (ToCharTable at: nib+1).

		lineLength := lineLength + 4.].
	phase1 ifTrue: [
		mimeStream skip: -2; nextPut: $=; nextPut: $=.
		^ mimeStream].
	phase2 ifTrue: [
		mimeStream skipBack; nextPut: $=.
		^ mimeStream]! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 5/26/2022 15:14:19' prior: 16946114!
                            nextNumber
	"Answer a number from the (text) stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element = $- or: [element = $. or: [element = $)]]]]] whileFalse.
	element ifNil: [^nil].
	self skipBack.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/26/2022 15:14:30' prior: 16913824!
     back
	"Go back one element and return it."
	self position = 0 ifTrue: [ self error: 'CantGoBack' ].
	self skipBack.
	^ self peek! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/26/2022 15:53:03' prior: 16914067!
                               peekBack
	"Return the element at the previous position, without changing position."

	self position = 0 ifTrue: [ self error: 'CantGoBack' ].
	self skipBack.
	^self next! !
!PositionableStream methodsFor: 'positioning' stamp: 'jmv 5/26/2022 15:11:51' prior: 16914345!
                    skip: n 
	"Skips the next amount objects in the receiver's future sequence values."

	self position: (self position + n min: self contents size).! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/23/2022 17:47:39' prior: 50359770!
             nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator ch done |
	terminator _ $!!.
	^self collectionSpecies streamContents: [ :strm |
		self skipSeparators.
		done _ false.
		[done not and: [(ch _ self next) ~~ nil]] whileTrue: [
			done _ false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done _ true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/21/2022 10:57:33' prior: 16914541!
                               skipSeparators
	| prevPosition |
	[self atEnd]
		whileFalse: [
			prevPosition _ self position.
			self next isSeparator ifFalse: [
				self position: prevPosition.
				^ self ]]! !
!WriteStream methodsFor: 'character writing' stamp: 'jmv 5/26/2022 15:14:44' prior: 16983082!
            ensureNoSpace
	"If there is not one on the end, remove it."

	(position > 0 and: [(collection at: position) = Character space]) 
		ifTrue: [self skipBack].! !
!StandardFileStream methodsFor: 'access' stamp: 'jmv 5/26/2022 15:14:52' prior: 16944523 overrides: 16914077!
                   peekFor: item 
	"Answer false and do not advance if the next element is not equal to item, or if this stream is at the end.  If the next element is equal to item, then advance over it and return true"
	| next |
	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"
	(next _ self next) ifNil: [^ false].
	item = next ifTrue: [^ true].
	self skipBack.
	^ false! !
!ReferenceStream methodsFor: 'writing' stamp: 'jmv 5/26/2022 15:15:36' prior: 16924593 overrides: 16835342!
     beginInstance: aClass size: anInteger
	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."
	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.
	In ReferenceStream, class is just 5 bytes for shared symbol.
	SmartRefStream puts out the names and number of class's instances variables for checking.
6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "

	| short ref |
	short _ true.	"All tests for object header that can be written in 4 bytes"
	anInteger <= 254 ifFalse: [short _ false].	"one byte size"
	ref _ references at: aClass name ifAbsent: [short _ false. nil].
	ref isInteger ifFalse: [short _ false].
	short ifTrue: [short _ (ref < 65536) & (ref > 0) "& (ref ~= self vacantRef)"].  "vacantRef is big"
	short ifTrue: [
		byteStream skipBack.
		short _ byteStream next = 9.
		byteStream skip: 0].	"ugly workaround"
	short 
		ifTrue: ["passed all the tests!!"
			byteStream skipBack; nextPut: 16; "type = short header"
				nextPut: anInteger + 1;	"size is short"
				nextUnsignedInt16Put: ref bigEndian: true ]
		ifFalse: [
			"default to normal longer object header"
			byteStream nextUnsignedInt32Put: anInteger + 1 bigEndian: true.
			self nextPut: aClass name].! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/26/2022 15:15:15' prior: 50359820!
                  xDigit
	"Form a number."

	tokenType := #number.
	(aheadChar = DoItCharacter and: [source atEnd
			and:  [source skipBack. source next ~= DoItCharacter]])
		ifTrue: [source skipBack "Read off the end last time"]
		ifFalse: [source skipBack; skipBack].
	token := [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].
	self step; step! !
!DifferenceFinder methodsFor: 'private' stamp: 'jmv 5/26/2022 15:15:18' prior: 16842889!
         linesIn: aString
	"
	LongestCommonSequenceFinder linesIn: 'x y'
	"
	^Array streamContents: [:strm | | cr read |
		cr := '
'.
		read := aString readStream.
		[read atEnd] whileFalse: [| line |
			line := read nextLine.
			read skipBack.
			read peek = cr last ifTrue: [line := line , cr].
			read skip.
			strm nextPut: line]]
! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 5/26/2022 15:15:24' prior: 50357495!
                     startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean
	"This menu is too big to fit comfortably on the screen.
	Break it up into smaller chunks, and manage the relative indices.
	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

"
(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; newLine]. s skipBack])
		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'.
"
	| nLines nLinesPer allLabels from to subset subLines index |
	allLabels := labelString lines.
	nLines _ allLabels size.
	lineArray ifNil: [lineArray _ Array new].
	nLinesPer _ segmentHeight // (PreferenceNG at: #standardMenuFont) lineSpacing - 5.
	from := 1.
	[ true ] whileTrue: [
		to := (from + nLinesPer) min: nLines.
		subset := (allLabels copyFrom: from to: to) asOrderedCollection.
		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])
			before: subset first.
		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].
		subLines _ (Array with: 1) , subLines.
		index := (PopUpMenu labels: subset printStringWithNewline lines: subLines)
					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
		index = 1
			ifTrue: [from := to + 1.
					from > nLines ifTrue: [ from := 1 ]]
			ifFalse: [index = 0 ifTrue: [^ 0].
					^ from + index - 2]]! !
!PopUpMenu class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 16:34:10' prior: 16913654!
                             labelArray: labelArray lines: lineArray icons: icons
	"Answer an instance of me whose items are in labelArray, with lines 
	drawn after each item indexed by anArray. 2/1/96 sw"

	labelArray isEmpty ifTrue: [self error: 'Menu must not be zero size'].
	^ self
		labels: (String streamContents: [ :stream |
			labelArray do: [:each | stream nextPutAll: each; newLine].
			stream skipBack "remove last newline"])
		lines: lineArray
		icons: icons

"Example:
	(PopUpMenu labelArray: #('frog' 'and' 'toad') lines: #() icons: #()) startUpWithCaption: 'Please pick one.'
"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5203-skip-skipBack-StreamUseCleanup-JuanVuletich-2022May26-16h33m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5202] on 30 May 2022 at 9:24:28 am'!
!Inspector methodsFor: 'selecting' stamp: 'jmv 5/30/2022 09:19:36' prior: 16871937!
 accept: aString

	| result |
	result _ self doItReceiver class compilerClass new
				evaluate: aString asPlainString readStream
				in: self doItContext
				to: self doItReceiver
				notifying: nil	"fix this"
				ifFail:  [^ false].
	acceptedContentsCache _ result printString.
	self replaceSelectionValue: result.	"may put contents back"
	self acceptedContentsChanged.
	^ true! !
!Scanner methodsFor: 'public access' stamp: 'jmv 5/30/2022 08:55:18' prior: 50363289!
             scanFieldNames: stringOrArray
	"Answer an Array of Strings that are the identifiers in the input string, 
	stringOrArray. If passed an Array, just answer with that Array, i.e., 
	assume it has already been scanned."

	| strm |
	(stringOrArray isMemberOf: Array)
		ifTrue: [^stringOrArray].
	self scan: stringOrArray asString asPlainString readStream.
	strm := (Array new: 10) writeStream.
	[tokenType == #doIt]
		whileFalse: [
			tokenType == #word ifTrue: [strm nextPut: token].
			self scanToken ].
	^strm contents

	"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !
!Parser methodsFor: 'private' stamp: 'jmv 5/30/2022 08:50:24' prior: 50363476!
     privateReadSelectorFrom: aMethodSource
	"Answer the message selector for the argument, aMethodSource, which should 
	 parse successfully up to the temporary declaration or the end of the 
	 method header."
	"Note: only intended to read the selector. Parser instance might be inconsistent afterwards.
	Optimized these kind of methods (compare the following):
	[ 100000 timesRepeat: [Parser new parseSelector: 'a ^#[123 123 123 123 123 123 123 123 987 987 987 987 987 987 987 987]'] ] timeToRun 4824
	[ 100000 timesRepeat: [Parser new privateReadSelectorFrom: 'a ^#[123 123 123 123 123 123 123 123 987 987 987 987 987 987 987 987]'] ] timeToRun  342
	"

	| result |
	self initScannerForTokenization.
	self
		init: aMethodSource asString asPlainString readStream
		notifying: nil
		failBlock: [ ^nil ].
	encoder _ self.
	result _ self privateReadSelector.
	encoder _ failBlock _ nil.  "break cycles"
	^result! !
!Parser methodsFor: 'public access' stamp: 'jmv 5/30/2022 08:59:04' prior: 50363598!
                              parse: sourceStream class: class category: aCategory noPattern: noPattern doIt: doIt context: aContext notifying: aRequestor ifFail: aBlock

	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	
	| methNode repeatNeeded myStream sourceCode startPosition |
	
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		startPosition _ myStream position.
		sourceCode _ myStream upToEnd.
		myStream position: startPosition.
		self encoder init: class context: aContext notifying: self.
		"Protect against possible parsing failure"
		doIt ifTrue: [
			(sourceCode beginsWith: Scanner doItInSelector)
				ifTrue: [encoder selector: Scanner doItInSelector]
				ifFalse: [
					(sourceCode beginsWith: Scanner doItSelector)
						ifTrue: [encoder selector: Scanner doItSelector]]].
		self init: myStream notifying: aRequestor failBlock: [^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern doIt: doIt context: aContext ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ requestor text string asPlainString readStream ].
		repeatNeeded
	] whileTrue: [ encoder _ self encoder class new ].

	methNode sourceText: sourceCode.
	"See #xBacktick"
	sentInLiterals do: [ :sym | encoder noteOptimizedSelector: sym ].

	^ methNode! !
!Parser methodsFor: 'public access' stamp: 'jmv 5/30/2022 09:17:34' prior: 16908965!
          parse: sourceStreamOrString class: behavior noPattern: aBoolean
	| stream |
	stream _ (sourceStreamOrString is: #Stream)
		ifTrue: [sourceStreamOrString]
		ifFalse: [sourceStreamOrString asPlainString readStream].
	^ self
		parse: stream
		class: behavior
		noPattern: aBoolean
		context: nil
		notifying: nil
		ifFail: [^nil]! !
!MethodNode methodsFor: 'source mapping' stamp: 'jmv 5/30/2022 09:04:09' prior: 16890071!
                            rawSourceRangesAndMethodDo: aBinaryBlock
	"Evaluate aBinaryBlock with the rawSourceRanges and method generated from the receiver."

	| methNode method |
	methNode := encoder classEncoding parserClass new
					encoderClass: encoder class;
					parse: (sourceText "If no source, use decompile string as source to map from"
							ifNil: [self decompileString]
							ifNotNil: [sourceText asPlainString])
					class: self methodClass.
	method := methNode generate.  "set bytecodes to map to"
	^aBinaryBlock
		value: methNode encoder rawSourceRanges
		value: method! !
!MethodNode methodsFor: 'debugger support' stamp: 'jmv 5/30/2022 09:04:20' prior: 16890177!
              blockExtentsToTempsMap
	"Answer a Dictionary of blockExtent to temp locations for the current method.
	 This is used by the debugger to locate temp vars in contexts.  A temp map
	 entry is a pair of the temp's name and its index, where an index is either an
	 integer for a normal temp or a pair of the index of the indirect temp vector
	 containing  the temp and the index of the temp in its indirect temp vector."

	^encoder blockExtentsToTempsMap ifNil:
		[| methNode |
		methNode := encoder classEncoding parserClass new
						encoderClass: encoder class;
						parse: (sourceText
							ifNil: [self decompileString]
							ifNotNil: [sourceText asPlainString])
						class: self methodClass.
		"As a side effect generate: creates data needed for the map."
		methNode generate.
		methNode encoder blockExtentsToTempsMap]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5204-AvoidTextWhenParsing-JuanVuletich-2022May30-09h22m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5204] on 30 May 2022 at 11:02:28 am'!
!ByteArray methodsFor: 'testing' stamp: 'jmv 5/26/2022 16:04:32' overrides: 16823949!
   is: aSymbol
	^#ByteArray = aSymbol or: [ super is: aSymbol ]! !
!Stream methodsFor: 'testing' stamp: 'jmv 5/30/2022 10:53:58'!
 isWriteOnly
	"To be redefined in subclasses that can't do #next"
	^ false! !
!ReadStream methodsFor: 'accessing' stamp: 'jmv 5/28/2022 17:15:19' overrides: 16913904!
                          next: anInteger putAll: aString startingAt: startIndex
	self shouldNotImplement! !
!ReadStream methodsFor: 'accessing' stamp: 'jmv 5/28/2022 17:16:40' overrides: 16945788!
                    nextPutAll: aCollection
	self shouldNotImplement! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:57:04' overrides: 16913861!
                  next: n
	self isWriteOnly ifTrue: [
		self error: 'This is a Write-Only Stream' ].
	^super next: n! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:58:13' overrides: 16913883!
next: n into: aCollection startingAt: startIndex
	self isWriteOnly ifTrue: [
		self error: 'This is a Write-Only Stream' ].
	^super next: n into: aCollection startingAt: startIndex! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:59:06' overrides: 16913981!
              nextWordsInto: aBitmap
	self isWriteOnly ifTrue: [
		self error: 'This is a Write-Only Stream' ].
	^super nextWordsInto: aBitmap! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:59:34' overrides: 16914055!
  peek
	self isWriteOnly ifTrue: [
		self error: 'This is a Write-Only Stream' ].
	^super peek! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:59:58' overrides: 16914114!
      upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	self isWriteOnly ifTrue: [
		self error: 'This is a Write-Only Stream' ].
	^super upTo: delimiter delimiterIsTerminator: delimiterIsTerminator! !
!WriteStream methodsFor: 'testing' stamp: 'jmv 5/30/2022 10:54:20' overrides: 50365239!
                        isWriteOnly
	^true! !
!ReadWriteStream methodsFor: 'testing' stamp: 'jmv 5/30/2022 10:54:37' overrides: 50365294!
              isWriteOnly
	^false! !
!TextModel methodsFor: 'undoable commands' stamp: 'jmv 5/30/2022 10:15:38' prior: 16968790!
             logUndoAndReplaceFrom: start to: stop with: replacement
	"As requested."

	| command now |
	"Time millisecondClockValue rolls over and is generally not adviced.
	But here, we don't care. A user edit doing during rollover would be split  in two, as if the user did a pause.
	Not a problem."
	
	now _ Time millisecondClockValue.
	command _ self commandForReplaceFrom: start to: stop with: replacement.
	(stop+1 = start and: [ lastEditTimeStamp notNil and: [ now - lastEditTimeStamp < 1000 and: [start = undoRedoCommands peekLast stopPosition] ]])
		ifTrue: [
			"Don't use the command we just built"
			undoRedoCommands peekLast appendToNew: replacement
			]
		ifFalse: [
			undoRedoCommands
				nextPut: command;
				truncateAtPosition.	"To disable redo of previous commands, now invalidated."
			].
	command doOn: self.
	lastEditTimeStamp _ now! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:18:25' prior: 16914092!
                   untilAnySatisfying: aBlock
	| c |
	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				c := self peek.
				(aBlock value: c) not]]
			whileTrue: [write nextPut: self next]].! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 5/30/2022 10:28:24' prior: 50339646!
                        debugIt

	self lineSelectAndEmptyCheck: [^self].
	self 
		afterCompiling: self selection
		do: [ :compiler :method :receiver :context | method ifNotNil: [ self debug: method receiver: receiver in: context ]]
		ifFail: [].! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 5/30/2022 10:28:37' prior: 16939472!
        evaluateSelectionAndDo: aBlock ifFail: failBlock profiled: doProfile
	"Treat the current selection as an expression; evaluate it and return the result
	3 +4
	"	
	
	self lineSelectAndEmptyCheck: [^ ''].
	^self evaluate: self selection andDo: aBlock ifFail: failBlock profiled: doProfile! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 5/30/2022 10:43:50' prior: 16940463!
 fileItIn
	"Make a Stream on the text selection and fileIn it."

	self selection fileIn! !

TextEditor removeSelector: #selectionAsStream!

!methodRemoval: TextEditor #selectionAsStream stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
selectionAsStream
	"Answer a ReadStream on the text that is currently  selected."

	^ReadWriteStream
		on: self privateCurrentString
		from: self startIndex
		to: self stopIndex - 1!

RWBinaryOrTextStream removeSelector: #upToEnd!

!methodRemoval: RWBinaryOrTextStream #upToEnd stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
upToEnd
	"Must override to get class right."
	| newArray |
	newArray _ (isBinary ifTrue: [ByteArray] ifFalse: [String]) new: self size - self position.
	^ self nextInto: newArray!

ReadWriteStream class removeSelector: #readingOn:!

!methodRemoval: ReadWriteStream class #readingOn: stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
readingOn: aCollection
	"Answer an instance that can be used like a ReadStream, i.e. it is born ready to read over aCollection."

	| instance |
	instance _ self with: aCollection.
	instance position: 0.
	^instance!

WriteStream class removeSelector: #on:from:to:!

!methodRemoval: WriteStream class #on:from:to: stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
on: aCollection from: firstIndex to: lastIndex 
	"Answer an instance of me on a copy of the argument, aCollection, 
	determined by the indices firstIndex and lastIndex. Position the instance 
	at the beginning of the collection."

	^self basicNew
		on: aCollection
		from: firstIndex
		to: lastIndex!

WriteStream removeSelector: #on:from:to:!

!methodRemoval: WriteStream #on:from:to: stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
on: aCollection from: firstIndex to: lastIndex 
	| len |
	collection _ aCollection.
	readLimit _ 
		writeLimit _ lastIndex > (len _ collection size)
						ifTrue: [len]
						ifFalse: [lastIndex].
	position _ firstIndex <= 1
				ifTrue: [0]
				ifFalse: [firstIndex - 1]!

WriteStream removeSelector: #nextPutAllString:withAttributes:!

!methodRemoval: WriteStream #nextPutAllString:withAttributes: stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd!

PositionableStream class removeSelector: #on:from:to:!

!methodRemoval: PositionableStream class #on:from:to: stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
on: aCollection from: firstIndex to: lastIndex 
	"Answer a new instance of me, streaming over a copy of aCollection from
	firstIndex to lastIndex."

	^self basicNew on: (aCollection copyFrom: firstIndex to: lastIndex)!

PositionableStream removeSelector: #upToEnd!

!methodRemoval: PositionableStream #upToEnd stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
upToEnd
	"Answer a subcollection from the current access position through the last element of the receiver."

	| newStream |
	newStream := WriteStream on: (self collectionSpecies new: 100).
	[self atEnd] whileFalse: [ newStream nextPut: self next ].
	^ newStream contents!

PositionableStream removeSelector: #last!

!methodRemoval: PositionableStream #last stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
last
	"Return the final element in the receiver"

	^ collection at: position!

Stream removeSelector: #upToEnd!

!methodRemoval: Stream #upToEnd stamp: 'Install-5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st 6/16/2022 07:24:49'!
upToEnd
	"answer the remaining elements in the string"
	| elements |
	elements _ OrderedCollection new.
	[ self atEnd ] whileFalse: [ 
		elements add: self next ].
	^elements!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5205-Stream-cleanup-JuanVuletich-2022May30-10h55m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5205] on 30 May 2022 at 12:15:50 pm'!
!WriteStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/30/2022 12:12:54' prior: 16983202!
          timeStamp
	"Append the current time to the receiver as a String."
	self nextChunkPut:	"double string quotes and !!s"
		(self collectionSpecies streamContents: [:s | Smalltalk timeStamp: s]) printString.
	self newLine! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5206-WriteStream-fix-JuanVuletich-2022May30-12h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5207] on 31 May 2022 at 12:05:25 pm'!
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/31/2022 11:55:07' prior: 16962618!
         runSuite: suite
	running ifNotNil: [ ^ self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	running _ [
	[ result _ suite run ] ensure: [
		running _ nil.
		suite removeDependent: self.
		runSemaphore signal.
		UISupervisor whenUIinSafeState: [
			self updateWindow: result.
			self changed: #runTests.
			self changed: #runOneTest ]]] newProcess.
	self runWindow.
	self changed: #runTests.
	self changed: #runOneTest.
	running
		name: 'TestRunner';
		priority: Processor userBackgroundPriority;
		resume.! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/31/2022 11:55:11' prior: 16962642!
               runSuiteProfiled: suite
	running ifNotNil: [ ^ self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	running _ [
	[ result _ TimeProfileBrowser onBlock: [ suite run ]] ensure: [
		running _ nil.
		suite removeDependent: self.
		runSemaphore signal.
		UISupervisor whenUIinSafeState: [
			self updateWindow: result.
			self changed: #runTests.
			self changed: #runOneTest ]]] newProcess.
	self runWindow.
	self changed: #runTests.
	self changed: #runOneTest.
	running
		name: 'TestRunner';
		priority: Processor userBackgroundPriority;
		resume.! !
!ProgressiveTestRunner methodsFor: 'evaluating - private' stamp: 'jmv 5/31/2022 11:38:00' prior: 16920159!
                   createProgressBarAndRun

	self createProgressBar.
	[ self runSuiteShowingProgress ]
		forkAt: Processor userBackgroundPriority
		named: 'ProgressiveTestRunner'.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5207-runTestsAtBackgroundPriority-JuanVuletich-2022May31-11h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5207] on 31 May 2022 at 2:24:13 pm'!
!Object methodsFor: 'testing' stamp: 'jmv 5/30/2022 15:16:50'!
            isUtf8String
	"Overridden to return true in Utf8String, natch"
	^ false! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 5/27/2022 17:35:23'!
          digitValue
	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 
	otherwise. This is used to parse literal numbers of radix 2-36.
	$0 numericValue = 48
	$9 numericValue = 57
	$A numericValue = 65
	$Z numericValue = 90 
	$7 digitValue = 7 
	"

	| nv |
	nv _ value.
	(nv between: 48 and: 57)
		ifTrue: [ ^ nv - 48 ].
	(nv between: 65 and: 90)
		ifTrue: [ ^ nv - 55 ].
	^ -1! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 5/31/2022 14:22:15'!
              numericValue
self flag: #unicodeNeedsImprovement.
	^self iso8859s15Code ifNil: [255]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/27/2022 18:25:29'!
                               asLowercase
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^UnicodeCodePoint codePoint: ch asUnaccented asLowercase ].
	^self! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/27/2022 18:25:34'!
                            asUnaccented
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^UnicodeCodePoint codePoint: ch asUnaccented codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 5/30/2022 16:31:05'!
                          asText
	^ (Utf8String with: self) asText! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 5/30/2022 15:16:58' overrides: 50365586!
                             isUtf8String

	^true! !
!Utf8String methodsFor: 'initialization' stamp: 'jmv 5/30/2022 17:10:13' overrides: 16920235!
          initialize
	bytes _ `#[]`! !
!Utf8String methodsFor: 'printing' stamp: 'jmv 5/27/2022 17:33:58' overrides: 16902957!
           print
	Transcript show: self; newLine! !
!Utf8String methodsFor: 'printing' stamp: 'jmv 5/27/2022 17:33:50' overrides: 16902975!
                               printOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."

	self storeOn: aStream! !
!Utf8String methodsFor: 'printing' stamp: 'jmv 5/27/2022 17:33:44' overrides: 16903050!
  storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do: [ :i |
		aStream nextPut: (x _ self at: i).
		x = $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'! !
!Utf8String methodsFor: 'compatibility' stamp: 'jmv 5/30/2022 15:11:24'!
              contents
	^self! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/30/2022 14:23:03' prior: 50351381!
                          , aString
	^Utf8String withBytes: bytes, aString asUtf8Bytes.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5208-CodePoint-UtfString-JuanVuletich-2022May31-14h20m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5207] on 31 May 2022 at 2:38:12 pm'!
!VersionsBrowser methodsFor: 'init & update' stamp: 'jmv 5/31/2022 14:37:36' prior: 16978185!
                         scanVersionsOf: method class: class meta: meta category: category selector: selector
	| position stamp prevPos prevFileIndex preamble tokens sourceFilesCopy |
	selectorOfMethod _ selector.
	currentCompiledMethod _ method.
	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	self addedChangeRecord ifNotNil: [ :change |
		self addItem: change text: ('{1} (in {2})' format: { change stamp. change fileName }) ].
	listIndex _ 0.
	position _ method filePosition.
	sourceFilesCopy _ SourceFiles collect:
		[:x | x ifNotNil: [ x name asFileEntry readStream ]].
	method fileIndex = 0 ifTrue: [^ nil].
	file _ sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble _ file backChunk.
		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevFileIndex _ nil.
		prevPos _ nil.
		stamp _ ''.
		(preamble includesSubString: 'methodsFor:')
			ifTrue: [
				tokens _ Scanner new scanTokens: preamble.
				stamp _ CompiledMethod stampFrom: tokens.
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorMethodRef |
					prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: priorMethodRef.
					prevPos _ sourceFilesCopy filePositionFromSourcePointer: priorMethodRef ]].
 		self addItem:
				(ChangeRecord new file: file position: position type: #method
						class: class name category: category meta: meta stamp: stamp)
			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.
		position _ prevPos.
		prevPos notNil ifTrue: [
			file _ sourceFilesCopy at: prevFileIndex]].
	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].
	self clearSelections! !
!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'jmv 5/31/2022 14:37:31' prior: 16813300!
    scanVersionsOf: class
	"Scan for all past versions of the class comment of the given class"

	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |

	classOfMethod _ class.
	oldCommentRemoteStr _ class  organization commentRemoteStr.
	currentCompiledMethod _ oldCommentRemoteStr.
	selectorOfMethod _ #Comment.
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].

	sourceFilesCopy _ SourceFiles collect: [ :x | x ifNotNil: [x name asFileEntry readStream]].
	position _ oldCommentRemoteStr position.
	file _ sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.
	[ position notNil & file notNil]  whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble _ file backChunk.
		prevPos _ nil.
		stamp _ ''.
		(preamble includesSubString: 'commentStamp:')
			ifTrue: [
				tokens _ Scanner new scanTokens: preamble.
				stamp _ CompiledMethod field: #commentStamp: from: tokens ifAbsentOrNil: [ '' ].
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorRef |
					prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: priorRef.
					prevPos _ sourceFilesCopy filePositionFromSourcePointer: priorRef ]]
			ifFalse: [
				"The stamp get lost, maybe after a condenseChanges"
				stamp _ '<historical>'].
 		self addItem:
				(ChangeRecord new file: file position: position type: #classComment
						class: class name category: nil meta: class isMeta stamp: stamp)
			text: stamp , ' ' , class name , ' class comment'. 
		prevPos = 0 ifTrue: [ prevPos _ nil ].
		position _ prevPos.
		prevPos notNil ifTrue: [ file _ sourceFilesCopy at: prevFileIndex ]].
	sourceFilesCopy do: [ :x | x notNil ifTrue: [ x close ]].
	self clearSelections! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5209-backChunk-useIt-JuanVuletich-2022May31-14h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5209] on 31 May 2022 at 4:10:07 pm'!
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 5/31/2022 15:53:55'!
              grownTo: newSize

	| grownCollection |
	grownCollection _ self class ofSize: newSize.
	grownCollection replaceFrom: 1 to: self size with: self startingAt: 1.
	^grownCollection! !
!Text methodsFor: 'copying' stamp: 'jmv 5/31/2022 15:57:36' overrides: 50365810!
                            grownTo: newSize
	"Accommodate for the fact that string could hold a String or an ArrayOfCharactersAndCodePoints
	when being streamed to."

	| grownText |
	grownText _ Text fromString: (string class new: newSize).
	grownText replaceFrom: 1 to: self size with: self startingAt: 1.
	^grownText! !
!WriteStream methodsFor: 'private' stamp: 'jmv 5/31/2022 15:54:26' prior: 16983231!
     growTo: anInteger
	"Grow the collection by creating a new bigger collection and then
	copy over the contents from the old one. We grow by doubling the size.

	anInteger is the required minimal new size of the collection "

	| oldSize newSize |
	oldSize _ collection size.
	newSize _ anInteger + (oldSize max: 20).
	collection _ collection grownTo: newSize.
	writeLimit _ collection size! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5210-growTo-grownTo-JuanVuletich-2022May31-16h09m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5209] on 31 May 2022 at 4:12:55 pm'!

Array variableSubclass: #ArrayOfCharactersAndCodePoints
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #ArrayOfCharactersAndCodePoints category: #'System-Text' stamp: 'Install-5211-AutoConvertStreamsForUnicode-JuanVuletich-2022May31-16h10m-jmv.001.cs.st 6/16/2022 07:24:49'!
Array variableSubclass: #ArrayOfCharactersAndCodePoints
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!Object methodsFor: 'testing' stamp: 'jmv 5/31/2022 15:34:04'!
  isUnicodeCodePoint
	"Overridden to return true in UnicodeCodePoint, natch"
	^ false! !
!SequenceableCollection methodsFor: 'converting' stamp: 'jmv 5/31/2022 15:14:15'!
                       asStreamResult
	^self! !
!SequenceableCollection methodsFor: 'testing' stamp: 'jmv 5/31/2022 15:37:21'!
                        canHoldCodePoints
	"Why not?"
	^true! !
!String methodsFor: 'converting' stamp: 'jmv 5/31/2022 15:39:11'!
                      thatCanHoldCodePoints
	^ArrayOfCharactersAndCodePoints withAll: self! !
!String methodsFor: 'testing' stamp: 'jmv 5/31/2022 15:38:15' overrides: 50365878!
     canHoldCodePoints
	"Nope. Needs something like Utf8String or Utf32String for that. Even an Array is better than us."
	^false! !
!ArrayOfCharactersAndCodePoints methodsFor: 'accessing' stamp: 'jmv 5/31/2022 15:59:57' overrides: 16901507!
                   at: index
	"Full compatibility with String"
	^(super at: index) ifNil: [ `Character null` ].! !
!ArrayOfCharactersAndCodePoints methodsFor: 'converting' stamp: 'jmv 5/31/2022 15:14:28' overrides: 50365874!
                  asStreamResult
	^Utf8String newFrom: self! !
!Text methodsFor: 'converting' stamp: 'jmv 5/31/2022 15:15:58' overrides: 50365874!
                               asStreamResult
	self setString: string asStreamResult setRuns: runs.
	^self! !
!Text methodsFor: 'converting' stamp: 'jmv 5/31/2022 15:39:54'!
                 thatCanHoldCodePoints
	string _ string thatCanHoldCodePoints! !
!Text methodsFor: 'testing' stamp: 'jmv 5/31/2022 15:37:39' overrides: 50365878!
               canHoldCodePoints
	"Ask our string"
	^string canHoldCodePoints! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/31/2022 15:34:13' overrides: 50365868!
 isUnicodeCodePoint
	^true! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/31/2022 15:50:25' overrides: 16785654!
                            new: sizeRequested
	^self withBytes: (ByteArray new: sizeRequested)! !
!SequenceableCollection class methodsFor: 'stream creation' stamp: 'jmv 5/31/2022 15:27:41' prior: 16935216!
            streamContents: blockWithArg estimatedSize: estimatedSize

	| stream originalContents |
	
	stream _ WriteStream on: (self ofSize: estimatedSize).
	blockWithArg value: stream.
	originalContents _ stream originalContents.
	
	^stream position = originalContents size
		ifTrue: [ originalContents asStreamResult ]
		ifFalse: [ stream contents ]! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 15:28:46' prior: 16913831 overrides: 16945726!
                       contents
	"Answer with a copy of my collection from 1 to readLimit."

	^ (collection copyFrom: 1 to: readLimit) asStreamResult! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 15:27:30' prior: 16982972 overrides: 50365948!
                    contents
	readLimit _ readLimit max: position.
	^(collection copyFrom: 1 to: position) asStreamResult! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 15:40:16' prior: 16982999 overrides: 16945776!
             nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	(anObject isUnicodeCodePoint and: [collection canHoldCodePoints not]) ifTrue: [
		collection _ collection thatCanHoldCodePoints ].
	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position _ position + 1.
			^collection at: position put: anObject]! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 15:43:32' prior: 16983010 overrides: 16945788!
                nextPutAll: aCollection

	| newEnd |
	(aCollection canHoldCodePoints and: [collection canHoldCodePoints not]) ifTrue: [
		collection _ collection thatCanHoldCodePoints ].
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd _ position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position _ newEnd.! !
!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 15:28:17' prior: 16922568 overrides: 50365956!
                            contents
	"Answer with a copy of my collection from 1 to readLimit."

	readLimit _ readLimit max: position.
	^ (collection copyFrom: 1 to: readLimit) asStreamResult! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5211-AutoConvertStreamsForUnicode-JuanVuletich-2022May31-16h10m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5211] on 1 June 2022 at 9:18:03 am'!
!WriteStream methodsFor: 'accessing' stamp: 'jmv 3/12/2017 18:55:36'!
 nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5212-nextPutAllStringwithAttributes-stillHasSendersInStyledText-JuanVuletich-2022Jun01-09h13m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5211] on 1 June 2022 at 9:21:20 am'!
!SystemDictionary methodsFor: 'ui' stamp: 'jmv 5/25/2014 15:54' prior: 50357762!
                    beep
	"
	Smalltalk beep
	"
	Preferences soundsEnabled ifTrue: [
		Smalltalk
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5213-DontUseMissingPreferenceNGs-JuanVuletich-2022Jun01-09h20m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5213] on 1 June 2022 at 11:12:10 am'!
!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 6/1/2022 10:45:26' prior: 16807424 overrides: 16820774!
                          acceptedStringOrText
	"return the source code that shows in the bottom pane"

	| sel class changeType answer |
	self changed: #clearUserEdits.
	currentClassName ifNil: [^ myChangeSet preambleString ifNil: ['']].
	class _ self selectedClassOrMetaClass.
	(sel _ currentSelector)
		ifNotNil: [
			changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).
			changeType == #remove
				ifTrue: [^'Method has been removed (see versions)'].
			changeType == #addedThenRemoved
				ifTrue: [^'Added then removed (see versions)'].
			changeType == #movedToOtherPackage
				ifTrue: [^'Method was moved to some other package'].
			class ifNil: [^'Method was added, but cannot be found!!'].
			(class includesSelector: sel)
				ifFalse: [^'Method was added, but cannot be found!!'].
			answer _  (class sourceCodeAt: sel).
			(#(prettyPrint prettyLineDiffs prettyWordDiffs) includes: self contentsSymbol) ifTrue: [
				answer _ (class compilerClass new
						format: answer
						in: class 
						notifying: nil)].
			self showingAnyKindOfDiffs
				ifTrue: [ answer _ (self diffFromPriorSourceFor: answer) ].
			^ answer ]
		ifNil: [
			^ String streamContents: [ :strm |
				(myChangeSet classChangeAt: currentClassName) do: [ :each |
					each == #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; newLine].
					each == #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'; newLine].
					each == #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; newLine].
					each == #add ifTrue: [strm nextPutAll: 'Class definition was added.'; newLine].
					each == #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; newLine].
					each == #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; newLine].
					each == #comment ifTrue: [strm nextPutAll: 'New class comment.'; newLine].
					each == #movedToOtherPackage ifTrue: [strm nextPutAll: 'Class was moved to some other package.'; newLine].
				]]].! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 6/1/2022 10:48:05' prior: 16785940!
                            firstPrecodeCommentFor:  selector
	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"

	| parser source tree |
	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"
	(MessageSet isPseudoSelector: selector)
		ifTrue: [
			"Not really a selector"
			^ nil].
	source _ self sourceCodeAt: selector asSymbol ifAbsent: [^ nil].
	parser _ self parserClass new.
	tree _ 
		parser
			parse: source readStream
			class: self
			noPattern: false
			context: nil
			notifying: nil
			ifFail: [^ nil].
	^ (tree comment ifNil: [^ nil]) first! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 6/1/2022 10:46:20' prior: 16815144!
               browseClassVarRefs 
	"Put up a menu offering all class variable names; if the user chooses one, open up a message-list browser on all methods that refer to the selected class variable"

	| lines labelStream allVars index owningClasses |
	lines _ OrderedCollection new.
	allVars _ OrderedCollection new.
	owningClasses _ OrderedCollection new.
	labelStream _ String writeStream.
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class classVarNames asArray sort.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var.
			owningClasses add: class].
		vars isEmpty ifFalse: [ lines add: allVars size ]].
	labelStream contents isEmpty ifTrue: [^Smalltalk beep]. "handle nil superclass better"
	index _ (PopUpMenu labels: labelStream contents lines: lines) startUpMenu.
	index = 0 ifTrue: [^ self].
	Smalltalk browseAllCallsOn:
		((owningClasses at: index) classPool associationAt: (allVars at: index))! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 6/1/2022 10:47:21' prior: 16815193!
                          chooseClassVarName 
	"Present the user with a list of class variable names and answer the one selected, or nil if none"

	| lines labelStream  allVars index |
	lines _ OrderedCollection new.
	allVars _ OrderedCollection new.
	labelStream _ String writeStream.
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class classVarNames asArray sort.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	labelStream contents isEmpty ifTrue: [^Smalltalk beep]. "handle nil superclass better"
	index _ (PopUpMenu labels: labelStream contents lines: lines) startUpMenu.
	index = 0 ifTrue: [^ nil].
	^ allVars at: index! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 6/1/2022 10:47:34' prior: 50345787!
   chooseInstVarThenDo: aBlock
	"Put up a menu of all the instance variables in the receiver, and when
the user chooses one, evaluate aBlock with the chosen variable as its
parameter.  If the list is 6 or larger, then offer an alphabetical
formulation as an alternative. triggered by a 'show alphabetically' item
at the top of the list."

	| lines labelStream allVars index count offerAlpha |
	(count _ self allInstVarNames size) = 0 ifTrue: 
		[ ^ self inform: 'There are no\instance variables.' withNewLines ].

	allVars _ OrderedCollection new.
	lines _ OrderedCollection new.
	labelStream _ String writeStream.

	(offerAlpha _ count > 5)
		ifTrue: [
			lines add: 1.
			allVars add: 'show alphabetically'.
			labelStream nextPutAll: allVars first].
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class instVarNames.
		vars do: [ :var |
			labelStream position = 0 ifFalse: [labelStream newLine].
			labelStream nextPutAll: var.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	(lines notEmpty and: [ lines last = allVars size ]) ifTrue: [
		lines removeLast ].  "dispense with inelegant line beneath last item"
	index _ (PopUpMenu labels: labelStream contents lines: lines)
startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	(index = 1 and: [offerAlpha]) ifTrue: [
		^ self chooseInstVarAlphabeticallyThenDo: aBlock].
	aBlock value: (allVars at: index)! !
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 5/22/2022 20:21:04' prior: 16837480!
fromString: aString


	^ self readFrom: aString readStream.! !
!Duration class methodsFor: 'squeak protocol' stamp: 'jmv 5/22/2022 20:21:16' prior: 16845266!
  fromString: aString
	"
	Extended to accept non-ANSI formats, such as:
		Duration fromString: '1:50:00'
		Duration fromString: '5:30.5'
		Duration fromString: '1:6:50:00'
		Duration fromString: '3.5h'
		Duration fromString: '2.5min'
		Duration fromString: '1.5s'
		Duration fromString: '200s'
		Duration fromString: '200ms'
	"
	| colons s |

	"If aString includes at least one $:, complete ANSI format"
	colons _ aString occurrencesOf: $:.
	colons > 0 ifTrue: [
		s _ aString.
		[colons < 3] whileTrue: [
			s _ '00:', s.
			colons _ colons + 1 ].
		^ self readFrom: s readStream ].

	"'3.5h' means 3.5 hours"
	(aString endsWith: 'h') ifTrue: [
		^self hours: aString asNumber ].

	"'3.5min' means 3.5 minutes"
	(aString endsWith: 'min') ifTrue: [
		^self minutes: aString asNumber ].

	"'3ms' means 3 milliseconds"
	(aString endsWith: 'ms') ifTrue: [
		^self milliSeconds: aString asNumber ].

	"'3.5s' means 3.5 seconds"
	(aString endsWith: 's') ifTrue: [
		^self seconds: aString asNumber ].
	
	^nil! !
!Duration class methodsFor: 'squeak protocol' stamp: 'jmv 5/22/2022 20:58:59' prior: 16845327 overrides: 50361598!
readFrom: aStream
	"Formatted as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]"

	| sign days hours minutes seconds nanos nanosBuffer |
	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].
	days := (aStream upTo: $:) findPositiveInteger * sign.
	hours := (aStream upTo: $:) findPositiveInteger * sign.
	minutes := (aStream upTo: $:) findPositiveInteger * sign.
	seconds := (aStream upTo: $.) findPositiveInteger * sign.
	nanosBuffer := '000000000' copy.
	nanos := nanosBuffer writeStream.
	[aStream atEnd not and: [aStream peek isDigit]]
		whileTrue: [nanos nextPut: aStream next].
		
	^ self 
		days: days 
		hours: hours 
		minutes: minutes 
		seconds: seconds 
		nanoSeconds: (nanosBuffer findPositiveInteger * sign)

	"
		Duration readFrom: '0:00:00:00' readStream
		Duration readFrom: '0:00:00:00.000000001' readStream
		Duration readFrom: '0:00:00:00.9' readStream
		Duration readFrom: '0:00:00:00.99' readStream
		Duration readFrom: '0:00:00:00.99999999' readStream
		Duration readFrom: '0:00:00:00.999999999' readStream
		Duration readFrom: '0:00:00:00.100000000' readStream
		Duration readFrom: '0:00:00:00.001 ' readStream
		Duration readFrom: '0:00:00:00.1' readStream
		Duration readFrom: '0:00:00:01 ' readStream
		Duration readFrom: '0:12:45:45' readStream
		Duration readFrom: '1:00:00:00' readStream
		Duration readFrom: '365:00:00:00' readStream
		Duration readFrom: '-7:09:12:06.10' readStream
		Duration readFrom: '+0:01:02:3' readStream
 	"! !
!Time class methodsFor: 'smalltalk-80' stamp: 'jmv 5/22/2022 20:59:06' prior: 16972859 overrides: 50361598!
readFrom: aStream
	"Read a Time from the stream in the form:
		<hour>:<minute>:<second> <am/pm>

	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"

	| hour minute second ampm nanos nanosBuffer |
	hour := Integer readFrom: aStream.
	minute := 0.
	second := 0.
	nanosBuffer := '000000000' copy.
	nanos := nanosBuffer writeStream.
	(aStream peekFor: $:) 
		ifTrue: [
			minute := Integer readFrom: aStream.
			(aStream peekFor: $:) 
				ifTrue: [
					second := Integer readFrom: aStream].
					(aStream peekFor: $.)
						ifTrue: [
							[aStream atEnd not and: [aStream peek isDigit]]
								whileTrue: [nanos nextPut: aStream next]]].
	aStream skipSeparators.
	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: 
		[ampm := aStream next asLowercase.
	
	(ampm = $p and: [hour < 12]) ifTrue: [hour := hour + 12].
		(ampm = $a and: [hour = 12]) ifTrue: [hour := 0].
	
	(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].
	^ self 
		hour: hour 
		minute: minute 
		second: second 
		nanoSecond: nanosBuffer asNumber

	"Time readFrom: '2:23:09 pm' readStream"! !
!Time class methodsFor: 'squeak protocol' stamp: 'jmv 5/22/2022 20:21:28' prior: 16972909!
                            fromString: aString
	^ self readFrom: aString readStream! !
!Date methodsFor: 'printing' stamp: 'jmv 6/1/2022 10:52:59' prior: 16836349!
                       printFormat: formatArray 
	"Answer a String describing the receiver using the format denoted by the 
	argument, formatArray."

	^ String streamContents: [ :strm |
		self printOn: strm format: formatArray].! !
!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'jmv 6/1/2022 10:58:52' prior: 16925638 overrides: 16873169!
                        printInstructionsOn: aStream
	"Append to the stream, aStream, a description of each bytecode in the instruction stream."
	
	| label |
	labelling := true.
	labels := Array new: method size + 1 withAll: false.
	super printInstructionsOn: String writeStream.
	label := 0.
	labels withIndexDo:
		[:bool :index|
		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].
	labelling := false.
	super printInstructionsOn: aStream! !
!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'jmv 6/1/2022 10:58:56' prior: 16925655 overrides: 16873183!
           printInstructionsOn: aStream do: aBlock
	"Append to the stream, aStream, a description of each bytecode in the instruction stream.
	  Evaluate aBlock with the receiver, the scanner and the stream after each instruction."
	
	| label |
	labelling := true.
	labels := Array new: method size withAll: false.
	super printInstructionsOn: String writeStream do: [:ig :no :re|].
	label := 0.
	labels withIndexDo:
		[:bool :index|
		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].
	labelling := false.
	super printInstructionsOn: aStream do: aBlock! !
!ContextPart methodsFor: 'debugger access' stamp: 'jmv 6/1/2022 10:59:12' prior: 16832524!
         tempsAndValuesLimitedTo: sizeLimit indent: indent
	"Return a string of the temporary variabls and their current values"

	| tempNames title |
	^ String streamContents: [ :strm |
		tempNames _ self tempNames.
		1 to: self size do: [ :index |
			title _ tempNames size = self size ifTrue: [tempNames at: index]  ifFalse: [ 'argOrTemp', index printString ].
			indent timesRepeat: [strm tab].
			strm nextPutAll: title; nextPut: $:; space; tab.
			strm nextPutAll: 
				((self tempAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1)).
			strm newLine ]].! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'jmv 5/22/2022 20:22:33' prior: 16840308!
      case: dist
	"statements = keyStmts #CascadeFlag keyValueBlock ... keyStmts"

	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |
	nextCase := pc + dist.

	"Now add #CascadeFlag & keyValueBlock to statements"
	statements addLast: stack removeLast.
	stack addLast: #CaseFlag. "set for next pop"
	statements addLast: (self blockForCaseTo: nextCase).

	stack last == #CaseFlag
		ifTrue: "Last case"
			["ensure jump is within block (in case thenExpr returns weirdly I guess)"
			stack removeLast. "get rid of #CaseFlag"
			stmtStream := (self popTo: stack removeLast) readStream.
			
			elements := OrderedCollection new.
			b := OrderedCollection new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == #CascadeFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream next)).
						 b := OrderedCollection new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			"try find the end of the case"
			myExits := caseExits removeLast: elements size.
			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].
			thenJump := myExits isEmpty
							ifTrue: [ nextCase ]
							ifFalse: [ myExits max ].
			
			otherBlock := self blockTo: thenJump.
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)
					arguments: (Array with: cases with: otherBlock))].! !
!SequenceableCollection class methodsFor: 'stream creation' stamp: 'jmv 6/1/2022 10:57:20' prior: 50365933!
                          streamContents: blockWithArg estimatedSize: estimatedSize

	| stream originalContents |
	
	stream _ (self ofSize: estimatedSize) writeStream.
	blockWithArg value: stream.
	originalContents _ stream originalContents.
	
	^stream position = originalContents size
		ifTrue: [ originalContents asStreamResult ]
		ifFalse: [ stream contents ]! !
!String methodsFor: 'copying' stamp: 'jmv 6/1/2022 10:59:22' prior: 16947977!
                              join: aCollection 
	"'*' join: #('WWWWW' 'W  EW' 'zzzz')
		->  'WWWWW*W  EW*zzzz' "

	^String streamContents: [ :strm |
		aCollection
			do: [ :elem | strm nextPutAll: elem asString]
			separatedBy: [strm nextPutAll: self]].! !
!String methodsFor: 'converting' stamp: 'jmv 6/1/2022 10:59:18' prior: 16948072!
           asHex

	^String streamContents: [ :strm |
		self do: [ :ch | strm nextPutAll: ch hex ]].! !
!String methodsFor: 'converting' stamp: 'jmv 6/1/2022 11:00:06' prior: 50341249!
                   asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in out char rest did |
	in _ self readStream.
	out _ String writeStream.
	[ in atEnd ] whileFalse: [
		in peek = $<
			ifTrue: [in unCommand] 	"Absorb <...><...>"
			ifFalse: [(char _ in next) = $&
				ifTrue: [
					rest _ in upTo: $;.
					did _ out position.
					rest = 'lt' ifTrue: [out nextPut: $<].
					rest = 'gt' ifTrue: [out nextPut: $>].
					rest = 'amp' ifTrue: [out nextPut: $&].
					rest = 'deg' ifTrue: [out nextPut: $°].
					rest = 'quot' ifTrue: [out nextPut: $"].
					rest first = $# ifTrue: [ out nextPut: (Character numericValue: rest findPositiveInteger) ].
					did = out position ifTrue: [
						out nextPut: $&; nextPutAll: rest.
						"self error: 'unknown encoded HTML char'."
						"Please add it to this method"]]
				ifFalse: [out nextPut: char]].
		].
	^ out contents! !
!String methodsFor: 'converting' stamp: 'jmv 6/1/2022 11:00:50' prior: 16948513!
                         keywords
	"Answer an array of the keywords that compose the receiver."
	| kwd char keywords isAllValidInIdentifiers |
	keywords _ Array streamContents: [ :kwds |
		kwd _ String writeStream.
		isAllValidInIdentifiers _ true.
		1
			to: self size
			do: [ :i |
				char _ self at: i.
				kwd nextPut: char.
				char = $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers _ true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers _ false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!String methodsFor: 'converting' stamp: 'jmv 6/1/2022 11:10:20' prior: 16948564!
   squeezedTo: n
	"
Examples:
	Do nothing:
		'This one is a rather long phrase' squeezedTo: 32

	1-remove blanks (result can be shorter than asked):
		'This one is a rather long phrase' squeezedTo: 30

	2-remove necessary trailing vowels
		'This one is a rather long phrase' squeezedTo: 24

	3-truncate as needed (and add ellipsis)
		'This one is a rather long phrase' squeezedTo: 15

	4-avoid ellipsis
		'This one is a rather long phrase' squeezedTo: 5
	"
	| vowelCount read write i char allowedVowels str desiredSize postFix j |
	str := self.
	desiredSize := n.
	str size <= n ifTrue: [^str].
	str := str asCamelCase.
	str size <= n ifTrue: [^str].
	postFix := ''.
	desiredSize := n - postFix size.
	vowelCount := str
		inject: 0
		into: [:prev :each | each isVowel ifTrue: [prev + 1] ifFalse: [prev]].
	str size - vowelCount <= desiredSize
		ifTrue: [allowedVowels := vowelCount - (str size - desiredSize)]
		ifFalse: [
			allowedVowels := 0.
			postFix := '...'.
			n - postFix size < 5 ifTrue: [postFix := ''].
			desiredSize := n - postFix size].

	read := str readStream.
	write := String writeStream.
	i := 0.
	j := 0.
	[read atEnd not and: [j < desiredSize]] whileTrue: [
		char := read next.
		(char isVowel not or: [i < allowedVowels]) ifTrue: [
			char isVowel ifTrue: [i := i + 1].
			write nextPut: char.
			j := j + 1]].
	str := write contents , postFix.
	^ str! !
!String methodsFor: 'private' stamp: 'jmv 6/1/2022 11:10:35' prior: 50359647!
                 getEnclosedExpressionFrom: aStream 
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"
	| result currentChar |
	result := String writeStream.

	[aStream atEnd 
		or: [(currentChar := aStream next) = $}]]
		whileFalse: [result nextPut: currentChar].

	^ result contents withBlanksTrimmed! !
!String methodsFor: 'paragraph support' stamp: 'jmv 5/22/2022 20:22:59' prior: 16949258!
           indentationIfBlank: aBlock
	"Answer the number of leading tabs in the receiver.  If there are
	 no visible characters, pass the number of tabs to aBlock and return its value."
	| reader leadingTabs lastSeparator tab ch |
	tab _ Character tab.
	reader _ self readStream.
	leadingTabs _ 0.
	[ reader atEnd not and: [ (ch _ reader next) == tab ]] whileTrue: [
		leadingTabs _ leadingTabs + 1 ].
	lastSeparator _ leadingTabs + 1.
	[ reader atEnd not and: [
		ch isSeparator and: [ ch isLineSeparator not ]]] whileTrue: [
			lastSeparator _ lastSeparator + 1.
			ch _ reader next ].
	lastSeparator = self size | (ch notNil and: [ch isLineSeparator]) ifTrue: [
		^ aBlock value: leadingTabs ].
	^ leadingTabs! !
!String methodsFor: 'formatting' stamp: 'jmv 6/1/2022 11:10:39' prior: 50359661!
             format: aCollection 
	"format the receiver with aCollection  
	 
	simplest example:  
	'foo {1} bar' format: {Date today}.
	 
	complete example:  
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}.  
	"
	| result stream |
	result := String writeStream.
	stream := self readStream.

	[stream atEnd]
		whileFalse: [| currentChar | 
			currentChar := stream next.
			currentChar = ${
				ifTrue: [| expression | 
					expression := self getEnclosedExpressionFrom: stream.
					result
						nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
				ifFalse: [
					currentChar = $\
						ifTrue: [stream atEnd
								ifFalse: [result nextPut: stream next]]
						ifFalse: [result nextPut: currentChar]]].

	^ result contents! !
!Symbol methodsFor: 'system primitives' stamp: 'jmv 6/1/2022 11:01:33' prior: 16950767!
                             numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs offs |
	(numArgs _ self numArgs) >= n ifTrue: [ ^self ].	
	^ (String streamContents: [ :strm |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs _ 0 ] ifFalse: [offs _ 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol! !
!CompiledMethod methodsFor: 'printing' stamp: 'jmv 6/1/2022 11:06:21' prior: 16828427!
               abstractSymbolic
	"Answer a String that contains a list of all the byte codes in a method with a
	 short description of each, using relative addresses and not including code bytes."

	^ String streamContents: [ :strm |
		self longPrintRelativeOn: strm indent: 0 ].! !
!CompiledMethod methodsFor: 'printing' stamp: 'jmv 6/1/2022 11:06:26' prior: 16828564!
                             symbolic
	"Answer a String that contains a list of all the byte codes in a method 
	with a short description of each."

	^ String streamContents: [ :strm |
		self longPrintOn: strm ].! !
!Base64MimeConverter class methodsFor: 'services' stamp: 'jmv 5/22/2022 20:28:33' prior: 16784424!
  mimeDecode: aString
	^ ByteArray streamContents: [ :out |
		self mimeDecode: aString to: out]! !
!Base64MimeConverter class methodsFor: 'services' stamp: 'jmv 5/22/2022 20:28:53' prior: 16784431!
                            mimeDecode: aString to: outStream
	self new
		mimeStream: aString readStream;
		dataStream: outStream;
		mimeDecodeToByteArray! !
!Base64MimeConverter class methodsFor: 'services' stamp: 'jmv 5/22/2022 20:29:50' prior: 16784452!
                           mimeEncode: aByteArray to: outStream
	self new
		dataStream: aByteArray readStream;
		mimeStream: outStream;
		multiLine: true;
		mimeEncode! !
!Base64MimeConverter class methodsFor: 'additional services' stamp: 'jmv 5/22/2022 20:23:18' prior: 16784463!
  decodeInteger: mimeString
	| bytes sum |
	"Decode the MIME string into an integer of any length"

	bytes _ (Base64MimeConverter mimeDecodeToBytes: 
				mimeString readStream) contents.
	sum _ 0.
	bytes reverseDo: [:by | sum _ sum * 256 + by].
	^ sum! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/22/2022 21:13:39' prior: 16914169!
      upToAny: aCollection 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
	| element prevPos |
	^self collectionSpecies streamContents: [ :strm |
		[self atEnd or: [
			prevPos _ self position.
			element _ self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'positioning' stamp: 'jmv 5/22/2022 20:33:08' prior: 16914271!
            match: subCollection
	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."

	| pattern startMatch |
	pattern _ subCollection readStream.
	startMatch _ nil.
	[pattern atEnd] whileFalse: 
		[self atEnd ifTrue: [^ false].
		(self next) = (pattern next) 
			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]
			ifFalse: [pattern position: 0.
					startMatch ifNotNil: [
						self position: startMatch.
						startMatch _ nil]]].
	^ true

! !
!Compiler methodsFor: 'private' stamp: 'jmv 5/22/2022 20:36:30' prior: 50342633!
                from: textOrStream class: aClass context: aContext notifying: req

	sourceStream _ (textOrStream is: #Stream)
		ifTrue: [ textOrStream ]
		ifFalse: [ textOrStream asPlainString readStream ].
	class _ aClass.
	context _ aContext.
	requestor _ req.! !
!ParseNode methodsFor: 'printing' stamp: 'jmv 6/1/2022 11:06:49' prior: 16906154!
                    nodePrintOn: aStrm indent: nn
	| var aaStrm myLine |
	"Show just the sub nodes and the code."

	aaStrm := aStrm ifNil: [String writeStream].
	nn timesRepeat: [aaStrm tab].
	aaStrm nextPutAll: self class name; space.
	myLine := self printString withBlanksCondensed.
	myLine := myLine copyFrom: 1 to: (myLine size min: 70).
	aaStrm nextPutAll: myLine; newLine.
	1 to: self class instSize do: [:ii | 
		var := self instVarAt: ii.
		(var respondsTo: #asReturnNode) ifTrue: [var nodePrintOn: aaStrm indent: nn+1]].
	1 to: self class instSize do: [:ii | 
		var := self instVarAt: ii.
		(var isCollection and: [var isSequenceable]) ifTrue: [
			var do: [ :aNode | 
				(aNode respondsTo: #asReturnNode) ifTrue: [
					aNode nodePrintOn: aaStrm indent: nn+1]]]].
	^ aaStrm! !
!ParseNode methodsFor: 'private' stamp: 'jmv 6/1/2022 11:06:31' prior: 16906514!
               nextWordFrom: aStream setCharacter: aBlock

	| outStream char |
	outStream _ String writeStream.
	[ (aStream peekFor: Character space) or: [ aStream peekFor: Character tab ]] whileTrue.
	[ aStream atEnd or: [
		char _ aStream next.
		char isSeparator ]]
			whileFalse: [ outStream nextPut: char ].
	aBlock value: char.
	^ outStream contents! !
!BlockNode methodsFor: 'printing' stamp: 'jmv 6/1/2022 11:07:32' prior: 16793184!
                      printTemporaries: tempSequence on: aStream doPrior: aBlock
	"Print any in-scope temporaries.  If there are any evaluate aBlock
	 prior to printing.  Answer whether any temporaries were printed."
	| tempStream seen |
	tempSequence ifNil:
		[^false].
	tempStream := String writeStream.
	"This is for the decompiler which canmot work out which optimized block a particular temp is
	 local to and hence may produce diplicates as in
		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"
	seen := Set new.
	tempSequence do:
		[:tempNode |
		tempNode isIndirectTempVector
			ifTrue:
				[tempNode remoteTemps do:
					[:tempVariableNode|
					 (tempVariableNode scope >= 0
					  and: [(seen includes: tempNode key) not]) ifTrue:
						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]
			ifFalse:
				[(tempNode scope >= -1
				  and: ["This is for the decompiler which may create a block arg when converting
						a while into a to:do: but won't remove it form temporaries"
					   tempNode isBlockArg not
				  and: [(seen includes: tempNode key) not]]) ifTrue:
					[tempStream space; nextPutAll: (seen add: tempNode key)]]].
	tempStream position = 0 ifTrue:
		[^false].
	aBlock value.
	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.
	^true! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 5/22/2022 20:43:07' prior: 50347627!
inOutdent: aKeyboardEvent delta: delta
	"Add/remove a tab at the front of every line occupied by the selection. 
	Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"
	"This is a user command, and generates undo"

	| realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |

	"Operate on entire lines, but remember the real selection for re-highlighting later"
	realStart _ self startIndex.
	realStop _ self stopIndex - 1.

	"Special case: the text cursor on a line of its own, including weird case at end of paragraph"
	(realStart > realStop and: [
				realStart < 2 or: [(self privateCurrentString at: realStart - 1) isLineSeparator ]])
		ifTrue: [
			delta < 0
				ifTrue: [
					morph flash]
				ifFalse: [
					self replaceSelectionWith: Character tab asSymbol.
					self deselectAndPlaceCursorAt: realStart + 1].
			^true].

	lines _ textComposition lines.
	startLine _ textComposition lineIndexFor: realStart.
	stopLine _ textComposition lineIndexFor: (realStart max: realStop).
	start _ (lines at: startLine) first.
	stop _ (lines at: stopLine) last.
	
	"Pin the start of highlighting unless the selection starts a line"
	adjustStart _ realStart > start.

	"Find the indentation of the least-indented non-blank line; never outdent more"
	indentation _ (startLine to: stopLine) inject: 1000 into: [ :previousValue :each |
		previousValue min: (textComposition indentationOfLineIndex: each ifBlank: [ :tabs | 1000 ])].			

	size _  stop + 1 - start.
	numLines _ stopLine + 1 - startLine.
	inStream _ self privateCurrentString readStreamFrom: start to: stop.

	newString _ self stringClassToUse new: size + ((numLines * delta) max: 0).
	outStream _ ReadWriteStream on: newString.

	"This subroutine does the actual work"
	self indent: delta fromStream: inStream toStream: outStream.

	"Adjust the range that will be highlighted later"
	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].
	realStop _ realStop + outStream position - size.

	"Prepare for another iteration"
	indentation _ indentation + delta.
	size _ outStream position.
	inStream _ outStream setFrom: 1 to: size.

	outStream
		ifNil: [ 	"tried to outdent but some line(s) were already left flush"
			morph flash]
		ifNotNil: [
			self selectInvisiblyFrom: start to: stop.
			size = newString size ifFalse: [newString _ outStream contents].
			self replaceSelectionWith: newString].
	self selectFrom: realStart to: realStop. 	"highlight only the original range"
	^ true! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 5/22/2022 20:43:16' prior: 16940166!
                        explainNumber: string 
	"Is string a Number?"

	| strm c |
	(c _ string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])
			ifFalse: [^nil]].
	strm _ string readStream.
	c _ Number readFrom: strm.
	strm atEnd ifFalse: [ ^nil ].
	c printString = string
		ifTrue: [ ^ string , ' is a ' , c class name ]
		ifFalse: [ ^ string , ' (= ' , c printString , ') is a ' , c class name ]! !
!Transcript class methodsFor: 'class initialization' stamp: 'jmv 6/1/2022 11:10:09' prior: 16974026 overrides: 16904184!
     initialize
	"
	self initialize
	"
	showOnDisplay _ true.
	bounds _ 20@20 extent: 300@500.
	logToFile _ false.
	logToStdout _ false.
	entries _ Array new: self maxEntries.
	unfinishedEntry _ String writeStream.
	lastDisplayPosition _ 0.
	accessSemaphore _ Semaphore forMutualExclusion.
	self clear! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 5/22/2022 20:43:25' prior: 16977609!
                      vmStatisticsShortString
	"Convenience item for access to recent statistics only"
	"
	(TextModel new contents: Utilities vmStatisticsShortString) openLabel: 'VM Recent Statistics'
	"

	^ self vmStatisticsReportString readStream upToAll: 'Since'; crLfNextLine; upToEnd
! !
!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 6/1/2022 11:07:36' prior: 16911022!
                         copyListToClipboard
	"Copy my items to the clipboard as a multi-line string"

	Clipboard storeObject: (String streamContents: [ :strm |
		list
			do: [:ea | strm nextPutAll: ea asString]
			separatedBy: [ strm newLine ]]).! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 6/1/2022 11:07:41' prior: 16805435!
       fatDefForClass: class

	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |
	newDef _ class definition.
	oldDef _ (self changeRecorderFor: class) priorDefinition.
	oldDef ifNil: [^ newDef].
	oldDef = newDef ifTrue: [^ newDef].

	oldStrm _ oldDef readStream.
	newStrm _ newDef readStream.
	outStrm _ String writeStream.

	"Merge inst vars from old and new defs..."
	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.
	outStrm 
		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 
		nextPutAll: 'instanceVariableNames:'.
	newStrm peek = $: ifTrue: [newStrm next].	"may or may not be there, but already written"
	outStrm
		nextPutAll: (newStrm upTo: $'); nextPut: $'.
	oldVars _ (oldStrm upTo: $') findTokens: Character separators.
	newVars _ (newStrm upTo: $') findTokens: Character separators.
	addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
	outStrm nextPut: $'.

	class isMeta ifFalse: [
		"Merge class vars from old and new defs..."
		oldStrm upToAll: 'classVariableNames:'; upTo: $'.
		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';
			nextPutAll: (newStrm upTo: $'); nextPut: $'.
		oldVars _ (oldStrm upTo: $') findTokens: Character separators.
		newVars _ (newStrm upTo: $') findTokens: Character separators.
		addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
		outStrm nextPut: $'].

	outStrm nextPutAll: newStrm upToEnd.
	^ outStrm contents
! !
!DebuggerMethodMap methodsFor: 'accessing' stamp: 'jmv 6/1/2022 11:07:45' prior: 16839176!
       tempsAndValuesForContext: aContext
	"Return a string of the temporary variabls and their current values"

	^ String streamContents: [ :strm |
		(self tempNamesForContext: aContext) withIndexDo: [ :title :index |
			strm nextPutAll: title; nextPut: $:; space; tab.
			aContext print: (self namedTempAt: index in: aContext) on: strm.
			strm newLine]].! !
!ReferencesExplorerWrapper methodsFor: 'printing' stamp: 'jmv 6/1/2022 11:07:49' prior: 16925377!
                            pathStringFrom: parentObject to: childObject count: anInteger

	| answer referenceDescription |
	answer _ String writeStream.
	referenceDescription _ self referenceDescriptionFrom: parentObject to: childObject count: anInteger.
	self print: parentObject on: answer.
	answer
		nextPutAll: ' ';
		nextPutAll: referenceDescription;
		nextPutAll: ' --> '.
	self print: childObject on: answer.
	^answer contents! !
!WeightExplorerWrapper methodsFor: 'printing' stamp: 'jmv 6/1/2022 11:07:54' prior: 16980800!
        weightStringFrom: parentObject to: childObject count: anInteger

	| answer |
	answer _ String writeStream.
	self print: parentObject on: answer.
	^answer contents! !
!ClosureTraceNode methodsFor: 'printing' stamp: 'jmv 6/1/2022 11:09:55' prior: 16817261!
 dumpString

	^String streamContents: [ :strm |
		self dumpOn: strm ].! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/23/2022 12:46:55' prior: 50360501!
     scanNumber
	| start c nc base |
	start := sourcePosition.
	self skipDigits.
	c := self currentChar.
	('rx' includes: c)
		ifTrue: [
			base := Integer readFrom: ((source copyFrom: start to: sourcePosition - 1) readStream).
			self peekChar = $- ifTrue: [self nextChar].
			self skipBigDigits: base.
			c := self currentChar.
			c = $. 
				ifTrue: [
					(self isBigDigit: self nextChar base: base) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipBigDigits: base]].
			c := self currentChar.
			('deqp'includes: c)
				ifTrue: [
					((nc := self nextChar) isDigit or: [nc = $- and:[self peekChar isDigit]]) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			c = $s 
				ifTrue: [
					self nextChar isDigit 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c = $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits.].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c = $. 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [
					sourcePosition := sourcePosition - 1.
					currentToken := source copyFrom: start to: sourcePosition - 1.
					^currentTokenSourcePosition := start]
				ifTrue: [self skipDigits]].
	c := self currentChar.
	('deqp' includes: c)
		ifTrue: [
			((nc := self nextChar) isDigit or: [nc = $-  and:[self peekChar isDigit]]) 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	c = $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	currentToken := source copyFrom: start to: sourcePosition - 1.
	^currentTokenSourcePosition := start! !
!DifferenceFinder class methodsFor: 'compatibility' stamp: 'jmv 6/1/2022 11:09:23' prior: 16843138!
                           wordsDisplayPatchFrom: srcString to: dstString
	| finder answer src1 dst1 changedCount |
	finder _ self base: srcString case: dstString.
	finder compareLines; compute.
	answer _ String new asText.
	src1 _ String writeStream.
	dst1 _ String writeStream.
	changedCount _ 0.
	finder differences sort first do: [:item :condition |
		condition caseOf: {
			[ #unchanged ] -> [
				changedCount > 0 ifTrue: [
					"If the sequence of changed lines is large, comparing words gets too slow and less useful"
					changedCount > 30 ifTrue: [
						^nil ].
					"Compare the just ended sequence of changed lines"
					finder base: src1 contents case: dst1 contents.
					finder compareWords; compute: true.
					finder differences ifNil: [ ^nil ].
					answer _ answer append:  finder differences anyOne asText.
					src1 resetToStart.
					dst1 resetToStart.
					changedCount _ 0.
				].
				"This line hasn't changed. Just add it to the result in plain text."
				answer append: item ].
			[ #removed ] -> [
				"A removed line belongs in the source"
				src1 nextPutAll: item.
				changedCount _ changedCount + 1 ].
			[ #inserted ] -> [
				"An added line belongs in the destination"
				dst1 nextPutAll: item.
				changedCount _ changedCount + 1  ].
			}.
		].
	"If the sequence of changed lines is large, comparing words gets too slow and less useful"
	changedCount > 30 ifTrue: [
		^nil ].
	finder base: src1 contents case: dst1 contents.
	finder compareWords; compute: true.
	finder differences ifNil: [ ^nil ].
	answer _ answer append: finder differences anyOne asText.

	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5214-StreamUsageCleanup-JuanVuletich-2022Jun01-10h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5214] on 2 June 2022 at 7:13:45 pm'!

Object subclass: #Utf32String
	instanceVariableNames: 'codePoints hash '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf32String category: #'System-Text' stamp: 'Install-5215-StringAndUtfString-EqualityAndHash-JuanVuletich-2022Jun02-19h09m-jmv.001.cs.st 6/16/2022 07:24:50'!
Object subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index hash '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5215-StringAndUtfString-EqualityAndHash-JuanVuletich-2022Jun02-19h09m-jmv.001.cs.st 6/16/2022 07:24:50'!
Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!Object methodsFor: 'testing' stamp: 'jmv 6/2/2022 15:04:50'!
                          isUtf32String
	"Overridden to return true in Utf32String, natch"
	^ false! !
!String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 14:43:31'!
                   is: aStringOrByteArray sameAs: another 
	"Take adventage of String primitive for comparing, for example, ByteArrays"

	^ (self compare: aStringOrByteArray with: another collated: CaseInsensitiveOrder) = 2! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 6/2/2022 15:04:42' overrides: 50367308!
                         isUtf32String

	^true! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 14:24:51'!
   computeHash
	"Same hash value as the equivalent ASCII String, provided that all our CodePoints exist as Characters"
	| hashForAscii byteString |
	hashForAscii _ self computeHashForAscii.
	self isAscii ifTrue: [
		^hashForAscii ].
	"If there's a String that is equal to us (i.e. no NCRs were needed to represent us)"
	byteString _ self asByteString.
	byteString size = self size ifTrue: [
		^byteString hash ].
	"Otherwise, use a hash that doesn't need to equal that of a String"
	^hashForAscii
! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 14:14:52'!
          computeHashForAscii
	"Same hash value as a pure ASCII String.
	Some other reasonable hash value otherwise, but not the same as the one of the equivalent String if ISO-8859 non ASCII characters are present."
	bytes size > 256 ifTrue: [ ^ bytes hashQuick ].
	^ByteArray
		hashBytes: bytes
		startingWith: String hash! !
!String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 15:03:08' prior: 16947522 overrides: 16934001!
                              = aString 
	"Answer whether the receiver sorts equally as aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String or Symbol, maybe it is a Text?"
	aString isStringLike ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Let them handle us"
	aString isString ifFalse: [
		^aString = self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 2.! !
!String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 15:01:55' prior: 16947756 overrides: 16934038!
  hash
	"#hash is implemented, because #= is implemented.
	Note: #hash must be the same for String, Symbol, Utf8String, Utf8Symbol, Utf32String and Text
	if they hold same Characters."

	self size > 256 ifTrue: [ ^ self hashQuick ].
	^ByteArray
		hashBytes: self
		startingWith: String hash! !
!ByteArray methodsFor: 'comparing' stamp: 'jmv 6/2/2022 14:47:56' prior: 16799015 overrides: 16934001!
                     = another
	"Make good use of String primitives"

	self == another ifTrue: [ ^ true ].
	self species == another species ifFalse: [^ false].
	^'' is: self sameAs: another ! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 15:06:02' prior: 50351078 overrides: 16901772!
          = aString
	"Answer whether the receiver sorts equally as anUtf32String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isStringLike ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Expensive. Assume it is extremely unlikely."
	aString isUtf32String ifFalse: [
		^self asUtf8String = aString ].

	^ codePoints = aString words! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 15:06:54' prior: 50351100 overrides: 16901788!
                             hash
	"#hash is implemented, because #= is implemented.
	Note: #hash must be the same for String, Symbol, Utf8String, Utf8Symbol, Utf32String and Text
	if they hold same Characters.
	This implementation is expensive. We assume that String and Utf8String are much more common."

	hash ifNil: [ hash _ self asUtf8String hash ].
	^hash! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 15:03:08' prior: 50351434 overrides: 16901772!
        = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isStringLike ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	aString isString ifTrue: [
		"If aString contains NCRs wit will never equal self. If this ever changes, don't forget about #hash,
		and String >> #="
		^bytes = (aString asUtf8Bytes: false) ].

	^ bytes = aString asUtf8Bytes.! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/2/2022 15:01:38' prior: 50351455 overrides: 16901788!
                            hash
	"#hash is implemented, because #= is implemented.
	Note: #hash must be the same for String, Symbol, Utf8String, Utf8Symbol, Utf32String and Text
	if they hold same Characters."

	hash ifNil: [ hash _ self computeHash ].
	^hash! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/2/2022 14:11:48' prior: 50351706!
  computeCountAndIndex
	self isEmpty ifTrue: [ count := 0. index := #(). ^ self ].
	"the number of characters cannot be larger than the byte size"
	bytes size <= self stride
		ifTrue: [ self computeCountNoIndex ]
		ifFalse: [ self computeCountAndIndexFull ]! !

Object subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf32String category: #'System-Text' stamp: 'Install-5215-StringAndUtfString-EqualityAndHash-JuanVuletich-2022Jun02-19h09m-jmv.001.cs.st 6/16/2022 07:24:50'!
Object subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5215-StringAndUtfString-EqualityAndHash-JuanVuletich-2022Jun02-19h09m-jmv.001.cs.st 6/16/2022 07:24:50'!
Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5215-StringAndUtfString-EqualityAndHash-JuanVuletich-2022Jun02-19h09m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5215] on 2 June 2022 at 8:17:57 pm'!
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/2/2022 19:26:33'!
                    popUpAt: aPoint allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt hand world |
	self items isEmpty ifTrue: [^self].
	self addBlankIconsIfNecessary.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	world _ self runningWorld.
	world ifNil: [ ^ self ].
	hand _ world activeHand.
	world addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	prevKbdFocus _ hand keyboardFocus.
	prevMouseFocus _ hand mouseFocus.
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 6/2/2022 17:30:58'!
              invokeNonModalAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point."

	self
		popUpAt: aPoint
		allowKeyboard: aBoolean.! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 6/2/2022 17:29:50'!
       startUpNonModalWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self 
		startUpNonModalWithCaption: captionOrNil 
		at: Sensor mousePoint 
		allowKeyboard: (PreferenceNG at: #menuKeyboardControl)! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 6/2/2022 17:30:15'!
            startUpNonModalWithCaption: captionOrNil at: location allowKeyboard: aBoolean 
	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,
	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."

	| maxHeight |
	maxHeight := Display height * 3 // 4.
	self frameHeight > maxHeight 
		ifTrue: [
			^self 
				startUpSegmented: maxHeight
				withCaption: captionOrNil
				at: location
				allowKeyboard: aBoolean].
	^(MVCMenuMorph from: self title: captionOrNil) 
		invokeNonModalAt: location
		allowKeyboard: aBoolean! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 6/2/2022 20:15:44' prior: 16883005 overrides: 16892202!
         keyStroke: aKeyboardEvent
	| matchString char asc selectable |
	char := aKeyboardEvent keyCharacter.
	asc := char numericValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
					selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: [
							"self delete."
							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			self delete.
			aKeyboardEvent hand
				newKeyboardFocus: prevKbdFocus;
				newMouseFocus: prevMouseFocus.
			^self].
	(asc = 28 or: [asc = 29]) 
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
				ifFalse: [^ self]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := char = Character backspace 
				ifTrue: [
					matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 6/2/2022 16:56:31' prior: 16883075 overrides: 16892224!
               mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event."
	(stayUp or: [ self includesPixel: aMouseButtonEvent eventPosition ]) 
		ifFalse: [
			self deleteIfPopUp: aMouseButtonEvent.
			aMouseButtonEvent hand
				newKeyboardFocus: prevKbdFocus;
				newMouseFocus: prevMouseFocus.
			^ self ]. "click outside"

	"Grab the menu and drag it to some other place
	This is reimplemented here because we handle the event, and if the following lines are commented, a menu can't be grabbed with the hand. This is not nice and shouldn't be needed"
	self isSticky ifTrue: [ ^self ].
	aMouseButtonEvent hand grabMorph: self.! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 6/2/2022 20:17:15' prior: 16883098 overrides: 16892239!
         mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self includesPixel: aMouseButtonEvent eventPosition) ifFalse:[
		"Mouse up outside. Release eventual focus and delete if pop up."
		aMouseButtonEvent hand releaseMouseFocus: self.
		self deleteIfPopUp: aMouseButtonEvent.
		aMouseButtonEvent hand
				newKeyboardFocus: prevKbdFocus;
				newMouseFocus: prevMouseFocus.
		^ self].
	stayUp ifFalse: [
		"Still in pop-up transition; keep focus"
		aMouseButtonEvent hand newMouseFocus: self ].! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 6/2/2022 19:27:37' prior: 16883300!
invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand delay |
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self popUpAt: actHand morphPosition allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	delay _ Delay forMilliseconds: 10.
	[ self isInWorld and: [self isModalInvokationDone not] ] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 6/2/2022 20:14:17' prior: 16881600!
                        invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|w delay |
	w _ self runningWorld.
	w doOneMinimalCycleNow.
	self popUpAt: aPoint allowKeyboard: aBoolean.
	done _ false.
	delay _ Delay forMilliseconds: 20.
	[ done not and: [self isInWorld] ] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	^ mvcSelection ! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'jmv 6/2/2022 17:29:26' prior: 16913793 overrides: 16903525!
                            inform: aString
	"PopUpMenu inform: 'I like Cuis'"

	UISupervisor whenUIinSafeState: [
		(self labels: ' OK ' icons: #(emblemImportantIcon)) startUpNonModalWithCaption: aString ]! !

MenuMorph removeSelector: #popUpAt:forHand:allowKeyboard:!

!methodRemoval: MenuMorph #popUpAt:forHand:allowKeyboard: stamp: 'Install-5216-Menus-MoreRobustCode-JuanVuletich-2022Jun02-20h10m-jmv.001.cs.st 6/16/2022 07:24:50'!
popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	self addBlankIconsIfNecessary.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	prevKbdFocus _ hand keyboardFocus.
	prevMouseFocus _ hand mouseFocus.
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5216-Menus-MoreRobustCode-JuanVuletich-2022Jun02-20h10m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5216] on 3 June 2022 at 9:35:17 am'!
!ArrayOfCharactersAndCodePoints methodsFor: 'testing' stamp: 'jmv 6/1/2022 11:29:22' overrides: 16781010!
           is: aSymbol
	^ aSymbol == #ArrayOfCharactersAndCodePoints or: [ super is: aSymbol ]! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 6/1/2022 11:32:13'!
      canHoldCodePoints

	^true! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 6/1/2022 11:32:02'!
 canHoldCodePoints

	^true! !
!WriteStream methodsFor: 'private' stamp: 'jmv 6/1/2022 11:29:56' prior: 16983250!
                isCompatibleWithContents: aCollection

	collection class == aCollection class
		ifTrue: [ ^ true ].

	(aCollection isString and: [ (collection is: #Text) or: [ collection is: #ArrayOfCharactersAndCodePoints ]])
		ifTrue: [ ^ true ].

	^ false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5217-WriteStream-AutoConvertForUnicode-Enh-JuanVuletich-2022Jun03-09h25m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5217] on 3 June 2022 at 10:03:15 am'!
!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 08:00' prior: 16902652!
                           perform: selector withArguments: argArray inSuperclass: lookupClass
	"NOTE:  This is just like perform:withArguments:, except that
	the message lookup process begins, not with the receivers's class,
	but with the supplied superclass instead.  It will fail if lookupClass
	cannot be found among the receiver's superclasses.
	Primitive. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 100>
	(selector isSymbol)
		ifFalse: [^ self error: 'selector argument must be a Symbol'].
	(selector numArgs = argArray size)
		ifFalse: [^ self error: 'incorrect number of arguments'].
	(self class == lookupClass or: [self class inheritsFrom: lookupClass])
		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].
	self primitiveFailed! !
!Behavior methodsFor: 'printing' stamp: 'jmv 3/2/2010 15:33' prior: 16785269!
                         literalScannedAs: scannedLiteral notifying: requestor
	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).
	If scannedLiteral is not an association, answer it.
	Else, if it is of the form:
		nil->#NameOfMetaclass
	answer nil->theMetaclass, if any has that name, else report an error.
	Else, if it is of the form:
		#NameOfGlobalVariable->anythiEng
	answer the global, class, or pool association with that nameE, if any, else
	add it to Undeclared a answer the new Association."

	| key value |
	(scannedLiteral isVariableBinding)
		ifFalse: [^ scannedLiteral].
	key _ scannedLiteral key.
	value _ scannedLiteral value.
	key ifNil: [
		(self bindingOf: value) ifNotNil: [ :assoc |
				 (assoc value isKindOf: Behavior)
					ifTrue: [^ nil->assoc value class]].
		requestor notify: 'No such metaclass'.
		^false].
	key isSymbol
		ifTrue: [ "##<global var name>"
			(self bindingOf: key) ifNotNil:[ :assoc | ^assoc].
			Undeclared at: key put: nil.
			 ^Undeclared bindingOf: key].
	requestor notify: '## must be followed by a non-local variable name'.
	^false

"	Form literalScannedAs: 14 notifying: nil 14
	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm
	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form
	Form literalScannedAs: ##Form notifying: nil   Form->Form
	Form literalScannedAs: ###Form notifying: nil   nilE->Form class
"! !
!Behavior methodsFor: 'printing' stamp: 'ar 5/17/2003 14:11' prior: 16785361!
   storeLiteral: aCodeLiteral on: aStream
	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName
	 or ###MetaclassSoleInstanceName format if appropriate"
	| key value |
	(aCodeLiteral isVariableBinding)
		ifFalse:
			[aCodeLiteral storeOn: aStream.
			 ^self].
	key _ aCodeLiteral key.
	(key isNil and: [(value _ aCodeLiteral value) isMemberOf: Metaclass])
		ifTrue:
			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.
			 ^self].
	(key isSymbol and: [(self bindingOf: key) notNil])
		ifTrue:
			[aStream nextPutAll: '##'; nextPutAll: key.
			 ^self].
	aCodeLiteral storeOn: aStream! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 5/26/2013 16:18' prior: 16953786!
                              allGlobalRefsWithout: classesAndMessagesPair
	"Answer a set of symbols that may be refs to Global names. 
	This method computes its result in the absence of specified classes and messages.
	Does not include references from a class to itself"

	| globalRefs absentClasses absentSelectors |
	globalRefs _ IdentitySet new: CompiledMethod instanceCount.
	absentClasses _ classesAndMessagesPair first.
	absentSelectors _ classesAndMessagesPair second.
	self classNames do: [ :cName |
		((absentClasses includes: cName)
					ifTrue: [#()]
					ifFalse: [{(self at: cName). (self at: cName) class}]) do: [ :cl | 
			(absentSelectors isEmpty
					ifTrue: [cl selectors]
					ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: [ :sel |
				"Include all capitalized symbols for good measure"
				self allSymbolsIn: (cl compiledMethodAt: sel) literals do: [ :m | 
					(m isSymbol and: [ m size > 0] and: [m first isUppercase]) ifTrue: [
						m = cl name ifFalse: [
							globalRefs add: m]].
					(m isVariableBinding) ifTrue:
						[m key ifNotNil: [
							m key = cl name ifFalse: [
								globalRefs add: m key]]]]]]].
	^ globalRefs! !
!SystemDictionary methodsFor: 'private' stamp: 'jmv 4/7/2009 14:23' prior: 16956849!
                    allSymbolsIn: anArray do: aBlock
	"Recursively dig into anArray and evaluate aBlock on any Symbols found"
	"allSymbols and variableBindings"
	
	anArray do: [ :elem |
		(elem isSymbol or: [ elem isVariableBinding ])
			ifTrue: [ aBlock value: elem ]
			ifFalse: [
				(elem isMemberOf: Array) ifTrue: [ 
					self allSymbolsIn: elem do: aBlock ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5218-AvoidAskingForSymbolClass-JuanVuletich-2022Jun03-10h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5218] on 3 June 2022 at 11:04:09 am'!
!String class methodsFor: 'system' stamp: 'jmv 6/3/2022 10:29:45'!
                symbolClassToUse
	"Answer the class to create symbols from us"
	^Symbol! !
!Symbol class methodsFor: 'private' stamp: 'jmv 6/3/2022 10:28:45'!
                 basicFromString: aString
	"Private use. Answers an instance that is not yet interned.
	Can break the Symbol invariant: forAllSymbols, (s1 = s2) => (s1 == s2)
	Please don't call lightly."

	^(self basicNew: aString size) string: aString! !
!Symbol methodsFor: 'comparing' stamp: 'jmv 6/3/2022 10:34:38' prior: 16950714 overrides: 50367358!
             = another

	"Use == between two symbols..."
	self == another ifTrue: [
		^ true].  "Was == "
	another isSymbol ifTrue: [
		^ false].  "Was not ==, therefore can't be = "

	"Otherwise use string =..."
	^ super = another! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 6/3/2022 10:40:03' prior: 16951076!
    intern: aStringOrSymbol

	^(self lookup: aStringOrSymbol)
		ifNil:
			[
				NewSymbols add:
					(aStringOrSymbol isSymbol
						ifTrue: [ aStringOrSymbol ]
						ifFalse: [ aStringOrSymbol class symbolClassToUse basicFromString: aStringOrSymbol ])
			]! !

Symbol removeSelector: #is:!

!methodRemoval: Symbol #is: stamp: 'Install-5219-Symbol-Refactor-JuanVuletich-2022Jun03-11h03m-jmv.001.cs.st 6/16/2022 07:24:50'!
is: aSymbol
	"Answer false if I am not a Symbol.
	 ??Note: A Symbol is also a String; should we check for #String and answer false??"
	^#Symbol = aSymbol or: [ super is: aSymbol]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5219-Symbol-Refactor-JuanVuletich-2022Jun03-11h03m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5219] on 5 June 2022 at 4:46:34 pm'!
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/5/2022 16:43:57' prior: 16802062!
               selectEquivalentMethods
	"Selects all method definitions for which there is already an equivalent method in the current image, 
	(meaning that the difference is cosmetic and not in behavior)"
	1 to: changeList size do: [ :i | 
		| change class |
		change _ changeList at: i.
		listSelections at: i put:
			(((change changeType == #method and: [ change isMethodDeletion not ]) and: [
				(class _ change changeClass) notNil]) and: [
					(class includesSelector: change methodSelector) and: [
						| cmWithNode |
						cmWithNode _ [class basicCompile: change string notifying: nil trailer: class defaultMethodTrailer ifFail: nil] 
							on: SyntaxErrorNotification do: [ :ex | ex return ].
						(cmWithNode notNil and: [
							| current inChange |
							current _ (class compiledMethodAt: change methodSelector) copyWithTrailerBytes: #(0).
							inChange _ cmWithNode method copyWithTrailerBytes: #(0).
							current = inChange or: [
								| currentCmWithNode |
								currentCmWithNode _ [class basicCompile: (class decompilerClass new decompile: change methodSelector in: class) decompileString
										notifying: nil trailer: class defaultMethodTrailer ifFail: nil] on: SyntaxErrorNotification do: [ :ex | ex return ].
								(currentCmWithNode notNil and: [
									current _ currentCmWithNode method copyWithTrailerBytes: #(0).
									current = inChange])
							]
						])
					]]
			)].
	self changed: #allSelections.
	self changed: #annotation! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5220-avoidBuggyWarningWhen-selectEquivalentMethods-JuanVuletich-2022Jun05-16h45m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5220] on 6 June 2022 at 10:37:32 am'!
!Object methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:20:29'!
isByteString
	"Overridden to return true in String, natch"
	^ false! !
!String methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:21:36' overrides: 50368125!
       isByteString
	^ true! !
!String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 10:24:19' prior: 50367358 overrides: 16934001!
    = aString 
	"Answer whether the receiver sorts equally as aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String or Symbol, maybe it is a Text?"
	aString isStringLike ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Let them handle us"
	aString isByteString ifFalse: [
		^aString = self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 2.! !
!String methodsFor: 'converting' stamp: 'jmv 6/6/2022 10:29:16' prior: 50343455!
                 uncapitalized
	"Answer an object like the receiver but with first character downshifted if necesary"
	"'MElViN' uncapitalized"
	"#Will uncapitalized"
	| answer |
	self isEmpty ifTrue: [^ self].
	answer _ self asPlainString.
	answer == self ifTrue: ["don't modify receiver"
		answer _ self copy ].
	answer at: 1 put: (answer at: 1) asLowercase.
	^ answer! !
!WriteStream methodsFor: 'private' stamp: 'jmv 6/6/2022 10:33:40' prior: 50367839!
        isCompatibleWithContents: aCollection

	collection class == aCollection class
		ifTrue: [ ^ true ].

	(aCollection isByteString and: [ (collection is: #Text) or: [ collection is: #ArrayOfCharactersAndCodePoints ]])
		ifTrue: [ ^ true ].

	^ false! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 10:35:18' prior: 50367442 overrides: 16901772!
                              = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isStringLike ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	aString isByteString ifTrue: [
		"If aString contains NCRs wit will never equal self. If this ever changes, don't forget about #hash,
		and String >> #="
		^bytes = (aString asUtf8Bytes: false) ].

	^ bytes = aString asUtf8Bytes.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5221-isByteString-JuanVuletich-2022Jun06-10h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5220] on 6 June 2022 at 10:42:16 am'!
!Object methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:40:12'!
isCharacter
	"Overridden to return true in Character and UnicodeCodePoint."
	^ false! !
!Character methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:40:24' overrides: 50368218!
                   isCharacter
	^true! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:40:28' overrides: 50368218!
              isCharacter
	^true! !
!Character methodsFor: 'comparing' stamp: 'jmv 6/6/2022 10:40:45' prior: 50358937 overrides: 16901772!
   = aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].
	aCodePointOrCharacter isCharacter ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint! !
!CharacterSet methodsFor: 'collection ops' stamp: 'jmv 6/6/2022 10:40:49' prior: 50360988 overrides: 16823908!
                        includes: aCharacter
	aCharacter isCharacter ifFalse: [ ^ false ].
	^aCharacter iso8859s15Code ifNotNil: [ :index | (map at: index + 1) > 0 ].! !
!String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 10:40:54' prior: 50360996 overrides: 16901525!
          at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	
			(aCharacter is: #Character)
				ifFalse: [
					aCharacter asCharacter
						ifNotNil: [ :ch | ^self at: index put: ch ]
						ifNil: [self error: 'String only store code points in the ISO 8859-15 set']]
				ifTrue: [
					index isInteger
						ifTrue: [self errorSubscriptBounds: index]
						ifFalse: [self errorNonIntegerIndex]]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 10:40:58' prior: 50361038!
  findAnySubStr: delimiters startingAt: start 
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min ind |
	min _ self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		delim isCharacter
			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [ind _ self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
			min _ min min: ind].
	^ min! !
!String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 10:41:02' prior: 50361063!
                           findTokens: delimiters
	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."

	| tokens keyStart keyStop separators |

	tokens _ OrderedCollection new.
	separators _ delimiters isCharacter
		ifTrue: [Array with: delimiters]
		ifFalse: [delimiters].
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: separators startingAt: keyStop.
		keyStop _ self findDelimiters: separators startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 10:41:06' prior: 50361091 overrides: 16933668!
                               indexOf: aCharacter

	aCharacter isCharacter ifFalse: [^ 0].
	^ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: 1.! !
!String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 10:41:10' prior: 50361099 overrides: 16933688!
             indexOf: aCharacter  startingAt: start

	aCharacter isCharacter ifFalse: [^ 0].
	^ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: start.! !
!String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 10:41:15' prior: 50361108 overrides: 16933699!
                      indexOf: aCharacter  startingAt: start  ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	ans _ String indexOfByte: aCharacter iso8859s15Code inString: self  startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 10:41:19' prior: 50361119!
      skipAnySubStr: delimiters startingAt: start 
	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."
	| any this ind ii |
	ii _ start-1.
	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"
		any _ false.
		delimiters do: [ :delim |
			delim isCharacter
				ifTrue: [ (self at: ii) = delim ifTrue: [any _ true]]
				ifFalse: ["a substring"
					delim size > (self size - ii + 1) ifFalse: [ "Here's where the one-off error was."
						ind _ 0.
						this _ true.
						delim do: [ :dd | 
							dd = (self at: ii+ind) ifFalse: [this _ false].
							ind _ ind + 1].
						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]
							ifTrue: [any _ false] "if the delim is too big, it can't match"]].
		any ifFalse: [^ ii]].
	^ self size + 1! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:41:22' prior: 50361585 overrides: 50361580!
                               isConstantCharacter
	^ key isCharacter! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 6/6/2022 10:41:29' prior: 50358922 overrides: 16901772!
        = aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].
	aCodePointOrCharacter isCharacter ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint! !
!Utf32String methodsFor: 'enumerating' stamp: 'jmv 6/6/2022 10:41:33' prior: 50363892!
                collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacter ]) ifFalse: [
		^array ].
	^Utf32String newFrom: array! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 6/6/2022 10:41:37' prior: 50363999!
                      collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacter ]) ifFalse: [
		^array ].
	^Utf8String newFrom: array! !

UnicodeCodePoint removeSelector: #isCharacterLike!

!methodRemoval: UnicodeCodePoint #isCharacterLike stamp: 'Install-5222-isCharacter-JuanVuletich-2022Jun06-10h37m-jmv.001.cs.st 6/16/2022 07:24:50'!
isCharacterLike
	^true!

Character removeSelector: #isCharacterLike!

!methodRemoval: Character #isCharacterLike stamp: 'Install-5222-isCharacter-JuanVuletich-2022Jun06-10h37m-jmv.001.cs.st 6/16/2022 07:24:50'!
isCharacterLike
	^true!

Object removeSelector: #isCharacterLike!

!methodRemoval: Object #isCharacterLike stamp: 'Install-5222-isCharacter-JuanVuletich-2022Jun06-10h37m-jmv.001.cs.st 6/16/2022 07:24:50'!
isCharacterLike
	"Overridden to return true in Character and UnicodeCodePoint."
	^ false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5222-isCharacter-JuanVuletich-2022Jun06-10h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5229] on 6 June 2022 at 11:03:28 am'!
!Utf32String methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:55:00' overrides: 16903430!
                  isString
	^true! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:55:03' overrides: 16903430!
                       isString
	^true! !
!Object methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:54:35' prior: 16903430!
                               isString
	"Overridden to return true in String, Utf8String and Utf32String."
	^ false! !
!Object class methodsFor: 'instance creation' stamp: 'jmv 9/2/2013 09:01' prior: 50361598!
            readFrom: aStream
	"Create an object based on the contents of aStream."

	| object ok |
	ok _ (aStream is: #Stream) or: [ aStream isString ].
	(ok or: [ aStream is: #Text ]) ifFalse: [ ^ self error: 'expected String or Text' ].
	object _ Compiler evaluate: aStream.
	(object isKindOf: self) ifFalse: [ self error: self name, ' expected' ].
	^ object! !
!Number class methodsFor: 'instance creation' stamp: 'jmv 6/6/2022 10:59:12' prior: 50361613 overrides: 50368467!
             readFrom: stringOrStream 
	"Answer a number as described on aStream.  The number may
	include a leading radix specification, as in 16rFADE"
	| value base aStream sign |
	aStream _ stringOrStream isString
		ifTrue: [stringOrStream readStream]
		ifFalse: [stringOrStream].
	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].
	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [aStream peekFor: $+. 1].
	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].
	base _ 10.
	aStream peek = $.
		ifTrue: [ value _ 0 ]
		ifFalse: [
			value _ Integer readFrom: aStream base: base.
			(aStream peekFor: $r)
				ifTrue: [
					"<base>r<integer>"
					(base _ value) < 2 ifTrue: [
						base = 1 ifTrue: [ ^Integer readBaseOneFrom: aStream ].
						^self error: 'Invalid radix'].
					(aStream peekFor: $-) ifTrue: [sign _ sign negated].
					value _ Integer readFrom: aStream base: base].
			(aStream peekFor: $x)
				ifTrue: [
					"0x<integer>" "Hexadecimal"
					base _ 16.
					(aStream peekFor: $-) ifTrue: [sign _ sign negated].
					value _ Integer readFrom: aStream base: base]].
	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !
!String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 10:59:35' prior: 50368134 overrides: 16934001!
         = aString 
	"Answer whether the receiver sorts equally as aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String or Symbol, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Let them handle us"
	aString isByteString ifFalse: [
		^aString = self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 2.! !
!String methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:54:40' prior: 16949190 overrides: 50368461!
    isString
	^ true! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 6/6/2022 11:00:00' prior: 50362218 overrides: 16945788!
                              nextPutAll: aStringOrUTF8Bytes
	"Write the given String (possibly including NCRs) or ByteArray (with utf-8 contents)
		 StdIOWriteStream stdout nextPutAll: '--- &#16r2713; ==='; flush.
		 StdIOWriteStream stdout nextPutAll: '--- &#10003; ==='; flush.
		 StdIOWriteStream stdout nextPutAll: #[226 156 147]; flush.
		StdIOWriteStream stdout nextPutAll: 'øEl —and˙ toma ag¸ita?', String newLineString; flush.
		StdIOWriteStream stdout nextPutAll: ('øEl —and˙ toma ag¸ita?', String newLineString) asUtf8 ; flush.
	See at the end of this method for a larger example with NCRs for arbitrary Unicode
	"
	| utf8Bytes |
	utf8Bytes _ aStringOrUTF8Bytes isString
		ifTrue: [ aStringOrUTF8Bytes asUtf8Bytes ]
		ifFalse: [ aStringOrUTF8Bytes ].
	self primWrite: fileID from: utf8Bytes startingAt: 1 count: utf8Bytes size.
	^aStringOrUTF8Bytes
"
StdIOWriteStream stdout nextPutAll: '
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
Ü&#948; 	Delta 	
&#917;Ñ 	Epsilon 	
&#918;Ö 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;É 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
á&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
'; flush
"! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:00:10' prior: 50367405 overrides: 16901772!
                            = aString
	"Answer whether the receiver sorts equally as anUtf32String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Expensive. Assume it is extremely unlikely."
	aString isUtf32String ifFalse: [
		^self asUtf8String = aString ].

	^ codePoints = aString words! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/6/2022 11:00:28' prior: 50363942!
                        appendToString: aString

	aString isString ifFalse: [
'pufff' print.
	self halt ].
	^Utf8String withBytes: aString asUtf8Bytes, bytes! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:00:14' prior: 50368185 overrides: 16901772!
               = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	aString isByteString ifTrue: [
		"If aString contains NCRs wit will never equal self. If this ever changes, don't forget about #hash,
		and String >> #="
		^bytes = (aString asUtf8Bytes: false) ].

	^ bytes = aString asUtf8Bytes.! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 6/6/2022 11:00:47' prior: 50347266!
                 retrieveStringOrText: stringClass
	"Answer a Text or a String. Appropriate for a Text Editor."
	| answer |
	
	answer _ self retrieveObject: stringClass.
	
	"If clipboard contents is already a Text or String, answer it."
	(answer isString or: [ answer is: #Text ]) ifTrue: [
		^answer ].
	
	"If clipboard contains a Morph, answer a TextAnchor incuding it..."
	(answer is: #Morph) ifTrue: [
		^ (Text string: (stringClass with: $*) attribute: (TextAnchor new anchoredFormOrMorph: answer)) ].
	
	"If clipboard contains a Form, prepare a Text including it."
	(answer is: #Form) ifTrue: [
		^Text withForm: answer ].
	
	"Answer some string..."
	^answer ifNil: [ stringClass new ] ifNotNil: [ answer printString ]! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 6/6/2022 11:00:55' prior: 50362635!
      storeObject: anObject
	"Set new contents on the clipboard.  Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isString or: [ anObject is: #Text])
		ifTrue: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id _ self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat _ (self stringOrIdFor: contents) asUtf8Bytes.
	self primitiveClipboardString: primitiveFormat! !
!Clipboard methodsFor: 'private' stamp: 'jmv 1/10/2014 10:25' prior: 50347477!
 stringOrIdFor: anObject
	"
	Clipboard default stringOrIdFor: Smalltalk
	"
	anObject isString ifTrue: [ ^anObject ].
	(anObject is: #Text) ifTrue: [ ^anObject string ].
	^self idFor: anObject! !
!CodeFile methodsFor: 'private' stamp: 'jmv 6/6/2022 11:02:06' prior: 50361653!
              msgClassComment: string with: chgRec
	| tokens theClass |
	tokens := Scanner new scanTokens: string.
	(tokens size = 3 and:[(tokens at: 3) isString ]) ifTrue:[
		theClass := self getClass: tokens first.
		^theClass classComment: tokens last].
	(tokens size = 4 and:[(tokens at: 3) asString = 'class' and:[(tokens at: 4) isString ]]) ifTrue:[
		theClass := self getClass: tokens first.
		theClass theMetaClass classComment: tokens last].
! !
!CodeFile methodsFor: 'private' stamp: 'jmv 6/6/2022 11:02:26' prior: 50361670!
                       possibleSystemSource: chgRec
	| tokens |
	sourceSystem isEmpty ifTrue:[
		tokens := Scanner new scanTokens: chgRec string.
		(tokens size = 1 and: [tokens first isString]) ifTrue:[
			sourceSystem := tokens first.
			^self]].
	doIts add: chgRec.! !
!CodePackageFile methodsFor: 'change record types' stamp: 'jmv 6/6/2022 11:02:40' prior: 50361681!
    possibleDescription: chgRec
	| tokens prefix token |
	description isEmpty ifTrue:[
		tokens _ Scanner new scanTokens: chgRec string.
		(tokens size = 1 and: [ (token _ tokens first) isString ]) ifTrue: [
			prefix _ 'Description '.
			(token beginsWith: prefix) ifTrue: [
				description _ token copyFrom: prefix size + 1 to: token size.
				^self ]]].
	doIts add: chgRec.! !

Utf8String removeSelector: #isStringLike!

!methodRemoval: Utf8String #isStringLike stamp: 'Install-5223-isString-not-isStringLike-JuanVuletich-2022Jun06-10h54m-jmv.001.cs.st 6/16/2022 07:24:50'!
isStringLike

	^true!

Utf32String removeSelector: #isStringLike!

!methodRemoval: Utf32String #isStringLike stamp: 'Install-5223-isString-not-isStringLike-JuanVuletich-2022Jun06-10h54m-jmv.001.cs.st 6/16/2022 07:24:50'!
isStringLike

	^true!

String removeSelector: #isStringLike!

!methodRemoval: String #isStringLike stamp: 'Install-5223-isString-not-isStringLike-JuanVuletich-2022Jun06-10h54m-jmv.001.cs.st 6/16/2022 07:24:50'!
isStringLike
	^ true!

Object removeSelector: #isStringLike!

!methodRemoval: Object #isStringLike stamp: 'Install-5223-isString-not-isStringLike-JuanVuletich-2022Jun06-10h54m-jmv.001.cs.st 6/16/2022 07:24:50'!
isStringLike
	"Overridden to return true in String, Utf8String and Utf32String."
	^ false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5223-isString-not-isStringLike-JuanVuletich-2022Jun06-10h54m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5220] on 6 June 2022 at 10:03:46 am'!
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:03:32' prior: 50365612!
                              asLowercase
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^UnicodeCodePoint codePoint: ch asUnaccented asLowercase codePoint ].
	^self! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5224-UnicodeCodePoint-fix-JuanVuletich-2022Jun06-10h03m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5226] on 6 June 2022 at 11:36:52 am'!
!PositionableStream methodsFor: 'positioning' stamp: 'jmv 6/5/2022 18:54:33' prior: 50364823!
                   skip: n
	"Skips the next amount objects in the receiver's future sequence values."

	self position: (self position + n min: self size).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5225-Stream-optimization-JuanVuletich-2022Jun06-11h36m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5226] on 6 June 2022 at 11:37:23 am'!
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/5/2022 19:47:24' prior: 50358293!
          withBytes: aByteArray

	^self new bytes: aByteArray ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5226-UTF8String-dontCheckForBOM-JuanVuletich-2022Jun06-11h36m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5226] on 6 June 2022 at 11:54:07 am'!
!Character methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:36' prior: 16808119!
     < aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	aCharacter isUnicodeCodePoint ifTrue: [ ^aCharacter > self ].
	^String does: self collateBefore: aCharacter! !
!Character methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:40' prior: 16808127!
                         <= aCharacter 
	"Answer whether the receiver is less than or equal to the argument."

	aCharacter isUnicodeCodePoint ifTrue: [ ^aCharacter >= self ].
	^(self > aCharacter) not! !
!Character methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:44' prior: 16808140!
                          > aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	aCharacter isUnicodeCodePoint ifTrue: [ ^aCharacter < self ].
	^String does: self collateAfter: aCharacter! !
!Character methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:48' prior: 16808148!
                          >= aCharacter 
	"Answer whether the receiver is greater than or equal to the argument."

	aCharacter isUnicodeCodePoint ifTrue: [ ^aCharacter <= self ].
	^aCharacter <= self! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:16'!
     < aCodePointOrCharacter

	^self codePoint < aCodePointOrCharacter codePoint! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:20'!
       <= aCodePointOrCharacter

	^self codePoint <= aCodePointOrCharacter codePoint! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:25'!
     > aCodePointOrCharacter

	^self codePoint > aCodePointOrCharacter codePoint! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 6/6/2022 11:53:29'!
       >= aCodePointOrCharacter

	^self codePoint >= aCodePointOrCharacter codePoint! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5227-Character-UnicodeCodePoint-compare-JuanVuletich-2022Jun06-11h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5227] on 6 June 2022 at 12:29:15 pm'!

Utf8String subclass: #Utf8Symbol
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8Symbol category: #'System-Text' stamp: 'Install-5228-Utf8Symbol-JuanVuletich-2022Jun06-12h28m-jmv.001.cs.st 6/16/2022 07:24:50'!
Utf8String subclass: #Utf8Symbol
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 5/30/2022 15:13:02'!
         asSymbol
	^(Utf8String with: self) asSymbol! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/3/2022 10:49:30'!
            asSymbol
	"Answer the unique symbol whose characters are the characters of the string."
	^Symbol intern: self! !
!Utf8String class methodsFor: 'system' stamp: 'jmv 6/3/2022 10:29:49'!
        symbolClassToUse
	"Answer the class to create symbols from us"
	^Utf8Symbol! !
!Utf8Symbol methodsFor: 'comparing' stamp: 'jmv 6/3/2022 10:34:35' overrides: 50368630!
                         = another

	"Use == between two symbols..."
	self == another ifTrue: [
		^ true].  "Was == "
	another isSymbol ifTrue: [
		^ false].  "Was not ==, therefore can't be = "

	"Otherwise use string =..."
	^ super = another! !
!Utf8Symbol methodsFor: 'converting' stamp: 'jmv 6/6/2022 12:00:10' overrides: 50351466!
         asPlainString
	"Answer a plain String, not a Symbol."
	^Utf8String fromUtf8Bytes: bytes.! !
!Utf8Symbol methodsFor: 'converting' stamp: 'jmv 6/6/2022 12:00:21' overrides: 50351472!
           asString
	^ self asPlainString! !
!Utf8Symbol methodsFor: 'converting' stamp: 'jmv 6/3/2022 10:49:43' overrides: 50368954!
     asSymbol! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/3/2022 10:34:29' overrides: 16903434!
                              isSymbol
	^ true! !
!Utf8Symbol class methodsFor: 'private' stamp: 'jmv 6/3/2022 11:09:33'!
    basicFromString: aString
	"Private use. Answers an instance that is not yet interned.
	Can break the Symbol invariant: forAllSymbols, (s1 = s2) => (s1 == s2)
	Please don't call lightly."

	^self basicNew bytes: aString asUtf8Bytes! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5228-Utf8Symbol-JuanVuletich-2022Jun06-12h28m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5220] on 6 June 2022 at 10:03:28 am'!
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 09:50:43'!
                  commonPartWith: aString startAt: startIndex stopAt: stopIndexRequested applying: aBlock
	"Return the size of the longest common subsequence with aString, only between startIndex and stopIndex.
	Apply aBlock to each character before comparing.
	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."
	| stopIndex |
	stopIndex _ stopIndexRequested min: aString size.
	startIndex
		to: stopIndex
		do: [ :i |
			(aBlock value: (self at: i)) = (aBlock value: (aString at: i)) ifFalse: [ ^ i - 1 ]].
	^ stopIndex! !
!Trie methodsFor: 'enumerating' stamp: 'jmv 6/6/2022 08:59:31' prior: 16974763!
                               keysDo: aBlock

	self keysAndValuesDo: [ :k :v | aBlock value: k ]! !
!Trie methodsFor: 'enumerating' stamp: 'jmv 6/6/2022 08:59:37' prior: 16974769!
          valuesDo: aBlock

	self keysAndValuesDo: [ :k :v | aBlock value: v ]! !
!TrieNode methodsFor: 'private' stamp: 'jmv 6/6/2022 09:33:06' prior: 16974993!
        childFor1: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil.
	This method for the case where we currently have exactly one child."
	| nextSegmentStart nextSegmentFirst answer |

	nextSegmentStart _ i + segmentSize.
	nextSegmentFirst _ nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	childrenFirstChars = nextSegmentFirst ifTrue: [ ^ children].

	doAdd ifFalse: [ ^ nil ].
	
	answer _ nextSegmentStart > aString size
		ifTrue: [ TrieLeaf new ]
		ifFalse: [ TrieNode someKey: aString segmentStart: nextSegmentStart ].

	"Just one child, if adding, convert references to a collection"
	nextSegmentFirst < childrenFirstChars
		ifTrue: [
			children _ {answer . children }.
			childrenFirstChars _ Array with: nextSegmentFirst with: childrenFirstChars ]
		ifFalse: [
			children _ {children . answer}.
			childrenFirstChars _ Array with: childrenFirstChars with: nextSegmentFirst ].
	^answer! !
!TrieNode methodsFor: 'private' stamp: 'jmv 6/6/2022 09:32:06' prior: 16975031!
    childFor: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."

	"No children yet"
	childrenFirstChars ifNil: [
		doAdd ifTrue: [
			children _ TrieLeaf new.
			childrenFirstChars _ TrieNode characterForLeaf ].
		^children ].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		^ self childFor1: aString characterIndex: i orAdd: doAdd ].

	"Already more than one child. If adding, convert to a bigger collection."
	^self childForN: aString characterIndex: i orAdd: doAdd! !
!TrieNode methodsFor: 'private' stamp: 'jmv 6/6/2022 09:30:11' prior: 16975055!
        childForN: aString characterIndex: i orAdd: doAdd
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil.
	This method for the case where we currently have more than one child."
	| answer newChildren newFirstChars nextSegmentFirst nextSegmentStart s |

	nextSegmentStart _ i + segmentSize.
	nextSegmentFirst _ nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found | ^ children at: found ]
		ifNone: [ :a :b |
			"Already more than one child. If adding, convert to a bigger collection."
			doAdd
				ifFalse: [ ^nil]
				ifTrue: [
					 answer _ nextSegmentStart > aString size
						ifTrue: [ TrieLeaf new ]
						ifFalse: [  TrieNode someKey: aString segmentStart: nextSegmentStart ].
					s _ children size + 1.
					newChildren _ Array new: s.
					newChildren
						replaceFrom: 1 to: a with: children startingAt: 1;
						at: a+1 put: answer;
						replaceFrom: a+2 to: s with: children startingAt: a+1.
					newFirstChars _ Array new: s.
					newFirstChars
						replaceFrom: 1 to: a with: childrenFirstChars startingAt: 1;
						at: a+1 put: nextSegmentFirst;
						replaceFrom: a+2 to: s with: childrenFirstChars startingAt: a+1.
					children _ newChildren.
					childrenFirstChars _ newFirstChars.
					^answer ]]! !
!TrieNode methodsFor: 'private' stamp: 'jmv 6/6/2022 09:32:10' prior: 16975107!
                            removeChildFor: aString characterIndex: i
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."
	| nextSegmentStart nextSegmentFirst |

	nextSegmentStart _ i + segmentSize.
	nextSegmentFirst _ nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		childrenFirstChars = nextSegmentFirst
			ifTrue: [ childrenFirstChars _ nil. children _ nil ].
		^self ].
	
	"Already more than one child."
	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found |
			childrenFirstChars size = 2
				ifTrue: [		"Two children: remove the arrays"
					childrenFirstChars _ childrenFirstChars at: 3-found.
					children _ children at: 3-found ]
				ifFalse: [	"More than two children. condense the arrays"
					childrenFirstChars _ (childrenFirstChars copyFrom: 1 to: found-1), 
						(childrenFirstChars copyFrom: found+1 to: childrenFirstChars size).
					children _ (children copyFrom: 1 to: found-1), (children copyFrom: found+1 to: children size) ]]
		ifNone: [].! !

TrieNode removeSelector: #usedMemory!

!methodRemoval: TrieNode #usedMemory stamp: 'Install-5229-Trie-Utf8StringCompatibility-JuanVuletich-2022Jun06-10h00m-jmv.001.cs.st 6/16/2022 07:24:50'!
usedMemory
	| s |
	s _ 4 "Object header for a compact class"
		+ (4*4). "4 instance variables"

	childrenFirstChars isString 
		ifTrue: [
			"String is a compact class of bytes"
			s _  childrenFirstChars size + 4 + s.
			"Array is a compact class of words"
			s _ children size * 4 + 4 + s.
			children do: [ :c | 
				s _ c usedMemory + s ]]
		ifFalse: [
			children ifNotNil: [ s _ s + children usedMemory ]].
	^s!

TrieLeaf removeSelector: #usedMemory!

!methodRemoval: TrieLeaf #usedMemory stamp: 'Install-5229-Trie-Utf8StringCompatibility-JuanVuletich-2022Jun06-10h00m-jmv.001.cs.st 6/16/2022 07:24:50'!
usedMemory
	| s |
	s _ 4 "Object header for a compact class"
		+ (2*4). "2 instance variables"

	keys isArray ifTrue: [
		"Array is a compact class of words"
		s _ keys size * 4 + 4 + s.
		s _ values size * 4 + 4 + s ].
	^s!

Trie removeSelector: #usedMemory!

!methodRemoval: Trie #usedMemory stamp: 'Install-5229-Trie-Utf8StringCompatibility-JuanVuletich-2022Jun06-10h00m-jmv.001.cs.st 6/16/2022 07:24:50'!
usedMemory
	^rootNode usedMemory + 12 "object header+ 1 ivar"!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmalltalkCompleter initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5229-Trie-Utf8StringCompatibility-JuanVuletich-2022Jun06-10h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5213] on 2 June 2022 at 3:49:24 pm'!
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 6/2/2022 15:48:59' prior: 50335951!
                    testSuiteForCategoryOf: aClass

	| selectedSystemCategory |
	
	"If we are in a senders or implementors window, a MessageSet, the selectedSystemCategory is nil.
	In that case most of those cases the user wants to run the tests of the category of the selected method class - Hernan"
	selectedSystemCategory := self codeProvider selectedSystemCategory ifNil: [ aClass category ].
	^TestSuite forSystemCategoryNamed: selectedSystemCategory using: SystemOrganization 
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5230-RunningTestFromMessageSetWindow-HernanWilkinson-2022Jun02-15h48m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5230] on 6 June 2022 at 3:49:35 pm'!

Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index hash strideIndex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5231-UtfString-Refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st 6/16/2022 07:24:51'!
Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index hash strideIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!Utf8String methodsFor: 'private' stamp: 'jmv 6/6/2022 15:49:28' prior: 50351648!
                             beAscii
	"Mark me as being pure 7-bit ASCII, which means each character is encoded as one byte"
	
	count := bytes size.
	strideIndex := #().! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/6/2022 15:49:28' prior: 50351662!
                              byteIndexAt: codePointIndex
	| byteIndex |
	self isAscii ifTrue: [ ^ codePointIndex ].
	codePointIndex = (self size+1) ifTrue: [
		"The position a hypotetical extra code point would start at.
		Useful to find the last byte position for some codePointIndex. See senders."
		^bytes size+1 ].
	byteIndex := codePointIndex > self stride
		ifTrue: [
			strideIndex at: codePointIndex - 1 // self stride ]
		ifFalse: [ 1 ].
	codePointIndex - 1 \\ self stride timesRepeat: [ 
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ].
	^ byteIndex! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/6/2022 15:49:28' prior: 50351682!
      codePointIndexAt: byteIndex
	| codePointIndex byteCursor |
	self isAscii ifTrue: [ ^ byteIndex ].
	codePointIndex := byteCursor := 1.
	strideIndex ifNil: [ self computeCountAndIndex ].
	strideIndex ifNotEmpty: [  
		strideIndex 
			findBinaryIndex: [ :x | byteIndex - x ] 
			do: [ :found | ^ (found * self stride) + 1 ] 
			ifNone: [ :lower :upper |
				lower = 0 
			 		ifFalse: [ 
						byteCursor := strideIndex at: lower. 
						codePointIndex := (lower * self stride) + 1 ] ] ].
	[ byteCursor <= bytes size ] whileTrue: [
		byteCursor = byteIndex 
			ifTrue: [ ^ codePointIndex ].
		byteCursor := byteCursor + (self encodedByteCountAt: byteCursor).
		codePointIndex := codePointIndex + 1 ].
	^ 0! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/6/2022 15:49:28' prior: 50367480!
             computeCountAndIndex
	self isEmpty ifTrue: [ count := 0. strideIndex := #(). ^ self ].
	"the number of characters cannot be larger than the byte size"
	bytes size <= self stride
		ifTrue: [ self computeCountNoIndex ]
		ifFalse: [ self computeCountAndIndexFull ]! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/6/2022 15:49:28' prior: 50351716!
     computeCountAndIndexFull
	count := 0.
	strideIndex := Array streamContents: [ :out | | byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/6/2022 15:49:28' prior: 50351730!
     computeCountNoIndex
	| byteIndex |
	count := 0.
	strideIndex := #().
	byteIndex := 1.
	[ byteIndex <= bytes size ] whileTrue: [
		count := count + 1.
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ]! !

Object subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5231-UtfString-Refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st 6/16/2022 07:24:51'!
Object subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5231-UtfString-Refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5230] on 6 June 2022 at 3:50:59 pm'!

SequenceableCollection subclass: #EncodedString
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #EncodedString category: #'System-Text' stamp: 'Install-5232-UtfString-refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st 6/16/2022 07:24:51'!
SequenceableCollection subclass: #EncodedString
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

EncodedString subclass: #Utf32String
	instanceVariableNames: 'codePoints hash '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf32String category: #'System-Text' stamp: 'Install-5232-UtfString-refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st 6/16/2022 07:24:51'!
EncodedString subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

EncodedString subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5232-UtfString-refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st 6/16/2022 07:24:51'!
EncodedString subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

EncodedString subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf32String category: #'System-Text' stamp: 'Install-5232-UtfString-refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st 6/16/2022 07:24:51'!
EncodedString subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

EncodedString subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5232-UtfString-refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st 6/16/2022 07:24:51'!
EncodedString subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5232-UtfString-refactor-JuanVuletich-2022Jun06-15h49m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5230] on 6 June 2022 at 4:21:28 pm'!
!EncodedString methodsFor: 'copying' stamp: 'jmv 6/6/2022 16:06:18'!
                         appendToText: aText

	| textStringSize |
	textStringSize := aText string size.
	^ aText replaceFrom: textStringSize + 1
			 to: textStringSize 
			 with: self asText! !
!EncodedString methodsFor: 'comparing' stamp: 'jmv 6/6/2022 16:14:15'!
                commonPartWith: aString startAt: startIndex stopAt: stopIndexRequested applying: aBlock
	"Return the size of the longest common subsequence with aString, only between startIndex and stopIndex.
	Apply aBlock to each character before comparing.
	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."
	| stopIndex |
	stopIndex _ stopIndexRequested min: aString size.
	startIndex
		to: stopIndex
		do: [ :i |
			(aBlock value: (self at: i)) = (aBlock value: (aString at: i)) ifFalse: [ ^ i - 1 ]].
	^ stopIndex! !
!EncodedString methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:07:16'!
       asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8Bytes: self asUtf8Bytes! !
!EncodedString methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:07:58'!
      asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!EncodedString methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:08:08' overrides: 16901837!
                  asString
	"Answer the receiver itself."
	^self! !
!EncodedString methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:06:38'!
      asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!EncodedString methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:07:34'!
       asUtf8Bytes
	^self subclassResponsibility! !
!EncodedString methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:16:29'!
           contractTo: smallSize
	"return myself or a copy shortened by ellipsis to smallSize"
	| leftSize |
	self size <= smallSize
		ifTrue: [^ self].  "short enough"
	smallSize < 5
		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"
	leftSize _ smallSize-2//2.
	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"
		to: self size - (smallSize - leftSize - 3)
		with: '...'
"
	(Utf8String withBytes: 'A clear but rather long-winded summary' asUtf8) contractTo: 18
"! !
!EncodedString methodsFor: 'enumerating' stamp: 'jmv 6/6/2022 16:13:15' overrides: 16934336!
                            collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacter ]) ifFalse: [
		^array ].
	^self class newFrom: array! !
!EncodedString methodsFor: 'enumerating' stamp: 'jmv 6/6/2022 16:13:44'!
    collectInArray: aBlock
	"Refer to the comment in Collection|collect:."
	| result i |
	result _ Array new: self size.
	i _ 1.
	self do: [ :codePoint |
		result at: i put: codePoint.
		i _ i + 1 ].
	^ result.! !
!EncodedString methodsFor: 'testing' stamp: 'jmv 6/6/2022 16:19:41' overrides: 50368461!
                     isString
	^true! !
!EncodedString methodsFor: 'user interface' stamp: 'jmv 6/6/2022 16:17:30'!
 edit

	self editLabel: self class name, ' Text Editor'! !
!EncodedString methodsFor: 'user interface' stamp: 'jmv 6/6/2022 16:18:04'!
                          editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 16:15:46'!
              basicHash
	"Same hash value as a pure ASCII String.
	Some other reasonable hash value otherwise, but not the same as the one of the equivalent String if ISO-8859 non ASCII characters are present."
	bytes size > 256 ifTrue: [ ^ bytes hashQuick ].
	^ByteArray
		hashBytes: bytes
		startingWith: String hash! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:09:55' prior: 50363880!
                      asUtf32String
	"Answer an instance of the UTF-32 encoded String class"

	^self! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/6/2022 16:05:42' prior: 50368622!
                            appendToString: aString

	^Utf8String withBytes: aString asUtf8Bytes, bytes! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 16:16:05' prior: 50367326!
                             computeHash
	"Same hash value as the equivalent ASCII String, provided that all our CodePoints exist as Characters"
	| basicHash byteString |
	basicHash _ self basicHash.
	self isAscii ifTrue: [
		^basicHash ].
	"If there's a String that is equal to us (i.e. no NCRs were needed to represent us)"
	byteString _ self asByteString.
	byteString size = self size ifTrue: [
		^byteString hash ].
	"Otherwise, use a hash that doesn't need to equal that of a String"
	^basicHash
! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/6/2022 16:09:45' prior: 50363963!
               asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	^self! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/6/2022 16:12:02' prior: 50351655!
                              boundsCheck: codePointIndex
	(self isInBounds: codePointIndex) 
		ifFalse: [ self errorSubscriptBounds: codePointIndex ]! !

Utf8String removeSelector: #commonPartWith:startAt:stopAt:applying:!

!methodRemoval: Utf8String #commonPartWith:startAt:stopAt:applying: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
commonPartWith: aString startAt: startIndex stopAt: stopIndexRequested applying: aBlock
	"Return the size of the longest common subsequence with aString, only between startIndex and stopIndex.
	Apply aBlock to each character before comparing.
	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."
	| stopIndex |
	stopIndex _ stopIndexRequested min: aString size.
	startIndex
		to: stopIndex
		do: [ :i |
			(aBlock value: (self at: i)) = (aBlock value: (aString at: i)) ifFalse: [ ^ i - 1 ]].
	^ stopIndex!

Utf8String removeSelector: #appendToText:!

!methodRemoval: Utf8String #appendToText: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
appendToText: aText

	| textStringSize |
	textStringSize := aText string size.
	^ aText replaceFrom: textStringSize + 1
			 to: textStringSize 
			 with: self asText!

Utf8String removeSelector: #at:ifAbsent:!

!methodRemoval: Utf8String #at:ifAbsent: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
at: codePointIndex ifAbsent: absentBlock
	"Answer the UnicodeCodePoint at code point index codePointIndex (not a byte index!!)"

	(codePointIndex between: 1 and: self size) ifFalse: [ ^absentBlock value ].
	^self at: codePointIndex!

Utf8String removeSelector: #asByteString!

!methodRemoval: Utf8String #asByteString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8Bytes: bytes!

Utf8String removeSelector: #last!

!methodRemoval: Utf8String #last stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
last
	"Answer the last element of the receiver.
	Raise an error if the collection is empty."

	| size |
	(size _ self size) = 0 ifTrue: [self error: 'Empty Utf8String'].
	^ self at: size!

Utf8String removeSelector: #editLabel:!

!methodRemoval: Utf8String #editLabel: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
editLabel: labelString

	(TextModel withText: self) openLabel: labelString!

Utf8String removeSelector: #contents!

!methodRemoval: Utf8String #contents stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
contents
	^self!

Utf8String removeSelector: #isString!

!methodRemoval: Utf8String #isString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
isString
	^true!

Utf8String removeSelector: #edit!

!methodRemoval: Utf8String #edit stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
edit

	self editLabel: 'UTF-8 Text Editor'!

Utf8String removeSelector: #asString!

!methodRemoval: Utf8String #asString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asString
	"Answer the receiver itself."
	^self!

Utf8String removeSelector: #collect:!

!methodRemoval: Utf8String #collect: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacter ]) ifFalse: [
		^array ].
	^Utf8String newFrom: array!

Utf8String removeSelector: #canHoldCodePoints!

!methodRemoval: Utf8String #canHoldCodePoints stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
canHoldCodePoints

	^true!

Utf8String removeSelector: #asText!

!methodRemoval: Utf8String #asText stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self!

Utf8String removeSelector: #asPlainString!

!methodRemoval: Utf8String #asPlainString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self!

Utf8String removeSelector: #computeHashForAscii!

!methodRemoval: Utf8String #computeHashForAscii stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
computeHashForAscii
	"Same hash value as a pure ASCII String.
	Some other reasonable hash value otherwise, but not the same as the one of the equivalent String if ISO-8859 non ASCII characters are present."
	bytes size > 256 ifTrue: [ ^ bytes hashQuick ].
	^ByteArray
		hashBytes: bytes
		startingWith: String hash!

Utf8String removeSelector: #notEmpty!

!methodRemoval: Utf8String #notEmpty stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
notEmpty
	"Answer whether the receiver contains any elements."

	^ self isEmpty not!

Utf8String removeSelector: #collectInArray:!

!methodRemoval: Utf8String #collectInArray: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
collectInArray: aBlock
	"Refer to the comment in Collection|collect:."
	| result i |
	result _ Array new: self size.
	i _ 1.
	self do: [ :codePoint |
		result at: i put: codePoint.
		i _ i + 1 ].
	^ result.!

Utf8String removeSelector: #contractTo:!

!methodRemoval: Utf8String #contractTo: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
contractTo: smallSize
	"return myself or a copy shortened by ellipsis to smallSize"
	| leftSize |
	self size <= smallSize
		ifTrue: [^ self].  "short enough"
	smallSize < 5
		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"
	leftSize _ smallSize-2//2.
	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"
		to: self size - (smallSize - leftSize - 3)
		with: '...'
"
	(Utf8String withBytes: 'A clear but rather long-winded summary' asUtf8) contractTo: 18
"!

Utf32String removeSelector: #from:to:do:!

!methodRemoval: Utf32String #from:to:do: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
from: start to: stop do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	start to: stop do: [ :index | aBlock value: (self at: index) ].!

Utf32String removeSelector: #appendToText:!

!methodRemoval: Utf32String #appendToText: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
appendToText: aText

	| textStringSize |
	textStringSize := aText string size.
	^ aText replaceFrom: textStringSize + 1
			 to: textStringSize 
			 with: self asText!

Utf32String removeSelector: #at:ifAbsent:!

!methodRemoval: Utf32String #at:ifAbsent: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
at: codePointIndex ifAbsent: absentBlock
	"Answer the UnicodeCodePoint at codePointIndex"

	(codePointIndex between: 1 and: self size) ifFalse: [ ^absentBlock value ].
	^self at: codePointIndex!

Utf32String removeSelector: #asByteString!

!methodRemoval: Utf32String #asByteString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8Bytes: self asUtf8Bytes!

Utf32String removeSelector: #last!

!methodRemoval: Utf32String #last stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
last
	"Answer the last element of the receiver.
	Raise an error if the collection is empty."

	| size |
	(size _ self size) = 0 ifTrue: [self error: 'Empty Utf32String'].
	^ self at: size!

Utf32String removeSelector: #canHoldCodePoints!

!methodRemoval: Utf32String #canHoldCodePoints stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
canHoldCodePoints

	^true!

Utf32String removeSelector: #collect:!

!methodRemoval: Utf32String #collect: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
collect: aBlock
	"Refer to the comment in Collection|collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacter ]) ifFalse: [
		^array ].
	^Utf32String newFrom: array!

Utf32String removeSelector: #asText!

!methodRemoval: Utf32String #asText stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self!

Utf32String removeSelector: #editLabel:!

!methodRemoval: Utf32String #editLabel: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
editLabel: labelString

	(TextModel withText: self) openLabel: labelString!

Utf32String removeSelector: #isString!

!methodRemoval: Utf32String #isString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
isString
	^true!

Utf32String removeSelector: #do:!

!methodRemoval: Utf32String #do: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
do: aBlock
	self from: 1 to: codePoints size do: aBlock!

Utf32String removeSelector: #asPlainString!

!methodRemoval: Utf32String #asPlainString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self!

Utf32String removeSelector: #notEmpty!

!methodRemoval: Utf32String #notEmpty stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
notEmpty
	"Answer whether the receiver contains any elements."

	^ self isEmpty not!

Utf32String removeSelector: #collectInArray:!

!methodRemoval: Utf32String #collectInArray: stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
collectInArray: aBlock
	"Refer to the comment in Collection|collect:."
	| result i |
	result _ Array new: self size.
	i _ 1.
	self do: [ :codePoint |
		result at: i put: codePoint.
		i _ i + 1 ].
	^ result.!

Utf32String removeSelector: #edit!

!methodRemoval: Utf32String #edit stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
edit

	self editLabel: 'UTF-32 Text Editor'!

Utf32String removeSelector: #asString!

!methodRemoval: Utf32String #asString stamp: 'Install-5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st 6/16/2022 07:24:51'!
asString
	"Answer the receiver itself."
	^self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5233-UtfString-refactor-JuanVuletich-2022Jun06-15h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5237] on 6 June 2022 at 4:28:22 pm'!
!String methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:06'!
                 firstNonSeparator

	^self findFirst: [:aChar | aChar isSeparator not ]! !
!String methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:54'!
                     lastNonSeparator

	^ self findLast: [:aChar | aChar isSeparator not].
	! !
!String methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:10' prior: 16948030!
    afterBlanksEndsWith: aTail

	^(self endsWith: aTail) and: [ self firstNonSeparator = (self size - aTail size + 1) ]
! !
!String methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:59' prior: 16948717!
                       withBlanksTrimmed
	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."

	| first |
	
	first _ self firstNonSeparator.
	first = 0 ifTrue: [^ ''].  "no non-separator character"
	
	^ self copyFrom: first to: self lastNonSeparator 

	" ' abc  d   ' withBlanksTrimmed"
! !
!String methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:16' prior: 16948809!
                             withoutLeadingBlanks
	
	"Return a copy of the receiver from which leading blanks have been trimmed."
	
	| first |
	
	first := self firstNonSeparator.
	first = 0 ifTrue: [^ ''].  
	first = 1 ifTrue: [^ self ].
	
	"no non-separator character"	
	^ self copyFrom: first to: self size
		
	" '    abc  d  ' withoutLeadingBlanks"
! !
!String methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:37:02' prior: 16948843!
        withoutTrailingBlanks
	"Return a copy of the receiver from which trailing blanks have been trimmed."

	| last |
	
	last _ self lastNonSeparator.
	last = 0 ifTrue: [^ ''].  "no non-separator character"
	last = self size ifTrue: [ ^self ].
	
	^ self copyFrom: 1 to: last

	" ' abc  d   ' withoutTrailingBlanks"
! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 6/6/2022 15:36:19' prior: 50342499!
   logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString _ aStringOrText asPlainString.
	aString firstNonSeparator = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			self forceChangesToDisk ]].
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString ]]! !

String removeSelector: #firstNoBlankIndex!

!methodRemoval: String #firstNoBlankIndex stamp: 'Install-5234-String-Refactor-JuanVuletich-2022Jun06-16h24m-jmv.001.cs.st 6/16/2022 07:24:51'!
firstNoBlankIndex 

	^self findFirst: [:aChar | aChar isSeparator not ]!

String removeSelector: #lastNoBlankIndex!

!methodRemoval: String #lastNoBlankIndex stamp: 'Install-5234-String-Refactor-JuanVuletich-2022Jun06-16h24m-jmv.001.cs.st 6/16/2022 07:24:51'!
lastNoBlankIndex

	^ self findLast: [:aChar | aChar isSeparator not].
	!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5234-String-Refactor-JuanVuletich-2022Jun06-16h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5234] on 11 June 2022 at 8:28:35 pm'!

MessageSet subclass: #InlineMethodMessageSendsSet
	instanceVariableNames: 'applier selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodMessageSendsSet category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
MessageSet subclass: #InlineMethodMessageSendsSet
	instanceVariableNames: 'applier selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MessageSetWindow subclass: #InlineMethodWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodWizardStepWindow category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
MessageSetWindow subclass: #InlineMethodWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

InlineMethodWizardStepWindow subclass: #InlineMethodImplementorsStepWindow
	instanceVariableNames: 'selectedImplementor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodImplementorsStepWindow category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
InlineMethodWizardStepWindow subclass: #InlineMethodImplementorsStepWindow
	instanceVariableNames: 'selectedImplementor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

InlineMethodImplementorsStepWindow subclass: #InlineMethodImplementorsWithShowUsagesStepWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodImplementorsWithShowUsagesStepWindow category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
InlineMethodImplementorsStepWindow subclass: #InlineMethodImplementorsWithShowUsagesStepWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

InlineMethodWizardStepWindow subclass: #InlineMethodUsagesStepWindow
	instanceVariableNames: 'changedMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodUsagesStepWindow category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
InlineMethodWizardStepWindow subclass: #InlineMethodUsagesStepWindow
	instanceVariableNames: 'changedMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

InlineMethodUsagesStepWindow subclass: #InlineMethodUsagesWithShowImplementorsStepWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodUsagesWithShowImplementorsStepWindow category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
InlineMethodUsagesStepWindow subclass: #InlineMethodUsagesWithShowImplementorsStepWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #MessageNodeReference
	instanceVariableNames: 'messageNode selector classReference completeSourceRange methodNode stringVersion'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #MessageNodeReference category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
Object subclass: #MessageNodeReference
	instanceVariableNames: 'messageNode selector classReference completeSourceRange methodNode stringVersion'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MessageNodeReference subclass: #PossibleMessageNodeReference
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PossibleMessageNodeReference category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
MessageNodeReference subclass: #PossibleMessageNodeReference
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #InlineMethod
	instanceVariableNames: 'methodToInline messageSendsToInline updatedSendersCode methodNodeToInline replacementsByMessageSend temporariesDeclarationsByNode temporariesToDeclareByInsertionPoint implementorCompleteSourceRanges removeMethod'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethod category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
Refactoring subclass: #InlineMethod
	instanceVariableNames: 'methodToInline messageSendsToInline updatedSendersCode methodNodeToInline replacementsByMessageSend temporariesDeclarationsByNode temporariesToDeclareByInsertionPoint implementorCompleteSourceRanges removeMethod'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #InlineTemporaryVariable
	instanceVariableNames: 'variableToInline methodToRefactor updatedSourceCode methodNode oldVariableNode usageToInline sourceCodeChanges methodOrBlockNodeDeclaringTemporary rangeOfNodeDeclaringTemporary assignmentToInlineRange endOfNodeEnclosingAssignment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineTemporaryVariable category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
Refactoring subclass: #InlineTemporaryVariable
	instanceVariableNames: 'variableToInline methodToRefactor updatedSourceCode methodNode oldVariableNode usageToInline sourceCodeChanges methodOrBlockNodeDeclaringTemporary rangeOfNodeDeclaringTemporary assignmentToInlineRange endOfNodeEnclosingAssignment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #InlineMethodApplier
	instanceVariableNames: 'selectorToInline scopeChoice implementors messageSends selectedClass wizardStepWindow shouldShowChanges browser shouldRemoveImplementor triggeringMessageSend shouldInlineTriggeringMessageSendOnly'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodApplier category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
RefactoringApplier subclass: #InlineMethodApplier
	instanceVariableNames: 'selectorToInline scopeChoice implementors messageSends selectedClass wizardStepWindow shouldShowChanges browser shouldRemoveImplementor triggeringMessageSend shouldInlineTriggeringMessageSendOnly'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #InlineTemporaryVariableApplier
	instanceVariableNames: 'codeProvider temporaryToInline usageInterval methodToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineTemporaryVariableApplier category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:51'!
RefactoringApplier subclass: #InlineTemporaryVariableApplier
	instanceVariableNames: 'codeProvider temporaryToInline usageInterval methodToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!CompiledMethod methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:28:05'!
 referencesSelf

	^self methodNode referencesSelf! !
!CompiledMethod methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:28:09'!
     referencesSuper

	^self methodNode referencesSuper! !
!Interval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:29:34' overrides: 16823915!
                     includesAllOf: aCollection

	^aCollection isInterval
		ifTrue: [ (self includes: aCollection first)
			and: [ (self includes: aCollection last)
			and: [ self increment = aCollection increment or: [ super includesAllOf:aCollection ]]]]
		ifFalse: [ super includesAllOf: aCollection ]! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 6/11/2022 19:30:38'!
                  codeAfterIntervalOn: aSourceCode

	^ aSourceCode copyFrom: (self last + 1) to: aSourceCode size! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 6/11/2022 19:36:07'!
              expandUntilStartOfNextStatementOn: aSourceCode

	"Expands a source code interval containing a valid expression until the next statement. If there isn't one, the interval is not modified.
	Examples:
	- The interval *a := 1 + 2.*   b = 3 + 4.	 is expanded to *a := 1 + 2.   *b = 3 + 4.
	- The interval *a := 1 + 2.*  '
		 b = 3 + 4.	 is expanded to
		*a := 1 + 2.
		   *b = 3 + 4.
	- The interval *| a b |*
		a : =1. is expanded to
		*| a b |
		*a := 1.

	TODO: improve to take into account that there could be a comment in the middle of the statements or
	 after the last statement - Fernando"

	((self last >= aSourceCode size)
		or:[ (self isEndOfLastStatementOn: aSourceCode)
		or:[self isLastStatementOfBlockOn: aSourceCode]]) ifTrue: [^self class from: self first to: self last].

	((self isEndOfTemporariesDeclarationOn: aSourceCode) or: [self endsOnDotOn: aSourceCode ])
		ifTrue: [^self expandUntilNextNonBlankCharacterOn: aSourceCode ].

	(self nextNonBlankCharacterIsDotOn: aSourceCode)
		ifTrue: [^(self expandUntilStatementEndOn: aSourceCode) expandUntilStartOfNextStatementOn: aSourceCode ].

	self error: self class canNotExpandIncompleteStatementError.
	! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 6/11/2022 19:34:10'!
                             expandUntilStatementEndOn: aSourceCode

	^SourceCodeInterval
		from: self first
		to: (aSourceCode findDelimiters: '.' startingAt: self last)
	! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 6/11/2022 19:34:23'!
                              lastCharacterOfRangeOn: aSourceCode

	^aSourceCode at: self last! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 6/11/2022 19:34:48'!
             nextNonBlankCharacterIs: aCharacter on: aSourceCode

	| codeAfterInterval firstNonBlankIndex |

	codeAfterInterval := self codeAfterIntervalOn: aSourceCode.

	firstNonBlankIndex := codeAfterInterval firstNonSeparator.

	^firstNonBlankIndex ~= 0 and: [(codeAfterInterval at: firstNonBlankIndex) = aCharacter]
! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 6/11/2022 19:35:00'!
                         nextNonBlankCharacterIsDotOn: aSourceCode

	^self nextNonBlankCharacterIs: $. on: aSourceCode.
	! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:22'!
                 endsOnDotOn: aSourceCode

	^(self lastCharacterOfRangeOn: aSourceCode) = $.! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:32:09'!
      intervalEndsOnEndOfStatementIn: aSourceCode

	^(self endsOnDotOn: aSourceCode)
		or: [ (self nextNonBlankCharacterIsDotOn: aSourceCode)
	 	or: [self isEndOfTemporariesDeclarationOn: aSourceCode ]].! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:03'!
            isEndOfLastStatementOn: aSourceCode

	^((self lastCharacterOfRangeOn: aSourceCode) isSeparator not)
		and: [(self codeAfterIntervalOn: aSourceCode) firstNonSeparator = 0].
	! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:07'!
    isEndOfTemporariesDeclarationOn: aSourceCode

	^((self lastCharacterOfRangeOn: aSourceCode) = $|) and: [^(aSourceCode indexOf: $|) < self last]! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:11'!
  isLastStatementOfBlockOn: aSourceCode

	^self nextNonBlankCharacterIs: $] on: aSourceCode.! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 6/11/2022 18:57:06'!
                   expandUntilNextNonBlankCharacterOn: aSourceCode

	^SourceCodeInterval from: self first to: (self last +
		(aSourceCode copyFrom: (self last + 1) to: (aSourceCode size)) firstNonSeparator - 1)
	! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:43:52'!
                         isMethodNode

	^false! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:44:17'!
     referencesSelf

	^ false! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:44:05'!
  referencesSuper

	^false! !
!AssignmentNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:44:54' overrides: 50370511!
         referencesSelf

	^variable referencesSelf or: [value referencesSelf]! !
!AssignmentNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:44:57' overrides: 50370514!
                             referencesSuper

	^variable referencesSuper or: [value referencesSuper]! !
!BlockNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:38:06' overrides: 50370511!
                               referencesSelf

	^self statements anySatisfy: [:aParseNode | aParseNode referencesSelf]! !
!BlockNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:38:09' overrides: 50370514!
               referencesSuper

	^self statements anySatisfy: [:aParseNode | aParseNode referencesSuper]! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 6/11/2022 19:38:58'!
                         completeSourceRangesOf: requestedParseNode ifAbsent: emptySourceRangesBlock
	"Returns the source ranges associated with the requested parse node."

	| completeSourceRanges |

	completeSourceRanges := Set new.

	"There may be more than one equivalent key in the complete source ranges map
	if more than one block declare a temporary variable with the same name - Fernando"
	self completeSourceRangesDo: [:parseNode :sourceRanges |
		(parseNode equivalentTo: requestedParseNode) ifTrue: [completeSourceRanges addAll: sourceRanges]].

	completeSourceRanges isEmpty ifFalse: [^completeSourceRanges ] ifTrue: [^emptySourceRangesBlock value].
	! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 6/11/2022 19:42:44' prior: 16890115!
    singleCompleteSourceRangeOf: requestedParseNode
	"Returns the source range associated with the requested parse node.
	Fails if there is no source range, or if there are multiple source ranges."

	^self
		singleCompleteSourceRangeOf: requestedParseNode
		ifPresent: [ :sourceRange | sourceRange ]
		ifAbsent: [ self error: 'could not find source range for node: ' , requestedParseNode printString ]! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 6/11/2022 19:42:35' prior: 16890130!
                     singleCompleteSourceRangeOf: requestedParseNode ifPresent: sourceRangePresentBlock ifAbsent: sourceRangeAbsentBlock
	"Finds the source range associated with the requested parse node.
	If it is present, evaluates sourceRangePresentBlock with the result.
	Otherwise, it evaluates sourceRangeAbsentBlock.
	Raises an error if the requested parse node has multiple source ranges"
	| sourceRanges |

	sourceRanges := self
		completeSourceRangesOf: requestedParseNode
		ifAbsent: [^sourceRangeAbsentBlock value].

	^sourceRanges size > 1
		ifTrue: [self error: 'there are multiple source ranges for the parse node: ' , requestedParseNode printString ]
		ifFalse: [sourceRangePresentBlock value: sourceRanges anyOne].! !
!MethodNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:39:19' overrides: 16906293!
equivalentTo: aParseNode

	^ aParseNode isMethodNode
		and: [ block equivalentTo: aParseNode block]! !
!MethodNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:41:48' overrides: 50370508!
  isMethodNode

	^true.! !
!MethodNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:38:25' overrides: 50370511!
                referencesSelf

	^block referencesSelf! !
!MethodNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:38:28' overrides: 50370514!
                               referencesSuper

	^block referencesSuper! !
!VariableNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:52:27' overrides: 50370511!
                           referencesSelf

	^ self isSelfPseudoVariable ! !
!VariableNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:49:49' overrides: 50370514!
                      referencesSuper

	^self isSuperPseudoVariable ! !
!SelectorNode methodsFor: 'testing' stamp: 'HAW 5/3/2020 22:39:23'!
          isInfix

	^key isInfix ! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 5/3/2020 22:39:07'!
  isInfix

	^selector isInfix! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:45:21'!
                             isKeywordMessageSend

	^self selectorSymbol isKeyword! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:46:12' overrides: 50370511!
               referencesSelf

	^self receiver referencesSelf
		or: [self arguments anySatisfy: [:argument | argument referencesSelf]]! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:46:16' overrides: 50370514!
             referencesSuper

	^self receiver referencesSuper
		or: [self arguments anySatisfy: [:argument | argument referencesSuper]]! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 8/3/2019 10:31:57'!
                               isUnaryMessageSend

	^self selectorSymbol isUnary ! !
!ReturnNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:46:37' overrides: 50370511!
                   referencesSelf

	^expr referencesSelf! !
!ReturnNode methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:46:42' overrides: 50370514!
referencesSuper

	^expr referencesSuper! !
!SmalltalkEditor methodsFor: 'inline method' stamp: 'HAW 6/11/2022 19:58:26'!
       contextualInlineMethod

	self isEditingClassDefinition ifTrue: [ ^morph flash ].
	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualInlineMethodOf: methodNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]	]	! !
!SmalltalkEditor methodsFor: 'inline method' stamp: 'HAW 6/11/2022 19:58:29'!
                            contextualInlineMethod: aKeyboardEvent

	self contextualInlineMethod.
	^true.

	! !
!SmalltalkEditor methodsFor: 'inline method' stamp: 'HAW 6/11/2022 19:58:33'!
                              contextualInlineMethodOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor |
			nodeUnderCursor isMessageNode ifFalse: [^morph flash].

			((aMethodNode completeSourceRangesOf: nodeUnderCursor ifAbsent: [self shouldNotHappen])
				detect: [ :aSourceRange | aSourceRange includes: self startIndex]
					ifFound: [ :aSourceRange | | messageNodeReference |
						messageNodeReference := MessageNodeReference
							messageNode: nodeUnderCursor
							selector: aMethodNode selector
							class: aSelectedClass
							completeSourceRange: aSourceRange.
						self inlineMethodInUsage: messageNodeReference.	]
					ifNone: [self shouldNotHappen ])]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition ifFalse: [ ^ morph flash ].

			RefactoringApplier inlineMethodApplier
				createAndValueHandlingExceptionsOn: model textProvider
				forMethod: (MethodReference class: aSelectedClass selector: aMethodNode selector)]

! !
!SmalltalkEditor methodsFor: 'inline method' stamp: 'HAW 6/11/2022 19:58:36'!
           inlineMethodInUsage: aMessageNodeReference

	RefactoringApplier inlineMethodApplier
		createAndValueHandlingExceptionsOn: model textProvider
		forMessageSend: aMessageNodeReference.! !
!SmalltalkEditor methodsFor: 'inline temporaray variable' stamp: 'HAW 6/11/2022 19:58:40'!
            inlineTemporaryVariable

	"To prevent the refactoring to be evaluated on editors w/o methods like the workspace - Fernando"
	self hasValidCurrentCompiledMethod ifFalse: [ ^ nil ].

	InlineTemporaryVariableApplier createAndValueHandlingExceptions: [
		InlineTemporaryVariableApplier
			on: self
			for: self selectionInterval asSourceCodeInterval
			of: self codeProvider currentCompiledMethod ]! !
!SmalltalkEditor methodsFor: 'inline temporaray variable' stamp: 'HAW 6/11/2022 19:58:43'!
                       inlineTemporaryVariable: aKeyboardEvent

	self inlineTemporaryVariable.
	^true! !
!BrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 6/11/2022 20:00:51' prior: 50360215 overrides: 50360137!
                         messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel |
	sel _ model selectedMessageName.
	sel
		ifNotNil: [
			"The following require a method selection"
			aChar = $R ifTrue: [^ self renameSelector].
			aChar = $U ifTrue: [^ self addParameter ].
			aChar = $I ifTrue: [^ self removeParameter ].
			aChar = $3 ifTrue: [^ self inlineMethod ]].
	super messageListKey: aChar from: view! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 6/11/2022 19:59:39'!
                      inlineMethod

	model selectedMessageName ifNotNil: [ :selectorToInline |
		RefactoringApplier inlineMethodApplier
			createAndValueHandlingExceptionsOn: model
			forMethod: (MethodReference class: model selectedClassOrMetaClass selector: selectorToInline )]! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 6/11/2022 20:02:15' prior: 50359411!
messageRefactoringMenu

	^DynamicMenuBuilder buildTitled: 'Refactorings' targeting: self collectingMenuOptionsWith: #messageRefactoringMenuOptions.! !
!MethodReference methodsFor: 'testing' stamp: 'HAW 6/11/2022 20:04:20'!
 isMessageListTitle

	^(self actualClass isKindOf: Object) and: [methodSymbol first = $_]
! !
!RefactoringApplier class methodsFor: 'appliers - registering' stamp: 'HAW 6/11/2022 20:05:08'!
   registerInlineMethodApplier: anInlineMethodApplierClass

	self registerApplierAt: self inlineMethodApplierId with: anInlineMethodApplierClass ! !
!RefactoringApplier class methodsFor: 'appliers - getting' stamp: 'HAW 6/11/2022 20:04:51'!
                  inlineMethodApplier

	^self applierAt: self inlineMethodApplierId ifAbsent: [ InlineMethodApplier ]! !
!RefactoringApplier class methodsFor: 'appliers - id' stamp: 'HAW 6/11/2022 20:05:00'!
  inlineMethodApplierId

	^#inlineMethodApplier! !
!RefactoringApplier class methodsFor: 'appliers - resetting' stamp: 'HAW 6/11/2022 20:05:19'!
                 resetInlineMethodApplier

	self resetApplierAt: self inlineMethodApplierId ! !
!RefactoringMenues class methodsFor: 'editor menus' stamp: 'HAW 6/11/2022 20:06:01' prior: 50359365!
            messageRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		15.
				#label 			-> 		'change keyword order...'.
				#selector 		-> 		#changeKeywordOrder.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'push down'.
				#selector 		-> 		#pushDownSelector.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		60.
				#label 			-> 		'move to instance/class method'.
				#selector 		-> 		#moveToInstanceOrClassMethod.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		70.
				#label 			-> 		'inline method... (3)'.
				#selector 		-> 		#inlineMethod.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
	}`.

	! !
!RefactoringMenues class methodsFor: 'editor menus' stamp: 'HAW 6/11/2022 20:06:58' prior: 16924103!
                       smalltalkEditorMenuOptions

	^`{
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		10.
				#label 			-> 		'Rename... (R)'.
				#selector 		-> 		#contextualRename.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		20.
				#label 			-> 		'Extract Temporary... (J)'.
				#selector 		-> 		#extractToTemporary.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		30.
				#label 			-> 		'Extract Method... (K)'.
				#selector 		-> 		#extractMethod.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		40.
				#label 			-> 		'Inline Temporary... (2)'.
				#selector 		-> 		#inlineTemporaryVariable.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		50.
				#label 			-> 		'More Refactorings...'.
				#selector 		-> 		#openSmalltalkEditorRefactoringMenu.
				#icon 			-> 		#listAddIcon
		} asDictionary.
	}`! !
!RefactoringMenues class methodsFor: 'editor menus' stamp: 'HAW 6/11/2022 20:07:45' prior: 16924131!
                  smalltalkEditorRefactoringMenuOptions

	^`{
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		30.
				#label 			-> 		'Add Parameter... (A)'.
				#selector 		-> 		#contextualAddParameter.
				#icon 			-> 		#listAddIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		35.
				#label 			-> 		'Extract as Parameter... (1)'.
				#selector 		-> 		#contextualExtractAsParameter.
				#icon 			-> 		#listAddIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		40.
				#label 			-> 		'Remove Parameter... (S)'.
				#selector 		-> 		#contextualRemoveParameter.
				#icon 			-> 		#listRemoveIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		50.
				#label 			-> 		'Temporary to Instance Variable (O)'.
				#selector 		-> 		#temporaryToInstanceVariable.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		60.
				#label 			-> 		'Push Up Instance Variable'.
				#selector 		-> 		#contextualPushUpInClassDefinition.
				#icon 			-> 		#goTopIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		70.
				#label 			-> 		'Push Down Instance Variable'.
				#selector 		-> 		#contextualPushDownInClassDefinition.
				#icon 			-> 		#goBottomIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		80.
				#label 			-> 		'Inline Method... (3)'.
				#selector 		-> 		#contextualInlineMethod.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
	}`! !
!RefactoringMenues class methodsFor: 'shortcuts' stamp: 'HAW 6/11/2022 20:06:27' prior: 16924313!
                   smalltalkEditorCmdShortcutsSpec

	"
	SmalltalkEditor initializeCmdShortcuts
	"
	^#(
		#($R	#contextualRename:					'Renames what is under cursor')
		#($A	#contextualAddParameter:			'Adds parameter to message that is under cursor')
		#($S	#contextualRemoveParameter:		'Removes parameter to message that is under cursor')
		#($O	#temporaryToInstanceVariable:		'Extracts temporary variable to instance variable')
		#($J	#extractToTemporary:					'Extracts the selected code into a temporary variable')
		#($K	#extractMethod:						'Extracts the selected code into a separate method')
		#($1 #contextualExtractAsParameter: 'Extracts the selected code as parameter')
		#($2	#inlineTemporaryVariable:						'Inlines the selected temporary variable into each usage')
		#($3	#contextualInlineMethod:						'Inlines the selected message send into desired colaborations')
	)! !

MethodNode removeSelector: #hasTemporaryNamed:!
!InlineMethod commentStamp: '<historical>' prior: 0!
                           I am a refactoring that replaces message sends in the sender with the body of the target method , replacing the parameters as needed.
Implementation notes:

- I can refactor multiple message sends at the same time.
- I can delete the target method.!
!InlineMethod methodsFor: 'changes' stamp: 'FB 11/22/2021 17:01:21'!
 changedMethods

	| changedMethods |

	changedMethods := (messageSendsToInline collect: [:aMessageNodeReference | aMessageNodeReference methodReference ]) asSet.
	removeMethod ifTrue: [changedMethods add: methodToInline methodReference].
	^changedMethods.! !
!InlineMethod methodsFor: 'applying' stamp: 'FB 5/21/2022 16:49:59' overrides: 16923675!
     apply

	messageSendsToInline do: [:aMessageNodeReference | self inlineMessageSend: aMessageNodeReference].
	self declareNecessaryTemporaries.
	removeMethod ifTrue: [self removeMethodToInline].
	self compileChanges.

	^self changedMethods! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'FB 11/4/2021 22:04:44'!
                 declareNecessaryTemporaries

	temporariesToDeclareByInsertionPoint keysAndValuesDo: [:aSenderAndPosition :temporariesToDeclare |
		| sender positionToInsertTemporaries temporariesString |
		sender := aSenderAndPosition key.
		positionToInsertTemporaries := aSenderAndPosition value.
		temporariesString := temporariesToDeclare reduce: [:t1 : t2 | t1 value, ' ', t2 value].
		((sender methodNode parseNodesPathAt: positionToInsertTemporaries ifAbsent: 	[self shouldNotHappen ]) first key isTemporariesDeclaration)
			ifTrue: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: temporariesString, ' |'
				inMethod: sender.
			]
			ifFalse: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: '| ',  temporariesString, ' |', Character newLineCharacter asString
				inMethod: sender
			]
	]! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'HAW 6/11/2022 19:07:59'!
                      declareTemporaries: temporariesToDeclare in: aMethodOrBlockNode of: aSenderMethod

	| positionToInsertNewVariablesDeclarations renamedTemporaries temporariesToDeclareInPosition|

	renamedTemporaries := self renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod.

	aMethodOrBlockNode hasTemporaryVariables
		ifTrue: [
			positionToInsertNewVariablesDeclarations := (aSenderMethod methodNode
				singleCompleteSourceRangeOf: (aMethodOrBlockNode temporariesDeclaration)) last.
		]
		ifFalse: [
			| firstStatementRange |
			firstStatementRange := aSenderMethod methodNode singleCompleteSourceRangeOf: (aMethodOrBlockNode statements first).
			positionToInsertNewVariablesDeclarations := firstStatementRange first.
		].
	temporariesToDeclareInPosition := self temporariesToDeclareByInsertionPoint: (aSenderMethod -> positionToInsertNewVariablesDeclarations).
	temporariesToDeclareInPosition addAll: (renamedTemporaries collect: [:aReplacementAssociation | aReplacementAssociation value]).
	^renamedTemporaries.
	! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'HAW 6/11/2022 19:05:49'!
                             declareTemporaries: temporariesToDeclare inBlockOf: aMessageNodeReference

	| methodOrBlockNodeDeclaringNewVariables renamedTemporaries replacements |

	methodOrBlockNodeDeclaringNewVariables := self enclosingBlockOf: aMessageNodeReference.
	renamedTemporaries := self declareTemporaries: temporariesToDeclare in: methodOrBlockNodeDeclaringNewVariables of: aMessageNodeReference compiledMethod.

	replacements := self replacementsMapForMessageSend: aMessageNodeReference .
	renamedTemporaries do: [:oldVariableAndNewName |
			(self findRangesOf: oldVariableAndNewName key in: implementorCompleteSourceRanges) do: [:range |
				replacements at: range put: oldVariableAndNewName value.
			]
	]
	! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'FB 11/4/2021 23:14:31'!
         declareTemporariesIfNeededFor: aMessageNodeReference

	| implementorTemporaries |

	implementorTemporaries := methodNodeToInline temporariesDeclaration allDeclaredVariableNodes.
	implementorTemporaries isEmpty ifFalse: [self declareTemporaries: implementorTemporaries
		inBlockOf: aMessageNodeReference].
	! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'HAW 6/11/2022 19:04:49'!
           renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod

	"If a temporary to declare already exists in the scope, a new fresh name
	will be found for it. The method returns an OrderedCollection of (variableNode -> newVariableName)
	replacements. If the variable does not need a rename, it will still be added to the collection.
	This method also adds the new name to the map that tracks temporaries
	names in scope for the requested method or block node across the whole refactoring - Fernando"

	| alreadyDeclaredTemporaries newTemporaries |

	newTemporaries := OrderedCollection new: temporariesToDeclare size.
	alreadyDeclaredTemporaries := self declaredTemporariesFor: aMethodOrBlockNode ofSender: aSenderMethod.
	temporariesToDeclare do: [:temporary |
		| finalTemporaryName index |
		finalTemporaryName := temporary name.
		index := 1.
		[alreadyDeclaredTemporaries includes: finalTemporaryName] whileTrue: [
			finalTemporaryName := temporary name, index asString.
			index := index + 1.
		].
		alreadyDeclaredTemporaries add: finalTemporaryName.
		newTemporaries add: (temporary -> finalTemporaryName).
	].

	^newTemporaries.! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'HAW 6/11/2022 19:07:59'!
  temporariesToDeclareByInsertionPoint: aSenderAndPosition

	^temporariesToDeclareByInsertionPoint keys
		detect: [:senderAndPosition | senderAndPosition = aSenderAndPosition]
		ifFound: [ :key | temporariesToDeclareByInsertionPoint at: key ]
		ifNone: [| temporariesToDeclareAtInsertionPoint |
			temporariesToDeclareAtInsertionPoint := OrderedCollection new.
			temporariesToDeclareByInsertionPoint at: aSenderAndPosition put: temporariesToDeclareAtInsertionPoint.
			temporariesToDeclareAtInsertionPoint].
	! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 11/22/2021 17:32:45'!
     compileChanges

	updatedSendersCode keysAndValuesDo: [:aMethodReference :aCollectionOfChanges |
		| updatedSenderSourceCode |

		updatedSenderSourceCode := aMethodReference sourceCode copyReplacing: 	aCollectionOfChanges.
		aMethodReference methodClass compile: updatedSenderSourceCode classified: aMethodReference category
	].! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'HAW 6/11/2022 19:06:09'!
                          declaredTemporariesFor: aParseNode ofSender: aSender

	^temporariesDeclarationsByNode keys
		detect: [:senderAndNode | senderAndNode key = aSender and: [senderAndNode value equivalentTo: aParseNode]]
		ifFound: [ :key | temporariesDeclarationsByNode at: key]
		ifNone: [| temporariesAndArgsDict |

			temporariesAndArgsDict := self temporariesAndArgsInScopeOf: aParseNode ofSender: aSender.
			temporariesDeclarationsByNode at: (aSender -> aParseNode) put: temporariesAndArgsDict.
			temporariesAndArgsDict].


	! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 3/31/2022 22:59:39'!
  enclosingBlockOf: aMessageNodeReferenceWithReturnValue

	| parseNodeSourceRange methodNode |

	methodNode := aMessageNodeReferenceWithReturnValue methodNode.
	parseNodeSourceRange := aMessageNodeReferenceWithReturnValue completeSourceRange.
	^self enclosingBlockOf: parseNodeSourceRange in: methodNode.! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 3/31/2022 23:01:25'!
                    enclosingBlockOf: aParseNodeSourceRange in: aMethodNode

	aMethodNode completeSourceRangesDo: [ :parseNode :sourceRanges |
		(parseNode isBlockNode
			and: [ parseNode ~= aMethodNode ]
			and: [ sourceRanges anySatisfy: [ :sourceRange |
					sourceRange first < aParseNodeSourceRange first and: [ sourceRange last > aParseNodeSourceRange last ] ] ])
				ifTrue: [ ^ parseNode ]
		].
	^aMethodNode.! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 7/13/2021 01:17:58'!
                     findRangesOf: aNode in: completeSourceRanges
	"This is needed because the map of source ranges compares nodes by memory
	instead of using equivalentTo: -- Fernando"

	completeSourceRanges keysAndValuesDo: [:aParseNode :sourceRanges |
		(aParseNode equivalentTo: aNode) ifTrue: [^sourceRanges]
	].
	^#().
		! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 9/5/2021 20:43:20'!
                 findSourceRangeOf: aMessageNodeWithReturnValue in: aSenderMethod

	^ (aSenderMethod methodNode completeSourceRangesOf: aMessageNodeWithReturnValue ifAbsent: [self shouldNotHappen]) anyOne! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 10/31/2021 23:29:24'!
      removeMethodToInline

	methodToInline methodClass removeSelector: methodToInline selector.! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 11/22/2021 17:31:25'!
       replaceRange: aSourceCodeInterval withNewSourceCode: newSourceCode inMethod: aCompiledMethod

	| currentUpdates sourceCodeReplacement|

	sourceCodeReplacement := newSourceCode.
	((aSourceCodeInterval last < aCompiledMethod sourceCode size) and: [((aCompiledMethod sourceCode at: aSourceCodeInterval last + 1) = $.)])
		ifTrue: [sourceCodeReplacement := newSourceCode copyUpToLast: $.].
	"It's important to use < and not <= because temporaries declarations are added to the changes collection
	after the changes concerning the inlining of the implementor code, but they need to be replaced first - Fernando"
	currentUpdates := updatedSendersCode at: aCompiledMethod methodReference ifAbsent: (SortedCollection sortBlock: [ :left :right | left key first < right key first ]).
	currentUpdates add: (aSourceCodeInterval -> sourceCodeReplacement).
	updatedSendersCode at: aCompiledMethod methodReference put: currentUpdates.
	! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'HAW 6/11/2022 19:05:49'!
        replacementsMapForMessageSend: aMessageNodeReference

	^replacementsByMessageSend keys
		detect: [:messageNodeReference | messageNodeReference equivalentTo: aMessageNodeReference]
		ifFound: [ :key | replacementsByMessageSend at: key	]
		 ifNone: [| replacementsDict |

			replacementsDict := Dictionary new.
			replacementsByMessageSend at: aMessageNodeReference put: replacementsDict.
			replacementsDict ].

	! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 6/28/2021 21:08:59'!
      sourceCodeOfNode: aParseNode ofSender: aSender using: completeSourceCodeRanges

	completeSourceCodeRanges keysAndValuesDo: [:aNode :aCollectionOfRanges |
		(aNode equivalentTo: aParseNode) ifTrue: [ |range|
			range := aCollectionOfRanges anyOne.
			^aSender sourceCode copyFrom: range first to: range last
		]
	].
	self shouldNotHappen.! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'HAW 6/11/2022 19:06:09'!
                temporariesAndArgsInScopeOf: aParseNode ofSender: aSender

	| enclosingNodes parseNodeRange methodNode temporariesInScope |

	temporariesInScope := Set new.
	methodNode := aSender methodNode.
	methodNode arguments size > 0 ifTrue: [temporariesInScope addAll: (methodNode arguments collect: [:arg | arg name])].
	methodNode hasTemporaryVariables
		ifTrue: [temporariesInScope addAll: (methodNode temporariesDeclaration allDeclaredVariableNodes
					collect: [:temporaryNode | temporaryNode name])].
	(aParseNode isKindOf: BlockNode) ifTrue: [
		parseNodeRange := (methodNode singleCompleteSourceRangeOf: aParseNode).
		enclosingNodes := (methodNode parseNodesPathAt: parseNodeRange first ifAbsent: [self shouldNotHappen])
			collect: [:nodeAndRange | nodeAndRange key].
		enclosingNodes do: [:enclosingNode |
				enclosingNode isBlockNode ifTrue: [
					enclosingNode hasTemporaryVariables
						ifTrue: [temporariesInScope addAll: (enclosingNode temporariesDeclaration allDeclaredVariableNodes
							collect: [:temporaryNode | temporaryNode name])].
					enclosingNode arguments size > 0
						ifTrue: [temporariesInScope addAll: (enclosingNode arguments collect: [:temporaryNode | temporaryNode name])].
				].
		].
	].

	^temporariesInScope



	! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'HAW 6/11/2022 18:58:18'!
addParenthesesIfNeededTo: anExpression

	"TODO: duplicated code in InlineTemporaryVariable"

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |

 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) = $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) = $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [^anExpression]
		ifFalse: [^'(', anExpression, ')'].! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'HAW 6/11/2022 19:05:49'!
       buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference removingReturn: removeReturn

	| inlinedStatements senderCompleteSourceRanges argumentsAndTemporariesReplacements indentation |

	senderCompleteSourceRanges := aMessageNodeReference methodNode completeSourceRanges.
	self calculateReplacementsFrom: aMessageNodeReference
		usingRanges: senderCompleteSourceRanges.

	self declareTemporariesIfNeededFor: aMessageNodeReference.
	argumentsAndTemporariesReplacements := self replacementsMapForMessageSend: aMessageNodeReference.

	indentation := self indentationUpTo: aMessageNodeReference completeSourceRange first in: aMessageNodeReference compiledMethod sourceCode.
	inlinedStatements := indentation, ((statementsToInline collect: [:aStatementToInline |
		self sourceCodeOfImplementorStatement: aStatementToInline withReplacements: argumentsAndTemporariesReplacements removingReturn: removeReturn
			 ])
			reduce: [:aStatementWithReplacements :nextStatementWithReplacements |
				aStatementWithReplacements, Character newLineCharacter asString, indentation,
					(nextStatementWithReplacements copyReplaceAll: String newLineString with: String newLineString, indentation asTokens: false)]).

	^inlinedStatements.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'HAW 6/11/2022 19:05:49'!
                     buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference usedInNode: aParseNode

	| inlinedStatements argumentsAndTemporariesReplacements senderCompleteSourceRanges usageNodeSourceRange
	 inlinedUsageStatement statementsWithReplacements indentation |

	senderCompleteSourceRanges := aMessageNodeReference methodNode completeSourceRanges.
	usageNodeSourceRange := (self findRangesOf: aParseNode in: senderCompleteSourceRanges) first.

	self calculateReplacementsFrom: aMessageNodeReference
		usingRanges: senderCompleteSourceRanges.

	self declareTemporariesIfNeededFor: aMessageNodeReference.
	argumentsAndTemporariesReplacements := self replacementsMapForMessageSend: aMessageNodeReference.

	statementsWithReplacements := statementsToInline collect: [:aStatementToInline |
		self sourceCodeOfImplementorStatement: aStatementToInline withReplacements: argumentsAndTemporariesReplacements removingReturn: true].
	indentation := self indentationUpTo: usageNodeSourceRange first in: aMessageNodeReference compiledMethod sourceCode.

	statementsWithReplacements size > 1
		ifTrue: [inlinedStatements := indentation, ((statementsWithReplacements allButLast)
			reduce: [:aStatementWithReplacements :nextStatementWithReplacements |
				aStatementWithReplacements, String newLineString, indentation, (nextStatementWithReplacements
					copyReplaceAll: String newLineString with: String newLineString, indentation asTokens: false) ])]
		 ifFalse: [inlinedStatements := ''].
	inlinedUsageStatement := self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
		lastStatement: statementsToInline last replacement: statementsWithReplacements last.

	statementsWithReplacements size > 1
		ifTrue: [inlinedStatements := inlinedStatements, String newLineString, indentation, inlinedUsageStatement]
		ifFalse: [inlinedStatements := inlinedUsageStatement ].

	^inlinedStatements.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'HAW 6/11/2022 19:05:49'!
calculateParameterReplacementsFrom: aMessageNodeReference withRanges: senderRanges

	"Return a Dict of (sourceRange -> string) where the source range belongs to a parameter usage
	in the implementor method and the string is the variable name passed as that used parameter
	in the message node
	E.g.

	m1: aParam

	^aParam

	---
	m2
		^m1:2

	then the Dict would have one entry: (<rangeOfAParamUsage> -> 2)"
	| replacements |

	replacements := self replacementsMapForMessageSend: aMessageNodeReference.
	methodToInline methodNode arguments withIndexDo: [:anArgumentNode :argIndex | | passedArgument |
		passedArgument := aMessageNodeReference messageNode arguments at: argIndex.
		(self findRangesOf: anArgumentNode in: 	implementorCompleteSourceRanges) do: [:aRange |
			replacements at: aRange put: (self sourceCodeOfNode: passedArgument ofSender: aMessageNodeReference compiledMethod using: senderRanges).]

	].
	^replacements.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'HAW 6/11/2022 19:05:49'!
                               calculateReplacementsFrom: aMessageNodeReference usingRanges: senderRanges

	"Return a Dict of (sourceRange -> string) where the source range belongs to a parameter usage
	or self reference in the implementor method and the string is the variable name passed as
	that used parameter in the message node, or the receiver of the message to inline for self references
	E.g.

	m1: aParam

	^aParam

	---
	m2
		^m1:2

	then the Dict would have one entry: (<rangeOfAParamUsage> -> 2)"
	| replacements |

	replacements := self replacementsMapForMessageSend: aMessageNodeReference.
	methodToInline methodNode arguments withIndexDo: [:anArgumentNode :argIndex | | passedArgument |
		passedArgument := aMessageNodeReference messageNode arguments at: argIndex.
		(self findRangesOf: anArgumentNode in: 	implementorCompleteSourceRanges) do: [:aRange |
			replacements at: aRange put: (self sourceCodeOfNode: passedArgument ofSender: aMessageNodeReference compiledMethod using: senderRanges).]

	].

	methodToInline methodNode nodesDo: [:aParseNode | (aParseNode isVariableNode and: [aParseNode referencesSelf]) ifTrue: [
		(self findRangesOf: aParseNode in: 	implementorCompleteSourceRanges) do: [:rangeOfSelfReference |
			"Given previous validations, we can be sure that the receiver is a variable node"
			replacements at: rangeOfSelfReference put: aMessageNodeReference messageNode receiver name.
		]
	]].
	^replacements.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 11/16/2021 20:18:53'!
                           indentationUpTo: anIndex in: aSourceCode

	| indentation currentIndex character|

	currentIndex := anIndex - 1.
	indentation := ''.

	[currentIndex > 0 and: [
		character := (aSourceCode at: currentIndex).
		(character = Character tab) or: [character = Character space]
	]] whileTrue: [
		indentation := indentation, character asString.
		currentIndex := currentIndex - 1.
	].

	^(character = Character newLineCharacter) ifFalse: [^''] ifTrue: [^indentation reversed].! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 6/27/2021 19:35:43'!
             removeReturnSelfStatementIfNeeded: aCollectionOfStatements

	(aCollectionOfStatements last isReturnSelf)
		ifTrue: [aCollectionOfStatements removeLast].

	^aCollectionOfStatements! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 3/13/2022 17:44:17'!
              sourceCodeOfImplementorStatement: aStatementToInline withReplacements: replacementsDict removingReturn: removeReturn

	| sourceRange originalSourceCode statementReplacements |

	sourceRange := (self findRangesOf: aStatementToInline in: implementorCompleteSourceRanges) anyOne.
	originalSourceCode := methodToInline sourceCode copyFrom: sourceRange first to: sourceRange last.
	"Replacements must be adjusted because the statement string begins at index 1 instead of the
	original position on the source code"
	statementReplacements := ((replacementsDict associations select: [:anAssociation | sourceRange includesAllOf: (anAssociation key)])
		collect: [:anAssociation | ((anAssociation key first - sourceRange first + 1) to: (anAssociation key last - sourceRange first + 1)) -> anAssociation value])
		asSortedCollection: [ :left :right | left key first < right key first ].

	"Remove the return character if present"
	(removeReturn and: [aStatementToInline isReturn]) ifTrue: [statementReplacements add: (1 to: 1) -> ''].
	^(originalSourceCode copyReplacing: statementReplacements), '.'.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 11/21/2021 20:29:45'!
                               statementWithMessageSend: aMessageNodeReference usedIn: aParseNode inlinedWith: anExpression addingParentheses: addParentheses

	| sourceRangeOfUsage usageNodeSourceRange normalizedMessageSendRange expression|

	usageNodeSourceRange := (self findRangesOf: aParseNode in: aMessageNodeReference methodNode completeSourceRanges) first.
	sourceRangeOfUsage := aMessageNodeReference completeSourceRange.
	normalizedMessageSendRange := (sourceRangeOfUsage first - usageNodeSourceRange first + 1)
					to: (sourceRangeOfUsage last - usageNodeSourceRange first + 1).
	expression := addParentheses ifTrue: [(self addParenthesesIfNeededTo: (anExpression copyUpToLast: $.)), '.'] ifFalse: [anExpression].

	^(aMessageNodeReference compiledMethod sourceCode copyFrom: usageNodeSourceRange first to: usageNodeSourceRange last)
		copyReplacing: (Array with: ((normalizedMessageSendRange -> expression)))! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 3/13/2022 17:44:17'!
        statementWithMessageSend: aMessageNodeReference usedIn: aParseNode lastStatement: implementorLastStatementToInline
	replacement: lastStatementWithReplacements

	| inlinedStatementContainingMessageSend |

	implementorLastStatementToInline expr isMessageNode
		ifTrue: [ | senderSourceRange enclosingNode |
			senderSourceRange := aMessageNodeReference completeSourceRange.
			(aMessageNodeReference methodNode parseNodesPathAt: senderSourceRange first
				ifAbsent: [self shouldNotHappen])
					detect: [:aNodeAndRange | (aNodeAndRange value includesAllOf: senderSourceRange)
						and: [aNodeAndRange value first < senderSourceRange first]]
					ifFound: [:aNodeAndRange |
						enclosingNode := aNodeAndRange key.
					]
					ifNone: [self shouldNotHappen].
			inlinedStatementContainingMessageSend := self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
				inlinedWith: lastStatementWithReplacements addingParentheses: enclosingNode isMessageNode.
		]
		ifFalse: [
			inlinedStatementContainingMessageSend := self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
				inlinedWith: lastStatementWithReplacements addingParentheses: false.
		].

	^inlinedStatementContainingMessageSend.! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 3/13/2022 17:44:17'!
       findOutermostStatementContaining: aMessageNodeReference enclosedBy: enclosingBlock ifFound: ifFoundBlock ifNone: ifNoneBlock

	| usageNodesPath isDifferentMessageNode isIncludedInBlock |

	usageNodesPath := aMessageNodeReference methodNode parseNodesPathAt: aMessageNodeReference completeSourceRange first
		ifAbsent: [self shouldNotHappen].
	isDifferentMessageNode := [:aNode | aNode isMessageNode and: [(aNode equivalentTo: aMessageNodeReference messageNode) not]].
	isIncludedInBlock := [:aRange | |sourceRangeOfEnclosingBlock |
		sourceRangeOfEnclosingBlock := enclosingBlock isBlockNode
			ifTrue: [self findSourceRangeOf: enclosingBlock in: aMessageNodeReference compiledMethod.]
			ifFalse: [(1 to: aMessageNodeReference compiledMethod sourceCode size)].
		sourceRangeOfEnclosingBlock includesAllOf: aRange.
	].
	usageNodesPath reversed
		detect: [:aNodeAndRange | | node range |
			node := aNodeAndRange key.
			range := aNodeAndRange value.
			((node isAssignmentNode or: [isDifferentMessageNode value: node]) and: [isIncludedInBlock value: range])
		]
		ifFound: [:aNodeAndRange | ^ifFoundBlock value: aNodeAndRange]
		ifNone: [^ifNoneBlock value].




	! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 3/6/2022 14:52:08'!
  inlineMessageSend: aMessageNodeReference

	| statementsToInline |

	statementsToInline := self removeReturnSelfStatementIfNeeded: (methodToInline methodNode block statements).
	statementsToInline isEmpty ifTrue: [^self].
	statementsToInline last isReturn
		ifTrue: [self inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReference.]
		ifFalse: [self inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReference
			 removingReturn: true].


	! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 5/25/2022 20:44:39'!
               inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReferenceWithReturnValue

	| enclosingBlock |

	enclosingBlock := self enclosingBlockOf: aMessageNodeReferenceWithReturnValue.
	(self parseNode: enclosingBlock returns: aMessageNodeReferenceWithReturnValue messageNode)
		ifTrue: [^self inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReferenceWithReturnValue
			removingReturn: false].

	"Find the outermost statement containing the usage to inline that's inside the enclosing block"
	self findOutermostStatementContaining: aMessageNodeReferenceWithReturnValue enclosedBy: enclosingBlock
		ifFound: [ :outermostNodeAndRange |
			self inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReferenceWithReturnValue
				usedInParseNode: outermostNodeAndRange	 key
		]
		ifNone: [ | includeLastStatement statements lastStatementOfEnclosingBlock |
			lastStatementOfEnclosingBlock := (self removeReturnSelfStatementIfNeeded:
				((enclosingBlock isBlockNode ifTrue: enclosingBlock ifFalse: enclosingBlock block)
					statements)) last.
			includeLastStatement := (lastStatementOfEnclosingBlock equivalentTo: aMessageNodeReferenceWithReturnValue messageNode)
				or: [lastStatementOfEnclosingBlock equivalentTo: aMessageNodeReferenceWithReturnValue messageNode asReturnNode].
			statements := includeLastStatement ifTrue: statementsToInline ifFalse: statementsToInline allButLast.
			self inlineStatements: statements ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReferenceWithReturnValue
				removingReturn: true
		]




	! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 11/16/2021 21:29:22'!
                      inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeWithReturnValueReference usedInParseNode: aParseNode

	| inlinedStatements sourceRangeOfUsage senderMethod|

	inlinedStatements := self buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeWithReturnValueReference
		usedInNode: aParseNode.

	senderMethod := aMessageNodeWithReturnValueReference compiledMethod.
	sourceRangeOfUsage := self findSourceRangeOf: aParseNode in: senderMethod.

	self replaceRange: sourceRangeOfUsage withNewSourceCode: inlinedStatements inMethod: senderMethod.


	! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 5/18/2022 15:01:06'!
                   inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReference removingReturn: removeReturn

	| inlinedStatements sourceRangeToReplace senderMethod senderSourceCode |

	senderMethod := aMessageNodeReference compiledMethod.
	senderSourceCode := aMessageNodeReference compiledMethod sourceCode.
	statementsToInline isEmpty
		ifTrue: [
			inlinedStatements := ''.
			sourceRangeToReplace := aMessageNodeReference completeSourceRange asSourceCodeInterval
				expandUntilStartOfNextStatementOn: senderSourceCode.
		]
		ifFalse: [
			inlinedStatements := self buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference
				removingReturn: removeReturn.
			removeReturn
				ifTrue: [sourceRangeToReplace := aMessageNodeReference completeSourceRange]
				ifFalse: 	[
					(self enclosingBlockOf: aMessageNodeReference) nodesDo: [:aNode |
						(aNode isReturn and: [aNode expr equivalentTo: aMessageNodeReference messageNode ])
							ifTrue: [sourceRangeToReplace := (self findSourceRangeOf: aNode in: senderMethod)
								asSourceCodeInterval expandUntilStartOfNextStatementOn: senderSourceCode ] ]
				].
		].

	self replaceRange: sourceRangeToReplace withNewSourceCode: inlinedStatements inMethod: senderMethod.



	! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 11/3/2021 22:59:59'!
                              parseNode: aParseNode returns: aMessageNode

	aParseNode nodesDo: [:aNode | (aNode isReturn and: [aNode expr equivalentTo: aMessageNode])
		ifTrue: [^true]].
	^false.




	! !
!InlineMethod methodsFor: 'initialization' stamp: 'FB 3/6/2022 15:12:28'!
      methodToInline: aCompiledMethod usages: aCollectionOfMesageNodeReferences removingMethod: removingMethod

	methodToInline := aCompiledMethod.
	messageSendsToInline := aCollectionOfMesageNodeReferences.
	replacementsByMessageSend := Dictionary new.
	temporariesDeclarationsByNode := Dictionary new.
	temporariesToDeclareByInsertionPoint := Dictionary new.
	updatedSendersCode := Dictionary ofSize: ((messageSendsToInline groupBy: [:aMessageNodeReference | aMessageNodeReference methodReference]) keys) size.
	methodNodeToInline := methodToInline methodNode.
	implementorCompleteSourceRanges := methodNodeToInline completeSourceRanges.
	removeMethod := removingMethod.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineMethod class
	instanceVariableNames: ''!

!classDefinition: 'InlineMethod class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineMethod class
	instanceVariableNames: ''!
!InlineMethod class methodsFor: 'initialization' stamp: 'FB 4/14/2022 15:14:25'!
    from: aCompiledMethodToInline intoSendersAndUsages: aCollectionOfMessageSends removeMethod: removingMethod

	self assertCanInlineMethod: aCompiledMethodToInline intoMessageSends: aCollectionOfMessageSends.

	^self new
		methodToInline: aCompiledMethodToInline
		usages: aCollectionOfMessageSends
		removingMethod: removingMethod.! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 5/21/2022 18:00:47'!
   assertCanInlineMethod: aCompiledMethodToInline intoMessageSends: aCollectionOfMessageSends

	| senders |

	self assertNoCascadingMessages: aCollectionOfMessageSends.
	senders := aCollectionOfMessageSends collect: [:aMessageNodeReference | aMessageNodeReference actualClass].
	self assertSenders: senders haveAccessToPrivateVariablesOf: aCompiledMethodToInline.
	self assertMethodToInlineHasOnlyOneReturn: aCompiledMethodToInline.

	"When the method to inline references self, only allow inlining on statements like:
		variable := ClassOfMethodToInline new.
		variable methodToInline.
	but not on:
		ClassOfMethodToInline new methodToInline
	to be able to replace the references to self with the variable name
	"

	(aCompiledMethodToInline referencesSelf) ifTrue: [
		(aCollectionOfMessageSends allSatisfy: [:aSender | (self sender: aSender belongsToClassOf: aCompiledMethodToInline)
			or: [aSender messageNode receiver isVariableNode ]]) ifFalse: [
				self signalMethodToInlineReferencesSelf
			]
	].

	"Do not allow inlining implementors that reference super unless all the senders belong to the same class,
	since otherwise it's not possible to replace the super keyword with something that maintains the semantics"
	(aCompiledMethodToInline referencesSuper) ifTrue: [
		self assertSenders: aCollectionOfMessageSends belongToClassOf: aCompiledMethodToInline
			ifFalse: [self signalMethodToInlineReferencesSuper] .
	].
	! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 10/16/2021 21:26:35'!
                           assertMethodToInlineHasOnlyOneReturn: aCompiledMethod

	| returnsCount |

	returnsCount := 0.
	aCompiledMethod methodNode nodesDo: [:aNode | aNode isReturn ifTrue: [
			returnsCount := returnsCount  + 1.
			returnsCount > 1 ifTrue: [self signalMethodHasMultipleReturnsErrorMessage ]
		]
	]! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 4/14/2022 15:08:07'!
           assertNoCascadingMessages: aCollectionOfMessageSends

	(aCollectionOfMessageSends anySatisfy: [:aMessageNodeReference |
		aMessageNodeReference messageNode isCascade ]) ifTrue: [self signalMessageSendCanNotBeCascade]! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 5/21/2022 16:36:12'!
                    assertSenders: aCollectionOfSenders belongToClassOf: aCompiledMethod ifFalse: ifFalseBlock

	(aCollectionOfSenders allSatisfy: [:aSender | self sender: aSender belongsToClassOf: aCompiledMethod])
		ifFalse: [^ifFalseBlock value].! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 5/21/2022 15:38:18'!
       assertSenders: aSendersCollection haveAccessToPrivateVariablesOf: aCompiledMethod

	| methodReferencesInstanceVariables |

	methodReferencesInstanceVariables := false.
	aCompiledMethod methodNode
		nodesDo: [:aNode | aNode isInstanceVariableNode ifTrue: [methodReferencesInstanceVariables := true]].

	methodReferencesInstanceVariables ifTrue: [
		(aSendersCollection allSatisfy: [:aSenderClass | aSenderClass = aCompiledMethod methodClass])
			ifFalse: [self signalMethodAccessPrivateVariablesNotVisibleToSenderErrorMessage]
	].
	 ! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 4/9/2022 00:04:03'!
                         assertSendersHaveAccessToPrivateVariables: aSendersCollection of: aCompiledMethod

	| methodReferencesInstanceVariables |

	methodReferencesInstanceVariables := false.
	aCompiledMethod methodNode
		nodesDo: [:aNode | aNode isInstanceVariableNode ifTrue: [methodReferencesInstanceVariables := true]].

	methodReferencesInstanceVariables ifTrue: [
		(aSendersCollection allSatisfy: [:aSenderClass | aSenderClass = aCompiledMethod methodClass])
			ifFalse: [self signalMethodAccessPrivateVariablesNotVisibleToSenderErrorMessage]
	].
	 ! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 5/21/2022 17:16:46'!
                        methodToInlineReferencesSelfErrorMessage

	^'The method to inline references self, but at least one sender does not have a variable as the receiver and it
	 does not belong to the same class'! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 5/21/2022 16:29:27'!
             sender: aSender belongsToClassOf: aCompiledMethod

	^(aSender actualClass = aCompiledMethod methodClass)! !
!InlineMethod class methodsFor: 'preconditions' stamp: 'FB 5/21/2022 17:15:10'!
    signalMethodToInlineReferencesSelf

	self refactoringError: self methodToInlineReferencesSelfErrorMessage! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 4/14/2022 15:11:22'!
          messageSendCanNotBeCascadeErrorMessage

	^'Refactoring a cascade message send is not supported'.! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 4/8/2022 23:35:57'!
                    methodAccessPrivateVariablesNotVisibleToSenderErrorMessage

	^'Method to inline is accessing private variables that are not visible to at least one sender'! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 10/16/2021 21:16:21'!
                       methodHasMultipleReturnsErrorMessage

	^'Method to inline has more than one possible return value'! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 5/21/2022 16:39:45'!
                 methodToInlineReferencesSuperErrorMessage

	^'The method to inline references super but there is at least one sender that does not belong to the same class'! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 4/14/2022 15:09:36'!
                       signalMessageSendCanNotBeCascade

	^self refactoringError: self messageSendCanNotBeCascadeErrorMessage.! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 4/8/2022 23:36:18'!
             signalMethodAccessPrivateVariablesNotVisibleToSenderErrorMessage

	^self refactoringError: self methodAccessPrivateVariablesNotVisibleToSenderErrorMessage.! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 10/16/2021 21:16:58'!
                       signalMethodHasMultipleReturnsErrorMessage

	^self refactoringError: self methodHasMultipleReturnsErrorMessage.! !
!InlineMethod class methodsFor: 'errors' stamp: 'FB 5/21/2022 16:38:43'!
    signalMethodToInlineReferencesSuper

	self refactoringError: self methodToInlineReferencesSuperErrorMessage! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 10/31/2021 22:53:44'!
                     addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages forClassAndMetaOf: aPotentialClassToRefactor

	self addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor theNonMetaClass.
	self addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor theMetaClass.

! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 10/31/2021 22:53:48'!
            addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	| categories |

	categories := Set new.

	self
		addImplementorsOf: aSelectorToInline
		to: implementors
		andUsagesTo: usages
		inHierarchyOf: aClass
		doingPerClass: [:aClassInHierarchy | categories add: aClassInHierarchy category ].

	categories do: [:aCategory |
		self
			addImplementorsOf: aSelectorToInline
			to: implementors
			andUsagesTo: usages
			inCategory: aCategory
			organizedBy: anOrganization ].
! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 12/21/2021 20:24:21'!
                     addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inCategory: aCategory organizedBy: anOrganization

	| classesInCategory |

	classesInCategory := anOrganization classesAt: aCategory.
	classesInCategory do: [ :aPotentialClassToRefactor |
		self
			addImplementorsOf: aSelectorToInline
			to: implementors
			andUsagesTo: usages
			forClassAndMetaOf: aPotentialClassToRefactor ].! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 10/31/2021 22:53:54'!
              addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inHierarchyOf: aClass

	self
		addImplementorsOf: aSelectorToInline
		to: implementors
		andUsagesTo: usages
		inHierarchyOf: aClass
		doingPerClass: [ :aClassInHierarchy | ]

	! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 10/31/2021 22:53:57'!
     addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inHierarchyOf: aClass doingPerClass: aBlock

	| highestClassImplementingOldSelector |

	highestClassImplementingOldSelector := aClass highestClassImplementing: aSelectorToInline ifNone: [ aClass ].
	highestClassImplementingOldSelector theNonMetaClass withAllSubclassesDo: [ :aPotentialClassToRefactor |
		aPotentialClassToRefactor isMeta ifFalse: [
			self
				addImplementorsOf: aSelectorToInline
				to: implementors
				andUsagesTo: usages
				forClassAndMetaOf: aPotentialClassToRefactor.
			aBlock value: aPotentialClassToRefactor ]]
	! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 10/31/2021 22:52:25'!
                          addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inSystem: aSystem

	aSystem allBehaviorsDo: [ :aPotentialClassToRefactor |
		self addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor ].
! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 11/13/2021 21:50:33'!
                         addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor

	| potentialImplementor |

	"Phil B. requested to avoid refactoring OMeta2 classes, so right now
	it avoids implementors and senders whose compilerClass is not register
	as allowed compiler - Hernan"
	(self canRefactor: aPotentialClassToRefactor) ifFalse: [ ^self ].

	potentialImplementor := aPotentialClassToRefactor compiledMethodAt: aSelectorToInline ifAbsent: [ nil ].
	potentialImplementor ifNotNil: [ implementors add: potentialImplementor ].

	(aPotentialClassToRefactor whichSelectorsReferTo: aSelectorToInline) do: [ :aSelector |
		usages addAll: (self findReferencesToSelector: aSelectorToInline in: (MethodReference class: aPotentialClassToRefactor selector: aSelector))]! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 5/5/2022 22:14:13'!
              convertToSender: aSenderSelector of: aPotentialClassToRefactor referencing: aSelector

	^(self findReferencesToSelector: aSelector
		in: (MethodReference class: aPotentialClassToRefactor selector: aSenderSelector))! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'FB 10/31/2021 22:48:46'!
          findReferencesToSelector: aSelectorToInline in: aMethodReference

	| references |

	references := Set new.
	aMethodReference compiledMethod methodNode completeSourceRangesDo: [:aNode :ranges |
		(aNode isMessageNode and: [aNode selector key = aSelectorToInline]) ifTrue: [
			ranges do: [:range  | references add: (MessageNodeReference messageNode: aNode
				selector: aMethodReference methodSymbol class: aMethodReference methodClass completeSourceRange: range)]
		]
	].

	^references.

	! !
!InlineMethodApplier commentStamp: '<historical>' prior: 0!
                       I can apply the InlineMethod refactoring to a message. I am in charge of handling the configuration windows and instantiating an instance of InlineMethod.
Implementation notes:

- A single implementor will have to be chosen.
- More than one message send can be refactored.
- An option to delete the implementor is provided.!
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/11/2022 19:14:25'!
                      askForImplementorsAndMessageSends

	self
		initializeImplementorsAndMessageSends;
		calculateImplementorsAndMessageSends;
		openImplementorSelectionWindow.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/11/2022 19:14:09'!
                            askForImplementorsOnly

	self
		initializeImplementors;
		calculateImplementorsAndMessageSends;
		openImplementorSelectionWindow.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/11/2022 19:14:36'!
                      askForMessagesToInlineOnly

	self
		initializeMessageSends;
		calculateImplementorsAndMessageSends;
		openMessageSendsSelectionWindow.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/22/2021 19:06:58'!
                 askIfImplementorShouldBeRemoved

	self askIfImplementorShouldBeRemoved: 'Do you want to remove the implementor method from the system?'.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/22/2021 19:06:41'!
               askIfImplementorShouldBeRemoved: aMessage

	shouldRemoveImplementor := PopUpMenu confirm: aMessage.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/22/2021 19:12:11'!
                    askIfImplementorShouldBeRemovedWhenNoSenders

	self askIfImplementorShouldBeRemoved: 'This message has no senders so inlining is a no-op. Do you want to remove the implementor method from the system?'.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:26:45'!
              askIfOnlyTriggeringMessageSendShouldBeInlined

	| scopeMenu choice |

	scopeMenu := PopUpMenu labelArray: #('Inline only this message send' 'Select message sends to inline').
	choice := scopeMenu startUpWithCaption: 'What message sends should be inlined?'.
	choice = 0 ifTrue: [ self endRequest ].
	shouldInlineTriggeringMessageSendOnly := choice = 1! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 10/18/2021 19:48:26'!
                         askScope

	| scopeMenu |

	scopeMenu := PopUpMenu labelArray: self scopeOptionLabels.
	scopeChoice := scopeMenu startUpWithCaption: 'Select Refactoring Scope'.
	scopeChoice = 0 ifTrue: [ self endRequest ].
	! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:23:13'!
        calculateImplementorsAndMessageSends

	scopeChoice = 1 ifTrue: [ ^self implementorsAndMessageSendsForClass ].
	scopeChoice = 2 ifTrue: [ ^self implementorsAndMessageSendsForHierarchy ].
	scopeChoice = 3 ifTrue: [ ^self implementorsAndMessageSendsInCategory ].
	scopeChoice = 4 ifTrue: [ ^self implementorsAndMessageSendsInCategoryAndHierarchy ].
	scopeChoice = 5 ifTrue: [ ^self implementorsAndMessageSendsInSystem ].

	self error: 'Unknown scope option'

		! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 10/24/2021 15:03:32'!
             createImplementors

	^IdentitySet new
! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:24:50'!
                 createMessageSends

	^OrderedCollection new.
! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:27:41'!
          implementorsAndMessageSendsForClass

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		forClassAndMetaOf: selectedClass! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:27:41'!
                   implementorsAndMessageSendsForHierarchy

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inHierarchyOf: selectedClass! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:27:41'!
                   implementorsAndMessageSendsInCategory

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inCategory: selectedClass category
		organizedBy: SystemOrganization! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:27:41'!
             implementorsAndMessageSendsInCategoryAndHierarchy

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inCategoriesAndHierarchyOf: selectedClass
		organizedBy: SystemOrganization ! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:27:41'!
                         implementorsAndMessageSendsInSystem

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inSystem: Smalltalk ! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 3/19/2022 18:39:34'!
implementorsOrDiscardCollection

	"This is implemented like this so we don't have to duplicate every implementorsAndMessageSendsInXXX method to
	only calculate implementors or only usages. We always calculate both but if they are not needed they end
	up in this collection that will not be used in the refactoring process - Fernando"

	^self shouldAskForImplementors ifTrue: [implementors] ifFalse: [^Set new]! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/13/2021 18:19:25'!
                              initializeImplementors

	implementors := self createImplementors.
	! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:24:27'!
                    initializeImplementorsAndMessageSends

	self initializeImplementors.
	self initializeMessageSends.
	! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:24:50'!
                   initializeMessageSends

	messageSends := self createMessageSends
	! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/25/2021 00:25:03'!
                     messageSendsOrDiscardCollection

	"This is implemented like this so we don't have to duplicate every implementorsAndUsagesInXXX method to
	only calculate implementors or only usages. We always calculate both but if they are not needed they end
	up in this collection that will not be used in the refactoring process - Fernando"

	^self shouldAskForMessageSendsToInline ifTrue: [messageSends] ifFalse: [^Set new].! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 3/3/2022 21:48:32'!
                             openImplementorSelectionWindow

	| windowClass |

	implementors isEmpty ifTrue: [self handleRefactoringError: (RefactoringError signal: self class implementorsNotFoundErrorMessage)].
	windowClass := self shouldAskForMessageSendsToInline
		ifTrue: [InlineMethodImplementorsWithShowUsagesStepWindow]
		ifFalse: [InlineMethodImplementorsStepWindow].
	^windowClass openFrom: self.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:27:26'!
                               openMessageSendsSelectionWindow

	| windowClass |

	windowClass := self shouldAskForImplementors
		ifTrue: [InlineMethodUsagesWithShowImplementorsStepWindow]
		ifFalse: [InlineMethodUsagesStepWindow].
	^windowClass openFrom: self.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 11/24/2021 00:26:21' overrides: 16923803!
                             requestRefactoringParameters

	self refactoringRequestedFromUsage ifTrue: [self askIfOnlyTriggeringMessageSendShouldBeInlined].
	self askIfImplementorShouldBeRemoved.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'FB 10/18/2021 19:48:26'!
                 scopeOptionLabels

	^{'In Class'. 'In Hierarchy'. 'In Category'. 'In Hierarchy and its Categories'. 'In System'}.! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 10/31/2021 16:49:55'!
                             implementors

	^implementors ! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 11/13/2021 21:15:51'!
                 implementors: aCollectionOfImplementors

	implementors := aCollectionOfImplementors ! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 11/24/2021 20:05:21'!
                          messageSendAt: anIndex ifAbsent: ifAbsentBlock

	^messageSends at: anIndex ifAbsent: ifAbsentBlock! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 11/25/2021 00:24:47'!
            messageSends: aCollectionOfMessageSends

	messageSends := aCollectionOfMessageSends reject: [:aMessageNodeReference | aMessageNodeReference isMessageListTitle ]! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 11/25/2021 00:25:16'!
              messageSendsToInline

	^messageSends ! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 11/24/2021 00:23:25'!
         methodsOfUsagesToInline

	^messageSends collect: [:aMessageNodeReference | aMessageNodeReference methodReference]! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 10/31/2021 16:50:12'!
                             selectorToInline

	^selectorToInline ! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 11/22/2021 17:42:30'!
         shouldAskForImplementors

	^triggeringMessageSend isNil not.! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 11/25/2021 00:25:03'!
                  shouldAskForMessageSendsToInline

	^shouldInlineTriggeringMessageSendOnly not.! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'FB 10/18/2021 19:48:26'!
wizardStepWindow: aWizarStepWindow

	wizardStepWindow := aWizarStepWindow ! !
!InlineMethodApplier methodsFor: 'refactoring - changes' stamp: 'FB 10/18/2021 19:48:26'!
                        closeBrowser

	wizardStepWindow delete.
	! !
!InlineMethodApplier methodsFor: 'refactoring - changes' stamp: 'FB 10/18/2021 19:48:26'!
                         doNotShowChanges

	shouldShowChanges := false! !
!InlineMethodApplier methodsFor: 'refactoring - changes' stamp: 'FB 10/18/2021 19:48:26'!
                     messageSetWindowClass

	^MessageSetWindow
	! !
!InlineMethodApplier methodsFor: 'refactoring - changes' stamp: 'FB 10/18/2021 19:48:26' overrides: 16923923!
   showChanges

	self showChangesInMessageSetWindow! !
!InlineMethodApplier methodsFor: 'refactoring - changes' stamp: 'FB 10/18/2021 19:48:26'!
                  showChangesInMessageSetWindow

	self messageSetWindowClass openMessageList: changes asSortedCollection label: 'Changed methods' ! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'FB 6/3/2022 17:27:44'!
   createAndApplyRefactoring

	self
		removeMessageSendsBelongingToImplementor;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring.

	shouldShowChanges ifTrue: [ self showChanges ]

			! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'FB 11/24/2021 00:23:25'!
                         createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor

	implementors := Array with: anImplementor.
	messageSends := #().
	shouldShowChanges := false.

	self createAndApplyRefactoring ! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'FB 11/24/2021 00:23:25' overrides: 16923785!
     createRefactoring

	self assert: implementors size = 1.
	^self refactoringClass
		from: (implementors anyOne)
		intoSendersAndUsages: messageSends
		removeMethod: shouldRemoveImplementor

			! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'FB 10/18/2021 19:50:16'!
  refactoringClass

	^InlineMethod ! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'FB 6/3/2022 17:27:29'!
  removeMessageSendsBelongingToImplementor

	messageSends := messageSends reject: [:messageNodeReference |
		messageNodeReference compiledMethod equivalentTo: implementors anyOne
	]
! !
!InlineMethodApplier methodsFor: 'initialization' stamp: 'FB 11/24/2021 00:26:29'!
                     initializeOn: aBrowser for: aSelector in: aSelectedClass

	"To be used when initiating refactoring from message selector pane"

	selectorToInline := aSelector.
	selectedClass := aSelectedClass.
	browser := aBrowser.
	shouldInlineTriggeringMessageSendOnly := false.
	shouldShowChanges := true.! !
!InlineMethodApplier methodsFor: 'initialization' stamp: 'FB 11/22/2021 17:42:30'!
     initializeOn: aBrowser forMessageSend: aMessageNodeReference

	"To be used when initiating refactoring from a message send"

	selectorToInline := aMessageNodeReference selectorOfMessageNode.
	triggeringMessageSend := aMessageNodeReference.
	selectedClass := aMessageNodeReference actualClass.
	browser := aBrowser.
	shouldShowChanges := true.! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'FB 11/22/2021 19:10:54'!
                       ifHasNoUsagesAndOneImplementor: trueBlock ifNot: falseBlock

	| allImplementors |

	allImplementors := Smalltalk allImplementorsOf: selectorToInline.

	"I could try to see if there is one sender and that that sender is in the same method beeing renamed. That could
	mean that it is a recursive call but I should also see if the receiver is self to be sure because if it is other 'type' of
	object the rename could not be safe. To complex for a small posibility - Hernan"
	(allImplementors size = 1 and: [ (Smalltalk allCallsOn: selectorToInline) isEmpty ])
		ifTrue: [ trueBlock value: allImplementors anyOne compiledMethod ]
		ifFalse: falseBlock! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'FB 11/22/2021 17:42:30'!
      refactoringRequestedFromUsage

	^triggeringMessageSend isNil not.! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'FB 3/5/2022 14:06:26' overrides: 16923927!
                          value

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'FB 10/18/2021 19:48:26'!
        wizardEnded

	requestExitBlock := [ ^self ].

	self
		closeBrowser;
		createAndApplyRefactoring.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineMethodApplier class
	instanceVariableNames: ''!

!classDefinition: 'InlineMethodApplier class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineMethodApplier class
	instanceVariableNames: ''!
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'FB 12/21/2021 19:57:14' overrides: 16923943!
          createAndValueHandlingExceptions: creationBlock


	[super createAndValueHandlingExceptions: creationBlock]
		on: Refactoring refactoringErrorClass
		do: [ :refactoringError | ^self inform: refactoringError messageText ].
! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'FB 11/22/2021 17:42:17'!
   createAndValueHandlingExceptionsOn: aModel forMessageSend: aMessageNodeReference

	self createAndValueHandlingExceptions: [ self initializeOn: aModel forMessageSend: aMessageNodeReference ].
! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'FB 11/22/2021 17:44:22'!
 createAndValueHandlingExceptionsOn: aModel forMethod: aMethodReference

	self createAndValueHandlingExceptions: [ self initializeOn: aModel forMethod: aMethodReference ].
! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'FB 3/3/2022 21:42:58'!
                       implementorsNotFoundErrorMessage

	^'There are no implementors for this message in the selected scope'! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'FB 11/22/2021 17:42:17'!
                          initializeOn: aModel forMessageSend: aMessageNodeReference

	^self new initializeOn: aModel forMessageSend: aMessageNodeReference
	! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'FB 11/22/2021 18:27:52'!
                             initializeOn: aModel forMethod: aMethodReference

	"To be called when calling from method selector or when inlining self method from the code editor"

	^self new initializeOn: aModel for: aMethodReference selector in: aMethodReference actualClass.! !
!InlineMethodWizardStepWindow methodsFor: 'actions' stamp: 'FB 10/18/2021 20:25:55'!
                do: aBlock withEnteredClassLabeled: aLabel
	ClassNameRequestMorph
		request: aLabel
		initialAnswer: ''
		do: [:className| self withClassNamed: className do: aBlock]! !
!InlineMethodWizardStepWindow methodsFor: 'actions' stamp: 'FB 10/18/2021 20:25:55'!
  inform: aClass doesNotImplement: aSelector

 	self inform: aClass name, ' does not implement #', aSelector ! !
!InlineMethodWizardStepWindow methodsFor: 'actions' stamp: 'FB 10/18/2021 20:25:55'!
                            justRefactor

	applier doNotShowChanges.
	self refactor.! !
!InlineMethodWizardStepWindow methodsFor: 'actions' stamp: 'FB 10/18/2021 20:25:55'!
               refactor

	applier wizardStepWindow: self.
	applier wizardEnded.
	! !
!InlineMethodWizardStepWindow methodsFor: 'actions' stamp: 'FB 10/18/2021 20:25:55'!
     withClassNamed: aName do: aBlock

	| trimmedNamed |

	trimmedNamed := aName withBlanksTrimmed.

	(Smalltalk classNamed: trimmedNamed asSymbol)
		ifNotNil: aBlock
		ifNil: [ self inform: 'Class ', trimmedNamed , ' does not exist' ].
! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'FB 10/18/2021 20:25:55'!
                          addButton: button to: row color: buttonColor

	button color: buttonColor.
	row addMorph: button proportionalWidth: 10! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'FB 10/18/2021 20:25:55'!
             addButtonsTo: row color: buttonColor

	self subclassResponsibility ! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'FB 10/18/2021 20:25:55' overrides: 50355704!
           buildLowerPanes

	| codeAndButtons  |

	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.

	^codeAndButtons ! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'FB 10/18/2021 20:25:55'!
                      buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.

	^row

	! !
!InlineMethodWizardStepWindow methodsFor: 'compile methods' stamp: 'FB 10/18/2021 20:25:55'!
                      compiledMethodsFrom: methodReferences

	"If the method is not implemented, I leave the not implemented reference because actual senders of it
	should be renamed. This is important for LiveTyping Actual Scope Refactorings - Hernan"
	^ methodReferences collect: [:aMethodReference |
		aMethodReference compiledMethodIfAbsent: [ aMethodReference ]]! !
!InlineMethodWizardStepWindow methodsFor: 'button creation' stamp: 'FB 10/18/2021 20:25:55'!
      createCancelButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #delete
		label: 'Cancel'.
! !
!InlineMethodWizardStepWindow methodsFor: 'button creation' stamp: 'FB 10/18/2021 20:25:55'!
              createJustRefactorButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #justRefactor
		label: 'Just Refactor!!'! !
!InlineMethodWizardStepWindow methodsFor: 'button creation' stamp: 'FB 10/18/2021 20:25:55'!
                           createRefactorButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #refactor
		label: 'Refactor'! !
!InlineMethodWizardStepWindow methodsFor: 'button creation' stamp: 'FB 11/22/2021 16:23:59'!
          createRemoveButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #remove
		label: 'Remove'.
! !
!InlineMethodWizardStepWindow methodsFor: 'initialization' stamp: 'FB 10/31/2021 17:27:23'!
               initializeFrom: anInlineMethodApplier

	applier := anInlineMethodApplier ! !
!InlineMethodWizardStepWindow methodsFor: 'testing' stamp: 'FB 10/18/2021 20:25:55'!
                              isMessageSelected

	^model isNil ifTrue: [ false ] ifFalse: [ model selection notNil ]! !
!InlineMethodWizardStepWindow methodsFor: 'accessing' stamp: 'FB 10/31/2021 17:26:48'!
               selectorToInline

	^applier selectorToInline ! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineMethodWizardStepWindow class
	instanceVariableNames: ''!

!classDefinition: 'InlineMethodWizardStepWindow class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineMethodWizardStepWindow class
	instanceVariableNames: ''!
!InlineMethodWizardStepWindow class methodsFor: 'instance creation' stamp: 'FB 11/22/2021 15:10:45'!
             methodReferencesOf: methods

	^methods asOrderedCollection collect: [:aCompiledMethod | aCompiledMethod methodReference ].
! !
!InlineMethodWizardStepWindow class methodsFor: 'instance creation' stamp: 'FB 11/13/2021 21:16:10'!
                            openFrom: anInlineMethodApplier methods: methods label: aLabel selecting: somethingToSelect

	| window |

	window := self openMessageList: methods label: aLabel autoSelect: somethingToSelect.
	window initializeFrom: anInlineMethodApplier.

	^window

! !
!InlineMethodImplementorsStepWindow methodsFor: 'actions' stamp: 'FB 11/22/2021 15:25:47' overrides: 50372880!
                   justRefactor

	self setImplementorInApplier.
	super justRefactor.! !
!InlineMethodImplementorsStepWindow methodsFor: 'actions' stamp: 'FB 11/22/2021 15:54:27' overrides: 50372885!
            refactor

	self setImplementorInApplier.
	super refactor.! !
!InlineMethodImplementorsStepWindow methodsFor: 'actions' stamp: 'FB 11/14/2021 17:07:45'!
        selectImplementor

	selectedImplementor := model selection.
	self refactor.! !
!InlineMethodImplementorsStepWindow methodsFor: 'actions' stamp: 'FB 11/21/2021 21:00:23'!
                      setImplementorInApplier

	selectedImplementor := selectedImplementor ifNil: [model selection].
	applier implementors: (self compiledMethodsFrom: (Array with: selectedImplementor)).
	! !
!InlineMethodImplementorsStepWindow methodsFor: 'GUI building' stamp: 'FB 11/22/2021 15:52:57' overrides: 50372908!
                  addButtonsTo: row color: buttonColor

	self addButton: self createRefactorButton to: row color: buttonColor.
	self addButton: self createJustRefactorButton to: row color: buttonColor.
	self addButton: self createCancelButton to: row color: buttonColor.
! !
!InlineMethodImplementorsStepWindow methodsFor: 'button creation' stamp: 'FB 11/13/2021 19:03:50'!
                            createSelectImplementorButton

	^PluggableButtonMorph
		model: self
		stateGetter: #isMessageSelected
		action: #selectImplementor
		label: 'Select'.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineMethodImplementorsStepWindow class
	instanceVariableNames: ''!

!classDefinition: 'InlineMethodImplementorsStepWindow class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineMethodImplementorsStepWindow class
	instanceVariableNames: ''!
!InlineMethodImplementorsStepWindow class methodsFor: 'instance creation' stamp: 'FB 10/31/2021 22:16:04'!
             openFrom: anInlineMethodApplier

	^self
		openFrom: anInlineMethodApplier
		methods: (self methodReferencesOf: anInlineMethodApplier implementors)
		label: 'Implementors of #', anInlineMethodApplier selectorToInline, ' to Refactor'
		selecting: nil
! !
!InlineMethodImplementorsWithShowUsagesStepWindow methodsFor: 'button creation' stamp: 'FB 11/27/2021 17:12:10' overrides: 50373055!
                              addButtonsTo: row color: buttonColor

	self addButton: self createSelectAndSeeUsagesButton to: row color: buttonColor.
	self addButton: self createRefactorButton to: row color: buttonColor.
	self addButton: self createJustRefactorButton to: row color: buttonColor.
	self addButton: self createCancelButton to: row color: buttonColor.! !
!InlineMethodImplementorsWithShowUsagesStepWindow methodsFor: 'button creation' stamp: 'FB 11/22/2021 16:16:53'!
                              createSelectAndSeeUsagesButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #selectAndSeeUsages
		label: 'Select and see usages'.

! !
!InlineMethodImplementorsWithShowUsagesStepWindow methodsFor: 'actions' stamp: 'FB 11/24/2021 00:27:26'!
                          selectAndSeeUsages

	self setImplementorInApplier.
	self delete.

	"Necesary indirection to support actual senders in LiveTyping - Hernan"
	applier openMessageSendsSelectionWindow.! !
!InlineMethodImplementorsWithShowUsagesStepWindow methodsFor: 'actions' stamp: 'FB 11/22/2021 14:33:31' overrides: 50373039!
           selectImplementor

	selectedImplementor := model selection.
	self selectAndSeeUsages.! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'FB 10/31/2021 21:38:33'!
                  add

		self
			do: [ :classOfSenderToAdd | self askAndAddAllUsagesInSenderOf: classOfSenderToAdd ]
			withEnteredClassLabeled: 'Sender of #', self selectorToInline
			! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'FB 10/31/2021 23:14:50'!
addToList: aMessageNodeReference

	model addMessageNodeReference: aMessageNodeReference ifIncluded: [ self inform: 'Usage already in list' ]! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'FB 10/31/2021 23:15:46'!
                           askAndAddAllUsagesInSenderOf: classOfSenderToAdd

	"Adds all usages of the selected sender to the usages to refactor"
	| senderSelector senderToAdd |

	senderSelector := self request: 'Selector of sender of #', self selectorToInline initialAnswer: '' orCancel: [^self ].
	senderToAdd := classOfSenderToAdd
		compiledMethodAt: senderSelector asSymbol
		ifAbsent: [ ^self inform: classOfSenderToAdd doesNotImplement: senderSelector asSymbol].

	(senderToAdd sendsOrRefersTo: self selectorToInline) ifFalse: [ ^self inform: senderToAdd classAndSelector, ' does not refer to #', self selectorToInline].

	(applier refactoringClass findReferencesToSelector: self selectorToInline in: senderToAdd asMethodReference)
		do: [:aMessageNodeReference | self addToList: aMessageNodeReference]! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'FB 11/25/2021 00:24:47'!
                           changeUsages

	applier messageSends: model messageList
	! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'FB 10/31/2021 17:26:16' overrides: 50372885!
                           refactor

	self changeUsages.
	super refactor ! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'FB 11/22/2021 16:24:46'!
                         remove

	model removeMessageFromBrowserKeepingLabel.! !
!InlineMethodUsagesStepWindow methodsFor: 'GUI building' stamp: 'FB 11/22/2021 16:24:33' overrides: 50372908!
                          addButtonsTo: row color: buttonColor

	self addButton: self createRemoveButton to: row color: buttonColor.
	self addButton: self createRefactorButton to: row color: buttonColor.
	self addButton: self createJustRefactorButton to: row color: buttonColor.
	self addButton: self createCancelButton to: row color: buttonColor.
! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineMethodUsagesStepWindow class
	instanceVariableNames: ''!

!classDefinition: 'InlineMethodUsagesStepWindow class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineMethodUsagesStepWindow class
	instanceVariableNames: ''!
!InlineMethodUsagesStepWindow class methodsFor: 'instance creation' stamp: 'FB 11/24/2021 20:04:24'!
                        openFrom: anInlineMethodApplier

	| window messageSendsSet |

	messageSendsSet := InlineMethodMessageSendsSet applier: anInlineMethodApplier.

	messageSendsSet autoSelectString: 'asd'.

	window := self open: messageSendsSet label: 'Message sends of #', anInlineMethodApplier selectorToInline, ' to Refactor'.
	window initializeFrom: anInlineMethodApplier.

	^window.! !
!InlineMethodUsagesWithShowImplementorsStepWindow methodsFor: 'button creation' stamp: 'FB 11/13/2021 21:40:51' overrides: 50373202!
         addButtonsTo: row color: buttonColor

	super addButtonsTo: row color: buttonColor.
	self addButton: self createSeeImplementorsButton to: row color: buttonColor.! !
!InlineMethodUsagesWithShowImplementorsStepWindow methodsFor: 'button creation' stamp: 'FB 11/13/2021 21:40:02'!
           createSeeImplementorsButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #seeImplementors
		label: 'See Implementors'.
! !
!InlineMethodUsagesWithShowImplementorsStepWindow methodsFor: 'actions' stamp: 'FB 11/22/2021 16:19:11'!
      seeImplementors

	self changeUsages.
	self delete.

	applier openImplementorSelectionWindow.! !
!InlineTemporaryVariable commentStamp: '<historical>' prior: 0!
I am a refactoring that replaces references to a temporary variable for its actual value.
Implementation notes:

- If the refactoring is initiated from the declaration of the variable, then it must have at most one assignment.
- If there are no assignments, the only effect is the removal of the declaration.
- If the refactoring is triggered from a usage, the value used is the one from the previous last assignment and
the scope is limited to all usages up the next assignment, if any, or the end of the method.!
!InlineTemporaryVariable methodsFor: 'applying' stamp: 'FB 12/21/2021 20:24:52' overrides: 16923675!
                        apply

	self usageToInlineIsTemporaryDeclaration
		ifTrue: [self inlineFromTemporaryDeclaration]
		ifFalse: [self inlineFromNonDeclarationUsage].

	self compileChanges.

! !
!InlineTemporaryVariable methodsFor: 'initialization' stamp: 'FB 3/13/2022 17:44:17'!
                            initializeOldVariableNode: aVariableNodeToInline usage: aUsageToInline method: aCompiledMethodToRefactor methodNode: aMethodNode

	| parseNodesPath  |

	oldVariableNode := aVariableNodeToInline.
	usageToInline := aUsageToInline.
	variableToInline := aVariableNodeToInline name.
	methodToRefactor := aCompiledMethodToRefactor.
	updatedSourceCode := methodToRefactor sourceCode.
	methodNode := aMethodNode.
	parseNodesPath := methodNode parseNodesPathAt: usageToInline first ifAbsent: [self class signalSelectedIntervalIsNotATemporary].
	methodOrBlockNodeDeclaringTemporary := (parseNodesPath collect: [:anAssociation | anAssociation key])
		detect: [:aParseNode | aParseNode isBlockNode and: [aParseNode hasArgumentOrTemporaryNamed: variableToInline]]
		ifNone: methodNode.
	rangeOfNodeDeclaringTemporary := (methodOrBlockNodeDeclaringTemporary = methodNode)
		ifTrue: [1 to: (methodNode sourceText size)]
		ifFalse: [(methodNode completeSourceRangesOf: methodOrBlockNodeDeclaringTemporary ifAbsent: [self shouldNotHappen])
			detect: [:aSourceRange | aSourceRange includesAllOf: usageToInline]].
	sourceCodeChanges := SortedCollection sortBlock: [ :left :right | left key first < right key first ].

! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'HAW 6/11/2022 19:21:17'!
      addParenthesesIfNeededTo: anExpression

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |

 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) = $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) = $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [anExpression]
		ifFalse: ['(', anExpression, ')'].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 12/21/2021 19:34:24'!
                    assertTemporaryHasAtMostOneAssignment

	self atMostOneAssignment ifFalse: [self class signalMoreThanOneAssignmentError].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/13/2022 17:44:17'!
                               assertTemporaryNotUsedInBlockBetween: assignmentToInline and: anIndex

	| temporaryPositionsBetweenAssignmentAndIndex |

	temporaryPositionsBetweenAssignmentAndIndex := (methodNode consolidateAsCollection: (methodNode rangeForNode: oldVariableNode
		ifAbsent: [self shouldNotHappen ]))
			select: [:aPosition | aPosition first > assignmentToInline last and: [aPosition last < anIndex]].

	temporaryPositionsBetweenAssignmentAndIndex do: [:aPosition | ((methodNode parseNodesPathAt: aPosition first ifAbsent: [self shouldNotHappen])
		anySatisfy: [:aNodeAndRange | aNodeAndRange key isBlockNode
			and: [aNodeAndRange key ~= methodOrBlockNodeDeclaringTemporary ]
			and: [(aNodeAndRange value includesAllOf: rangeOfNodeDeclaringTemporary) not ]])
				ifTrue: [self class signalTemporaryUsedInBlockSurroundedWithAssignments]]! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 1/9/2022 16:27:33'!
 assertUnassignedTemporaryIsNotReferenced

	((methodNode positionsForTemporaryVariable: variableToInline
		ifAbsent: [self shouldNotHappen]) size > 1) ifTrue: [self class signalAssignmentNotFound]






! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/13/2022 17:44:17'!
             assignmentNodeToInline: assignmentToInline

	methodNode nodesDo: [:aNode | ((self nodeIsAssignmentToTemporaryToInline: aNode)
		and: [
			|ranges|

			ranges := (methodNode rangeForNode: aNode ifAbsent: [#()]).
			(methodNode isMultipleRanges: ranges) ifFalse: [ranges := {ranges}].
			ranges anySatisfy: [:range | assignmentToInline includesAllOf: range].
		])
		ifTrue: [^aNode]].

	self shouldNotHappen.




! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 1/8/2022 13:27:10'!
                             assignmentsToVariableCount

	| count |

	count := 0.
	methodOrBlockNodeDeclaringTemporary nodesDo: [:aNode |
		(self nodeIsAssignmentToTemporaryToInline: aNode) ifTrue: [count := count + 1 ].
	].

	^count.





! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 1/8/2022 13:27:42'!
     atMostOneAssignment

	^self assignmentsToVariableCount <= 1.





! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/13/2022 17:44:17'!
                     closestAssignmentBeforeUsage: assignments


	^(assignments
		select: [:assignmentRange | (assignmentRange includesAllOf: usageToInline)
			or: [assignmentRange last < usageToInline first]])
		detectMax: [:assignmentRange | assignmentRange last]




! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 2/16/2021 17:03:49'!
                              compileChanges

	updatedSourceCode := updatedSourceCode copyReplacing: sourceCodeChanges.

	^methodToRefactor methodClass compile: updatedSourceCode classified: methodToRefactor category! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 4/3/2022 23:03:19'!
                              computeEndOfNodeEnclosingAssignment

	endOfNodeEnclosingAssignment := (methodNode parseNodesPathAt: assignmentToInlineRange first
		ifAbsent: [self shouldNotHappen])
			detect: [:nodeAndRange | nodeAndRange key isBlockNode]
			ifFound: [:nodeAndRangeOfAssignment | nodeAndRangeOfAssignment value last ]
			ifNone: [methodNode sourceText size].




! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/13/2022 17:44:17'!
                           findAssignmentOfUsage

	| lastAssignment assignments |

	assignments := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodOrBlockNodeDeclaringTemporary thatMatch:
		[:range | (range includesAllOf: usageToInline) or: [range last < usageToInline first] ].

	lastAssignment := assignments detectMax: [:assignment | assignment last].

	lastAssignment ~= nil ifTrue: [^lastAssignment ] ifFalse: [self class signalAssignmentNotFound]





! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 18:20:30'!
                            findLastIndexOfFirstAssignmentAfter: assignmentToInline

	| nextAssignmentsRanges |


	nextAssignmentsRanges := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodOrBlockNodeDeclaringTemporary
		thatMatch: [:range | range first > assignmentToInline last].

	^nextAssignmentsRanges collect: [:assignmentRange | assignmentRange last]
		andFold: [:rangeEnd1 :rangeEnd2 | rangeEnd1 min: rangeEnd2]
		ifEmpty: nil






! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 18:21:11'!
               findOnlyAssignmentRangeInNode: aMethodOrBlockNode

	^(self selectCompleteRangesOfAssignmentsToTemporaryFrom: aMethodOrBlockNode
	 	thatMatch: [:aRange | true])
			ifEmpty: [^nil]
			ifNotEmpty: [:rangesSet | rangesSet anyOne].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/19/2022 13:29:23'!
                     findReferencesBetweenAssignmentAndIndex: anIndex

	^((methodNode completeSourceRangesOf: oldVariableNode ifAbsent: [self shouldNotHappen])
		select: [:range | (range first >= assignmentToInlineRange last) and: [range first <= anIndex]
			and: [(self rangeIsLeftPartOfAssignmentToTemporary: range) not	]])! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 4/3/2022 23:27:25'!
        inlineAssignment

	| endOfNextAssignmentIndex endOfRefactoringScopeIndex |

	endOfNextAssignmentIndex := self findLastIndexOfFirstAssignmentAfter: assignmentToInlineRange.
	self computeEndOfNodeEnclosingAssignment.
	endOfRefactoringScopeIndex := endOfNextAssignmentIndex ifNil: [endOfNodeEnclosingAssignment ].
	self inlineAssignment: assignmentToInlineRange upTo: endOfRefactoringScopeIndex.

	(self atMostOneAssignment and: [self noReferencesToTemporaryAfter: endOfRefactoringScopeIndex ])
		ifTrue: [self removeTemporaryVariableDeclaration].




! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 4/3/2022 23:04:04'!
                   inlineAssignment: assignmentToInline upTo: anIndex

	| assignmentNode assignmentNodeValue expression expressionRange |

	(anIndex ~= endOfNodeEnclosingAssignment) ifTrue: [self assertTemporaryNotUsedInBlockBetween: assignmentToInline and: anIndex].
	assignmentNode := self assignmentNodeToInline: assignmentToInline.
	assignmentNodeValue := assignmentNode value.
	expressionRange := (methodNode completeSourceRangesOf: assignmentNodeValue ifAbsent: [self shouldNotHappen])
		detect: [:range | assignmentToInline includesAllOf: range].
	expression := methodNode sourceText copyFrom: expressionRange first to: expressionRange last.

	self inlineAssignmentNode: assignmentNode withExpression: expression upTo: anIndex;
		removeAssignment: assignmentToInline.! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 4/24/2021 18:20:38'!
    inlineAssignmentNode: anAssignmentNode withExpression: anExpression upTo: anIndex

	| assignmentNodeValue |

	assignmentNodeValue := anAssignmentNode value.
	assignmentNodeValue isMessageNode
		ifTrue: [
			assignmentNodeValue isUnaryMessageSend
				ifTrue: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isInfix
				ifTrue: [self inlineTemporaryNodeWithBinaryMessageExpression: anExpression
					upTo: anIndex].
			assignmentNodeValue isKeywordMessageSend
				ifTrue: [self inlineTemporaryNodeWithKeywordMessageExpression: anExpression
					upTo: anIndex].

		]
		ifFalse: [self inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression upTo: anIndex].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/19/2022 13:18:06'!
                       inlineFromNonDeclarationUsage

	assignmentToInlineRange := self findAssignmentOfUsage.
	self inlineAssignment.
! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/19/2022 13:17:11'!
        inlineFromTemporaryDeclaration

	self assertTemporaryHasAtMostOneAssignment.

	assignmentToInlineRange := self findOnlyAssignmentRangeInNode: methodOrBlockNodeDeclaringTemporary.

	assignmentToInlineRange ~= nil
		ifTrue: [self inlineAssignment]
		ifFalse: [
			self assertUnassignedTemporaryIsNotReferenced.
			self removeTemporaryVariableDeclaration
		]






! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 2/16/2021 20:44:12'!
             inlineTemp: aTempNode usedIn: aRange insideBinaryMessageNode: aBinaryMessageNode withBinaryExpression: aBinaryExpression

	(self temporaryNode: aTempNode referencedIn: aRange isArgumentIn: aBinaryMessageNode)
		ifTrue: [self replaceRange: aRange withParenthesisedExpression: aBinaryExpression]
		ifFalse: [self replaceRange: aRange withExpression: aBinaryExpression]


					! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/19/2022 13:26:48'!
 inlineTemporaryNodeWithBinaryMessageExpression: anExpression upTo: anIndex

	| referencesToInline |

	referencesToInline := self findReferencesBetweenAssignmentAndIndex: anIndex.
	referencesToInline do: [:range |
		| parentNode  |

		parentNode := (methodNode parseNodesPathAt: range first ifAbsent: [self shouldNotHappen]) second key.

		((parentNode isMessageNode) and: [parentNode isKeywordMessageSend not])
			ifTrue: [
				parentNode isUnaryMessageSend ifTrue: [self replaceRange: range withParenthesisedExpression: anExpression ].
				parentNode isInfix ifTrue: [self inlineTemp: oldVariableNode usedIn: range insideBinaryMessageNode: parentNode
					withBinaryExpression: anExpression].
			]
			ifFalse: [self replaceRange: range withExpression: anExpression.]
	].	! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/19/2022 13:26:48'!
                   inlineTemporaryNodeWithKeywordMessageExpression: anExpression upTo: anIndex

	| referencesToInline |

	referencesToInline := self findReferencesBetweenAssignmentAndIndex: anIndex.
	referencesToInline do: [:range |
		| parentNode  |

		parentNode := (methodNode parseNodesPathAt: range first ifAbsent: [self shouldNotHappen]) second key.

		(parentNode isMessageNode)
			ifTrue: [
				parentNode isUnaryMessageSend ifTrue: [self replaceRange: range withParenthesisedExpression: anExpression ].
				((parentNode isInfix) or: parentNode isKeywordMessageSend) ifTrue: [(self tempNodeIsReceiverOrArgumentOfReceiverWhenUsedIn: range)
					ifTrue: [self replaceRange: range withParenthesisedExpression: anExpression]
					ifFalse: [self replaceRange: range withExpression: anExpression ]]
			]
			ifFalse: [self replaceRange: range withExpression: anExpression.]
	].	! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/19/2022 13:26:48'!
                           inlineTemporaryNodeWithLiteralOrUnaryMessageExpression: anExpression upTo: anIndex

	| referencesToInline |

	referencesToInline := self findReferencesBetweenAssignmentAndIndex: anIndex.

	referencesToInline do: [:range |
		self replaceRange: range withExpression: anExpression.
	].



	! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 4/3/2022 23:26:14'!
                         noReferencesToTemporaryAfter: endOfRefactoringScopeIndex

	^(methodNode consolidateAsCollection: (methodNode rangeForNode: oldVariableNode
		ifAbsent: [self shouldNotHappen ]))
			noneSatisfy: [:aPosition | aPosition first > endOfRefactoringScopeIndex].




! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 11/28/2020 16:23:56'!
                    nodeIsAssignmentToTemporaryToInline: aNode

	^ (aNode isAssignmentToTemporary) and: [aNode variable name = variableToInline]! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/13/2022 17:44:17'!
                           range: aRange isArgumentIn: aBinaryMessageNode

	^ (methodNode consolidateAsCollection: (methodNode rangeForNode: aBinaryMessageNode ifAbsent: 	[self shouldNotHappen]))
					anySatisfy: [:aBinaryMessageNodeRange | aBinaryMessageNodeRange includesAllOf: aRange]! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/13/2022 17:44:17'!
                   rangeIsLeftPartOfAssignmentToTemporary: aRange

	methodNode nodesDo: [:aNode |
		(self nodeIsAssignmentToTemporaryToInline: aNode)	 ifTrue: [
			| ranges completeRanges |

			ranges := methodNode consolidateAsCollection: (methodNode rangeForNode: aNode ifAbsent: [self shouldNotHappen ]).
			completeRanges := methodNode consolidateAsCollection:(methodNode completeSourceRangesOf: aNode ifAbsent: [self shouldNotHappen ]).
			((completeRanges anySatisfy: [:aCompleteRange | aCompleteRange includesAllOf: aRange])
				and: [ranges noneSatisfy: [:aNonCompleteRange | aNonCompleteRange includesAllOf: aRange ]]) ifTrue: [^true]
		]
	].

	^false

		! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/16/2022 18:41:08'!
                  rangeIsPartOfTemporaryDeclaration: aRange

	^(methodNode parseNodesPathAt: aRange first ifAbsent: [self shouldNotHappen])
		detect: [:aNodeAndRange | aNodeAndRange key isTemporariesDeclaration ]
		ifFound: [:foundNodeAndRange | ^true]
		ifNone: [^false].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 18:34:13'!
                          removeAssignment: assignmentToInline

	self replaceRange: assignmentToInline withExpression: ''.





! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 19:14:06'!
                  removeTemporaryVariableDeclaration

	| temporariesDeclarationNodes temporariesDeclarationNode intervalToRemove sourceText |

	temporariesDeclarationNode := methodOrBlockNodeDeclaringTemporary temporariesDeclaration.
	temporariesDeclarationNodes := temporariesDeclarationNode temporaryDeclarationNodes.
	sourceText := methodNode sourceText.
	temporariesDeclarationNodes size = 1
		ifTrue: [
			intervalToRemove := (methodNode rangeForNode: temporariesDeclarationNode
				ifAbsent: [self shouldNotHappen ])
					asSourceCodeInterval expandUntilStartOfNextStatementOn: sourceText.
		]
		ifFalse: [
			| temporaryDeclarationNode |
			temporaryDeclarationNode := temporariesDeclarationNodes detect: [:aTemporaryDeclarationNode |
				aTemporaryDeclarationNode declaresVariable: oldVariableNode ].
			intervalToRemove := (methodNode rangeForNode: temporaryDeclarationNode ifAbsent: [self shouldNotHappen ])
				asSourceCodeInterval expandUntilNextNonBlankCharacterOn: sourceText.
		].

	self replaceRange: intervalToRemove withExpression: ''
	! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 12/28/2021 20:01:40'!
          replaceRange: aRange withExpression: anExpression

	sourceCodeChanges add: (aRange -> anExpression).

	! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 2/20/2021 19:55:15'!
                replaceRange: aRange withParenthesisedExpression: anExpression

	self replaceRange: aRange withExpression: (self addParenthesesIfNeededTo: anExpression).

	! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 18:20:30'!
                            selectCompleteRangesOfAssignmentsToTemporaryFrom: aParseNode thatMatch: aConditionBlock

	| assignments |

	assignments := Set new.
	aParseNode nodesDo: [:aNode |
		(self nodeIsAssignmentToTemporaryToInline: aNode)
			ifTrue: [
				| nodeRanges satisfyingRanges |
				nodeRanges := methodNode completeSourceRanges at: aNode ifAbsent: [].
				satisfyingRanges := (nodeRanges select: aConditionBlock)
					collect:[:range | range asSourceCodeInterval
						expandUntilStartOfNextStatementOn: methodNode sourceText].
				assignments addAll: (satisfyingRanges)]
	].

	^assignments






! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 3/13/2022 17:44:17'!
                tempNodeIsReceiverOrArgumentOfReceiverWhenUsedIn: aRange

	methodNode nodesDo: [ :aNode |
		(aNode isMessageNode
			and: [(methodNode completeSourceRangesOf: aNode ifAbsent: [self shouldNotHappen])
				anySatisfy: [:completeRange | (completeRange includesAllOf: aRange) and: [completeRange last > aRange last] ]]
		 	and: [(aNode receiver equivalentTo: oldVariableNode)
				or: [aNode receiver isMessageNode and: [aNode receiver arguments
						anySatisfy: [:argument | argument equivalentTo: oldVariableNode]]]]	)
			ifTrue: [^true]
	].
	^false.! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 2/14/2021 16:55:38'!
                     tempNodeToInline

	^methodNode tempNodes select: [:aNode | aNode name = variableToInline].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 2/16/2021 20:14:05'!
                             temporaryNode: aTempNode referencedIn: aRange isArgumentIn: aBinaryMessageNode

	^ (aBinaryMessageNode arguments first equivalentTo: aTempNode) and: [self range: aRange isArgumentIn: aBinaryMessageNode]! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 18:07:51'!
              usageToInlineIsTemporaryDeclaration

	^(methodNode parseNodesPathAt: usageToInline first ifAbsent: [self shouldNotHappen ])
		anySatisfy: [:aNodeAndRangeAssociation | aNodeAndRangeAssociation key isTemporaryDeclaration].





! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineTemporaryVariable class
	instanceVariableNames: 'variableToInline blockNodeDeclaringTemporary'!

!classDefinition: 'InlineTemporaryVariable class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineTemporaryVariable class
	instanceVariableNames: 'variableToInline blockNodeDeclaringTemporary'!
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 11/29/2020 01:42:06'!
                               assignmentNotFoundErrorMessage

	^'Variable is never assigned'
! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 11/28/2020 16:27:34'!
        moreThanOneAssignmentErrorMessage

	^'There are multiple assignments that could be inlined. Please select a specific usage to inline'.
! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 12/28/2021 20:02:39'!
selectionIsNotATemporaryVariableErrorMessage

	^'Selected interval is not a temporary variable'.! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 12/29/2021 21:11:34'!
       signalAssignmentNotFound

	^self refactoringError: (self assignmentNotFoundErrorMessage)





! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 12/21/2021 19:36:51'!
         signalMoreThanOneAssignmentError

	self refactoringError: self moreThanOneAssignmentErrorMessage.





! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 12/28/2021 20:02:39'!
signalSelectedIntervalIsNotATemporary

	^self refactoringError: self selectionIsNotATemporaryVariableErrorMessage
! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 3/25/2021 20:15:05'!
                      signalTemporaryUsedInBlockSurroundedWithAssignments

	^self refactoringError: self temporaryUsedInBlockSurroundedWithAssignmentsErrorMessage
! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 3/25/2021 20:15:05'!
                           temporaryUsedInBlockSurroundedWithAssignmentsErrorMessage

	^'Temporary is used in block and has multiple assignments'.! !
!InlineTemporaryVariable class methodsFor: 'instance creation - private' stamp: 'FB 4/11/2021 20:18:01'!
                            findTemporaryNamed: temporaryName atUsage: usageInterval inMethodNode: aMethodNode

	| oldVariableNodeAndUsageInterval parseNodesPath |

	parseNodesPath := aMethodNode parseNodesPathAt: usageInterval first ifAbsent: [self signalSelectedIntervalIsNotATemporary].
	oldVariableNodeAndUsageInterval := parseNodesPath
		detect: [:anAssociation |
			| parseNode |
			parseNode := anAssociation key.
			(parseNode isTemp and: [parseNode isNamed: temporaryName])]
		ifNone:[self signalSelectedIntervalIsNotATemporary].

	^{oldVariableNodeAndUsageInterval key. oldVariableNodeAndUsageInterval value}.
! !
!InlineTemporaryVariable class methodsFor: 'instance creation' stamp: 'FB 4/11/2021 20:18:52'!
             named: tempVarToInlineName atUsageInterval: usageInterval inMethod: compiledMethodToRefactor

	| oldVariableNodeAndUsageInterval methodNode |
	methodNode := compiledMethodToRefactor methodNode.
	oldVariableNodeAndUsageInterval := self findTemporaryNamed: tempVarToInlineName atUsage: usageInterval
		inMethodNode: methodNode.

	^self new
		initializeOldVariableNode: oldVariableNodeAndUsageInterval first
		usage: oldVariableNodeAndUsageInterval second
		method: compiledMethodToRefactor methodNode: methodNode.! !
!InlineTemporaryVariableApplier methodsFor: 'refactoring - creation' stamp: 'FB 5/20/2021 20:54:28' overrides: 16923785!
    createRefactoring

	^ self refactoringClass
		named: temporaryToInline
		atUsageInterval: usageInterval
		inMethod: methodToRefactor.! !
!InlineTemporaryVariableApplier methodsFor: 'refactoring - creation' stamp: 'FB 5/20/2021 20:28:41'!
                  refactoringClass

	^ InlineTemporaryVariable ! !
!InlineTemporaryVariableApplier methodsFor: 'refactoring - changes' stamp: 'FB 6/3/2021 19:22:49' overrides: 16923803!
                        requestRefactoringParameters! !
!InlineTemporaryVariableApplier methodsFor: 'refactoring - changes' stamp: 'FB 5/20/2021 20:55:04' overrides: 16923923!
        showChanges

	codeProvider currentMethodRefactored! !
!InlineTemporaryVariableApplier methodsFor: 'initialization' stamp: 'FB 5/20/2021 20:52:16'!
             initializeOn: aCodeProvider forTemporary: aTemporaryToInline at: aUsageInterval of: aMethodToRefactor

	codeProvider := aCodeProvider.
	temporaryToInline := aTemporaryToInline.
	usageInterval  := aUsageInterval.
	methodToRefactor := aMethodToRefactor.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineTemporaryVariableApplier class
	instanceVariableNames: ''!

!classDefinition: 'InlineTemporaryVariableApplier class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineTemporaryVariableApplier class
	instanceVariableNames: ''!
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 12/21/2021 19:56:05' overrides: 16923943!
                              createAndValueHandlingExceptions: creationBlock


	[super createAndValueHandlingExceptions: creationBlock]
		on: Refactoring refactoringErrorClass
		do: [ :refactoringError | ^self inform: refactoringError messageText ].
! !
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 6/3/2021 19:20:00'!
                     on: anEditor for: usageInterval of: aMethodToRefactor

	| tempToInline |

	tempToInline := anEditor wordUnder: usageInterval first.

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor ! !
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 5/20/2021 20:27:02'!
                        refactoringClass

	^ InlineTemporaryVariable ! !
!InlineMethodMessageSendsSet methodsFor: 'initialization' stamp: 'HAW 6/11/2022 19:15:58'!
                    addMessageNodeReference: aMessageNodeReference ifIncluded: anIncludedBlock

	(messageList includes: aMessageNodeReference)
		ifTrue: [anIncludedBlock value]
		ifFalse: [messageList add: aMessageNodeReference]! !
!InlineMethodMessageSendsSet methodsFor: 'initialization' stamp: 'FB 10/31/2021 15:52:40' overrides: 16796676!
                             initialize

	selectedIndex := 0.
	super initialize ! !
!InlineMethodMessageSendsSet methodsFor: 'initialization' stamp: 'FB 10/31/2021 17:15:15'!
              initializeApplier: anInlineMethodApplier

	applier := anInlineMethodApplier.! !
!InlineMethodMessageSendsSet methodsFor: 'message list' stamp: 'FB 10/31/2021 15:52:41' overrides: 16796141!
   messageListIndex

	^selectedIndex ! !
!InlineMethodMessageSendsSet methodsFor: 'message list' stamp: 'FB 10/31/2021 15:52:41' overrides: 16886325!
             messageListIndex: anIndex

	selectedIndex := anIndex.
	^super messageListIndex: anIndex ! !
!InlineMethodMessageSendsSet methodsFor: 'source code ranges' stamp: 'FB 11/24/2021 23:24:15' overrides: 16886940!
                 messageSendsRangesOf: aMessageNodeReference

	| messageSend |

	messageSend := applier messageSendAt: self messageListIndex ifAbsent: [ ^#()  ].
	messageSend completeSourceRange isEmpty
		ifTrue: [^#()]
		ifFalse: [^Array with: messageSend completeSourceRange]

	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

InlineMethodMessageSendsSet class
	instanceVariableNames: ''!

!classDefinition: 'InlineMethodMessageSendsSet class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
InlineMethodMessageSendsSet class
	instanceVariableNames: ''!
!InlineMethodMessageSendsSet class methodsFor: 'instance creation' stamp: 'FB 11/25/2021 00:25:16'!
                       applier: anInlineMethodApplier

	^(self messageList: anInlineMethodApplier messageSendsToInline) initializeApplier: anInlineMethodApplier! !
!MessageNodeReference methodsFor: 'printing' stamp: 'FB 11/25/2021 00:12:18' overrides: 16902848!
                 displayStringOrText
	"To be used in the UI"

	^stringVersion ifNil: [String streamContents: [:aStream | self printOn: aStream ]].! !
!MessageNodeReference methodsFor: 'printing' stamp: 'FB 3/19/2022 19:43:35'!
              prefixStringVersionWith: aString

	"TODO: duplicated code from MethodReference"

	self removeStringVersionPrefix.
	stringVersion _ '[', aString, '] - ', (stringVersion ifNil: [self displayStringOrText]).! !
!MessageNodeReference methodsFor: 'printing' stamp: 'FB 11/25/2021 00:13:41' overrides: 16902975!
               printOn: aStream

	classReference printOn: aStream.
	aStream nextPutAll: '>>'.
	selector printOn: aStream.
	aStream newLine.
	messageNode printOn: aStream.
	aStream newLine.
	completeSourceRange printOn: aStream.! !
!MessageNodeReference methodsFor: 'printing' stamp: 'FB 3/19/2022 19:41:12'!
                           removeStringVersionPrefix

	"TODO: duplicated code from MethodReference"

	stringVersion ifNotNil: [:string | | i prefixCoda |
		prefixCoda _ '] - '.
		i _ stringVersion findString: prefixCoda.
		i = 0 ifFalse: [stringVersion _ stringVersion copyFrom: i + prefixCoda size to: stringVersion size ].
	].

	! !
!MessageNodeReference methodsFor: 'printing' stamp: 'FB 11/24/2021 23:26:59'!
                              stringVersion

	^stringVersion! !
!MessageNodeReference methodsFor: 'printing' stamp: 'FB 11/24/2021 23:26:47'!
                stringVersion: aString

	stringVersion := aString.! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 11/14/2021 18:04:33'!
                            actualClass

	^classReference! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 11/3/2021 19:51:41'!
                  compiledMethod

	^classReference >> selector ! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 10/31/2021 23:04:04'!
 completeSourceRange

	^completeSourceRange! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 3/19/2022 19:13:52'!
     isPossibleMessageSend

	"Implements polymorphism with PossbileMessageNodeReference"

	^false! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 10/31/2021 21:00:34'!
                  messageNode

	^messageNode ! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 11/14/2021 18:15:07'!
                   messageSendsRangesOf: aSelector

	"To use polimorphysm with MethodReference - Fernando"

	^completeSourceRange! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 11/3/2021 20:03:36'!
 methodNode

	^methodNode! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 11/14/2021 17:19:18'!
                      methodReference

	^MethodReference class: classReference selector: 	selector.! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 11/14/2021 18:05:14'!
 methodSymbol

	^selector! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 11/14/2021 18:06:31'!
                      selectorOfMessageNode

	^messageNode selector key! !
!MessageNodeReference methodsFor: 'comparing' stamp: 'HAW 6/11/2022 19:24:06'!
                            asPossibleMessageNodeReference

	^PossibleMessageNodeReference
		messageNode: messageNode
		selector: selector
		class: classReference
		completeSourceRange: completeSourceRange.! !
!MessageNodeReference methodsFor: 'comparing' stamp: 'HAW 6/11/2022 19:24:24'!
                           equivalentTo: anObject

	^(anObject isKindOf: MessageNodeReference)
		and: [anObject actualClass = classReference]
		and: [anObject methodNode sourceText = methodNode sourceText ]
		and: [anObject messageNode equivalentTo: messageNode ]
		and: [anObject completeSourceRange = completeSourceRange		]
		! !
!MessageNodeReference methodsFor: 'testing' stamp: 'FB 11/25/2021 00:30:20'!
  isMessageListTitle

	^completeSourceRange = #()
! !
!MessageNodeReference methodsFor: 'initialization' stamp: 'FB 3/19/2022 19:41:58'!
                         messageNode: aMessageNode selector: aSelector class: aClass completeSourceRange: aCompleteSourceRange

	messageNode := aMessageNode.
	selector := aSelector.
	classReference := aClass.
	completeSourceRange := aCompleteSourceRange.
	"When no source range is passed it means this is a dummy message node reference that works as a title in the message list window
	and the selector is not even defined in the class - Fernando"
	self isMessageListTitle ifFalse: [methodNode := (classReference >> selector) methodNode.].
	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

MessageNodeReference class
	instanceVariableNames: ''!

!classDefinition: 'MessageNodeReference class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
MessageNodeReference class
	instanceVariableNames: ''!
!MessageNodeReference class methodsFor: 'initialization' stamp: 'FB 11/13/2021 17:39:03'!
                         messageNode: aMessageNode selector: aSelector class: aClass completeSourceRange: aCompleteSourceRange

	^self new messageNode: aMessageNode selector: aSelector class: aClass completeSourceRange: aCompleteSourceRange.! !
!PossibleMessageNodeReference methodsFor: 'accesing' stamp: 'FB 3/19/2022 19:13:17' overrides: 50374225!
                           isPossibleMessageSend

	^true! !
!PossibleMessageNodeReference methodsFor: 'initialization' stamp: 'FB 3/19/2022 19:23:16' overrides: 50374285!
                messageNode: aMessageNode selector: aSelector class: aClass completeSourceRange: aCompleteSourceRange

	super messageNode: aMessageNode selector: aSelector class: aClass completeSourceRange: aCompleteSourceRange.
	self prefixStringVersionWith: self class possibleMessageSendStringVersionHeader.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

PossibleMessageNodeReference class
	instanceVariableNames: ''!

!classDefinition: 'PossibleMessageNodeReference class' category: #'Tools-Refactoring' stamp: 'Install-5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st 6/16/2022 07:24:52'!
PossibleMessageNodeReference class
	instanceVariableNames: ''!
!PossibleMessageNodeReference class methodsFor: 'printing' stamp: 'FB 3/19/2022 19:10:06'!
                              possibleMessageSendStringVersionHeader

	"TODO: duplicated code from PossibleSender"

	^'Possible'! !
!PossibleMessageNodeReference class methodsFor: 'instance creation' stamp: 'FB 3/19/2022 19:15:35' overrides: 50374316!
  messageNode: aMessageNode selector: aSelector class: aClass completeSourceRange: aCompleteSourceRange

	^self new messageNode: aMessageNode selector: aSelector class: aClass completeSourceRange: aCompleteSourceRange.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5235-InlineRefactorings-HernanWilkinson-2022Jun11-19h09m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5234] on 8 June 2022 at 10:10:32 am'!

SequenceableCollection subclass: #CharacterSequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #CharacterSequence category: #'Kernel-Text' stamp: 'Install-5236-NewClass-CharacterSequence-JuanVuletich-2022Jun08-10h00m-jmv.002.cs.st 6/16/2022 07:24:52'!
SequenceableCollection subclass: #CharacterSequence
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!
!CharacterSequence commentStamp: '<historical>' prior: 0!
Superclass for String classes!
!CharacterSequence methodsFor: 'accessing' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 16822799!
size
	"Answer the number of indexable fields in the receiver. This value is the 
	same as the largest legal subscript. Primitive is specified here to override 
	SequenceableCollection size. Essential. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 62>
	^self basicSize! !
!CharacterSequence methodsFor: 'adding' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 16822843!
    add: newObject
	self shouldNotImplement! !
!CharacterSequence methodsFor: 'copying' stamp: 'KenD 9/4/2016 18:22:51'!
           appendToText: aText

	| textStringSize |
	textStringSize := aText string size.
	^ aText replaceFrom: textStringSize + 1
			 to: textStringSize 
			 with: self asText! !
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 6/23/2011 09:53'!
              commonPartWith: aString startAt: startIndex stopAt: stopIndexRequested applying: aBlock
	"Return the size of the longest common subsequence with aString, only between startIndex and stopIndex.
	Apply aBlock to each character before comparing.
	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."
	| stopIndex |
	stopIndex _ stopIndexRequested min: aString size.
	startIndex
		to: stopIndex
		do: [ :i |
			(aBlock value: (self at: i)) = (aBlock value: (aString at: i)) ifFalse: [ ^ i - 1 ]].
	^ stopIndex! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 09:32:35'!
   asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8Bytes: self asUtf8Bytes! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:43:33'!
 asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!CharacterSequence methodsFor: 'converting' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 16901837!
            asString
	"Answer the receiver itself."
	^self! !
!CharacterSequence methodsFor: 'converting' stamp: 'ST-80 5/31/1983 9:10:35'!
asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 09:32:54'!
   asUtf8Bytes
	^self subclassResponsibility! !
!CharacterSequence methodsFor: 'converting' stamp: 'di 1/16/98 16:33'!
            contractTo: smallSize
	"return myself or a copy shortened by ellipsis to smallSize"
	| leftSize |
	self size <= smallSize
		ifTrue: [^ self].  "short enough"
	smallSize < 5
		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"
	leftSize _ smallSize-2//2.
	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"
		to: self size - (smallSize - leftSize - 3)
		with: '...'
"
	'A clear but rather long-winded summary' contractTo: 18
	(Utf8String withBytes: 'A clear but rather long-winded summary' asUtf8) contractTo: 18
"! !
!CharacterSequence methodsFor: 'enumerating' stamp: 'jmv 6/8/2022 09:46:46' overrides: 16934336!
                               collect: aBlock
	"Refer to the comment in Collection >> #collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacter ]) ifFalse: [
		^array ].
	^self class newFrom: array! !
!CharacterSequence methodsFor: 'enumerating' stamp: 'jmv 6/8/2022 09:47:25'!
                            collectInArray: aBlock
	"Refer to the comment in Collection >> #collect:."
	| result i |
	result _ Array new: self size.
	i _ 1.
	self do: [ :codePoint |
		result at: i put: (aBlock value: codePoint).
		i _ i + 1 ].
	^ result.! !
!CharacterSequence methodsFor: 'testing' stamp: 'jmv 6/8/2022 08:41:33' overrides: 16823965!
                             isEmpty
	^self size = 0! !
!CharacterSequence methodsFor: 'testing' stamp: 'jmv 6/6/2022 10:54:40' overrides: 50368461!
        isString
	^ true! !
!CharacterSequence methodsFor: 'user interface' stamp: 'jmv 1/2/2013 15:26'!
                               edit

	self editLabel: self class name, ' Text Editor'! !
!CharacterSequence methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:22'!
                     editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 9/29/2019 12:52:40' overrides: 16785646!
    new
	"Answer a new instance of me, with size = 0, unles a specific size is used."

	^self new: self numElements! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35'!
                  new: size withAll: value 
	"Answer a new instance of me, whose every element is equal to the argument,
	value."

	^(self new: size) atAllPut: value! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 3/7/2015 22:23' overrides: 16824134!
                               newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."
	| newArray index |
	newArray _ self new: aCollection size.
	index _ 0.
	aCollection do: [ :each | newArray at: (index _ index + 1) put: each].
	^ newArray

"
	Array newFrom: {1. 2. 3}
	{1. 2. 3} as: Array
	{1. 2. 3} as: ByteArray
	{$c. $h. $r} as: String
	{$c. $h. $r} as: Text
"! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 9/29/2019 12:47:53'!
           numElements
	"Some subclasses create instances of a specific size, and a non-zero number"
	^0! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 16824154!
                with: anObject 
	"Answer a new instance of me, containing only anObject."

	| newCollection |
	newCollection _ self new: 1.
	newCollection at: 1 put: anObject.
	^newCollection! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 16824160!
                              with: firstObject with: secondObject 
	"Answer a new instance of me, containing firstObject and secondObject."

	| newCollection |
	newCollection _ self new: 2.
	newCollection at: 1 put: firstObject.
	newCollection at: 2 put: secondObject.
	^newCollection! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 16824168!
              with: firstObject with: secondObject with: thirdObject 
	"Answer a new instance of me, containing only these three objects."

	| newCollection |
	newCollection _ self new: 3.
	newCollection at: 1 put: firstObject.
	newCollection at: 2 put: secondObject.
	newCollection at: 3 put: thirdObject.
	^newCollection! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 3/7/2015 23:10' overrides: 16824214!
                              withAll: aSequenceableCollection
	"Create a new collection containing all the elements from aSequenceableCollection."

	^ (self new: aSequenceableCollection size)
		replaceFrom: 1
		to: aSequenceableCollection size
		with: aSequenceableCollection! !
!CharacterSequence class methodsFor: 'stream creation' stamp: 'jmv 5/22/2022 21:07:37'!
              writeStream
	^ WriteStream on: (self new: 100)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5236-NewClass-CharacterSequence-JuanVuletich-2022Jun08-10h00m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5234] on 8 June 2022 at 9:55:57 am'!
!String methodsFor: 'enumerating' stamp: 'jmv 6/8/2022 09:46:53' prior: 50364113 overrides: 16934336!
                         collect: aBlock
	"Refer to the comment in Collection >> #collect:."
	| array resultClass |
	array _ self collectInArray: aBlock.
	resultClass _ String.
	array do: [ :element |
		element isCharacter ifFalse: [ ^array ].
		(element is: #Character) ifFalse: [
			resultClass _ Utf8String ]].
	^resultClass newFrom: array! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
ArrayedCollection removeSubclass: String.
String superclass: CharacterSequence.
CharacterSequence addSubclass: String.
String class superclass: CharacterSequence class.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5237-CharacterSequence-NewSuperclassForString-JuanVuletich-2022Jun08-09h54m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5236] on 8 June 2022 at 9:57:20 am'!

String removeSelector: #commonPartWith:startAt:stopAt:applying:!

!methodRemoval: String #commonPartWith:startAt:stopAt:applying: stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
commonPartWith: aString startAt: startIndex stopAt: stopIndexRequested applying: aBlock
	"Return the size of the longest common subsequence with aString, only between startIndex and stopIndex.
	Apply aBlock to each character before comparing.
	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."
	| stopIndex |
	stopIndex _ stopIndexRequested min: aString size.
	startIndex
		to: stopIndex
		do: [ :i |
			(aBlock value: (self at: i)) = (aBlock value: (aString at: i)) ifFalse: [ ^ i - 1 ]].
	^ stopIndex!

String removeSelector: #appendToText:!

!methodRemoval: String #appendToText: stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
appendToText: aText

	| textStringSize |
	textStringSize := aText string size.
	^ aText replaceFrom: textStringSize + 1
			 to: textStringSize 
			 with: self asText!

String removeSelector: #editLabel:!

!methodRemoval: String #editLabel: stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
editLabel: labelString

	(TextModel withText: self) openLabel: labelString!

String removeSelector: #isString!

!methodRemoval: String #isString stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
isString
	^ true!

String removeSelector: #asText!

!methodRemoval: String #asText stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self!

String removeSelector: #asPlainString!

!methodRemoval: String #asPlainString stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self!

String removeSelector: #contractTo:!

!methodRemoval: String #contractTo: stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
contractTo: smallSize
	"return myself or a copy shortened by ellipsis to smallSize"
	| leftSize |
	self size <= smallSize
		ifTrue: [^ self].  "short enough"
	smallSize < 5
		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"
	leftSize _ smallSize-2//2.
	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"
		to: self size - (smallSize - leftSize - 3)
		with: '...'
"
	'A clear but rather long-winded summary' contractTo: 18
"!

String removeSelector: #collectInArray:!

!methodRemoval: String #collectInArray: stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
collectInArray: aBlock
	"Refer to the comment in Collection|collect:."
	| result value |
	result _ Array new: self size.
	1 to: self size do: [ :index |
		value _ aBlock value: (self at: index).
		result at: index put: value].
	^ result.!

String removeSelector: #edit!

!methodRemoval: String #edit stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
edit

	self editLabel: 'Text Editor'!

String removeSelector: #asString!

!methodRemoval: String #asString stamp: 'Install-5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st 6/16/2022 07:24:52'!
asString
	"Answer the receiver itself."
	^self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5238-StringCleanup-JuanVuletich-2022Jun08-09h57m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5237] on 8 June 2022 at 10:22:09 am'!

Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #UnicodeCodePoint category: #'Kernel-Text' stamp: 'Install-5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st 6/16/2022 07:24:52'!
Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

CharacterSequence subclass: #Utf32String
	instanceVariableNames: 'codePoints hash '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Utf32String category: #'Kernel-Text' stamp: 'Install-5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st 6/16/2022 07:24:52'!
CharacterSequence subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

CharacterSequence subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Utf8String category: #'Kernel-Text' stamp: 'Install-5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st 6/16/2022 07:24:52'!
CharacterSequence subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

Utf8String subclass: #Utf8Symbol
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Utf8Symbol category: #'Kernel-Text' stamp: 'Install-5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st 6/16/2022 07:24:52'!
Utf8String subclass: #Utf8Symbol
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

CharacterSequence subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Utf32String category: #'Kernel-Text' stamp: 'Install-5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st 6/16/2022 07:24:52'!
CharacterSequence subclass: #Utf32String
	instanceVariableNames: 'codePoints hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

CharacterSequence subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Utf8String category: #'Kernel-Text' stamp: 'Install-5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st 6/16/2022 07:24:52'!
CharacterSequence subclass: #Utf8String
	instanceVariableNames: 'bytes count strideIndex hash'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

Smalltalk removeClassNamed: #EncodedString!

!classRemoval: #EncodedString stamp: 'Install-5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st 6/16/2022 07:24:52'!
SequenceableCollection subclass: #EncodedString
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5239-UnicodeStringsAsSubclassesOfCharacterSequence-JuanVuletich-2022Jun08-10h12m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 11:38:36 am'!
!String methodsFor: 'accessing' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 50374399!
              size
	"Answer the number of indexable fields in the receiver. This value is the 
	same as the largest legal subscript. Primitive is specified here to override 
	SequenceableCollection size. Essential. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 62>
	^self basicSize! !
!String methodsFor: 'testing' stamp: 'jmv 6/8/2022 08:41:33' overrides: 50374511!
                isEmpty
	^self size = 0! !

CharacterSequence removeSelector: #size!

!methodRemoval: CharacterSequence #size stamp: 'Install-5240-String-Cleanup-JuanVuletich-2022Jun08-11h35m-jmv.001.cs.st 6/16/2022 07:24:52'!
size
	"Answer the number of indexable fields in the receiver. This value is the 
	same as the largest legal subscript. Primitive is specified here to override 
	SequenceableCollection size. Essential. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 62>
	^self basicSize!

CharacterSequence removeSelector: #isEmpty!

!methodRemoval: CharacterSequence #isEmpty stamp: 'Install-5240-String-Cleanup-JuanVuletich-2022Jun08-11h35m-jmv.001.cs.st 6/16/2022 07:24:52'!
isEmpty
	^self size = 0!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5240-String-Cleanup-JuanVuletich-2022Jun08-11h35m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 11:44:56 am'!
!String methodsFor: 'system primitives' stamp: 'jmv 6/6/2022 20:10:40'!
              compare: string1 with: string2
	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."

	^self compare: string1 with: string2 collated: CaseSensitiveOrder! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:20:13'!
                              < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	^ ('' compare: bytes with: aString asUtf8Bytes) = 1! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:20:18'!
                            <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	^ ('' compare: bytes with: aString asUtf8Bytes) <= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:20:25'!
              > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	^ ('' compare: bytes with: aString asUtf8Bytes) = 3! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:20:28'!
                             >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	^ ('' compare: bytes with: aString asUtf8Bytes) >= 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:07:22' prior: 16947505!
   < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString > self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 1! !
!String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:07:18' prior: 16947513!
                   <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString >= self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:07:14' prior: 50368522 overrides: 16934001!
                = aString
	"Answer whether the receiver sorts equally as aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String or Symbol, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Let them handle us"
	aString isByteString ifFalse: [
		^aString = self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 2.! !
!String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:07:10' prior: 16947542!
                       > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString < self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 3! !
!String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 20:07:05' prior: 16947550!
                    >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString <= self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) >= 2! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5241-String-Utf8String-Comparisons-JuanVuletich-2022Jun08-11h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5240] on 7 June 2022 at 4:47:19 pm'!
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/7/2022 16:43:43'!
                               sameAs: aString 
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	^ ('' compare: bytes with: aString asUtf8Bytes) = 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/7/2022 16:44:05' prior: 16947823!
              sameAs: aString 
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString sameAs: self ].

	^ (self compare: self with: aString collated: CaseInsensitiveOrder) = 2! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5242-String-Utf8String-Comparisons-JuanVuletich-2022Jun07-16h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 12:03:47 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'ST-80 5/31/1983 9:10:35'!
                         string
	"Answer the receiver itself.  This is for compatibility with other text classes."
	^self! !
!CharacterSequence methodsFor: 'converting' stamp: 'ST-80 5/31/1983 9:10:35'!
              asSymbol
	"Answer the unique symbol whose characters are the characters of the string."
	^Symbol intern: self! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 11:52:25'!
   asUtf32String
	"Answer an instance of the UTF-32 encoded String class"

	^Utf32String fromUtf8Bytes: self asUtf8Bytes.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 11:53:21'!
                          asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	^Utf8String fromUtf8Bytes: self asUtf8Bytes! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/7/2014 22:05' overrides: 16902848!
             displayStringOrText
	"To be used in the UI"
	"Answer this string."

	^ self
! !
!CharacterSequence methodsFor: 'printing' stamp: 'jmv 3/13/2012 12:48' overrides: 16902957!
                    print
	Transcript show: self; newLine! !
!CharacterSequence methodsFor: 'printing' stamp: 'sma 6/1/2000 09:48' overrides: 16823635!
                            printOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."

	self storeOn: aStream! !
!CharacterSequence methodsFor: 'printing' stamp: 'Squeak1.0 9/20/1996 10:50:05' overrides: 16823643!
                     storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do:
		[:i |
		aStream nextPut: (x _ self at: i).
		x = $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'! !
!Utf8Symbol methodsFor: 'printing' stamp: 'jmv 6/8/2022 11:58:13' overrides: 50365641!
                               print
	Transcript show: self printString; newLine! !
!Utf8Symbol methodsFor: 'printing' stamp: 'jmv 6/8/2022 12:02:18' overrides: 50365652!
                    storeOn: aStream 

	aStream nextPut: $#.
	(Scanner isLiteralSymbol: self)
		ifTrue: [aStream nextPutAll: self]
		ifFalse: [super storeOn: aStream]! !

Utf8String removeSelector: #displayStringOrText!

!methodRemoval: Utf8String #displayStringOrText stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
displayStringOrText
	"To be used in the UI"
	"Answer the receiver itself."

	^self!

Utf8String removeSelector: #storeOn:!

!methodRemoval: Utf8String #storeOn: stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do: [ :i |
		aStream nextPut: (x _ self at: i).
		x = $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'!

Utf8String removeSelector: #asSymbol!

!methodRemoval: Utf8String #asSymbol stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
asSymbol
	"Answer the unique symbol whose characters are the characters of the string."
	^Symbol intern: self!

Utf8String removeSelector: #asUtf32String!

!methodRemoval: Utf8String #asUtf32String stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
asUtf32String
	"Answer an instance of the UTF-32 encoded String class"

	^Utf32String fromUtf8Bytes: self asUtf8Bytes!

Utf8String removeSelector: #print!

!methodRemoval: Utf8String #print stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
print
	Transcript show: self; newLine!

Utf8String removeSelector: #string!

!methodRemoval: Utf8String #string stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
string
	"Answer the receiver itself.  This is for compatibility with other text classes."
	^self!

Utf8String removeSelector: #printOn:!

!methodRemoval: Utf8String #printOn: stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
printOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."

	self storeOn: aStream!

Utf32String removeSelector: #asUtf8String!

!methodRemoval: Utf32String #asUtf8String stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	^Utf8String fromUtf8Bytes: self asUtf8Bytes!

String removeSelector: #displayStringOrText!

!methodRemoval: String #displayStringOrText stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
displayStringOrText
	"To be used in the UI"
	"Answer this string."

	^ self
!

String removeSelector: #storeOn:!

!methodRemoval: String #storeOn: stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do: [ :i |
		aStream nextPut: (x _ self at: i).
		x = $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'!

String removeSelector: #asSymbol!

!methodRemoval: String #asSymbol stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
asSymbol
	"Answer the unique symbol whose characters are the characters of the string."
	^Symbol intern: self!

String removeSelector: #asUtf32String!

!methodRemoval: String #asUtf32String stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
asUtf32String
	"Answer an instance of the UTF-32 encoded String class"

	^Utf32String fromUtf8Bytes: self asUtf8Bytes!

String removeSelector: #print!

!methodRemoval: String #print stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
print
	Transcript show: self; newLine!

String removeSelector: #string!

!methodRemoval: String #string stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
string
	"Answer the receiver itself.  This is for compatibility with other text classes."
	^self!

String removeSelector: #asUtf8String!

!methodRemoval: String #asUtf8String stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	^Utf8String fromUtf8Bytes: self asUtf8Bytes!

String removeSelector: #printOn:!

!methodRemoval: String #printOn: stamp: 'Install-5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st 6/16/2022 07:24:52'!
printOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."

	self storeOn: aStream!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5243-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-11h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 12:04:50 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5244-MethodCategories-JuanVuletich-2022Jun08-12h03m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 12:26:23 pm'!
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/6/2022 17:16:35'!
                           canBeGlobalVarInitial
	^self isUppercase! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/6/2022 17:16:54'!
            isUppercase
	"Answer whether the receiver is an uppercase letter."
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isUppercase ].
	^false! !
!CharacterSequence methodsFor: 'accessing' stamp: 'sw 8/12/97 12:37'!
                includesSubString: subString
	^ (self findString: subString startingAt: 1) > 0! !
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 2/22/2013 07:41' overrides: 16935095!
                 beginsWith: prefix
	"Answer whether the receiver begins with the given prefix string.
	The comparison is case-sensitive."

	^self is: prefix substringAt: 1! !
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 2/22/2013 07:41' overrides: 16935107!
    endsWith: suffix
	"Answer whether the tail end of the receiver is the same as suffix.
	The comparison is case-sensitive."

	^self is: suffix substringAt: self size - suffix size + 1
"
  'Elvis' endsWith: 'vis'
  'Elvis' asUtf8String endsWith: 'vis'
  'Elvis' endsWith: 'vis' asUtf8String
"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:10'!
               afterBlanksEndsWith: aTail

	^(self endsWith: aTail) and: [ self firstNonSeparator = (self size - aTail size + 1) ]
! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:43:55'!
                           asLowercase
	"Answer a String made up from the receiver whose characters are all 
	lowercase."

	^ self copy asPlainString translateToLowercase! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:06'!
 firstNonSeparator

	^self findFirst: [:aChar | aChar isSeparator not ]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:54'!
          lastNonSeparator

	^ self findLast: [:aChar | aChar isSeparator not].
	! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:59'!
         withBlanksTrimmed
	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."

	| first |
	
	first _ self firstNonSeparator.
	first = 0 ifTrue: [^ ''].  "no non-separator character"
	
	^ self copyFrom: first to: self lastNonSeparator 

	" ' abc  d   ' withBlanksTrimmed"
! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/6/2022 15:36:16'!
  withoutLeadingBlanks
	
	"Return a copy of the receiver from which leading blanks have been trimmed."
	
	| first |
	
	first := self firstNonSeparator.
	first = 0 ifTrue: [^ ''].  
	first = 1 ifTrue: [^ self ].
	
	"no non-separator character"	
	^ self copyFrom: first to: self size
		
	" '    abc  d  ' withoutLeadingBlanks"
! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 14:54:20'!
                     findString: subString startingAt: start 
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	^ '' findString: subString asUtf8Bytes in: bytes startingAt: start! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 15:26:19'!
          findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

"caseSensitive = false is very expensive. Do better."

	^caseSensitive
		ifTrue: [ self findString: key startingAt: start ]
		ifFalse: [ self asLowercase findString: key asLowercase startingAt: start ]! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/6/2022 15:06:02' overrides: 16933739!
    indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| ndex |
	ndex _ '' findString: subString asUtf8Bytes in: bytes startingAt: start.
	ndex = 0 ifTrue: [^ exceptionBlock value].
	^ ndex! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/6/2022 15:05:05'!
      is: subString substringAt: ndex
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."
	| sequenceSize subStringBytes |
	ndex < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - ndex + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	subStringBytes _ subString asUtf8Bytes.
	(bytes at: ndex) = (subStringBytes at: 1) ifFalse: [ ^false ].
	^('' findString: subStringBytes in: bytes startingAt: ndex) = ndex! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/6/2022 15:47:19'!
       isInitializePvtSelector
	"Answer whether the receiver is a private instance initialization message selector, that is,
	begins with 'initializePvt' (followed or not by additional stuff, as a unary message, or as keyword with arguments)"

	^ bytes beginsWith: `'initializePvt' asUtf8Bytes`! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/6/2022 15:46:51'!
                           isPvtSelector
	"Answer whether the receiver is a private message selector, that is,
	begins with 'pvt' followed by an uppercase letter, e.g. pvtStringhash."

	^ (bytes beginsWith: `'pvt' asUtf8Bytes` ) and: [bytes size >= 4 and: [(self at: 4) isUppercase]]! !
!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:43' prior: 50348758!
              findString: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseSensitiveOrder.! !
!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:43' prior: 16947222!
findString: subString startingAt: start 
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	subString isByteString ifFalse: [ ^self asUtf8String findString: subString startingAt: start ].
	^ self findString: subString in: self startingAt: start! !
!String methodsFor: 'accessing' stamp: 'di 11/15/1998 17:02' prior: 16947366 overrides: 16933739!
                      indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isByteString ifFalse: [ ^self asUtf8String indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index _ self findString: subString in: self startingAt: start.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!String methodsFor: 'comparing' stamp: 'len 11/15/2015 04:23' prior: 16947764!
                              is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."
	| sequenceSize |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	subString isByteString ifFalse: [ ^self asUtf8String is: subString substringAt: index ].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	(self basicAt: index) = (subString basicAt: 1) ifFalse: [ ^false ].
	^(self findString: subString in: self startingAt: index) = index! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 6/6/2022 17:06:41' prior: 50366013!
            nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(aString canHoldCodePoints and: [collection canHoldCodePoints not]) ifTrue: [
		collection _ collection thatCanHoldCodePoints ].
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !
!DifferenceFinder class methodsFor: 'compatibility' stamp: 'jmv 6/1/2022 11:24:19' prior: 50367219!
              wordsDisplayPatchFrom: srcString to: dstString
	| finder answer src1 dst1 changedCount |

	srcString class == dstString class ifFalse: [
		^self wordsDisplayPatchFrom: srcString asUtf8String to: dstString asUtf8String ].

	finder _ self base: srcString case: dstString.
	finder compareLines; compute.
	answer _ srcString class new asText.
	src1 _ srcString class writeStream.
	dst1 _ srcString class writeStream.
	changedCount _ 0.
	finder differences sort first do: [:item :condition |
		condition caseOf: {
			[ #unchanged ] -> [
				changedCount > 0 ifTrue: [
					"If the sequence of changed lines is large, comparing words gets too slow and less useful"
					changedCount > 30 ifTrue: [
						^nil ].
					"Compare the just ended sequence of changed lines"
					finder base: src1 contents case: dst1 contents.
					finder compareWords; compute: true.
					finder differences ifNil: [ ^nil ].
					answer _ answer append:  finder differences anyOne asText.
					src1 resetToStart.
					dst1 resetToStart.
					changedCount _ 0.
				].
				"This line hasn't changed. Just add it to the result in plain text."
				answer append: item ].
			[ #removed ] -> [
				"A removed line belongs in the source"
				src1 nextPutAll: item.
				changedCount _ changedCount + 1 ].
			[ #inserted ] -> [
				"An added line belongs in the destination"
				dst1 nextPutAll: item.
				changedCount _ changedCount + 1  ].
			}.
		].
	"If the sequence of changed lines is large, comparing words gets too slow and less useful"
	changedCount > 30 ifTrue: [
		^nil ].
	finder base: src1 contents case: dst1 contents.
	finder compareWords; compute: true.
	finder differences ifNil: [ ^nil ].
	answer _ answer append: finder differences anyOne asText.

	^answer! !

String removeSelector: #lastNonSeparator!

!methodRemoval: String #lastNonSeparator stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
lastNonSeparator

	^ self findLast: [:aChar | aChar isSeparator not].
	!

String removeSelector: #withoutLeadingBlanks!

!methodRemoval: String #withoutLeadingBlanks stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
withoutLeadingBlanks
	
	"Return a copy of the receiver from which leading blanks have been trimmed."
	
	| first |
	
	first := self firstNonSeparator.
	first = 0 ifTrue: [^ ''].  
	first = 1 ifTrue: [^ self ].
	
	"no non-separator character"	
	^ self copyFrom: first to: self size
		
	" '    abc  d  ' withoutLeadingBlanks"
!

String removeSelector: #includesSubString:!

!methodRemoval: String #includesSubString: stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
includesSubString: subString
	^ (self findString: subString startingAt: 1) > 0!

String removeSelector: #afterBlanksEndsWith:!

!methodRemoval: String #afterBlanksEndsWith: stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
afterBlanksEndsWith: aTail

	^(self endsWith: aTail) and: [ self firstNonSeparator = (self size - aTail size + 1) ]
!

String removeSelector: #endsWith:!

!methodRemoval: String #endsWith: stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
endsWith: suffix
	"Answer whether the tail end of the receiver is the same as suffix.
	The comparison is case-sensitive."

	^self is: suffix substringAt: self size - suffix size + 1
"
  'Elvis' endsWith: 'vis'
"!

String removeSelector: #withBlanksTrimmed!

!methodRemoval: String #withBlanksTrimmed stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
withBlanksTrimmed
	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."

	| first |
	
	first _ self firstNonSeparator.
	first = 0 ifTrue: [^ ''].  "no non-separator character"
	
	^ self copyFrom: first to: self lastNonSeparator 

	" ' abc  d   ' withBlanksTrimmed"
!

String removeSelector: #firstNonSeparator!

!methodRemoval: String #firstNonSeparator stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
firstNonSeparator

	^self findFirst: [:aChar | aChar isSeparator not ]!

String removeSelector: #asLowercase!

!methodRemoval: String #asLowercase stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
asLowercase
	"Answer a String made up from the receiver whose characters are all 
	lowercase."

	^ self copy asPlainString translateToLowercase!

String removeSelector: #beginsWith:!

!methodRemoval: String #beginsWith: stamp: 'Install-5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st 6/16/2022 07:24:52'!
beginsWith: prefix
	"Answer whether the receiver begins with the given prefix string.
	The comparison is case-sensitive."

	^self is: prefix substringAt: 1!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5245-UnicodeClasses-Compatibility-JuanVuletich-2022Jun08-12h04m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 1:29:47 pm'!
!UnicodeCodePoint methodsFor: 'fileman-testing' stamp: 'jmv 6/7/2022 20:47:28'!
    isDriveLetter
	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' includes: self! !
!UnicodeCodePoint methodsFor: 'fileman-testing' stamp: 'jmv 6/7/2022 20:46:31'!
                       isDriveSeparator
	^self = $:! !
!UnicodeCodePoint methodsFor: 'fileman-testing' stamp: 'jmv 6/7/2022 20:46:25'!
                isPathSeparator
	self = $\ ifTrue: [^true].
	self = $: ifTrue: [^true].
	self = $/ ifTrue: [^true].
	^false! !
!CharacterSequence methodsFor: 'accessing' stamp: 'Squeak1.0 9/20/1996 10:50:05'!
                               findDelimiters: delimiters startingAt: start
	"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1."

	start to: self size do: [:i |
		delimiters do: [:delim | delim = (self at: i) ifTrue: [^ i]]].
	^ self size + 1! !
!CharacterSequence methodsFor: 'accessing' stamp: 'tk 8/10/2000 09:14'!
                            findTokens: delimiters
	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."

	| tokens keyStart keyStop separators |

	tokens _ OrderedCollection new.
	separators _ delimiters isCharacter
		ifTrue: [Array with: delimiters]
		ifFalse: [delimiters].
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: separators startingAt: keyStop.
		keyStop _ self findDelimiters: separators startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!CharacterSequence methodsFor: 'accessing' stamp: 'Squeak1.2 6/29/1997 10:40:55'!
                 skipDelimiters: delimiters startingAt: start
	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."

	start to: self size do: [:i |
		delimiters detect: [:delim | delim = (self at: i)]
				ifNone: [^ i]].
	^ self size + 1! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'mu 3/4/2007 11:04'!
                   asPathComponents

	| tokens |
	self isRelativePathName ifTrue: [self error: 'relative form is invaild!!'].
	tokens _ self asPathTokens.
	^tokens! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 6/6/2015 23:56'!
                           asPathTokens

	^self beginsWithWindowsDriveName
		ifTrue: [
			(OrderedCollection with: (self copyFrom: 1 to: 2)), 
				((self copyFrom: 3 to: self size) findTokens: String pathSeparators) ]
		ifFalse: [
			self findTokens: String pathSeparators ]! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'jmv 9/17/2015 10:36'!
                      beginsWithWindowsDriveName
	"Answer doesn't depend on running on Windows or not"
	self size < 2 ifTrue: [ ^false ].
	^self first isDriveLetter
		and: [ self second isDriveSeparator
			and: [ self size = 2 or: [ self third isPathSeparator ]]]! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'mu 3/2/2007 22:05'!
                              isPathSeparator
	self = '\' ifTrue: [^true].
	self = ':' ifTrue: [^true].
	self = '/' ifTrue: [^true].
	^false! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'mu 6/11/2006 22:41'!
isRelativeMark

	self = '.' ifTrue: [^true].
	self = '..' ifTrue: [^true].

	^false! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'mu 3/4/2007 10:46'!
                            isRelativePathName
	self ifEmpty: [^false].
	self isRelativeMark ifTrue: [^true].
	^#('.' '..') includes: self upToFirstPathSeparator! !
!CharacterSequence methodsFor: 'fileman-accessing' stamp: 'jmv 4/2/2016 23:07'!
       indexOfFirstPathSeparator
	self
		withIndexDo: [:each :idx | each isPathSeparator
				ifTrue: [^ idx]].
	^ 0! !
!CharacterSequence methodsFor: 'fileman-accessing' stamp: 'mu 3/4/2007 10:45'!
 upToFirstPathSeparator
	| index |
	self ifEmpty: [^self].
	index _ self indexOfFirstPathSeparator.
	index = 0 ifTrue: [^self].
	^self copyFrom: 1 to: index - 1! !
!String methodsFor: 'converting' stamp: 'jmv 6/7/2022 20:26:14'!
                            substrings: aString
	"Answer an array of the substrings that compose the receiver."
	| end beginning |
	end _ 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning _ aString indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end _ aString indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ aString size + 1 ].
			end _ end - 1.
			result nextPut: (aString copyFrom: beginning to: end).
		]
	].! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/7/2022 20:34:31'!
                         substrings
	"
	'  Hello World!! Some  		1234 more  ' substrings
	'  Hello World!! Some  		1234 more  ' asUtf8String substrings
	"
	^ ('' substrings: bytes) collect: [ :eachBytes | Utf8String withBytes: eachBytes ].! !
!ByteArray methodsFor: 'accessing' stamp: 'jmv 6/7/2022 20:33:24'!
   indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer _ String findFirstInString: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]! !
!String methodsFor: 'converting' stamp: 'jmv 6/7/2022 20:26:38' prior: 16948610!
                substrings
	"Answer an array of the substrings that compose the receiver."
	^self substrings: self! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 12:35:38' prior: 50368858!
                        withBytes: aByteArray

	^self basicNew bytes: aByteArray ! !
!DifferenceFinder class methodsFor: 'compatibility' stamp: 'jmv 6/8/2022 13:17:15' prior: 50375594!
                               wordsDisplayPatchFrom: srcStringOrText to: dstStringOrText

	| finder answer src1 dst1 changedCount dstString srcString |
	srcString _ srcStringOrText asPlainString.
	dstString _ dstStringOrText asPlainString.
	srcString class == dstString class ifFalse: [
		^self wordsDisplayPatchFrom: srcString asUtf8String to: dstString asUtf8String ].

	finder _ self base: srcString case: dstString.
	finder compareLines; compute.
	answer _ srcString class new asText.
	src1 _ srcString class writeStream.
	dst1 _ srcString class writeStream.
	changedCount _ 0.
	finder differences sort first do: [:item :condition |
		condition caseOf: {
			[ #unchanged ] -> [
				changedCount > 0 ifTrue: [
					"If the sequence of changed lines is large, comparing words gets too slow and less useful"
					changedCount > 30 ifTrue: [
						^nil ].
					"Compare the just ended sequence of changed lines"
					finder base: src1 contents case: dst1 contents.
					finder compareWords; compute: true.
					finder differences ifNil: [ ^nil ].
					answer _ answer append:  finder differences anyOne asText.
					src1 resetToStart.
					dst1 resetToStart.
					changedCount _ 0.
				].
				"This line hasn't changed. Just add it to the result in plain text."
				answer append: item ].
			[ #removed ] -> [
				"A removed line belongs in the source"
				src1 nextPutAll: item.
				changedCount _ changedCount + 1 ].
			[ #inserted ] -> [
				"An added line belongs in the destination"
				dst1 nextPutAll: item.
				changedCount _ changedCount + 1  ].
			}.
		].
	"If the sequence of changed lines is large, comparing words gets too slow and less useful"
	changedCount > 30 ifTrue: [
		^nil ].
	finder base: src1 contents case: dst1 contents.
	finder compareWords; compute: true.
	finder differences ifNil: [ ^nil ].
	answer _ answer append: finder differences anyOne asText.

	^answer! !

String removeSelector: #asPathComponents!

!methodRemoval: String #asPathComponents stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
asPathComponents
	| tokens |

	self isRelativePathName ifTrue: [self error: 'relative form is invaild!!'].

	tokens := self asPathTokens.
	^tokens!

String removeSelector: #indexOfFirstPathSeparator!

!methodRemoval: String #indexOfFirstPathSeparator stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
indexOfFirstPathSeparator
	self
		withIndexDo: [:each :idx | each isPathSeparator
				ifTrue: [^ idx]].
	^ 0!

String removeSelector: #isRelativeMark!

!methodRemoval: String #isRelativeMark stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
isRelativeMark
	
	self = '.' ifTrue: [^true].
	self = '..' ifTrue: [^true].

	^false!

String removeSelector: #skipDelimiters:startingAt:!

!methodRemoval: String #skipDelimiters:startingAt: stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
skipDelimiters: delimiters startingAt: start 
	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."

	start to: self size do: [:i |
		delimiters detect: [:delim | delim = (self at: i)]
				ifNone: [^ i]].
	^ self size + 1!

String removeSelector: #asPathTokens!

!methodRemoval: String #asPathTokens stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
asPathTokens

	^self beginsWithWindowsDriveName
		ifTrue: [
			(OrderedCollection with: (self copyFrom: 1 to: 2)), 
				((self copyFrom: 3 to: self size) findTokens: String pathSeparators) ]
		ifFalse: [
			self findTokens: String pathSeparators ]!

String removeSelector: #beginsWithWindowsDriveName!

!methodRemoval: String #beginsWithWindowsDriveName stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
beginsWithWindowsDriveName
	"Answer doesn't depend on running on Windows or not"
	self size < 2 ifTrue: [ ^false ].
	^self first isDriveLetter
		and: [ self second isDriveSeparator
			and: [ self size = 2 or: [ self third isPathSeparator ]]]!

String removeSelector: #isRelativePathName!

!methodRemoval: String #isRelativePathName stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
isRelativePathName
	self ifEmpty: [^false].
	self isRelativeMark ifTrue: [^true].
	^#('.' '..') includes: self upToFirstPathSeparator !

String removeSelector: #upToFirstPathSeparator!

!methodRemoval: String #upToFirstPathSeparator stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
upToFirstPathSeparator
	| index |
	self ifEmpty: [^self].
	index := self indexOfFirstPathSeparator.
	index = 0 ifTrue: [^self].
	^self copyFrom: 1 to: index - 1
	!

String removeSelector: #findTokens:!

!methodRemoval: String #findTokens: stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
findTokens: delimiters
	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."

	| tokens keyStart keyStop separators |

	tokens _ OrderedCollection new.
	separators _ delimiters isCharacter
		ifTrue: [Array with: delimiters]
		ifFalse: [delimiters].
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: separators startingAt: keyStop.
		keyStop _ self findDelimiters: separators startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens!

String removeSelector: #isPathSeparator!

!methodRemoval: String #isPathSeparator stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
isPathSeparator
	self = '\' ifTrue: [^true].
	self = ':' ifTrue: [^true].
	self = '/' ifTrue: [^true].
	^false!

String removeSelector: #findDelimiters:startingAt:!

!methodRemoval: String #findDelimiters:startingAt: stamp: 'Install-5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st 6/16/2022 07:24:52'!
findDelimiters: delimiters startingAt: start 
	"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1."

	start to: self size do: [:i |
		delimiters do: [:delim | delim = (self at: i) ifTrue: [^ i]]].
	^ self size + 1!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5246-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-12h26m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 1:33:38 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 13:32:02'!
         findSelector
	"Revised to use scanner for better removal of extraneous stuff"
	| potentialSelector colonIndex |
	potentialSelector _ self withBlanksTrimmed withoutEnclosing: $".
	colonIndex _ potentialSelector indexOf: $:.
	"possible keyword selector"
	(colonIndex > 1 and: [ (potentialSelector at: colonIndex - 1) isValidInIdentifiers ]) ifTrue: [
		potentialSelector _ [ Scanner findSelectorIn: potentialSelector ] on: Error do: [ :anError | 
			anError messageText = Scanner unmatechedCommentQuoteErrorDescription 
				ifTrue: [ 
					potentialSelector _ potentialSelector copyWithout: $".
					anError retry ]
				ifFalse: [ anError return: '']]].
		
	potentialSelector isEmpty ifTrue: [ ^ nil ].
	Symbol
		hasInterned: potentialSelector
		ifTrue: [ :aSymbol | ^ aSymbol ].
		
	^ nil.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 13:32:51'!
                            withoutEnclosing: aCharacter
	"
	'*Hello*' withoutEnclosing: $*
	'*Hello*' asUtf8String withoutEnclosing: $*
	"
	| s |
	s _ self size.
	s = 0 ifTrue: [ ^ self ].
	^((self at: 1) = aCharacter and: [ (self at: s) = aCharacter ])
		ifTrue: [ self copyFrom: 2 to: s-1 ]
		ifFalse: [ self ]! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 6/8/2022 13:33:10'!
           asFileEntry
	"

Windows	
	'C:\Windows' asFileEntry exists false
	'C:\Windows' asDirectoryEntry exists true
	'/' asFileEntry exists false
	'/' asDirectoryEntry exists false
	'C:\' asFileEntry exists false
	'C:\' asDirectoryEntry exists true
	('C:' asDirectoryEntry // 'Windows') exists false
	('C:' asDirectoryEntry / 'Windows') exists true
	
Linux
    '/var' asFileEntry exists
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists true
    '/media/cdrom' asFileEntry exists false
    '/media/cdrom' asDirectoryEntry exists true
    ('/bin' asDirectoryEntry / 'more') exists false
    ('/bin' asDirectoryEntry // 'more') exists true

MacOsX
    '/var' asFileEntry exists false
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists  true
    '/Volumes/SanDisk32-NTFS' asFileEntry exists false
    '/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
    'SanDisk32-NTFS' asFileEntry exists false
    'SanDisk32-NTFS' asDirectoryEntry exists false
	
	"
	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^FileEntry withPathName: self! !

String removeSelector: #findSelector!

!methodRemoval: String #findSelector stamp: 'Install-5247-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h30m-jmv.001.cs.st 6/16/2022 07:24:52'!
findSelector
	"Revised to use scanner for better removal of extraneous stuff"
	| potentialSelector colonIndex |
	potentialSelector _ self withBlanksTrimmed withoutEnclosing: $".
	colonIndex _ potentialSelector indexOf: $:.
	"possible keyword selector"
	(colonIndex > 1 and: [ (potentialSelector at: colonIndex - 1) isValidInIdentifiers ]) ifTrue: [
		potentialSelector _ [ Scanner findSelectorIn: potentialSelector ] on: Error do: [ :anError | 
			anError messageText = Scanner unmatechedCommentQuoteErrorDescription 
				ifTrue: [ 
					potentialSelector _ potentialSelector copyWithout: $".
					anError retry ]
				ifFalse: [ anError return: '']]].
		
	potentialSelector isEmpty ifTrue: [ ^ nil ].
	Symbol
		hasInterned: potentialSelector
		ifTrue: [ :aSymbol | ^ aSymbol ].
		
	^ nil.!

String removeSelector: #withoutEnclosing:!

!methodRemoval: String #withoutEnclosing: stamp: 'Install-5247-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h30m-jmv.001.cs.st 6/16/2022 07:24:52'!
withoutEnclosing: aCharacter
	"
	'*Hello*' withoutEnclosing: $*
	"
	| s |
	s _ self size.
	s = 0 ifTrue: [ ^ self ].
	^((self at: 1) = aCharacter and: [ (self at: s) = aCharacter ])
		ifTrue: [ self copyFrom: 2 to: s-1 ]
		ifFalse: [ self ]!

String removeSelector: #asFileEntry!

!methodRemoval: String #asFileEntry stamp: 'Install-5247-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h30m-jmv.001.cs.st 6/16/2022 07:24:52'!
asFileEntry
	"

Windows	
	'C:\Windows' asFileEntry exists false
	'C:\Windows' asDirectoryEntry exists true
	'/' asFileEntry exists false
	'/' asDirectoryEntry exists false
	'C:\' asFileEntry exists false
	'C:\' asDirectoryEntry exists true
	('C:' asDirectoryEntry // 'Windows') exists false
	('C:' asDirectoryEntry / 'Windows') exists true
	
Linux
    '/var' asFileEntry exists
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists true
    '/media/cdrom' asFileEntry exists false
    '/media/cdrom' asDirectoryEntry exists true
    ('/bin' asDirectoryEntry / 'more') exists false
    ('/bin' asDirectoryEntry // 'more') exists true

MacOsX
    '/var' asFileEntry exists false
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists  true
    '/Volumes/SanDisk32-NTFS' asFileEntry exists false
    '/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
    'SanDisk32-NTFS' asFileEntry exists false
    'SanDisk32-NTFS' asDirectoryEntry exists false
	
	"
	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^FileEntry withPathName: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5247-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h30m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5238] on 8 June 2022 at 2:37:55 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 3/13/2012 22:06'!
                  lineCount
	"Answer the number of lines represented by the receiver, where every cr adds one line.  5/10/96 sw"


	| i |
	i _ 0.
	self lineIndicesDo: [ :start :endWithoutDelimiters :end |
		i _ i + 1 ].
	^i

"
'Fred
the
Bear' lineCount
"! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 3/13/2012 22:05'!
       lineNumber: anIndex
	"Answer a string containing the characters in the given line number. "
	| i |
	i _ 1.
	self lineIndicesDo: [ :start :endWithoutDelimiters :end |
		i = anIndex ifTrue: [
			^ self copyFrom: start to: endWithoutDelimiters ].
		i _ i + 1 ].
	^nil
	
"
'Fred
the
Bear' lineNumber: 3
".! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 3/13/2012 22:08'!
      linesDo: aBlock
	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"
	
	self lineIndicesDo: [ :start :endWithoutDelimiters :end |
		aBlock value: (self copyFrom: start  to: endWithoutDelimiters) ]
		! !
!String methodsFor: 'accessing' stamp: 'jmv 6/7/2022 22:27:42'!
                      string: aString lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| start end endWithoutDelimiters |
	start _ 1.
	[
		end _ aString indexOfAnyOf: CSLineEnders startingAt: start ifAbsent: [ 0 ].
		end = 0
			ifTrue: [
				"Last line was found. Evaluate and exit.
				Note. If last char in receiver is a line separator, there's an extra empty line"
				endWithoutDelimiters _ end _ aString size.
				aBlock value: start value: endWithoutDelimiters value: end.
				^aString ].

		"Account for CrLf sequence"
		endWithoutDelimiters _ end - 1.
		(end < aString size
			and: [(aString basicAt: end + 1) = `Character lf codePoint`
			and: [(aString basicAt: end) = `Character cr codePoint` ]])
				ifTrue: [ end _ end + 1].

		aBlock value: start value: endWithoutDelimiters value: end.
		start _ end + 1 ] repeat! !
!String methodsFor: 'converting' stamp: 'jmv 6/7/2022 22:24:58'!
                         string: aString withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"
	| cr lf crlf inPos outPos outString lineEndPos newOutPos lineEndingSize |
	cr _ Character cr.
	lf _ Character lf.
	crlf _ CharacterSet new.
	crlf add: cr; add: lf.

	inPos _ 1.
	outPos _ 1.
	lineEndingSize _ lineEndingString size.
	"This could be extremely inefficient if lineEndingString size > 1"
	outString _ aString class new: aString size * lineEndingSize.

	[
		lineEndPos _ aString indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].
		lineEndPos ~= 0 ] whileTrue: [
			newOutPos _ outPos + (lineEndPos - inPos).
			outString replaceFrom: outPos to: newOutPos - 1 with: aString startingAt: inPos.
			1 to: lineEndingSize do: [ :i |
				outString at: newOutPos put: (lineEndingString at: i).
				newOutPos _ newOutPos + 1 ].
			outPos _ newOutPos.
			((aString at: lineEndPos) = cr and: [ lineEndPos < aString size and: [ (aString at: lineEndPos+1) = lf ] ]) ifTrue: [
				"CRLF ending"
				inPos _ lineEndPos + 2 ]
			ifFalse: [ 
				"CR or LF ending"
				inPos _ lineEndPos + 1 ]. ].

	"no more line endings.  copy the rest"
	newOutPos _ outPos + (aString size - inPos).
	outString replaceFrom: outPos to: newOutPos with: aString startingAt: inPos.

	^outString copyFrom: 1 to: newOutPos! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/8/2022 14:37:30'!
                lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"

	'' string: bytes lineIndicesDo: [ :startByte :endByteWithoutDelimiters :endByte |
		| start end endWithoutDelimiters |
		start _ self codePointIndexAt: startByte.
		end _ self codePointIndexAt: endByte.
		endWithoutDelimiters _ endByteWithoutDelimiters = endByte
			ifTrue: [end]
			ifFalse: [self codePointIndexAt: endByteWithoutDelimiters].
		aBlock
			value: start
			value: endWithoutDelimiters
			value: end
		]! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/7/2022 22:07:54' overrides: 16934268!
                         copyWith: anUnicodeCodePoint

	^Utf8String withBytes:
		bytes, (Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint).! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/8/2022 13:44:41'!
                  withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"

	^  Utf8String withBytes:  ('' string: bytes withLineEndings: lineEndingString).! !
!String methodsFor: 'accessing' stamp: 'jmv 6/8/2022 13:47:52' prior: 16947386!
               lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"

	self string: self lineIndicesDo: aBlock! !
!String methodsFor: 'converting' stamp: 'jmv 6/7/2022 22:21:30' prior: 50375898!
                       substrings: aString
	"Answer an array of the substrings that compose the argument."
	| end beginning |
	end _ 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning _ aString indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end _ aString indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ aString size + 1 ].
			end _ end - 1.
			result nextPut: (aString copyFrom: beginning to: end).
		]
	].! !
!String methodsFor: 'converting' stamp: 'jmv 6/8/2022 13:46:18' prior: 16948745!
             withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"

	^ self string: self withLineEndings: lineEndingString! !

String removeSelector: #lineNumber:!

!methodRemoval: String #lineNumber: stamp: 'Install-5248-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h33m-jmv.002.cs.st 6/16/2022 07:24:52'!
lineNumber: anIndex
	"Answer a string containing the characters in the given line number. "
	| i |
	i _ 1.
	self lineIndicesDo: [ :start :endWithoutDelimiters :end |
		i = anIndex ifTrue: [
			^ self copyFrom: start to: endWithoutDelimiters ].
		i _ i + 1 ].
	^nil
	
"
'Fred
the
Bear' lineNumber: 3
".!

String removeSelector: #lineCount!

!methodRemoval: String #lineCount stamp: 'Install-5248-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h33m-jmv.002.cs.st 6/16/2022 07:24:52'!
lineCount
	"Answer the number of lines represented by the receiver, where every cr adds one line.  5/10/96 sw"


	| i |
	i _ 0.
	self lineIndicesDo: [ :start :endWithoutDelimiters :end |
		i _ i + 1 ].
	^i

"
'Fred
the
Bear' lineCount
"!

String removeSelector: #linesDo:!

!methodRemoval: String #linesDo: stamp: 'Install-5248-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h33m-jmv.002.cs.st 6/16/2022 07:24:52'!
linesDo: aBlock
	"execute aBlock with each line in this string.  The terminating CR's are not included in what is passed to aBlock"
	
	self lineIndicesDo: [ :start :endWithoutDelimiters :end |
		aBlock value: (self copyFrom: start  to: endWithoutDelimiters) ]
		!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5248-CharacterSequence-commonMethods-JuanVuletich-2022Jun08-13h33m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5212] on 31 May 2022 at 4:35:01 pm'!

Object subclass: #EncodedStreamReadAdaptor
	instanceVariableNames: 'stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #EncodedStreamReadAdaptor category: #'Collections-Streams' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
Object subclass: #EncodedStreamReadAdaptor
	instanceVariableNames: 'stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

EncodedStreamReadAdaptor subclass: #BytesEncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #BytesEncodedStreamReadAdaptor category: #'Collections-Streams' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
EncodedStreamReadAdaptor subclass: #BytesEncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

EncodedStreamReadAdaptor subclass: #StringEncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #StringEncodedStreamReadAdaptor category: #'Collections-Streams' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
EncodedStreamReadAdaptor subclass: #StringEncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

EncodedStreamReadAdaptor subclass: #Utf32EncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #Utf32EncodedStreamReadAdaptor category: #'Collections-Streams' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
EncodedStreamReadAdaptor subclass: #Utf32EncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

EncodedStreamReadAdaptor subclass: #Utf8EncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #Utf8EncodedStreamReadAdaptor category: #'Collections-Streams' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
EncodedStreamReadAdaptor subclass: #Utf8EncodedStreamReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

ReadStream subclass: #EncodedReadStream
	instanceVariableNames: 'readAdaptor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #EncodedReadStream category: #'Collections-Streams' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
ReadStream subclass: #EncodedReadStream
	instanceVariableNames: 'readAdaptor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

WriteStream subclass: #EncodedWriteStream
	instanceVariableNames: 'lastWrittenElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #EncodedWriteStream category: #'Collections-Streams' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
WriteStream subclass: #EncodedWriteStream
	instanceVariableNames: 'lastWrittenElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

ReadWriteStream subclass: #EncodedFileStream
	instanceVariableNames: 'rwmode name fileID buffer1 readAdaptor lastWrittenElement'
	classVariableNames: 'Registry'
	poolDictionaries: ''
	category: 'System-Files'!

!classDefinition: #EncodedFileStream category: #'System-Files' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
ReadWriteStream subclass: #EncodedFileStream
	instanceVariableNames: 'rwmode name fileID buffer1 readAdaptor lastWrittenElement'
	classVariableNames: 'Registry'
	poolDictionaries: ''
	category: 'System-Files'!
!EncodedFileStream commentStamp: '<historical>' prior: 0!
      A new FileStream for Cuis.

Writes bytes. Binary content is stored verbatim. String is stored in UTF-8, but invalid UTF-8 sequences are interpreted as Cuis Characters (i.e. ISO-8859-15).!

TestCase subclass: #EncodedByteArrayStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #EncodedByteArrayStreamTest category: #'Tools-Testing' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
TestCase subclass: #EncodedByteArrayStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

TestCase subclass: #EncodedFileStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #EncodedFileStreamTest category: #'Tools-Testing' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
TestCase subclass: #EncodedFileStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

TestCase subclass: #FileStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #FileStreamTest category: #'Tools-Testing' stamp: 'Install-5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st 6/16/2022 07:24:52'!
TestCase subclass: #FileStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!EncodedStreamReadAdaptor methodsFor: 'accessing' stamp: 'jmv 5/25/2022 17:09:05'!
                            byteStream: aStream
	stream _ aStream! !
!EncodedStreamReadAdaptor methodsFor: 'accessing' stamp: 'jmv 5/25/2022 17:05:14'!
    collectionSpecies
	^self subclassResponsibility! !
!EncodedStreamReadAdaptor methodsFor: 'accessing' stamp: 'jmv 5/25/2022 17:09:12'!
                          stream: aStream
	stream _ aStream! !
!EncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/25/2022 17:05:14'!
          next
	self subclassResponsibility! !
!EncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/31/2022 09:48:36'!
          streamUpToEnd
	"Answer the contents of our stream, from current postion to end, seen from our perspective.
	Leave stream at the end position."

	^self subclassResponsibility! !
!BytesEncodedStreamReadAdaptor methodsFor: 'accessing' stamp: 'jmv 5/25/2022 17:05:30' overrides: 50376791!
   collectionSpecies
	^ByteArray! !
!BytesEncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/25/2022 17:08:42' overrides: 50376800!
                     next
	^stream nextByte! !
!BytesEncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/31/2022 09:48:02' overrides: 50376804!
                            streamUpToEnd
	"Answer the contents of our stream, from current postion to end, seen from our perspective:
	Whatever bytes in the stream.
	Leave stream at the end position."

	^stream bytesUpToEnd! !
!StringEncodedStreamReadAdaptor methodsFor: 'accessing' stamp: 'jmv 5/25/2022 17:05:41' overrides: 50376791!
           collectionSpecies
	^String! !
!StringEncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/31/2022 09:58:03' overrides: 50376800!
                       next
	"Stream bytes as Cuis / ISO 8859-15 Characters.
	Disregard the fact that stream contents are most likely UTF-8.
	This is valid only if contents are ASCII, or Cuis / ISO-8859-15 byte Characters."

	stream nextByte ifNotNil: [ :byte |
		^Character numericValue: byte ].
	^nil! !
!StringEncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/31/2022 09:58:10' overrides: 50376804!
                          streamUpToEnd
	"Answer the contents of our stream, from current postion to end, seen from our perspective:
	Stream bytes as Cuis / ISO 8859-15 Characters.
	Disregard the fact that stream contents are most likely UTF-8.
	This is valid only if contents are ASCII, or Cuis / ISO-8859-15 byte Characters.
	Leave stream at the end position."

	^stream bytesUpToEnd asString! !
!Utf32EncodedStreamReadAdaptor methodsFor: 'accessing' stamp: 'jmv 5/25/2022 17:05:51' overrides: 50376791!
collectionSpecies
	^Utf32String! !
!Utf32EncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/25/2022 17:08:53' overrides: 50376800!
                   next
	^stream nextCodePoint! !
!Utf32EncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/31/2022 09:48:20' overrides: 50376804!
                       streamUpToEnd
	"Answer the contents of our stream, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Leave stream at the end position."

	| utf32 |
	utf32 _ WordArray streamContents: [ :utf32Stream |
		[ stream atEnd ] whileFalse: [
			stream nextUtf8BytesAndCodePointInto: nil into: [ :codePoint |
				utf32Stream nextPut: codePoint]]].
	^Utf32String withWords: utf32! !
!Utf8EncodedStreamReadAdaptor methodsFor: 'accessing' stamp: 'jmv 5/25/2022 17:05:59' overrides: 50376791!
     collectionSpecies
	^Utf8String! !
!Utf8EncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/25/2022 17:08:58' overrides: 50376800!
                     next
	^stream nextCodePoint! !
!Utf8EncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 5/31/2022 09:48:24' overrides: 50376804!
                        streamUpToEnd
	"Answer the contents of our stream, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Leave stream at the end position."

	| utf8 |
	utf8 _ ByteArray streamContents: [ :utf8Stream |
		[ stream atEnd ] whileFalse: [
			stream nextUtf8BytesAndCodePointInto: [ :byte1 :byte2 :byte3 :byte4 | 
				utf8Stream nextPut: byte1.
				byte2 ifNotNil: [
					utf8Stream nextPut: byte2.
					byte3 ifNotNil: [
						utf8Stream nextPut: byte3.
						byte4 ifNotNil: [
							utf8Stream nextPut: byte4]]]]
				into: nil ]].
	^Utf8String withBytes: utf8! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:11:15' overrides: 16922435!
            next
	"Answer the next entry from this file, or nil if at the end of the file.
	Answer will be
	- CodePoint (for #useUtf8String and #useUtf32String)
	- Character (for #useCharacters)
	- SmallInteger (for #useBytes)"

	^readAdaptor next! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:11:41' overrides: 16922442!
     next: n
	"Return a string with the next n characters of the filestream in it.  1/31/96 sw"
'--------' print.
thisContext printStack: 10.
self halt.
	^ self nextInto: (ByteArray new: n)! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:12:45' overrides: 16922453!
                        next: n into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| obj |
'--------' print.
thisContext printStack: 10.
self halt. "ojo"
	0 to: n-1 do: [ :i |
		(obj _ self nextByte) ifNil: [ ^aCollection copyFrom: 1 to: startIndex+i-1 ].
		aCollection at: startIndex+i put: obj].
	^aCollection! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:46:47'!
                 nextUtf8BytesAndCodePointInto: bytesBlock into: codePointBlock
	"Find the next UTF-8 CodePoint from this file, assuming next byte is ISO 8859-15 if invalid UTF-8,
	or nil if at the end of the file."

	| bytesConsumed previousPosition |
	previousPosition _ self position.
	bytesConsumed _ 0.
	self nextByte ifNotNil: [ :byte1 |
		bytesConsumed _ Character
			utf8BytesAndCodePointFor: byte1
			byte2: self nextByte
			byte3: self nextByte
			byte4: self nextByte
			into: bytesBlock
			into: codePointBlock ].
	self position: previousPosition + bytesConsumed.! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:18:16' overrides: 16913981!
  nextWordsInto: aBitmap
	"Note: The file primitives automatically adjust for word based objects."

'--------' print.
thisContext printStack: 10.
self halt.
	self next: aBitmap basicSize into: aBitmap startingAt: 1.
	aBitmap restoreEndianness.
	^ aBitmap! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:46:52' overrides: 16914055!
                    peek
	"Answer what would be returned if the message next were sent to the receiver.
	If the receiver is at the end, answer nil.  "

	| next currentPosition |
	self atEnd ifTrue: [^ nil].
	currentPosition := self position.
	next _ self next.
	self position: currentPosition.
	^ next! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:32:26' overrides: 16914077!
                       peekFor: aCharacter 
	"Answer false and do not move over the next element if it is not equal to the argument, aCharacter 
	Answer true and increment the position for accessing elements, if the next element is equal to anObject."

	| nextChar |
	nextChar _ self peek.
	aCharacter = nextChar ifTrue: [
		self next.
		^ true].
	^ false! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/30/2022 14:57:41' overrides: 16914316!
    position: pos

	| m s |
	"Chequear que los senders sepan que estan mandando una posicion a byte!!"
	m _ thisContext sender method.
	thisContext sender receiver == self ifFalse: [
		thisContext sender receiver == readAdaptor ifFalse: [
			(EncodedFileStream positionValidatedSenders includes: m) ifFalse: [
				"SendersOfPositionColon _ Set new"
				s _ Smalltalk at: #SendersOfPositionColon ifAbsentPut: [ Set new ].
				(s includes: m) ifFalse: [
					s add: m.
					{ '-------- Sender de #position: '. m. pos} print.
					thisContext printStack: 10 ]]]].
	^super position: pos! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:20:26' overrides: 16922474!
              readInto: byteArray startingAt: startIndex count: count
	"Read into the given array as specified, and return the count
	actually transferred.  index and count are in units of bytes or
	longs depending on whether the array is Bitmap, String or ByteArray"

'--------' print.
thisContext printStack: 10.
self halt.
	^(self next: count into: byteArray startingAt: startIndex) size - startIndex + 1
! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:22:34' overrides: 50364304!
      skip
	"Skips one object in the receiver's future sequence values."

	self next! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:22:38' overrides: 50368843!
  skip: n
	n < 0 ifTrue: [
		^n negated timesRepeat: [ self skipBack ]].
	n timesRepeat: [ self skip ].! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:47:16' overrides: 50364310!
           skipBack
	| savePos try |
	savePos _ self position.

	"Try going back one byte. If ASCII, then OK, we are done.
	If not, don't assume ISO-8859-15 so lightly!!"
	try _ savePos-1.
	self position: try.
	self nextByte < 128 ifTrue: [
		^self position: try ].

	"Try going back two bytes. If doing #next leaves us at savePosition, we found a two byte CodePoint."
	try _ try-1.
	self position: try.
	(self next notNil and: [ self position = savePos ]) ifTrue: [
		^self position: try ].

	"Try going back three bytes. If doing #next leaves us at savePosition, we found a three byte CodePoint."
	try _ try-1.
	self position: try.
	(self next notNil and: [ self position = savePos ]) ifTrue: [
		^self position: try ].

	"Try going back four bytes. If doing #next leaves us at savePosition, we found a four byte CodePoint."
	try _ try-1.
	self position: try.
	(self next notNil and: [ self position = savePos ]) ifTrue: [
		^self position: try ].

	"Havent found a valid UTF-8 sequence that ends just before savePos.
	It means back byte is an ISO-8859-15 Character"
	self position: savePos-1.! !
!EncodedReadStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:24:32' overrides: 16922498!
                    upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
'--------' print.
thisContext printStack: 10.
self halt! !
!EncodedReadStream methodsFor: 'private' stamp: 'jmv 5/31/2022 09:48:09'!
                              bytesUpToEnd
	"Leave stream at the end position."

	| start |
	start _ position+1.
	position _ collection size.
	^collection copyFrom: start to: position! !
!EncodedReadStream methodsFor: 'private' stamp: 'jmv 5/28/2022 17:30:06'!
                         nextByte
	"Return the next object in the Stream represented by the receiver."

	"treat me as a FIFO"
	^ position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!EncodedReadStream methodsFor: 'private' stamp: 'jmv 5/28/2022 17:30:21'!
                               nextCodePoint
	| answer |
	answer _ nil.
	self nextUtf8BytesAndCodePointInto: nil into: [ :codePoint |
		answer _ UnicodeCodePoint codePoint: codePoint ].
	^answer! !
!EncodedReadStream methodsFor: 'private' stamp: 'jmv 5/28/2022 17:31:17' overrides: 50361502!
                           on: aCollection
	super on: aCollection.
	self useCharacters .
self useUtf8String.
"ok?"! !
!EncodedReadStream methodsFor: 'reading modes' stamp: 'jmv 5/28/2022 17:33:12'!
                     useBytes
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ BytesEncodedStreamReadAdaptor new stream: self.! !
!EncodedReadStream methodsFor: 'reading modes' stamp: 'jmv 5/28/2022 17:33:23'!
                      useCharacters
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ StringEncodedStreamReadAdaptor new stream: self.! !
!EncodedReadStream methodsFor: 'reading modes' stamp: 'jmv 5/28/2022 17:33:38'!
                useUtf32String
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ Utf32EncodedStreamReadAdaptor new stream: self.! !
!EncodedReadStream methodsFor: 'reading modes' stamp: 'jmv 5/28/2022 17:33:45'!
                useUtf8String
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ Utf8EncodedStreamReadAdaptor new stream: self.! !
!EncodedReadStream methodsFor: 'accessing' stamp: 'jmv 5/28/2022 17:34:08' overrides: 16914559!
  collectionSpecies
	^readAdaptor collectionSpecies! !
!EncodedReadStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 09:52:53' overrides: 50365948!
           contents
	"Return the full contents of the receiver. Do not close or otherwise touch the receiver.
	Return data in whatever mode the receiver is in (i.e. answer an instance of the appropriate class).
	Stream bytes as CodePoints (prefer UTF-8, but ISO-8859-15 if invalid UTF-8)."

	| savePos answer |
	savePos _ self position.
	self position: 0.
	answer _ self upToEnd.
	self position: savePos.
	^answer! !
!EncodedReadStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 17:16:50' overrides: 16922517!
          upToEnd
	"Return the contents of the receiver. Do not close or otherwise touch the receiver.
	Return data in whatever mode the receiver is in (i.e. answer an instance of the appropriate class)."

	^readAdaptor streamUpToEnd! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:13:28' overrides: 16982981!
                next: anInteger putAll: aString startingAt: startIndex
'--------' print.
thisContext printStack: 10.
self halt.
	lastWrittenElement _ aString at: anInteger.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:15:29' overrides: 50365963!
                   nextPut: aCodePointOrCharacterOrByte
	"Insert the argument at the next position in the Stream represented by the receiver.
	Argument can be Character, CodePoint or Byte (SmallInteger).
	Write to this stream. Character and CodePoint are UTF-8 encoded."

	aCodePointOrCharacterOrByte isNumber
		ifTrue: [self nextPutByte: aCodePointOrCharacterOrByte]
		ifFalse: [self nextPutCodePoint: aCodePointOrCharacterOrByte codePoint].
	lastWrittenElement _ aCodePointOrCharacterOrByte.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:16:04' overrides: 50365979!
                     nextPutAll: aStringOrBytes
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this stream. All 3 kinds of Strings are UTF-8 encoded."

	| bytes |
	bytes _ aStringOrBytes.
	(aStringOrBytes is: #ByteArray) ifFalse: [
		bytes _ aStringOrBytes asUtf8Bytes].
	super nextPutAll: bytes.
	lastWrittenElement _ aStringOrBytes last.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:17:07'!
          nextPutCodePoint: aNumber
	"UTF-8 encoded"

	Character
		evaluate: [ :byte | self nextPutByte: byte ]
		withUtf8BytesOfUnicodeCodePoint: aNumber! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:19:19'!
                   pastEndPutByte: aByte
	"Grow the collection.
	Then we put <anObject> at the current write position."

	self growTo: collection size + 1.
	collection at: (position _ position + 1) put: aByte! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:20:09' overrides: 16983135!
                  peekLast

	^lastWrittenElement! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/30/2022 14:57:55' overrides: 16983042!
                 position: pos

	| m s |
	"Chequear que los senders sepan que estan mandando una posicion a byte!!"
	m _ thisContext sender method.
	thisContext sender receiver == self ifFalse: [
		(EncodedFileStream positionValidatedSenders includes: m) ifFalse: [
			"SendersOfPositionColon _ Set new"
			s _ Smalltalk at: #SendersOfPositionColon ifAbsentPut: [ Set new ].
			(s includes: m) ifFalse: [
				s add: m.
				{ '-------- Sender de #position: '. m. pos} print.
				thisContext printStack: 10 ]]].
	^super position: pos! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:22:26' overrides: 50364304!
             skip
	"Skips one object in the receiver's future sequence values."
"
	self next
"
"Hago algo???"
self error: 'hacerlo?' print.
thisContext printStack: 10.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:22:43' overrides: 50368843!
                     skip: n
	"Skips one object in the receiver's future sequence values."
"
	self next
"
"Hago algo???"
self error: 'hacerlo?' print.
thisContext printStack: 10.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:23:12' overrides: 50364310!
                  skipBack
	"Skips one object in the receiver's future sequence values."
"
	self next
"
"Hago algo???"
self error: 'hacerlo?' print.
thisContext printStack: 10.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/30/2022 10:24:26' overrides: 16983291!
                 withAttribute: aTextAttribute do: streamBlock
'--------' print.
thisContext printStack: 10.
self halt.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 5/30/2022 10:24:42' overrides: 16983302!
         withAttributes: attributes do: streamBlock 
'--------' print.
thisContext printStack: 10.
self halt.! !
!EncodedWriteStream methodsFor: 'private' stamp: 'jmv 5/31/2022 12:52:18'!
             byteContents
	readLimit _ readLimit max: position.
	^collection copyFrom: 1 to: position.! !
!EncodedWriteStream methodsFor: 'private' stamp: 'jmv 5/30/2022 10:06:18' overrides: 50368173!
    isCompatibleWithContents: aCollection

	aCollection isString
		ifTrue: [ ^true ].

	(aCollection is: #ByteArray)
		ifTrue: [ ^true ].

	^ false! !
!EncodedWriteStream methodsFor: 'private' stamp: 'jmv 5/28/2022 17:30:29'!
  nextPutByte: aByte 
	"Insert the argument at the next position in the Stream represented by the receiver."

	position >= writeLimit
		ifTrue: [^ self pastEndPutByte: aByte]
		ifFalse: [
			position _ position + 1.
			^collection at: position put: aByte]! !
!EncodedWriteStream methodsFor: 'private' stamp: 'jmv 5/30/2022 10:23:37' overrides: 16983276!
pastEndPut: anObject
	self shouldNotImplement! !
!EncodedWriteStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 09:37:20' overrides: 16914559!
              collectionSpecies

	self shouldNotImplement! !
!EncodedWriteStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 09:37:04' overrides: 50365956!
                contents
	"We were built to create and answer an instance of Utf8String"

	^self utf8Contents! !
!EncodedWriteStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 12:52:16'!
                  utf8Contents
	"Answer the Utf8String built so far."

	^Utf8String withBytes: self byteContents.! !
!EncodedFileStream methodsFor: 'open/close' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945886!
                            close
	"Close this file."

	fileID ifNotNil: [
		collection ifNotNil: [
			readLimit := position := 0 ].
		self primClose: fileID.
		self unregister.
		fileID := nil].
! !
!EncodedFileStream methodsFor: 'open/close' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945834!
                   closed
	"Answer true if this file is closed."

	^ fileID == nil or: [ (self primSizeNoError: fileID) == nil ]
! !
!EncodedFileStream methodsFor: 'open/close' stamp: 'jmv 5/25/2022 16:58:41'!
 ensureOpen
	"Make sure that this file really is open."

	self closed ifTrue: [^ self reopen].
	(self primSizeNoError: fileID) ifNotNil: [^ self].
	self reopen.
! !
!EncodedFileStream methodsFor: 'open/close' stamp: 'jmv 5/26/2022 11:30:05'!
               open: fileName forWrite: writeMode
	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."
	"Changed to do a GC and retry before failing ar 3/21/98 17:25"
	fileID _ EncodedFileStream retryWithGC: [ self primOpen: fileName asUtf8Bytes writable: writeMode ]
					until: [ :id | id notNil ]
					forFileNamed: fileName.
	fileID ifNil: [^ nil].  "allows sender to detect failure"
	name _ fileName.
	"jmv: Register after setting name. Name is assumed to be defined for registered objects."
	self register.
	rwmode _ writeMode.
	buffer1 _ ByteArray new: 1.
	self useCharacters.	  	"By default"
self useUtf8String.
	self enableReadBuffering.
! !
!EncodedFileStream methodsFor: 'open/close' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945809!
  openReadOnly
	"Open the receiver as a read-only file.  1/31/96 sw"

	^ self open: name forWrite: false! !
!EncodedFileStream methodsFor: 'open/close' stamp: 'jmv 5/25/2022 16:58:41'!
         reopen
	"Close and reopen this file. The file position is reset to zero."
	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."

	fileID ifNotNil: [
		collection ifNotNil: [
			position < readLimit ifTrue: [
				self flushReadBuffer ] ].
		self primCloseNoError: fileID ].
	self open: name forWrite: rwmode.! !
!EncodedFileStream methodsFor: 'properties-setting' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945847!
                     isReadOnly

	^ rwmode not
! !
!EncodedFileStream methodsFor: 'properties-setting' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945817!
                         readOnly
	"Make this file read-only."

	rwmode _ false.
! !
!EncodedFileStream methodsFor: 'properties-setting' stamp: 'jmv 5/25/2022 16:58:41'!
               readWrite
	"Make this file writable."

	rwmode _ true.
! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:41'!
                            directory
	"Return the directory containing this file."

	^ self fileEntry parent! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:41'!
  fileEntry
	^ self fullName asFileEntry! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:41'!
             fullName
	"Answer this file's full path name."

	^ name
! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945734!
       localName
	^ self fileEntry name! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16922576!
                               name
	"Answer this file's full path name."

	^ name
! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:09' overrides: 16914077!
           peekFor: aCharacter 
	"Answer false and do not move over the next element if it is not equal to the argument, aCharacter 
	Answer true and increment the position for accessing elements, if the next element is equal to anObject."

	| nextChar |
	nextChar _ self peek.
	aCharacter = nextChar ifTrue: [
		self next.
		^ true].
	^ false! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945812!
                   printOn: aStream
	"Put a printed version of the receiver onto aStream.  1/31/96 sw"

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/28/2022 17:47:46' overrides: 16983048!
       reset
	self ensureOpen.
	self position: 0.! !
!EncodedFileStream methodsFor: 'access' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16983038!
                     size
	"Answer the size of the file in characters.  2/12/96 sw"

	^ self primSize: fileID! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16914201!
                        atEnd
	"Answer whether the receiver is at its end.  "
	
	collection ifNotNil: [
		position < readLimit ifTrue: [ ^false ] ].
	^self primAtEnd: fileID! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/25/2022 16:58:41'!
               crc16
	"Copied from String>>crc16"
	
	| buffer crc |
	self reset.
	buffer _ ByteArray new: 2000.
	crc _ 0.
	[ self atEnd ] whileFalse: [
		buffer _ self nextInto: buffer.
		buffer do: [:c |
			crc _ (crc bitShift: -8) bitXor: (
			 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241
				16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440
				16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40
				16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841
				16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40
				16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41
				16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641
				16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040
				16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240
				16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441
				16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41
				16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840
				16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41
				16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40
				16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640
				16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041
				16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240
				16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441
				16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41
				16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840
				16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41
				16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40
				16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640
				16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041
				16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241
				16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440
				16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40
				16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841
				16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40
				16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41
				16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641
				16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)
			 at: ((crc bitXor: c) bitAnd: 16rFF) + 1) 
		].
	].
	^crc! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16945731!
            flush
	"Flush pending changes"
	^self primFlush: fileID! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/25/2022 16:58:09' overrides: 16922580!
                         next
	"Answer the next entry from this file, or nil if at the end of the file.
	Answer will be
	- CodePoint (for #useUtf8String and #useUtf32String)
	- Character (for #useCharacters)
	- SmallInteger (for #useBytes)"

	^readAdaptor next! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:01:22' overrides: 16922588!
     next: n
	"Return a string with the next n characters of the filestream in it.  1/31/96 sw"
'--------' print.
thisContext printStack: 10.
self halt.
	^ self nextInto: (ByteArray new: n)! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:02:05' overrides: 50365262!
                        next: n into: aBytesOrWordsObject startingAt: startIndex
	"Read n bytes or words into the given aBytesOrWordsObject.
	Return aBytesOrWordsObject or a partial copy if less than
	n elements have been read."
	
	| count  newN newStartIndex |
true ifTrue: [
'--------' print.
thisContext printStack: 10.
self halt. "ojo"
"si se que son bytes quizas preferir
nextBytes: n into: aBytesOrWordsObject startingAt: startIndex
"
].
	collection 
		ifNil: [ 
			newN := n.
			newStartIndex := startIndex ]
		ifNotNil: [
			aBytesOrWordsObject class isBytes 
				ifFalse: [ 
					position < readLimit ifTrue: [ self flushReadBuffer ].
					newN := n.
					newStartIndex := startIndex ]
				ifTrue: [
					| available |
					(available := readLimit - position) > 0 
						ifFalse: [ available := 0 ]
						ifTrue: [
							| bufferedCount |
							bufferedCount := n min: available.
							aBytesOrWordsObject
								replaceFrom: startIndex
								to: startIndex + bufferedCount - 1
								with: collection
								startingAt: position + 1.
							position := position + bufferedCount.
							bufferedCount = n ifTrue: [ ^aBytesOrWordsObject ] ].
					newN := n - available.
					newStartIndex := startIndex + available ] ].
	count := self primRead: fileID into: aBytesOrWordsObject
				startingAt: newStartIndex count: newN.
	count = newN
		ifTrue:[ ^aBytesOrWordsObject ]
		ifFalse:[ ^aBytesOrWordsObject copyFrom: 1 to: newStartIndex + count - 1 ]! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:23:30' overrides: 16982981!
                   next: anInteger putAll: aString startingAt: startIndex
	"Store the next anInteger elements from the given collection."
'--------' print.
thisContext printStack: 10.
self halt.
	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [
		position < readLimit ifTrue: [ self flushReadBuffer ] ].	
	self primWrite: fileID from: aString startingAt: startIndex count: anInteger.
	lastWrittenElement _ aString at: anInteger.
	^aString! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/25/2022 16:58:41'!
                         nextBytes: n into: aBytesOrWordsObject startingAt: startIndex
	"Read n bytes or words into the given aBytesOrWordsObject.
	Return aBytesOrWordsObject or a partial copy if less than
	n elements have been read."
	
	| count  newN newStartIndex |

	collection 
		ifNil: [ 
			newN := n.
			newStartIndex := startIndex ]
		ifNotNil: [
			aBytesOrWordsObject class isBytes 
				ifFalse: [ 
					position < readLimit ifTrue: [ self flushReadBuffer ].
					newN := n.
					newStartIndex := startIndex ]
				ifTrue: [
					| available |
					(available := readLimit - position) > 0 
						ifFalse: [ available := 0 ]
						ifTrue: [
							| bufferedCount |
							bufferedCount := n min: available.
							aBytesOrWordsObject
								replaceFrom: startIndex
								to: startIndex + bufferedCount - 1
								with: collection
								startingAt: position + 1.
							position := position + bufferedCount.
							bufferedCount = n ifTrue: [ ^aBytesOrWordsObject ] ].
					newN := n - available.
					newStartIndex := startIndex + available ] ].
	count := self primRead: fileID into: aBytesOrWordsObject
				startingAt: newStartIndex count: newN.
	count = newN
		ifTrue:[ ^aBytesOrWordsObject ]
		ifFalse:[ ^aBytesOrWordsObject copyFrom: 1 to: newStartIndex + count - 1 ]! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:25:46' overrides: 50365963!
   nextPut: aCodePointOrCharacterOrByte
	"Insert the argument at the next position in the Stream represented by the receiver.
	Argument can be Character, CodePoint or Byte (SmallInteger).
	Write to this stream. Character and CodePoint are UTF-8 encoded."

	aCodePointOrCharacterOrByte isNumber
		ifTrue: [self nextPutByte: aCodePointOrCharacterOrByte]
		ifFalse: [self nextPutCodePoint: aCodePointOrCharacterOrByte codePoint].
	lastWrittenElement _ aCodePointOrCharacterOrByte.! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:24:25' overrides: 50365979!
                      nextPutAll: aStringOrBytes
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this file. All 3 kinds of Strings are UTF-8 encoded."

	| bytes |
	bytes _ aStringOrBytes.
	(aStringOrBytes is: #ByteArray) ifFalse: [
		bytes _ aStringOrBytes asUtf8Bytes].
	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [ 
		position < readLimit ifTrue: [ self flushReadBuffer ] ].
	self primWrite: fileID from: bytes startingAt: 1 count: bytes basicSize.
	lastWrittenElement _ aStringOrBytes last.! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/25/2022 16:58:09'!
       nextPutCodePoint: aNumber
	"UTF-8 encoded"

	Character
		evaluate: [ :byte | self nextPutByte: byte ]
		withUtf8BytesOfUnicodeCodePoint: aNumber! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:44:57'!
                    nextUtf8BytesAndCodePointInto: bytesBlock into: codePointBlock
	"Find the next UTF-8 CodePoint from this file, assuming next byte is ISO 8859-15 if invalid UTF-8,
	or nil if at the end of the file."

	| bytesConsumed previousPosition |
	previousPosition _ self position.
	bytesConsumed _ 0.
	self nextByte ifNotNil: [ :byte1 |
		bytesConsumed _ Character
			utf8BytesAndCodePointFor: byte1
			byte2: self nextByte
			byte3: self nextByte
			byte4: self nextByte
			into: bytesBlock
			into: codePointBlock ].
	self position: previousPosition + bytesConsumed.! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:01:29' overrides: 50365271!
  nextWordsInto: aBitmap
	"Note: The file primitives automatically adjust for word based objects."

'--------' print.
thisContext printStack: 10.
self halt.
	self next: aBitmap basicSize into: aBitmap startingAt: 1.
	aBitmap restoreEndianness.
	^ aBitmap! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:45:02' overrides: 16983319!
                    padToEndIfCantTruncate
	"Only makes sense for file streams with existing content.
	On file systems that don't support truncating this is needed.
	If truncating is supported, try that first"

	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."

	| pad |
	self atEnd ifTrue: [^ self].
	self truncate.
	self atEnd ifTrue: [^ self].
'--------' print.
thisContext printStack: 10.
self halt.
	pad := Character space numericValue.
	self nextPutAll: (ByteArray new: ((self size - self position) min: 20000) 
							withAll: pad)! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:45:07' overrides: 50365278!
 peek
	"Answer what would be returned if the message next were sent to the receiver.
	If the receiver is at the end, answer nil.  "

	| next currentPosition |
	self atEnd ifTrue: [^ nil].
	currentPosition := self position.
	next _ self next.
	self position: currentPosition.
	^ next! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:28:13' overrides: 16983135!
                       peekLast

	^lastWrittenElement! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:43:46' overrides: 16914311!
                  position
	"Return the receiver's current file position."

	collection ifNotNil: [
		position < readLimit ifTrue: [
			^(self primGetPosition: fileID) - readLimit + position ] ].
	^self primGetPosition: fileID! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/30/2022 14:58:11' overrides: 16983042!
position: pos
	"Set the receiver's position as indicated."

	| m s |
	"Chequear que los senders sepan que estan mandando una posicion a byte!!"
	m _ thisContext sender method.
	thisContext sender receiver == self ifFalse: [
		thisContext sender receiver == readAdaptor ifFalse: [
			(EncodedFileStream positionValidatedSenders includes: m) ifFalse: [
				"SendersOfPositionColon _ Set new"
				s _ Smalltalk at: #SendersOfPositionColon ifAbsentPut: [ Set new ].
				(s includes: m) ifFalse: [
					s add: m.
					{ '-------- Sender de #position: '. m. pos} print.
					thisContext printStack: 10 ]]]].

	collection ifNotNil: [
		position < readLimit ifTrue: [
			| newPosition |
			newPosition := pos - (self primGetPosition: fileID) + readLimit.
			newPosition < 0 ifTrue: [
					| offsetPos |
					self primSetPosition: fileID to: (offsetPos := pos - (collection size // 4) max: 0).
					readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
					position := pos - offsetPos.
					^self ].
			newPosition < readLimit 
				ifTrue: [
					position := newPosition.
					^self ]
				ifFalse: [
					readLimit := position := 0 ] ] ].
	^self primSetPosition: fileID to: pos! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/27/2022 10:01:38'!
               readInto: byteArray startingAt: startIndex count: count
	"Read into the given array as specified, and return the count
	actually transferred.  index and count are in units of bytes or
	longs depending on whether the array is Bitmap, String or ByteArray"

'--------' print.
thisContext printStack: 10.
self halt.
	^(self next: count into: byteArray startingAt: startIndex) size - startIndex + 1
! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:47:55' overrides: 16983057!
      setToEnd
	"Set the position of the receiver to the end of file.  1/31/96 sw"

	self position: self size! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/26/2022 14:38:48' overrides: 50364304!
         skip
	"Skips one object in the receiver's future sequence values."

	self next! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/26/2022 14:36:56' overrides: 50368843!
  skip: n
	n < 0 ifTrue: [
		^n negated timesRepeat: [ self skipBack ]].
	n timesRepeat: [ self skip ].! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:46:21' overrides: 50364310!
           skipBack
	| savePos try |
	savePos _ self position.

	"Try going back one byte. If ASCII, then OK, we are done.
	If not, don't assume ISO-8859-15 so lightly!!"
	try _ savePos-1.
	self position: try.
	self nextByte < 128 ifTrue: [
		^self position: try ].

	"Try going back two bytes. If doing #next leaves us at savePosition, we found a two byte CodePoint."
	try _ try-1.
	self position: try.
	(self next notNil and: [ self position = savePos ]) ifTrue: [
		^self position: try ].

	"Try going back three bytes. If doing #next leaves us at savePosition, we found a three byte CodePoint."
	try _ try-1.
	self position: try.
	(self next notNil and: [ self position = savePos ]) ifTrue: [
		^self position: try ].

	"Try going back four bytes. If doing #next leaves us at savePosition, we found a four byte CodePoint."
	try _ try-1.
	self position: try.
	(self next notNil and: [ self position = savePos ]) ifTrue: [
		^self position: try ].

	"Havent found a valid UTF-8 sequence that ends just before savePos.
	It means back byte is an ISO-8859-15 Character"
	self position: savePos-1.
	! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/25/2022 16:58:41'!
      truncate
	"Truncate to zero"

	^ self truncate: 0! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:47:58'!
                   truncate: bytePosition
	"Truncate to this position"

	self position: bytePosition.
	^self primTruncate: fileID to: bytePosition.! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/28/2022 17:45:59' overrides: 50365284!
                upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"See comment at PositionableStream.
	Fast version to speed up nextChunk"

	| pos buffer count skipSeparator tryAgain |

'--------' print.
thisContext printStack: 10.
self halt.
	skipSeparator _ delimiterIsTerminator ifTrue: [0] ifFalse: [1].
	collection ifNotNil: [
		(position < readLimit and: [
			(pos _ collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [
				pos > 0 ] ]) ifTrue: [
					^ collection copyFrom: position + 1 to: (position _ pos) - skipSeparator ] ].

	pos _ self position.
	buffer _ self next: 2000.
	(count _ buffer indexOf: delimiter) > 0 ifTrue: [
		"Found the delimiter part way into buffer"
		self position: pos + count.
		^ buffer copyFrom: 1 to: count - skipSeparator].

	self atEnd ifTrue: [
		"Never found it, and hit end of file"
		^ delimiterIsTerminator ifTrue: [self position: pos. nil] ifFalse: [buffer]].

	"Never found it, but there's more..."
	tryAgain _ self upTo: delimiter delimiterIsTerminator: delimiterIsTerminator.
	tryAgain ifNil: [
		self position: pos.
		^ nil ].
	^ buffer, tryAgain.! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/30/2022 10:24:32' overrides: 16983291!
                    withAttribute: aTextAttribute do: streamBlock
'--------' print.
thisContext printStack: 10.
self halt.! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 5/30/2022 10:24:44' overrides: 16983302!
          withAttributes: attributes do: streamBlock 
'--------' print.
thisContext printStack: 10.
self halt.! !
!EncodedFileStream methodsFor: 'testing' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16914229!
                          isFileStream
	^true! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
                            primAtEnd: id
	"Answer true if the file position is at the end of the file."

	<primitive: 'primitiveFileAtEnd' module: 'FilePlugin'>
	self primitiveFailed
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
                   primClose: id
	"Close this file."

	<primitive: 'primitiveFileClose' module: 'FilePlugin'>
	self primitiveFailed
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
                              primCloseNoError: id
	"Close this file. Don't raise an error if the primitive fails."

	<primitive: 'primitiveFileClose' module: 'FilePlugin'>
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/28/2022 17:45:16'!
primFlush: id
	"Flush pending changes to the disk"
	| p |
	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>
	"In some OS's seeking to 0 and back will do a flush"
	p _ self position.
	self position: 0; position: p! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
                     primGetPosition: id
	"Get this files current position."

	<primitive: 'primitiveFileGetPosition' module: 'FilePlugin'>
	self primitiveFailed
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
  primOpen: fileNameAsUtf8Bytes writable: writableFlag
	"Open a file of the given name, and return the file ID obtained.
	If writableFlag is true, then
		if there is none with this name, then create one
		else prepare to overwrite the existing from the beginning
	otherwise
		if the file exists, open it read-only
		else return nil"

	<primitive: 'primitiveFileOpen' module: 'FilePlugin'>
	^ nil
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
     primRead: id into: byteArray startingAt: startIndex count: count
	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."

	<primitive: 'primitiveFileRead' module: 'FilePlugin'>
	self closed ifTrue: [^ self error: 'File is closed'].
	self error: 'File read failed'.
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
  primSetPosition: id to: anInteger
	"Set this file to the given position."

	<primitive: 'primitiveFileSetPosition' module: 'FilePlugin'>
	self primitiveFailed
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
                primSize: id
	"Answer the size of this file."

	<primitive: 'primitiveFileSize' module: 'FilePlugin'>
	self primitiveFailed
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
                   primSizeNoError: id
	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."

	<primitive: 'primitiveFileSize' module: 'FilePlugin'>
	^ nil
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
  primTruncate: id to: anInteger
	"Truncate this file to the given position."

	<primitive: 'primitiveFileTruncate' module: 'FilePlugin'>
	self primitiveFailed
! !
!EncodedFileStream methodsFor: 'primitives' stamp: 'jmv 5/25/2022 16:58:41'!
                 primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	(FileWriteError fileName: name)
		signal: (self closed
			ifTrue: [ 'File [', name, '] is closed' ]
			ifFalse: [ 'File [', name, '] write failed' ])! !
!EncodedFileStream methodsFor: 'registry' stamp: 'jmv 5/25/2022 16:58:41'!
               register
	^self class register: self! !
!EncodedFileStream methodsFor: 'registry' stamp: 'jmv 5/25/2022 16:58:41'!
             unregister
	^self class unregister: self! !
!EncodedFileStream methodsFor: 'finalization' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16902443!
                 actAsExecutor
	super actAsExecutor.
	name := nil.! !
!EncodedFileStream methodsFor: 'finalization' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16902461!
        finalize
	self primCloseNoError: fileID.! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/31/2022 09:48:05'!
          bytesUpToEnd
	"Leave stream at the end position."

	| bytes s |
	s _ self size.
	bytes _ ByteArray new: s.
	^ self nextBytes: s into: bytes startingAt: 1.! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/28/2022 17:44:44'!
                        disableReadBuffering

	collection ifNotNil: [
		position < readLimit
			ifTrue: [
				| currentPosition |
				currentPosition := self position.
				collection := readLimit := position := nil.
				self position: currentPosition ]
			ifFalse: [
				collection := readLimit := position := nil ] ]
		! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/25/2022 16:58:41'!
          enableReadBuffering

	collection ifNil: [
		buffer1 ifNotNil: [
			collection := ByteArray new: 2048 ] ].
	readLimit := position := 0! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/28/2022 17:44:47'!
             flushReadBuffer

	collection ifNotNil: [
		position < readLimit ifTrue: [
			| currentPosition |
			currentPosition := self position.
			position := readLimit := 0.
			self primSetPosition: fileID to: currentPosition ] ]! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/25/2022 16:58:41'!
                      nextByte
	"Answer the next byte from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/25/2022 16:58:09'!
                               nextCodePoint
	| answer |
	answer _ nil.
	self nextUtf8BytesAndCodePointInto: nil into: [ :codePoint |
		answer _ UnicodeCodePoint codePoint: codePoint ].
	^answer! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/25/2022 16:58:41'!
               nextPutByte: aByte
	"Write the given byte to this file."

	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [ 
		position < readLimit ifTrue: [ self flushReadBuffer ] ].
	buffer1 at: 1 put: aByte.
	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.! !
!EncodedFileStream methodsFor: 'private' stamp: 'jmv 5/30/2022 10:23:41' overrides: 16983276!
                      pastEndPut: anObject
	self shouldNotImplement! !
!EncodedFileStream methodsFor: 'printing' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16902872!
                longPrintOn: aStream
	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."
! !
!EncodedFileStream methodsFor: 'printing' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16902884!
                  longPrintOn: aStream limitedTo: sizeLimit indent: indent

	"Do nothing, so it will print short.  Called to print the error file.  If the error was in a file operation, we can't read the contents of that file.  Just print its name instead."

	aStream newLine! !
!EncodedFileStream methodsFor: 'printing' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16903050!
                            storeOn: aStream
	"A file can't be serialized"

	^ self printOn: aStream! !
!EncodedFileStream methodsFor: 'accessing' stamp: 'jmv 5/25/2022 16:58:09' overrides: 16914559!
                    collectionSpecies
	^readAdaptor collectionSpecies! !
!EncodedFileStream methodsFor: 'accessing' stamp: 'jmv 5/31/2022 09:53:05' overrides: 50365998!
           contents
	"Return the full contents of the receiver. Do not close or otherwise touch the receiver.
	Return data in whatever mode the receiver is in (i.e. answer an instance of the appropriate class).
	Stream bytes as CodePoints (prefer UTF-8, but ISO-8859-15 if invalid UTF-8)."

	| savePos answer |
	savePos _ self position.
	self position: 0.
	answer _ self upToEnd.
	self position: savePos.
	^answer! !
!EncodedFileStream methodsFor: 'accessing' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16913837!
          contentsOfEntireFile
	"Read all of the contents of the receiver."

	| answer |
	self readOnly.
	self reset.
	answer _ self contents.
	self close.
	^answer! !
!EncodedFileStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 17:17:41'!
                      upToEnd
	"Return the contents of the receiver. Do not close or otherwise touch the receiver.
	Return data in whatever mode the receiver is in (i.e. answer an instance of the appropriate class)."

	^readAdaptor streamUpToEnd! !
!EncodedFileStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16914478!
                            fileIn
	"Guarantee that the receiver is readOnly before fileIn for efficiency and
	to eliminate remote sharing conflicts."

	self readOnly.
	self fileInAnnouncing: 'Loading ', self localName.
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].
! !
!EncodedFileStream methodsFor: 'reading modes' stamp: 'jmv 5/25/2022 17:09:17'!
                          useBytes
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ BytesEncodedStreamReadAdaptor new stream: self.! !
!EncodedFileStream methodsFor: 'reading modes' stamp: 'jmv 5/25/2022 17:09:23'!
                      useCharacters
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ StringEncodedStreamReadAdaptor new stream: self.! !
!EncodedFileStream methodsFor: 'reading modes' stamp: 'jmv 5/25/2022 17:09:27'!
                useUtf32String
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ Utf32EncodedStreamReadAdaptor new stream: self.! !
!EncodedFileStream methodsFor: 'reading modes' stamp: 'jmv 5/25/2022 17:09:31'!
                useUtf8String
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ Utf8EncodedStreamReadAdaptor new stream: self.! !
!EncodedFileStream class methodsFor: 'instance creation' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16946168!
                    new
	^ self basicNew initialize! !
!EncodedFileStream class methodsFor: 'registry' stamp: 'jmv 5/25/2022 16:58:41'!
            register: anObject
	
	^self registry add: anObject! !
!EncodedFileStream class methodsFor: 'registry' stamp: 'jmv 5/25/2022 16:58:41'!
                         registry
	
	^Registry ifNil: [ Registry := WeakRegistry new ]! !
!EncodedFileStream class methodsFor: 'registry' stamp: 'jmv 5/25/2022 16:58:41'!
              retryWithGC: execBlock until: testBlock forFileNamed: fullName
	"Re-implemented to only force GC if a file with the given name exists"
	| blockValue foundIt |
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	"See if we have a file with the given name"
	foundIt _ self registry keys "hold on strongly for now" 
		anySatisfy:[:file| file name sameAs: fullName].
	foundIt ifFalse:[^blockValue].
	Smalltalk garbageCollectMost.
	blockValue := execBlock value.
	(testBlock value: blockValue) ifTrue:[^blockValue].
	Smalltalk garbageCollect.
	^execBlock value.! !
!EncodedFileStream class methodsFor: 'registry' stamp: 'jmv 5/25/2022 16:58:41'!
                             unregister: anObject
	
	^self registry remove: anObject ifAbsent: nil! !
!EncodedFileStream class methodsFor: 'error handling' stamp: 'jmv 5/27/2022 10:01:55'!
fileDoesNotExistUserHandling: fullFileName

	| selection newName |
	selection _ (PopUpMenu labels:
'create a new file
choose another name
cancel')
			startUpWithCaption: fullFileName asFileEntry name, '
does not exist.'.
	selection = 1 ifTrue:
		[^ self new open: fullFileName forWrite: true].
	selection = 2 ifTrue:
		[ newName _ self request: 'Enter a new file name'
						initialAnswer:  fullFileName.
		^ FileIOAccessor default privateWriteableFile: newName asFileEntry ].
'--------' print.
thisContext printStack: 10.
	self halt! !
!EncodedFileStream class methodsFor: 'error handling' stamp: 'jmv 5/25/2022 16:58:41'!
                fileExistsUserHandling: fullFileName
	| dir localName choice newName entry |
	entry _ fullFileName asFileEntry.
	dir _ entry parent.
	localName _ entry name.
	choice _ (PopUpMenu
		labels:
'overwrite that file\choose another name\cancel' withNewLines)
		startUpWithCaption: localName, '
already exists.'.

	choice = 1 ifTrue: [
		dir removeKey: localName
			ifAbsent: [self error: 'Could not delete the old version of that file'].
		^ self new open: fullFileName forWrite: true].

	choice = 2 ifTrue: [
		newName _ self request: 'Enter a new file name' initialAnswer: fullFileName.
		^ FileIOAccessor default privateNewFile: newName asFileEntry ].

	self error: 'Please close this to abort file opening'! !
!EncodedFileStream class methodsFor: 'error handling' stamp: 'jmv 5/25/2022 16:58:41'!
      readOnlyFileDoesNotExistUserHandling: fullFileName

	| dir files choices selection newName fileName |
	dir _ fullFileName asFileEntry parent.
	files _ dir fileNames.
	fileName _ fullFileName asFileEntry name.
	choices _ fileName correctAgainst: files.
	choices add: 'Choose another name'.
	choices add: 'Cancel'.
	selection _ (PopUpMenu labelArray: choices lines: (Array with: 5) )
		startUpWithCaption: fullFileName asFileEntry name, '
does not exist.'.
	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].
	selection < (choices size - 1) ifTrue: [
		newName _ (dir pathName , '/', (choices at: selection))].
	selection = (choices size - 1) ifTrue: [
		newName _ self request: 'Enter a new file name' initialAnswer: fileName.
		"If Cancel was pressed, no file should be opened - Hernan"
		newName isEmpty ifTrue: [ ^nil ]].
	newName = '' ifFalse: [^ FileIOAccessor default privateReadOnlyFile: newName asFileEntry ].
	^ self error: 'Could not open a file'! !
!EncodedFileStream class methodsFor: 'cached state access' stamp: 'jmv 5/25/2022 16:58:41' overrides: 16787202!
        releaseClassCachedState

	Registry ifNotNil: [
		"Make the best effort to empty the registry.
		Only keep files that are still open have references from some object."
		Registry isEmpty ifFalse: [
			Smalltalk garbageCollectMost.
			Registry isEmpty ifFalse: [
				Smalltalk garbageCollect.
				Registry isEmpty ifFalse: [
					Registry finalizeValues ]]].

		"No open files. Can nil the Registry."
		Registry isEmpty ifTrue: [
			Registry _ nil ]
	]! !
!EncodedFileStream class methodsFor: 'file creation' stamp: 'jmv 5/25/2022 17:02:07'!
    crc16OfFileNamed: fileName
	"
	EncodedFileStream crc16OfFileNamed: 'cursor.jpeg'
	EncodedFileStream crc16OfFileNamed: 'deafultPID.txt'
	"

	^[fileName asFileEntry readStreamDo: [ :stream |
		stream crc16 ]]
			on: FileDoesNotExistException do: nil! !
!EncodedFileStream class methodsFor: 'as yet unclassified' stamp: 'jmv 5/31/2022 09:53:31'!
         positionValidatedSenders
	^{
		ChangeList >> #scanDoIt.
		ChangeList >> #scanFile:from:to:.
		ChangeList >> #scanSpecificChangeRecordType.
		ChangeList >> #scanUpTo:informing:.
		ChangeList >> #scanCategory:class:meta:stamp:prior:overrides:.
		PositionableStream >> #skipSeparators.
		ChangeRecord >> #string.
		PositionableStream >> #back.
		PositionableStream >> #peekBack.
		PositionableStream >> #backChunk.
		CompiledMethod >> #getPreamble.
		EncodedReadStream >> #nextUtf8BytesAndCodePointInto:into:.
		Parser >> #parse:class:category:noPattern:doIt:context:notifying:ifFail:.
	}! !
!EncodedByteArrayStreamTest methodsFor: 'tests' stamp: 'jmv 5/31/2022 16:27:37'!
  test01

	| utf8String utf32String stringAsIso8859s15 bytes1 bytes2 bytes3 |
	utf8String _ Utf8String withBytes: 'Hello World, Òand˙, ag¸ita. ' asUtf8Bytes, #[208 155 208 190 209 128 208 181 208 188].
	utf32String _ Utf32String withWords: utf8String asUtf32Words.
	stringAsIso8859s15 _ utf8String bytes asString.							"Includes random content, String can't handle full Unicode"

	bytes1 _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: utf8String ].
	self assert: ((EncodedReadStream on: bytes1) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes1) useBytes; contents) equals: bytes1.
	self assert: ((EncodedReadStream on: bytes1) useUtf32String; contents) equals: utf32String.
	self assert: ((EncodedReadStream on: bytes1) useCharacters; contents) equals: stringAsIso8859s15.

	bytes2 _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: utf8String bytes ].
	self assert: ((EncodedReadStream on: bytes2) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes2) useBytes; contents) equals: bytes2.
	self assert: ((EncodedReadStream on: bytes2) useUtf32String; contents) equals: utf32String.
	self assert: ((EncodedReadStream on: bytes2) useCharacters; contents) equals: stringAsIso8859s15.

	bytes3 _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: utf32String ].
	self assert: ((EncodedReadStream on: bytes3) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes3) useBytes; contents) equals: bytes3.
	self assert: ((EncodedReadStream on: bytes3) useUtf32String; contents) equals: utf32String.
	self assert: ((EncodedReadStream on: bytes3) useCharacters; contents) equals: stringAsIso8859s15.! !
!EncodedByteArrayStreamTest methodsFor: 'tests' stamp: 'jmv 5/31/2022 16:29:30'!
  test02
	"Invalid UTF-8, but possible saved as reasonable ISO 8859-15, with use of full 8 bit range.
	To test invalid utf8 detection, and conversion from 8859-15 to utf."

	| invalidUtf8Bytes validUtf8Bytes utf8String utf32String bytes |

	"Second byte is invalid UTF-8. Created from a String (i.e. ISO 8859-15 bytes), and a valid UTF-8 ByteArray:
	'uÒa ' asByteArray, #[206 188]"
	invalidUtf8Bytes _ #[117 241 97 32 206 188].

	"A correct UTF-8 sequence, created by correct conversion of the String above, and the same valid UTF-8 coda.
	'uÒa ' asUtf8Bytes, #[206 188]"
	validUtf8Bytes _ #[117 195 177 97 32 206 188].
	
	utf8String _ Utf8String withBytes: validUtf8Bytes.
	utf32String _ Utf32String withWords: utf8String asUtf32Words.

	bytes _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: invalidUtf8Bytes ].
	self assert: ((EncodedReadStream on: bytes) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes) useBytes; contents) equals: bytes.
	self assert: ((EncodedReadStream on: bytes) useUtf32String; contents) equals: utf32String.! !
!EncodedFileStreamTest methodsFor: 'tests' stamp: 'jmv 5/31/2022 16:31:47'!
                 test01

	| bytes utf8String utf32String stringAsIso8859s15 fe1 fe2 fe3 |
	bytes _ 'Hello World, Òand˙, ag¸ita. ' asUtf8Bytes, #[208 155 208 190 209 128 208 181 208 188].
	utf8String _ Utf8String withBytes: bytes.
	utf32String _ Utf32String withWords: utf8String asUtf32Words.
	stringAsIso8859s15 _ utf8String bytes asString.							"Includes random content, String can't handle full Unicode"

	fe1 _ 'xxtes01tUtf8String.txt' asFileEntry.
	fe1 forceWriteStreamDo: [ :stream | stream nextPutAll: utf8String ].
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe1 readStreamDo: [ :strm | strm useBytes; contents ]) equals: bytes.
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.
	self assert: (fe1 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: stringAsIso8859s15.

	fe2 _ 'xxtest01Utf8Bytes.txt' asFileEntry.
	fe2 forceWriteStreamDo: [ :stream | stream nextPutAll: utf8String bytes ].
	self assert: (fe2 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe2 readStreamDo: [ :strm | strm useBytes; contents ]) equals: bytes.
	self assert: (fe2 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.
	self assert: (fe2 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: stringAsIso8859s15.

	fe3 _ 'xxtes01tUtf32String.txt' asFileEntry.
	fe3 forceWriteStreamDo: [ :stream | stream nextPutAll: utf32String ].
	self assert: (fe3 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe3 readStreamDo: [ :strm | strm useBytes; contents ]) equals: bytes.
	self assert: (fe3 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.
	self assert: (fe3 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: stringAsIso8859s15.

	fe1 delete.
	fe2 delete.
	fe3 delete.! !
!EncodedFileStreamTest methodsFor: 'tests' stamp: 'jmv 5/31/2022 16:32:25'!
           test02
	"Invalid UTF-8, but possible saved as reasonable ISO 8859-15, with use of full 8 bit range.
	To test invalid utf8 detection, and conversion from 8859-15 to utf."

	| invalidUtf8Bytes validUtf8Bytes utf8String utf32String fe1 |

	"Second byte is invalid UTF-8. Created from a String (i.e. ISO 8859-15 bytes), and a valid UTF-8 ByteArray:
	'uÒa ' asByteArray, #[206 188]"
	invalidUtf8Bytes _ #[117 241 97 32 206 188].

	"A correct UTF-8 sequence, created by correct conversion of the String above, and the same valid UTF-8 coda.
	'uÒa ' asUtf8Bytes, #[206 188]"
	validUtf8Bytes _ #[117 195 177 97 32 206 188].
	
	utf8String _ Utf8String withBytes: validUtf8Bytes.
	utf32String _ Utf32String withWords: utf8String asUtf32Words.
	
	fe1 _ 'xxtest02InvalidUtf8Bytes.txt' asFileEntry.
	fe1 forceWriteStreamDo: [ :stream | stream nextPutAll: invalidUtf8Bytes ].
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe1 readStreamDo: [ :strm | strm useBytes; contents ]) equals: invalidUtf8Bytes.
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.

	fe1 delete.! !
!FileStreamTest methodsFor: 'tests' stamp: 'jmv 5/17/2022 12:56:47'!
            test01

	| ba str fe1 fe2 |
	str _ 'Hello World'.
	ba _ str asByteArray.	

	fe1 _ 'testStr.txt' asFileEntry.
	fe1 fileContents: str.
	self assert: (fe1 fileContents) equals: str.
	self assert: (fe1 readStreamDo: [ :strm | strm useBytes; contents ]) equals: ba.
	self assert: (fe1 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: str.
	
	fe2 _ 'testStrBA.txt' asFileEntry.
	fe2 fileContents: ba.
	self assert: (fe2 fileContents) equals: str.
	self assert: (fe2 readStreamDo: [ :strm | strm useBytes; contents ]) equals: ba.
	self assert: (fe2 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: str.

	fe1 delete.
	fe2 delete.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5249-EncodedStreams-JuanVuletich-2022May31-16h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5205] on 30 May 2022 at 11:14:39 am'!
!ByteArray class methodsFor: 'stream creation' stamp: 'jmv 5/29/2022 12:17:32'!
                            streamUtf8Contents: blockWithArg
	"Evaluate a block on a write stream that accepts bytes, characters.
	Arguments to #nextPutAll: can be sequences of bytes, Strings, Utf8Strings or Utf32Strings.
	Answer is an instance of us, holding UTF-8 encoded bytes."

	| stream |	
	stream _ EncodedWriteStream on: (ByteArray new: 100).
	blockWithArg value: stream.
	^stream byteContents! !
!Utf8String methodsFor: 'as yet unclassified' stamp: 'jmv 5/28/2022 17:37:51' overrides: 16934111!
    readStream
	| stream |
	stream _ EncodedReadStream on: bytes.
	stream useUtf8String.
	^stream! !
!Utf8String class methodsFor: 'stream creation' stamp: 'jmv 5/29/2022 12:19:27' overrides: 16935210!
                          streamContents: blockWithArg
	"Evaluate a block on a write stream that accepts bytes, characters.
	Arguments to #nextPutAll: can be sequences of bytes, Strings, Utf8Strings or Utf32Strings.
	Answer is an instance of us."

	| stream |	
	stream _ EncodedWriteStream on: (ByteArray new: 100).
	blockWithArg value: stream.
	^stream utf8Contents! !
!Utf8String class methodsFor: 'stream creation' stamp: 'jmv 5/29/2022 12:19:34' overrides: 50374615!
   writeStream
	"Answer a write stream that accepts bytes, characters.
	Arguments to #nextPutAll: can be sequences of bytes, Strings, Utf8Strings or Utf32Strings."

	| stream |	
	stream _ EncodedWriteStream on: (ByteArray new: 100).
	^stream! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5250-UseEncodedStreams-JuanVuletich-2022May30-11h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5252] on 8 June 2022 at 3:31:59 pm'!
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/8/2022 15:31:27'!
tokenish
	"Answer whether the receiver is a valid token-character--letter, digit, or 
	colon."

	^self isValidInIdentifiers or: [self = $:]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 15:01:25'!
     withNewLines
	"Return a copy of the receiver in which backslash (\) characters have been replaced with newLine (i.e. Lf)."

	^ self collect: [ :c | c = $\ ifTrue: [ Character newLineCharacter ] ifFalse: [ c ]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 14:58:47'!
                              withoutSuffix: aString
	"
	'Elvis' withoutSuffix: 'vis'
	'Elvis' withoutSuffix: 'Paul'
	"
	^(self endsWith: aString)
		ifTrue: [ self copyFrom: 1 to: self size - aString size ]! !
!Utf8String methodsFor: 'as yet unclassified' stamp: 'jmv 6/8/2022 15:31:07'!
                              numArgs
	"Answer either the number of arguments that the receiver would take if considered a selector. 
	Answer -1 if it couldn't be a selector. 
		Note that currently this will answer -1 for anything begining with an uppercase letter even though 
		the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."
	| firstChar numColons start ix |
	self isEmpty ifTrue: [ ^ -1 ].
	"Binary messages"
	(self allSatisfy: [ :c | c isValidInBinarySelectors ])
		ifTrue: [ ^1 ].
	"Unary and keyword messages"
	firstChar _ self at: 1.
	firstChar isValidStartOfIdentifiers ifTrue: [
		"Reject if any chars are non-alphanumeric"
		self do: [ :codePoint | codePoint tokenish ifFalse: [ ^-1 ]].
		"Fast colon count"
		numColons _ 0.
		start _ 1.
		[ (ix _ self findString: ':' startingAt: start) > 0 ] whileTrue: [
			numColons _ numColons + 1.
			start _ ix + 1 ].
		^ numColons ].
	^ -1.! !
!String methodsFor: 'system primitives' stamp: 'jmv 6/8/2022 15:29:29' prior: 50346161!
 numArgs
	"Answer either the number of arguments that the receiver would take if considered a selector. 
	Answer -1 if it couldn't be a selector. 
		Note that currently this will answer -1 for anything begining with an uppercase letter even though 
		the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."
	| firstChar numColons start ix |
	self isEmpty ifTrue: [ ^ -1 ].
	"Binary messages"
	(self allSatisfy: [ :c | c isValidInBinarySelectors ])
		ifTrue: [ ^1 ].
	"Unary and keyword messages"
	firstChar _ self at: 1.
	firstChar isValidStartOfIdentifiers ifTrue: [
		"Fast reject if any chars are non-alphanumeric"
		(self
			findSubstring: '~'
			in: self
			startingAt: 1
			matchTable: Tokenish) > 0 ifTrue: [ ^ -1 ].
		"Fast colon count"
		numColons _ 0.
		start _ 1.
		[ (ix _ self findString: ':' startingAt: start) > 0 ] whileTrue: [
			numColons _ numColons + 1.
			start _ ix + 1 ].
		^ numColons ].
	^ -1.! !
!Symbol class methodsFor: 'access' stamp: 'jmv 6/8/2022 15:23:10' prior: 50343475!
                       selectorsContaining: aString
	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."

	| size selectorList ascii |

	selectorList _ OrderedCollection new.
	(size _ aString size) = 0 ifTrue: [^selectorList].

	aString size = 1 ifTrue: [
		ascii _ aString first numericValue.
		ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]].

	aString first isValidInIdentifiers ifFalse: [
		aString size = 2 ifTrue: [
			Symbol hasInterned: aString ifTrue: [ :s | selectorList add: s]].
		^selectorList ].

	selectorList _ selectorList copyFrom: 2 to: selectorList size.

	self allSymbolTablesDo: [ :each |
		each size >= size ifTrue: [
			(each findString: aString startingAt: 1 caseSensitive: false) > 0
				ifTrue: [selectorList add: each]]].

	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"
		each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]].

"Symbol selectorsContaining: 'scon'"! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/8/2022 15:23:54' prior: 50375437 overrides: 16933739!
                            indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	index _ '' findString: subString asUtf8Bytes in: bytes startingAt: start.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/8/2022 15:24:39' prior: 50375446!
                  is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."
	| sequenceSize subStringBytes |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	subStringBytes _ subString asUtf8Bytes.
	(bytes at: index) = (subStringBytes at: 1) ifFalse: [ ^false ].
	^('' findString: subStringBytes in: bytes startingAt: index) = index! !

String removeSelector: #withoutSuffix:!

!methodRemoval: String #withoutSuffix: stamp: 'Install-5251-String-Utf8String-refactor-JuanVuletich-2022Jun08-14h51m-jmv.001.cs.st 6/16/2022 07:24:53'!
withoutSuffix: aString
	"
	'Elvis' withoutSuffix: 'vis'
	'Elvis' withoutSuffix: 'Paul'
	"
	^(self endsWith: aString)
		ifTrue: [ self copyFrom: 1 to: self size - aString size ]!

String removeSelector: #withNewLines!

!methodRemoval: String #withNewLines stamp: 'Install-5251-String-Utf8String-refactor-JuanVuletich-2022Jun08-14h51m-jmv.001.cs.st 6/16/2022 07:24:53'!
withNewLines
	"Return a copy of the receiver in which backslash (\) characters have been replaced with newLine (i.e. Lf)."

	^ self collect: [ :c | c = $\ ifTrue: [ Character newLineCharacter ] ifFalse: [ c ]].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5251-String-Utf8String-refactor-JuanVuletich-2022Jun08-14h51m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5252] on 8 June 2022 at 4:15:34 pm'!
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 15:45:45' prior: 50374537!
     new: size withAll: element 
	"Answer a new instance of me, whose every element is equal to the argument,
	value."

	^ self streamContents: [ :strm |
		size timesRepeat: [ strm nextPut: element ]].! !
!String class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 50379076!
                    new: size withAll: value
	"Answer a new instance of me, whose every element is equal to the argument,
	value."

	^(self new: size) atAllPut: value! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 16:14:12' overrides: 50374546!
        newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."
	| newArray index |
	newArray _ self new: aCollection size.
	index _ 0.
	aCollection do: [ :each | newArray at: (index _ index + 1) put: each].
	^ newArray

"
	{$c. $h. $r} as: String
	{$c. $h. $r} as: Utf8String
	{$c. $h. $r} as: Utf32String
"! !
!String class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 50374568!
     with: aCharacter 
	"Answer a new instance of me, containing only aCharacter.
	String with: $a
	String with: $·
	String with: Character euro
	"

	| newCollection |
	newCollection _ self new: 1.
	newCollection at: 1 put: aCharacter.
	^newCollection! !
!String class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 50374578!
  with: firstChar with: secondChar
	"Answer a new instance of me, containing firstChar and secondChar.
	String with: $a
	String with: $· with: Character euro
	"

	| newCollection |
	newCollection _ self new: 2.
	newCollection at: 1 put: firstChar.
	newCollection at: 2 put: secondChar.
	^newCollection! !
!String class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' overrides: 50374590!
             with: firstObject with: secondObject with: thirdObject 
	"Answer a new instance of me, containing only these three objects."

	| newCollection |
	newCollection _ self new: 3.
	newCollection at: 1 put: firstObject.
	newCollection at: 2 put: secondObject.
	newCollection at: 3 put: thirdObject.
	^newCollection! !
!String class methodsFor: 'instance creation' stamp: 'jmv 3/7/2015 23:10' overrides: 50374604!
         withAll: aSequenceableCollection
	"Create a new collection containing all the elements from aSequenceableCollection."

	^ (self new: aSequenceableCollection size)
		replaceFrom: 1
		to: aSequenceableCollection size
		with: aSequenceableCollection! !
!String class methodsFor: 'stream creation' stamp: 'jmv 6/8/2022 16:15:00' overrides: 50374615!
      writeStream
	^ WriteStream on: (self new: 100)! !
!Utf32String methodsFor: 'initialization' stamp: 'jmv 6/8/2022 15:39:27' overrides: 16920235!
                initialize
	codePoints _ `WordArray new`! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 15:37:14' overrides: 16785654!
             new: sizeRequested
	^self withWords: (WordArray new: sizeRequested)! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 15:47:59' overrides: 50379076!
                  new: size withAll: codePoint
	"Answer a new instance of me, whose every element is equal to the argument,
	value."

	^ self withWords: (WordArray new: size withAll: codePoint codePoint)! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 15:48:16' overrides: 50379076!
                             new: size withAll: codePoint 
	"Answer a new instance of me, whose every element is equal to the argument,
	value."

	^ self streamContents: [ :strm |
		size timesRepeat: [ strm nextPut: codePoint ]].! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 16:14:16' prior: 50363916 overrides: 50374546!
                             newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."
	| newArray index |
	newArray _ WordArray new: aCollection size.
	index _ 0.
	aCollection do: [ :each | newArray at: (index _ index + 1) put: each codePoint].
	^ self withWords: newArray

"
	{$c. $h. $r} as: String
	{$c. $h. $r} as: Utf8String
	{$c. $h. $r} as: Utf32String
"! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 16:04:56' prior: 50351274 overrides: 50374578!
                   with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf words for aCharacter and otherCharacter.
	Utf32String with: $a
	Utf32String with: $· with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint with: otherCharacter codePoint).! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 15:38:20' prior: 50351285!
withWords: aWordArray
	^self basicNew words: aWordArray ! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 16:14:20' prior: 50364032 overrides: 50374546!
              newFrom: aSimilarObject
	^Utf8String streamContents: [ :strm |
		aSimilarObject do: [ :codePoint |
			strm nextPut: codePoint ]]

"
	{$c. $h. $r} as: String
	{$c. $h. $r} as: Utf8String
	{$c. $h. $r} as: Utf32String
"! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 16:05:02' prior: 50351792 overrides: 50374578!
             with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter and otherCharacter.
	Utf8String with: $a
	Utf8String with: $· with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint),
		(Character utf8BytesOfUnicodeCodePoint: otherCharacter codePoint).! !
!ArrayedCollection class methodsFor: 'instance creation' stamp: 'jmv 6/8/2022 16:14:27' prior: 16781750 overrides: 16824134!
           newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."
	| newArray index |
	newArray _ self new: aCollection size.
	index _ 0.
	aCollection do: [ :each | newArray at: (index _ index + 1) put: each].
	^ newArray

"
	Array newFrom: {1. 2. 3}
	{1. 2. 3} as: Array
	{1. 2. 3} as: ByteArray
	{$c. $h. $r} as: String
"! !

CharacterSequence class removeSelector: #with:with:with:!

!methodRemoval: CharacterSequence class #with:with:with: stamp: 'Install-5252-CharacterSequence-cleanup-JuanVuletich-2022Jun08-15h31m-jmv.001.cs.st 6/16/2022 07:24:53'!
with: firstObject with: secondObject with: thirdObject 
	"Answer a new instance of me, containing only these three objects."

	| newCollection |
	newCollection _ self new: 3.
	newCollection at: 1 put: firstObject.
	newCollection at: 2 put: secondObject.
	newCollection at: 3 put: thirdObject.
	^newCollection!

CharacterSequence class removeSelector: #with:with:!

!methodRemoval: CharacterSequence class #with:with: stamp: 'Install-5252-CharacterSequence-cleanup-JuanVuletich-2022Jun08-15h31m-jmv.001.cs.st 6/16/2022 07:24:53'!
with: firstObject with: secondObject 
	"Answer a new instance of me, containing firstObject and secondObject."

	| newCollection |
	newCollection _ self new: 2.
	newCollection at: 1 put: firstObject.
	newCollection at: 2 put: secondObject.
	^newCollection!

CharacterSequence class removeSelector: #withAll:!

!methodRemoval: CharacterSequence class #withAll: stamp: 'Install-5252-CharacterSequence-cleanup-JuanVuletich-2022Jun08-15h31m-jmv.001.cs.st 6/16/2022 07:24:53'!
withAll: aSequenceableCollection
	"Create a new collection containing all the elements from aSequenceableCollection."

	^ (self new: aSequenceableCollection size)
		replaceFrom: 1
		to: aSequenceableCollection size
		with: aSequenceableCollection!

CharacterSequence class removeSelector: #writeStream!

!methodRemoval: CharacterSequence class #writeStream stamp: 'Install-5252-CharacterSequence-cleanup-JuanVuletich-2022Jun08-15h31m-jmv.001.cs.st 6/16/2022 07:24:53'!
writeStream
	^ WriteStream on: (self new: 100)!

CharacterSequence class removeSelector: #newFrom:!

!methodRemoval: CharacterSequence class #newFrom: stamp: 'Install-5252-CharacterSequence-cleanup-JuanVuletich-2022Jun08-15h31m-jmv.001.cs.st 6/16/2022 07:24:53'!
newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."
	| newArray index |
	newArray _ self new: aCollection size.
	index _ 0.
	aCollection do: [ :each | newArray at: (index _ index + 1) put: each].
	^ newArray

"
	Array newFrom: {1. 2. 3}
	{1. 2. 3} as: Array
	{1. 2. 3} as: ByteArray
	{$c. $h. $r} as: String
	{$c. $h. $r} as: Text
"!

CharacterSequence class removeSelector: #with:!

!methodRemoval: CharacterSequence class #with: stamp: 'Install-5252-CharacterSequence-cleanup-JuanVuletich-2022Jun08-15h31m-jmv.001.cs.st 6/16/2022 07:24:53'!
with: anObject 
	"Answer a new instance of me, containing only anObject."

	| newCollection |
	newCollection _ self new: 1.
	newCollection at: 1 put: anObject.
	^newCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5252-CharacterSequence-cleanup-JuanVuletich-2022Jun08-15h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5254] on 9 June 2022 at 10:59:53 am'!
!String methodsFor: 'converting' stamp: 'jmv 6/9/2022 10:52:26' prior: 50361810!
                       asUtf32Words
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15).
	Answer a WordArray.
	Ignore any NCRs (Numeric Character References). See #fromUtf32Words: "

	| inStream nextChar codePoint |
	^WordArray streamContents: [ :outStream |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			codePoint _ nextChar codePoint.
			outStream nextPut: codePoint ]]! !
!String methodsFor: 'converting' stamp: 'jmv 6/9/2022 10:56:28' prior: 50361818!
                     asUtf32Words: convertEmbeddedNCRs
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	see #asUtf8Bytes:
	"

	| str |
	^WordArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					outStream nextPut: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					outStream nextPut: codePoint ]]]! !
!String methodsFor: 'converting' stamp: 'jmv 6/9/2022 10:58:04' prior: 50364103 overrides: 50374465!
                              asUtf8Bytes
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray with a valid UTF-8 sequence.
	Ignore any NCRs (Numeric Character References). See #fromUtf8Bytes: "

	| inStream nextChar codePoint |
	^ByteArray streamContents: [ :outStream |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			codePoint _ nextChar codePoint.
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: codePoint ]]! !
!String methodsFor: 'converting' stamp: 'jmv 6/9/2022 10:57:55' prior: 50361910!
               asUtf8Bytes: convertEmbeddedNCRs
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8Bytes:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

You can hack #asUtf8Bytes to call this method with argument true, and then copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^ByteArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint ]]]! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/9/2022 10:54:48' prior: 50368630 overrides: 16934001!
          = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	aString isByteString ifTrue: [
		^bytes = aString asUtf8Bytes ].

	^ bytes = aString asUtf8Bytes.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5253-DontUseNCRsByDefault-JuanVuletich-2022Jun09-10h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5255] on 10 June 2022 at 9:06:19 am'!
!CharacterSet class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 11:11:34'!
          ascii
	"return a set containing just all the 7 bit ASCII Characters"

	| set |
	set _ self new.
	0 to: 127 do: [ :ascii |
		set add: (Character numericValue: ascii) ].
	^set! !
!CharacterSet class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 11:11:23'!
                           nonAscii
	"return a set containing all Characters that are not 7 bit ASCII"

	| set |
	set _ self new.
	128 to: 255 do: [ :ascii |
		set add: (Character numericValue: ascii) ].
	^set! !
!String methodsFor: 'testing' stamp: 'jmv 6/9/2022 15:01:48'!
        isAscii
	"Return true when I am pure 7-bit ASCII.
	This means, for example, that my bytes are also my UTF-8 representation."

	^ String isAscii: self! !
!String class methodsFor: 'services' stamp: 'jmv 6/9/2022 15:01:34'!
  isAscii: aStringOrByteArray
	"Return true if all bytes in argument are less than 128.
	This means it is a pure 7-bit ASCII.
	Valid both for instances of String (possibly with accented latin letters or other Character)
	and for utf-8 encoded ByteArrays.
	In these cases, the bytes represent the same ascii string both as String and as Utf8."

	^ (String
		findFirstInString: aStringOrByteArray
		inSet: `(CharacterSet nonAscii) byteArrayMap`
		startingAt: 1)
			= 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5254-isAscii-primitive-forStringAndUtf8Bytes-JuanVuletich-2022Jun10-09h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5256] on 10 June 2022 at 9:49:11 am'!
!Utf8String methodsFor: 'private' stamp: 'jmv 6/9/2022 12:01:04'!
             privateBytes: utf8ByteArray codePointCount: aNumber
	"Initialize the receiver. If we already know that utf8ByteArray only holds bytes less than 128 (i.e. ASCII characters), initialize 'count'. This is an important optimization."

	bytes _ utf8ByteArray.
	count _ aNumber.
	strideIndex _ nil.
	hash _ nil.! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 13:19:50'!
                          fromUtf8Bytes: utf8ByteArray codePointCount: aNumber
	"Call this method if the number of CodePoints encoded in utf8ByteArray is known.
	This is an important optimization, especially if ASCII (i.e. utfByteArray size = aNumber).
	Note: The received ByteArray argument should not be modified elsewhere. Pass a copy if needed."

	^self basicNew privateBytes: utf8ByteArray codePointCount: aNumber.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/9/2022 13:11:27' prior: 50375106!
                       asUtf8String
	"Answer an instance of the UTF-8 encoded String class"

	| utf8Bytes |
	utf8Bytes _ self asUtf8Bytes.
	^Utf8String fromUtf8Bytes: utf8Bytes codePointCount: self size.! !
!String methodsFor: 'converting' stamp: 'jmv 6/9/2022 12:12:05' prior: 50379434 overrides: 50374465!
   asUtf8Bytes
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray with a valid UTF-8 sequence.
	Ignore any NCRs (Numeric Character References). See #fromUtf8Bytes: "

	| inStream nextChar codePoint |
	"Fast lane."
	self isAscii ifTrue: [ ^self asByteArray ].

	"Need to do UTF-8 encoding."
	^ByteArray streamContents: [ :outStream |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			codePoint _ nextChar codePoint.
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: codePoint ]]! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/10/2022 09:28:43' prior: 50362048!
       fromUtf8Bytes: aByteArray
	"Convert the given bytes from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf8Bytes "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	"Fast lane."
	(String isAscii: aByteArray) ifTrue: [
		^aByteArray asString ].

	"Need to do UTF-8 decoding."
	^self fromUtf8Bytes: aByteArray hex: false trimLastNull: false! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 6/9/2022 14:43:15' prior: 50362265 overrides: 16934202!
                      copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ startIndex-1.
	epilogFirstIndex _ endIndex+1.
	^Utf32String withWords:
		(codePoints copyFrom: 1 to: prologLastIndex),
		replacement asUtf32Words,
		(codePoints
			copyFrom: epilogFirstIndex
			to: codePoints size)! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 6/10/2022 09:39:14' prior: 50364135!
     fromUtf8Bytes: aByteArray

	"Fast lane."
	(String isAscii: aByteArray) ifTrue: [
		^self withWords: aByteArray asWordArray ].

	"Need to do UTF-8 decoding."
	^self withWords: (Utf8String utf32FromUtf8: aByteArray).! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/9/2022 12:36:41' prior: 50365666 overrides: 16934134!
, aString
	^Utf8String fromUtf8Bytes: bytes, aString asUtf8Bytes codePointCount: self size + aString size.! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/9/2022 12:38:34' prior: 50369616!
appendToString: aString

	^Utf8String fromUtf8Bytes: aString asUtf8Bytes, bytes codePointCount: aString size + self size.! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/9/2022 12:41:57' prior: 50351386 overrides: 16934176!
                             copyFrom: startIndex to: stopIndex
	"Return a new string, a copy of me from startIndex to stopIndex, both character indices.
	Signal SubscriptOutOfBounds or CollectionIsEmpty in case of illegal indices."
	
	| startByteIndex stopByteIndex |
	startIndex = (self size+1) ifTrue: [ ^Utf8String empty ].
	stopIndex = 0 ifTrue: [ ^Utf8String empty ].
	self boundsCheck: startIndex. 
	self boundsCheck: stopIndex. 
	startByteIndex := self byteIndexAt: startIndex.
	stopByteIndex := self byteIndexAt: stopIndex.
	stopByteIndex := stopByteIndex + (self encodedByteCountAt: stopByteIndex) - 1.
	^Utf8String
		fromUtf8Bytes: (bytes copyFrom: startByteIndex to: stopByteIndex)
		codePointCount: stopIndex-startIndex+1.! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/9/2022 14:49:21' prior: 50362294 overrides: 16934202!
                    copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| epilogFirstIndex prologLastIndex newBytes replacementBytes |
	prologLastIndex _ (self byteIndexAt: startIndex)-1.
	epilogFirstIndex _ self byteIndexAt: endIndex+1.
	replacementBytes _ replacement asUtf8Bytes.
	newBytes _ (bytes copyFrom: 1 to: prologLastIndex),
		replacementBytes,
		(bytes
			copyFrom: epilogFirstIndex
			to: bytes size).
	^Utf8String fromUtf8Bytes: newBytes codePointCount: (startIndex-1) + replacement size + (self size-endIndex).! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/9/2022 13:00:37' prior: 50376492 overrides: 16934268!
            copyWith: anUnicodeCodePoint

	^Utf8String
		fromUtf8Bytes: bytes, (Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint)
		codePointCount: self size + 1.! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/9/2022 12:58:39' prior: 50375919!
                              substrings
	"
	'  Hello World!! Some  		1234 more  ' substrings
	'  Hello World!! Some  		1234 more  ' asUtf8String substrings
	"
	^ self isAscii
		ifTrue: [ ('' substrings: bytes) collect: [ :eachBytes |
				Utf8String fromUtf8Bytes: eachBytes codePointCount: eachBytes size ]]
		ifFalse: [ ('' substrings: bytes) collect: [ :eachBytes |
				Utf8String fromUtf8Bytes: eachBytes ]].! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/10/2022 09:36:46' prior: 50376499!
        withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"

	| correctedBytes |
	correctedBytes _ '' string: bytes withLineEndings: lineEndingString.
	"The codePointCount trick can be done because the line endings considered are all single byte UTF-8.
	If we ever consider unicode line endings taking more than one byte, this is no longer valid (pass nil instead)."
	^  Utf8String fromUtf8Bytes: correctedBytes codePointCount: self size - bytes size + correctedBytes size.! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 6/10/2022 09:40:57' prior: 50351542!
isAscii
	"Return true when I am pure 7-bit ASCII, which means each character is encoded as one byte."

	^ bytes size = self size! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/10/2022 09:44:05' prior: 50369309!
         byteIndexAt: codePointIndex
	| byteIndex |
	self isAscii ifTrue: [ ^ codePointIndex ].
	codePointIndex = (self size+1) ifTrue: [
		"The position a hypotetical extra code point would start at.
		Useful to find the last byte position for some codePointIndex. See senders."
		^bytes size+1 ].
	byteIndex _ codePointIndex > self stride
		ifTrue: [
			strideIndex ifNil: [ self computeCountAndIndex ].
			strideIndex at: codePointIndex - 1 // self stride ]
		ifFalse: [ 1 ].
	codePointIndex - 1 \\ self stride timesRepeat: [ 
		byteIndex _ byteIndex + (self encodedByteCountAt: byteIndex) ].
	^ byteIndex! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/10/2022 09:42:45' prior: 50369354!
                  computeCountAndIndex
	self isEmpty ifTrue: [
		count _ 0.
		strideIndex _ #().
		^ self ].
	"the number of characters cannot be larger than the byte size"
	bytes size <= self stride
		ifTrue: [ self computeCountNoIndex ]
		ifFalse: [ self computeCountAndIndexFull ]! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/10/2022 09:47:15' prior: 50369365!
computeCountAndIndexFull
	| byteIndex |
	count _ 0.
	strideIndex _ Array streamContents: [ :out |
		byteIndex _ 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count _ count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex _ byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/10/2022 09:41:56' prior: 50369379!
        computeCountNoIndex
	| byteIndex |
	count _ 0.
	strideIndex _ #().
	byteIndex _ 1.
	[ byteIndex <= bytes size ] whileTrue: [
		count _ count + 1.
		byteIndex _ byteIndex + (self encodedByteCountAt: byteIndex) ]! !
!Utf8String methodsFor: 'initialization' stamp: 'jmv 6/9/2022 12:30:42' prior: 50365637 overrides: 16920235!
                             initialize
	"Just an empty string."

	self privateBytes: `#[]` codePointCount: 0.! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 12:44:51' prior: 50351763!
         empty
	"Return the empty Utf8String instance.
	Since my instances are readonly, this could be cached."

	^ self fromUtf8Bytes: `#[]` codePointCount: 0.! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 12:54:51' prior: 50364170!
   fromUtf32Words: aWordArray

	^self fromUtf8Bytes: (Utf8String utf8FromUtf32: aWordArray) codePointCount: aWordArray size.! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 13:19:18' prior: 50362138!
 fromUtf8Bytes: utf8ByteArray
	"Prefer #fromUtf8Bytes:codePointCount: if the number of CodePoints is cheap to know.
	Performance optimization.
	Note: The received ByteArray argument should not be modified elsewhere. Pass a copy if needed."

	^self basicNew privateBytes: utf8ByteArray codePointCount: nil.! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 12:52:15' prior: 50351781 overrides: 16824154!
                      with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	Utf8String with: $a
	Utf8String with: $·
	Utf8String with: Character euro
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint)
		codePointCount: 1.! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/9/2022 12:51:46' prior: 50379238 overrides: 16824160!
                        with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter and otherCharacter.
	Utf8String with: $a
	Utf8String with: $· with: Character euro
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint),
			(Character utf8BytesOfUnicodeCodePoint: otherCharacter codePoint)
		codePointCount: 2.! !
!Utf8Symbol methodsFor: 'converting' stamp: 'jmv 6/9/2022 13:12:48' prior: 50368976 overrides: 50374450!
    asPlainString
	"Answer a plain String, not a Symbol."

	^Utf8String fromUtf8Bytes: bytes codePointCount: self size.! !
!Utf8Symbol class methodsFor: 'private' stamp: 'jmv 6/9/2022 12:33:24' prior: 50368993!
                 basicFromString: aString
	"Private use. Answers an instance that is not yet interned.
	Can break the Symbol invariant: forAllSymbols, (s1 = s2) => (s1 == s2)
	Please don't call lightly."

	| utf8Bytes |
	utf8Bytes _ aString asUtf8Bytes.
	^self basicNew privateBytes: utf8Bytes codePointCount: aString size.! !
!Utf8EncodedStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 6/9/2022 13:16:52' prior: 50376904 overrides: 50376804!
                  streamUpToEnd
	"Answer the contents of our stream, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Leave stream at the end position."

	| utf8 codePointCount |
	codePointCount _ 0.
	utf8 _ ByteArray streamContents: [ :utf8Stream |
		[ stream atEnd ] whileFalse: [
			stream nextUtf8BytesAndCodePointInto: [ :byte1 :byte2 :byte3 :byte4 |
				codePointCount _ codePointCount + 1.
				utf8Stream nextPut: byte1.
				byte2 ifNotNil: [
					utf8Stream nextPut: byte2.
					byte3 ifNotNil: [
						utf8Stream nextPut: byte3.
						byte4 ifNotNil: [
							utf8Stream nextPut: byte4]]]]
				into: nil ]].
	^Utf8String fromUtf8Bytes: utf8 codePointCount: codePointCount.! !
!EncodedWriteStream methodsFor: 'accessing' stamp: 'jmv 6/10/2022 09:37:30' prior: 50377390!
           utf8Contents
	"Answer the Utf8String built so far."

	^Utf8String fromUtf8Bytes: self byteContents.! !
!EncodedByteArrayStreamTest methodsFor: 'tests' stamp: 'jmv 6/9/2022 13:18:20' prior: 50378592!
                         test01

	| utf8String utf32String stringAsIso8859s15 bytes1 bytes2 bytes3 |
	utf8String _ Utf8String fromUtf8Bytes: 'Hello World, Òand˙, ag¸ita. ' asUtf8Bytes, #[208 155 208 190 209 128 208 181 208 188].
	utf32String _ Utf32String withWords: utf8String asUtf32Words.
	stringAsIso8859s15 _ utf8String bytes asString.							"Includes random content, String can't handle full Unicode"

	bytes1 _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: utf8String ].
	self assert: ((EncodedReadStream on: bytes1) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes1) useBytes; contents) equals: bytes1.
	self assert: ((EncodedReadStream on: bytes1) useUtf32String; contents) equals: utf32String.
	self assert: ((EncodedReadStream on: bytes1) useCharacters; contents) equals: stringAsIso8859s15.

	bytes2 _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: utf8String bytes ].
	self assert: ((EncodedReadStream on: bytes2) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes2) useBytes; contents) equals: bytes2.
	self assert: ((EncodedReadStream on: bytes2) useUtf32String; contents) equals: utf32String.
	self assert: ((EncodedReadStream on: bytes2) useCharacters; contents) equals: stringAsIso8859s15.

	bytes3 _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: utf32String ].
	self assert: ((EncodedReadStream on: bytes3) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes3) useBytes; contents) equals: bytes3.
	self assert: ((EncodedReadStream on: bytes3) useUtf32String; contents) equals: utf32String.
	self assert: ((EncodedReadStream on: bytes3) useCharacters; contents) equals: stringAsIso8859s15.! !
!EncodedByteArrayStreamTest methodsFor: 'tests' stamp: 'jmv 6/9/2022 13:18:24' prior: 50378649!
               test02
	"Invalid UTF-8, but possible saved as reasonable ISO 8859-15, with use of full 8 bit range.
	To test invalid utf8 detection, and conversion from 8859-15 to utf."

	| invalidUtf8Bytes validUtf8Bytes utf8String utf32String bytes |

	"Second byte is invalid UTF-8. Created from a String (i.e. ISO 8859-15 bytes), and a valid UTF-8 ByteArray:
	'uÒa ' asByteArray, #[206 188]"
	invalidUtf8Bytes _ #[117 241 97 32 206 188].

	"A correct UTF-8 sequence, created by correct conversion of the String above, and the same valid UTF-8 coda.
	'uÒa ' asUtf8Bytes, #[206 188]"
	validUtf8Bytes _ #[117 195 177 97 32 206 188].
	
	utf8String _ Utf8String fromUtf8Bytes: validUtf8Bytes.
	utf32String _ Utf32String withWords: utf8String asUtf32Words.

	bytes _ ByteArray streamUtf8Contents: [ :stream | stream nextPutAll: invalidUtf8Bytes ].
	self assert: ((EncodedReadStream on: bytes) useUtf8String; contents) equals: utf8String.
	self assert: ((EncodedReadStream on: bytes) useBytes; contents) equals: bytes.
	self assert: ((EncodedReadStream on: bytes) useUtf32String; contents) equals: utf32String.! !
!EncodedFileStreamTest methodsFor: 'tests' stamp: 'jmv 6/9/2022 13:18:28' prior: 50378686!
                              test01

	| bytes utf8String utf32String stringAsIso8859s15 fe1 fe2 fe3 |
	bytes _ 'Hello World, Òand˙, ag¸ita. ' asUtf8Bytes, #[208 155 208 190 209 128 208 181 208 188].
	utf8String _ Utf8String fromUtf8Bytes: bytes.
	utf32String _ Utf32String withWords: utf8String asUtf32Words.
	stringAsIso8859s15 _ utf8String bytes asString.							"Includes random content, String can't handle full Unicode"

	fe1 _ 'xxtes01tUtf8String.txt' asFileEntry.
	fe1 forceWriteStreamDo: [ :stream | stream nextPutAll: utf8String ].
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe1 readStreamDo: [ :strm | strm useBytes; contents ]) equals: bytes.
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.
	self assert: (fe1 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: stringAsIso8859s15.

	fe2 _ 'xxtest01Utf8Bytes.txt' asFileEntry.
	fe2 forceWriteStreamDo: [ :stream | stream nextPutAll: utf8String bytes ].
	self assert: (fe2 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe2 readStreamDo: [ :strm | strm useBytes; contents ]) equals: bytes.
	self assert: (fe2 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.
	self assert: (fe2 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: stringAsIso8859s15.

	fe3 _ 'xxtes01tUtf32String.txt' asFileEntry.
	fe3 forceWriteStreamDo: [ :stream | stream nextPutAll: utf32String ].
	self assert: (fe3 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe3 readStreamDo: [ :strm | strm useBytes; contents ]) equals: bytes.
	self assert: (fe3 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.
	self assert: (fe3 readStreamDo: [ :strm | strm useCharacters; contents ]) equals: stringAsIso8859s15.

	fe1 delete.
	fe2 delete.
	fe3 delete.! !
!EncodedFileStreamTest methodsFor: 'tests' stamp: 'jmv 6/9/2022 13:18:38' prior: 50378749!
                        test02
	"Invalid UTF-8, but possible saved as reasonable ISO 8859-15, with use of full 8 bit range.
	To test invalid utf8 detection, and conversion from 8859-15 to utf."

	| invalidUtf8Bytes validUtf8Bytes utf8String utf32String fe1 |

	"Second byte is invalid UTF-8. Created from a String (i.e. ISO 8859-15 bytes), and a valid UTF-8 ByteArray:
	'uÒa ' asByteArray, #[206 188]"
	invalidUtf8Bytes _ #[117 241 97 32 206 188].

	"A correct UTF-8 sequence, created by correct conversion of the String above, and the same valid UTF-8 coda.
	'uÒa ' asUtf8Bytes, #[206 188]"
	validUtf8Bytes _ #[117 195 177 97 32 206 188].
	
	utf8String _ Utf8String fromUtf8Bytes: validUtf8Bytes.
	utf32String _ Utf32String withWords: utf8String asUtf32Words.
	
	fe1 _ 'xxtest02InvalidUtf8Bytes.txt' asFileEntry.
	fe1 forceWriteStreamDo: [ :stream | stream nextPutAll: invalidUtf8Bytes ].
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf8String; contents ]) equals: utf8String.
	self assert: (fe1 readStreamDo: [ :strm | strm useBytes; contents ]) equals: invalidUtf8Bytes.
	self assert: (fe1 readStreamDo: [ :strm | strm useUtf32String; contents ]) equals: utf32String.

	fe1 delete.! !

Utf8String class removeSelector: #withBytes:!

!methodRemoval: Utf8String class #withBytes: stamp: 'Install-5255-Utf8String-Optimization-Cleanup-JuanVuletich-2022Jun10-09h12m-jmv.001.cs.st 6/16/2022 07:24:53'!
withBytes: aByteArray

	^self basicNew bytes: aByteArray !

Utf8String class removeSelector: #new:!

!methodRemoval: Utf8String class #new: stamp: 'Install-5255-Utf8String-Optimization-Cleanup-JuanVuletich-2022Jun10-09h12m-jmv.001.cs.st 6/16/2022 07:24:53'!
new: sizeRequested
	^self withBytes: (ByteArray new: sizeRequested)!

Utf8String removeSelector: #beAscii!

!methodRemoval: Utf8String #beAscii stamp: 'Install-5255-Utf8String-Optimization-Cleanup-JuanVuletich-2022Jun10-09h12m-jmv.001.cs.st 6/16/2022 07:24:53'!
beAscii
	"Mark me as being pure 7-bit ASCII, which means each character is encoded as one byte"
	
	count := bytes size.
	strideIndex := #().!

Utf8String removeSelector: #bytes:!

!methodRemoval: Utf8String #bytes: stamp: 'Install-5255-Utf8String-Optimization-Cleanup-JuanVuletich-2022Jun10-09h12m-jmv.001.cs.st 6/16/2022 07:24:53'!
bytes: aByteArray
	bytes _ aByteArray!

Utf32String class removeSelector: #new:!

!methodRemoval: Utf32String class #new: stamp: 'Install-5255-Utf8String-Optimization-Cleanup-JuanVuletich-2022Jun10-09h12m-jmv.001.cs.st 6/16/2022 07:24:53'!
new: sizeRequested
	^self withWords: (WordArray new: sizeRequested)!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5255-Utf8String-Optimization-Cleanup-JuanVuletich-2022Jun10-09h12m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5256] on 10 June 2022 at 10:00:18 am'!

WriteStream subclass: #EncodedWriteStream
	instanceVariableNames: 'lastWrittenElement numberOfCodePointsWritten '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #EncodedWriteStream category: #'Collections-Streams' stamp: 'Install-5256-EncodedWriteStream-countCodePointsWritten-JuanVuletich-2022Jun10-09h49m-jmv.001.cs.st 6/16/2022 07:24:53'!
WriteStream subclass: #EncodedWriteStream
	instanceVariableNames: 'lastWrittenElement numberOfCodePointsWritten'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!
!EncodedWriteStream methodsFor: 'private' stamp: 'jmv 6/10/2022 09:50:58' overrides: 50361513!
               on: aCollection
	"Initialize the stream to write over all of aCollection.
	The collection contents are considered useless.
	Overwrite them."

	super on: aCollection.
	lastWrittenElement _ nil.
	numberOfCodePointsWritten _ 0.! !
!EncodedWriteStream methodsFor: 'positioning' stamp: 'jmv 6/9/2022 20:00:15' overrides: 16983048!
                          reset
	super reset.
	lastWrittenElement _ nil.
	numberOfCodePointsWritten _ 0.! !
!EncodedWriteStream methodsFor: 'positioning' stamp: 'jmv 6/9/2022 20:00:04' overrides: 16983053!
            resetToStart
	super resetToStart.
	lastWrittenElement _ nil.
	numberOfCodePointsWritten _ 0.! !
!EncodedWriteStream methodsFor: 'positioning' stamp: 'jmv 6/9/2022 20:01:18' overrides: 16983057!
                              setToEnd 
	super setToEnd.
	lastWrittenElement _ nil.
	numberOfCodePointsWritten _ nil.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/9/2022 14:28:06' prior: 50377225 overrides: 16982981!
         next: anInteger putAll: aString startingAt: startIndex
'--------' print.
thisContext printStack: 10.
self halt.
	lastWrittenElement _ aString at: anInteger.
	"?
	numberOfCodePointsWritten ifNotNil: [
		numberOfCodePointsWritten _ numberOfCodePointsWritten + aString size ]]"! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/10/2022 09:56:59' prior: 50377253 overrides: 50365979!
             nextPutAll: aStringOrBytes
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this stream. All 3 kinds of Strings are UTF-8 encoded."

	| bytes |
	bytes _ aStringOrBytes.
	(aStringOrBytes is: #ByteArray) ifFalse: [
		bytes _ aStringOrBytes asUtf8Bytes.
		numberOfCodePointsWritten ifNotNil: [
			"As aStringOrBytes is a kind of String, not utf-8 byteArray, we can use its size."
			numberOfCodePointsWritten _ numberOfCodePointsWritten + aStringOrBytes size ]].
	super nextPutAll: bytes.
	lastWrittenElement _ aStringOrBytes last.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/10/2022 09:57:27' prior: 50377267!
          nextPutCodePoint: aNumber
	"UTF-8 encoded"

	| n |
	"Save in a temp because #nextPutByte: smashes the ivar."
	n _ numberOfCodePointsWritten ifNotNil: [ numberOfCodePointsWritten + 1 ].
	Character
		evaluate: [ :byte | self nextPutByte: byte ]
		withUtf8BytesOfUnicodeCodePoint: aNumber.
	numberOfCodePointsWritten _ n.! !
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/10/2022 09:55:39' prior: 50377290 overrides: 16983042!
 position: pos

	| m s |
	"Chequear que los senders sepan que estan mandando una posicion a byte!!"
	m _ thisContext sender method.
	thisContext sender receiver == self ifFalse: [
		(EncodedFileStream positionValidatedSenders includes: m) ifFalse: [
			"SendersOfPositionColon _ Set new"
			s _ Smalltalk at: #SendersOfPositionColon ifAbsentPut: [ Set new ].
			(s includes: m) ifFalse: [
				s add: m.
				{ '-------- Sender de #position: '. m. pos} print.
				thisContext printStack: 10 ]]].
	super position: pos.
	lastWrittenElement _ nil.
	numberOfCodePointsWritten _ nil.! !
!EncodedWriteStream methodsFor: 'private' stamp: 'jmv 6/10/2022 09:57:32' prior: 50377363!
  nextPutByte: aByte 
	"Insert the argument at the next position in the Stream represented by the receiver."

	numberOfCodePointsWritten _ nil.	"We can no longer know"
	position >= writeLimit
		ifTrue: [^ self pastEndPutByte: aByte]
		ifFalse: [
			position _ position + 1.
			^collection at: position put: aByte]! !
!EncodedWriteStream methodsFor: 'accessing' stamp: 'jmv 6/9/2022 14:29:47' prior: 50380032!
         utf8Contents
	"Answer the Utf8String built so far."

	^Utf8String fromUtf8Bytes: self byteContents codePointCount: numberOfCodePointsWritten.! !

WriteStream subclass: #EncodedWriteStream
	instanceVariableNames: 'lastWrittenElement numberOfCodePointsWritten'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

!classDefinition: #EncodedWriteStream category: #'Collections-Streams' stamp: 'Install-5256-EncodedWriteStream-countCodePointsWritten-JuanVuletich-2022Jun10-09h49m-jmv.001.cs.st 6/16/2022 07:24:53'!
WriteStream subclass: #EncodedWriteStream
	instanceVariableNames: 'lastWrittenElement numberOfCodePointsWritten'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5256-EncodedWriteStream-countCodePointsWritten-JuanVuletich-2022Jun10-09h49m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5256] on 10 June 2022 at 10:04:03 am'!
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 6/10/2022 10:04:00' prior: 16939433!
             doItProfiling: aBoolean
	"Set the context to include pool vars of the model.  Then evaluate.
	Print the result on the Transcript"
	| answer |
	answer _ self
		evaluateSelectionAndDo: [ :result |
			Transcript finishEntry.
			[result print]
				on: UnhandledError
				do: [:ex | 'printing doIt result failed (remove handler in #doItProfiling: if you prefer the debugger).' print]]
		ifFail: nil
		profiled: aBoolean.
	morph formatAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5257-tweak-JuanVuletich-2022Jun10-10h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5258] on 10 June 2022 at 12:55:45 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/10/2022 12:21:38'!
    asUtf8BytesOrByteString
	"Similar to #asUtf8Bytes.
	May answer an instance of String as an optimization.
	See senders"
	^self asUtf8Bytes! !
!String methodsFor: 'converting' stamp: 'jmv 6/10/2022 12:21:55' overrides: 50380481!
                             asUtf8BytesOrByteString
	"Similar to #asUtf8Bytes.
	May answer an instance of String as an optimization.
	See senders"

	| inStream nextChar codePoint |
	"Fast lane."
	self isAscii ifTrue: [ ^self ].

	"Need to do UTF-8 encoding."
	^ByteArray streamContents: [ :outStream |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			codePoint _ nextChar codePoint.
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: codePoint ]]! !
!String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:05:07' prior: 50374980!
        < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString > self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 1! !
!String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:05:43' prior: 50374991!
          <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString >= self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:05:20' prior: 50375028!
                            > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString < self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) = 3! !
!String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:05:32' prior: 50375039!
           >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString <= self ].

	^ (self compare: self with: aString collated: CaseSensitiveOrder) >= 2! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:54:15' prior: 50368600 overrides: 16934001!
    = aString
	"Answer whether the receiver sorts equally as anUtf32String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Expensive. Assume it is extremely unlikely."
self flag: #slowUnicode.
	aString isUtf32String ifFalse: [
		^self asUtf8String = aString ].

	^ codePoints = aString words! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/10/2022 12:26:56' prior: 50375410!
                            findString: subString startingAt: start 
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	^ '' findString: subString asUtf8BytesOrByteString in: bytes startingAt: start! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/10/2022 12:48:18' prior: 50375420!
             findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

"caseSensitive = false is very expensive. Do better."
self flag: #slowUnicode.

	^caseSensitive
		ifTrue: [ self findString: key startingAt: start ]
		ifFalse: [ self asLowercase findString: key asLowercase startingAt: start ]! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/10/2022 12:27:05' prior: 50379001 overrides: 16933739!
                          indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	index _ '' findString: subString asUtf8BytesOrByteString in: bytes startingAt: start.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/10/2022 12:22:26' prior: 50379739 overrides: 16934134!
                   , aString
	^Utf8String fromUtf8Bytes: bytes, aString asUtf8BytesOrByteString codePointCount: self size + aString size.! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/10/2022 12:25:40' prior: 50379779 overrides: 16934202!
                               copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| epilogFirstIndex prologLastIndex newBytes replacementBytes |
	prologLastIndex _ (self byteIndexAt: startIndex)-1.
	epilogFirstIndex _ self byteIndexAt: endIndex+1.
	replacementBytes _ replacement asUtf8BytesOrByteString.
	newBytes _ (bytes copyFrom: 1 to: prologLastIndex),
		replacementBytes,
		(bytes
			copyFrom: epilogFirstIndex
			to: bytes size).
	^Utf8String fromUtf8Bytes: newBytes codePointCount: (startIndex-1) + replacement size + (self size-endIndex).! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:22:34' prior: 50374948!
                 < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) = 1! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:23:07' prior: 50374956!
                       <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) <= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:24:20' prior: 50379546 overrides: 16934001!
                      = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	(self isAscii and: [	aString isByteString ]) ifTrue: [
		"Fast lane."
		^'' is: bytes sameAs: aString ].

	"May need to do UTF-8 encoding."
	^ '' is: bytes sameAs: aString asUtf8Bytes.! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:24:26' prior: 50374964!
                            > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) = 3! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:24:29' prior: 50374972!
                        >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) >= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 12:48:25' prior: 50375058!
           sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

self flag: #slowUnicode.
	^self asLowercase = aString asLowercase! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5258-String-Utf8String-tweaks-JuanVuletich-2022Jun10-12h40m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5259] on 10 June 2022 at 3:00:53 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/10/2022 14:40:29' prior: 50375368!
       asLowercase
	"Answer a String made up from the receiver whose characters are all 
	lowercase."

	^ self collect: [ :each | each asLowercase ].! !
!String methodsFor: 'converting' stamp: 'jmv 6/10/2022 14:39:20' overrides: 50380753!
                        asLowercase
	"Answer a String made up from the receiver whose characters are all 
	lowercase."

	^ self copy asPlainString translateToLowercase! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 14:44:47'!
       sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	self = aString ifTrue: [ ^true ].
self flag: #slowUnicode.
	^self asLowercase = aString asLowercase! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/10/2022 14:49:49' prior: 50368827!
                      asLowercase
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^UnicodeCodePoint codePoint: ch asLowercase codePoint ].
	^self! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 6/10/2022 14:56:13' prior: 50350982!
                  isLastLineSeparator

	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12 16r0085 16r2028 16r2029) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	^false.
	! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 6/10/2022 14:54:09' prior: 50351005!
                  isLastSeparator

	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/10/2022 14:56:07' prior: 50351313!
        isLastLineSeparator

	| s butButLastByte butLastByte lastByte |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	s = 1 ifTrue: [ ^false ].
	lastByte _ bytes at: s.
	butLastByte _ bytes at: s-1.
	(butLastByte = 16rC2 and: [ lastByte = 16r85 ]) ifTrue: [ ^true ]. "Next Line, NEL"
	s = 2 ifTrue: [ ^false ].
	butButLastByte _ bytes at: s-2.
	(butButLastByte = 16rE2 and: [butLastByte = 16r80 and: [ "Line Separator and Paragraph Separator"
		lastByte = 16rA8 or: [lastByte = 16rA9]]]) ifTrue: [ ^true ].
	^false.
	! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/10/2022 14:54:00' prior: 50351348!
           isLastSeparator

	| s |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/10/2022 14:44:51' prior: 50380736!
                  sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	self = aString ifTrue: [ ^true ].
self flag: #slowUnicode.
	^self asLowercase = aString asLowercase! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5259-asLowercase-sameAs-JuanVuletich-2022Jun10-14h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5259] on 10 June 2022 at 3:17:14 pm'!
!Utf32String methodsFor: 'testing' stamp: 'jmv 6/10/2022 15:08:28'!
   isAscii
	"Return true when I am pure 7-bit ASCII."

	^ codePoints max < 128! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5260-Utf32String-isAscii-JuanVuletich-2022Jun10-15h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5259] on 10 June 2022 at 9:24:11 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/28/2015 10:03' overrides: 16822822!
          adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with a number, convert me to a number."

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/28/2015 10:03' overrides: 16822832!
                     adaptToPoint: rcvr andSend: selector
	"If I am involved in arithmetic with a point, convert me to a number."

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30' overrides: 16822868!
                        * arg

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:29' overrides: 16822872!
                               + arg

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30' overrides: 16822876!
                               - arg

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'arithmetic' stamp: 'pb 5/25/2016 01:13' overrides: 16822880!
                               / arg
	"If working with file paths, just use $/
	Or better yet, use DirectoryEntry protocol"

	self shouldNotImplement! !
!CharacterSequence methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30' overrides: 16822884!
         // arg

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'arithmetic' stamp: 'jmv 9/7/2011 07:30' overrides: 16822888!
                              \\ arg

	self shouldNotImplement.! !

String removeSelector: #+!

!methodRemoval: String #+ stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
+ arg

	self shouldNotImplement.
"	^ arg adaptToString: self andSend: #+"!

String removeSelector: #\\!

!methodRemoval: String #\\ stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
\\ arg

	self shouldNotImplement.
"	^ arg adaptToString: self andSend: #\\"!

String removeSelector: #*!

!methodRemoval: String #* stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
* arg

	self shouldNotImplement.
"	^ arg adaptToString: self andSend: #*"!

String removeSelector: #-!

!methodRemoval: String #- stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
- arg

	self shouldNotImplement.
"	^ arg adaptToString: self andSend: #-"!

String removeSelector: #adaptToPoint:andSend:!

!methodRemoval: String #adaptToPoint:andSend: stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
adaptToPoint: rcvr andSend: selector
	"If I am involved in arithmetic with a point, convert me to a number."

"	^ rcvr perform: selector with: self asNumber"
	self shouldNotImplement.!

String removeSelector: #//!

!methodRemoval: String #// stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
// arg

	self shouldNotImplement.
"	^ arg adaptToString: self andSend: #//"!

String removeSelector: #/!

!methodRemoval: String #/ stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
/ arg
	"If working with file paths, just use $/
	Or better yet, use DirectoryEntry protocol"

	self shouldNotImplement!

String removeSelector: #adaptToNumber:andSend:!

!methodRemoval: String #adaptToNumber:andSend: stamp: 'Install-5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st 6/16/2022 07:24:53'!
adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with a number, convert me to a number."

"	^ rcvr perform: selector with: self asNumber"
	self shouldNotImplement.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5261-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h21m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5259] on 10 June 2022 at 9:35:30 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/10/2022 21:29:53' overrides: 16822806!
                      adaptToCollection: rcvr andSend: selector
	"If I am involved in arithmetic with a number, convert me to a number."

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'converting' stamp: 'Squeak1.0 9/20/1996 10:50:05' overrides: 16823613!
        truncateTo: smallSize
	"return myself or a copy shortened to smallSize.  1/18/96 sw"

	^ self size <= smallSize
		ifTrue:
			[self]
		ifFalse:
			[self copyFrom: 1 to: smallSize]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/28/2015 10:03' prior: 50380865 overrides: 16822822!
                            adaptToNumber: rcvr andSend: selector
	"If I am involved in arithmetic with a number, convert me to a number."

	self shouldNotImplement.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/28/2015 10:03' prior: 50380873 overrides: 16822832!
     adaptToPoint: rcvr andSend: selector
	"If I am involved in arithmetic with a point, convert me to a number."

	self shouldNotImplement.! !

String removeSelector: #truncateTo:!

!methodRemoval: String #truncateTo: stamp: 'Install-5262-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h24m-jmv.001.cs.st 6/16/2022 07:24:53'!
truncateTo: smallSize
	"return myself or a copy shortened to smallSize.  1/18/96 sw"

	^ self size <= smallSize
		ifTrue:
			[self]
		ifFalse:
			[self copyFrom: 1 to: smallSize]!

String removeSelector: #adaptToCollection:andSend:!

!methodRemoval: String #adaptToCollection:andSend: stamp: 'Install-5262-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h24m-jmv.001.cs.st 6/16/2022 07:24:53'!
adaptToCollection: rcvr andSend: selector
	"If I am involved in arithmetic with a collection, convert me to a number."

	^ rcvr perform: selector with: self asNumber!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5262-MoveUpToCharacterSequence-JuanVuletich-2022Jun10-21h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5261] on 11 June 2022 at 3:34:09 pm'!
!Utf8String class methodsFor: 'services' stamp: 'jmv 6/11/2022 15:33:28'!
             utf8FromUtf16: utf16ByteArray
	"Convert the given string from UTF-16 to UTF-8.
	Use BOM if present."

	| codePoint isBigEndian startIndex |
	isBigEndian _ false. "best guess"
	startIndex _ 1.
	(utf16ByteArray unsignedShortAt: 1 bigEndian: true) = 16rFEFF ifTrue: [
		isBigEndian _ true.
		startIndex _ 3 ].
	(utf16ByteArray unsignedShortAt: 1 bigEndian: false) = 16rFEFF  ifTrue: [
		isBigEndian _ false.
		startIndex _ 3 ].
	^ByteArray streamContents: [ :strm |
		startIndex to: utf16ByteArray size by: 2 do: [ :index |
			codePoint _ utf16ByteArray unsignedShortAt: index bigEndian: isBigEndian.
			Character
				evaluate: [ :byte | strm nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: codePoint ]].! !
!Utf8String class methodsFor: 'services' stamp: 'jmv 6/11/2022 15:32:35' prior: 50364054!
utf8FromUtf32: aWordArray
	"Convert the given string from UTF-32 to UTF-8"

	^ByteArray streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			Character
				evaluate: [ :byte | strm nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: codePoint ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5263-Minimal-UTF-16-support-JuanVuletich-2022Jun11-15h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5262] on 11 June 2022 at 5:18:55 pm'!
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/11/2022 15:50:52'!
          asUppercase
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^UnicodeCodePoint codePoint: ch asUppercase codePoint ].
	^self! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 11/30/2010 19:39'!
                             asCamelCase
	"Answer a new String, without any whitespace, and with words capitalized (Except for the first one)
	' how do you do? ' asCamelCase
	' how do you do? ' asUtf8String asCamelCase
	"
	^ String streamContents: [ :outStream | | inStream capitalize wroteSome |
		wroteSome _ false.
		capitalize _ false.
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [ | c |
			c _ inStream next.
			c isSeparator
				ifTrue: [ capitalize _ true ]
				ifFalse: [
					capitalize & wroteSome ifTrue: [ c _ c asUppercase ].
					outStream nextPut: c.
					wroteSome _ true.
					capitalize _ false ]]]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/11/2022 15:51:30'!
                 asUppercase
	"Answer a String made up from the receiver whose characters are all 
	uppercase."

	^ self collect: [ :each | each asUppercase ].! !
!CharacterSequence methodsFor: 'converting' stamp: 'sma 5/20/2000 17:17'!
    romanNumber
	"
	2022 printStringRoman romanNumber
	"
	| value v1 v2 |
	value _ v1 _ v2 _ 0.
	self reverseDo:
		[:each |
		v1 _ #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).
		v1 >= v2
			ifTrue: [value _ value + v1]
			ifFalse: [value _ value - v1].
		v2 _ v1].
	^ value! !
!CharacterSequence methodsFor: 'text conversion emphasis' stamp: 'len 6/3/2019 10:24:00'!
         bold
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText bold! !
!CharacterSequence methodsFor: 'text conversion emphasis' stamp: 'len 6/3/2019 10:24:16'!
              italic
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText italic! !
!CharacterSequence methodsFor: 'text conversion emphasis' stamp: 'jmv 9/3/2019 10:17:21'!
          pointSize: pointSize
	"Stuff like
	('Hello World' pointSize: 22) edit
	"
	^self asText pointSize: pointSize! !
!CharacterSequence methodsFor: 'text conversion emphasis' stamp: 'len 6/6/2016 02:14'!
                          struck
	^self asText struck! !
!CharacterSequence methodsFor: 'text conversion emphasis' stamp: 'len 6/3/2019 10:24:18'!
       sub
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText sub! !
!CharacterSequence methodsFor: 'text conversion emphasis' stamp: 'len 6/3/2019 10:24:20'!
                super
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText super! !
!CharacterSequence methodsFor: 'text conversion emphasis' stamp: 'len 6/3/2019 10:24:24'!
            under
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText under! !
!CharacterSequence methodsFor: 'text conversion attributes' stamp: 'jmv 9/3/2019 10:08:21'!
          centered
	"Stuff like
	('Hello world' centered ) edit
	"
	^self asText centered! !
!CharacterSequence methodsFor: 'text conversion attributes' stamp: 'jmv 9/3/2019 10:08:52'!
                 justified
	"Stuff like
	('Hello world' justified ) edit
	"
	^self asText justified! !
!CharacterSequence methodsFor: 'text conversion attributes' stamp: 'jmv 9/3/2019 10:09:50'!
              leftFlush
	"Stuff like
	('Hello world' leftFlush ) edit
	"
	^self asText leftFlush! !
!CharacterSequence methodsFor: 'text conversion attributes' stamp: 'jmv 9/3/2019 10:10:05'!
              rightFlush
	"Stuff like
	('Hello world' rightFlush ) edit
	"
	^self asText rightFlush! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:29:49'!
                black
	"Stuff like
	'Hello world' black edit
	"
	^self asText black! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:29:58'!
  blue
	"Stuff like
	'Hello world' blue edit
	"
	^self asText blue! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:30:04'!
     cyan
	"Stuff like
	'Hello world' cyan edit
	"
	^self asText cyan! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:30:11'!
     gray
	"Stuff like
	'Hello world' gray edit
	"
	^self asText gray! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:30:19'!
     green
	"Stuff like
	'Hello world' green edit
	"
	^self asText green! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:31:04'!
  magenta
	"Stuff like
	'Hello world' magenta edit
	"
	^self asText magenta! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:31:17'!
                            red
	"Stuff like
	'Hello world' red edit
	"
	^self asText red! !
!CharacterSequence methodsFor: 'text conversion color' stamp: 'jmv 9/3/2019 10:31:27'!
        yellow
	"Stuff like
	'Hello world' yellow edit
	"
	^self asText yellow! !
!Integer methodsFor: 'printing' stamp: 'nice 12/13/2009 17:59' prior: 16875534!
      printStringRoman
	"
	2022 printStringRoman romanNumber
	"
	^String streamContents: [:stream | | integer |
		integer := self negative ifTrue: [stream nextPut: $-. self negated] ifFalse: [self].
		integer // 1000 timesRepeat: [stream nextPut: $M].
		integer
			romanDigits: 'MDC' for: 100 on: stream;
			romanDigits: 'CLX' for: 10 on: stream;
			romanDigits: 'XVI' for: 1 on: stream]! !

String removeSelector: #leftFlush!

!methodRemoval: String #leftFlush stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
leftFlush
	"Stuff like
	('Hello world' leftFlush ) edit
	"
	^self asText leftFlush!

String removeSelector: #asCamelCase!

!methodRemoval: String #asCamelCase stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
asCamelCase
	"Answer a new String, without any whitespace, and with words capitalized (Except for the first one)
	' how do you do? ' asCamelCase
	"
	^ String streamContents: [ :outStream | | inStream capitalize wroteSome |
		wroteSome _ false.
		capitalize _ false.
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [ | c |
			c _ inStream next.
			c isSeparator
				ifTrue: [ capitalize _ true ]
				ifFalse: [
					capitalize & wroteSome ifTrue: [ c _ c asUppercase ].
					outStream nextPut: c.
					wroteSome _ true.
					capitalize _ false ]]]!

String removeSelector: #cyan!

!methodRemoval: String #cyan stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
cyan
	"Stuff like
	'Hello world' cyan edit
	"
	^self asText cyan!

String removeSelector: #pointSize:!

!methodRemoval: String #pointSize: stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
pointSize: pointSize
	"Stuff like
	('Hello World' pointSize: 22) edit
	"
	^self asText pointSize: pointSize!

String removeSelector: #struck!

!methodRemoval: String #struck stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
struck
	^self asText struck!

String removeSelector: #justified!

!methodRemoval: String #justified stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
justified
	"Stuff like
	('Hello world' justified ) edit
	"
	^self asText justified!

String removeSelector: #romanNumber!

!methodRemoval: String #romanNumber stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
romanNumber
	| value v1 v2 |
	value _ v1 _ v2 _ 0.
	self reverseDo:
		[:each |
		v1 _ #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).
		v1 >= v2
			ifTrue: [value _ value + v1]
			ifFalse: [value _ value - v1].
		v2 _ v1].
	^ value!

String removeSelector: #black!

!methodRemoval: String #black stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
black
	"Stuff like
	'Hello world' black edit
	"
	^self asText black!

String removeSelector: #super!

!methodRemoval: String #super stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
super
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText super!

String removeSelector: #yellow!

!methodRemoval: String #yellow stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
yellow
	"Stuff like
	'Hello world' yellow edit
	"
	^self asText yellow!

String removeSelector: #blue!

!methodRemoval: String #blue stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
blue
	"Stuff like
	'Hello world' blue edit
	"
	^self asText blue!

String removeSelector: #centered!

!methodRemoval: String #centered stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
centered
	"Stuff like
	('Hello world' centered ) edit
	"
	^self asText centered!

String removeSelector: #green!

!methodRemoval: String #green stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
green
	"Stuff like
	'Hello world' green edit
	"
	^self asText green!

String removeSelector: #sub!

!methodRemoval: String #sub stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
sub
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText sub!

String removeSelector: #bold!

!methodRemoval: String #bold stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
bold
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText bold!

String removeSelector: #italic!

!methodRemoval: String #italic stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
italic
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText italic!

String removeSelector: #magenta!

!methodRemoval: String #magenta stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
magenta
	"Stuff like
	'Hello world' magenta edit
	"
	^self asText magenta!

String removeSelector: #gray!

!methodRemoval: String #gray stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
gray
	"Stuff like
	'Hello world' gray edit
	"
	^self asText gray!

String removeSelector: #under!

!methodRemoval: String #under stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
under
	"Stuff like
	('X' italic, '2' super, ' + ', 'H' bold, 'ij' sub, ' + ', 'lim' italic under, 'z  Å' sub, '(1 / z)' ) edit
	"
	^self asText under!

String removeSelector: #red!

!methodRemoval: String #red stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
red
	"Stuff like
	'Hello world' red edit
	"
	^self asText red!

String removeSelector: #rightFlush!

!methodRemoval: String #rightFlush stamp: 'Install-5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st 6/16/2022 07:24:53'!
rightFlush
	"Stuff like
	('Hello world' rightFlush ) edit
	"
	^self asText rightFlush!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5264-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-17h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5263] on 11 June 2022 at 8:49:54 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'di 11/15/1998 16:53'!
                           includesSubstring: aString caseSensitive: caseSensitive
	
	^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 6/11/2022 19:15:43' overrides: 16933668!
                      indexOf: aCharacter

	^self indexOf: aCharacter startingAt: 1! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 6/11/2022 16:21:15'!
                   indexOfAnyOf: aCharacterSet
	"returns the index of the first character in the given set, starting from start"

	^ self indexOfAnyOf: aCharacterSet  startingAt: 1 ifAbsent: 0! !
!CharacterSequence methodsFor: 'comparing' stamp: 'di 11/19/1998 13:37'!
      match: text
	"Answer whether text matches the pattern in this string.
	Matching ignores upper/lower case differences.
	Where this string contains #, text may contain any character.
	Where this string contains *, text may contain any sequence of characters."

	^ self startingAt: 1 match: text startingAt: 1
"
	'*'			match: 'zort' true
	'*baz'		match: 'mobaz' true
	'*baz'		match: 'mobazo' false
	'*baz*'		match: 'mobazo' true
	'*baz*'		match: 'mozo' false
	'foo*'		match: 'foozo' true
	'foo*'		match: 'bozo' false
	'foo*baz'	match: 'foo23baz' true
	'foo*baz'	match: 'foobaz' true
	'foo*baz'	match: 'foo23bazo' false
	'foo'		match: 'Foo' true
	'foo*baz*zort' match: 'foobazort' false
	'foo*baz*zort' match: 'foobazzort' false
	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true
	'*foo*zort'	match: 'afoodezortorfoo3zort' true
"! !
!CharacterSequence methodsFor: 'comparing' stamp: 'ul 11/14/2010 06:02'!
                            startingAt: keyStart match: text startingAt: textStart
	"Answer whether text matches the pattern in this string.
	Matching ignores upper/lower case differences.
	Where this string contains #, text may contain any character.
	Where this string contains *, text may contain any sequence of characters."
	| anyMatch matchStart matchEnd i matchStr j ii jj |
	i := keyStart.
	j := textStart.

	"Check for any #'s"
	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].
	(self at: i) = $#] whileTrue:
		["# consumes one char of key and one char of text"
		j > text size ifTrue: [^ false "no more text"].
		i := i+1.  j := j+1].

	"Then check for *"
	(self at: i) = $*
		ifTrue: [i = self size ifTrue:
					[^ true "Terminal * matches all"].
				"* means next match string can occur anywhere"
				anyMatch := true.
				matchStart := i + 1]
		ifFalse: ["Otherwise match string must occur immediately"
				anyMatch := false.
				matchStart := i].

	"Now determine the match string"
	matchEnd := self size.
	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '** not valid -- use * instead'].
		matchEnd := ii-1].
	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '*# not valid -- use #* instead'].
		matchEnd := matchEnd min: ii-1].
	matchStr := self copyFrom: matchStart to: matchEnd.

	"Now look for the match string"
	[jj := text findString: matchStr startingAt: j caseSensitive: false.
	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]
		whileTrue:
		["Found matchStr at jj.  See if the rest matches..."
		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:
			[^ true "the rest matches -- success"].
		"The rest did not match."
		anyMatch ifFalse: [^ false].
		"Preceded by * -- try for a later match"
		j := j+1].
	^ false "Failed to find the match string"! !
!String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 16:11:05'!
           findStringIgnoreCase: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0.
	Ignore case"

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseInsensitiveOrder.! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 16:29:52' overrides: 16933699!
                            indexOf: anUnicodeCodePoint  startingAt: start  ifAbsent: aBlock
	| startByte codePointBytes answer foundByte |
	anUnicodeCodePoint isCharacter ifFalse: [ ^ aBlock value ].
	startByte _ self byteIndexAt: start.
	codePointBytes _ Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint.
	foundByte _ '' findString: codePointBytes in: bytes startingAt: startByte.
	answer _ self codePointIndexAt: foundByte.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/11/2022 19:30:22' overrides: 50374444!
   asByteString
	"Answer an instance of the Byte oriented String class"

	"Fast lane."
	self isAscii ifTrue: [
		^bytes asString ].

	"Need to do UTF-8 decoding and possible NCR generation."
	^super asByteString! !
!ByteArray methodsFor: 'accessing' stamp: 'jmv 6/11/2022 19:14:09' overrides: 16933699!
                    indexOf: anInteger startingAt: start ifAbsent: aBlock

	| ans |
	(anInteger isInteger and: [
		anInteger >= 0 and: [
		anInteger <= 255 ] ]) ifFalse: [ ^0 ].
	ans _ String indexOfByte: anInteger inString: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/11/2022 19:39:00' prior: 50375099!
   asUtf32String
	"Answer an instance of the UTF-32 encoded String class"
self flag: #slowUnicode.
	^Utf32String fromUtf8Bytes: self asUtf8Bytes.! !
!String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 19:46:54' prior: 50375512!
                             findString: subString startingAt: start 
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	subString isByteString ifFalse: [
		(subString isUtf8String and: [subString isAscii])  "Use cheapest tests and conversion possible."
			ifTrue: [ ^self findString: subString asByteString startingAt: start  ].
		^self asUtf8String findString: subString startingAt: start ].
	^ self findString: subString in: self startingAt: start! !
!String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 19:13:48' prior: 50368345 overrides: 16933699!
  indexOf: aCharacter  startingAt: start  ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	ans _ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 19:48:30' prior: 50375526 overrides: 16933739!
                  indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isByteString ifFalse: [
		(subString isUtf8String and: [subString isAscii])  "Use cheapest tests and conversion possible."
			ifTrue: [ ^self indexOfSubCollection: subString asByteString
						startingAt: start ifAbsent: exceptionBlock ].
		^self asUtf8String indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index _ self findString: subString in: self startingAt: start.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 19:47:00' prior: 50375540!
   is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	subString isByteString ifFalse: [
		(subString isUtf8String and: [subString isAscii])  "Use cheapest tests and conversion possible."
			ifTrue: [ ^self is: subString asByteString substringAt: index ].
		^self asUtf8String is: subString substringAt: index ].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	(self basicAt: index) = (subString basicAt: 1) ifFalse: [ ^false ].
	^(self findString: subString in: self startingAt: index) = index! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/11/2022 19:30:25' prior: 50379686!
                        fromUtf8Bytes: aByteArray
	"Convert the given bytes from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf8Bytes "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	"Fast lane."
	(String isAscii: aByteArray) ifTrue: [
		^aByteArray asString ].

	"Need to do UTF-8 decoding and possible NCR generation."
	^self fromUtf8Bytes: aByteArray hex: false trimLastNull: false! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 20:01:25' prior: 50380585!
            findString: subString startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	| arg |
	arg _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].

	"Do UTF-8 encoding as needed."
	^ '' findString: arg in: bytes startingAt: start! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 16:12:20' prior: 50380596!
                            findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	caseSensitive ifTrue: [
		^self findString: key startingAt: start ].

	self isAscii ifTrue: [
		key isAscii
			ifTrue: [
				"Fast lane"
				^'' findStringIgnoreCase: key in: bytes startingAt: start ]
			ifFalse: [
				"Won't be found"
				^0 ]].

"caseSensitive = false is very expensive. Do better."
self flag: #slowUnicode.
	^self asLowercase findString: key asLowercase startingAt: start! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/11/2022 20:03:12' prior: 50380615 overrides: 16933739!
                    indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index arg |
	arg _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	index _ '' findString: arg in: bytes startingAt: start.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:36:23' prior: 50380665!
                         < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) = 1].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) = 1]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) = 1! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:36:28' prior: 50380676!
                     <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) <= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) <= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) <= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:22:58' prior: 50380688 overrides: 16934001!
                  = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	(self isAscii and: [	aString isByteString ]) ifTrue: [
		"Fast lane."
		^'' is: bytes sameAs: aString ].
	
	aString isUtf8String ifTrue: [
		self isAscii = aString isAscii ifFalse: [
			^false ]].

	"May need to do UTF-8 encoding."
	^ '' is: bytes sameAs: aString asUtf8Bytes.! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:36:33' prior: 50380714!
> aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) = 3].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) = 3]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) = 3! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:36:37' prior: 50380725!
                      >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) >= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) >= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) >= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:01:14' prior: 50379011!
       is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize subStringBytes |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	subStringBytes _ subString asUtf8Bytes.
	subStringBytes _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	(bytes at: index) = (subStringBytes byteAt: 1) ifFalse: [ ^false ].
	^('' findString: subStringBytes in: bytes startingAt: index) = index! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:44:31' prior: 50380835!
                        sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	self size = aString size ifFalse: [
		^false ].

	"Fast lane. Use String implementation for ASCII only instances."
	(self isAscii and: [	aString isByteString ]) ifTrue: [
		^self asByteString sameAs: aString ].
	aString isUtf8String ifTrue: [
		self isAscii = aString isAscii ifFalse: [
			^false ].
		(self isAscii and: [aString isAscii]) ifTrue: [
			^self asByteString sameAs: aString asByteString ]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #slowUnicode.
	^self asLowercase = aString asLowercase! !

ByteArray removeSelector: #indexOf:startingAt:!

!methodRemoval: ByteArray #indexOf:startingAt: stamp: 'Install-5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st 6/16/2022 07:24:53'!
indexOf: anInteger startingAt: start

	(anInteger isInteger and: [
		anInteger >= 0 and: [
		anInteger <= 255 ] ]) ifFalse: [ ^0 ].
	^String indexOfByte: anInteger inString: self startingAt: start!

String removeSelector: #match:!

!methodRemoval: String #match: stamp: 'Install-5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st 6/16/2022 07:24:53'!
match: text
	"Answer whether text matches the pattern in this string.
	Matching ignores upper/lower case differences.
	Where this string contains #, text may contain any character.
	Where this string contains *, text may contain any sequence of characters."

	^ self startingAt: 1 match: text startingAt: 1
"
	'*'			match: 'zort' true
	'*baz'		match: 'mobaz' true
	'*baz'		match: 'mobazo' false
	'*baz*'		match: 'mobazo' true
	'*baz*'		match: 'mozo' false
	'foo*'		match: 'foozo' true
	'foo*'		match: 'bozo' false
	'foo*baz'	match: 'foo23baz' true
	'foo*baz'	match: 'foobaz' true
	'foo*baz'	match: 'foo23bazo' false
	'foo'		match: 'Foo' true
	'foo*baz*zort' match: 'foobazort' false
	'foo*baz*zort' match: 'foobazzort' false
	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true
	'*foo*zort'	match: 'afoodezortorfoo3zort' true
"!

String removeSelector: #indexOf:!

!methodRemoval: String #indexOf: stamp: 'Install-5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st 6/16/2022 07:24:53'!
indexOf: aCharacter

	aCharacter isCharacter ifFalse: [^ 0].
	^ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: 1.!

String removeSelector: #includesSubstring:caseSensitive:!

!methodRemoval: String #includesSubstring:caseSensitive: stamp: 'Install-5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st 6/16/2022 07:24:53'!
includesSubstring: aString caseSensitive: caseSensitive
	
	^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0!

String removeSelector: #indexOf:startingAt:!

!methodRemoval: String #indexOf:startingAt: stamp: 'Install-5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st 6/16/2022 07:24:53'!
indexOf: aCharacter  startingAt: start

	aCharacter isCharacter ifFalse: [^ 0].
	^ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: start.!

String removeSelector: #indexOfAnyOf:!

!methodRemoval: String #indexOfAnyOf: stamp: 'Install-5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st 6/16/2022 07:24:53'!
indexOfAnyOf: aCharacterSet
	"returns the index of the first character in the given set, starting from start"

	^String findFirstInString: self inSet: aCharacterSet byteArrayMap startingAt: 1!

String removeSelector: #startingAt:match:startingAt:!

!methodRemoval: String #startingAt:match:startingAt: stamp: 'Install-5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st 6/16/2022 07:24:53'!
startingAt: keyStart match: text startingAt: textStart
	"Answer whether text matches the pattern in this string.
	Matching ignores upper/lower case differences.
	Where this string contains #, text may contain any character.
	Where this string contains *, text may contain any sequence of characters."
	| anyMatch matchStart matchEnd i matchStr j ii jj |
	i := keyStart.
	j := textStart.

	"Check for any #'s"
	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].
	(self at: i) = $#] whileTrue:
		["# consumes one char of key and one char of text"
		j > text size ifTrue: [^ false "no more text"].
		i := i+1.  j := j+1].

	"Then check for *"
	(self at: i) = $*
		ifTrue: [i = self size ifTrue:
					[^ true "Terminal * matches all"].
				"* means next match string can occur anywhere"
				anyMatch := true.
				matchStart := i + 1]
		ifFalse: ["Otherwise match string must occur immediately"
				anyMatch := false.
				matchStart := i].

	"Now determine the match string"
	matchEnd := self size.
	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '** not valid -- use * instead'].
		matchEnd := ii-1].
	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '*# not valid -- use #* instead'].
		matchEnd := matchEnd min: ii-1].
	matchStr := self copyFrom: matchStart to: matchEnd.

	"Now look for the match string"
	[jj := text findString: matchStr startingAt: j caseSensitive: false.
	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]
		whileTrue:
		["Found matchStr at jj.  See if the rest matches..."
		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:
			[^ true "the rest matches -- success"].
		"The rest did not match."
		anyMatch ifFalse: [^ false].
		"Preceded by * -- try for a later match"
		j := j+1].
	^ false "Failed to find the match string"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5265-Optimizations-MoveUpToCharacterSequence-JuanVuletich-2022Jun11-19h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5263] on 11 June 2022 at 7:06:25 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:22:17'!
       asDate
	"Many allowed forms, see Date>>#readFrom:
		'2014/6/30' asDate.
		'2014/6/30' asUtf8String asDate.
		'70/12/30' asDate.
		'70/12/30' asUtf8String asDate.
		'12/30/70' asDate.
		'12/30/70' asUtf8String asDate.
		'30/12/70' asDate.
		'30/12/70' asUtf8String asDate.
		'4/5/6' asDate.
		'4/5/6' asUtf8String asDate.
		'15 April 1982' asDate.
		'15 April 1982' asUtf8String asDate.
	"

	^ Date fromString: self! !

String removeSelector: #asDate!

!methodRemoval: String #asDate stamp: 'Install-5266-asDate-JuanVuletich-2022Jun11-19h05m-jmv.001.cs.st 6/16/2022 07:24:53'!
asDate
	"Many allowed forms, see Date>>#readFrom:
		'2014/6/30' asDate.
		'70/12/30' asDate.
		'12/30/70' asDate.
		'30/12/70' asDate.
		'4/5/6' asDate.
		'15 April 1982' asDate.
	"

	^ Date fromString: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5266-asDate-JuanVuletich-2022Jun11-19h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5263] on 11 June 2022 at 8:58:45 pm'!
!String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:50:20'!
                  is: aStringOrByteArray equalTo: another
	"Take adventage of String primitive for comparing, for example, ByteArrays"

	^ (self compare: aStringOrByteArray with: another collated: CaseSensitiveOrder) = 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:52:28' prior: 50381873 overrides: 16934001!
         = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	(self isAscii and: [	aString isByteString ]) ifTrue: [
		"Fast lane."
		^'' is: bytes equalTo: aString ].
	
	aString isUtf8String ifTrue: [
		self isAscii = aString isAscii ifFalse: [
			^false ]].

	"May need to do UTF-8 encoding."
	^ bytes = aString.! !
!ByteArray methodsFor: 'comparing' stamp: 'jmv 6/11/2022 20:50:36' prior: 50367396 overrides: 16934001!
     = another
	"Make good use of String primitives"

	self == another ifTrue: [ ^ true ].
	self species == another species ifFalse: [^ false].
	^'' is: self equalTo: another ! !

String removeSelector: #is:sameAs:!

!methodRemoval: String #is:sameAs: stamp: 'Install-5267-BugFix-DontCallSameForEquality-JuanVuletich-2022Jun11-20h49m-jmv.001.cs.st 6/16/2022 07:24:53'!
is: aStringOrByteArray sameAs: another 
	"Take adventage of String primitive for comparing, for example, ByteArrays"

	^ (self compare: aStringOrByteArray with: another collated: CaseInsensitiveOrder) = 2!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5267-BugFix-DontCallSameForEquality-JuanVuletich-2022Jun11-20h49m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5265] on 12 June 2022 at 3:46:42 pm'!
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/12/2022 15:36:54' prior: 50381766!
                             findString: subString startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	| arg startByteIndex byteIndex |
	arg _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].

	"Do UTF-8 encoding as needed."
	startByteIndex _ self byteIndexAt: start.
	byteIndex _ '' findString: arg in: bytes startingAt: startByteIndex.
	^self codePointIndexAt: byteIndex! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/12/2022 15:38:35' prior: 50381782!
 findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	| startByteIndex byteIndex |
	caseSensitive ifTrue: [
		^self findString: key startingAt: start ].

	self isAscii ifTrue: [
		key isAscii
			ifTrue: [
				"Fast lane"
				startByteIndex _ self byteIndexAt: start.
				byteIndex _ '' findStringIgnoreCase: key in: bytes startingAt: startByteIndex.
				^self codePointIndexAt: byteIndex ]
			ifFalse: [
				"Won't be found"
				^0 ]].

"caseSensitive = false is very expensive. Do better."
self flag: #slowUnicode.
	^self asLowercase findString: key asLowercase startingAt: start! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/12/2022 15:45:08' prior: 50381609 overrides: 16933699!
             indexOf: anUnicodeCodePoint  startingAt: start  ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	anUnicodeCodePoint isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes _ Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint.
	startByteIndex _ self byteIndexAt: start.
	foundByteIndex _ '' findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer _ self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/12/2022 15:39:57' prior: 50381806 overrides: 16933739!
                      indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock

	| index arg startByteIndex byteIndex |
	arg _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	startByteIndex _ self byteIndexAt: start.
	byteIndex _ '' findString: arg in: bytes startingAt: startByteIndex.
	index _ self codePointIndexAt: byteIndex.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/12/2022 15:41:57' prior: 50381953!
                            is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize subStringBytes byteIndex |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	subStringBytes _ subString asUtf8Bytes.
	subStringBytes _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	byteIndex _ self byteIndexAt: index.
	(bytes at: byteIndex) = (subStringBytes byteAt: 1) ifFalse: [ ^false ].
	^('' findString: subStringBytes in: bytes startingAt: byteIndex) = byteIndex! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5268-FixBuggyHandlingOfByteIndexInUtf8-JuanVuletich-2022Jun12-15h30m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5267] on 12 June 2022 at 5:24:45 pm'!
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/12/2022 17:10:16'!
                 isVowel
	"Answer whether the receiver is one of the vowels, AEIOU, in upper or 
	lower case, and with various diacritical marks."
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isVowel ].
	^false! !
!CharacterSequence methodsFor: 'copying' stamp: 'Squeak1.0 9/20/1996 10:50:05'!
           copyReplaceTokens: oldSubstring with: newSubstring
	"Replace all occurrences of oldSubstring that are surrounded
	by non-alphanumeric characters"
	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true
	"
	'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'
	'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick' asUtf8String
	'File asFile Files File''s File' copyReplaceTokens: 'File' asUtf8String with: 'Snick'
	'File asFile Files File''s File' copyReplaceTokens: 'File' asUtf8String with: 'Snick' asUtf8String
	'File asFile Files File''s File' asUtf8String copyReplaceTokens: 'File' with: 'Snick'
	'File asFile Files File''s File' asUtf8String copyReplaceTokens: 'File' with: 'Snick' asUtf8String
	'File asFile Files File''s File' asUtf8String copyReplaceTokens: 'File' asUtf8String with: 'Snick'
	'File asFile Files File''s File' asUtf8String copyReplaceTokens: 'File' asUtf8String with: 'Snick' asUtf8String
	"! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/12/2022 16:22:58' overrides: 16823105!
                    flattenTo: flattenedStream

	flattenedStream nextPut: self! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:09:06'!
                     squeezedTo: n
	"
Examples:
	Do nothing:
		'This one is a rather long phrase' squeezedTo: 32
		'This one is a rather long phrase' asUtf8String squeezedTo: 32

	1-remove blanks (result can be shorter than asked):
		'This one is a rather long phrase' squeezedTo: 30
		'This one is a rather long phrase' asUtf8String squeezedTo: 30

	2-remove necessary trailing vowels
		'This one is a rather long phrase' squeezedTo: 24
		'This one is a rather long phrase' asUtf8String squeezedTo: 24

	3-truncate as needed (and add ellipsis)
		'This one is a rather long phrase' squeezedTo: 15
		'This one is a rather long phrase' asUtf8String squeezedTo: 15

	4-avoid ellipsis
		'This one is a rather long phrase' squeezedTo: 5
		'This one is a rather long phrase' asUtf8String squeezedTo: 5
	"
	| vowelCount read write i char allowedVowels str desiredSize postFix j |
	str _ self.
	desiredSize _ n.
	str size <= n ifTrue: [^str].
	str _ str asCamelCase.
	str size <= n ifTrue: [^str].
	postFix _ ''.
	desiredSize _ n - postFix size.
	vowelCount _ str
		inject: 0
		into: [:prev :each | each isVowel ifTrue: [prev + 1] ifFalse: [prev]].
	str size - vowelCount <= desiredSize
		ifTrue: [allowedVowels _ vowelCount - (str size - desiredSize)]
		ifFalse: [
			allowedVowels _ 0.
			postFix _ '...'.
			n - postFix size < 5 ifTrue: [postFix _ ''].
			desiredSize _ n - postFix size].

	read _ str readStream.
	write _ self class writeStream.
	i _ 0.
	j _ 0.
	[read atEnd not and: [j < desiredSize]] whileTrue: [
		char _ read next.
		(char isVowel not or: [i < allowedVowels]) ifTrue: [
			char isVowel ifTrue: [i := i + 1].
			write nextPut: char.
			j _ j + 1]].
	str _ write contents , postFix.
	^ str! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:17:56'!
                            withoutPrefix: aString
	"
	'Elvis' withoutPrefix: 'El'
	'Elvis' withoutPrefix: 'Paul'
	'Elvis' withoutPrefix: 'El' asUtf8String
	'Elvis' withoutPrefix: 'Paul' asUtf8String
	'Elvis' asUtf8String withoutPrefix: 'El'
	'Elvis' asUtf8String withoutPrefix: 'Paul'
	'Elvis' asUtf8String withoutPrefix: 'El' asUtf8String
	'Elvis' asUtf8String withoutPrefix: 'Paul' asUtf8String
	"
	^(self beginsWith: aString)
		ifTrue: [ self copyFrom: aString size+1 to: self size ]! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/12/2022 16:32:43'!
            caseInsensitiveLessOrEqual: aString 
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			^self asByteString caseInsensitiveLessOrEqual: aString ].
		(aString isUtf8String and: [ aString isAscii ]) ifTrue: [
			^self asByteString sameAs: aString asByteString ]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #slowUnicode.
	^self asLowercase <= aString asLowercase! !
!FileList methodsFor: 'private' stamp: 'jmv 6/12/2022 16:54:38' prior: 16855830!
     sortBlock
	"Answer block to decide what order to display the directory entries."

	^ [ :xx :yy | | x y |
		(xx isDirectory == yy isDirectory) 
			ifTrue: [  
				sortAscending
					ifTrue: [ x _ xx. y _ yy ]
					ifFalse: [ x _ yy. y _ xx ].
				"sort by user-specified criterion"
				sortMode = #name 
					ifTrue: [x name <= y name]
					ifFalse: [ sortMode = #date
						ifTrue: [ x modificationTime = y modificationTime
								ifTrue: [ x name <= y name ]
								ifFalse: [ x modificationTime <= y modificationTime ] ]
						ifFalse: [ "size"
							x fileSize = y fileSize 
								ifTrue: [ x name <= y name ]
								ifFalse: [ x fileSize <= y fileSize ] ] ] ]
			ifFalse: [
				"directories always precede files"
				xx isDirectory ] ]! !

String removeSelector: #caseSensitiveLessOrEqual:!

!methodRemoval: String #caseSensitiveLessOrEqual: stamp: 'Install-5269-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-16h07m-jmv.004.cs.st 6/16/2022 07:24:53'!
caseSensitiveLessOrEqual: aString 
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2!

String removeSelector: #withoutPrefix:!

!methodRemoval: String #withoutPrefix: stamp: 'Install-5269-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-16h07m-jmv.004.cs.st 6/16/2022 07:24:53'!
withoutPrefix: aString
	"
	'Elvis' withoutPrefix: 'El'
	'Elvis' withoutPrefix: 'Paul'
	"
	^(self beginsWith: aString)
		ifTrue: [ self copyFrom: aString size+1 to: self size ]!

String removeSelector: #squeezedTo:!

!methodRemoval: String #squeezedTo: stamp: 'Install-5269-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-16h07m-jmv.004.cs.st 6/16/2022 07:24:53'!
squeezedTo: n
	"
Examples:
	Do nothing:
		'This one is a rather long phrase' squeezedTo: 32

	1-remove blanks (result can be shorter than asked):
		'This one is a rather long phrase' squeezedTo: 30

	2-remove necessary trailing vowels
		'This one is a rather long phrase' squeezedTo: 24

	3-truncate as needed (and add ellipsis)
		'This one is a rather long phrase' squeezedTo: 15

	4-avoid ellipsis
		'This one is a rather long phrase' squeezedTo: 5
	"
	| vowelCount read write i char allowedVowels str desiredSize postFix j |
	str := self.
	desiredSize := n.
	str size <= n ifTrue: [^str].
	str := str asCamelCase.
	str size <= n ifTrue: [^str].
	postFix := ''.
	desiredSize := n - postFix size.
	vowelCount := str
		inject: 0
		into: [:prev :each | each isVowel ifTrue: [prev + 1] ifFalse: [prev]].
	str size - vowelCount <= desiredSize
		ifTrue: [allowedVowels := vowelCount - (str size - desiredSize)]
		ifFalse: [
			allowedVowels := 0.
			postFix := '...'.
			n - postFix size < 5 ifTrue: [postFix := ''].
			desiredSize := n - postFix size].

	read := str readStream.
	write := String writeStream.
	i := 0.
	j := 0.
	[read atEnd not and: [j < desiredSize]] whileTrue: [
		char := read next.
		(char isVowel not or: [i < allowedVowels]) ifTrue: [
			char isVowel ifTrue: [i := i + 1].
			write nextPut: char.
			j := j + 1]].
	str := write contents , postFix.
	^ str!

String removeSelector: #flattenTo:!

!methodRemoval: String #flattenTo: stamp: 'Install-5269-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-16h07m-jmv.004.cs.st 6/16/2022 07:24:53'!
flattenTo: flattenedStream

	flattenedStream nextPut: self!

String removeSelector: #copyReplaceTokens:with:!

!methodRemoval: String #copyReplaceTokens:with: stamp: 'Install-5269-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-16h07m-jmv.004.cs.st 6/16/2022 07:24:53'!
copyReplaceTokens: oldSubstring with: newSubstring 
	"Replace all occurrences of oldSubstring that are surrounded
	by non-alphanumeric characters"
	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true
	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5269-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-16h07m-jmv.004.cs.st----!

'From Cuis 6.0 [latest update: #5267] on 12 June 2022 at 6:07:25 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:41:46'!
                       fixLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings. Replace each occurence with a single Lf.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') fixLineEndings
	('Hello ', String crString, 'World') fixLineEndings
	('Hello ', String lfString, 'World') fixLineEndings
	('Hello ' asUtf8String, String crlfString, 'World') fixLineEndings
	('Hello ' asUtf8String, String crString, 'World') fixLineEndings
	('Hello ' asUtf8String, String lfString, 'World') fixLineEndings
	"
	(self includes: `Character cr`) ifFalse: [ ^self ].
	^ self withLineEndings: `String newLineString`! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 18:01:37'!
              withBlanksCondensed
	"Return a copy of the receiver with leading/trailing blanks removed
	 and consecutive white spaces condensed as a single space."

	| trimmed lastWasBlank |
	trimmed _ self withBlanksTrimmed.
	^self class streamContents: [ :stream |
		lastWasBlank _ false.
		trimmed do: [ :c |
			c isSeparator
				ifTrue: [ lastWasBlank ifFalse: [ stream space ]]
				ifFalse: [ stream nextPut: c ].
			lastWasBlank _ c isSeparator ]].

	"
	' abc  d   ' withBlanksCondensed
	' abc  d   ' asUtf8String withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' asUtf8String withBlanksCondensed
	"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:36:52'!
            withCuisLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings.
	Answer a new instance, replacing each occurence with a single Lf.
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	('aLine' asUtf8String, String crlfString, 'anotherOne') withCuisLineEndings
	"
	^ self withLineEndings: `String newLineString`.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:31:05'!
                             withDescriptiveLineEndings
	"
	('Hello', String newLineString, 'World') withDescriptiveLineEndings
	('Hello' asUtf8String, String newLineString, 'World') withDescriptiveLineEndings
	"
	^ self withLineEndings: '[enter]'! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:58:20'!
                     withoutSeparators
	
	^self reject: [ :aCharacter | aCharacter isSeparator ]

	"
	' abc  d   ' withoutSeparators
	' abc  d   ' asUtf8String withoutSeparators
	"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:56:59'!
                withoutTrailingBlanks
	"Return a copy of the receiver from which trailing blanks have been trimmed."

	| last |
	
	last _ self lastNonSeparator.
	last = 0 ifTrue: [^ ''].  "no non-separator character"
	last = self size ifTrue: [ ^self ].
	
	^ self copyFrom: 1 to: last

	"
	' abc  d   ' withoutTrailingBlanks
	' abc  d   ' asUtf8String withoutTrailingBlanks
	"
! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 6/12/2022 17:59:27'!
                              withoutWindowsDriveName
	^self beginsWithWindowsDriveName 
		ifFalse: [ self ]
		ifTrue: [ self copyFrom: 3 to: self size ]! !
!String methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:39:24' prior: 50347032 overrides: 50382695!
                           fixLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings. Replace each occurence with a single Lf.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') fixLineEndings
	('Hello ', String crString, 'World') fixLineEndings
	('Hello ', String lfString, 'World') fixLineEndings
	"
	(self includes: `Character cr`) ifFalse: [ ^self ].
	(self includesSubString: `String crlfString`) ifTrue: [ "A new instance is needed"
		^ self withLineEndings: `String newLineString` ].
	self replaceAll: `Character cr` with: `Character lf`.! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/12/2022 17:36:10' prior: 50379834!
                              withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"

	| correctedBytes |
	correctedBytes _ '' string: bytes withLineEndings: lineEndingString asByteArray.
	"The codePointCount trick can be done because the line endings considered are all single byte UTF-8.
	If we ever consider unicode line endings taking more than one byte, this is no longer valid (pass nil instead)."
	^  Utf8String fromUtf8Bytes: correctedBytes codePointCount: self size - bytes size + correctedBytes size.! !

String removeSelector: #withBlanksCondensed!

!methodRemoval: String #withBlanksCondensed stamp: 'Install-5270-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-17h30m-jmv.003.cs.st 6/16/2022 07:24:53'!
withBlanksCondensed
	"Return a copy of the receiver with leading/trailing blanks removed
	 and consecutive white spaces condensed as a single space."

	| trimmed lastWasBlank |
	trimmed _ self withBlanksTrimmed.
	^String streamContents: [ :stream |
		lastWasBlank _ false.
		trimmed do: [ :c |
			c isSeparator
				ifTrue: [ lastWasBlank ifFalse: [ stream space ]]
				ifFalse: [ stream nextPut: c ].
			lastWasBlank _ c isSeparator ]].

	" 
	' abc  d   ' withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' withBlanksCondensed
	"!

String removeSelector: #withoutSeparators!

!methodRemoval: String #withoutSeparators stamp: 'Install-5270-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-17h30m-jmv.003.cs.st 6/16/2022 07:24:53'!
withoutSeparators
	
	^self reject: [ :aCharacter | aCharacter isSeparator ]!

String removeSelector: #withCuisLineEndings!

!methodRemoval: String #withCuisLineEndings stamp: 'Install-5270-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-17h30m-jmv.003.cs.st 6/16/2022 07:24:53'!
withCuisLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings.
	Answer a new instance, replacing each occurence with a single Lf.
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"
	^ self withLineEndings: `String newLineString`.!

String removeSelector: #withoutTrailingBlanks!

!methodRemoval: String #withoutTrailingBlanks stamp: 'Install-5270-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-17h30m-jmv.003.cs.st 6/16/2022 07:24:53'!
withoutTrailingBlanks
	"Return a copy of the receiver from which trailing blanks have been trimmed."

	| last |
	
	last _ self lastNonSeparator.
	last = 0 ifTrue: [^ ''].  "no non-separator character"
	last = self size ifTrue: [ ^self ].
	
	^ self copyFrom: 1 to: last

	" ' abc  d   ' withoutTrailingBlanks"
!

String removeSelector: #withoutWindowsDriveName!

!methodRemoval: String #withoutWindowsDriveName stamp: 'Install-5270-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-17h30m-jmv.003.cs.st 6/16/2022 07:24:53'!
withoutWindowsDriveName
	^self beginsWithWindowsDriveName 
		ifFalse: [ self ]
		ifTrue: [ self copyFrom: 3 to: self size ]!

String removeSelector: #withDescriptiveLineEndings!

!methodRemoval: String #withDescriptiveLineEndings stamp: 'Install-5270-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-17h30m-jmv.003.cs.st 6/16/2022 07:24:53'!
withDescriptiveLineEndings
	"
	('Hello', String newLineString, 'World') withDescriptiveLineEndings
	"
	^ self withLineEndings: '[enter]'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5270-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-17h30m-jmv.003.cs.st----!

'From Cuis 6.0 [latest update: #5267] on 12 June 2022 at 7:11:56 pm'!
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/12/2022 18:09:59'!
                      isAccented
	"Answer whether the receiver is a letter."
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isAccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/12/2022 18:21:34'!
                          isLowercase
	"Answer whether the receiver is a letter."
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isLowercase ].
	^false! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:24:09'!
                    asMonth
	"Many allowed forms, see Month>>#readFrom:
		'July 1998' asMonth.
		'July 1998' asUtf8String asMonth.
		'1998/7' asMonth.
		'1998/7' asUtf8String asMonth.
	"

	^ Month fromString: self! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/2/2011 08:51'!
                  asNumber 
	"Answer the Number created by interpreting the receiver as the string 
	representation of a number."
	^Number readFrom: self readStream! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 18:10:15'!
                             asUnaccented
	"
	'Hello' asUnaccented
	'Hello' asUtf8String asUnaccented
	'·ÈÓÙÛ¸' asUnaccented
	'·ÈÓÙÛ¸' asUtf8String asUnaccented
	"
	^(self anySatisfy: [ :c | c isAccented])
		ifFalse: [ self ]
		ifTrue: [ self collect: [ :c | c asUnaccented ]]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:39:13'!
                        asWeek
	"
		'2008-W52' asUtf8String asWeek.
		'2008-W53' asUtf8String asWeek. 'Invalid format!!'.
		'2009-W01' asUtf8String asWeek
		'2009-W02' asUtf8String asWeek
		'2009-W53' asUtf8String asWeek
		'2010-W01' asUtf8String asWeek
		'2010-W02' asUtf8String asWeek
		'2008-W52' asUtf8String asWeek start.
		'2009-W01' asUtf8String asWeek start
		'2009-W02' asUtf8String asWeek start
		'2009-W53' asUtf8String asWeek start
		'2010-W01' asUtf8String asWeek start
		'2010-W02' asUtf8String asWeek start
	"

	^ Week fromString: self! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:37:23'!
 asYear
	"
		'2008' asUtf8String asYear.
		'2008' asUtf8String asYear start.
	"

	^ Year fromString: self! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 18:24:05'!
       capitalized
	"Answer an object like the receiver but with first character downshifted if necesary
	'mElViN' asUtf8String capitalized
	'MElViN' asUtf8String capitalized
	('will', Random next mantissaPart printString) asUtf8String asSymbol capitalized
	('Will', Random next mantissaPart printString) asUtf8String asSymbol capitalized
	"
	self isEmpty ifTrue: [^ self].
	self first isUppercase ifTrue: [ ^self ].
	^self class streamContents: [ :strm | | isFirst corrected |
		isFirst _ true.
		self do: [ :codePoint |
			isFirst
				ifTrue: [
					corrected _ codePoint asUppercase.
					isFirst _ false ]
				ifFalse: [corrected _ codePoint].
			strm nextPut: corrected ]]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 19:09:42'!
                 findPositiveInteger 
	"Answer the Integer created by interpreting the receiver as the string representation of an integer.
	Answer nil if no digits, else find the first digit and then all consecutive digits after that"

	| startPosition tail endPosition |
	startPosition _ self findFirst: [:ch | ch isDigit].
	startPosition = 0 ifTrue: [^ nil].
	tail _ self copyFrom: startPosition to: self size.
	endPosition _ tail findFirst: [:ch | ch isDigit not].
	endPosition = 0 ifTrue: [endPosition _ tail size + 1].
	^ Number readFrom: (tail copyFrom: 1 to: endPosition - 1) readStream

"
'1796exportFixes-tkMX' findPositiveInteger
'1796exportFixes-tkMX' asUtf8String findPositiveInteger
'1848recentLogFile-sw' findPositiveInteger
'1848recentLogFile-sw' asUtf8String findPositiveInteger
'donald' findPositiveInteger
'donald' asUtf8String findPositiveInteger
'abc234def567' findPositiveInteger
'abc234def567' asUtf8String findPositiveInteger
"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 19:11:26'!
         initialIntegerOrNil
	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"
	| firstNonDigit |
	(self isEmpty or: [self first isDigit not]) ifTrue: [^ nil].
	firstNonDigit _ (self findFirst: [:m | m isDigit not]).
	firstNonDigit = 0 ifTrue: [firstNonDigit _ self size + 1].
	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber
"
'234Whoopie' initialIntegerOrNil
'234Whoopie' asUtf8String initialIntegerOrNil
'wimpy' initialIntegerOrNil
'wimpy' asUtf8String initialIntegerOrNil
'234' initialIntegerOrNil
'234' asUtf8String initialIntegerOrNil
'2N' initialIntegerOrNil
'2N' asUtf8String initialIntegerOrNil
'2' initialIntegerOrNil
'2' asUtf8String initialIntegerOrNil
'  89Ten ' initialIntegerOrNil
'  89Ten ' asUtf8String initialIntegerOrNil
'78 92' initialIntegerOrNil
'78 92' asUtf8String initialIntegerOrNil
"
! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/12/2022 18:18:59'!
                            uncapitalized
	"Answer an object like the receiver but with first character downshifted if necesary
	'MElViN' asUtf8String uncapitalized
	'mElViN' asUtf8String uncapitalized
	('Will', Random next mantissaPart printString) asUtf8String asSymbol uncapitalized
	('will', Random next mantissaPart printString) asUtf8String asSymbol uncapitalized
	"
	self isEmpty ifTrue: [^ self].
	self first isLowercase ifTrue: [ ^self ].
	^self class streamContents: [ :strm | | isFirst corrected |
		isFirst _ true.
		self do: [ :codePoint |
			isFirst
				ifTrue: [
					corrected _ codePoint asLowercase.
					isFirst _ false ]
				ifFalse: [corrected _ codePoint].
			strm nextPut: corrected ]]! !
!CharacterSequence methodsFor: 'testing' stamp: 'len 11/26/2016 09:05:35'!
         isAlphaNumeric
	"Answer true if the receiver contains only letters or digits."
	^ self allSatisfy: [:each| each isAlphaNumeric]! !
!Utf8Symbol methodsFor: 'converting' stamp: 'jmv 6/12/2022 18:11:42' overrides: 50383008!
   capitalized
	^ self asPlainString capitalized asSymbol! !
!Utf8Symbol methodsFor: 'converting' stamp: 'jmv 6/12/2022 18:11:29' overrides: 50383095!
            uncapitalized
	^ self asPlainString uncapitalized asSymbol! !
!String methodsFor: 'converting' stamp: 'jmv 6/12/2022 18:19:34' prior: 50368159 overrides: 50383095!
                            uncapitalized
	"Answer an object like the receiver but with first character downshifted if necesary
	'MElViN' uncapitalized
	'mElViN' uncapitalized
	('Will', Random next mantissaPart printString) asSymbol uncapitalized
	('will', Random next mantissaPart printString) asSymbol uncapitalized
	"
	| answer |
	self isEmpty ifTrue: [^ self].
	self first isLowercase ifTrue: [ ^self ].
	answer _ self asPlainString.
	answer == self ifTrue: ["don't modify receiver"
		answer _ self copy ].
	answer at: 1 put: (answer at: 1) asLowercase.
	^ answer! !

String removeSelector: #findPositiveInteger!

!methodRemoval: String #findPositiveInteger stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
findPositiveInteger 
	"Answer the Integer created by interpreting the receiver as the string representation of an integer.
	Answer nil if no digits, else find the first digit and then all consecutive digits after that"

	| startPosition tail endPosition |
	startPosition _ self findFirst: [:ch | ch isDigit].
	startPosition = 0 ifTrue: [^ nil].
	tail _ self copyFrom: startPosition to: self size.
	endPosition _ tail findFirst: [:ch | ch isDigit not].
	endPosition = 0 ifTrue: [endPosition _ tail size + 1].
	^ Number readFrom: (tail copyFrom: 1 to: endPosition - 1) readStream

"
'1796exportFixes-tkMX' findPositiveInteger
'1848recentLogFile-sw'  findPositiveInteger
'donald' findPositiveInteger
'abc234def567' findPositiveInteger
"!

String removeSelector: #asNumber!

!methodRemoval: String #asNumber stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
asNumber 
	"Answer the Number created by interpreting the receiver as the string 
	representation of a number."
	^Number readFrom: self readStream!

String removeSelector: #asUnaccented!

!methodRemoval: String #asUnaccented stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
asUnaccented
	"
	'Hello' asUnaccented
	'·ÈÓÙÛ¸' asUnaccented
	"
	^(self anySatisfy: [ :c | c isAccented])
		ifFalse: [ self ]
		ifTrue: [ self collect: [ :c | c asUnaccented ]]!

String removeSelector: #asYear!

!methodRemoval: String #asYear stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
asYear
	"
		'2008' asYear.
		'2008' asYear start.
	"

	^ Year fromString: self!

String removeSelector: #isAlphaNumeric!

!methodRemoval: String #isAlphaNumeric stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
isAlphaNumeric
	"Answer true if the receiver contains only letters or digits."
	^ self allSatisfy: [:each| each isAlphaNumeric]!

String removeSelector: #initialIntegerOrNil!

!methodRemoval: String #initialIntegerOrNil stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
initialIntegerOrNil
	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"
	| firstNonDigit |
	(self isEmpty or: [self first isDigit not]) ifTrue: [^ nil].
	firstNonDigit _ (self findFirst: [:m | m isDigit not]).
	firstNonDigit = 0 ifTrue: [firstNonDigit _ self size + 1].
	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber
"
'234Whoopie' initialIntegerOrNil
'wimpy' initialIntegerOrNil
'234' initialIntegerOrNil
'2N' initialIntegerOrNil
'2' initialIntegerOrNil
'  89Ten ' initialIntegerOrNil
'78 92' initialIntegerOrNil
"
!

String removeSelector: #asMonth!

!methodRemoval: String #asMonth stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
asMonth
	"Many allowed forms, see Month>>#readFrom:
		'July 1998' asMonth.
		'1998/7'asMonth.
	"

	^ Month fromString: self!

String removeSelector: #asWeek!

!methodRemoval: String #asWeek stamp: 'Install-5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st 6/16/2022 07:24:54'!
asWeek
	"
		'2008-W52' asWeek.
		'2008-W53' asWeek. 'Invalid format!!'.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
		'2008-W52' asWeek start.
		'2009-W01' asWeek start
		'2009-W02' asWeek start
		'2009-W53' asWeek start
		'2010-W01' asWeek start
		'2010-W02' asWeek start
	"

	^ Week fromString: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5271-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-18h07m-jmv.003.cs.st----!

'From Cuis 6.0 [latest update: #5267] on 12 June 2022 at 7:19:46 pm'!
!CharacterSequence methodsFor: 'displaying' stamp: 'jmv 6/12/2022 19:12:32'!
                  displayAt: aPoint 
	"Display the receiver as a DisplayText at aPoint on the display screen."

	self displayOn: Display at: aPoint.
	DisplayScreen screenUpdateRequired: nil! !
!CharacterSequence methodsFor: 'displaying' stamp: 'jmv 6/12/2022 19:12:44'!
    displayOn: aDisplayMedium
	"Display the receiver on the given DisplayMedium.  5/16/96 sw"

	self displayOn: aDisplayMedium at: `0 @ 0`! !
!CharacterSequence methodsFor: 'displaying' stamp: 'jmv 6/12/2022 19:13:01'!
         displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: `Color black`
	"
	'Display' displayOn: Display at: 10@10. Display forceToScreen.
	"! !
!CharacterSequence methodsFor: 'displaying' stamp: 'jmv 6/12/2022 19:13:15'!
    displayOn: aDisplayMedium at: aPoint textColor: aColor
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"

	^aDisplayMedium getCanvas drawString: self at: aPoint font: nil color: aColor! !
!CharacterSequence methodsFor: 'displaying' stamp: 'jmv 7/17/2017 15:41:46'!
                              displayProgressAt: aPoint from: minVal to: maxVal during: workBlock
	"Display this string as a caption over a progress bar while workBlock is evaluated.

EXAMPLE (Select next 6 lines and Do It)

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
		1 to: 100 do: [:x | 
			(Delay forMilliseconds: 10) wait.
			barBlock value: x.]].

['Now here''s some Real Progress' asUtf8String
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
	1 to: 100 do: [:x | barBlock value: x.
			(Delay forMilliseconds: 100) wait]].] fork
	
['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: x \\ 11.
			(Delay forMilliseconds: 100) wait]]] fork

'Now here''s some Real Progress' asUtf8String
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: nil.
			(Delay forMilliseconds: 200) wait]].

HOW IT WORKS (Try this in any other language :-)
Since your code (the last 2 lines in the above example) is in a block,
this method gets control to display its heading before, and clean up 
the screen after, its execution.
The key, though, is that the block is supplied with an argument,
named 'bar' in the example, which will update the bar image every 
it is sent the message value: x, where x is in the from:to: range.

The use of ProgressInitiationException allows for avoiding actual
progress display, by catching the exception.
"
	^ProgressInitiationException 
		display: self
		at: aPoint 
		from: minVal 
		to: maxVal 
		during: workBlock! !

String removeSelector: #displayOn:at:!

!methodRemoval: String #displayOn:at: stamp: 'Install-5272-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-19h11m-jmv.001.cs.st 6/16/2022 07:24:54'!
displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: `Color black`
	"
	'Display' displayOn: Display at: 10@10. Display forceToScreen.
	"!

String removeSelector: #displayOn:at:textColor:!

!methodRemoval: String #displayOn:at:textColor: stamp: 'Install-5272-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-19h11m-jmv.001.cs.st 6/16/2022 07:24:54'!
displayOn: aDisplayMedium at: aPoint textColor: aColor
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"

	^aDisplayMedium getCanvas drawString: self at: aPoint font: nil color: aColor!

String removeSelector: #displayAt:!

!methodRemoval: String #displayAt: stamp: 'Install-5272-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-19h11m-jmv.001.cs.st 6/16/2022 07:24:54'!
displayAt: aPoint 
	"Display the receiver as a DisplayText at aPoint on the display screen."

	self displayOn: Display at: aPoint.
	DisplayScreen screenUpdateRequired: nil!

String removeSelector: #displayOn:!

!methodRemoval: String #displayOn: stamp: 'Install-5272-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-19h11m-jmv.001.cs.st 6/16/2022 07:24:54'!
displayOn: aDisplayMedium
	"Display the receiver on the given DisplayMedium.  5/16/96 sw"

	self displayOn: aDisplayMedium at: `0 @ 0`!

String removeSelector: #displayProgressAt:from:to:during:!

!methodRemoval: String #displayProgressAt:from:to:during: stamp: 'Install-5272-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-19h11m-jmv.001.cs.st 6/16/2022 07:24:54'!
displayProgressAt: aPoint from: minVal to: maxVal during: workBlock
	"Display this string as a caption over a progress bar while workBlock is evaluated.

EXAMPLE (Select next 6 lines and Do It)

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
		1 to: 100 do: [:x | 
			(Delay forMilliseconds: 10) wait.
			barBlock value: x.]].

['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
	1 to: 100 do: [:x | barBlock value: x.
			(Delay forMilliseconds: 100) wait]].] fork
	
['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: x \\ 11.
			(Delay forMilliseconds: 100) wait]]] fork

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: nil.
			(Delay forMilliseconds: 200) wait]].

HOW IT WORKS (Try this in any other language :-)
Since your code (the last 2 lines in the above example) is in a block,
this method gets control to display its heading before, and clean up 
the screen after, its execution.
The key, though, is that the block is supplied with an argument,
named 'bar' in the example, which will update the bar image every 
it is sent the message value: x, where x is in the from:to: range.

The use of ProgressInitiationException allows for avoiding actual
progress display, by catching the exception.
"
	^ProgressInitiationException 
		display: self
		at: aPoint 
		from: minVal 
		to: maxVal 
		during: workBlock!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5272-Utf8String-AddMoreStringStuff-JuanVuletich-2022Jun12-19h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5271] on 13 June 2022 at 8:38:06 am'!
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 08:36:38'!
                       copyReplacing: rangesToNewStrings

	^self class streamContents: [ :replacementStream | self copyReplacing: rangesToNewStrings into: replacementStream ].! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 08:36:15'!
                          copyReplacing: rangesToNewStrings into: replacementStream

	| lastFrom |

	lastFrom := rangesToNewStrings inject: 1 into: [ :from :aRangeToNewString |
		self
			newFromAfterAppending: aRangeToNewString value
			into: replacementStream
			keepingFrom: from
			skipping: aRangeToNewString key ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).
! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 08:36:59'!
   copyReplacing: ranges with: newString

	"Ranges must be in order, with first ranges first. If not, result is unexpected - Hernan"

	^ self class streamContents: [ :replacementStream | self copyReplacing: ranges with: newString into: replacementStream ]
		! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 08:36:30'!
                   copyReplacing: ranges with: newString into: replacementStream

	| lastFrom |

	lastFrom := ranges
		inject: 1
		into: [ :from :aRange |
			self newFromAfterAppending: newString into: replacementStream keepingFrom: from skipping: aRange ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 08:35:29'!
                           newFromAfterAppending: aNewString into: replacementStream keepingFrom: from skipping: aRange

	replacementStream
		nextPutAll: (self copyFrom: from to: aRange first - 1);
		nextPutAll: aNewString.

	^ aRange last + 1! !

String removeSelector: #copyReplacing:with:!

!methodRemoval: String #copyReplacing:with: stamp: 'Install-5273-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h35m-jmv.001.cs.st 6/16/2022 07:24:54'!
copyReplacing: ranges with: newString

	"Ranges must be in order, with first ranges first. If not, result is unexpected - Hernan"

	^ self class streamContents: [ :replacementStream | self copyReplacing: ranges with: newString into: replacementStream ]
		!

String removeSelector: #copyReplacing:!

!methodRemoval: String #copyReplacing: stamp: 'Install-5273-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h35m-jmv.001.cs.st 6/16/2022 07:24:54'!
copyReplacing: rangesToNewStrings

	^self class streamContents: [ :replacementStream | self copyReplacing: rangesToNewStrings into: replacementStream ].!

String removeSelector: #newFromAfterAppending:into:keepingFrom:skipping:!

!methodRemoval: String #newFromAfterAppending:into:keepingFrom:skipping: stamp: 'Install-5273-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h35m-jmv.001.cs.st 6/16/2022 07:24:54'!
newFromAfterAppending: aNewString into: replacementStream keepingFrom: from skipping: aRange

	replacementStream
		nextPutAll: (self copyFrom: from to: aRange first - 1);
		nextPutAll: aNewString.

	^ aRange last + 1!

String removeSelector: #copyReplacing:into:!

!methodRemoval: String #copyReplacing:into: stamp: 'Install-5273-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h35m-jmv.001.cs.st 6/16/2022 07:24:54'!
copyReplacing: rangesToNewStrings into: replacementStream

	| lastFrom |

	lastFrom := rangesToNewStrings inject: 1 into: [ :from :aRangeToNewString |
		self
			newFromAfterAppending: aRangeToNewString value
			into: replacementStream
			keepingFrom: from
			skipping: aRangeToNewString key ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).
!

String removeSelector: #copyReplacing:with:into:!

!methodRemoval: String #copyReplacing:with:into: stamp: 'Install-5273-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h35m-jmv.001.cs.st 6/16/2022 07:24:54'!
copyReplacing: ranges with: newString into: replacementStream

	| lastFrom |

	lastFrom := ranges
		inject: 1
		into: [ :from :aRange |
			self newFromAfterAppending: newString into: replacementStream keepingFrom: from skipping: aRange ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5273-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h35m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5271] on 13 June 2022 at 8:52:23 am'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 6/13/2022 08:40:10'!
                         findAnySubStr: delimiters startingAt: start
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min ind |
	min _ self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		delim isCharacter
			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [ind _ self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
			min _ min min: ind].
	^ min! !
!CharacterSequence methodsFor: 'accessing' stamp: 'dew 11/15/2000 15:02'!
  findBetweenSubStrs: delimiters
	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."

	| tokens keyStart keyStop |
	tokens _ OrderedCollection new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipAnySubStr: delimiters startingAt: keyStop.
		keyStop _ self findAnySubStr: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!CharacterSequence methodsFor: 'accessing' stamp: 'nice 10/5/2009 03:15'!
   findLastOccurrenceOfString: subString startingAt: start 
	"Answer the index of the last occurrence of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0.  Case-sensitive match used."

	| last now |
	last := self findString: subString startingAt: start.
	last = 0 ifTrue: [^ 0].
	[last > 0] whileTrue:
		[now := last.
		last := self findString: subString startingAt: last + 1].

	^ now
! !
!CharacterSequence methodsFor: 'accessing' stamp: 'ar 4/11/1999 22:15'!
                             findString: subString
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."
	^self findString: subString startingAt: 1.! !
!CharacterSequence methodsFor: 'accessing' stamp: 'tk 6/19/97 10:05'!
                    findTokens: delimiters keep: keepers
	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"

	| tokens keyStart keyStop |
	tokens _ OrderedCollection new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.
		keyStop to: keyStart-1 do: [:ii | 
			(keepers includes: (self at: ii)) ifTrue: [
				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"
		keyStop _ self findDelimiters: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 6/13/2022 08:40:46'!
       skipAnySubStr: delimiters startingAt: start 
	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."
	| any this ind ii |
	ii _ start-1.
	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"
		any _ false.
		delimiters do: [ :delim |
			delim isCharacter
				ifTrue: [ (self at: ii) = delim ifTrue: [any _ true]]
				ifFalse: ["a substring"
					delim size > (self size - ii + 1) ifFalse: [ "Here's where the one-off error was."
						ind _ 0.
						this _ true.
						delim do: [ :dd | 
							dd = (self at: ii+ind) ifFalse: [this _ false].
							ind _ ind + 1].
						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]
							ifTrue: [any _ false] "if the delim is too big, it can't match"]].
		any ifFalse: [^ ii]].
	^ self size + 1! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 6/13/2022 08:50:22'!
                            evaluateExpression: aString parameters: aCollection 
	"private - evaluate the expression aString with  
	aCollection as the parameters and answer the  
	evaluation result as an string"

	| index |
	index _ ('0' , aString) asNumber.
	index isZero
		ifTrue: [^ '[invalid subscript: {1}]' format: {aString}].
	index > aCollection size
		ifTrue: [^ '[subscript is out of bounds: {1}]' format: {aString}].
	^ (aCollection at: index) asString! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 6/13/2022 08:51:35'!
                              getEnclosedExpressionFrom: aStream
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"

	| result currentChar |
	result _ self class writeStream.
	[aStream atEnd 
		or: [(currentChar _ aStream next) = $}]]
			whileFalse: [result nextPut: currentChar].
	^ result contents withBlanksTrimmed.! !
!CharacterSequence methodsFor: 'formatting' stamp: 'jmv 6/13/2022 08:50:33'!
                     format: aCollection 
	"format the receiver with aCollection  
	 
	simplest example:
	'foo {1} bar' format: {Date today}.
	'foo {1} bar' asUtf8String format: {Date today}.
	 
	complete example:
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}.
	'\{ \} \\ foo {1} bar {2}' asUtf8String format: {12. 'string'}.
	"
	| stream |
	^self class streamContents: [ :out |
		stream _ self readStream.
		[stream atEnd]
			whileFalse: [| currentChar | 
				currentChar _ stream next.
				currentChar = ${
					ifTrue: [| expression | 
						expression _ self getEnclosedExpressionFrom: stream.
						out nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
					ifFalse: [
						currentChar = $\
							ifTrue: [stream atEnd ifFalse: [out nextPut: stream next]]
							ifFalse: [out nextPut: currentChar]]]].! !

String removeSelector: #format:!

!methodRemoval: String #format: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
format: aCollection 
	"format the receiver with aCollection  
	 
	simplest example:  
	'foo {1} bar' format: {Date today}.
	 
	complete example:  
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}.  
	"
	| result stream |
	result := String writeStream.
	stream := self readStream.

	[stream atEnd]
		whileFalse: [| currentChar | 
			currentChar := stream next.
			currentChar = ${
				ifTrue: [| expression | 
					expression := self getEnclosedExpressionFrom: stream.
					result
						nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
				ifFalse: [
					currentChar = $\
						ifTrue: [stream atEnd
								ifFalse: [result nextPut: stream next]]
						ifFalse: [result nextPut: currentChar]]].

	^ result contents!

String removeSelector: #skipAnySubStr:startingAt:!

!methodRemoval: String #skipAnySubStr:startingAt: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
skipAnySubStr: delimiters startingAt: start 
	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."
	| any this ind ii |
	ii _ start-1.
	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"
		any _ false.
		delimiters do: [ :delim |
			delim isCharacter
				ifTrue: [ (self at: ii) = delim ifTrue: [any _ true]]
				ifFalse: ["a substring"
					delim size > (self size - ii + 1) ifFalse: [ "Here's where the one-off error was."
						ind _ 0.
						this _ true.
						delim do: [ :dd | 
							dd = (self at: ii+ind) ifFalse: [this _ false].
							ind _ ind + 1].
						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]
							ifTrue: [any _ false] "if the delim is too big, it can't match"]].
		any ifFalse: [^ ii]].
	^ self size + 1!

String removeSelector: #findLastOccurrenceOfString:startingAt:!

!methodRemoval: String #findLastOccurrenceOfString:startingAt: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
findLastOccurrenceOfString: subString startingAt: start 
	"Answer the index of the last occurrence of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0.  Case-sensitive match used."

	| last now |
	last := self findString: subString startingAt: start.
	last = 0 ifTrue: [^ 0].
	[last > 0] whileTrue:
		[now := last.
		last := self findString: subString startingAt: last + 1].

	^ now
!

String removeSelector: #findString:!

!methodRemoval: String #findString: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
findString: subString
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."
	^self findString: subString startingAt: 1.!

String removeSelector: #evaluateExpression:parameters:!

!methodRemoval: String #evaluateExpression:parameters: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
evaluateExpression: aString parameters: aCollection 
	"private - evaluate the expression aString with  
	aCollection as the parameters and answer the  
	evaluation result as an string"
	| index |
	index := ('0' , aString) asNumber.

	index isZero
		ifTrue: [^ '[invalid subscript: {1}]' format: {aString}].

	index > aCollection size
		ifTrue: [^ '[subscript is out of bounds: {1}]' format: {aString}].

	^ (aCollection at: index) asString!

String removeSelector: #findAnySubStr:startingAt:!

!methodRemoval: String #findAnySubStr:startingAt: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
findAnySubStr: delimiters startingAt: start 
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min ind |
	min _ self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		delim isCharacter
			ifTrue: [ind _ self indexOfSubCollection: (String with: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [ind _ self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
			min _ min min: ind].
	^ min!

String removeSelector: #findTokens:keep:!

!methodRemoval: String #findTokens:keep: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
findTokens: delimiters keep: keepers
	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"

	| tokens keyStart keyStop |
	tokens _ OrderedCollection new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: delimiters startingAt: keyStop.
		keyStop to: keyStart-1 do: [:ii | 
			(keepers includes: (self at: ii)) ifTrue: [
				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"
		keyStop _ self findDelimiters: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens!

String removeSelector: #findBetweenSubStrs:!

!methodRemoval: String #findBetweenSubStrs: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
findBetweenSubStrs: delimiters
	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."

	| tokens keyStart keyStop |
	tokens _ OrderedCollection new.
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipAnySubStr: delimiters startingAt: keyStop.
		keyStop _ self findAnySubStr: delimiters startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens!

String removeSelector: #getEnclosedExpressionFrom:!

!methodRemoval: String #getEnclosedExpressionFrom: stamp: 'Install-5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st 6/16/2022 07:24:54'!
getEnclosedExpressionFrom: aStream 
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"
	| result currentChar |
	result := String writeStream.

	[aStream atEnd 
		or: [(currentChar := aStream next) = $}]]
		whileFalse: [result nextPut: currentChar].

	^ result contents withBlanksTrimmed!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5274-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5271] on 13 June 2022 at 9:04:15 am'!
!CharacterSequence methodsFor: 'copying' stamp: 'di 2/15/98 22:54'!
padded: leftOrRight to: length with: char
	leftOrRight = #left ifTrue: [
		^ (self class new: (length - self size max: 0) withAll: char) , self].
	leftOrRight = #right ifTrue: [
		^ self , (self class new: (length - self size max: 0) withAll: char)].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 08:58:52'!
                     keywords
	"Answer an array of the keywords that compose the receiver."
	| kwd char keywords isAllValidInIdentifiers |
	keywords _ Array streamContents: [ :kwds |
		kwd _ self species writeStream.
		isAllValidInIdentifiers _ true.
		1
			to: self size
			do: [ :i |
				char _ self at: i.
				kwd nextPut: char.
				char = $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers _ true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers _ false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/6/2011 10:34'!
    prefixAndSuffix: aCharacter
	"Answer an array with the prefix up to the last occurrence of aCharacter, and the suffix after it.
	Answer nil if aCharacter is not in self
	'1164-ReferenceStreamFix-jmv.1.cs' prefixAndSuffix: $-
	'1164-ReferenceStreamFix-jmv.1.cs' asUtf8String prefixAndSuffix: $-
	"
	| i |
	i _ self findLast: [ :c | c = aCharacter ].
	i = 0 ifTrue: [ ^ nil ].
	^ { self copyFrom: 1 to: i-1 . self copyFrom: i+1 to: self size }! !
!CharacterSequence methodsFor: 'uCompletion' stamp: 'jmv 11/1/2011 23:20'!
                        separateKeywords

	^self, ' '! !
!Utf8Symbol methodsFor: 'accessing' stamp: 'jmv 6/13/2022 09:01:03'!
                          precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise.  The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c _ self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last = $: ifTrue: [^ 3].
	^ 1! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/13/2022 09:00:44'!
 isKeyword
	"Answer whether the receiver is a message keyword."

	^ self precedence = 3! !
!Utf8Symbol methodsFor: 'uCompletion' stamp: 'jmv 6/13/2022 09:00:06' overrides: 50384112!
           separateKeywords

	^self isKeyword
		ifFalse: [ self, ' ' ]
		ifTrue: [
			self species streamContents: [ :strm |
				self keywords
					do: [ :keyword | strm nextPutAll: keyword ]
					separatedBy: [ strm space; space ].
				strm space]]! !
!Symbol methodsFor: 'uCompletion' stamp: 'jmv 11/1/2011 23:21' prior: 16950878 overrides: 16949349!
          separateKeywords

	^self isKeyword
		ifFalse: [ self, ' ' ]
		ifTrue: [
			self species streamContents: [ :strm |
				self keywords
					do: [ :keyword | strm nextPutAll: keyword ]
					separatedBy: [ strm space; space ].
				strm space]]! !

String removeSelector: #separateKeywords!

!methodRemoval: String #separateKeywords stamp: 'Install-5275-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h52m-jmv.001.cs.st 6/16/2022 07:24:54'!
separateKeywords

	^self, ' '!

String removeSelector: #prefixAndSuffix:!

!methodRemoval: String #prefixAndSuffix: stamp: 'Install-5275-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h52m-jmv.001.cs.st 6/16/2022 07:24:54'!
prefixAndSuffix: aCharacter
	"Answer an array with the prefix up to the last occurrence of aCharacter, and the suffix after it.
	Answer nil if aCharacter is not in self
	'1164-ReferenceStreamFix-jmv.1.cs' prefixAndSuffix: $-
	"
	| i |
	i _ self findLast: [ :c | c = aCharacter ].
	i = 0 ifTrue: [ ^ nil ].
	^ { self copyFrom: 1 to: i-1 . self copyFrom: i+1 to: self size }!

String removeSelector: #padded:to:with:!

!methodRemoval: String #padded:to:with: stamp: 'Install-5275-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h52m-jmv.001.cs.st 6/16/2022 07:24:54'!
padded: leftOrRight to: length with: char
	leftOrRight = #left ifTrue:
		[^ (String new: (length - self size max: 0) withAll: char) , self].
	leftOrRight = #right ifTrue:
		[^ self , (String new: (length - self size max: 0) withAll: char)].!

String removeSelector: #keywords!

!methodRemoval: String #keywords stamp: 'Install-5275-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h52m-jmv.001.cs.st 6/16/2022 07:24:54'!
keywords
	"Answer an array of the keywords that compose the receiver."
	| kwd char keywords isAllValidInIdentifiers |
	keywords _ Array streamContents: [ :kwds |
		kwd _ String writeStream.
		isAllValidInIdentifiers _ true.
		1
			to: self size
			do: [ :i |
				char _ self at: i.
				kwd nextPut: char.
				char = $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers _ true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers _ false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5275-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-08h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5271] on 13 June 2022 at 9:33:19 am'!
!Utf8Symbol methodsFor: 'private' stamp: 'jmv 6/13/2022 09:19:51' overrides: 16823689!
                     species
	^Utf8String! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 09:24:10' prior: 50383498!
              copyReplacing: rangesToNewStrings

	^self species streamContents: [ :replacementStream |
		self copyReplacing: rangesToNewStrings into: replacementStream ].! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 09:24:04' prior: 50383520!
      copyReplacing: ranges with: newString

	"Ranges must be in order, with first ranges first. If not, result is unexpected - Hernan"

	^ self species streamContents: [ :replacementStream |
		self copyReplacing: ranges with: newString into: replacementStream ]
		! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 09:27:18' prior: 50384062!
                               padded: leftOrRight to: length with: char
	leftOrRight = #left ifTrue: [
		^ (self species new: (length - self size max: 0) withAll: char) , self].
	leftOrRight = #right ifTrue: [
		^ self , (self species new: (length - self size max: 0) withAll: char)].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 09:20:05' prior: 50383008!
 capitalized
	"Answer an object like the receiver but with first character downshifted if necesary
	'mElViN' asUtf8String capitalized
	'MElViN' asUtf8String capitalized
	('will', Random next mantissaPart printString) asUtf8String asSymbol capitalized
	('Will', Random next mantissaPart printString) asUtf8String asSymbol capitalized
	"
	self isEmpty ifTrue: [^ self].
	self first isUppercase ifTrue: [ ^self ].
	^self species streamContents: [ :strm | | isFirst corrected |
		isFirst _ true.
		self do: [ :codePoint |
			isFirst
				ifTrue: [
					corrected _ codePoint asUppercase.
					isFirst _ false ]
				ifFalse: [corrected _ codePoint].
			strm nextPut: corrected ]]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 09:27:49' prior: 50382466!
                               squeezedTo: n
	"
Examples:
	Do nothing:
		'This one is a rather long phrase' squeezedTo: 32
		'This one is a rather long phrase' asUtf8String squeezedTo: 32

	1-remove blanks (result can be shorter than asked):
		'This one is a rather long phrase' squeezedTo: 30
		'This one is a rather long phrase' asUtf8String squeezedTo: 30

	2-remove necessary trailing vowels
		'This one is a rather long phrase' squeezedTo: 24
		'This one is a rather long phrase' asUtf8String squeezedTo: 24

	3-truncate as needed (and add ellipsis)
		'This one is a rather long phrase' squeezedTo: 15
		'This one is a rather long phrase' asUtf8String squeezedTo: 15

	4-avoid ellipsis
		'This one is a rather long phrase' squeezedTo: 5
		'This one is a rather long phrase' asUtf8String squeezedTo: 5
	"
	| vowelCount read write i char allowedVowels str desiredSize postFix j |
	str _ self.
	desiredSize _ n.
	str size <= n ifTrue: [^str].
	str _ str asCamelCase.
	str size <= n ifTrue: [^str].
	postFix _ ''.
	desiredSize _ n - postFix size.
	vowelCount _ str
		inject: 0
		into: [:prev :each | each isVowel ifTrue: [prev + 1] ifFalse: [prev]].
	str size - vowelCount <= desiredSize
		ifTrue: [allowedVowels _ vowelCount - (str size - desiredSize)]
		ifFalse: [
			allowedVowels _ 0.
			postFix _ '...'.
			n - postFix size < 5 ifTrue: [postFix _ ''].
			desiredSize _ n - postFix size].

	read _ str readStream.
	write _ self species writeStream.
	i _ 0.
	j _ 0.
	[read atEnd not and: [j < desiredSize]] whileTrue: [
		char _ read next.
		(char isVowel not or: [i < allowedVowels]) ifTrue: [
			char isVowel ifTrue: [i := i + 1].
			write nextPut: char.
			j _ j + 1]].
	str _ write contents , postFix.
	^ str! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 09:28:02' prior: 50383095!
          uncapitalized
	"Answer an object like the receiver but with first character downshifted if necesary
	'MElViN' asUtf8String uncapitalized
	'mElViN' asUtf8String uncapitalized
	('Will', Random next mantissaPart printString) asUtf8String asSymbol uncapitalized
	('will', Random next mantissaPart printString) asUtf8String asSymbol uncapitalized
	"
	self isEmpty ifTrue: [^ self].
	self first isLowercase ifTrue: [ ^self ].
	^self species streamContents: [ :strm | | isFirst corrected |
		isFirst _ true.
		self do: [ :codePoint |
			isFirst
				ifTrue: [
					corrected _ codePoint asLowercase.
					isFirst _ false ]
				ifFalse: [corrected _ codePoint].
			strm nextPut: corrected ]]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 09:28:22' prior: 50382721!
                     withBlanksCondensed
	"Return a copy of the receiver with leading/trailing blanks removed
	 and consecutive white spaces condensed as a single space."

	| trimmed lastWasBlank |
	trimmed _ self withBlanksTrimmed.
	^self species streamContents: [ :stream |
		lastWasBlank _ false.
		trimmed do: [ :c |
			c isSeparator
				ifTrue: [ lastWasBlank ifFalse: [ stream space ]]
				ifFalse: [ stream nextPut: c ].
			lastWasBlank _ c isSeparator ]].

	"
	' abc  d   ' withBlanksCondensed
	' abc  d   ' asUtf8String withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' asUtf8String withBlanksCondensed
	"! !
!CharacterSequence methodsFor: 'enumerating' stamp: 'jmv 6/13/2022 09:21:00' prior: 50374490 overrides: 16934336!
     collect: aBlock
	"Refer to the comment in Collection >> #collect:."
	| array |
	array _ self collectInArray: aBlock.
	(array allSatisfy: [ :c | c isCharacter ]) ifFalse: [
		^array ].
	^self species newFrom: array! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 6/13/2022 09:25:45' prior: 50383788!
             getEnclosedExpressionFrom: aStream
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"

	| result currentChar |
	result _ self species writeStream.
	[aStream atEnd 
		or: [(currentChar _ aStream next) = $}]]
			whileFalse: [result nextPut: currentChar].
	^ result contents withBlanksTrimmed.! !
!CharacterSequence methodsFor: 'formatting' stamp: 'jmv 6/13/2022 09:25:19' prior: 50383802!
   format: aCollection
	"format the receiver with aCollection  
	 
	simplest example:
	'foo {1} bar' format: {Date today}.
	'foo {1} bar' asUtf8String format: {Date today}.
	 
	complete example:
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}.
	'\{ \} \\ foo {1} bar {2}' asUtf8String format: {12. 'string'}.
	"
	| stream |
	^self species streamContents: [ :out |
		stream _ self readStream.
		[stream atEnd]
			whileFalse: [| currentChar | 
				currentChar _ stream next.
				currentChar = ${
					ifTrue: [| expression | 
						expression _ self getEnclosedExpressionFrom: stream.
						out nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
					ifFalse: [
						currentChar = $\
							ifTrue: [stream atEnd ifFalse: [out nextPut: stream next]]
							ifFalse: [out nextPut: currentChar]]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5276-StringMethods-Use-species-not-class-JuanVuletich-2022Jun13-09h04m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5275] on 13 June 2022 at 10:04:59 am'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 10:01:22' prior: 50381107!
                  asCamelCase
	"Answer a new String, without any whitespace, and with words capitalized (Except for the first one)
	' how do you do? ' asCamelCase
	' how do you do? ' asUtf8String asCamelCase
	"
	^ self species streamContents: [ :outStream | | inStream capitalize wroteSome |
		wroteSome _ false.
		capitalize _ false.
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [ | c |
			c _ inStream next.
			c isSeparator
				ifTrue: [ capitalize _ true ]
				ifFalse: [
					capitalize & wroteSome ifTrue: [ c _ c asUppercase ].
					outStream nextPut: c.
					wroteSome _ true.
					capitalize _ false ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5277-CharacterSequence-fix-JuanVuletich-2022Jun13-09h59m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5276] on 13 June 2022 at 10:32:07 am'!
!Utf8Symbol methodsFor: 'copying' stamp: 'jmv 6/13/2022 10:25:41' overrides: 16901967!
                     shallowCopy
	"Answer with me, because Symbols are unique."! !
!Utf8Symbol methodsFor: 'converting' stamp: 'jmv 6/13/2022 10:30:50'!
                            numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs offs |
	(numArgs _ self numArgs) >= n ifTrue: [ ^self ].	
	^ (Utf8String streamContents: [ :strm |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs _ 0 ] ifFalse: [offs _ 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/13/2022 10:28:04'!
                               isInfix
	"Answer whether the receiver is an infix message selector."

	^ self precedence = 2! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/13/2022 10:26:58'!
                             isUnary
	"Answer whether the receiver is an unary message selector."

	^ self precedence = 1! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/13/2022 10:27:53'!
                             isValidBinarySelector

	^ self isInfix and: [ self allSatisfy: [ :character | character isValidInBinarySelectors ] ]! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/13/2022 10:28:38'!
     isValidKeywordSelector

	^ self isKeyword and: [ self keywords allSatisfy: [ :keywordString | keywordString allButLast asSymbol isValidSelector ] ]! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/13/2022 10:27:23'!
      isValidSelector

	^ self isValidUnarySelector
		or: [ self isValidBinarySelector ]
		or: [ self isValidKeywordSelector ]! !
!Utf8Symbol methodsFor: 'testing' stamp: 'jmv 6/13/2022 10:27:32'!
 isValidUnarySelector

	^ self isUnary and: [ self allSatisfy: [ :character | character isValidInIdentifiers ] ]! !
!Symbol methodsFor: 'converting' stamp: 'jmv 6/13/2022 10:30:31' prior: 50366710!
                           numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs offs |
	(numArgs _ self numArgs) >= n ifTrue: [ ^self ].	
	^ (String streamContents: [ :strm |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs _ 0 ] ifFalse: [offs _ 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5278-Utf8Symbol-stuff-JuanVuletich-2022Jun13-10h25m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5276] on 13 June 2022 at 10:44:57 am'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 3/13/2012 22:08'!
                      lines
	"Answer an array of lines composing this receiver without the line ending delimiters."

	^Array
		streamContents: [ :lines | self linesDo: [ :aLine | lines nextPut: aLine ]]
		estimatedSize: (self size // 60 max: 16)! !
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/13/2022 10:39:11'!
                   join: aCollection 
	"
	'*' join: #('WWWWW' 'W  EW' 'zzzz')
	'*' asUtf8String join: #('WWWWW' 'W  EW' 'zzzz')
		->  'WWWWW*W  EW*zzzz' "

	^self species streamContents: [ :strm |
		aCollection
			do: [ :elem | strm nextPutAll: elem asString]
			separatedBy: [strm nextPutAll: self]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'sw 9/2/1998 17:09'!
                          truncateWithElipsisTo: maxLength
	"Return myself or a copy suitably shortened but with elipsis added"

	^ self size <= maxLength
		ifTrue:
			[self]
		ifFalse:
			[(self copyFrom: 1 to: (maxLength - 3)), '...']


	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !
!CharacterSequence methodsFor: 'fileman-accessing' stamp: 'jmv 10/16/2015 14:21'!
indexOfLastPathSeparator
	"
	'pp.txt' indexOfLastPathSeparator
	'/pp.txt' indexOfLastPathSeparator
	'a/pp.txt' indexOfLastPathSeparator
	'b/a/pp.txt' indexOfLastPathSeparator
	'/b/a/pp.txt' indexOfLastPathSeparator
	"
	^self findLast: [ :char | char isPathSeparator ]! !
!CharacterSequence methodsFor: 'fileman-accessing' stamp: 'mu 5/7/2007 15:55'!
  pathAndLocalName
	| index path localName |
	index := self indexOfLastPathSeparator.
	index = 0 ifTrue: [^{''. self}].

	path := self copyFrom: 1 to: index-1.
	localName := self copyFrom: index+1 to: self size.

	^{path. localName}

	! !
!CharacterSequence methodsFor: 'fileman-accessing' stamp: 'mu 5/7/2007 15:49'!
    upToLastPathSeparator
	| index |
	self ifEmpty: [^self].
	index := self indexOfLastPathSeparator.
	index = 0 ifTrue: [^self].
	^self copyFrom: 1 to: index - 1
	! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/13/2022 10:34:24'!
                      surroundedBySingleQuotes
	"Answer the receiver with leading and trailing quotes.  "

	^ `(Utf8String with: $')`, self, `(Utf8String with: $')`! !

String removeSelector: #truncateWithElipsisTo:!

!methodRemoval: String #truncateWithElipsisTo: stamp: 'Install-5279-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-10h32m-jmv.001.cs.st 6/16/2022 07:24:54'!
truncateWithElipsisTo: maxLength
	"Return myself or a copy suitably shortened but with elipsis added"

	^ self size <= maxLength
		ifTrue:
			[self]
		ifFalse:
			[(self copyFrom: 1 to: (maxLength - 3)), '...']


	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"!

String removeSelector: #join:!

!methodRemoval: String #join: stamp: 'Install-5279-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-10h32m-jmv.001.cs.st 6/16/2022 07:24:54'!
join: aCollection 
	"'*' join: #('WWWWW' 'W  EW' 'zzzz')
		->  'WWWWW*W  EW*zzzz' "

	^String streamContents: [ :strm |
		aCollection
			do: [ :elem | strm nextPutAll: elem asString]
			separatedBy: [strm nextPutAll: self]].!

String removeSelector: #indexOfLastPathSeparator!

!methodRemoval: String #indexOfLastPathSeparator stamp: 'Install-5279-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-10h32m-jmv.001.cs.st 6/16/2022 07:24:54'!
indexOfLastPathSeparator
	"
	'pp.txt' indexOfLastPathSeparator
	'/pp.txt' indexOfLastPathSeparator
	'a/pp.txt' indexOfLastPathSeparator
	'b/a/pp.txt' indexOfLastPathSeparator
	'/b/a/pp.txt' indexOfLastPathSeparator
	"
	^self findLast: [ :char | char isPathSeparator ]!

String removeSelector: #lines!

!methodRemoval: String #lines stamp: 'Install-5279-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-10h32m-jmv.001.cs.st 6/16/2022 07:24:54'!
lines
	"Answer an array of lines composing this receiver without the line ending delimiters."

	^Array
		streamContents: [ :lines | self linesDo: [ :aLine | lines nextPut: aLine ]]
		estimatedSize: (self size // 60 max: 16)!

String removeSelector: #upToLastPathSeparator!

!methodRemoval: String #upToLastPathSeparator stamp: 'Install-5279-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-10h32m-jmv.001.cs.st 6/16/2022 07:24:54'!
upToLastPathSeparator
	| index |
	self ifEmpty: [^self].
	index := self indexOfLastPathSeparator.
	index = 0 ifTrue: [^self].
	^self copyFrom: 1 to: index - 1
	!

String removeSelector: #pathAndLocalName!

!methodRemoval: String #pathAndLocalName stamp: 'Install-5279-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-10h32m-jmv.001.cs.st 6/16/2022 07:24:54'!
pathAndLocalName
	| index path localName |
	index := self indexOfLastPathSeparator.
	index = 0 ifTrue: [^{''. self}].

	path := self copyFrom: 1 to: index-1.
	localName := self copyFrom: index+1 to: self size.

	^{path. localName}

	!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5279-MoveUpToCharacterSequence-JuanVuletich-2022Jun13-10h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5276] on 13 June 2022 at 10:47:19 am'!
!String methodsFor: 'fileman-converting' stamp: 'jmv 6/13/2022 10:46:09' prior: 16949372!
   asDriveName
	"Answer a real drive name, or else answer nil.
	(Original FileMan implementation would answer first token on Mac even if it is not a Drive Name,
	and self in any case in other Unix variants)
	
Windows
	'C:\' asDriveName 'C:'
	'NotAChance' asDriveName nil
	
Linux
	'/media/cdrom' asDriveName nil

MacOsX
    '/SanDisk32-NTFS' asDriveName nil
	
	"
	FileIOAccessor default onWindows ifTrue: [
		self beginsWithWindowsDriveName ifTrue: [ 
		^self copyFrom: 1 to: 2 ]].
	
	^ nil! !
!String methodsFor: 'fileman-testing' stamp: 'jmv 6/13/2022 10:46:33' prior: 16949481!
                               isAbsolutePathName
	"Note: On Windows, both 'C:\Users\Someone\file.txt' and '\Users\Someone\file.txt'
	and even '/Users/Someone/file.txt' are considered an absolute pathName.
	This is essentially because FilePlugin can handle them. The gained uniformity with Unix is nice."
	
	self isEmpty ifTrue: [^ false].
	self first isPathSeparator ifTrue: [^ true].

	FileIOAccessor default onWindows
		ifTrue: [
			^ self beginsWithWindowsDriveName and: [ self size = 2 or: [ (self at: 3) isPathSeparator ]]].

	^ false! !
!String methodsFor: 'fileman-testing' stamp: 'jmv 6/13/2022 10:46:43' prior: 16949509!
        isDriveName
	FileIOAccessor default onWindows
		ifTrue: [
			^ (self size between: 2 and: 3)
				and: [self beginsWithWindowsDriveName]].

	^false! !
!FileIOAccessor methodsFor: 'testing' stamp: 'jmv 6/13/2022 10:46:50' prior: 16854844!
                   isDriveSupported
	^self onWindows! !

FileIOAccessor removeSelector: #onMacClassic!

!methodRemoval: FileIOAccessor #onMacClassic stamp: 'Install-5280-Remove-Obsolete-MacClassic-Stuff-JuanVuletich-2022Jun13-10h44m-jmv.001.cs.st 6/16/2022 07:24:54'!
onMacClassic
	^self pathNameDelimiter = $:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5280-Remove-Obsolete-MacClassic-Stuff-JuanVuletich-2022Jun13-10h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5279] on 14 June 2022 at 12:26:32 pm'!
!CharacterSequence methodsFor: 'copying' stamp: 'jmv 6/14/2022 12:25:35'!
                          append: aStringOrText

	^ aStringOrText appendToString: self! !
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 6/23/2011 09:54'!
                       commonPrefixWith: aString
	"Return the size of the longest common prefix with aString.
	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly.
	'this is a string' commonPrefixWith: 'this is another'
	'this is a string' commonPrefixWith: ''
	'' commonPrefixWith: 'this is another'
	't' commonPrefixWith: 'this is another'
	'txxxxxxxxx' commonPrefixWith: 'this is another'

	'this is a string' commonPrefixWith: 'this is another' asUtf8String
	'this is a string' commonPrefixWith: '' asUtf8String
	'' commonPrefixWith: 'this is another' asUtf8String
	't' commonPrefixWith: 'this is another' asUtf8String
	'txxxxxxxxx' commonPrefixWith: 'this is another' asUtf8String

	'this is a string' asUtf8String commonPrefixWith: 'this is another'
	'this is a string' asUtf8String commonPrefixWith: ''
	'' asUtf8String commonPrefixWith: 'this is another'
	't' asUtf8String commonPrefixWith: 'this is another'
	'txxxxxxxxx' asUtf8String commonPrefixWith: 'this is another'

	'this is a string' asUtf8String commonPrefixWith: 'this is another' asUtf8String
	'this is a string' asUtf8String commonPrefixWith: '' asUtf8String
	'' asUtf8String commonPrefixWith: 'this is another' asUtf8String
	't' asUtf8String commonPrefixWith: 'this is another' asUtf8String
	'txxxxxxxxx' asUtf8String commonPrefixWith: 'this is another' asUtf8String
		"
	^ self commonPartWith: aString startAt: 1 stopAt: self size applying: [ :c | c ]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 10:54:41'!
   asIdentifier: shouldBeCapitalized
	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"

	| aString |
	aString _ self select: [ :el | el isValidInIdentifiers ].
	(aString isEmpty or: [aString first isValidStartOfIdentifiers not])
		ifTrue:	 [aString _ 'a', aString].
	^ shouldBeCapitalized ifTrue: [ aString capitalized ] ifFalse: [ aString uncapitalized ]

"
'234Fred987' asIdentifier: false
'235Fred987' asIdentifier: true
'' asIdentifier: true
'()87234' asIdentifier: false
'())z>=PPve889  U >' asIdentifier: false

'234Fred987' asUtf8String asIdentifier: false
'235Fred987' asUtf8String asIdentifier: true
'' asUtf8String asIdentifier: true
'()87234' asUtf8String asIdentifier: false
'())z>=PPve889  U >' asUtf8String asIdentifier: false
"! !
!CharacterSequence methodsFor: 'converting' stamp: 'ls 10/28/2003 12:24'!
         asSmalltalkComment
	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"

	^String streamContents:  [ :str |
		| quoteCount first |

		str nextPut: $".
	
		quoteCount := 0.
		first := true.
		self do: [ :char |
			char = $"
				ifTrue: [
					first ifFalse: [
						str nextPut: char.
						quoteCount := quoteCount + 1 ] ]
				ifFalse: [
					quoteCount odd ifTrue: [
						"add a quote to even the number of quotes in a row"
						str nextPut: $" ].
					quoteCount := 0.
					str nextPut: char ].
			first := false ]. 

		quoteCount odd ifTrue: [
			"check at the end"
			str nextPut: $". ].

		str nextPut: $".
	].
	! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 10:56:52'!
                      asValidInstanceVariableName
	| answer |
	answer _ self asIdentifier: false.
	(Scanner pseudoVariableNames includes: answer)
		ifTrue: [ answer _ answer , 'x' ].
	^ answer

"
'234znak 43 ) 2' asValidInstanceVariableName
'234 xx\ Uml /ler42342380-4' asValidInstanceVariableName
'super' asValidInstanceVariableName
'234znak 43 ) 2' asUtf8String asValidInstanceVariableName
'234 xx\ Uml /ler42342380-4' asUtf8String asValidInstanceVariableName
'super' asUtf8String asValidInstanceVariableName
"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 10:55:40'!
     asValidSelector
	^ self asIdentifier: false

"
'234znak 43 ) 2' asValidSelector
'234znak 43 ) 2' asUtf8String asValidSelector
"! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 6/13/2022 11:04:05'!
        asDriveName
	"Answer a real drive name, or else answer nil.
	(Original FileMan implementation would answer first token on Mac even if it is not a Drive Name,
	and self in any case in other Unix variants)
	
Windows
	'C:\' asDriveName 'C:'
	'NotAChance' asDriveName nil
	
Linux
	'/media/cdrom' asDriveName nil

MacOsX
    '/SanDisk32-NTFS' asDriveName nil
	
	"
	FileIOAccessor default onWindows ifTrue: [
		self beginsWithWindowsDriveName ifTrue: [ 
		^self copyFrom: 1 to: 2 ]].
	
	^ nil! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'mu 3/4/2007 10:22'!
         beginsWithPathSeparator
	self ifEmpty: [^false].
	^self first isPathSeparator! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'jmv 6/13/2022 10:47:58'!
                             isAbsolutePathName
	"Note: On Windows, both 'C:\Users\Someone\file.txt' and '\Users\Someone\file.txt'
	and even '/Users/Someone/file.txt' are considered an absolute pathName.
	This is essentially because FilePlugin can handle them. The gained uniformity with Unix is nice."
	
	self isEmpty ifTrue: [^ false].
	self first isPathSeparator ifTrue: [^ true].

	FileIOAccessor default onWindows
		ifTrue: [
			^ self beginsWithWindowsDriveName and: [ self size = 2 or: [ (self at: 3) isPathSeparator ]]].

	^ false! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'jmv 6/13/2022 10:47:29'!
             isDriveName
	FileIOAccessor default onWindows
		ifTrue: [
			^ (self size between: 2 and: 3)
				and: [self beginsWithWindowsDriveName]].

	^false! !
!CharacterSequence methodsFor: 'paragraph support' stamp: 'jmv 6/13/2022 10:49:26'!
                      endOfParagraphBefore: aNumber
	"Return the index of the last Character newLineCharacter before position aNumber, or zero if this is the first paragraph.
	'ddd' endOfParagraphBefore: 3
	'dd
	d' endOfParagraphBefore: 4
	"
	^ self lastIndexOf: Character newLineCharacter startingAt: aNumber - 1 ifAbsent: [ 0 ]! !
!CharacterSequence methodsFor: 'paragraph support' stamp: 'jmv 6/13/2022 10:48:57'!
                     indentationIfBlank: aBlock
	"Answer the number of leading tabs in the receiver.  If there are
	 no visible characters, pass the number of tabs to aBlock and return its value."
	| reader leadingTabs lastSeparator tab ch |
	tab _ Character tab.
	reader _ self readStream.
	leadingTabs _ 0.
	[ reader atEnd not and: [ (ch _ reader next) == tab ]] whileTrue: [
		leadingTabs _ leadingTabs + 1 ].
	lastSeparator _ leadingTabs + 1.
	[ reader atEnd not and: [
		ch isSeparator and: [ ch isLineSeparator not ]]] whileTrue: [
			lastSeparator _ lastSeparator + 1.
			ch _ reader next ].
	lastSeparator = self size | (ch notNil and: [ch isLineSeparator]) ifTrue: [
		^ aBlock value: leadingTabs ].
	^ leadingTabs! !
!Text methodsFor: 'accessing' stamp: 'KenD 9/5/2016 15:59:40' prior: 16963479!
               append: stringOrText

	^ stringOrText appendToText: self! !

String removeSelector: #endOfParagraphBefore:!

!methodRemoval: String #endOfParagraphBefore: stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
endOfParagraphBefore: aNumber
	"Return the index of the last Character newLineCharacter before position aNumber, or zero if this is the first paragraph.
	'ddd' endOfParagraphBefore: 3
	'dd
	d' endOfParagraphBefore: 4
	"
	^ self lastIndexOf: Character newLineCharacter startingAt: aNumber - 1 ifAbsent: [ 0 ]!

String removeSelector: #indentationIfBlank:!

!methodRemoval: String #indentationIfBlank: stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
indentationIfBlank: aBlock
	"Answer the number of leading tabs in the receiver.  If there are
	 no visible characters, pass the number of tabs to aBlock and return its value."
	| reader leadingTabs lastSeparator tab ch |
	tab _ Character tab.
	reader _ self readStream.
	leadingTabs _ 0.
	[ reader atEnd not and: [ (ch _ reader next) == tab ]] whileTrue: [
		leadingTabs _ leadingTabs + 1 ].
	lastSeparator _ leadingTabs + 1.
	[ reader atEnd not and: [
		ch isSeparator and: [ ch isLineSeparator not ]]] whileTrue: [
			lastSeparator _ lastSeparator + 1.
			ch _ reader next ].
	lastSeparator = self size | (ch notNil and: [ch isLineSeparator]) ifTrue: [
		^ aBlock value: leadingTabs ].
	^ leadingTabs!

String removeSelector: #asIdentifier:!

!methodRemoval: String #asIdentifier: stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
asIdentifier: shouldBeCapitalized
	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"

	| aString |
	aString _ self select: [ :el | el isValidInIdentifiers ].
	(aString isEmpty or: [aString first isValidStartOfIdentifiers not])
		ifTrue:	 [aString _ 'a', aString].
	^ shouldBeCapitalized ifTrue: [ aString capitalized ] ifFalse: [ aString uncapitalized ]

"
'234Fred987' asIdentifier: false
'235Fred987' asIdentifier: true
'' asIdentifier: true
'()87234' asIdentifier: false
'())z>=PPve889  U >' asIdentifier: false
"!

String removeSelector: #asSmalltalkComment!

!methodRemoval: String #asSmalltalkComment stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
asSmalltalkComment
	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"

	^String streamContents:  [ :str |
		| quoteCount first |

		str nextPut: $".
	
		quoteCount := 0.
		first := true.
		self do: [ :char |
			char = $"
				ifTrue: [
					first ifFalse: [
						str nextPut: char.
						quoteCount := quoteCount + 1 ] ]
				ifFalse: [
					quoteCount odd ifTrue: [
						"add a quote to even the number of quotes in a row"
						str nextPut: $" ].
					quoteCount := 0.
					str nextPut: char ].
			first := false ]. 

		quoteCount odd ifTrue: [
			"check at the end"
			str nextPut: $". ].

		str nextPut: $".
	].
	!

String removeSelector: #commonPrefixWith:!

!methodRemoval: String #commonPrefixWith: stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
commonPrefixWith: aString
	"Return the size of the longest common prefix with aString.
	Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly.
	'this is a string' commonPrefixWith: 'this is another'
	'this is a string' commonPrefixWith: ''
	'' commonPrefixWith: 'this is another'
	't' commonPrefixWith: 'this is another'
	'txxxxxxxxx' commonPrefixWith: 'this is another'
		"
	^ self commonPartWith: aString startAt: 1 stopAt: self size applying: [ :c | c ]!

String removeSelector: #asValidInstanceVariableName!

!methodRemoval: String #asValidInstanceVariableName stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
asValidInstanceVariableName
	| answer |
	answer _ self asIdentifier: false.
	(Scanner pseudoVariableNames includes: answer)
		ifTrue: [ answer _ answer , 'x' ].
	^ answer

"
'234znak 43 ) 2' asValidInstanceVariableName
'234 xx\ Uml /ler42342380-4' asValidInstanceVariableName
"!

String removeSelector: #isDriveName!

!methodRemoval: String #isDriveName stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
isDriveName
	FileIOAccessor default onWindows
		ifTrue: [
			^ (self size between: 2 and: 3)
				and: [self beginsWithWindowsDriveName]].

	^false!

String removeSelector: #asDriveName!

!methodRemoval: String #asDriveName stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
asDriveName
	"Answer a real drive name, or else answer nil.
	(Original FileMan implementation would answer first token on Mac even if it is not a Drive Name,
	and self in any case in other Unix variants)
	
Windows
	'C:\' asDriveName 'C:'
	'NotAChance' asDriveName nil
	
Linux
	'/media/cdrom' asDriveName nil

MacOsX
    '/SanDisk32-NTFS' asDriveName nil
	
	"
	FileIOAccessor default onWindows ifTrue: [
		self beginsWithWindowsDriveName ifTrue: [ 
		^self copyFrom: 1 to: 2 ]].
	
	^ nil!

String removeSelector: #asValidSelector!

!methodRemoval: String #asValidSelector stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
asValidSelector
	^ self asIdentifier: false

"
'234znak 43 ) 2' asValidSelector
"!

String removeSelector: #append:!

!methodRemoval: String #append: stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
append: aStringOrText

	^ aStringOrText appendToString: self!

String removeSelector: #isAbsolutePathName!

!methodRemoval: String #isAbsolutePathName stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
isAbsolutePathName
	"Note: On Windows, both 'C:\Users\Someone\file.txt' and '\Users\Someone\file.txt'
	and even '/Users/Someone/file.txt' are considered an absolute pathName.
	This is essentially because FilePlugin can handle them. The gained uniformity with Unix is nice."
	
	self isEmpty ifTrue: [^ false].
	self first isPathSeparator ifTrue: [^ true].

	FileIOAccessor default onWindows
		ifTrue: [
			^ self beginsWithWindowsDriveName and: [ self size = 2 or: [ (self at: 3) isPathSeparator ]]].

	^ false!

String removeSelector: #beginsWithPathSeparator!

!methodRemoval: String #beginsWithPathSeparator stamp: 'Install-5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st 6/16/2022 07:24:54'!
beginsWithPathSeparator
	self ifEmpty: [^false].
	^self first isPathSeparator!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5281-MoveUpToCharacterSequence-JuanVuletich-2022Jun14-12h22m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5280] on 13 June 2022 at 3:30:12 pm'!
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 6/13/2022 15:23:00'!
                     alike: aString
	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."

	| i j k minSize bonus |
	minSize _ (j _ self size) min: (k _ aString size).
	bonus _ (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].

	i _ 1.
	[(i <= minSize) and: [(self at: i) asUppercase = (aString at: i) asUppercase]]
		whileTrue: [ i _ i + 1 ].

	[(j > 0) and: [(k > 0) and:
		[(self at: j) asUppercase = (aString at: k) asUppercase]]]
			whileTrue: [ j _ j - 1.  k _ k - 1. ].

	^ i - 1 + self size - j + bonus.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 15:16:43'!
                   asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in char rest did |
	in _ self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [(char _ in next) = $&
					ifTrue: [
						rest _ in upTo: $;.
						did _ out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $°].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character numericValue: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'Squeak1.0 9/20/1996 10:50:05'!
          correctAgainst: wordList
	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"
	| results |
	results _ self correctAgainst: wordList continuedFrom: nil.
	results _ self correctAgainst: nil continuedFrom: results.
	^ results! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 3/2/2010 16:36'!
         correctAgainst: wordList continuedFrom: oldCollection
	"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."

	^ wordList
		ifNil: [
			self correctAgainstEnumerator: nil continuedFrom: oldCollection ]
		ifNotNil: [
			self
				correctAgainstEnumerator: [ :action | wordList do: action without: nil]
				continuedFrom: oldCollection ]! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 3/2/2010 16:37'!
           correctAgainstDictionary: wordDict continuedFrom: oldCollection
	"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary."

	^ wordDict
		ifNil: [
			self correctAgainstEnumerator: nil continuedFrom: oldCollection ]
		ifNotNil: [
			self
				correctAgainstEnumerator: [ :action | wordDict keysDo: action ]
				continuedFrom: oldCollection ]! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 3/2/2010 16:38'!
  correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results score maxChoices |
	scoreMin _ self size // 2 min: 3.
	maxChoices _ 10.
	choices _ oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results _ OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				(score _ self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) value] ] ].
			results _ choices ].
	^ results! !

String removeSelector: #correctAgainstEnumerator:continuedFrom:!

!methodRemoval: String #correctAgainstEnumerator:continuedFrom: stamp: 'Install-5282-MoveUpToCharacterSequence-correct-alike-JuanVuletich-2022Jun13-15h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results score maxChoices |
	scoreMin _ self size // 2 min: 3.
	maxChoices _ 10.
	choices _ oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results _ OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				(score _ self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin _ (choices at: maxChoices) value] ] ].
			results _ choices ].
	^ results!

String removeSelector: #correctAgainstDictionary:continuedFrom:!

!methodRemoval: String #correctAgainstDictionary:continuedFrom: stamp: 'Install-5282-MoveUpToCharacterSequence-correct-alike-JuanVuletich-2022Jun13-15h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
correctAgainstDictionary: wordDict continuedFrom: oldCollection
	"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary."

	^ wordDict
		ifNil: [
			self correctAgainstEnumerator: nil continuedFrom: oldCollection ]
		ifNotNil: [
			self
				correctAgainstEnumerator: [ :action | wordDict keysDo: action ]
				continuedFrom: oldCollection ]!

String removeSelector: #asUnHtml!

!methodRemoval: String #asUnHtml stamp: 'Install-5282-MoveUpToCharacterSequence-correct-alike-JuanVuletich-2022Jun13-15h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in out char rest did |
	in _ self readStream.
	out _ String writeStream.
	[ in atEnd ] whileFalse: [
		in peek = $<
			ifTrue: [in unCommand] 	"Absorb <...><...>"
			ifFalse: [(char _ in next) = $&
				ifTrue: [
					rest _ in upTo: $;.
					did _ out position.
					rest = 'lt' ifTrue: [out nextPut: $<].
					rest = 'gt' ifTrue: [out nextPut: $>].
					rest = 'amp' ifTrue: [out nextPut: $&].
					rest = 'deg' ifTrue: [out nextPut: $°].
					rest = 'quot' ifTrue: [out nextPut: $"].
					rest first = $# ifTrue: [ out nextPut: (Character numericValue: rest findPositiveInteger) ].
					did = out position ifTrue: [
						out nextPut: $&; nextPutAll: rest.
						"self error: 'unknown encoded HTML char'."
						"Please add it to this method"]]
				ifFalse: [out nextPut: char]].
		].
	^ out contents!

String removeSelector: #alike:!

!methodRemoval: String #alike: stamp: 'Install-5282-MoveUpToCharacterSequence-correct-alike-JuanVuletich-2022Jun13-15h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
alike: aString 
	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."

	| i j k minSize bonus |
	minSize _ (j _ self size) min: (k _ aString size).
	bonus _ (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].
	i _ 1.
	[(i <= minSize) and: [((super at: i) bitAnd: 16rDF)  = ((aString at: i) numericValue bitAnd: 16rDF)]]
		whileTrue: [ i _ i + 1 ].
	[(j > 0) and: [(k > 0) and:
		[((super at: j) bitAnd: 16rDF) = ((aString at: k) numericValue bitAnd: 16rDF)]]]
			whileTrue: [ j _ j - 1.  k _ k - 1. ].
	^ i - 1 + self size - j + bonus. !

String removeSelector: #correctAgainst:continuedFrom:!

!methodRemoval: String #correctAgainst:continuedFrom: stamp: 'Install-5282-MoveUpToCharacterSequence-correct-alike-JuanVuletich-2022Jun13-15h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
correctAgainst: wordList continuedFrom: oldCollection
	"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."

	^ wordList
		ifNil: [
			self correctAgainstEnumerator: nil continuedFrom: oldCollection ]
		ifNotNil: [
			self
				correctAgainstEnumerator: [ :action | wordList do: action without: nil]
				continuedFrom: oldCollection ]!

String removeSelector: #correctAgainst:!

!methodRemoval: String #correctAgainst: stamp: 'Install-5282-MoveUpToCharacterSequence-correct-alike-JuanVuletich-2022Jun13-15h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
correctAgainst: wordList
	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"
	| results |
	results _ self correctAgainst: wordList continuedFrom: nil.
	results _ self correctAgainst: nil continuedFrom: results.
	^ results!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5282-MoveUpToCharacterSequence-correct-alike-JuanVuletich-2022Jun13-15h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5280] on 13 June 2022 at 3:34:32 pm'!
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 7/5/2020 16:47:58'!
                       article
	| article first letter second |
	self isEmpty ifTrue: [^self].
	article := self first isVowel ifTrue: ['an'] ifFalse: ['a'].
	first := self first asLowercase.
	letter := self size = 1.
	second := letter ifFalse: [self second asLowercase].
	(first = $f and: [letter orNot: ['aeiloru' includes: second]])
		ifTrue: [^'an'].
	first = $u ifTrue: [
		(letter or: ['cks' includes: second]) ifTrue: [^'a'].
		second = $n
			ifTrue: [(self size = 2 or: [self third isVowel]) ifTrue: [^'a']]].
	(first = $e and: [second = $u]) ifTrue: [^'a'].
	^article! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 4/25/2020 10:29:48'!
           asPlural
	| k trimmed plural n |
	k := self findFirst: [:ch | ch isSeparator not].
	k > 1
		ifTrue: [^(self copyFrom: 1 to: k - 1) , (self allButFirst: k - 1) asPlural].
	trimmed := self withBlanksTrimmed.
	trimmed isEmpty ifTrue: [^''].
	plural := trimmed asLowercase lowercasePlural.
	n := trimmed size min: plural size.
	1 to: n do: [:i |
		(trimmed at: i) isUppercase
			ifTrue: [plural at: i put: (plural at: i) asUppercase]].
	^plural! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 6/19/2020 12:52:49'!
                           exceptionalPlural
	| singular plural index |
	singular := #(
		'addendum' 'aircraft' 'alga' 'alumna' 'alumnus' 'amoeba' 'antenna' 'appendix' 'automaton'
		'bacillus' 'bacterium' 'barracks'
		'cactus' 'calculus' 'child' 'cicatrix' 'colossus' 'corpus' 'corrigendum' 'criterion' 'curriculum'
		'datum' 'deer' 'desideratum' 'dwarf'
		'echo' 'embargo' 'ephemeris' 'erratum' 'extremum'
		'fish' 'focus' 'foot' 'forum' 'fungus'
		'gallows' 'genus' 'goose'
		'hero'
		'index' 'infimum' 'is'
		'lacuna' 'larva' 'louse'
		'matrix' 'maximum' 'means' 'memorandum' 'minimum' 'mythos' 'money' 'mouse'
		'nucleus'
		'offspring' 'optimum' 'opus' 'ox'
		'person' 'phenomenon' 'phylum' 'potato' 'proof'
		'quantum'
		'roof'
		'series' 'sheep' 'species' 'spoof' 'stimulus' 'stratum' 'syllabus'
		'tomato' 'tooth' 'torpedo' 'trilby'
		'vertebra' 'vertex' 'veto'
		'was').
	plural := #(
		'addenda' 'aircraft' 'algae' 'alumnae' 'alumni' 'amoebae' 'antennae' 'appendices' 'automata'
		'bacilli' 'bacteria' 'barracks'
		'cacti' 'calculi' 'children' 'cicatrices' 'colossi' 'corpora' 'corrigenda' 'criteria' 'curricula'
		'data' 'deer' 'desiderata' 'dwarfs'
		'echoes' 'embargoes' 'ephemerides' 'errata' 'extrema'
		'fish' 'foci' 'feet' 'fora' 'fungi'
		'gallows' 'genera' 'geese'
		'heroes'
		'indices' 'infima' 'are'
		'lacunae' 'larvae' 'lice'
		'matrices' 'maxima' 'means' 'memoranda' 'minima' 'mythoi' 'moneys' 'mice'
		'nuclei'
		'offspring' 'optima' 'opera' 'oxen'
		'people' 'phenomena' 'phyla' 'potatoes' 'proofs'
		'quanta'
		'roofs'
		'series' 'sheep' 'species' 'spoofs' 'stimuli' 'strata' 'syllabi'
		'tomatoes' 'teeth' 'torpedoes' 'trilbys'
		'vertebrae' 'vertices' 'vetoes'
		'were').
	index := singular indexOf: self.
	^index > 0 ifTrue: [plural at: index]! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 4/25/2020 10:25:45'!
 isUninflictedNoun
	| nouns |
	nouns := #(
		'bison' 'bream' 'breeches' 'britches'
		'carp' 'chassis' 'clippers' 'cod' 'contretemps' 'corps'
		'debris' 'diabetes' 'djinn'
		'eland' 'elk'
		'flounder'
		'gallows' 'graffiti'
		'headquarters' 'herpes' 'high-jinks' 'homework'
		'innings'
		'jackanapes'
		'mackerel' 'measles' 'mews' 'mumps'
		'news'
		'pincers' 'pliers' 'proceedings'
		'rabies'
		'salmon' 'scissors' 'sea-bass' 'series' 'shears' 'species' 'swine'
		'trout' 'tuna'
		'whiting' 'wildebeest').
	^nouns includes: self! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 4/25/2020 10:24:38'!
    lowercasePlural
	| last |
	self exceptionalPlural ifNotNil: [:pl | ^pl].
	self isUninflictedNoun ifTrue: [^self].
	last := self last.
	last = $y ifTrue: [
		#('ay' 'ey' 'oy' 'uy') do: [:t |
			(self endsWith: t) ifTrue: [^self , 's'].
			^self allButLast , 'ies']].
	#('zz' 'ch' 'sh') do: [:t | (self endsWith: t) ifTrue: [^self , 'es']].
	last = $s ifTrue: [
		self = 'its' ifTrue: [^'their'].
		#('bs' 'cs' 'ds' 'ks' 'ls' 'ms' 'rs' 'ts' 'ws')
			do: [:t | (self endsWith: t) ifTrue: [^self]].
		#('sis' 'xis')
			do: [:t | (self endsWith: t) ifTrue: [^(self allButLast: 2) , 'es']]].
	last = $z ifTrue: [^self , 'zes'].
	(last = $x or: [last = $s]) ifTrue: [^self , 'es'].
	(self endsWith: 'man') ifTrue: [^(self allButLast: 2) , 'en'].
	last = $f ifTrue: [^self allButLast , 'ves'].
	(self endsWith: 'fe') ifTrue: [^(self allButLast: 2) , 'ves'].
	^self , 's'! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 4/25/2020 10:26:19'!
                     pluralize: aBoolean
	^aBoolean ifTrue: [self asPlural] ifFalse: [self]! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 4/25/2020 10:45:49'!
             withArticle
	^self article , ' ' , self! !

String removeSelector: #withArticle!

!methodRemoval: String #withArticle stamp: 'Install-5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st 6/16/2022 07:24:54'!
withArticle
	^self article , ' ' , self!

String removeSelector: #asPlural!

!methodRemoval: String #asPlural stamp: 'Install-5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st 6/16/2022 07:24:54'!
asPlural
	| k trimmed plural n |
	k := self findFirst: [:ch | ch isSeparator not].
	k > 1
		ifTrue: [^(self copyFrom: 1 to: k - 1) , (self allButFirst: k - 1) asPlural].
	trimmed := self withBlanksTrimmed.
	trimmed isEmpty ifTrue: [^''].
	plural := trimmed asLowercase lowercasePlural.
	n := trimmed size min: plural size.
	1 to: n do: [:i |
		(trimmed at: i) isUppercase
			ifTrue: [plural at: i put: (plural at: i) asUppercase]].
	^plural!

String removeSelector: #pluralize:!

!methodRemoval: String #pluralize: stamp: 'Install-5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st 6/16/2022 07:24:54'!
pluralize: aBoolean
	^aBoolean ifTrue: [self asPlural] ifFalse: [self]!

String removeSelector: #lowercasePlural!

!methodRemoval: String #lowercasePlural stamp: 'Install-5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st 6/16/2022 07:24:54'!
lowercasePlural
	| last |
	self exceptionalPlural ifNotNil: [:pl | ^pl].
	self isUninflictedNoun ifTrue: [^self].
	last := self last.
	last = $y ifTrue: [
		#('ay' 'ey' 'oy' 'uy') do: [:t |
			(self endsWith: t) ifTrue: [^self , 's'].
			^self allButLast , 'ies']].
	#('zz' 'ch' 'sh') do: [:t | (self endsWith: t) ifTrue: [^self , 'es']].
	last = $s ifTrue: [
		self = 'its' ifTrue: [^'their'].
		#('bs' 'cs' 'ds' 'ks' 'ls' 'ms' 'rs' 'ts' 'ws')
			do: [:t | (self endsWith: t) ifTrue: [^self]].
		#('sis' 'xis')
			do: [:t | (self endsWith: t) ifTrue: [^(self allButLast: 2) , 'es']]].
	last = $z ifTrue: [^self , 'zes'].
	(last = $x or: [last = $s]) ifTrue: [^self , 'es'].
	(self endsWith: 'man') ifTrue: [^(self allButLast: 2) , 'en'].
	last = $f ifTrue: [^self allButLast , 'ves'].
	(self endsWith: 'fe') ifTrue: [^(self allButLast: 2) , 'ves'].
	^self , 's'!

String removeSelector: #article!

!methodRemoval: String #article stamp: 'Install-5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st 6/16/2022 07:24:54'!
article
	| article first letter second |
	self isEmpty ifTrue: [^self].
	article := self first isVowel ifTrue: ['an'] ifFalse: ['a'].
	first := self first asLowercase.
	letter := self size = 1.
	second := letter ifFalse: [self second asLowercase].
	(first = $f and: [letter orNot: ['aeiloru' includes: second]])
		ifTrue: [^'an'].
	first = $u ifTrue: [
		(letter or: ['cks' includes: second]) ifTrue: [^'a'].
		second = $n
			ifTrue: [(self size = 2 or: [self third isVowel]) ifTrue: [^'a']]].
	(first = $e and: [second = $u]) ifTrue: [^'a'].
	^article!

String removeSelector: #exceptionalPlural!

!methodRemoval: String #exceptionalPlural stamp: 'Install-5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st 6/16/2022 07:24:54'!
exceptionalPlural
	| singular plural index |
	singular := #(
		'addendum' 'aircraft' 'alga' 'alumna' 'alumnus' 'amoeba' 'antenna' 'appendix' 'automaton'
		'bacillus' 'bacterium' 'barracks'
		'cactus' 'calculus' 'child' 'cicatrix' 'colossus' 'corpus' 'corrigendum' 'criterion' 'curriculum'
		'datum' 'deer' 'desideratum' 'dwarf'
		'echo' 'embargo' 'ephemeris' 'erratum' 'extremum'
		'fish' 'focus' 'foot' 'forum' 'fungus'
		'gallows' 'genus' 'goose'
		'hero'
		'index' 'infimum' 'is'
		'lacuna' 'larva' 'louse'
		'matrix' 'maximum' 'means' 'memorandum' 'minimum' 'mythos' 'money' 'mouse'
		'nucleus'
		'offspring' 'optimum' 'opus' 'ox'
		'person' 'phenomenon' 'phylum' 'potato' 'proof'
		'quantum'
		'roof'
		'series' 'sheep' 'species' 'spoof' 'stimulus' 'stratum' 'syllabus'
		'tomato' 'tooth' 'torpedo' 'trilby'
		'vertebra' 'vertex' 'veto'
		'was').
	plural := #(
		'addenda' 'aircraft' 'algae' 'alumnae' 'alumni' 'amoebae' 'antennae' 'appendices' 'automata'
		'bacilli' 'bacteria' 'barracks'
		'cacti' 'calculi' 'children' 'cicatrices' 'colossi' 'corpora' 'corrigenda' 'criteria' 'curricula'
		'data' 'deer' 'desiderata' 'dwarfs'
		'echoes' 'embargoes' 'ephemerides' 'errata' 'extrema'
		'fish' 'foci' 'feet' 'fora' 'fungi'
		'gallows' 'genera' 'geese'
		'heroes'
		'indices' 'infima' 'are'
		'lacunae' 'larvae' 'lice'
		'matrices' 'maxima' 'means' 'memoranda' 'minima' 'mythoi' 'moneys' 'mice'
		'nuclei'
		'offspring' 'optima' 'opera' 'oxen'
		'people' 'phenomena' 'phyla' 'potatoes' 'proofs'
		'quanta'
		'roofs'
		'series' 'sheep' 'species' 'spoofs' 'stimuli' 'strata' 'syllabi'
		'tomatoes' 'teeth' 'torpedoes' 'trilbys'
		'vertebrae' 'vertices' 'vetoes'
		'were').
	index := singular indexOf: self.
	^index > 0 ifTrue: [plural at: index]!

String removeSelector: #isUninflictedNoun!

!methodRemoval: String #isUninflictedNoun stamp: 'Install-5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st 6/16/2022 07:24:54'!
isUninflictedNoun
	| nouns |
	nouns := #(
		'bison' 'bream' 'breeches' 'britches'
		'carp' 'chassis' 'clippers' 'cod' 'contretemps' 'corps'
		'debris' 'diabetes' 'djinn'
		'eland' 'elk'
		'flounder'
		'gallows' 'graffiti'
		'headquarters' 'herpes' 'high-jinks' 'homework'
		'innings'
		'jackanapes'
		'mackerel' 'measles' 'mews' 'mumps'
		'news'
		'pincers' 'pliers' 'proceedings'
		'rabies'
		'salmon' 'scissors' 'sea-bass' 'series' 'shears' 'species' 'swine'
		'trout' 'tuna'
		'whiting' 'wildebeest').
	^nouns includes: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5283-MoveUpToCharacterSequence-grammar-JuanVuletich-2022Jun13-15h30m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5280] on 13 June 2022 at 4:28:36 pm'!
!CharacterSet methodsFor: 'testing' stamp: 'jmv 6/13/2022 15:55:38'!
                          isAscii
	"Answer true if we only contain ASCII characters
	(CharacterSet newFrom: { $a. $b }) isAscii.
	(CharacterSet newFrom: { $·. $Í }) isAscii.
	"

	^(String indexOfByte: 1 inString: map startingAt: 128) = 0! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 16:07:33'!
                            asFileName
	"Answer a String made up from the receiver that is an acceptable file name."

	| badChars |

	"Check if the file name contains any invalid characters"
	badChars _ `CharacterSet newFrom: #( $: $< $> $| $/ $\ $? $* $")`.
	(self indexOfAnyOf: badChars) = 0
		ifTrue: [^self ].
	^ self collect: [ :char |
			(badChars includes: char) 
				ifTrue: [$#] 
				ifFalse: [char]]! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 6/13/2022 16:12:45'!
          asAbsolutePathName
	"See comment at #isAbsolutePathName"

	^ self species streamContents: [ :childPath |
		childPath nextPut: $/.
		(FileIOAccessor default absolutePathComponentsFor: self)
			do: [ :each | childPath nextPutAll: each]
			separatedBy: [childPath nextPut: $/]]! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 6/13/2022 16:18:29'!
                     asDirectoryEntry
	"See examples in #asFileEntry method comment"
	^DirectoryEntry withPathName: self! !
!CharacterSequence methodsFor: 'fileman-actions' stamp: 'mu 6/11/2006 22:12'!
           fileContents
	^self asFileEntry fileContents! !
!CharacterSequence methodsFor: 'fileman-actions' stamp: 'mu 6/11/2006 22:19'!
  fileContents: aString
	self asFileEntry fileContents: aString.
	^aString! !
!String methodsFor: 'accessing' stamp: 'jmv 6/13/2022 15:43:32' overrides: 50381497!
                               indexOfAnyOf: aCharacterSet
	"returns the index of the first character in the given set, starting from start"

	^ self indexOfAnyOf: aCharacterSet startingAt: 1 ifAbsent: 0! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/13/2022 16:03:08' overrides: 50381497!
                       indexOfAnyOf: aCharacterSet
	"returns the index of the first character in the given set, starting from start."

	"Fast lane."
	| index |
	(self isAscii or: [aCharacterSet isAscii]) ifTrue: [
		^ bytes indexOfAnyOf: aCharacterSet startingAt: 1 ifAbsent: 0 ].

	index _ 1.
	self do: [ :codePoint |
		(aCharacterSet includes: codePoint) ifTrue: [ ^index ].
		index _ index + 1].

	^0! !
!CharacterSet methodsFor: 'collection ops' stamp: 'jmv 6/13/2022 15:51:37' prior: 50361227 overrides: 16822843!
                add: aCharacter
	map at: aCharacter iso8859s15Code+1 put: 1.! !
!CharacterSet methodsFor: 'collection ops' stamp: 'jmv 6/13/2022 16:07:09' prior: 50368242 overrides: 16823908!
                includes: aCharacter
	aCharacter isCharacter ifFalse: [ ^ false ].
	aCharacter iso8859s15Code ifNotNil: [ :index | ^(map at: index + 1) > 0 ].
	^false! !
!CharacterSet methodsFor: 'collection ops' stamp: 'jmv 6/13/2022 15:52:07' prior: 50361233 overrides: 16823710!
                      remove: aCharacter
	map at: aCharacter iso8859s15Code+1 put: 0! !
!CharacterSequence methodsFor: 'converting' stamp: 'ls 10/28/2003 12:24' prior: 50384882!
    asSmalltalkComment
	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"

	^self species streamContents:  [ :str |
		| quoteCount first |

		str nextPut: $".
	
		quoteCount := 0.
		first := true.
		self do: [ :char |
			char = $"
				ifTrue: [
					first ifFalse: [
						str nextPut: char.
						quoteCount := quoteCount + 1 ] ]
				ifFalse: [
					quoteCount odd ifTrue: [
						"add a quote to even the number of quotes in a row"
						str nextPut: $" ].
					quoteCount := 0.
					str nextPut: char ].
			first := false ]. 

		quoteCount odd ifTrue: [
			"check at the end"
			str nextPut: $". ].

		str nextPut: $".
	].
	! !

FileIOAccessor removeSelector: #checkName:fixErrors:!

!methodRemoval: FileIOAccessor #checkName:fixErrors: stamp: 'Install-5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st 6/16/2022 07:24:54'!
checkName: aFileName fixErrors: fixing
	"Check if the file name contains any invalid characters"
	| badChars hasBadChars |
	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.
	hasBadChars _ aFileName includesAnyOf: badChars.
	(hasBadChars and:[fixing not]) ifTrue: [^self error:'Invalid file name'].
	hasBadChars ifFalse:[^ aFileName].
	^ aFileName collect: [ :char |
			(badChars includes: char) 
				ifTrue:[$#] 
				ifFalse:[char]]!

String removeSelector: #fileContents!

!methodRemoval: String #fileContents stamp: 'Install-5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st 6/16/2022 07:24:54'!
fileContents
	^self asFileEntry fileContents!

String removeSelector: #fileContents:!

!methodRemoval: String #fileContents: stamp: 'Install-5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st 6/16/2022 07:24:54'!
fileContents: aString
	self asFileEntry fileContents: aString.
	^aString!

String removeSelector: #asFileName!

!methodRemoval: String #asFileName stamp: 'Install-5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st 6/16/2022 07:24:54'!
asFileName
	"Answer a String made up from the receiver that is an acceptable file 
	name."

	^FileIOAccessor default checkName: self fixErrors: true!

String removeSelector: #asDirectoryEntry!

!methodRemoval: String #asDirectoryEntry stamp: 'Install-5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st 6/16/2022 07:24:54'!
asDirectoryEntry
	"See examples in #asFileEntry method comment"
	^DirectoryEntry withPathName: self!

String removeSelector: #asAbsolutePathName!

!methodRemoval: String #asAbsolutePathName stamp: 'Install-5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st 6/16/2022 07:24:54'!
asAbsolutePathName
	"See comment at #isAbsolutePathName"

	| slash |
	slash _ FileIOAccessor default slash.
	^ String streamContents: [ :childPath |
		childPath nextPutAll: slash.
		(FileIOAccessor default absolutePathComponentsFor: self)
			do: [ :each | childPath nextPutAll: each]
			separatedBy: [childPath nextPutAll: slash]]!

CharacterSequence removeSelector: #indexOfAnyOf:!

!methodRemoval: CharacterSequence #indexOfAnyOf: stamp: 'Install-5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st 6/16/2022 07:24:54'!
indexOfAnyOf: aCharacterSet
	"returns the index of the first character in the given set, starting from start"

	^ self indexOfAnyOf: aCharacterSet  startingAt: 1 ifAbsent: 0!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5284-MoveUpToCharacterSequence-FileSystem-JuanVuletich-2022Jun13-15h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5280] on 13 June 2022 at 4:56:18 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/13/2022 16:32:53'!
                    base64Decoded
	"Decode the receiver from base 64"
	"
	'SGVsbG8gV29ybGQ=' base64Decoded
	'SGVsbG8gV29ybGQ=' base64Decoded asString
	"
	^(Base64MimeConverter mimeDecode: self)! !
!CharacterSequence methodsFor: 'testing' stamp: 'jmv 6/13/2022 16:37:27'!
     isRemote
	^false! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/13/2022 16:55:29'!
      asHex

	^bytes asHex! !
!Utf8String methodsFor: 'printing' stamp: 'jmv 6/13/2022 16:36:46' overrides: 16902865!
                isLiteral
self flag: #unicodeNeedsImprovement.
	^super isLiteral! !
!Utf8Symbol methodsFor: 'printing' stamp: 'jmv 6/13/2022 16:36:57' overrides: 50386116!
    isLiteral
self flag: #unicodeNeedsImprovement.
	^super isLiteral! !
!ByteArray methodsFor: 'converting' stamp: 'jmv 6/13/2022 16:54:10'!
                       asHex
	"Answer an hexa decimal representation of the receiver
	
	        #[122 43 213 7] asHex
		=> '7A 2B D5 07'
	"

	^String streamContents: [ :strm |
		self
			do: [ :byte | strm
				nextPut: ('0123456789ABCDEF' at: byte//16+1);
				nextPut: ('0123456789ABCDEF' at: byte\\16+1)]
			separatedBy: [strm space ]].! !
!String methodsFor: 'converting' stamp: 'jmv 6/13/2022 16:55:56' prior: 50366536!
                 asHex

	^String streamContents: [ :strm |
		self do: [ :ch | strm nextPutAll: ch hex ] separatedBy: [ strm space ]].! !
!String methodsFor: 'converting' stamp: 'jmv 6/13/2022 16:39:45' prior: 50376522!
                      substrings: aByteStringOrByteArray
	"Answer an array of the substrings that compose the argument.
	If argument is an UTF-8 encoded ByteArray, answer is an array of same."

	| end beginning |
	end _ 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning _ aByteStringOrByteArray indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end _ aByteStringOrByteArray indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ aByteStringOrByteArray size + 1 ].
			end _ end - 1.
			result nextPut: (aByteStringOrByteArray copyFrom: beginning to: end).
		]
	].! !
!String class methodsFor: 'primitives' stamp: 'jmv 6/13/2022 16:40:18' prior: 16950116!
                  findFirstInString: aByteStringOrByteArray inSet: inclusionMap startingAt: start
	| i stringSize |
	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>
	self var: #aString declareC: 'unsigned char *aString'.
	self var: #inclusionMap  declareC: 'char *inclusionMap'.

	inclusionMap size ~= 256 ifTrue: [ ^0 ].

	i _ start.
	stringSize _ aByteStringOrByteArray size.
	[ i <= stringSize and: [ (inclusionMap at: (aByteStringOrByteArray at: i) numericValue+1) = 0 ] ] whileTrue: [ 
		i _ i + 1 ].

	i > stringSize ifTrue: [ ^0 ].
	^i! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/13/2022 16:36:41' prior: 50381820!
   < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) = 1].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) = 1]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) = 1! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/13/2022 16:36:25' prior: 50381846!
                <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) <= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) <= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) <= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/13/2022 16:36:20' prior: 50381901!
 > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) = 3].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) = 3]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) = 3! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/13/2022 16:36:16' prior: 50381927!
                 >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ ('' compare: bytes with: aString) >= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ ('' compare: bytes with: aString bytes) >= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ ('' compare: bytes with: aString asUtf8BytesOrByteString) >= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/13/2022 16:36:12' prior: 50382539!
  caseInsensitiveLessOrEqual: aString 
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			^self asByteString caseInsensitiveLessOrEqual: aString ].
		(aString isUtf8String and: [ aString isAscii ]) ifTrue: [
			^self asByteString sameAs: aString asByteString ]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase <= aString asLowercase! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/13/2022 16:36:09' prior: 50381991!
                            sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	self size = aString size ifFalse: [
		^false ].

	"Fast lane. Use String implementation for ASCII only instances."
	(self isAscii and: [	aString isByteString ]) ifTrue: [
		^self asByteString sameAs: aString ].
	aString isUtf8String ifTrue: [
		self isAscii = aString isAscii ifFalse: [
			^false ].
		(self isAscii and: [aString isAscii]) ifTrue: [
			^self asByteString sameAs: aString asByteString ]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase = aString asLowercase! !

String removeSelector: #base64Decoded!

!methodRemoval: String #base64Decoded stamp: 'Install-5285-MoveUpToCharacterSequence-OddsAndEnds-JuanVuletich-2022Jun13-16h28m-jmv.001.cs.st 6/16/2022 07:24:54'!
base64Decoded
	"Decode the receiver from base 64"
	"
	'SGVsbG8gV29ybGQ=' base64Decoded
	'SGVsbG8gV29ybGQ=' base64Decoded asString
	"
	^(Base64MimeConverter mimeDecode: self)!

String removeSelector: #isRemote!

!methodRemoval: String #isRemote stamp: 'Install-5285-MoveUpToCharacterSequence-OddsAndEnds-JuanVuletich-2022Jun13-16h28m-jmv.001.cs.st 6/16/2022 07:24:54'!
isRemote
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5285-MoveUpToCharacterSequence-OddsAndEnds-JuanVuletich-2022Jun13-16h28m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5284] on 14 June 2022 at 3:05:28 pm'!
!EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/14/2022 15:02:10' prior: 50380387 overrides: 16983042!
                       position: pos

	super position: pos.
	lastWrittenElement _ nil.
	numberOfCodePointsWritten _ nil.! !
!EncodedFileStream methodsFor: 'open/close' stamp: 'jmv 6/14/2022 15:04:29' prior: 50377420!
                              open: fileName forWrite: writeMode
	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."
	"Changed to do a GC and retry before failing ar 3/21/98 17:25"
	fileID _ EncodedFileStream retryWithGC: [ self primOpen: fileName asUtf8Bytes writable: writeMode ]
					until: [ :id | id notNil ]
					forFileNamed: fileName.
	fileID ifNil: [^ nil].  "allows sender to detect failure"
	name _ fileName.
	"jmv: Register after setting name. Name is assumed to be defined for registered objects."
	self register.
	rwmode _ writeMode.
	buffer1 _ ByteArray new: 1.
	self useUtf8String.
	self enableReadBuffering.! !
!EncodedFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/14/2022 15:02:29' prior: 50377901 overrides: 16983042!
            position: pos
	"Set the receiver's position as indicated."

	collection ifNotNil: [
		position < readLimit ifTrue: [
			| newPosition |
			newPosition := pos - (self primGetPosition: fileID) + readLimit.
			newPosition < 0 ifTrue: [
					| offsetPos |
					self primSetPosition: fileID to: (offsetPos := pos - (collection size // 4) max: 0).
					readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
					position := pos - offsetPos.
					^self ].
			newPosition < readLimit 
				ifTrue: [
					position := newPosition.
					^self ]
				ifFalse: [
					readLimit := position := 0 ] ] ].
	^self primSetPosition: fileID to: pos! !

EncodedFileStream class removeSelector: #positionValidatedSenders!

!methodRemoval: EncodedFileStream class #positionValidatedSenders stamp: 'Install-5286-Cleanup-JuanVuletich-2022Jun14-15h01m-jmv.001.cs.st 6/16/2022 07:24:54'!
positionValidatedSenders
	^{
		ChangeList >> #scanDoIt.
		ChangeList >> #scanFile:from:to:.
		ChangeList >> #scanSpecificChangeRecordType.
		ChangeList >> #scanUpTo:informing:.
		ChangeList >> #scanCategory:class:meta:stamp:prior:overrides:.
		PositionableStream >> #skipSeparators.
		ChangeRecord >> #string.
		PositionableStream >> #back.
		PositionableStream >> #peekBack.
		PositionableStream >> #backChunk.
		CompiledMethod >> #getPreamble.
		EncodedReadStream >> #nextUtf8BytesAndCodePointInto:into:.
		Parser >> #parse:class:category:noPattern:doIt:context:notifying:ifFail:.
	}!

EncodedReadStream removeSelector: #position:!

!methodRemoval: EncodedReadStream #position: stamp: 'Install-5286-Cleanup-JuanVuletich-2022Jun14-15h01m-jmv.001.cs.st 6/16/2022 07:24:54'!
position: pos

	| m s |
	"Chequear que los senders sepan que estan mandando una posicion a byte!!"
	m _ thisContext sender method.
	thisContext sender receiver == self ifFalse: [
		thisContext sender receiver == readAdaptor ifFalse: [
			(EncodedFileStream positionValidatedSenders includes: m) ifFalse: [
				"SendersOfPositionColon _ Set new"
				s _ Smalltalk at: #SendersOfPositionColon ifAbsentPut: [ Set new ].
				(s includes: m) ifFalse: [
					s add: m.
					{ '-------- Sender de #position: '. m. pos} print.
					thisContext printStack: 10 ]]]].
	^super position: pos!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5286-Cleanup-JuanVuletich-2022Jun14-15h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5284] on 14 June 2022 at 3:06:18 pm'!

Utf8String removeSelector: #readStream!

!methodRemoval: Utf8String #readStream stamp: 'Install-5287-EncodedReadStream-removal-JuanVuletich-2022Jun14-15h05m-jmv.001.cs.st 6/16/2022 07:24:54'!
readStream
	| stream |
	stream _ EncodedReadStream on: bytes.
	stream useUtf8String.
	^stream!

Smalltalk removeClassNamed: #EncodedByteArrayStreamTest!

!classRemoval: #EncodedByteArrayStreamTest stamp: 'Install-5287-EncodedReadStream-removal-JuanVuletich-2022Jun14-15h05m-jmv.001.cs.st 6/16/2022 07:24:54'!
TestCase subclass: #EncodedByteArrayStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

Smalltalk removeClassNamed: #EncodedReadStream!

!classRemoval: #EncodedReadStream stamp: 'Install-5287-EncodedReadStream-removal-JuanVuletich-2022Jun14-15h05m-jmv.001.cs.st 6/16/2022 07:24:54'!
ReadStream subclass: #EncodedReadStream
	instanceVariableNames: 'readAdaptor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5287-EncodedReadStream-removal-JuanVuletich-2022Jun14-15h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5286] on 15 June 2022 at 9:49:45 am'!

Smalltalk renameClassNamed: #EncodedFileStream as: #UniFileStream!

!classRenamed: #EncodedFileStream as: #UniFileStream stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Smalltalk renameClassNamed: #EncodedFileStream as: #UniFileStream!

Smalltalk renameClassNamed: #EncodedWriteStream as: #Utf8EncodedWriteStream!

!classRenamed: #EncodedWriteStream as: #Utf8EncodedWriteStream stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Smalltalk renameClassNamed: #EncodedWriteStream as: #Utf8EncodedWriteStream!

Smalltalk renameClassNamed: #EncodedStreamReadAdaptor as: #UniStreamReadAdaptor!

!classRenamed: #EncodedStreamReadAdaptor as: #UniStreamReadAdaptor stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Smalltalk renameClassNamed: #EncodedStreamReadAdaptor as: #UniStreamReadAdaptor!

Object subclass: #UniStreamReadAdaptor
	instanceVariableNames: 'stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

!classDefinition: #UniStreamReadAdaptor category: #'System-Files' stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Object subclass: #UniStreamReadAdaptor
	instanceVariableNames: 'stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

Smalltalk renameClassNamed: #StringEncodedStreamReadAdaptor as: #ByteStringReadAdaptor!

!classRenamed: #StringEncodedStreamReadAdaptor as: #ByteStringReadAdaptor stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Smalltalk renameClassNamed: #StringEncodedStreamReadAdaptor as: #ByteStringReadAdaptor!

UniStreamReadAdaptor subclass: #ByteStringReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

!classDefinition: #ByteStringReadAdaptor category: #'System-Files' stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
UniStreamReadAdaptor subclass: #ByteStringReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

Smalltalk renameClassNamed: #BytesEncodedStreamReadAdaptor as: #BytesReadAdaptor!

!classRenamed: #BytesEncodedStreamReadAdaptor as: #BytesReadAdaptor stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Smalltalk renameClassNamed: #BytesEncodedStreamReadAdaptor as: #BytesReadAdaptor!

UniStreamReadAdaptor subclass: #BytesReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

!classDefinition: #BytesReadAdaptor category: #'System-Files' stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
UniStreamReadAdaptor subclass: #BytesReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

Smalltalk renameClassNamed: #Utf32EncodedStreamReadAdaptor as: #Utf32ReadAdaptor!

!classRenamed: #Utf32EncodedStreamReadAdaptor as: #Utf32ReadAdaptor stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Smalltalk renameClassNamed: #Utf32EncodedStreamReadAdaptor as: #Utf32ReadAdaptor!

UniStreamReadAdaptor subclass: #Utf32ReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

!classDefinition: #Utf32ReadAdaptor category: #'System-Files' stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
UniStreamReadAdaptor subclass: #Utf32ReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

Smalltalk renameClassNamed: #Utf8EncodedStreamReadAdaptor as: #Utf8ReadAdaptor!

!classRenamed: #Utf8EncodedStreamReadAdaptor as: #Utf8ReadAdaptor stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
Smalltalk renameClassNamed: #Utf8EncodedStreamReadAdaptor as: #Utf8ReadAdaptor!

UniStreamReadAdaptor subclass: #Utf8ReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!

!classDefinition: #Utf8ReadAdaptor category: #'System-Files' stamp: 'Install-5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st 6/16/2022 07:24:54'!
UniStreamReadAdaptor subclass: #Utf8ReadAdaptor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Files'!
!Utf8String class methodsFor: 'stream creation' stamp: 'jmv 6/15/2022 09:44:15' prior: 50378841 overrides: 16935210!
     streamContents: blockWithArg
	"Evaluate a block on a write stream that accepts bytes, characters.
	Arguments to #nextPutAll: can be sequences of bytes, Strings, Utf8Strings or Utf32Strings.
	Answer is an instance of us."

	| stream |	
	stream _ Utf8EncodedWriteStream on: (ByteArray new: 100).
	blockWithArg value: stream.
	^stream utf8Contents! !
!Utf8String class methodsFor: 'stream creation' stamp: 'jmv 6/15/2022 09:44:15' prior: 50378855!
   writeStream
	"Answer a write stream that accepts bytes, characters.
	Arguments to #nextPutAll: can be sequences of bytes, Strings, Utf8Strings or Utf32Strings."

	| stream |	
	stream _ Utf8EncodedWriteStream on: (ByteArray new: 100).
	^stream! !
!ByteArray class methodsFor: 'stream creation' stamp: 'jmv 6/15/2022 09:44:15' prior: 50378819!
          streamUtf8Contents: blockWithArg
	"Evaluate a block on a write stream that accepts bytes, characters.
	Arguments to #nextPutAll: can be sequences of bytes, Strings, Utf8Strings or Utf32Strings.
	Answer is an instance of us, holding UTF-8 encoded bytes."

	| stream |	
	stream _ Utf8EncodedWriteStream on: (ByteArray new: 100).
	blockWithArg value: stream.
	^stream byteContents! !
!UniFileStream methodsFor: 'open/close' stamp: 'jmv 6/15/2022 09:43:53' prior: 50386389!
          open: fileName forWrite: writeMode
	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."
	"Changed to do a GC and retry before failing ar 3/21/98 17:25"
	fileID _ UniFileStream retryWithGC: [ self primOpen: fileName asUtf8Bytes writable: writeMode ]
					until: [ :id | id notNil ]
					forFileNamed: fileName.
	fileID ifNil: [^ nil].  "allows sender to detect failure"
	name _ fileName.
	"jmv: Register after setting name. Name is assumed to be defined for registered objects."
	self register.
	rwmode _ writeMode.
	buffer1 _ ByteArray new: 1.
	self useUtf8String.
	self enableReadBuffering.! !
!UniFileStream methodsFor: 'reading modes' stamp: 'jmv 6/15/2022 09:46:47' prior: 50378381!
                useBytes
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ BytesReadAdaptor new stream: self.! !
!UniFileStream methodsFor: 'reading modes' stamp: 'jmv 6/15/2022 09:47:04' prior: 50378391!
                       useCharacters
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ ByteStringReadAdaptor new stream: self.! !
!UniFileStream methodsFor: 'reading modes' stamp: 'jmv 6/15/2022 09:47:22' prior: 50378401!
             useUtf32String
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ Utf32ReadAdaptor new stream: self.! !
!UniFileStream methodsFor: 'reading modes' stamp: 'jmv 6/15/2022 09:47:35' prior: 50378411!
                 useUtf8String
	"Only for reading.
	For writing accept bytes, Characters, CodePoints or ByteArray, String,  Utf8String, Utf32String,
	according to protocol."
	readAdaptor _ Utf8ReadAdaptor new stream: self.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5288-UniFileStream-isABetterName-JuanVuletich-2022Jun15-09h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5286] on 15 June 2022 at 9:50:43 am'!

UniStreamReadAdaptor removeSelector: #byteStream:!

!methodRemoval: UniStreamReadAdaptor #byteStream: stamp: 'Install-5289-Cleanup-JuanVuletich-2022Jun15-09h49m-jmv.001.cs.st 6/16/2022 07:24:54'!
byteStream: aStream
	stream _ aStream!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5289-Cleanup-JuanVuletich-2022Jun15-09h49m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5284] on 14 June 2022 at 3:14:50 pm'!
!SequenceableCollection methodsFor: 'comparing' stamp: 'jmv 6/14/2022 14:50:11'!
    hashQuick: initialHash
	| hash size step |

	size _ self size.
	hash _ (initialHash + size hash) hashMultiply.
	step _ size < 64 ifTrue: [1] ifFalse: [size//64].
	1 to: size by: step do: [ :i | | elem |
		elem _ self at: i.
		elem == self ifFalse: [
			hash _ (hash + elem hash) hashMultiply]].
	^hash! !
!ByteArray class methodsFor: 'byte based hash' stamp: 'jmv 6/14/2022 14:45:55'!
                               minSizeForHashQuick
	"Answer the size above which we prefer using the #hashQuick method"

	^256! !
!FloatArray class methodsFor: 'byte based hash' stamp: 'jmv 6/14/2022 14:47:18'!
            minSizeForHashQuick
	"Answer the size above which we prefer using the #hashQuick method"

	^256! !
!SequenceableCollection methodsFor: 'comparing' stamp: 'jmv 6/14/2022 14:50:31' prior: 16934045!
                            hashQuick
	^self hashQuick: self species hash! !
!String methodsFor: 'comparing' stamp: 'jmv 6/14/2022 14:51:19' prior: 50367383 overrides: 16934038!
          hash
	"#hash is implemented, because #= is implemented.
	Note: #hash must be the same for String, Symbol, Utf8String, Utf8Symbol, Utf32String and Text
	if they hold same Characters."

	self size >  ByteArray minSizeForHashQuick ifTrue: [
		^ self hashQuick: String hash ].
	^ByteArray
		hashBytes: self
		startingWith: String hash! !
!ByteArray methodsFor: 'comparing' stamp: 'jmv 6/14/2022 14:52:04' prior: 16799025 overrides: 16934038!
          hash
	"#hash is implemented, because #= is implemented"
	self size > ByteArray minSizeForHashQuick ifTrue: [
		^ self hashQuick: ByteArray hash ].
	^self class
		hashBytes: self
		startingWith: ByteArray hash! !
!FloatArray methodsFor: 'comparing' stamp: 'jmv 6/14/2022 14:47:35' prior: 16860020 overrides: 16934001!
   = another 
	self == another ifTrue: [ ^ true ].
	self class == another class ifFalse: [ ^ false ].
	self size > FloatArray minSizeForHashQuick ifTrue: [
		self hashQuick = another hashQuick ifFalse: [ ^false ]].
	^self primitiveEqual: another! !
!FloatArray methodsFor: 'comparing' stamp: 'jmv 6/14/2022 14:47:42' prior: 16860030 overrides: 16934038!
 hash
	self size > FloatArray minSizeForHashQuick ifTrue: [ ^ self hashQuick ].
	^ self hashFull! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5290-Collections-hash-tweaks-JuanVuletich-2022Jun14-15h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5284] on 14 June 2022 at 3:17:50 pm'!
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/14/2022 13:18:55' prior: 50382228 overrides: 16934001!
       = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	(self isAscii and: [	aString isByteString ]) ifTrue: [
		"Fast lane."
		^'' is: bytes equalTo: aString ].
	
	aString isUtf8String ifTrue: [
		self isAscii = aString isAscii ifFalse: [
			^false ]].

	"May need to do UTF-8 encoding."
	^ bytes = aString asUtf8Bytes.! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/14/2022 14:51:14' prior: 50369597!
            basicHash
	"Same hash value as a pure ASCII String.
	Some other reasonable hash value otherwise, but not the same as the one of the equivalent String if ISO-8859 non ASCII characters are present."
	bytes size >  ByteArray minSizeForHashQuick ifTrue: [
		^ bytes hashQuick: String hash ].
	^ByteArray
		hashBytes: bytes
		startingWith: String hash! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5291-Utf8String-eq-hash-fix-JuanVuletich-2022Jun14-15h14m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5290] on 15 June 2022 at 9:53:27 am'!
!UniFileStream class methodsFor: 'file creation' stamp: 'jmv 6/15/2022 09:53:15' prior: 50378560!
                    crc16OfFileNamed: fileName
	"
	UniFileStream crc16OfFileNamed: 'cursor.jpeg'
	UniFileStream crc16OfFileNamed: 'deafultPID.txt'
	"

	^[fileName asFileEntry readStreamDo: [ :stream |
		stream crc16 ]]
			on: FileDoesNotExistException do: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5292-tweak-JuanVuletich-2022Jun15-09h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5291] on 15 June 2022 at 10:04:07 am'!
!Text methodsFor: 'accessing' stamp: 'jmv 6/14/2022 16:54:10'!
                  asUtf8Bytes
	"Answer UTF-8 bytes for the string representation of the receiver."
	^string asUtf8Bytes! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5293-Text-String-compatibility-JuanVuletich-2022Jun15-10h03m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5171] on 15 June 2022 at 11:30:17 am'!
!FeatureRequirement methodsFor: 'accessing' stamp: 'jmv 6/15/2022 11:30:10' prior: 16853245!
          codePackageFile
	codePackageFile isNil ifTrue: [
		codePackageFile _ CodePackageFile onFileEntry: pathName asFileEntry.
		"?"
		pathName _ nil ].
	^codePackageFile! !
!FeatureRequirement methodsFor: 'requires' stamp: 'jmv 6/15/2022 11:28:26' prior: 16853306!
                             install
	"Preconditions have been satisfied.  Install the required package."

	| existing |
	existing _ CodePackage named: self codePackageFile packageName createIfAbsent: false registerIfNew: false.
	(existing isNil
		or: [ existing hasUnsavedChanges not
			or: [ self confirm: 'If you install this package, there are unsaved changes that will be lost.', String newLineString, 'Continue?' ]]) ifTrue: [
		self codePackageFile install.
		codePackageFile _ nil.
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5294-FeatureRequirement-fix-JuanVuletich-2022Jun15-11h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5293] on 15 June 2022 at 3:01:29 pm'!
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 6/15/2022 15:00:23' prior: 50351558!
    encompassLine: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: aCodePointInterval first.
	argumentRightByte _ self byteIndexAt: aCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 6/15/2022 15:00:32' prior: 50351592!
                   encompassParagraph: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: aCodePointInterval first.
	argumentRightByte _ self byteIndexAt: aCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size]).
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/15/2022 14:55:53' prior: 50379863!
                      byteIndexAt: codePointIndex
	| byteIndex |
	codePointIndex < 2 ifTrue: [ ^codePointIndex ]. "For 0 and 1"
	self isAscii ifTrue: [ ^ codePointIndex ].
	codePointIndex = (self size+1) ifTrue: [
		"The position a hypotetical extra code point would start at.
		Useful to find the last byte position for some codePointIndex. See senders."
		^bytes size+1 ].
	byteIndex _ codePointIndex > self stride
		ifTrue: [
			strideIndex ifNil: [ self computeCountAndIndex ].
			strideIndex at: codePointIndex - 1 // self stride ]
		ifFalse: [ 1 ].
	codePointIndex - 1 \\ self stride timesRepeat: [ 
		byteIndex _ byteIndex + (self encodedByteCountAt: byteIndex) ].
	^ byteIndex! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/15/2022 14:56:02' prior: 50369329!
                   codePointIndexAt: byteIndex
	| codePointIndex byteCursor |
	byteIndex < 2 ifTrue: [ ^byteIndex ]. "For 0 and 1"
	self isAscii ifTrue: [ ^ byteIndex ].
	codePointIndex := byteCursor := 1.
	strideIndex ifNil: [ self computeCountAndIndex ].
	strideIndex ifNotEmpty: [  
		strideIndex 
			findBinaryIndex: [ :x | byteIndex - x ] 
			do: [ :found | ^ (found * self stride) + 1 ] 
			ifNone: [ :lower :upper |
				lower = 0 
			 		ifFalse: [ 
						byteCursor := strideIndex at: lower. 
						codePointIndex := (lower * self stride) + 1 ] ] ].
	[ byteCursor <= bytes size ] whileTrue: [
		byteCursor = byteIndex 
			ifTrue: [ ^ codePointIndex ].
		byteCursor := byteCursor + (self encodedByteCountAt: byteCursor).
		codePointIndex := codePointIndex + 1 ].
	^ 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5295-Utf8String-fixes-JuanVuletich-2022Jun15-15h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5295] on 15 June 2022 at 3:41:26 pm'!
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:28:13' overrides: 50368467!
                      readFrom: inStream
	"Answer a new String that is determined by reading the stream, inStream.  Embedded
	double quotes become the quote Character."

	| char done |
	^self streamContents: [ :outStream |
		"go to first quote"
		inStream skipTo: $'.
		done _ false.
		[done or: [inStream atEnd]]
			whileFalse: 
				[char _ inStream next.
				char = $'
					ifTrue: 
						[char _ inStream next.
						char = $'
							ifTrue: [outStream nextPut: char]
							ifFalse: [done _ true]]
					ifFalse: [outStream nextPut: char]]].! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:20:49'!
                               crString
	"Answer a string containing a carriage return.
	Utf8String crString
	"
	^ `Utf8String with: Character cr`! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:20:34'!
                      crlfString
	"Answer a string containing a carriage return and a linefeed.
	Utf8String crlfString
	"
	^ `Utf8String with: Character cr with: Character lf`! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:25:02'!
                lfString
	"Answer a string containing a single Lf character.
	Utf8String lfString
	"
	^ `Utf8String with: Character lf`! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:25:35'!
                  newLineString
	"Answer a string containing a single newLine (i.e. Lf) character.
	Utf8String newLineString
	"
	^ `Utf8String with: Character newLineCharacter`! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:31:40'!
           tab
	"Answer a string containing a single tab character.
	Utf8String tab
	"
	^ `Utf8String with: Character tab`! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:12:58' overrides: 16824168!
      with: aCharacter with: otherCharacter with: thirdCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter, otherCharacter and thirdCharacter.
	Utf8String with: $a
	Utf8String with: $√° with: Character euro
	Utf8String with: $√° with: Character euro with: $¬ø
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint),
			(Character utf8BytesOfUnicodeCodePoint: otherCharacter codePoint),
			(Character utf8BytesOfUnicodeCodePoint: thirdCharacter codePoint)
		codePointCount: 3.! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:17:25' overrides: 16824214!
     withAll: aSequenceableCollection
	"Create a new instance containing all the elements from aSequenceableCollection."
	^ self newFrom: aSequenceableCollection! !
!Utf8Symbol class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:40:27'!
             fromCollectionOfStrings: aCollectionOfStrings

	^self newFrom: aCollectionOfStrings concatenation ! !
!Utf8Symbol class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:39:08' overrides: 50379227!
                   newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."

	^ (Utf8String newFrom: aCollection) asSymbol

"
	Utf8Symbol newFrom: {$P. $e. $n}
	{$P. $e. $n} as: Utf8Symbol
"! !
!Utf8Symbol class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:40:05' overrides: 50387134!
    readFrom: strm
	"
	Utf8Symbol readFrom: '#abc' readStream
	"

	strm peek = $# ifFalse: [self error: 'Symbols must be introduced by #'].
	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 6/15/2022 15:38:49' prior: 16951102 overrides: 50379094!
                        newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."

	^ (String newFrom: aCollection) asSymbol

"
	Symbol newFrom: {$P. $e. $n}
	{$P. $e. $n} as: Symbol
"! !

String class removeSelector: #fromString:!

!methodRemoval: String class #fromString: stamp: 'Install-5296-UTf8StringAndSymbol-aFewMissingMethods-JuanVuletich-2022Jun15-15h03m-jmv.001.cs.st 6/16/2022 07:24:54'!
fromString: aString 
	"Answer an instance of me that is a copy of the argument, aString."
	
	^ aString copyFrom: 1 to: aString size!

String class removeSelector: #stringHash:initialHash:!

!methodRemoval: String class #stringHash:initialHash: stamp: 'Install-5296-UTf8StringAndSymbol-aFewMissingMethods-JuanVuletich-2022Jun15-15h03m-jmv.001.cs.st 6/16/2022 07:24:54'!
stringHash: aString initialHash: speciesHash

	| stringSize hash low |
	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>

	self var: #aHash declareC: 'int speciesHash'.
	self var: #aString declareC: 'unsigned char *aString'.

	stringSize _ aString size.
	hash _ speciesHash bitAnd: 16rFFFFFFF.
	1 to: stringSize do: [:pos |
		hash _ hash + (aString at: pos) numericValue.
		"Begin hashMultiply"
		low _ hash bitAnd: 16383.
		hash _ (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.
	].
	^ hash!

String class removeSelector: #readFrom:!

!methodRemoval: String class #readFrom: stamp: 'Install-5296-UTf8StringAndSymbol-aFewMissingMethods-JuanVuletich-2022Jun15-15h03m-jmv.001.cs.st 6/16/2022 07:24:54'!
readFrom: inStream
	"Answer a new String that is determined by reading the stream, inStream.  Embedded
	double quotes become the quote Character."

	| outStream char done |
	outStream _ WriteStream on: (String new: 16).
	"go to first quote"
	inStream skipTo: $'.
	done _ false.
	[done or: [inStream atEnd]]
		whileFalse: 
			[char _ inStream next.
			char = $'
				ifTrue: 
					[char _ inStream next.
					char = $'
						ifTrue: [outStream nextPut: char]
						ifFalse: [done _ true]]
				ifFalse: [outStream nextPut: char]].
	^outStream contents!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5296-UTf8StringAndSymbol-aFewMissingMethods-JuanVuletich-2022Jun15-15h03m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5295] on 15 June 2022 at 4:26:11 pm'!
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/15/2022 16:07:35' prior: 50382285!
            findString: subString startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	| arg startByteIndex byteIndex |
	(self isAscii and: [subString isByteString])
		ifTrue: [ "Fast lane"
			^'' findString: subString in: bytes startingAt: start ]
		ifFalse: [
			arg _ subString asUtf8BytesOrByteString.
			"Do UTF-8 encoding as needed."
			startByteIndex _ self byteIndexAt: start.
			byteIndex _ '' findString: arg in: bytes startingAt: startByteIndex.
			^self codePointIndexAt: byteIndex].! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/15/2022 16:09:23' prior: 50382304!
    findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	caseSensitive ifTrue: [
		^self findString: key startingAt: start ].

	self isAscii ifTrue: [
		key isAscii
			ifTrue: [ "Fast lane"
				^'' findStringIgnoreCase: key in: bytes startingAt: start ]
			ifFalse: [ "Won't be found"
				^0 ]].

"caseSensitive = false is very expensive. Do better."
self flag: #slowUnicode.
	^self asLowercase findString: key asLowercase startingAt: start! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/15/2022 16:15:02' prior: 50382332 overrides: 16933699!
                            indexOf: anUnicodeCodePoint startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	anUnicodeCodePoint isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes _ Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint.
	startByteIndex _ self byteIndexAt: start.
	foundByteIndex _ '' findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer _ self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5297-Utf8String-tweaks-JuanVuletich-2022Jun15-16h25m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5297] on 15 June 2022 at 5:02:15 pm'!
!SourceCodeInterval class methodsFor: 'error messages' stamp: 'jmv 6/15/2022 17:01:29'!
  canNotExpandIncompleteStatementError

	^ 'Can not expand an incomplete statement'.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5298-AddMissingErrorMessage-JuanVuletich-2022Jun15-17h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5298] on 15 June 2022 at 5:19:59 pm'!

Smalltalk removeClassNamed: #EncodedFileStreamTest!

!classRemoval: #EncodedFileStreamTest stamp: 'Install-5299-RemoveMisplacedTests-JuanVuletich-2022Jun15-17h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
TestCase subclass: #EncodedFileStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

Smalltalk removeClassNamed: #FileStreamTest!

!classRemoval: #FileStreamTest stamp: 'Install-5299-RemoveMisplacedTests-JuanVuletich-2022Jun15-17h15m-jmv.001.cs.st 6/16/2022 07:24:54'!
TestCase subclass: #FileStreamTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5299-RemoveMisplacedTests-JuanVuletich-2022Jun15-17h15m-jmv.001.cs.st----!

----QUIT----(16 June 2022 07:24:59) Cuis6.0-5299.image priorSource: 867323!

----STARTUP---- (5 July 2022 10:30:04) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5299.image!


'From Cuis 6.0 [latest update: #5235] on 12 June 2022 at 7:29:07 pm'!
!MethodNode methodsFor: 'accessing' stamp: 'FB 6/12/2022 18:56:52'!
                   statements

	^block statements.! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'FB 6/12/2022 19:25:43' prior: 50371028!
               declareNecessaryTemporaries

	temporariesToDeclareByInsertionPoint keysAndValuesDo: [:aSenderAndPosition :temporariesToDeclare |
		| sender positionToInsertTemporaries temporariesString |
		sender := aSenderAndPosition key.
		positionToInsertTemporaries := aSenderAndPosition value.
		temporariesString := temporariesToDeclare reduce: [:t1 : t2 | t1 value, ' ', t2 value].
		((sender methodNode parseNodesPathAt: positionToInsertTemporaries ifAbsent: 	[self shouldNotHappen ]) first key isTemporariesDeclaration)
			ifTrue: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: temporariesString, ' |'
				inMethod: sender.
			]
			ifFalse: [
				self replaceRange: (positionToInsertTemporaries to: positionToInsertTemporaries)
				withNewSourceCode: '| ',  temporariesString, ' |', Character newLineCharacter asString, Character tab asString
				inMethod: sender
			]
	]! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 6/12/2022 19:25:34' prior: 50371407!
                  buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference removingReturn: removeReturn

	| inlinedStatements senderCompleteSourceRanges argumentsAndTemporariesReplacements indentation |

	senderCompleteSourceRanges := aMessageNodeReference methodNode completeSourceRanges.
	self calculateReplacementsFrom: aMessageNodeReference
		usingRanges: senderCompleteSourceRanges.

	self declareTemporariesIfNeededFor: aMessageNodeReference.
	argumentsAndTemporariesReplacements := self replacementsMapForMessageSend: aMessageNodeReference.

	indentation := self indentationUpTo: aMessageNodeReference completeSourceRange first in: aMessageNodeReference compiledMethod sourceCode.
	inlinedStatements := (statementsToInline collect: [:aStatementToInline |
		self sourceCodeOfImplementorStatement: aStatementToInline withReplacements: argumentsAndTemporariesReplacements removingReturn: removeReturn
			 ])
			reduce: [:aStatementWithReplacements :nextStatementWithReplacements |
				aStatementWithReplacements, Character newLineCharacter asString, indentation,
					(nextStatementWithReplacements copyReplaceAll: String newLineString with: String newLineString asTokens: false)].

	^inlinedStatements.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 6/12/2022 18:33:45' prior: 50371594!
  indentationUpTo: anIndex in: aSourceCode

	| indentation currentIndex character|

	currentIndex := anIndex - 1.
	((aSourceCode at: currentIndex) = $^) ifTrue: [currentIndex := currentIndex  -1]. "Skip the return character if present"
	indentation := ''.

	[currentIndex > 0 and: [
		character := (aSourceCode at: currentIndex).
		(character = Character tab) or: [character = Character space]
	]] whileTrue: [
		indentation := indentation, character asString.
		currentIndex := currentIndex - 1.
	].

	^(character = Character newLineCharacter) ifFalse: [^''] ifTrue: [^indentation reversed].! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 6/12/2022 18:49:29' prior: 50371770!
               inlineMessageSend: aMessageNodeReference

	| statementsToInline |

	statementsToInline := self removeReturnSelfStatementIfNeeded: (methodToInline methodNode block statements).
	statementsToInline isEmpty ifTrue: [^self].
	statementsToInline last isReturn
		ifTrue: [self inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReference.]
		ifFalse: [self inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReference
			 removingReturn: true].


	! !
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 6/12/2022 18:47:21' prior: 50374081!
   on: anEditor for: aSelectionInterval of: aMethodToRefactor

	| noTempFoundBlock tempToInline usageInterval |

	noTempFoundBlock := [
		"This case will usually end in a failure because a temporary variable is not related to the selected interval"
		tempToInline := anEditor wordUnder: aSelectionInterval first.
		usageInterval := aSelectionInterval.
	].

	anEditor
		withNodeUnderCursorDo: [:aNode | | methodNode sourceRanges |
			methodNode :=aMethodToRefactor methodNode.
			sourceRanges := methodNode completeSourceRanges.
			aNode isVariableNode
				ifTrue: [
					tempToInline := aNode name.
					usageInterval := self findLeftmostSourceRangeOfNode: aNode inside: aSelectionInterval using: sourceRanges.
				]
				ifFalse: [ | assignmentNodeAndRange |
					assignmentNodeAndRange := (methodNode parseNodesPathAt: aSelectionInterval first ifAbsent: 	[self shouldNotHappen.])
						detect: [:aNodeAndRange | aNodeAndRange key isAssignmentNode]
						ifNone: [noTempFoundBlock value].
					tempToInline ifNil: [
						tempToInline := assignmentNodeAndRange key variable name.
						usageInterval := self findLeftmostSourceRangeOfNode: assignmentNodeAndRange key variable
							inside: assignmentNodeAndRange value using: sourceRanges.
					]
				]
		]
		ifAbsent: [
			noTempFoundBlock value.
		].

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5300-CuisCore-FernandoBalboa-2022Jun12-18h16m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5235] on 12 June 2022 at 6:16:14 pm'!
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 6/12/2022 18:06:43'!
         findLeftmostSourceRangeOfNode: aParseNode inside: anInterval using: completeSourceRanges

	^((completeSourceRanges associations detect: [:aNodeAndRange | aNodeAndRange key equivalentTo: aParseNode]) value)
		detect: [:nodeRange | anInterval includesAllOf: nodeRange].! !

InlineTemporaryVariableApplier class removeSelector: #findSourceRangeOfNode:inside:using:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5301-CuisCore-FernandoBalboa-2022Jun12-17h00m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5300] on 16 June 2022 at 4:31:56 pm'!
!Browser methodsFor: 'system category functions' stamp: 'len 6/12/2022 13:44:27'!
    categorizeUnderCategory: systemCategoryName class: className
	systemCategoryName isNil ifTrue: [^ self].
	(Smalltalk at: className asSymbol ifAbsent: [^ self]) category: systemCategoryName! !
!HierarchicalListMorph methodsFor: 'accessing' stamp: 'len 6/16/2022 16:30:58'!
                rejectDrops

	self removeProperty: #allowsMorphDrop.
	self removeProperty: #acceptedDragSource.
	self removeProperty: #dropActionSelector.! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'len 6/12/2022 13:31:46' overrides: 16892185!
                 dragEvent: aMouseEvent localPosition: localEventPosition
	| draggedItem draggingGuide label |
	draggedItem _ ((self itemFromPoint: localEventPosition) ifNil: [ ^self ]) withoutListWrapper.
	label _ LabelMorph contents: draggedItem asString.
	draggingGuide _ DraggingGuideMorph new.
	draggingGuide addMorph: label.
	draggingGuide morphExtent: label morphExtent.
	draggingGuide setProperty: #dragSource toValue: self.
	draggingGuide setProperty: #dropSelectorArgument toValue: draggedItem.	
	aMouseEvent hand attachMorphBeside: draggingGuide! !
!HierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 13:31:07' overrides: 16892045!
                     acceptDroppingMorph: aMorph event: dropEvent
	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:event: message. This default implementation just adds the given morph to the receiver."
	| localPosition targetItem dropActionSelector args |
	localPosition _ self internalizeFromWorld: dropEvent eventPosition.
	targetItem _ ((self itemFromPoint: localPosition) ifNil: [ ^self ]) withoutListWrapper.
	dropActionSelector _ self valueOfProperty: #dropActionSelector.
	args _ dropActionSelector numArgs.
	args = 1 ifTrue: [ ^model perform: dropActionSelector with: targetItem].
	args = 2 ifTrue: [ | dropSelectorArgument |
		dropSelectorArgument _ aMorph
			valueOfProperty: #dropSelectorArgument
			ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
		^model perform: dropActionSelector with: targetItem with: dropSelectorArgument ].
	self error: 'dropActionSelector must be a 1- or 2-keyword symbol'! !
!HierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 12:40:22'!
           acceptDropsFrom: aMorph performing: dropActionSelector
	(dropActionSelector numArgs between: 1 and: 2) ifFalse: [ self error: 'dropActionSelector must be a 1- or 2-keyword symbol' ].
	self setProperty: #allowsMorphDrop toValue: true.
	self setProperty: #acceptedDragSource toValue: aMorph.
	self setProperty: #dropActionSelector toValue: dropActionSelector! !
!HierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 13:26:38'!
allowItemDrag: aBoolean
	self setProperty: #allowsItemDrag toValue: aBoolean! !
!HierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 12:33:40' overrides: 50339211!
    wantsDroppedMorph: aMorph event: evt
	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. Note that for a successful drop operation both parties need to agree. The symmetric check is done automatically via aMorph wantsToBeDroppedInto: self."

	^(aMorph is: #DraggingGuideMorph)
		and: [ (aMorph valueOfProperty: #dragSource) = (self valueOfProperty: #acceptedDragSource) ]! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 12:57:39'!
       acceptDropsFrom: aMorph performing: dropActionSelector
	(dropActionSelector numArgs between: 1 and: 2) ifFalse: [ self error: 'dropActionSelector must be a 1- or 2-keyword symbol' ].
	self setProperty: #allowsMorphDrop toValue: true.
	self setProperty: #acceptedDragSource toValue: aMorph.
	self setProperty: #dropActionSelector toValue: dropActionSelector! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 13:25:07'!
   allowItemDrag: aBoolean
	self setProperty: #allowsItemDrag toValue: aBoolean! !
!Browser methodsFor: 'message category functions' stamp: 'len 6/12/2022 12:56:06' prior: 16795744!
             categorizeUnderCategoryAt: aMessageCategoryListIndex selector: aSelectorToCategorize
	aMessageCategoryListIndex isNil ifTrue: [^ self categorizeUnderNewCategorySelector: aSelectorToCategorize].
	self selectedClassOrMetaClass ifNotNil: [ :class | | categorySelector |
		categorySelector _ self messageCategoryList at: aMessageCategoryListIndex ifAbsent: [^self].
		categorySelector ~= Categorizer allCategory
			ifTrue: [
				class organization classify: aSelectorToCategorize under: categorySelector suppressIfDefault: false.
				self changed: #messageList]]! !
!Morph methodsFor: 'event handling testing' stamp: 'len 6/12/2022 12:05:17' prior: 16892403!
                 allowsMorphDrop
	"Answer whether we accept dropping morphs. By default answer false."

	^ (self valueOfProperty: #allowsMorphDrop) = true! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'len 6/12/2022 13:23:33' prior: 50333112 overrides: 16911850!
  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [ ^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: ((self valueOfProperty: #allowsItemDrag) = true ifTrue: [ #dragEvent:localPosition: ])! !
!PluggableListMorph methodsFor: 'accessing - properties' stamp: 'len 6/16/2022 16:28:43' prior: 16910544!
                  rejectDrops

	self removeProperty: #allowsMorphDrop.
	self removeProperty: #acceptedDragSource.
	self removeProperty: #dropActionSelector.! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 12:54:46' prior: 16910586 overrides: 16892045!
                         acceptDroppingMorph: aMorph event: dropEvent
	| localPosition row dropSelectorArgument dropActionSelector args |
	localPosition _ self internalizeFromWorld: dropEvent eventPosition.
	row _ self rowAtLocation: localPosition ifNone: [].
	dropSelectorArgument _ aMorph
		valueOfProperty: #dropSelectorArgument
		ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
	dropActionSelector _ self valueOfProperty: #dropActionSelector.
	args _ dropActionSelector numArgs.
	args = 1 ifTrue: [ ^model perform: dropActionSelector with: dropSelectorArgument ].
	args = 2 ifTrue: [ ^model perform: dropActionSelector with: row with: dropSelectorArgument ].
	self error: 'dropActionSelector must be a 1- or 2-keyword symbol'
	
		
! !
!PluggableListMorph methodsFor: 'events' stamp: 'len 6/12/2022 12:23:38' prior: 16910672 overrides: 16892185!
             dragEvent: aMouseEvent localPosition: localEventPosition
	| row listItem label draggingGuide |
	scroller highlightedRow: nil.
	row _ self rowAtLocation: localEventPosition ifNone: [ ^self ].
	listItem _ self getListItem: row.
	
	label _ LabelMorph contents: listItem.
	draggingGuide _ DraggingGuideMorph new.
	draggingGuide addMorph: label.
	draggingGuide morphExtent: label morphExtent.
	draggingGuide setProperty: #dragSource toValue: self.
	draggingGuide setProperty: #dropSelectorArgument toValue: listItem.
	
	aMouseEvent hand attachMorphBeside: draggingGuide! !
!PluggableListMorph methodsFor: 'events' stamp: 'len 6/12/2022 13:24:13' prior: 16910720 overrides: 16911850!
                          mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| row |
	
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		scroller noSelection].
	row _ self 
		rowAtLocation: localEventPosition
		ifNone:  [^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view.
	Model update will be done on mouse button up, so this feedback will be visible before that."
	scroller highlightedRow: row.

	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: ((self valueOfProperty: #allowsItemDrag) = true ifTrue: [ #dragEvent:localPosition: ] ifFalse: [ nil ])! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 6/12/2022 13:22:11' prior: 50335981!
             buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCategoryList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	classList allowItemDrag: true.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategory:class:.
		
	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 6/12/2022 13:22:16' prior: 50357254!
    buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	classList _ self buildMorphicClassList.
	classColumn _ self buildMorphicClassColumnWith: classList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (PreferenceNG at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

PluggableListMorph removeSelector: #acceptDroppingMorph:outsideListWithEvent:!

!methodRemoval: PluggableListMorph #acceptDroppingMorph:outsideListWithEvent: stamp: 'Install-5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st 7/5/2022 10:30:09'!
acceptDroppingMorph: aMorph outsideListWithEvent: dropEvent

	| dropActionSelector dropSelectorArgument |
	
	dropActionSelector _ self valueOfProperty: #dropOutsideListActionSelector.
	dropSelectorArgument _ aMorph
		valueOfProperty: #dropSelectorArgument
		ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
	model perform: dropActionSelector with: dropSelectorArgument.
	!

PluggableListMorph removeSelector: #allowsMorphDrop!

!methodRemoval: PluggableListMorph #allowsMorphDrop stamp: 'Install-5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st 7/5/2022 10:30:09'!
allowsMorphDrop

	^self hasProperty: #allowsMorphDrop!

PluggableListMorph removeSelector: #itemsAreDraggable!

!methodRemoval: PluggableListMorph #itemsAreDraggable stamp: 'Install-5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st 7/5/2022 10:30:09'!
itemsAreDraggable
	
	^self hasProperty: #draggableItems!

PluggableListMorph removeSelector: #acceptDroppingMorph:atRow:withEvent:!

!methodRemoval: PluggableListMorph #acceptDroppingMorph:atRow:withEvent: stamp: 'Install-5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st 7/5/2022 10:30:09'!
acceptDroppingMorph: aMorph atRow: row withEvent: dropEvent

	| args dropActionSelector |

	dropActionSelector _ self valueOfProperty: #dropActionSelector.
	args _ dropActionSelector numArgs.
	args = 1 ifTrue: [ ^model perform: dropActionSelector with: row].
	args = 2 ifTrue: [ | dropSelectorArgument |
		dropSelectorArgument _ aMorph
			valueOfProperty: #dropSelectorArgument
			ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
		^model perform: dropActionSelector with: row with: dropSelectorArgument ].
	
	self error: 'dropActionSelector must be a 1- or 2-keyword symbol'
	
	!

PluggableListMorph removeSelector: #acceptDropsFrom:performing:whenOutsideList:!

!methodRemoval: PluggableListMorph #acceptDropsFrom:performing:whenOutsideList: stamp: 'Install-5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st 7/5/2022 10:30:09'!
acceptDropsFrom: aMorph performing: aDropActionSelector whenOutsideList: aDropOutsideListActionSelector 

	(aDropActionSelector numArgs between: 1 and: 2) ifFalse: [ self error: 'dropActionSelector must be a 1- or 2-keyword symbol' ].
	aDropOutsideListActionSelector numArgs = 1 ifFalse: [ self error: 'dropOutsideListActionSelector must be a 1-keyword symbol' ].

	self setProperty: #allowsMorphDrop toValue: true.
	self setProperty: #acceptedDragSource toValue: aMorph.
	self setProperty: #dropActionSelector toValue: aDropActionSelector.
	self setProperty: #dropOutsideListActionSelector toValue: aDropOutsideListActionSelector !

PluggableListMorph removeSelector: #makeItemsUndraggable!

!methodRemoval: PluggableListMorph #makeItemsUndraggable stamp: 'Install-5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st 7/5/2022 10:30:09'!
makeItemsUndraggable

	self removeProperty: #draggableItems!

PluggableListMorph removeSelector: #makeItemsDraggable!

!methodRemoval: PluggableListMorph #makeItemsDraggable stamp: 'Install-5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st 7/5/2022 10:30:09'!
makeItemsDraggable

	self setProperty: #draggableItems toValue: true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5302-HierarchicalListDND-LucianoEstebanNotarfrancesco-2022Jun16-16h10m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5302] on 17 June 2022 at 10:11:35 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5303-Cleanup-JuanVuletich-2022Jun17-10h10m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5303] on 17 June 2022 at 11:19:28 am'!

PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView leftSibling rightSibling scrollSiblings '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableListMorph category: 'Morphic-Widgets' stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView leftSibling rightSibling scrollSiblings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!PluggableListMorph commentStamp: '<historical>' prior: 16910478!
                              When a PluggableListMorph is in focus, type in a letter (or several letters quickly) to go to the next item that begins with that letter. Special keys (up, down, home, etc.) are also supported.

It is possible to set sibling lists for multiscrolling by calling >>#scrollSiblings: with a collection of siblings. The sibling lists are scrolled vertically together with the receiver. For an example of usage see CodePackageListWindow >>#buildMorphicWindow.
!
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'len 6/17/2022 07:27:35'!
            currentChangeSetName
	^ (((myChangeSet isForBaseSystem or: [ myChangeSet codePackage notNil ]) and: [ myChangeSet hasUnsavedChanges ]) ifTrue: ['*'] ifFalse: ['']), myChangeSet name! !
!SingleSetChangeSorter methodsFor: 'accessing' stamp: 'len 6/17/2022 07:28:14' overrides: 50388189!
   currentChangeSetName
	^ (myChangeSet hasUnsavedChanges ifTrue: ['*'] ifFalse: ['']), myChangeSet name! !
!HandMorph methodsFor: 'focus handling' stamp: 'len 6/17/2022 11:13:10'!
              keyboardFocusNextWithinWindow
	| window |
	window _ (keyboardFocus ifNil: [^ false]) owningWindow.
	(keyboardFocus previousMorphThat: [ :m |
		m visible and: [m handlesKeyboard and: [m owningWindow = window]]]) ifNotNil: [ :aMorph |
			self newKeyboardFocus: aMorph.
			^true ].
	^false! !
!HandMorph methodsFor: 'focus handling' stamp: 'len 6/17/2022 11:13:03'!
                     keyboardFocusPreviousWithinWindow
	| window |
	window _ (keyboardFocus ifNil: [^ false]) owningWindow.
	(keyboardFocus nextMorphThat: [ :m |
		m visible and: [m handlesKeyboard and: [m owningWindow = window]]]) ifNotNil: [ :aMorph |
			self newKeyboardFocus: aMorph.
			^true ].
	^false! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'len 6/17/2022 11:18:26' overrides: 16892568!
                             focusKeyboardFor: aKeyboardEvent
{aKeyboardEvent . aKeyboardEvent isTab . aKeyboardEvent shiftPressed . aKeyboardEvent controlKeyPressed} print.
	(super focusKeyboardFor: aKeyboardEvent) ifTrue: [^ true].
	aKeyboardEvent shiftPressed ifTrue: [
		aKeyboardEvent isArrowLeft
			ifTrue: [ aKeyboardEvent hand keyboardFocusPreviousWithinWindow. ^ true ].
		aKeyboardEvent isArrowRight
			ifTrue: [ aKeyboardEvent hand keyboardFocusNextWithinWindow. ^ true ]].
	aKeyboardEvent isTab ifTrue: [
		aKeyboardEvent shiftPressed
			ifTrue: [ aKeyboardEvent hand keyboardFocusPreviousWithinWindow ]
			ifFalse: [ aKeyboardEvent hand keyboardFocusNextWithinWindow ]].
	^ true! !
!PluggableListMorph methodsFor: 'events' stamp: 'len 6/17/2022 10:55:01' overrides: 16892568!
        focusKeyboardFor: aKeyboardEvent
	(super focusKeyboardFor: aKeyboardEvent) ifTrue: [^ true].
{aKeyboardEvent . aKeyboardEvent isTab . aKeyboardEvent shiftPressed . aKeyboardEvent controlKeyPressed} print.
	(aKeyboardEvent isArrowLeft or: [aKeyboardEvent isTab and: [aKeyboardEvent shiftPressed]])
		ifTrue: [ aKeyboardEvent hand keyboardFocusPreviousWithinWindow. ^ true ].
	(aKeyboardEvent isArrowRight or: [aKeyboardEvent isTab])
		ifTrue: [ aKeyboardEvent hand keyboardFocusNextWithinWindow. ^ true ].
	^ false! !
!PluggableListMorph methodsFor: 'scrolling' stamp: 'len 6/17/2022 11:39:41'!
              updateSiblingsScroller
	"Update the siblings scroller to match the receiver."
	(self valueOfProperty: #scrollSiblings) ifNotNil: [:aCollection|
		| yOffset |
		yOffset _ self scrollerOffset y.
		aCollection do: [:each| each scrollerOffset: each scrollerOffset x @ yOffset]]! !
!ChangeSorter methodsFor: 'access' stamp: 'len 6/17/2022 07:26:02' prior: 16807103!
                       showChangeSet: chgSet

	myChangeSet == chgSet ifFalse: [
		myChangeSet _ chgSet.
		currentClassName _ nil.
		currentSelector _ nil].
	self changed: #relabel.
	self changed: #currentChangeSetName.	"new -- list of sets"
	self changed: #mainButtonName.	"old, button"
	self changed: #classList.
	self changed: #messageList.
	self acceptedContentsChanged.! !
!ChangeSorter methodsFor: 'access' stamp: 'len 6/17/2022 07:24:21' prior: 16807116!
          showChangeSetNamed: aString
	| name |
	name _ (aString beginsWith: '*') ifTrue: [aString allButFirst] ifFalse: [aString].
	self showChangeSet: (ChangeSet changeSetNamed: name) ! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'len 6/17/2022 07:14:27' prior: 16807138!
                changeSetList
	"Answer a list of ChangeSet names to be shown in the change sorter."

	^ (ChangeSet allChangeSets collect: [ :each |
		(((each isForBaseSystem or: [ each codePackage notNil ]) and: [ each hasUnsavedChanges ]) ifTrue: ['*'] ifFalse: ['']), each name ]) reversed! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'len 6/17/2022 07:15:33' prior: 16807282 overrides: 16821313!
                         updateIfNeeded
	"Recompute all of my lists."
	| newList |
	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList ].

	self acceptedContentsChanged! !
!SingleSetChangeSorter methodsFor: 'accessing' stamp: 'len 6/17/2022 07:18:34' prior: 16936804 overrides: 50388307!
                      changeSetList
	^{ (myChangeSet hasUnsavedChanges ifTrue: ['*'] ifFalse: ['']), myChangeSet name }! !
!CodePackageList methodsFor: 'accessing' stamp: 'len 6/17/2022 07:06:51' prior: 16819979!
 packageNames
	^ packages collect: [ :each | (each hasUnsavedChanges ifTrue: ['*'] ifFalse: ['']), each packageNameAndVersion ]! !
!CodePackageList methodsFor: 'accessing' stamp: 'len 6/17/2022 07:07:23' prior: 16819998!
    selectionIndex: anInteger

	selection _ anInteger = 0 ifFalse: [ packages at: anInteger ].
	self
		changed: #packageNames;
		changed: #packageFullNames;
		changed: #description;
		changed: #summary;
		changed: #requirements! !
!CodePackageList methodsFor: 'events' stamp: 'len 6/17/2022 07:08:14' prior: 16820051!
      updatePackageList
	
	| newPackages oldPackages |
	oldPackages _ (packages ifNil: [#()]) asIdentitySet.
	newPackages _ CodePackage installedPackages asIdentitySet.
	oldPackages do: [ :old |
		(newPackages includes: old) ifFalse: [
			old removeActionsWithReceiver: self ]].
	newPackages do: [ :new |
		(oldPackages includes: new) ifFalse: [
			new when: #dirtyFlagChanged send:#updatePackageList to: self ]].
	newPackages _ newPackages asArray sort: [ :a :b |
		 a packageName < b packageName ].
	packages _ newPackages.
	self
		changed: #packageNames;
		changed: #packageFullNames;
		changed: #description;
		changed: #summary;
		changed: #requirements! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/21/2018 09:21:39' prior: 16892568!
                       focusKeyboardFor: aKeyboardEvent

	"If aKeyboardEvent ctrl-tab or shift-ctrl-tab use it to navigate keyboard focus.
	Warning: This doesn't work on Windows... the event is not sent"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent controlKeyPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ]
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ].
			^ true ].
	"On Windows use at least some keystroke to navigate morphs... even shift-Tab that should navigate backwards"
"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent shiftPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent hand keyboardFocusNext.
			^ true ].
"

	"Cycle through windows with cmdAlt + < and cmdAlt + >.
	VM and platform peculiarities are hidden in #isCmdAltLessThan and #isCmdAltGreaterThan"
	"This was done as an attempt to mimic the Mac OSX keystrokes for 'Move focus to next window in active application'. Unfortunately, it only works if OS X is set to use any other keys for this. If (as for example, with German defaults), OS-X uses these keystrokes, then they are not sent to the VM. This is a long standing issues in Chromium and PhotoShop, for example..."
	self disableCode: [
		aKeyboardEvent isCmdAltLessThan ifTrue: [
			aKeyboardEvent hand activatePreviousWindow.
			^true ].
		aKeyboardEvent isCmdAltGreaterThan ifTrue: [
			aKeyboardEvent hand activateNextWindow.
			^true ]].
	"Alternative for Mac OS-X: option-Tab and option-shift-Tab"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent rawMacOptionKeyPressed ])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand activatePreviousWindow ]
				ifFalse: [ aKeyboardEvent hand activateNextWindow ].
			^ true ].
	"Alternative for non-Mac OS-X: alt-< and alt->"
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $< ]) ifTrue: [
		aKeyboardEvent hand activatePreviousWindow.
		^true ].
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $> ]) ifTrue: [
		aKeyboardEvent hand activateNextWindow.
		^true ].
	^false! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'len 6/17/2022 07:33:29' prior: 16910868 overrides: 50354163!
     initialize
	super initialize.
	scroller morphWidth: extent x! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'len 6/17/2022 06:48:51' prior: 16910902!
                         arrowKey: aKeyboardEvent
	"Handle a keyboard navigation event. Answer nil if not handled."
	aKeyboardEvent isArrowUp ifTrue: [ ^ self navigateUp ].
	aKeyboardEvent isArrowDown ifTrue: [ ^ self navigateDown ].
	aKeyboardEvent isHome ifTrue: [ ^ self navigateToTop ].
	aKeyboardEvent isEnd ifTrue: [ ^ self navigateToBottom ].
	aKeyboardEvent isPageUp ifTrue: [ ^ self navigateOnePageUp ].
	aKeyboardEvent isPageDown ifTrue: [ ^ self navigateOnePageDown ].
	^ nil! !
!PluggableListMorph methodsFor: 'scrolling' stamp: 'len 6/17/2022 11:40:12' prior: 16911307 overrides: 16912434!
                              scrollBy: delta
	"Scroll self and any siblings"
	super scrollBy: delta.
	self updateSiblingsScroller! !
!PluggableListMorph methodsFor: 'scrolling' stamp: 'len 6/17/2022 11:40:38' prior: 16911323 overrides: 16912456!
       scrollSelectionIntoView
	"make sure that the current selection is visible"
	| row r |
	row _ self getCurrentSelectionIndex.
	row = 0 
		ifTrue: [
			"Value is 0, but we need to propagate it to model"
			scrollBar internalScrollValue: scrollBar scrollValue ]
		ifFalse: [
			r _ scroller externalizeBoundingRectOf: (scroller drawBoundsForRow: row).
			self scrollToShow: r ].
	self updateSiblingsScroller! !
!PluggableListMorph methodsFor: 'scrolling' stamp: 'len 6/17/2022 11:43:05' prior: 16911301!
            scrollSiblings: aCollection
	"Set a collection of scroll panes to be scroller together with the receiver."
	self setProperty: #scrollSiblings toValue: aCollection! !
!PluggableListMorph methodsFor: 'scrolling' stamp: 'len 6/17/2022 11:41:26' prior: 16911338 overrides: 16912462!
         scrollToShow: aRectangle
	super scrollToShow: aRectangle.
	self updateSiblingsScroller! !
!PluggableListMorph methodsFor: 'scrolling' stamp: 'len 6/17/2022 11:41:55' prior: 16911350 overrides: 16912495!
                     vScrollBarValue: scrollValue
	super vScrollBarValue: scrollValue.
	self updateSiblingsScroller! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'len 6/17/2022 11:44:13' prior: 16820155!
                           buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| names fileNames namesPane fileNamesPane 
	upperRow  description summary backColor labelBackground |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	
	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	namesPane := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: ' Package Name');
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor;
			   alwaysHideVerticalScrollbar.
	fileNamesPane := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: ' File Name');
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: namesPane proportionalWidth: 0.4;
		addAdjusterAndMorph: fileNamesPane proportionalWidth: 0.6.
		
	description := (TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:) emptyTextDisplayMessage: 'Please enter a description for this package'.

	summary := (TextModelMorph
		textProvider: model
		textGetter: #summary) emptyTextDisplayMessage: 'Package summary (No package selected?)'.
	
	names scrollSiblings: {fileNames}.
	fileNames scrollSiblings: {names}.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: self buildButtonPane fixedHeight: Theme current buttonPaneHeight;
		addAdjusterAndMorph: summary fixedHeight: 60;
		addAdjusterAndMorph: description proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.15.
	self setLabel: 'Installed Packages'! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 6/17/2022 07:30:20' prior: 50387924!
                               buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCategoryList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList allowItemDrag: true.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategory:class:.
		
	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 6/17/2022 07:30:29' prior: 50387966!
                           buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	classList _ self buildMorphicClassList.
	classColumn _ self buildMorphicClassColumnWith: classList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (PreferenceNG at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'len 6/17/2022 07:30:42' prior: 50357305 overrides: 50388597!
                            buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model setSelectedSystemCategory: model systemCategoryList first.
	sysCatList _ PluggableListMorph
			model: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:
			mainView: self
			menuGetter: #codeFileListMenu
			keystrokeAction: #codeFileListKey:from:.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList _ PluggableListMorph
			model: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:
			mainView: self
			menuGetter: #messageCategoryMenu
			keystrokeAction: nil.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (PreferenceNG at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'len 6/17/2022 07:26:15' prior: 16807592!
                   buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| changeSetList classList changeSetListPane classListPane
	  messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentChangeSetName
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetListPane _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classListPane _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: changeSetListPane proportionalWidth: 0.6;
		addAdjusterAndMorph: classListPane proportionalWidth: 0.4.
	
	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !

PluggableListMorph removeSelector: #vPrivateScrollTo:!

!methodRemoval: PluggableListMorph #vPrivateScrollTo: stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
vPrivateScrollTo: scrollValue

	self scrollerOffset: (self scrollerOffset x @ scrollValue)!

PluggableListMorph removeSelector: #rightSibling:!

!methodRemoval: PluggableListMorph #rightSibling: stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
rightSibling: aListMorphToTheRight

	rightSibling _ aListMorphToTheRight!

PluggableListMorph removeSelector: #vScrollLeftSibling:!

!methodRemoval: PluggableListMorph #vScrollLeftSibling: stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
vScrollLeftSibling: yOffset
	"vertical scroll my LEFT siblings along with my self"
	self vPrivateScrollTo: yOffset.
	scrollSiblings ifTrue: [
		leftSibling  ifNotNil: [ :left    | 
			 left  vScrollLeftSibling: yOffset ]
	]!

PluggableListMorph removeSelector: #gainFocusFrom:!

!methodRemoval: PluggableListMorph #gainFocusFrom: stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
gainFocusFrom: aHand

	aHand newKeyboardFocus: self.
	self getCurrentSelectionIndex = 0 ifTrue: [ self selectionIndex: 1 ].!

PluggableListMorph removeSelector: #scrollMySiblings!

!methodRemoval: PluggableListMorph #scrollMySiblings stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
scrollMySiblings
	"vertical scroll my siblings along with my self"
	| yOffset |
	yOffset := self scrollerOffset y.
	scrollSiblings ifTrue: [
		self vScrollLeftSibling:  yOffset; 
			vScrollRightSibling: yOffset
	]!

PluggableListMorph removeSelector: #navigateRight!

!methodRemoval: PluggableListMorph #navigateRight stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
navigateRight

	rightSibling ifNotNil: [ rightSibling gainFocusFrom: self activeHand ]!

PluggableListMorph removeSelector: #leftSibling:rightSibling:!

!methodRemoval: PluggableListMorph #leftSibling:rightSibling: stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
leftSibling: aListMorphToTheLeft rightSibling: aListMorphToTheRight

	self leftSibling: aListMorphToTheLeft.
	self rightSibling: aListMorphToTheRight.!

PluggableListMorph removeSelector: #leftSibling:!

!methodRemoval: PluggableListMorph #leftSibling: stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
leftSibling: aListMorphToTheLeft

	leftSibling _ aListMorphToTheLeft!

PluggableListMorph removeSelector: #scrollSiblings!

!methodRemoval: PluggableListMorph #scrollSiblings stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
scrollSiblings
	"Do I scroll my siblings with myself?"
	^ scrollSiblings!

PluggableListMorph removeSelector: #vScrollRightSibling:!

!methodRemoval: PluggableListMorph #vScrollRightSibling: stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
vScrollRightSibling: yOffset
	"vertical scroll my RIGHT siblings along with my self"
	self vPrivateScrollTo: yOffset.
	scrollSiblings ifTrue: [
		rightSibling  ifNotNil: [ :left    | 
			 left  vScrollRightSibling: yOffset ]
	]!

PluggableListMorph removeSelector: #navigateLeft!

!methodRemoval: PluggableListMorph #navigateLeft stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
navigateLeft

	leftSibling ifNotNil: [ leftSibling gainFocusFrom: self activeHand ]!

CodePackageList removeSelector: #updateDirtyFlags!

!methodRemoval: CodePackageList #updateDirtyFlags stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
updateDirtyFlags
	self
		changed: #packageDirtyFlags;
		changed: #packageNames;		"if it was set dirty, revision number changed"
		changed: #packageFullNames	"if it was never saved and now it is, fileName changes"!

CodePackageList removeSelector: #packageDirtyFlags!

!methodRemoval: CodePackageList #packageDirtyFlags stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
packageDirtyFlags

	^ packages collect: [ :each |
		each hasUnsavedChanges
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]!

SingleSetChangeSorter removeSelector: #changeSetDirtyFlags!

!methodRemoval: SingleSetChangeSorter #changeSetDirtyFlags stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
changeSetDirtyFlags

	^myChangeSet hasUnsavedChanges
			ifTrue: [ #('     --->')]
			ifFalse: [ #('       -') ]!

ChangeSorter removeSelector: #changeSetDirtyFlags!

!methodRemoval: ChangeSorter #changeSetDirtyFlags stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
changeSetDirtyFlags

	^ (ChangeSet allChangeSets collect: [ :each |
		((each isForBaseSystem or: [ each codePackage notNil ]) and: [ each hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed!

PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableListMorph category: 'Morphic-Widgets' stamp: 'Install-5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st 7/5/2022 10:30:10'!
PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5304-BrowserKeyboardNavigation-siblingScrolllRemoval-LucianoEstebanNotarfrancesco-2022Jun17-10h46m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5304] on 20 June 2022 at 2:30:09 pm'!
!PluggableListMorph methodsFor: 'testing' stamp: 'jmv 6/20/2022 14:23:19'!
                 allowsMultipleSelection
	^false! !
!PluggableListMorphOfMany methodsFor: 'testing' stamp: 'jmv 6/20/2022 14:23:12' overrides: 50389034!
                        allowsMultipleSelection
	^true! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 6/20/2022 14:27:00' prior: 50388229 overrides: 50388386!
             focusKeyboardFor: aKeyboardEvent
	(super focusKeyboardFor: aKeyboardEvent)
		ifTrue: [^ true].
	aKeyboardEvent shiftPressed ifTrue: [
		aKeyboardEvent isArrowLeft
			ifTrue: [ ^ aKeyboardEvent hand keyboardFocusPreviousWithinWindow ].
		aKeyboardEvent isArrowRight
			ifTrue: [ ^ aKeyboardEvent hand keyboardFocusNextWithinWindow ]].
	^ false! !
!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 6/20/2022 14:24:53' prior: 16910624 overrides: 16892953!
                keyboardFocusChange: aBoolean
	"The message is sent to a morph when its keyboard focus changes.
	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.
	In this case, all we need to do is to redraw focus feedback"

	(scroller selectedRow = 0 and: [
		self allowsMultipleSelection not and: [ self getListSize > 0 ]])
			ifTrue: [ self navigateToTop ].
	drawKeyboardFocusIndicator
		ifTrue: [self redrawNeeded]
		ifFalse: [
			scroller selectedRow
				ifNotNil: [ :i |
					scroller selectedRow: nil; selectedRow: i ]]! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 6/20/2022 14:27:46' prior: 50388253 overrides: 50388386!
   focusKeyboardFor: aKeyboardEvent
	(super focusKeyboardFor: aKeyboardEvent)
		ifTrue: [^ true].
	aKeyboardEvent isArrowLeft
		ifTrue: [ ^ aKeyboardEvent hand keyboardFocusPreviousWithinWindow ].
	aKeyboardEvent isArrowRight
		ifTrue: [ ^ aKeyboardEvent hand keyboardFocusNextWithinWindow ].
	^ false! !

ChangeSorter removeSelector: #currentCngSet!

!methodRemoval: ChangeSorter #currentCngSet stamp: 'Install-5305-BrowserKeyboardNavigation-tweaks-JuanVuletich-2022Jun20-14h14m-jmv.001.cs.st 7/5/2022 10:30:10'!
currentCngSet
	^ myChangeSet name!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5305-BrowserKeyboardNavigation-tweaks-JuanVuletich-2022Jun20-14h14m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5305] on 23 June 2022 at 11:21:01 am'!
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/23/2022 09:50:02' prior: 16959172 overrides: 16892010!
                              visible: aBoolean
	self visible == aBoolean
		ifTrue: [ ^ self ].
	super visible: aBoolean.
	aBoolean ifTrue: [
		self activate ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5306-SystemWindow-DontGrabFocusWhenShouldnt-JuanVuletich-2022Jun23-11h19m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5306] on 23 June 2022 at 4:08:03 pm'!
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 6/23/2022 16:07:18' prior: 50366921!
       inOutdent: aKeyboardEvent delta: delta
	"Add/remove a tab at the front of every line occupied by the selection.
	This is a user command, and generates undo"

	| realStart realStop lines startLine stopLine start stop adjustStart size inStream outStream |

	"Operate on entire lines, but remember the real selection for re-highlighting later"
	realStart _ self startIndex.
	realStop _ self stopIndex - 1.

	"Special case: the text cursor on a line of its own, including weird case at end of paragraph"
	(realStart > realStop and: [
				realStart < 2 or: [(self privateCurrentString at: realStart - 1) isLineSeparator ]])
		ifTrue: [
			delta < 0
				ifTrue: [
					morph flash]
				ifFalse: [
					self replaceSelectionWith: Character tab asSymbol.
					self deselectAndPlaceCursorAt: realStart + 1].
			^true].

	lines _ textComposition lines.
	startLine _ textComposition lineIndexFor: realStart.
	stopLine _ textComposition lineIndexFor: (realStart max: realStop).
	start _ (lines at: startLine) first.
	stop _ (lines at: stopLine) last.
	
	"Pin the start of highlighting unless the selection starts a line"
	adjustStart _ realStart > start.

	size _  stop + 1 - start.
	inStream _ self privateCurrentString readStreamFrom: start to: stop.
	outStream _ self stringClassToUse writeStream.

	"This subroutine does the actual work"
	self indent: delta fromStream: inStream toStream: outStream.

	"Adjust the range that will be highlighted later"
	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].
	realStop _ realStop + outStream position - size.

	"Prepare for another iteration"
	self selectInvisiblyFrom: start to: stop.
	self replaceSelectionWith: outStream contents.
	self selectFrom: realStart to: realStop. 	"highlight only the original range"
	^ true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5307-IndentOutdentTweak-JuanVuletich-2022Jun23-15h59m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5307] on 23 June 2022 at 4:11:12 pm'!
!Morph methodsFor: 'focus handling' stamp: 'jmv 6/23/2022 16:09:26'!
   keyboardFocused
	"Just given focus via keyboard."! !
!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 6/23/2022 16:10:12' overrides: 50389189!
     keyboardFocused
	"Just given focus via keyboard.
	Autoselect first row."

	(scroller selectedRow = 0 and: [
		self allowsMultipleSelection not and: [ self getListSize > 0 ]])
			ifTrue: [ self navigateToTop ].! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 6/23/2022 15:48:54' prior: 50388204!
                  keyboardFocusNextWithinWindow
	| window |
	window _ (keyboardFocus ifNil: [^ false]) owningWindow.
	(keyboardFocus previousMorphThat: [ :m |
		m visible and: [m handlesKeyboard and: [m owningWindow = window]]]) ifNotNil: [ :aMorph |
			self newKeyboardFocus: aMorph.
			aMorph keyboardFocused.
			^true ].
	^false! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 6/23/2022 15:49:06' prior: 50388216!
          keyboardFocusPreviousWithinWindow
	| window |
	window _ (keyboardFocus ifNil: [^ false]) owningWindow.
	(keyboardFocus nextMorphThat: [ :m |
		m visible and: [m handlesKeyboard and: [m owningWindow = window]]]) ifNotNil: [ :aMorph |
			self newKeyboardFocus: aMorph.
			aMorph keyboardFocused.
			^true ].
	^false! !
!PluggableListMorph methodsFor: 'event handling' stamp: 'jmv 6/23/2022 15:49:35' prior: 50389059 overrides: 16892953!
             keyboardFocusChange: aBoolean
	"The message is sent to a morph when its keyboard focus changes.
	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.
	In this case, all we need to do is to redraw focus feedback"
	drawKeyboardFocusIndicator
		ifTrue: [self redrawNeeded]
		ifFalse: [
			scroller selectedRow
				ifNotNil: [ :i |
					scroller selectedRow: nil; selectedRow: i ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5308-KeyboardNavigationTweaks-JuanVuletich-2022Jun23-16h09m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5308] on 23 June 2022 at 4:41:00 pm'!
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/23/2022 16:39:16' prior: 16944805 overrides: 16856322!
               nextPutAll: aString
	"Write all the characters of the given string to this file."

	| byteString |
	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [ 
		position < readLimit ifTrue: [ self flushReadBuffer ] ].
	byteString _ aString isString ifTrue: [ aString asByteString ] ifFalse: [ aString ].
	self primWrite: fileID from: byteString startingAt: 1 count: byteString basicSize.
	^ aString
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5309-StandardFileStream-convertToByteStringIfNeeded-JuanVuletich-2022Jun23-16h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5308] on 23 June 2022 at 5:04:24 pm'!
!Character methodsFor: 'converting' stamp: 'jmv 6/23/2022 17:01:52'!
     asUnicodeCodePoint
	^UnicodeCodePoint codePoint: self codePoint! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/23/2022 16:49:59'!
                    isUnaccented
	"Answer whether the receiver is an unaccented letter."
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isUnaccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'copying' stamp: 'jmv 6/23/2022 16:54:34' overrides: 16901967!
                      shallowCopy
	"Answer with me, because we are immutable."! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 6/23/2022 16:43:47' overrides: 16901837!
    asString
	^Utf8String with: self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 6/23/2022 17:02:06'!
                to: other
	"Answer with a collection in ascii order
	$a asUnicodeCodePoint to: $z asUnicodeCodePoint
	"
	^ (self codePoint to: other codePoint) collect:
				[ :codePoint | UnicodeCodePoint codePoint: codePoint ]! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 6/23/2022 17:04:07'!
                             withDiacriticalMark: anUnicodeCodePoint
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch |
		^UnicodeCodePoint codePoint: (ch withDiacriticalMark: anUnicodeCodePoint) codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 6/23/2022 16:47:17'!
  hex
	^value printStringBase: 16 length: 6 padded: true! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 6/23/2022 16:49:08' overrides: 16902865!
        isLiteral
self flag: #unicodeNeedsImprovement.
	^super isLiteral! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 6/23/2022 16:51:57' overrides: 16902975!
                              printOn: aStream 
	aStream nextPut: $$; nextPut: $(.
	aStream nextPutAll: self hex.
	aStream nextPut: $).! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 6/23/2022 16:59:07' overrides: 16903050!
                     storeOn: aStream

	aStream nextPutAll: '(UnicodeCodePoint codePoint: '.
	aStream print: value.
	aStream nextPut: $).! !
!UnicodeCodePoint methodsFor: 'private' stamp: 'jmv 6/23/2022 16:55:56'!
                               privateValue: aNumericCodePoint
	value _ aNumericCodePoint! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 6/23/2022 16:53:55' overrides: 16901967!
           shallowCopy
	"Answer with me, because we are immutable."! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 6/23/2022 16:44:03' prior: 50368950!
        asSymbol
	^self asString asSymbol! !
!UnicodeCodePoint class methodsFor: 'instance creation' stamp: 'jmv 6/23/2022 16:56:24' prior: 50350920!
                  codePoint: aNumber
	^self new privateValue: aNumber! !

UnicodeCodePoint removeSelector: #codePoint:!

!methodRemoval: UnicodeCodePoint #codePoint: stamp: 'Install-5310-CodePoint-CompatibilityWithCharacter-JuanVuletich-2022Jun23-16h41m-jmv.001.cs.st 7/5/2022 10:30:10'!
codePoint: aNumber
	value _ aNumber!

Character removeSelector: #leadingChar!

!methodRemoval: Character #leadingChar stamp: 'Install-5310-CodePoint-CompatibilityWithCharacter-JuanVuletich-2022Jun23-16h41m-jmv.001.cs.st 7/5/2022 10:30:10'!
leadingChar
	"See Squeak if curious."
	^ 0!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5310-CodePoint-CompatibilityWithCharacter-JuanVuletich-2022Jun23-16h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5308] on 23 June 2022 at 5:06:59 pm'!

Utf8String removeSelector: #doesNotUnderstand:!

!methodRemoval: Utf8String #doesNotUnderstand: stamp: 'Install-5311-Cleanup-JuanVuletich-2022Jun23-17h04m-jmv.001.cs.st 7/5/2022 10:30:10'!
doesNotUnderstand: aMessage

	{ 'Utf8String does not understand: '. aMessage} print!

Utf8String removeSelector: #is:!

!methodRemoval: Utf8String #is: stamp: 'Install-5311-Cleanup-JuanVuletich-2022Jun23-17h04m-jmv.001.cs.st 7/5/2022 10:30:10'!
is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol!

Utf32String removeSelector: #doesNotUnderstand:!

!methodRemoval: Utf32String #doesNotUnderstand: stamp: 'Install-5311-Cleanup-JuanVuletich-2022Jun23-17h04m-jmv.001.cs.st 7/5/2022 10:30:10'!
doesNotUnderstand: aMessage

	{ 'Utf32String does not understand: '. aMessage} print!

Utf32String removeSelector: #is:!

!methodRemoval: Utf32String #is: stamp: 'Install-5311-Cleanup-JuanVuletich-2022Jun23-17h04m-jmv.001.cs.st 7/5/2022 10:30:10'!
is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol!

UnicodeCodePoint removeSelector: #doesNotUnderstand:!

!methodRemoval: UnicodeCodePoint #doesNotUnderstand: stamp: 'Install-5311-Cleanup-JuanVuletich-2022Jun23-17h04m-jmv.001.cs.st 7/5/2022 10:30:10'!
doesNotUnderstand: aMessage

	{ 'UnicodeCodePoint does not understand: '. aMessage} print!

UnicodeCodePoint removeSelector: #is:!

!methodRemoval: UnicodeCodePoint #is: stamp: 'Install-5311-Cleanup-JuanVuletich-2022Jun23-17h04m-jmv.001.cs.st 7/5/2022 10:30:10'!
is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5311-Cleanup-JuanVuletich-2022Jun23-17h04m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5311] on 24 June 2022 at 10:56:09 am'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/24/2022 10:50:57' prior: 50381649!
                asUtf32String
	"Answer an instance of the UTF-32 encoded String class"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^Utf32String fromUtf8Bytes: self asUtf8Bytes.! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 6/24/2022 10:51:01' prior: 50380562 overrides: 16934001!
                               = aString
	"Answer whether the receiver sorts equally as anUtf32String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Expensive. Assume it is extremely unlikely."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	aString isUtf32String ifFalse: [
		^self asUtf8String = aString ].

	^ codePoints = aString words! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 6/24/2022 10:51:05' prior: 50380768!
                      sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	self = aString ifTrue: [ ^true ].
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase = aString asLowercase! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/24/2022 10:51:11' prior: 50387345!
                     findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	caseSensitive ifTrue: [
		^self findString: key startingAt: start ].

	self isAscii ifTrue: [
		key isAscii
			ifTrue: [ "Fast lane"
				^'' findStringIgnoreCase: key in: bytes startingAt: start ]
			ifFalse: [ "Won't be found"
				^0 ]].

"caseSensitive = false is very expensive. Do better."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase findString: key asLowercase startingAt: start! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:30' prior: 50377647 overrides: 16922588!
        next: n
	"Return a string with the next n characters of the filestream in it.  1/31/96 sw"
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	^ self nextInto: (ByteArray new: n)! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:34' prior: 50377657 overrides: 50365262!
       next: n into: aBytesOrWordsObject startingAt: startIndex
	"Read n bytes or words into the given aBytesOrWordsObject.
	Return aBytesOrWordsObject or a partial copy if less than
	n elements have been read."
	
	| count  newN newStartIndex |
true ifTrue: [
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt. "ojo"
"si se que son bytes quizas preferir
nextBytes: n into: aBytesOrWordsObject startingAt: startIndex
"
].
	collection 
		ifNil: [ 
			newN := n.
			newStartIndex := startIndex ]
		ifNotNil: [
			aBytesOrWordsObject class isBytes 
				ifFalse: [ 
					position < readLimit ifTrue: [ self flushReadBuffer ].
					newN := n.
					newStartIndex := startIndex ]
				ifTrue: [
					| available |
					(available := readLimit - position) > 0 
						ifFalse: [ available := 0 ]
						ifTrue: [
							| bufferedCount |
							bufferedCount := n min: available.
							aBytesOrWordsObject
								replaceFrom: startIndex
								to: startIndex + bufferedCount - 1
								with: collection
								startingAt: position + 1.
							position := position + bufferedCount.
							bufferedCount = n ifTrue: [ ^aBytesOrWordsObject ] ].
					newN := n - available.
					newStartIndex := startIndex + available ] ].
	count := self primRead: fileID into: aBytesOrWordsObject
				startingAt: newStartIndex count: newN.
	count = newN
		ifTrue:[ ^aBytesOrWordsObject ]
		ifFalse:[ ^aBytesOrWordsObject copyFrom: 1 to: newStartIndex + count - 1 ]! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:38' prior: 50377706 overrides: 16982981!
  next: anInteger putAll: aString startingAt: startIndex
	"Store the next anInteger elements from the given collection."
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [
		position < readLimit ifTrue: [ self flushReadBuffer ] ].	
	self primWrite: fileID from: aString startingAt: startIndex count: anInteger.
	lastWrittenElement _ aString at: anInteger.
	^aString! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:42' prior: 50377835 overrides: 50365271!
                    nextWordsInto: aBitmap
	"Note: The file primitives automatically adjust for word based objects."

self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	self next: aBitmap basicSize into: aBitmap startingAt: 1.
	aBitmap restoreEndianness.
	^ aBitmap! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:45' prior: 50377847 overrides: 16983319!
   padToEndIfCantTruncate
	"Only makes sense for file streams with existing content.
	On file systems that don't support truncating this is needed.
	If truncating is supported, try that first"

	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."

	| pad |
	self atEnd ifTrue: [^ self].
	self truncate.
	self atEnd ifTrue: [^ self].
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	pad := Character space numericValue.
	self nextPutAll: (ByteArray new: ((self size - self position) min: 20000) 
							withAll: pad)! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:48' prior: 50377942!
    readInto: byteArray startingAt: startIndex count: count
	"Read into the given array as specified, and return the count
	actually transferred.  index and count are in units of bytes or
	longs depending on whether the array is Bitmap, String or ByteArray"

self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	^(self next: count into: byteArray startingAt: startIndex) size - startIndex + 1
! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:51' prior: 50378028 overrides: 50365284!
                     upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"See comment at PositionableStream.
	Fast version to speed up nextChunk"

	| pos buffer count skipSeparator tryAgain |

self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	skipSeparator _ delimiterIsTerminator ifTrue: [0] ifFalse: [1].
	collection ifNotNil: [
		(position < readLimit and: [
			(pos _ collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [
				pos > 0 ] ]) ifTrue: [
					^ collection copyFrom: position + 1 to: (position _ pos) - skipSeparator ] ].

	pos _ self position.
	buffer _ self next: 2000.
	(count _ buffer indexOf: delimiter) > 0 ifTrue: [
		"Found the delimiter part way into buffer"
		self position: pos + count.
		^ buffer copyFrom: 1 to: count - skipSeparator].

	self atEnd ifTrue: [
		"Never found it, and hit end of file"
		^ delimiterIsTerminator ifTrue: [self position: pos. nil] ifFalse: [buffer]].

	"Never found it, but there's more..."
	tryAgain _ self upTo: delimiter delimiterIsTerminator: delimiterIsTerminator.
	tryAgain ifNil: [
		self position: pos.
		^ nil ].
	^ buffer, tryAgain.! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:54' prior: 50378067 overrides: 16983291!
   withAttribute: aTextAttribute do: streamBlock
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:52:57' prior: 50378074 overrides: 16983302!
                         withAttributes: attributes do: streamBlock 
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.! !
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 6/24/2022 10:52:26' prior: 50378463!
                fileDoesNotExistUserHandling: fullFileName

	| selection newName |
	selection _ (PopUpMenu labels:
'create a new file
choose another name
cancel')
			startUpWithCaption: fullFileName asFileEntry name, '
does not exist.'.
	selection = 1 ifTrue:
		[^ self new open: fullFileName forWrite: true].
	selection = 2 ifTrue:
		[ newName _ self request: 'Enter a new file name'
						initialAnswer:  fullFileName.
		^ FileIOAccessor default privateWriteableFile: newName asFileEntry ].
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
	self halt! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:53:02' prior: 50380339 overrides: 16982981!
 next: anInteger putAll: aString startingAt: startIndex
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	lastWrittenElement _ aString at: anInteger.
	"?
	numberOfCodePointsWritten ifNotNil: [
		numberOfCodePointsWritten _ numberOfCodePointsWritten + aString size ]]"! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:53:25' prior: 50377310 overrides: 50364304!
    skip
	"Skips one object in the receiver's future sequence values."
"
	self next
"
"Should we actually implement this???"
self flag: #unicodeNeedsImprovement.
self error: 'hacerlo?' print.
thisContext printStack: 10.! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:53:38' prior: 50377319 overrides: 50368843!
    skip: n
	"Skips one object in the receiver's future sequence values."
"
	self next
"
self flag: #unicodeNeedsImprovement.
"Should we actually implement this???"
self error: 'hacerlo?' print.
thisContext printStack: 10.! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:53:53' prior: 50377328 overrides: 50364310!
 skipBack
	"Skips one object in the receiver's future sequence values."
"
	self next
"
self flag: #unicodeNeedsImprovement.
"Should we actually implement this???"
self error: 'hacerlo?' print.
thisContext printStack: 10.! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:53:57' prior: 50377337 overrides: 16983291!
withAttribute: aTextAttribute do: streamBlock
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 10:54:00' prior: 50377344 overrides: 16983302!
                withAttributes: attributes do: streamBlock 
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5312-codeFlags-comments-JuanVuletich-2022Jun24-10h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5311] on 24 June 2022 at 11:11:11 am'!
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 11:10:04'!
                      findString: string
	"Fast version of #upToAll: to find a String in a file starting from the beginning.
	Returns the position and also sets the position there.
	If string is not found 0 is returned and position is unchanged."
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 11:10:13'!
          findStringFromEnd: string
	"Fast version to find a String in a file starting from the end.
	Returns the position and also sets the position there.
	If string is not found 0 is returned and position is unchanged."
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.! !
!UniFileStream methodsFor: 'testing' stamp: 'jmv 6/24/2022 11:05:09'!
    isDirectory
	^false! !
!UniFileStream methodsFor: 'reading modes' stamp: 'jmv 6/24/2022 11:04:34' overrides: 16914207!
         isBinary
	^ readAdaptor class == BytesReadAdaptor! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5313-MoreOfThat-JuanVuletich-2022Jun24-10h56m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5313] on 24 June 2022 at 12:02:06 pm'!
!UniFileStream methodsFor: 'private' stamp: 'jmv 6/24/2022 11:24:06'!
    nextBytes: n
	"Read n bytes, or until the end of the file."

	| bytes s |
	s _ n min: self size.
	bytes _ ByteArray new: s.
	^ self nextBytes: s into: bytes startingAt: 1.! !
!UniStreamReadAdaptor methodsFor: 'reading' stamp: 'jmv 6/24/2022 11:21:14'!
    next: n
	"Read n elements, or until the end of the file."

	self subclassResponsibility! !
!ByteStringReadAdaptor methodsFor: 'reading' stamp: 'jmv 6/24/2022 11:32:23' overrides: 50389854!
   next: n
	"Read n bytes, or until the end of the file.
	Answer them as seen from our perspective:
	Stream bytes as Cuis / ISO 8859-15 Characters.
	Disregard the fact that stream contents are most likely UTF-8.
	This is valid only if contents are ASCII, or Cuis / ISO-8859-15 byte Characters.
	Answer is a String (i.e. a byte oriented ISO 8859-15 String)"

	^(stream nextBytes: n) asString! !
!BytesReadAdaptor methodsFor: 'reading' stamp: 'jmv 6/24/2022 11:27:57' overrides: 50389854!
                            next: n
	"Read n bytes, or until the end of the file.
	Answer them as a ByteArray."

	^stream nextBytes: n! !
!Utf32ReadAdaptor methodsFor: 'reading' stamp: 'jmv 6/24/2022 11:33:16' overrides: 50389854!
                     next: n
	"Read n UnicodeCodePoints, or until the end of the file.
	Answer them, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Answer is an instance of Utf32String."

	| utf32 codePointCount |
	codePointCount _ 0.
	utf32 _ WordArray streamContents: [ :utf32Stream |
		[ codePointCount = n or: [stream atEnd] ] whileFalse: [
			stream nextUtf8BytesAndCodePointInto: nil into: [ :codePoint |
				utf32Stream nextPut: codePoint.
				codePointCount _ codePointCount + 1 ]]].
	^Utf32String withWords: utf32! !
!Utf8ReadAdaptor methodsFor: 'reading' stamp: 'jmv 6/24/2022 11:56:07' overrides: 50389854!
            next: n
	"Read n UnicodeCodePoints, or until the end of the file.
	Answer them, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Answer is an instance of Utf8String."

	| utf8 codePointCount |
	codePointCount _ 0.
	utf8 _ ByteArray streamContents: [ :utf8Stream |
		[ codePointCount = n or: [stream atEnd] ] whileFalse: [
			stream
				nextUtf8BytesAndCodePointInto: [ :byte1 :byte2 :byte3 :byte4 |
					utf8Stream nextPut: byte1.
					byte2 ifNotNil: [
						utf8Stream nextPut: byte2.
						byte3 ifNotNil: [
							utf8Stream nextPut: byte3.
							byte4 ifNotNil: [
								utf8Stream nextPut: byte4 ]]].
					codePointCount _ codePointCount + 1]
				into: nil ]].
	^Utf8String fromUtf8Bytes: utf8 codePointCount: codePointCount.! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 6/24/2022 11:35:30' prior: 50389517 overrides: 16922588!
          next: n
	"Answer the next n charaters (or bytes) from this file, or nil if at the end of the file.
	Answer will be
	- an Utf8String, Utf32String or String or size n (or until the end of the file if shorter)
	- a ByteArray of size n (or until the end of the file if shorter)"

	^readAdaptor next: n! !
!Utf8ReadAdaptor methodsFor: 'reading' stamp: 'jmv 6/24/2022 11:56:17' prior: 50380005 overrides: 50376804!
       streamUpToEnd
	"Answer the contents of our stream, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Leave stream at the end position."

	| utf8 codePointCount |
	codePointCount _ 0.
	utf8 _ ByteArray streamContents: [ :utf8Stream |
		[ stream atEnd ] whileFalse: [
			stream
				nextUtf8BytesAndCodePointInto: [ :byte1 :byte2 :byte3 :byte4 |
					utf8Stream nextPut: byte1.
					byte2 ifNotNil: [
						utf8Stream nextPut: byte2.
						byte3 ifNotNil: [
							utf8Stream nextPut: byte3.
							byte4 ifNotNil: [
								utf8Stream nextPut: byte4]]].
					codePointCount _ codePointCount + 1]
				into: nil ]].
	^Utf8String fromUtf8Bytes: utf8 codePointCount: codePointCount.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5314-UniFileStream-nextColon-JuanVuletich-2022Jun24-11h59m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5311] on 24 June 2022 at 11:48:18 am'!
!FileList methodsFor: 'own services' stamp: 'jmv 6/24/2022 11:36:43' prior: 16855450!
                        viewContentsInWorkspace
	"View the contents of my selected file in a new workspace"

	| aString aName |
	directory // fileName readStreamDo: [ :stream |
		stream ifNil: [^ 'For some reason, this file cannot be read'].
		aString _ stream upToEnd.
		aName _ stream localName ].

	(Workspace new contents: aString) openLabel: 'Workspace from ', aName! !
!FileList methodsFor: 'private' stamp: 'jmv 6/24/2022 11:43:58' prior: 16855723!
                readContentsBrief: brevityFlag
	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first part characters. Don't create a file if it doesn't already exist."
	| fileSize firstPart firstPartSize |
firstPartSize _ 1e6.
directory // fileName readStreamDo: [ :f |
	f ifNil: [^ 'For some reason, this file cannot be read' halt].
	(brevityFlag not or: [(fileSize _ f size) <= (10*firstPartSize) ]) ifTrue: [
		acceptedContentsCache _ f contentsOfEntireFile.
		brevityState _ #fullFile.   "don't change till actually read"
		^ acceptedContentsCache ].

	"if brevityFlag is true, don't display long files when first selected"
	firstPart := f next: 1e6.
].
	acceptedContentsCache _
'File ''{1}'' is {2} characters long.
You may use the ''get'' command to read the entire file.

Here are the first {3} characters...
------------------------------------------
{4}
------------------------------------------
... end of the first {3} characters.' format: {fileName. fileSize. firstPartSize. firstPart}.
	brevityState := #briefFile.   "don't change till actually read"
	^ acceptedContentsCache! !
!FileList methodsFor: 'private' stamp: 'jmv 6/24/2022 11:46:02' prior: 16855759!
  readContentsHex: brevity
	"retrieve the contents from the external file unless it is too long.
	  Don't create a file here.  Check if exists."
	| size data hexData firstPartSize |
	firstPartSize _ 1e6.
	directory // fileName readStreamDo: [ :stream |
		stream ifNil: [^ 'For some reason, this file cannot be read'].
		((size _ stream size)) > (10*firstPartSize) & brevity
			ifTrue: [ data _ stream next: firstPartSize. brevityState := #briefHex ]
			ifFalse: [ data _ stream next: size. brevityState := #fullHex ]].

	hexData _ String streamContents: [ :s |
		0 to: data size-1 by: 16 do: [ :loc |
			loc printOn: s base: 16 length: 8 padded: true.
			s
				space;
				nextPut: $(.
			loc printOn: s base: 10 length: 10 padded: true.
			s
				nextPut: $);
				space;
				tab.
			loc+1 to: (loc+16 min: data size) do: [ :i | s nextPutAll: (data at: i) hex; space ].
			s newLine ]].

	^ acceptedContentsCache _ ((size > (10*firstPartSize)) & brevity
		ifTrue: ['File ''{1}'' is {2} bytes long.
You may use the ''get'' command to read the entire file.

Here are the first {3} characters...
------------------------------------------
{4}
------------------------------------------
... end of the first {3} characters.' format: {fileName. size. firstPartSize. hexData}]
		ifFalse: [hexData])! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5315-FileListTweaks-JuanVuletich-2022Jun24-11h36m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5315] on 24 June 2022 at 5:29:36 pm'!

Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value '
	classVariableNames: 'BinarySelectorsTable LowercaseLettersTable UppercaseLettersTable '
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #UnicodeCodePoint category: #'Kernel-Text' stamp: 'Install-5316-UnicodeCodePoints-tablesForUppercase-Lowercase-BinarySelectors-JuanVuletich-2022Jun24-17h26m-jmv.001.cs.st 7/5/2022 10:30:10'!
Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: 'BinarySelectorsTable LowercaseLettersTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!
!UnicodeCodePoint class methodsFor: 'class initialization' stamp: 'jmv 6/24/2022 15:43:16' overrides: 16904184!
                     initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	UnicodeCodePoint initialize
	"

	| fields codePoint codePointName generalCategory |
	UppercaseLettersTable _ ByteArray newBits: 16r10FFFF.
	LowercaseLettersTable _ ByteArray newBits: 16r10FFFF.
	BinarySelectorsTable _ ByteArray newBits: 16r10FFFF.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields _ strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self halt ].
			codePoint _ ('16r', fields first) asNumber.
			codePointName _ fields at: 2.
			generalCategory _ fields at: 3.
			(Character codePoint: codePoint)
				ifNotNil: [ :char |	"Char definition trumps Unicode definition"
					char isUppercase ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
					char isLowercase ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
					char isValidInBinarySelectors ifTrue: [ BinarySelectorsTable bitBooleanAt: codePoint+1 put: true ].
					]
				ifNil: [
					generalCategory = 'Lu' ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
					generalCategory = 'Ll' ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
					({ 'Po'. 'Sm'. 'Sc'. 'So' } includes: generalCategory) ifTrue: [ BinarySelectorsTable bitBooleanAt: codePoint+1 put: true ]].
			"
			cannonicalCombiningClasses _ fields at: 4.
			characterDecompositionMapping _ fields at: 6.
			uppercaseMapping _ fields at: 13. lowercaseMapping _ fields at: 14. titlecaseMapping _ fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue _ fields at: 7. digitValue _ fields at: 8. numericValue _ fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 6/24/2022 13:57:36'!
            substringsSeparatedBy: delimiterCharacter
	"Find substrings delimited by aCharacter.
	Answer may include empty strings
	'0063;LATIN SMALL LETTER C;Ll;0;L;;;;;N;;;0043;;0043' substringsSeparatedBy: $;
	"

	| char in out |
	^Array streamContents: [ :answer |
		in _ self readStream.
		out _ self species writeStream.
		[ in atEnd ] whileFalse: [
			char _ in next.
			char = delimiterCharacter
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					answer nextPut: out contents.
					out _ self species writeStream ]].
		answer nextPut: out contents.
		out _ nil ]! !
!Character methodsFor: 'testing' stamp: 'jmv 6/24/2022 15:16:31' prior: 16808241!
                         isValidInBinarySelectors
	"Can be part of a binary selector?
		$< isValidInBinarySelectors
		$| isValidInBinarySelectors
		$^ isValidInBinarySelectors
		$: isValidInBinarySelectors
	"
	| v |
	v _ self numericValue.
	v = 0 ifTrue: [ ^false ].
	^#(verticalBar upArrow xColon xBinary) statePointsTo: (Scanner typeTable at: v)! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/24/2022 15:26:02' prior: 50361022!
 isLetter
	"Answer whether the receiver is a letter."
	"
	(UnicodeCodePoint codePoint: 16r22C7) isLetter
	(UnicodeCodePoint codePoint: 16r042F) isLetter
	(UnicodeCodePoint codePoint: 16r0431) isLetter
	"
	^self isLowercase or: [ self isUppercase ]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/24/2022 15:25:44' prior: 50382947!
             isLowercase
	"Answer whether the receiver is a letter."
	"
	(UnicodeCodePoint codePoint: 16r22C7) isLowercase
	(UnicodeCodePoint codePoint: 16r042F) isLowercase
	(UnicodeCodePoint codePoint: 16r0431) isLowercase
	"
	self asCharacter ifNotNil: [ :ch | ^ch isLowercase ].
	^LowercaseLettersTable bitBooleanAt: value + 1! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/24/2022 15:25:29' prior: 50375327!
      isUppercase
	"Answer whether the receiver is an uppercase letter."
	"
	(UnicodeCodePoint codePoint: 16r22C7) isUppercase
	(UnicodeCodePoint codePoint: 16r042F) isUppercase
	(UnicodeCodePoint codePoint: 16r0431) isUppercase
	"
	self asCharacter ifNotNil: [ :ch | ^ch isUppercase ].
	^UppercaseLettersTable bitBooleanAt: value + 1! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/24/2022 15:25:09' prior: 50363843!
                           isValidInBinarySelectors
	"
	(UnicodeCodePoint codePoint: 16r22C7) isValidInBinarySelectors
	(UnicodeCodePoint codePoint: 16r042F) isValidInBinarySelectors
	(UnicodeCodePoint codePoint: 16r0431) isValidInBinarySelectors
	"
	(Character codePoint: value) ifNotNil: [ :ch | ^ch isValidInBinarySelectors ].
	^BinarySelectorsTable bitBooleanAt: value + 1! !

Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: 'BinarySelectorsTable LowercaseLettersTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #UnicodeCodePoint category: #'Kernel-Text' stamp: 'Install-5316-UnicodeCodePoints-tablesForUppercase-Lowercase-BinarySelectors-JuanVuletich-2022Jun24-17h26m-jmv.001.cs.st 7/5/2022 10:30:10'!
Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: 'BinarySelectorsTable LowercaseLettersTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

UnicodeCodePoint initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5316-UnicodeCodePoints-tablesForUppercase-Lowercase-BinarySelectors-JuanVuletich-2022Jun24-17h26m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5316] on 24 June 2022 at 5:34:16 pm'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 6/24/2022 17:33:30' prior: 50363663!
      typeTableAt: aCharacterOrCodePoint
	aCharacterOrCodePoint iso8859s15Code ifNotNil: [ :i |
		i <= typeTable size ifTrue: [
			^typeTable at: i ]].
	"For CodePoints not in the ISO 8859-15 set (i.e. not a possible instance of Character)"
	aCharacterOrCodePoint isLetter ifTrue: [ ^#xLetter ].
	aCharacterOrCodePoint isValidInBinarySelectors ifTrue: [ ^#xBinary ].
	^#xLetter! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5317-Scanner-AcceptUnicodeSmalltalkCode-JuanVuletich-2022Jun24-17h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5316] on 24 June 2022 at 5:37:58 pm'!
!Utf8Symbol methodsFor: 'system primitives' stamp: 'di 1/2/1999 17:00'!
         flushCache
	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.
	NOTE:  Only one of the two selective flush methods needs to be used.
	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."

	<primitive: 119>
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5318-Utf8Symbol-flushCache-JuanVuletich-2022Jun24-17h35m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5318] on 24 June 2022 at 6:54:35 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 6/24/2022 18:52:50' prior: 16874344!
                        tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks

For Pre-Squeak systems, measurements or estimations from
	https://smalltalkzoo.computerhistory.org/papers/EvolutionOfSmalltalk.pdf
										('The evolution of Smalltalk: from Smalltalk-72 through Squeak' by Dan Ingalls, p.98)
	http://wiki.c2.com/?GreenBook
	http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1982-qtr4-magnolia-perf-graph.pdf
	http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1983-Magnolia-st-perf.pdf

Xerox PARC systems
	Alto Smalltalk-72 5MHz µcode								694 bytecodes/sec						54 sends/sec					7200 µclocks/bytecode
	Alto Smalltalk-74 5MHz µcode								607 bytecodes/sec						46 sends/sec					8200 µclocks/bytecode
	Alto Smalltalk-76 5MHz µcode								16k bytecodes/sec						118 sends/sec					310 µclocks/bytecode
	NoteTaker Smalltalk-78 5MHz 8086								30k bytecodes/sec						250 sends/sec					166.67 clocks/bytecode
	Dorado Smalltalk-76 16.67MHz µcode								1M bytecodes/sec						50k sends/sec					16.67 µClocks/bytecode

Green Book systems
	DEC PDP-11/23								5k bytecodes/sec (Green Book, p.128)
	Apple 5MHz 68000								11k bytecodes/sec (Green Book, p.187, awb)											5000 clocks/bytecode
	VAX-11/780 5MHz C HP Smalltalk								10k bytecodes/sec (Green Book, p.235)											450 clocks/bytecode
	VAX-11/780 5MHz C Berkeley St								17k bytecodes/sec (Green Book, p.203, awb)											300 clocks/bytecode
	DEC VAX-11/780 5MHz assembly								20k bytecodes/sec (Green Book, p.149, awb)											250 clocks/bytecode
	TEK Magnolia 10MHz 68000								50k bytecodes/sec (awb)											200 clocks/bytecode

Squeak & Cuis
	110 MHz PowerPC Mac 8100								4.1M bytecodes/sec;						175k sends/sec					26.8 clocks/bytecode 
	292 MHz G3 Mac:								23M bytecodes/sec;						984k sends/sec					12.7 clocks/bytecode
	400 MHz PII/Win98:								18M bytecodes/sec;						1.08M sends/sec					22.2 clocks/bytecode

	1GHz RISCV Sipeed Lichee RV StackSpur64 35.56M bytecodes/sec;  														1.56M sends/sec  					28.1 clocks/bytecode

	900MHz RasPi2 - StackVM:								38M bytecodes/sec;						2.41M sends/sec					23.7 clocks/bytecode
	900MHz RasPi2- CogSSpur:								157M bytecodes/sec;						10.95M sends/sec					5.7 clocks/bytecode
	
	1GHz C.H.I.P. (*1) - StackVM:								55M bytecodes/sec;						3.35M sends/sec					18.2 clocks/bytecode
	1GHz C.H.I.P. (*1) - CogSpur:								254M bytecodes/sec;						16.85M sends/sec					3.9 clocks/bytecode
	
	1.2GHz RasPi3B - StackSpur:								44M bytecodes/sec;						2.77M sends/sec					27.2 clocks/bytecode
	1.2GHz RasPi3B - CogSpur:								282M bytecodes/sec;						16.40M sends/sec					4.3 clocks/bytecode

	1.66GHz Atom N450 - Cog:								244M bytecodes/sec;						28.80M sends/sec					6.8 clocks/bytecode
	1.66GHz Atom N450 - CogSpur:								470M bytecodes/sec;						30.75M sends/sec					3.5 clocks/bytecode

	1.33GHz Atom 3735G - Cog:								326M bytecodes/sec;						34.99M sends/sec					4.1 clocks/bytecode
	1.33GHz Atom 3735G - CogSpur:								632M bytecodes/sec;						33.69M sends/sec					2.1 clocks/bytecode

	1.5GHz AMD A4-5000 - Cog:								390M bytecodes/sec;						47.51M sends/sec					3.8 clocks/bytecode
	1.5GHz AMD A4-5000 - CogSpur:								676M bytecodes/sec;						40.67M sends/sec					2.2 clocks/bytecode
	1.5GHz AMD A4-5000 - CogSpur64:								659M bytecodes/sec;						50.34M sends/sec					2.3 clocks/bytecode

	1.5GHz ARM64 RasberryPi4 - CogSpur64: 732.5M bytecodes/sec;  														53.95M sends/sec					2.0 clocks/bytecode

	2.3GHz Tegra ARM64 (*2) - StackVM:								259M bytecodes/sec;						13.01M sends/sec					8.9 clocks/bytecode
	2.3GHz Tegra ARM64(*2) - CogSpur:								1.08G bytecodes/sec;						64.29M sends/sec					2.1 clocks/bytecode

	3.1GHz Core i3-2100 - Cog:								1.20G bytecodes/sec;						165.72M sends/sec					2.6 clocks/bytecode
	3.1GHz Core i3-2100 - CogSpur:								2.04G bytecodes/sec;						127.84M sends/sec					1.5 clocks/bytecode

	2.70GHz Core i5-6400 -CogSpur64								3.16G bytecodes/sec;						243.32M sends/sec					0.85 clocks/bytecode

	(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
	(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
	
It is interesting to note that Cog for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance,
i.e. around 100 Dorados.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue: [n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue: [n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^String streamContents: [ :strm |
		(n1 * 500000 * 1000) // t1 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Bytecodes/second; ' ].
		(r * 1000) // t2 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Sends/second' ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5319-tinyBenchmarks-update-JuanVuletich-2022Jun24-17h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5319] on 25 June 2022 at 4:57:45 pm'!
!ByteArray methodsFor: 'accessing' stamp: 'jmv 6/25/2022 16:53:20'!
                             bitSize
	"Note:
	(ByteArray newBits: 9) bitSize = 16 
	"
	^self size * 8! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/25/2022 16:54:29' prior: 50390220!
                           isLowercase
	"Answer whether the receiver is a letter."
	"
	(UnicodeCodePoint codePoint: 16r22C7) isLowercase
	(UnicodeCodePoint codePoint: 16r042F) isLowercase
	(UnicodeCodePoint codePoint: 16r0431) isLowercase
	"
	| i |
	self asCharacter ifNotNil: [ :ch | ^ch isLowercase ].
	i _ value + 1.
	LowercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^LowercaseLettersTable bitBooleanAt: i.! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/25/2022 16:54:09' prior: 50390233!
                               isUppercase
	"Answer whether the receiver is an uppercase letter."
	"
	(UnicodeCodePoint codePoint: 16r22C7) isUppercase
	(UnicodeCodePoint codePoint: 16r042F) isUppercase
	(UnicodeCodePoint codePoint: 16r0431) isUppercase
	"
	| i |
	self asCharacter ifNotNil: [ :ch | ^ch isUppercase ].
	i _ value + 1.
	UppercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^UppercaseLettersTable bitBooleanAt: i.! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 6/25/2022 16:54:52' prior: 50390247!
                    isValidInBinarySelectors
	"
	(UnicodeCodePoint codePoint: 16r22C7) isValidInBinarySelectors
	(UnicodeCodePoint codePoint: 16r042F) isValidInBinarySelectors
	(UnicodeCodePoint codePoint: 16r0431) isValidInBinarySelectors
	"
	| i |
	(Character codePoint: value) ifNotNil: [ :ch | ^ch isValidInBinarySelectors ].
	i _ value + 1.
	BinarySelectorsTable bitSize < i ifTrue: [ ^false ].
	^BinarySelectorsTable bitBooleanAt: i.! !
!UnicodeCodePoint class methodsFor: 'class initialization' stamp: 'jmv 6/25/2022 16:57:06' prior: 50390106 overrides: 16904184!
                         initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	UnicodeCodePoint initialize
	"

	| fields codePoint codePointName generalCategory |
	UppercaseLettersTable _ ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable _ ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	BinarySelectorsTable _ ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields _ strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self halt ].
			codePoint _ ('16r', fields first) asNumber.
			codePointName _ fields at: 2.
			generalCategory _ fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				(Character codePoint: codePoint)
					ifNotNil: [ :char |	"Char definition trumps Unicode definition"
						char isUppercase ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
						char isLowercase ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
						char isValidInBinarySelectors ifTrue: [ BinarySelectorsTable bitBooleanAt: codePoint+1 put: true ].
						]
					ifNil: [
						generalCategory = 'Lu' ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
						generalCategory = 'Ll' ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
						({ 'Po'. 'Sm'. 'Sc'. 'So' } includes: generalCategory) ifTrue: [ BinarySelectorsTable bitBooleanAt: codePoint+1 put: true ]]].
			"
			cannonicalCombiningClasses _ fields at: 4.
			characterDecompositionMapping _ fields at: 6.
			uppercaseMapping _ fields at: 13. lowercaseMapping _ fields at: 14. titlecaseMapping _ fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue _ fields at: 7. digitValue _ fields at: 8. numericValue _ fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].! !

UnicodeCodePoint initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5320-UnicodeTables-useLessMemory-JuanVuletich-2022Jun25-16h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5320] on 26 June 2022 at 3:25:27 pm'!
!String class methodsFor: 'services' stamp: 'jmv 6/26/2022 15:06:47'!
                            compare: string1 with: string2
	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."

	^self compare: string1 with: string2 collated: CaseSensitiveOrder! !
!String class methodsFor: 'services' stamp: 'ar 2/3/2001 16:12'!
 compare: string1 with: string2 collated: order
	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."

	| len1 len2 c1 c2 |
	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>
	self var: #string1 declareC: 'unsigned char *string1'.
	self var: #string2 declareC: 'unsigned char *string2'.
	self var: #order declareC: 'unsigned char *order'.

	len1 _ string1 size.
	len2 _ string2 size.
	1 to: (len1 min: len2) do:
		[:i |
		c1 _ order at: (string1 basicAt: i) + 1.
		c2 _ order at: (string2 basicAt: i) + 1.
		c1 = c2 ifFalse: 
			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].
	len1 = len2 ifTrue: [^ 2].
	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].
! !
!String class methodsFor: 'services' stamp: 'jmv 6/26/2022 15:16:59'!
  findStringIgnoreCase: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0.
	Ignore case"

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseInsensitiveOrder.! !
!String class methodsFor: 'services' stamp: 'jmv 6/26/2022 15:09:23'!
               findSubstring: key in: body startingAt: start matchTable: matchTable
	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."
	| index |
	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>
	self var: #key declareC: 'unsigned char *key'.
	self var: #body declareC: 'unsigned char *body'.
	self var: #matchTable declareC: 'unsigned char *matchTable'.

	key isEmpty ifTrue: [^ 0].
	start to: body size - key size + 1 do:
		[:startIndex |
		index _ 1.
			[(matchTable at: (body at: startIndex+index-1) numericValue + 1)
				= (matchTable at: (key at: index) numericValue + 1)]
				whileTrue:
				[index = key size ifTrue: [^ startIndex].
				index _ index+1]].
	^ 0
"
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0
String findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0
String findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7
"! !
!String class methodsFor: 'services' stamp: 'jmv 6/26/2022 15:05:49'!
       is: aStringOrByteArray equalTo: another
	"Take adventage of String primitive for comparing, for example, ByteArrays"

	^ (self compare: aStringOrByteArray with: another collated: CaseSensitiveOrder) = 2! !
!String class methodsFor: 'services' stamp: 'jmv 6/26/2022 15:00:28'!
            string: aString lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| start end endWithoutDelimiters |
	start _ 1.
	[
		end _ aString indexOfAnyOf: CSLineEnders startingAt: start ifAbsent: [ 0 ].
		end = 0
			ifTrue: [
				"Last line was found. Evaluate and exit.
				Note. If last char in receiver is a line separator, there's an extra empty line"
				endWithoutDelimiters _ end _ aString size.
				aBlock value: start value: endWithoutDelimiters value: end.
				^aString ].

		"Account for CrLf sequence"
		endWithoutDelimiters _ end - 1.
		(end < aString size
			and: [(aString basicAt: end + 1) = `Character lf codePoint`
			and: [(aString basicAt: end) = `Character cr codePoint` ]])
				ifTrue: [ end _ end + 1].

		aBlock value: start value: endWithoutDelimiters value: end.
		start _ end + 1 ] repeat! !
!String class methodsFor: 'services' stamp: 'jmv 6/26/2022 14:59:39'!
                    string: aString withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"
	| cr lf crlf inPos outPos outString lineEndPos newOutPos lineEndingSize |
	cr _ Character cr.
	lf _ Character lf.
	crlf _ CharacterSet new.
	crlf add: cr; add: lf.

	inPos _ 1.
	outPos _ 1.
	lineEndingSize _ lineEndingString size.
	"This could be extremely inefficient if lineEndingString size > 1"
	outString _ aString class new: aString size * lineEndingSize.

	[
		lineEndPos _ aString indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].
		lineEndPos ~= 0 ] whileTrue: [
			newOutPos _ outPos + (lineEndPos - inPos).
			outString replaceFrom: outPos to: newOutPos - 1 with: aString startingAt: inPos.
			1 to: lineEndingSize do: [ :i |
				outString at: newOutPos put: (lineEndingString at: i).
				newOutPos _ newOutPos + 1 ].
			outPos _ newOutPos.
			((aString at: lineEndPos) = cr and: [ lineEndPos < aString size and: [ (aString at: lineEndPos+1) = lf ] ]) ifTrue: [
				"CRLF ending"
				inPos _ lineEndPos + 2 ]
			ifFalse: [ 
				"CR or LF ending"
				inPos _ lineEndPos + 1 ]. ].

	"no more line endings.  copy the rest"
	newOutPos _ outPos + (aString size - inPos).
	outString replaceFrom: outPos to: newOutPos with: aString startingAt: inPos.

	^outString copyFrom: 1 to: newOutPos! !
!String class methodsFor: 'services' stamp: 'jmv 6/26/2022 14:57:27'!
              substringsIn: aByteStringOrByteArray
	"Answer an array of the substrings that compose the argument.
	If argument is an UTF-8 encoded ByteArray, answer is an array of same."

	| end beginning |
	end _ 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning _ aByteStringOrByteArray indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end _ aByteStringOrByteArray indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ aByteStringOrByteArray size + 1 ].
			end _ end - 1.
			result nextPut: (aByteStringOrByteArray copyFrom: beginning to: end).
		]
	].! !
!String class methodsFor: 'accessing' stamp: 'di 11/15/1998 16:43'!
    findString: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseSensitiveOrder.! !
!String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:11:24' prior: 50381657!
                             findString: subString startingAt: start 
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	subString isByteString ifFalse: [
		(subString isUtf8String and: [subString isAscii])  "Use cheapest tests and conversion possible."
			ifTrue: [ ^self findString: subString asByteString startingAt: start  ].
		^self asUtf8String findString: subString startingAt: start ].
	^ String findString: subString in: self startingAt: start! !
!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:45' prior: 16947233!
                       findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	^caseSensitive
		ifTrue: [String findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]
		ifFalse: [String findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]! !
!String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:11:44' prior: 50381688 overrides: 16933739!
              indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isByteString ifFalse: [
		(subString isUtf8String and: [subString isAscii])  "Use cheapest tests and conversion possible."
			ifTrue: [ ^self indexOfSubCollection: subString asByteString
						startingAt: start ifAbsent: exceptionBlock ].
		^self asUtf8String indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index _ String findString: subString in: self startingAt: start.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:00:38' prior: 50376511!
 lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"

	String string: self lineIndicesDo: aBlock! !
!String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:02:08' prior: 50380508!
                     < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString > self ].

	^ (String compare: self with: aString collated: CaseSensitiveOrder) = 1! !
!String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:02:12' prior: 50380521!
        <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString >= self ].

	^ (String compare: self with: aString collated: CaseSensitiveOrder) <= 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:02:17' prior: 50375003 overrides: 16934001!
      = aString
	"Answer whether the receiver sorts equally as aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String or Symbol, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Let them handle us"
	aString isByteString ifFalse: [
		^aString = self ].

	^ (String compare: self with: aString collated: CaseSensitiveOrder) = 2.! !
!String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:02:22' prior: 50380535!
                    > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString < self ].

	^ (String compare: self with: aString collated: CaseSensitiveOrder) = 3! !
!String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:02:26' prior: 50380548!
         >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString <= self ].

	^ (String compare: self with: aString collated: CaseSensitiveOrder) >= 2! !
!String methodsFor: 'comparing' stamp: 'sw 4/19/1999 12:11' prior: 16947588!
                               caseInsensitiveLessOrEqual: aString 
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case insensitive."

	^ (String compare: self with: aString collated: CaseInsensitiveOrder) <= 2! !
!String methodsFor: 'comparing' stamp: 'di 2/27/98 12:41' prior: 16947646!
                     compare: aString 
	"Answer a comparison code telling how the receiver sorts relative to aString:
		1 - before
		2 - equal
		3 - after.
	The collation sequence is ascii with case differences ignored.
	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."

	^ String compare: self with: aString collated: CaseInsensitiveOrder! !
!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:42' prior: 16947659!
                        compare: aString caseSensitive: aBool
	"Answer a comparison code telling how the receiver sorts relative to aString:
		1 - before
		2 - equal
		3 - after.
	"
	| map |
	map := aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder].
	^String compare: self with: aString collated: map! !
!String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:11:50' prior: 50381708!
        is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	subString isByteString ifFalse: [
		(subString isUtf8String and: [subString isAscii])  "Use cheapest tests and conversion possible."
			ifTrue: [ ^self is: subString asByteString substringAt: index ].
		^self asUtf8String is: subString substringAt: index ].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	(self basicAt: index) = (subString basicAt: 1) ifFalse: [ ^false ].
	^(String findString: subString in: self startingAt: index) = index! !
!String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:03:56' prior: 50375067!
    sameAs: aString 
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString sameAs: self ].

	^ (String compare: self with: aString collated: CaseInsensitiveOrder) = 2! !
!String methodsFor: 'converting' stamp: 'jmv 6/26/2022 14:57:43' prior: 50375941!
     substrings
	"Answer an array of the substrings that compose the receiver."
	^String substringsIn: self! !
!String methodsFor: 'converting' stamp: 'jmv 6/26/2022 14:59:49' prior: 50376543!
    withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"

	^ String string: self withLineEndings: lineEndingString! !
!String methodsFor: 'system primitives' stamp: 'jmv 6/26/2022 15:18:45' prior: 50378930!
                              numArgs
	"Answer either the number of arguments that the receiver would take if considered a selector. 
	Answer -1 if it couldn't be a selector. 
		Note that currently this will answer -1 for anything begining with an uppercase letter even though 
		the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."
	| firstChar numColons start ix |
	self isEmpty ifTrue: [ ^ -1 ].
	"Binary messages"
	(self allSatisfy: [ :c | c isValidInBinarySelectors ])
		ifTrue: [ ^1 ].
	"Unary and keyword messages"
	firstChar _ self at: 1.
	firstChar isValidStartOfIdentifiers ifTrue: [
		"Fast reject if any chars are non-alphanumeric"
		(String
			findSubstring: '~'
			in: self
			startingAt: 1
			matchTable: Tokenish) > 0 ifTrue: [ ^ -1 ].
		"Fast colon count"
		numColons _ 0.
		start _ 1.
		[ (ix _ self findString: ':' startingAt: start) > 0 ] whileTrue: [
			numColons _ numColons + 1.
			start _ ix + 1 ].
		^ numColons ].
	^ -1.! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:12:03' prior: 50387324!
                   findString: subString startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	| arg startByteIndex byteIndex |
	(self isAscii and: [subString isByteString])
		ifTrue: [ "Fast lane"
			^String findString: subString in: bytes startingAt: start ]
		ifFalse: [
			arg _ subString asUtf8BytesOrByteString.
			"Do UTF-8 encoding as needed."
			startByteIndex _ self byteIndexAt: start.
			byteIndex _ String findString: arg in: bytes startingAt: startByteIndex.
			^self codePointIndexAt: byteIndex].! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:17:16' prior: 50389492!
                            findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	caseSensitive ifTrue: [
		^self findString: key startingAt: start ].

	self isAscii ifTrue: [
		key isAscii
			ifTrue: [ "Fast lane"
				^String findStringIgnoreCase: key in: bytes startingAt: start ]
			ifFalse: [ "Won't be found"
				^0 ]].

"caseSensitive = false is very expensive. Do better."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase findString: key asLowercase startingAt: start! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:12:14' prior: 50387369 overrides: 16933699!
                   indexOf: anUnicodeCodePoint startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	anUnicodeCodePoint isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes _ Character utf8BytesOfUnicodeCodePoint: anUnicodeCodePoint codePoint.
	startByteIndex _ self byteIndexAt: start.
	foundByteIndex _ String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer _ self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:12:22' prior: 50382352 overrides: 16933739!
                    indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock

	| index arg startByteIndex byteIndex |
	arg _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	startByteIndex _ self byteIndexAt: start.
	byteIndex _ String findString: arg in: bytes startingAt: startByteIndex.
	index _ self codePointIndexAt: byteIndex.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:00:45' prior: 50376469!
                        lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"

	String string: bytes lineIndicesDo: [ :startByte :endByteWithoutDelimiters :endByte |
		| start end endWithoutDelimiters |
		start _ self codePointIndexAt: startByte.
		end _ self codePointIndexAt: endByte.
		endWithoutDelimiters _ endByteWithoutDelimiters = endByte
			ifTrue: [end]
			ifFalse: [self codePointIndexAt: endByteWithoutDelimiters].
		aBlock
			value: start
			value: endWithoutDelimiters
			value: end
		]! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:22:12' prior: 50386192!
                      < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 1].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 1]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ (String compare: bytes with: aString asUtf8BytesOrByteString) = 1! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:22:40' prior: 50386219!
    <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) <= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) <= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ (String compare: bytes with: aString asUtf8BytesOrByteString) <= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:06:08' prior: 50386888 overrides: 16934001!
 = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	(self isAscii and: [	aString isByteString ]) ifTrue: [
		"Fast lane."
		^String is: bytes equalTo: aString ].
	
	aString isUtf8String ifTrue: [
		self isAscii = aString isAscii ifFalse: [
			^false ]].

	"May need to do UTF-8 encoding."
	^ bytes = aString asUtf8Bytes.! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:22:50' prior: 50386246!
        > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 3].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 3]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ (String compare: bytes with: aString asUtf8BytesOrByteString) = 3! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:22:56' prior: 50386273!
     >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) >= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) >= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
	^ (String compare: bytes with: aString asUtf8BytesOrByteString) >= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:12:29' prior: 50382370!
                      is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize subStringBytes byteIndex |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	subStringBytes _ subString asUtf8Bytes.
	subStringBytes _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	byteIndex _ self byteIndexAt: index.
	(bytes at: byteIndex) = (subStringBytes byteAt: 1) ifFalse: [ ^false ].
	^(String findString: subStringBytes in: bytes startingAt: byteIndex) = byteIndex! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/26/2022 14:57:58' prior: 50379819!
                       substrings
	"
	'  Hello World!! Some  		1234 more  ' substrings
	'  Hello World!! Some  		1234 more  ' asUtf8String substrings
	"
	^ self isAscii
		ifTrue: [ (String substringsIn: bytes) collect: [ :eachBytes |
				Utf8String fromUtf8Bytes: eachBytes codePointCount: eachBytes size ]]
		ifFalse: [ (String substringsIn: bytes) collect: [ :eachBytes |
				Utf8String fromUtf8Bytes: eachBytes ]].! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 6/26/2022 14:59:55' prior: 50382824!
                            withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"

	| correctedBytes |
	correctedBytes _ String string: bytes withLineEndings: lineEndingString asByteArray.
	"The codePointCount trick can be done because the line endings considered are all single byte UTF-8.
	If we ever consider unicode line endings taking more than one byte, this is no longer valid (pass nil instead)."
	^  Utf8String fromUtf8Bytes: correctedBytes codePointCount: self size - bytes size + correctedBytes size.! !
!ByteArray methodsFor: 'comparing' stamp: 'jmv 6/26/2022 15:06:03' prior: 50382256 overrides: 16934001!
                           = another
	"Make good use of String primitives"

	self == another ifTrue: [ ^ true ].
	self species == another species ifFalse: [^ false].
	^String is: self equalTo: another ! !

String removeSelector: #findSubstring:in:startingAt:matchTable:!

!methodRemoval: String #findSubstring:in:startingAt:matchTable: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
findSubstring: key in: body startingAt: start matchTable: matchTable
	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."
	| index |
	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>
	self var: #key declareC: 'unsigned char *key'.
	self var: #body declareC: 'unsigned char *body'.
	self var: #matchTable declareC: 'unsigned char *matchTable'.

	key isEmpty ifTrue: [^ 0].
	start to: body size - key size + 1 do:
		[:startIndex |
		index _ 1.
			[(matchTable at: (body at: startIndex+index-1) numericValue + 1)
				= (matchTable at: (key at: index) numericValue + 1)]
				whileTrue:
				[index = key size ifTrue: [^ startIndex].
				index _ index+1]].
	^ 0
"
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7
"!

String removeSelector: #is:equalTo:!

!methodRemoval: String #is:equalTo: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
is: aStringOrByteArray equalTo: another
	"Take adventage of String primitive for comparing, for example, ByteArrays"

	^ (self compare: aStringOrByteArray with: another collated: CaseSensitiveOrder) = 2!

String removeSelector: #string:withLineEndings:!

!methodRemoval: String #string:withLineEndings: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
string: aString withLineEndings: lineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"
	| cr lf crlf inPos outPos outString lineEndPos newOutPos lineEndingSize |
	cr _ Character cr.
	lf _ Character lf.
	crlf _ CharacterSet new.
	crlf add: cr; add: lf.

	inPos _ 1.
	outPos _ 1.
	lineEndingSize _ lineEndingString size.
	"This could be extremely inefficient if lineEndingString size > 1"
	outString _ aString class new: aString size * lineEndingSize.

	[
		lineEndPos _ aString indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].
		lineEndPos ~= 0 ] whileTrue: [
			newOutPos _ outPos + (lineEndPos - inPos).
			outString replaceFrom: outPos to: newOutPos - 1 with: aString startingAt: inPos.
			1 to: lineEndingSize do: [ :i |
				outString at: newOutPos put: (lineEndingString at: i).
				newOutPos _ newOutPos + 1 ].
			outPos _ newOutPos.
			((aString at: lineEndPos) = cr and: [ lineEndPos < aString size and: [ (aString at: lineEndPos+1) = lf ] ]) ifTrue: [
				"CRLF ending"
				inPos _ lineEndPos + 2 ]
			ifFalse: [ 
				"CR or LF ending"
				inPos _ lineEndPos + 1 ]. ].

	"no more line endings.  copy the rest"
	newOutPos _ outPos + (aString size - inPos).
	outString replaceFrom: outPos to: newOutPos with: aString startingAt: inPos.

	^outString copyFrom: 1 to: newOutPos!

String removeSelector: #findStringIgnoreCase:in:startingAt:!

!methodRemoval: String #findStringIgnoreCase:in:startingAt: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
findStringIgnoreCase: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0.
	Ignore case"

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseInsensitiveOrder.!

String removeSelector: #string:lineIndicesDo:!

!methodRemoval: String #string:lineIndicesDo: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
string: aString lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| start end endWithoutDelimiters |
	start _ 1.
	[
		end _ aString indexOfAnyOf: CSLineEnders startingAt: start ifAbsent: [ 0 ].
		end = 0
			ifTrue: [
				"Last line was found. Evaluate and exit.
				Note. If last char in receiver is a line separator, there's an extra empty line"
				endWithoutDelimiters _ end _ aString size.
				aBlock value: start value: endWithoutDelimiters value: end.
				^aString ].

		"Account for CrLf sequence"
		endWithoutDelimiters _ end - 1.
		(end < aString size
			and: [(aString basicAt: end + 1) = `Character lf codePoint`
			and: [(aString basicAt: end) = `Character cr codePoint` ]])
				ifTrue: [ end _ end + 1].

		aBlock value: start value: endWithoutDelimiters value: end.
		start _ end + 1 ] repeat!

String removeSelector: #compare:with:collated:!

!methodRemoval: String #compare:with:collated: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
compare: string1 with: string2 collated: order
	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."

	| len1 len2 c1 c2 |
	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>
	self var: #string1 declareC: 'unsigned char *string1'.
	self var: #string2 declareC: 'unsigned char *string2'.
	self var: #order declareC: 'unsigned char *order'.

	len1 _ string1 size.
	len2 _ string2 size.
	1 to: (len1 min: len2) do:
		[:i |
		c1 _ order at: (string1 basicAt: i) + 1.
		c2 _ order at: (string2 basicAt: i) + 1.
		c1 = c2 ifFalse: 
			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].
	len1 = len2 ifTrue: [^ 2].
	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].
!

String removeSelector: #findString:in:startingAt:!

!methodRemoval: String #findString:in:startingAt: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
findString: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseSensitiveOrder.!

String removeSelector: #compare:with:!

!methodRemoval: String #compare:with: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
compare: string1 with: string2
	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."

	^self compare: string1 with: string2 collated: CaseSensitiveOrder!

String removeSelector: #substrings:!

!methodRemoval: String #substrings: stamp: 'Install-5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st 7/5/2022 10:30:14'!
substrings: aByteStringOrByteArray
	"Answer an array of the substrings that compose the argument.
	If argument is an UTF-8 encoded ByteArray, answer is an array of same."

	| end beginning |
	end _ 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning _ aByteStringOrByteArray indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end _ aByteStringOrByteArray indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ aByteStringOrByteArray size + 1 ].
			end _ end - 1.
			result nextPut: (aByteStringOrByteArray copyFrom: beginning to: end).
		]
	].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5321-MoveStringServicesToClassSide-JuanVuletich-2022Jun26-14h55m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5321] on 26 June 2022 at 3:52:33 pm'!
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/26/2022 15:50:44' prior: 50391247!
                   lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"

	String string: bytes lineIndicesDo: [ :startByte :endByteWithoutDelimiters :endByte |
		| start end endWithoutDelimiters |
		start _ self codePointIndexAt: startByte.
		end _ (self codePointIndexAt: endByte+1)-1.
		endWithoutDelimiters _ endByteWithoutDelimiters = endByte
			ifTrue: [end]
			ifFalse: [(self codePointIndexAt: endByteWithoutDelimiters+1)-1].
		aBlock
			value: start
			value: endWithoutDelimiters
			value: end
		]! !
!Utf8String methodsFor: 'private' stamp: 'jmv 6/26/2022 15:49:41' prior: 50387099!
            codePointIndexAt: byteIndex
	| codePointIndex byteCursor |
	byteIndex < 2 ifTrue: [ ^byteIndex ]. "For 0 and 1"
	self isAscii ifTrue: [ ^ byteIndex ].
	byteIndex = (bytes size+1) ifTrue: [
		"The index of the code point starting at a hypotetical extra byte.
		Useful to find the code point index for the last byte in a sequence. See senders."
		^self size+1 ].
	codePointIndex _ byteCursor _ 1.
	strideIndex ifNil: [ self computeCountAndIndex ].
	strideIndex ifNotEmpty: [  
		strideIndex 
			findBinaryIndex: [ :x | byteIndex - x ] 
			do: [ :found | ^ (found * self stride) + 1 ] 
			ifNone: [ :lower :upper |
				lower = 0 
			 		ifFalse: [ 
						byteCursor _ strideIndex at: lower. 
						codePointIndex _ (lower * self stride) + 1 ] ] ].
	[ byteCursor <= bytes size ] whileTrue: [
		byteCursor = byteIndex 
			ifTrue: [ ^ codePointIndex ].
		byteCursor _ byteCursor + (self encodedByteCountAt: byteCursor).
		codePointIndex _ codePointIndex + 1 ].
	^ 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5322-Utf8String-fix-JuanVuletich-2022Jun26-15h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5322] on 27 June 2022 at 12:30:56 pm'!
!TestRunner methodsFor: 'processing' stamp: 'jmv 6/27/2022 11:56:12' prior: 50365527!
   runSuite: suite
	running ifNotNil: [ ^ self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	running _ [
	[ result _ suite run ] ensure: [
		running _ nil.
		suite removeDependent: self.
		runSemaphore signal.
		UISupervisor whenUIinSafeState: [
			self updateWindow: result.
			self changed: #runTests.
			self changed: #runOneTest ]]] newProcess.
	self runWindow.
	self changed: #runTests.
	self changed: #runOneTest.
	running
		name: 'TestRunner';
		priority: Processor userSchedulingPriority;
		resume.! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 6/27/2022 11:56:27' prior: 50365548!
               runSuiteProfiled: suite
	running ifNotNil: [ ^ self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	running _ [
	[ result _ TimeProfileBrowser onBlock: [ suite run ]] ensure: [
		running _ nil.
		suite removeDependent: self.
		runSemaphore signal.
		UISupervisor whenUIinSafeState: [
			self updateWindow: result.
			self changed: #runTests.
			self changed: #runOneTest ]]] newProcess.
	self runWindow.
	self changed: #runTests.
	self changed: #runOneTest.
	running
		name: 'TestRunner';
		priority: Processor userSchedulingPriority;
		resume.! !
!ProgressiveTestRunner methodsFor: 'evaluating - private' stamp: 'jmv 6/27/2022 11:56:30' prior: 50365571!
                   createProgressBarAndRun

	self createProgressBar.
	[ self runSuiteShowingProgress ]
		forkAt: Processor userSchedulingPriority
		named: 'ProgressiveTestRunner'.! !
!ProgressiveTestRunner methodsFor: 'evaluating - private' stamp: 'jmv 6/27/2022 11:57:07' prior: 16920179!
                 runSuiteShowingProgress

	[
		self registerTestSuiteAction. 
		progressBar openInWorld.
		self runSuite ] ensure: [
			self unregisterTestSuiteAction.
			UISupervisor whenUIinSafeState: [progressBar dismissMorph] ].! !
!TestSuite methodsFor: 'running' stamp: 'jmv 6/27/2022 12:03:31' prior: 16963242!
                   run: aResult

	| t1 t2 |
	t1 _ Time localMillisecondClock.
	self tests do: [:each | 
		self changed: each.
		each run: aResult.
		"Allow for some responsivenes of the UI, or any other stuff that may need running"
		t2 _ Time localMillisecondClock.
		t2-t1 > 200 ifTrue: [
			Processor yield. 
			t1 _ t2 ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5323-TestRunner-RunTestsAtRegularPriority-JuanVuletich-2022Jun27-12h29m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5301] on 20 June 2022 at 2:35:31 pm'!
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 6/20/2022 14:23:01'!
     findSourceRangeOfNode: aParseNode containingIndex: anIndex using: completeSourceRanges

	^(self findSourceRangesOfNode: aParseNode using: completeSourceRanges) 
		detect: [:nodeRange | nodeRange includes: anIndex].! !
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 6/20/2022 14:21:26'!
                           findSourceRangesOfNode: aParseNode using: completeSourceRanges

	^(completeSourceRanges associations detect: [:aNodeAndRange | aNodeAndRange key equivalentTo: aParseNode]) value! !
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 6/20/2022 14:21:51' prior: 50387619!
                findLeftmostSourceRangeOfNode: aParseNode inside: anInterval using: completeSourceRanges

	^(self findSourceRangesOfNode: aParseNode using: completeSourceRanges) 
		detect: [:nodeRange | anInterval includesAllOf: nodeRange].! !
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 6/20/2022 14:34:44' prior: 50387564!
 on: anEditor for: aSelectionInterval of: aMethodToRefactor

	| noTempFoundBlock tempToInline usageInterval |

	noTempFoundBlock := [
		"This case will usually end in a failure because a temporary variable is not related to the selected interval"
		tempToInline := anEditor wordUnder: aSelectionInterval first.
		usageInterval := aSelectionInterval.
	].
	
	anEditor
		withNodeUnderCursorDo: [:aNode | | methodNode sourceRanges |
			methodNode := aMethodToRefactor methodNode.
			sourceRanges := methodNode completeSourceRanges.
			(aNode isVariableNode and: [methodNode argumentNames noneSatisfy: [:argument | argument = aNode name]])
				ifTrue: [
					tempToInline := aNode name.
					usageInterval := self findSourceRangeOfNode: aNode containingIndex: anEditor startIndex using: sourceRanges.
				]
				ifFalse: [ | assignmentNodeAndRange |
					assignmentNodeAndRange := (methodNode parseNodesPathAt: aSelectionInterval first ifAbsent: 	[self shouldNotHappen.])
						detect: [:aNodeAndRange | aNodeAndRange key isAssignmentNode]
						ifNone: [noTempFoundBlock value].
					tempToInline ifNil: [
						tempToInline := assignmentNodeAndRange key variable name.
						usageInterval := self findLeftmostSourceRangeOfNode: assignmentNodeAndRange key variable
							inside: assignmentNodeAndRange value using: sourceRanges.
					]
				]
		]
		ifAbsent: [
			noTempFoundBlock value.
		].

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5324-InlineTempFix-Fernando-2022Jun20-14h19m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5324] on 28 June 2022 at 11:35:01 am'!
!Morph methodsFor: 'user interface' stamp: 'jmv 6/28/2022 11:33:14' prior: 16895201!
        toggleCollapseOrShow
	"If collapsed, show me.
	If visible, collapse me."

	owner ifNil: [ ^self ].
	(self visible and: [self atFront])
		ifTrue:  [ self collapse ]
		ifFalse: [ self showAndComeToFront ]! !
!Morph methodsFor: 'previewing' stamp: 'jmv 6/28/2022 11:32:56' prior: 16895455!
 beginPreview

	owner ifNil: [ ^self ].
	(self visible and: [self atFront]) ifFalse: [
		self visibleBeforePreview: self visible.
		self morphBehindBeforePreview: (self owner submorphBehind: self).
		self previewing: true.
		self showAndComeToFront. ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5325-ProtectTaskbarAgainstMorphsWithoutOwner-JuanVuletich-2022Jun28-11h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5325] on 27 June 2022 at 4:03:25 pm'!
!String class methodsFor: 'primitives' stamp: 'jmv 6/27/2022 15:43:46' prior: 50386172!
             findFirstInString: aByteStringOrByteArray inSet: inclusionMap startingAt: start
	| i stringSize |
	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>

	inclusionMap size ~= 256 ifTrue: [ ^0 ].

	i _ start.
	stringSize _ aByteStringOrByteArray size.
	[ i <= stringSize and: [ (inclusionMap at: (aByteStringOrByteArray basicAt: i) +1) = 0 ] ] whileTrue: [ 
		i _ i + 1 ].

	i > stringSize ifTrue: [ ^0 ].
	^i! !
!String class methodsFor: 'primitives' stamp: 'jmv 6/27/2022 15:44:56' prior: 16950135!
                         indexOfByte: anInteger inString: aString startingAt: start

	| stringSize |
	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>

	start > 0 ifFalse: [ ^ 0 ].
	stringSize _ aString size.
	start to: stringSize do: [:pos |
		(aString basicAt: pos) = anInteger ifTrue: [^ pos]].
	^ 0
! !
!String class methodsFor: 'primitives' stamp: 'jmv 6/27/2022 15:45:23' prior: 16950172!
                    translate: aString from: start  to: stop  table: table
	"translate the characters in the string by the given table, in place"
	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>

	start to: stop do: [ :i |
		aString at: i put: (table at: (aString basicAt: i) +1) ]! !
!String class methodsFor: 'services' stamp: 'jmv 6/27/2022 15:40:39' prior: 50390665!
  compare: string1 with: string2 collated: order
	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."

	| len1 len2 c1 c2 |
	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>

	len1 _ string1 size.
	len2 _ string2 size.
	1 to: (len1 min: len2) do:
		[:i |
		c1 _ order at: (string1 basicAt: i) + 1.
		c2 _ order at: (string2 basicAt: i) + 1.
		c1 = c2 ifFalse: 
			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].
	len1 = len2 ifTrue: [^ 2].
	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].
! !
!String class methodsFor: 'services' stamp: 'jmv 6/27/2022 15:40:27' prior: 50390702!
                      findSubstring: key in: body startingAt: start matchTable: matchTable
	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."
	| index |
	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>

	key isEmpty ifTrue: [^ 0].
	start to: body size - key size + 1 do:
		[:startIndex |
		index _ 1.
			[(matchTable at: (body basicAt: startIndex+index-1) + 1)
				= (matchTable at: (key basicAt: index) + 1)]
				whileTrue:
				[index = key size ifTrue: [^ startIndex].
				index _ index+1]].
	^ 0
"
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0
String findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0
String findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7
"! !
!ByteArray class methodsFor: 'byte based hash' stamp: 'jmv 6/27/2022 15:45:37' prior: 16799083!
                             hashBytes: aByteArray startingWith: speciesHash
	"Answer the hash of a byte-indexed collection,
	using speciesHash as the initial value.
	See SmallInteger>>hashMultiply.

	The primitive should be renamed at a
	suitable point in the future"

	| byteArraySize hash low |
	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>

	byteArraySize _ aByteArray size.
	hash _ speciesHash bitAnd: 16rFFFFFFF.
	1 to: byteArraySize do: [ :pos |
		hash _ hash + (aByteArray basicAt: pos).
		"Begin hashMultiply"
		low _ hash bitAnd: 16383.
		hash _ (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.
	].
	^ hash! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5326-MiscPrimitivePlugin-SmalltalkAlternatives-tweaks-JuanVuletich-2022Jun27-16h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5323] on 27 June 2022 at 8:17:39 pm'!
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/27/2022 16:16:16' prior: 50386300!
 caseInsensitiveLessOrEqual: aString 
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			^self asByteString caseInsensitiveLessOrEqual: aString ].
		(aString isUtf8String and: [ aString isAscii ]) ifTrue: [
			^self asByteString caseInsensitiveLessOrEqual: aString asByteString ]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase <= aString asLowercase! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/27/2022 16:09:00' prior: 50391408!
        is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize subStringBytes byteIndex |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	subStringBytes _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	byteIndex _ self byteIndexAt: index.
	(bytes at: byteIndex) = (subStringBytes byteAt: 1) ifFalse: [ ^false ].
	^(String findString: subStringBytes in: bytes startingAt: byteIndex) = byteIndex! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5327-Utf8String-bugFixes-JuanVuletich-2022Jun27-20h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5325] on 28 June 2022 at 11:42:55 am'!
!String methodsFor: 'accessing' stamp: 'jmv 6/27/2022 20:27:24' prior: 50381676 overrides: 16933699!
       indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	ans _ String indexOfByte: aCharacter iso8859s15Code inString: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!String methodsFor: 'converting' stamp: 'jmv 6/27/2022 20:34:45' prior: 16948636!
       translateFrom: start  to: stop  table: table
	"translate the characters in the string by the given table, in place"
	String translate: self from: start to: stop table: table! !

String removeSelector: #compare:!

!methodRemoval: String #compare: stamp: 'Install-5328-String-Cleanup-JuanVuletich-2022Jun28-11h42m-jmv.001.cs.st 7/5/2022 10:30:14'!
compare: aString 
	"Answer a comparison code telling how the receiver sorts relative to aString:
		1 - before
		2 - equal
		3 - after.
	The collation sequence is ascii with case differences ignored.
	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."

	^ String compare: self with: aString collated: CaseInsensitiveOrder!

String removeSelector: #compare:caseSensitive:!

!methodRemoval: String #compare:caseSensitive: stamp: 'Install-5328-String-Cleanup-JuanVuletich-2022Jun28-11h42m-jmv.001.cs.st 7/5/2022 10:30:14'!
compare: aString caseSensitive: aBool
	"Answer a comparison code telling how the receiver sorts relative to aString:
		1 - before
		2 - equal
		3 - after.
	"
	| map |
	map := aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder].
	^String compare: self with: aString collated: map!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5328-String-Cleanup-JuanVuletich-2022Jun28-11h42m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5328] on 28 June 2022 at 2:54:52 pm'!
!String methodsFor: 'converting' stamp: 'jmv 6/28/2022 14:45:48' prior: 50392246!
             translateFrom: start to: stop table: table
	"translate the characters in the string by the given table, in place"
	String translate: self from: start to: stop table: table! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/28/2022 14:44:33' prior: 50362143!
                  addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs
	"Convert the given Unicode codePoint to the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8Bytes:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	(Character codePoint: codePoint trySimilar: true)
		ifNotNil: [ :char | strm nextPut: char]
		ifNil: [
			useHexForNCRs
				ifTrue: [
					strm nextPutAll: '&#x'.
					codePoint printOn: strm base: 16 length: 4 padded: true.
					strm nextPut: $; ]
				ifFalse: [
					strm nextPutAll: '&#'.
					codePoint printOn: strm base: 10.
					strm nextPut: $; ]]! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/28/2022 14:44:27' prior: 50361999!
       fromUtf32Words: aWordArray
	"Convert the given bytes from UTF-32 to the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf32Words "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	^self fromUtf32Words: aWordArray hex: false trimLastNull: false! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/28/2022 14:44:45' prior: 50362013!
          fromUtf32Words: aWordArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-32 to the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf32Words:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			"Add just one char if possible, or the apropriate sequence for the NCR"
			self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
		(doTrimLastNullChar and: [ aWordArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/28/2022 14:44:48' prior: 50381748!
                            fromUtf8Bytes: aByteArray
	"Convert the given bytes from UTF-8 to the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf8Bytes "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	"Fast lane."
	(String isAscii: aByteArray) ifTrue: [
		^aByteArray asString ].

	"Need to do UTF-8 decoding and possible NCR generation."
	^self fromUtf8Bytes: aByteArray hex: false trimLastNull: false! !
!String class methodsFor: 'instance creation' stamp: 'jmv 6/28/2022 14:44:52' prior: 50362062!
   fromUtf8Bytes: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8Bytes:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					"Add just one char if possible, or the apropriate sequence for the NCR"
					self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
			byteIndex _ byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!String class methodsFor: 'primitives' stamp: 'jmv 6/28/2022 14:45:44' prior: 50392054!
                         translate: aString from: start to: stop table: table
	"translate the characters in the string by the given table, in place"
	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>

	start to: stop do: [ :i |
		aString at: i put: (table at: (aString basicAt: i) +1) ]! !
!String class methodsFor: 'services' stamp: 'jmv 6/28/2022 11:48:16' prior: 50390656!
    compare: string1 with: string2
	"Return 1, 2 or 3, if string1 is <, =, or > string2,
	with the collating order of characters given by the order array."

	^self compare: string1 with: string2 collated: CaseSensitiveOrder! !
!String class methodsFor: 'services' stamp: 'jmv 6/28/2022 14:44:38' prior: 50392087!
           findSubstring: key in: body startingAt: start matchTable: matchTable
	"Answer the index in the string body at which the substring key first occurs, at or beyond start. The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."
	| index |
	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>

	key isEmpty ifTrue: [^ 0].
	start to: body size - key size + 1 do:
		[:startIndex |
		index _ 1.
			[(matchTable at: (body basicAt: startIndex+index-1) + 1)
				= (matchTable at: (key basicAt: index) + 1)]
				whileTrue:
				[index = key size ifTrue: [^ startIndex].
				index _ index+1]].
	^ 0
"
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7
String findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0
String findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0
String findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7
"! !
!Symbol methodsFor: 'accessing' stamp: 'jmv 6/28/2022 14:45:08' prior: 50346196!
             precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise. The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c _ self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last = $: ifTrue: [^ 3].
	^ 1! !
!Symbol methodsFor: 'system primitives' stamp: 'di 1/2/1999 17:00' prior: 16950753!
                 flushCache
	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.
	NOTE:  Only one of the two selective flush methods needs to be used.
	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."

	<primitive: 119>
! !
!Utf8Symbol methodsFor: 'accessing' stamp: 'jmv 6/28/2022 14:45:18' prior: 50384116!
 precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise. The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c _ self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last = $: ifTrue: [^ 3].
	^ 1! !
!Utf8Symbol methodsFor: 'system primitives' stamp: 'di 1/2/1999 17:00' prior: 50390312!
             flushCache
	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.
	NOTE:  Only one of the two selective flush methods needs to be used.
	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."

	<primitive: 119>
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5329-Cleanup-JuanVuletich-2022Jun28-14h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5328] on 28 June 2022 at 2:59:23 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 6/28/2022 12:41:58'!
             findString: subString startingAt: start caseSensitive: caseSensitive
	
	^caseSensitive
		ifTrue: [ self findString: subString startingAt: start ]
		ifFalse: [ self findStringCaseInsensitive: subString startingAt: start ]! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 6/28/2022 14:32:01' overrides: 16933739!
indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isString ifFalse: [
		^super indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index _ self findString: subString startingAt: start.
	index = 0 ifTrue: [ ^exceptionBlock value ].
	^index! !
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 6/28/2022 14:28:48'!
                        is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true ].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :i |
		(self at: index+i-1) = (subString at: i) ifFalse: [ ^false ]].
	^true! !
!String methodsFor: 'accessing' stamp: 'jmv 6/28/2022 12:39:30'!
          findStringCaseInsensitive: subString startingAt: start
	"Answer the index in this String at which the substring key first occurs, at or beyond start.
	If no match is found, zero will be returned."

	"An ASCII Utf8String is has same bytes as its String equivalent"
	(subString isUtf8String and: [ subString isAscii ]) ifTrue: [
		^String findStringIgnoreCase: subString bytes in: self startingAt: start ].
	"Do conversions if needed"
	subString isByteString ifFalse: [
		^self asUtf8String findStringCaseInsensitive: subString startingAt: start ].
	"Quick primitive if both String"
	^String findStringIgnoreCase: subString in: self startingAt: start! !
!String class methodsFor: 'services' stamp: 'jmv 6/28/2022 12:17:17'!
              compareIgnoreCase: string1 with: string2
	"Return 1, 2 or 3, if string1 is <, =, or > string2, 
	with the collating order of characters given by the order array."

	^self compare: string1 with: string2 collated: CaseInsensitiveOrder! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/28/2022 12:39:39'!
               findStringCaseInsensitive: subString startingAt: start
	"Answer the index in this String at which the substring key first occurs, at or beyond start.
	If no match is found, zero will be returned."

	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		subString isByteString ifTrue: [
			^String findStringIgnoreCase: subString in: bytes startingAt: start ].
		subString isUtf8String ifTrue: [
			^subString isAscii
				ifFalse: [ false ] "Won't be found, incudes non ASCII stuff, but we're ASCII"
				ifTrue: [ String findStringIgnoreCase: subString bytes in: bytes startingAt: start ]]].

"caseSensitive = false is very expensive. Do better."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase findString: subString asLowercase startingAt: start! !
!Text methodsFor: 'accessing' stamp: 'jmv 6/28/2022 12:40:43'!
              findStringCaseInsensitive: aString startingAt: start
	"Answer the index of subString within the receiver, starting at position start.
	If the receiver does not contain subString, answer 0."

	^string findStringCaseInsensitive: aString asPlainString startingAt: start! !
!String methodsFor: 'accessing' stamp: 'jmv 6/28/2022 12:02:25' prior: 50390876!
 findString: subString startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	"An ASCII Utf8String is has same bytes as its String equivalent"
	(subString isUtf8String and: [subString isAscii]) ifTrue: [
		^ String findString: subString bytes in: self startingAt: start ].
	"Do conversions if needed"
	subString isByteString ifFalse: [
		^ self asUtf8String findString: subString startingAt: start ].
	"Quick primitive if both String"
	^ String findString: subString in: self startingAt: start! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 12:49:45' prior: 50390944!
 < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString > self ].

	^ (String compare: self with: aString) = 1! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 12:49:40' prior: 50390957!
     <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString >= self ].

	^ (String compare: self with: aString) <= 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 14:37:09' prior: 50390971 overrides: 16934001!
   = aString
	"Answer whether the receiver sorts equally as aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String or Symbol, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Let them handle us"
	aString isByteString ifFalse: [
		^aString = self ].

	^String is: self equalTo: aString.! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 12:49:26' prior: 50390996!
                          > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString < self ].

	^ (String compare: self with: aString) = 3! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 12:49:21' prior: 50391009!
      >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString <= self ].

	^ (String compare: self with: aString) >= 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 14:58:45' prior: 50391023!
                        caseInsensitiveLessOrEqual: aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case insensitive."

	"An ASCII Utf8String is has same bytes as its String equivalent"
	(aString isUtf8String and: [ aString isAscii ]) ifTrue: [
		^(String compareIgnoreCase: self with: aString bytes) <= 2 ].
	"Do conversions if needed"
	aString isByteString ifFalse: [
		^self asUtf8String caseInsensitiveLessOrEqual: aString ].
	"Quick primitive if both String"
	^ (String compareIgnoreCase: self with: aString) <= 2! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 14:29:08' prior: 50391059 overrides: 50392605!
                         is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize subStringBytes |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].

	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	(self at: index) = (subString at: 1) ifFalse: [ ^false ].
	sequenceSize = 1 ifTrue: [ ^true ].
	(self at: index+sequenceSize-1) = (subString at: sequenceSize) ifFalse: [ ^false ].
	sequenceSize = 2 ifTrue: [ ^true ].
	(subString isAscii not and: [self isAscii]) ifTrue: [ ^false ].

	"Try to find arguments for the primitive in #findString:in:startingAt: cheaply"
	subStringBytes _ nil.
	subString isByteString ifTrue: [
		subStringBytes _ subString ].
	(subString isUtf8String and: [ subString isAscii ]) ifTrue: [
		"Can use #bytes, because it has just ASCII bytes"
		subStringBytes _ subString bytes ].
	subStringBytes ifNotNil: [
		^(String findString: subStringBytes in: self startingAt: index) = index ].

	"Do it in Smalltalk. Most likely cheaper than converting argument to String"
	^super is: subString substringAt: index! !
!String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 12:17:47' prior: 50391098!
sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"An ASCII Utf8String is has same bytes as its String equivalent"
	(aString isUtf8String and: [aString isAscii]) ifTrue: [
		^ (String compareIgnoreCase: self with: aString bytes) = 2 ].

	"Let them handle us"
	aString isByteString ifFalse: [ ^aString sameAs: self ].

	^ (String compareIgnoreCase: self with: aString) = 2! !
!String methodsFor: 'system primitives' stamp: 'jmv 6/28/2022 12:54:22' prior: 50391128!
                        numArgs
	"Answer either the number of arguments that the receiver would take if considered a selector. 
	Answer -1 if it couldn't be a selector. 
		Note that currently this will answer -1 for anything begining with an uppercase letter even though 
		the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."
	| firstChar numColons start ix |
	self isEmpty ifTrue: [ ^ -1 ].
	"Binary messages"
	(self allSatisfy: [ :c | c isValidInBinarySelectors ])
		ifTrue: [ ^1 ].
	"Unary and keyword messages"
	firstChar _ self at: 1.
	firstChar isValidStartOfIdentifiers ifTrue: [
		"Fast reject if any chars are non-alphanumeric"
		(String
			findSubstring: `'~' asByteString`
			in: self
			startingAt: 1
			matchTable: Tokenish) > 0 ifTrue: [ ^ -1 ].
		"Fast colon count"
		numColons _ 0.
		start _ 1.
		[ (ix _ self findString: ':' startingAt: start) > 0 ] whileTrue: [
			numColons _ numColons + 1.
			start _ ix + 1 ].
		^ numColons ].
	^ -1.! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 6/28/2022 13:00:23' prior: 50391162!
    findString: subString startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	| arg startByteIndex byteIndex |
	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		subString isByteString ifTrue: [
			^String findString: subString in: bytes startingAt: start ].
		subString isUtf8String ifTrue: [
			^subString isAscii
				ifFalse: [ false ] "Won't be found, incudes non ASCII stuff, but we're ASCII"
				ifTrue: [ String findString: subString bytes in: bytes startingAt: start ]]].

	arg _ subString asUtf8BytesOrByteString.
	"Do UTF-8 encoding as needed."
	startByteIndex _ self byteIndexAt: start.
	byteIndex _ String findString: arg in: bytes startingAt: startByteIndex.
	^self codePointIndexAt: byteIndex! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 14:40:35' prior: 50391325 overrides: 16934001!
           = aString
	"Answer whether the receiver is equal to aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, Utf8String, Utf8Symbol or Utf32String."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	(self isAscii and: [	aString isByteString ]) ifTrue: [
		"Fast lane."
		^String is: bytes equalTo: aString ].
	
	aString isUtf8String ifTrue: [
		self isAscii = aString isAscii ifFalse: [
			^false ].
		^String is: bytes equalTo: aString bytes ].

	^ self beginsWith: aString.! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 14:58:48' prior: 50392163!
caseInsensitiveLessOrEqual: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			^(String compareIgnoreCase: bytes with: aString) <= 2 ].
		(aString isUtf8String and: [ aString isAscii ]) ifTrue: [
			^(String compareIgnoreCase: bytes with: aString bytes) <= 2 ]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase <= aString asLowercase! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 14:29:18' prior: 50392189 overrides: 50392605!
                              is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	| sequenceSize subStringBytes byteIndex subStringIsAscii |
	index < 1 ifTrue: [ ^false ].
	sequenceSize _ subString size.
	sequenceSize = 0 ifTrue: [ ^true].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].

	"The following method uses a suboptimal algorithm (brute force pattern matching with O(n^2) worst case runtime), but the primitive in C is so fast (assuming large alphabets), that it's still worth using it instead of linear time pure smalltalk implementation. There are some obvious cases when the brute force algorithm is suboptimal, e.g. when the first elements don't match, so let's compare them here before using the primitive."
	(self at: index) = (subString at: 1) ifFalse: [ ^false ].
	sequenceSize = 1 ifTrue: [ ^true ].
	(self at: index+sequenceSize-1) = (subString at: sequenceSize) ifFalse: [ ^false ].
	sequenceSize = 2 ifTrue: [ ^true ].
	subStringIsAscii _ subString isAscii.
	(self isAscii and: [subStringIsAscii not]) ifTrue: [ ^false ].

	"Try to find arguments for the primitive in #findString:in:startingAt: cheaply"
	subStringBytes _ nil.
	subString isUtf8String ifTrue: [
		"Simple. Take the bytes"
		subStringBytes _ subString bytes ].
	(subString isByteString and: [ subStringIsAscii ]) ifTrue: [
		"Can use instance of String, because it has just ASCII bytes"
		subStringBytes _ subString ].
	subStringBytes ifNotNil: [
		byteIndex _ self byteIndexAt: index.
		^(String findString: subStringBytes in: bytes startingAt: byteIndex) = byteIndex ].

	"Do it in Smalltalk. Most likely cheaper than converting argument to Utf8String"
	^super is: subString substringAt: index! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 6/28/2022 12:17:57' prior: 50386326!
 sameAs: aString
	"Answer whether the receiver sorts equal to aString. The 
	collation sequence is ascii with case differences ignored."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	self size = aString size ifFalse: [
		^false ].

	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			^(String compareIgnoreCase: bytes with: aString) = 2 ].
		aString isUtf8String ifTrue: [
			^ aString isAscii
				ifFalse: [ false ] "One is ASCII, other isn't."
				ifTrue: [
					"Both are ASCII"
					(String compareIgnoreCase: bytes with: aString bytes) = 2 ]]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT)."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase = aString asLowercase! !

Utf8String removeSelector: #indexOfSubCollection:startingAt:ifAbsent:!

!methodRemoval: Utf8String #indexOfSubCollection:startingAt:ifAbsent: stamp: 'Install-5330-String-Utf8String-Optimizations-JuanVuletich-2022Jun28-14h54m-jmv.001.cs.st 7/5/2022 10:30:14'!
indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock

	| index arg startByteIndex byteIndex |
	arg _ (self isAscii and: [subString isByteString])
		ifTrue: [subString] "Fast lane"
		ifFalse: [subString asUtf8BytesOrByteString].
	startByteIndex _ self byteIndexAt: start.
	byteIndex _ String findString: arg in: bytes startingAt: startByteIndex.
	index _ self codePointIndexAt: byteIndex.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index!

Utf8String removeSelector: #findString:startingAt:caseSensitive:!

!methodRemoval: Utf8String #findString:startingAt:caseSensitive: stamp: 'Install-5330-String-Utf8String-Optimizations-JuanVuletich-2022Jun28-14h54m-jmv.001.cs.st 7/5/2022 10:30:14'!
findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	caseSensitive ifTrue: [
		^self findString: key startingAt: start ].

	self isAscii ifTrue: [
		key isAscii
			ifTrue: [ "Fast lane"
				^String findStringIgnoreCase: key in: bytes startingAt: start ]
			ifFalse: [ "Won't be found"
				^0 ]].

"caseSensitive = false is very expensive. Do better."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase findString: key asLowercase startingAt: start!

String removeSelector: #indexOfSubCollection:startingAt:ifAbsent:!

!methodRemoval: String #indexOfSubCollection:startingAt:ifAbsent: stamp: 'Install-5330-String-Utf8String-Optimizations-JuanVuletich-2022Jun28-14h54m-jmv.001.cs.st 7/5/2022 10:30:14'!
indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock
	| index |
	subString isByteString ifFalse: [
		(subString isUtf8String and: [subString isAscii])  "Use cheapest tests and conversion possible."
			ifTrue: [ ^self indexOfSubCollection: subString asByteString
						startingAt: start ifAbsent: exceptionBlock ].
		^self asUtf8String indexOfSubCollection: subString startingAt: start ifAbsent: exceptionBlock ].
	index _ String findString: subString in: self startingAt: start.
	index = 0 ifTrue: [^ exceptionBlock value].
	^ index!

String removeSelector: #findString:startingAt:caseSensitive:!

!methodRemoval: String #findString:startingAt:caseSensitive: stamp: 'Install-5330-String-Utf8String-Optimizations-JuanVuletich-2022Jun28-14h54m-jmv.001.cs.st 7/5/2022 10:30:14'!
findString: key startingAt: start caseSensitive: caseSensitive
	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."

	^caseSensitive
		ifTrue: [String findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]
		ifFalse: [String findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5330-String-Utf8String-Optimizations-JuanVuletich-2022Jun28-14h54m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5330] on 29 June 2022 at 11:08:35 am'!
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 6/29/2022 11:08:29' prior: 16811128!
              class: oldClass instanceVariableNames: instVarString unsafe: unsafe
	"This is the basic initialization message to change the definition of
	an existing Metaclass"
	| instVars newClass needNew copyOfOldClass |
	instVars _ Scanner new scanFieldNames: instVarString.
	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].
		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].
	"See if we need a new subclass or not"
	needNew _ self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.
	needNew ifNil:[^nil]. "some error"
	needNew ifFalse:[^oldClass]. "no new class needed"

	"Create the new class"
	copyOfOldClass _ oldClass copy.
	newClass _ self 
		newSubclassOf: oldClass superclass 
		type: oldClass typeOfClass
		instanceVariables: instVars
		from: oldClass.

	"Please see comment at this method. Also see other senders."
	newClass _ self recompileSingleRecursion: false from: oldClass to: newClass.
	newClass isNil ifTrue: [ ^nil ].

	self doneCompiling: newClass.
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	^newClass! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5331-FixBugWhenAddingClassIVars-JuanVuletich-2022Jun29-11h07m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5331] on 29 June 2022 at 4:36:26 pm'!
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 6/29/2022 16:18:04' prior: 16882074!
               invokeWithEvent: evt
	"Perform the action associated with the given menu item."

	| selArgCount |
	self isEnabled ifFalse: [^ self].
	owner ifNotNil: [
		owner deleteIfPopUp: evt ].
	selector ifNil: [ ^self ].
	(selArgCount _ selector numArgs) = 0
		ifTrue: [
			target perform: selector]
		ifFalse: [
			selArgCount = arguments size
				ifTrue: [target perform: selector withArguments: arguments]
				ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]]! !
!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'jmv 6/29/2022 16:27:46' prior: 16856983!
getUserResponse
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."

	| w delay |
	w _ self world.
	w isNil ifTrue: [^ response].
	done _ false.
	textPane focusText.
	delay _ Delay forMilliseconds: 10.
	[done] whileFalse: [
		self comeToFront.
		w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	^ response! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/29/2022 16:34:17' prior: 16882859!
  deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	| h |
	h _ evt ifNotNil: [ evt hand ].
	h ifNil: [
		self world ifNotNil: [ :w | h _ h activeHand ]].
	h ifNil: [ h _ self activeHand ].
	stayUp ifFalse: [ self delete ].
	h ifNotNil: [
		h newKeyboardFocus: prevKbdFocus.
		"h newMouseFocus: prevMouseFocus."
		h newMouseFocus: nil.
		].
	popUpOwner ifNotNil: [
		popUpOwner isSelected: false.
		popUpOwner deleteIfPopUp: evt ].! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 6/29/2022 16:29:24' prior: 50367608 overrides: 16892202!
                            keyStroke: aKeyboardEvent
	| matchString char asc selectable |
	char := aKeyboardEvent keyCharacter.
	asc := char numericValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
					selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: [
							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			self delete.
			aKeyboardEvent hand
				newKeyboardFocus: prevKbdFocus;
				newMouseFocus: prevMouseFocus.
			^self].
	(asc = 28 or: [asc = 29]) 
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
				ifFalse: [^ self]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := char = Character backspace 
				ifTrue: [
					matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 6/29/2022 16:23:13' prior: 50367679 overrides: 16892224!
    mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event."
	(stayUp or: [ self includesPixel: aMouseButtonEvent eventPosition ]) 
		ifFalse: [
			self deleteIfPopUp: aMouseButtonEvent.
			^ self ]. "click outside"

	"Grab the menu and drag it to some other place
	This is reimplemented here because we handle the event, and if the following lines are commented, a menu can't be grabbed with the hand. This is not nice and shouldn't be needed"
	self isSticky ifTrue: [ ^self ].
	aMouseButtonEvent hand grabMorph: self.! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 6/29/2022 16:23:02' prior: 50367703 overrides: 16892239!
         mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self includesPixel: aMouseButtonEvent eventPosition) ifFalse: [
		"Mouse up outside. Release eventual focus and delete if pop up."
		self deleteIfPopUp: aMouseButtonEvent.
		^ self].
	stayUp ifFalse: [
		"Still in pop-up transition; keep focus"
		aMouseButtonEvent hand newMouseFocus: self ].! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 6/29/2022 16:10:28' prior: 50367724!
                invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w actHand delay |
	w _ self runningWorld.
	actHand _ w activeHand.
	w doOneMinimalCycleNow.
	self popUpAt: actHand morphPosition allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	delay _ Delay forMilliseconds: 10.
	[ self isInWorld and: [self isModalInvokationDone not] ] whileTrue: [
		self comeToFront.
		w doOneMinimalCycleNow. delay wait ].
	self delete.
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 6/29/2022 16:08:37' prior: 50367751!
         invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	| w delay |
	w _ self runningWorld.
	w doOneMinimalCycleNow.
	self popUpAt: aPoint allowKeyboard: aBoolean.
	done _ false.
	delay _ Delay forMilliseconds: 20.
	[ done not and: [self isInWorld] ] whileTrue: [
		self comeToFront.
		w doOneMinimalCycleNow. delay wait ].
	^ mvcSelection ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5332-Menu-tweaks-JuanVuletich-2022Jun29-16h18m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5332] on 30 June 2022 at 3:59:30 pm'!
!PreferenceNG class methodsFor: 'toBeRemoved' stamp: 'jmv 6/30/2022 15:57:12'!
isInitialFileListDirectory: x
^false! !
!PreferenceNG class methodsFor: 'toBeRemoved' stamp: 'jmv 6/30/2022 15:55:35'!
         soundsEnabled
^true! !
!FileList methodsFor: 'user interface' stamp: 'jmv 6/30/2022 15:56:20' prior: 16855918!
                 toggleInitialDirectory
	"Toggle the initial directory setting of the currently selected directory."
	
	
"
	Preferences isInitialFileListDirectory: (directoryEntry _ currentDirectorySelected item)::
		ifTrue: [
			Preferences removeInitialFileListDirectory: directoryEntry ]
		ifFalse: [
			Preferences addInitialFileListDirectory: directoryEntry ]
"! !
!SystemDictionary methodsFor: 'ui' stamp: 'jmv 6/30/2022 15:55:50' prior: 50366037!
           beep
	"
	Smalltalk beep
	"
	PreferenceNG soundsEnabled ifTrue: [
		Smalltalk
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 6/30/2022 15:57:17' prior: 50356498!
                       volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	model currentDirectorySelected
		ifNil: [ aMenu add: 'initial directory' action: #yourself :: isEnabled: false ]
		ifNotNil: [ :selectedWrapper |
	aMenu 
		add: (PreferenceNG isInitialFileListDirectory: selectedWrapper item)
			asMenuItemTextPrefix, 'initial directory'
		action: #toggleInitialDirectory ::
			setBalloonText: 'The selected directory is an initial director for new file list windows' ].
	initialDirectoriesMenu _ MenuMorph new.
	#(
		(roots  'default roots' 'Use the usual root directories. Drives on Windows; "/" on Unix')
	   	(image 'image directory' 'Use the directory with Smalltalk image')
		(vm 'VM directory' 'Use the virtual machine directory')
		(current 'current directory' 'Use the current directory; usually the directory the VM was started in')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: PreferenceNG
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 6/30/2022 15:58:00' prior: 50359253!
             preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: {
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		PreferenceNG.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		PreferenceNG.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#readAdditionalTrueTypeFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		PreferenceNG.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5333-RemoveReferencesToPreferences-JuanVuletich-2022Jun30-15h53m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5333] on 30 June 2022 at 4:09:27 pm'!

Smalltalk removeClassNamed: #Preference!

!classRemoval: #Preference stamp: 'Install-5334-RemoveOldPreferenceClasses-JuanVuletich-2022Jun30-16h08m-jmv.001.cs.st 7/5/2022 10:30:14'!
Object subclass: #Preference
	instanceVariableNames: 'name value defaultValue helpString categoryList changeInformee changeSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

Smalltalk removeClassNamed: #Preferences!

!classRemoval: #Preferences stamp: 'Install-5334-RemoveOldPreferenceClasses-JuanVuletich-2022Jun30-16h08m-jmv.001.cs.st 7/5/2022 10:30:14'!
Object subclass: #Preferences
	instanceVariableNames: ''
	classVariableNames: 'DictionaryOfPreferences Parameters'
	poolDictionaries: ''
	category: 'System-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5334-RemoveOldPreferenceClasses-JuanVuletich-2022Jun30-16h08m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5305] on 23 June 2022 at 10:49:19 am'!

Object subclass: #PreferenceSet
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #PreferenceSet category: #'System-Support' stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
Object subclass: #PreferenceSet
	instanceVariableNames: 'contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!
!PreferenceSet commentStamp: '<historical>' prior: 0!
    I hold a set of preferences. An application may want to instanciate me to hold its related preferences.
- contents :  a Dictionary whose keys are preference names (symbol) and value a PreferenceNG instance.!
!PreferenceSet methodsFor: 'instance creation' stamp: 'hlsf 6/22/2022 22:19:59'!
                               name: nameSymbol category: categorySymbol value: aValue
	self name: nameSymbol description: nil category: categorySymbol type: nil value: aValue 
! !
!PreferenceSet methodsFor: 'instance creation' stamp: 'hlsf 6/22/2022 22:21:43'!
                         name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
"If I exist, I am updated with the newer sent data "
	(nameSymbol isSymbol or: [categorySymbol isSymbol]) ifFalse: 
		[self error: 'Preference Name & Category are not valid symbol.'].
	^ contents 
		at: nameSymbol
		ifPresent: [:thePref |
			thePref 
				description: aString;
				category: categorySymbol;
				value: aValue;
				yourself]
		ifAbsent: [ | newPref |
			newPref _ PreferenceNG new ::
				name: nameSymbol 
				description: aString 
				category: categorySymbol 
				type: aType 
				value: aValue.
			contents at: nameSymbol put: newPref ].
	! !
!PreferenceSet methodsFor: 'accessing' stamp: 'hlsf 6/22/2022 22:17:03'!
             allPreferences
	^ contents 
	! !
!PreferenceSet methodsFor: 'accessing' stamp: 'hlsf 6/22/2022 22:16:51' overrides: 16901507!
  at: symbolName
	^ (self instanceAt: symbolName) value! !
!PreferenceSet methodsFor: 'accessing' stamp: 'hlsf 6/22/2022 22:16:43' overrides: 16901525!
          at: symbolName put: aValue
	| myPref |
	myPref _ self instanceAt: symbolName. 
	myPref value: aValue! !
!PreferenceSet methodsFor: 'accessing' stamp: 'hlsf 6/22/2022 22:16:19'!
               categories
	| categories |
	categories _ Set new.
	contents values do: [:aPreference | categories add: aPreference category].
	^ categories sorted! !
!PreferenceSet methodsFor: 'accessing' stamp: 'hlsf 6/22/2022 22:16:00'!
 instanceAt: symbolName
	^ contents at: symbolName ifAbsent: [self error: 'Unknown preference ', symbolName ]! !
!PreferenceSet methodsFor: 'accessing' stamp: 'hlsf 6/23/2022 10:40:51'!
       openPreferencesInspector
	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"
	self allPreferences inspectWithLabel: 'Preferences'! !
!PreferenceSet methodsFor: 'accessing' stamp: 'hlsf 6/22/2022 22:16:30'!
                      selectCategory: aCategory
" I select the preferences of the given category "
	^ contents values select: [:aPreference | aPreference category == aCategory ]! !
!PreferenceSet methodsFor: 'error handling' stamp: 'hlsf 6/23/2022 10:19:47' overrides: 50337880!
                               doesNotUnderstand: aMessage
	aMessage hasArguments ifTrue: [^ super doesNotUnderstand: aMessage].
	^ self at: aMessage selector! !
!PreferenceSet methodsFor: 'fileIn/Out' stamp: 'hlsf 6/23/2022 10:24:29'!
                   loadFrom: aFileEntry
" Load all preferences from file, update the existing preferences with the data from file "
	(SmartRefStream restoreFromFile: aFileEntry) do: [:aPref | 
		self 
			name: aPref name 
			description: aPref description 
			category: aPref category 
			type: aPref type 
			value: (aPref instVarNamed: #value)	 " We want the raw value "]! !
!PreferenceSet methodsFor: 'fileIn/Out' stamp: 'hlsf 6/23/2022 10:25:38'!
                save: nameSymbol to: aFileEntry
" Save one preference to a file, even for a sole preference we save in a Dictionary"
	| myPref |
	myPref _ self instanceAt: nameSymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: {myPref name -> myPref} asDictionary! !
!PreferenceSet methodsFor: 'fileIn/Out' stamp: 'hlsf 6/23/2022 10:26:23'!
                 saveAllTo: aFileEntry
" Save all the preferences to a file "
	SmartRefStream dumpOnFile: aFileEntry object: self allPreferences! !
!PreferenceSet methodsFor: 'fileIn/Out' stamp: 'hlsf 6/23/2022 10:26:42'!
                   saveCategory: categorySymbol to: aFileEntry
	| myPref |
	myPref _ self selectCategory: categorySymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: 	(myPref collect: [:aPref | aPref name -> aPref ]) asDictionary! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:44:59'!
                   iconicHaloSpecifications
"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles 
that may be used in the iconic halo scheme"

^ #(	"selector					horiz			vert			color info				icon key"
(addDismissHandle:						left			top			(red)				haloDismissIcon 					'Remove')
(addMenuHandle:						leftCenter			top			(blue lighter)				haloMenuIcon 					'Menu')
(addGrabHandle:						center			top			(black)				haloGrabIcon 					'Pick up')
(addDragHandle:						rightCenter			top			(brown)				haloDragIcon 					'Move')
(addDupHandle:						right			top			(green)				haloDuplicateIcon     					'Duplicate')	
(addExploreHandle:						left			topCenter			(orange)				haloDebugIcon 					'Explore')
(addDebugHandle:						right			topCenter			(orange)				haloDebugIcon 					'Debug')
(addCollapseHandle:						left			center			(tan)				haloCollapseIcon 					'Collapse')
(addScaleHandle:						right			center			(blue)				haloScaleIcon 					'Change scale')
(addRotateHandle:						left			bottom			(blue)				haloRotateIcon 					'Rotate')
(addHelpHandle:						center			bottom			(lightBlue)				haloHelpIcon 					'Help')
(addResizeHandle:						right			bottom			(yellow)				haloResizeIcon 					'Change size')
	"FIXME - Currently non-functional...
	(addRecolorHandle:						right			bottomCenter			(magenta darker)						haloColorIcon 						'Change color')	"
)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:45:05'!
machineDefault
	^ #(
		#(drawKeyboardFocusIndicator true )
		#(balloonHelpEnabled true )
		#(biggerCursors false )
		#(browseWithPrettyPrint false )
		#(caseSensitiveFinds false )
		#(checkForSlips true )
		#(cmdDotEnabled true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(menuKeyboardControl true )
		#(optionalButtons true )
		#(extraDebuggerButtons true )
		#(subPixelRenderFonts true )
		#(thoroughSenders true )
		#(cheapWindowReframe false )
		#(syntaxHighlightingAsYouType true )
		#(tapAndHoldEmulatesButton2 true )
		#(clickGrabsMorphs false )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(wantsMenuIcons true )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:45:10'!
 machineSlow
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
		(methodAnnotations #(timeStamp messageCategory packages changeSets) )
		(classAnnotations  #(instanceMethodsCount classMethodsCount) )
		(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount) )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:45:16'!
             machineSmalltalk80
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:45:21'!
   prefFont
	^ #( 
		#(aaFontsColormapDepth 4)
		#(cacheTrueTypeGlyphs true )
		#(guiElementsSize standardFonts #(tinyFonts verySmallFonts smallFonts standardFonts largeFonts veryLargeFonts hugeFonts) defaultFontSize: )
		#(loadOnlyLatinGlyphData false )
		#(properDisplayAlphaForFonts false )	
		#(subPixelRenderColorFonts true )
		#(subPixelRenderFonts true )	
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:45:27'!
    prefGui
	^ #( 
		#(balloonHelpEnabled true )
		#(biggerCursors false )		
		#(cacheDisplayContentWhenMovingMorphs true )
		#(cheapWindowReframe false )		
		#(clickGrabsMorphs false )	
		#(ctrlArrowsScrollHorizontally false ) 
		#(drawKeyboardFocusIndicator true )
		#(focusFollowsMouse true )
		#(focusIndicatorWidth 1)
		#(fullScreenLeavesDeskMargins true )
		#(haloEnclosesFullBounds true )
		#(halosShowCoordinateSystem true )
		#(menuKeyboardControl true )
		#(optionalButtons true )		
		#(selectiveHalos true )
		#(tapAndHoldEmulatesButton2 true )
		#(tileResizerInWindowMenu true )
		#(wantsMenuIcons true )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:45:33'!
       prefProgramming
	^ #(
		#(atMinusDigitMeaning st80 #(st80 ansiSmalltalk disabled) )
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 6/22/2022 22:45:38'!
         prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'hlsf 6/22/2022 22:34:58'!
        init
" Not nme initialize to avoid auto start at class installation "
	#(gui font programming system) do: [: category | 
		(self perform: (#pref, category capitalized) asSymbol) do: [:aPrefArray |
			self installDefault: aPrefArray in: category] ].
	self installHaloPreferencesWith: self iconicHaloSpecifications.
	self installMiscPreferences.
	self defaultFontSize: #standardFonts.
	self setDefaultFont: FontFamily defaultFamilyName.! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'hlsf 6/23/2022 10:27:57'!
                      installDefault: anArray in: category
" Description of preference in Array: name - value - type (optional) - event handler (optional) "
	| myPref |
	myPref _ self sysPreferences 
		name: anArray first 
		description: '' 
		category: category 
		type: (anArray at: 3 ifAbsent: [PreferenceNG detectType: anArray second]) value: anArray second.
		
	anArray size = 4 ifTrue: [ "fourth record is an event listener hooked to Preference"
		myPref when: #preferenceChanged send: anArray fourth to: PreferenceSet.
		myPref triggerEvent: #preferenceChanged with: myPref]
	! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'hlsf 6/22/2022 22:42:05'!
                       installHaloPreferencesWith: anArray
	| aColor |
	^ self sysPreferences 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each |
			aColor _ Color.
			each fourth do: [ :sel | aColor _ aColor perform: sel].
			HaloSpec new 
				horizontalPlacement: each second
				verticalPlacement: each third 
				color: aColor
				iconSymbol: each fifth
				addHandleSelector: each first
				hoverHelp: each sixth])! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'hlsf 6/22/2022 22:43:37'!
    installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	self sysPreferences 

		name: #haloHandleSize 
		category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 5 // 3 max: 16];
	
		name: #roundedButtonRadius 	
		category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 8 // 14];
		
		name: #roundedWindowRadius 	
		category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize] ;
		
		name: #scrollbarThickness 
		category: #gui 		
		value: [(PreferenceNG at: #windowTitleFont) pointSize + 2];
		
		name: #classFinder 
		category: #programming 
		value: [ BrowserWindow findClass ];
		
		name: #defaultAuthorName 
		category: #programming 
		value: [Utilities authorName].! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'hlsf 6/22/2022 22:32:48'!
      sysPreferences
"Access to the Preference Set dedicated to the Cuis system"
	^ Smalltalk at: #Preferences ifAbsentPut: [PreferenceSet new]! !
!PreferenceSet class methodsFor: 'sys fonts' stamp: 'hlsf 6/23/2022 10:33:07'!
    fontSizes
	^ `{
		#tinyFonts -> 7 .
		#verySmallFonts -> 9 .
		#smallFonts ->11 .
		#standardFonts -> 14 .
		#largeFonts -> 18 .
		#veryLargeFonts -> 24 .
		#hugeFonts -> 32} asDictionary`! !
!PreferenceSet class methodsFor: 'sys fonts' stamp: 'hlsf 6/23/2022 10:36:35'!
                 setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	self
		setDefaultFont: FontFamily defaultFamilyName
		spec: {
			{#standardListFont. (self sysPreferences at: #standardListFont) pointSize.}.
			{#standardMenuFont. (self sysPreferences at: #standardMenuFont) pointSize.}.
			{#windowTitleFont. (self sysPreferences at: #windowTitleFont) pointSize.}.
			{#standardCodeFont. (self sysPreferences at: #standardCodeFont) pointSize.}.
			{#standardButtonFont. (self sysPreferences at: #standardButtonFont) pointSize.}.
		}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceSet class methodsFor: 'sys fonts' stamp: 'hlsf 6/23/2022 10:37:23'!
              setDefaultFont: fontFamilyName spec: defaultFontsSpec
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font _ font emphasized: triplet third ].
		self sysPreferences at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceSet class methodsFor: 'sys obsolete' stamp: 'hlsf 6/23/2022 10:40:08'!
desktopMenuTitle
"I have project to get rid of this one"
	^ 'World'   ! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'hlsf 6/23/2022 10:29:37'!
                              assignmentGlyph: assignmentPref
" #assignmentGliphSelector changed "
	AbstractFont withAllSubclassesDo: [ :fontClass | fontClass assignmentGlyphSelectorPreferenceChanged ]! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'hlsf 6/23/2022 10:30:25'!
                         defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	PreferenceNG name: #standardListFont category: #font value: font.
	PreferenceNG name: #standardMenuFont category: #font value: font.
	PreferenceNG name: #standardCodeFont category: #font value: font.
	PreferenceNG name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	PreferenceNG name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	PreferenceNG at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'hlsf 6/23/2022 10:31:46'!
                  machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray |
	prefArray _ self perform: (#machine, machinePref value capitalized) asSymbol.
	prefArray do: [:array | 		self sysPreferences at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'hlsf 6/23/2022 10:32:10'!
                      menuIcon: wantsMenuIconsPref
	Theme current class beCurrent! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'hlsf 6/23/2022 10:32:36'!
         pointer: pointerPref
	| enabled |
	enabled _ pointerPref value == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 	
		self sysPreferences at: aPref put: enabled]! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 6/23/2022 10:20:29' prior: 50358560!
        allPreferences
	^ ThePreferences 
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 6/23/2022 10:21:04' prior: 50352954 overrides: 16901507!
             at: symbolName
	^ (self instanceAt: symbolName) value
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 6/23/2022 10:20:39' prior: 50352959 overrides: 16901525!
                         at: symbolName put: aValue
	| myPref |
	myPref _ self instanceAt: symbolName. 
	myPref value: aValue
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 6/23/2022 10:20:45' prior: 50352965!
                              categories
	| categories |
	categories _ Set new.
	ThePreferences values do: [:aPreference | categories add: aPreference category].
	^ categories sorted
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 6/23/2022 10:20:53' prior: 50352973!
          instanceAt: symbolName
	^ ThePreferences at: symbolName ifAbsent: [self error: 'Unknown preference ', symbolName ]
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 6/23/2022 10:20:58' prior: 50358564!
                selectCategory: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'instance creation' stamp: 'hlsf 6/23/2022 10:21:15' prior: 50352988!
                         name: nameSymbol category: categorySymbol value: aValue
	self name: nameSymbol description: nil category: categorySymbol type: nil value: aValue 
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'instance creation' stamp: 'hlsf 6/23/2022 10:21:20' prior: 50352996!
         name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
"If I exist, I am updated with the newer sent data "
	(nameSymbol isSymbol or: [categorySymbol isSymbol]) ifFalse: 
		[self error: 'Preference Name & Category are not valid symbol.'].
	^ ThePreferences 
		at: nameSymbol
		ifPresent: [:thePref |
			thePref 
				description: aString;
				category: categorySymbol;
				value: aValue;
				yourself]
		ifAbsent: [ | newPref |
			newPref _ self new ::
				name: nameSymbol 
				description: aString 
				category: categorySymbol 
				type: aType 
				value: aValue.
			ThePreferences at: nameSymbol put: newPref ].
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'error handling' stamp: 'hlsf 6/23/2022 10:21:26' prior: 50353020 overrides: 50337880!
 doesNotUnderstand: aMessage
	aMessage hasArguments ifTrue: [^ super doesNotUnderstand: aMessage].
	^ self at: aMessage selector
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 6/23/2022 10:29:46' prior: 50353393!
                              assignmentGlyph: assignmentPref
" #assignmentGliphSelector changed "
	AbstractFont withAllSubclassesDo: [ :fontClass | fontClass assignmentGlyphSelectorPreferenceChanged ]
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 6/23/2022 10:30:39' prior: 50353402!
                  defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	PreferenceNG name: #standardListFont category: #font value: font.
	PreferenceNG name: #standardMenuFont category: #font value: font.
	PreferenceNG name: #standardCodeFont category: #font value: font.
	PreferenceNG name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	PreferenceNG name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	PreferenceNG at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 6/23/2022 10:31:50' prior: 50353436!
           machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray |
	prefArray _ self perform: (#machine, machinePref value capitalized) asSymbol.
	prefArray do: [:array | 		PreferenceNG at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 6/23/2022 10:32:14' prior: 50353450!
                      menuIcon: wantsMenuIconsPref
	Theme current class beCurrent
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 6/23/2022 10:32:42' prior: 50353455!
  pointer: pointerPref
	| enabled |
	enabled _ pointerPref value == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 		PreferenceNG at: aPref put: enabled]
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 6/23/2022 10:32:52' prior: 50353463!
                         fontSizes
	^ `{
		#tinyFonts -> 7 .
		#verySmallFonts -> 9 .
		#smallFonts ->11 .
		#standardFonts -> 14 .
		#largeFonts -> 18 .
		#veryLargeFonts -> 24 .
		#hugeFonts -> 32} asDictionary`
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 6/23/2022 10:36:26' prior: 50357850!
          setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	PreferenceNG
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (PreferenceNG at: #standardListFont) pointSize.}.
				{#standardMenuFont. (PreferenceNG at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (PreferenceNG at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (PreferenceNG at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (PreferenceNG at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 6/23/2022 10:39:04' prior: 50353497!
                          setDefaultFont: fontFamilyName spec: defaultFontsSpec
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font _ font emphasized: triplet third ].
		PreferenceNG at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'obsolete' stamp: 'hlsf 6/23/2022 10:40:23' prior: 50353515!
desktopMenuTitle
"I have project to get rid of this one"
	^ 'World' 
" Copied to PreferenceSet "! !
!PreferenceNG class methodsFor: 'as yet unclassified' stamp: 'hlsf 6/23/2022 10:41:06' prior: 50359244!
                    openPreferencesInspector
	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"
	
	self allPreferences inspectWithLabel: 'Preferences'
" Copied to PreferenceSet "! !

PreferenceSet class removeSelector: #cuisPreferences!

PreferenceNG class removeSelector: #installDefault:in:!

!methodRemoval: PreferenceNG class #installDefault:in: stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
installDefault: anArray in: category
" Description of preference in Array: name - value - type (optional) - event handler (optional) "
	| myPref |
	myPref _ PreferenceNG name: anArray first 				description: '' category: category 
		type: (anArray at: 3 ifAbsent: [self detectType: anArray second]) value: anArray second.
	anArray size = 4 ifTrue: [ "fourth record is an event listener hooked to Preference"
		myPref when: #preferenceChanged send: anArray fourth to: PreferenceNG.
		myPref triggerEvent: #preferenceChanged with: myPref]
	!

PreferenceNG class removeSelector: #loadFrom:!

!methodRemoval: PreferenceNG class #loadFrom: stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
loadFrom: aFileEntry
" Load all preferences from file, update the existing preferences with the data from file "
	(SmartRefStream restoreFromFile: aFileEntry) do: [:aPref | 
		PreferenceNG 
			name: aPref name 
			description: aPref description 
			category: aPref category 
			type: aPref type 
			value: (aPref instVarNamed: #value)	 " We want the raw value "]!

PreferenceNG class removeSelector: #prefFont!

!methodRemoval: PreferenceNG class #prefFont stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
prefFont
	^ #( 
		#(aaFontsColormapDepth 4)
		#(cacheTrueTypeGlyphs true )
		#(guiElementsSize standardFonts #(tinyFonts verySmallFonts smallFonts standardFonts largeFonts veryLargeFonts hugeFonts) defaultFontSize: )
		#(loadOnlyLatinGlyphData false )
		#(properDisplayAlphaForFonts false )	
		#(subPixelRenderColorFonts true )
		#(subPixelRenderFonts true )	
	)!

PreferenceNG class removeSelector: #prefProgramming!

!methodRemoval: PreferenceNG class #prefProgramming stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
prefProgramming
	^ #(
		#(atMinusDigitMeaning st80 #(st80 ansiSmalltalk disabled) )
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)!

PreferenceNG class removeSelector: #prefSystem!

!methodRemoval: PreferenceNG class #prefSystem stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)!

PreferenceNG class removeSelector: #machineDefault!

!methodRemoval: PreferenceNG class #machineDefault stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
machineDefault
	^ #(
		#(drawKeyboardFocusIndicator true )
		#(balloonHelpEnabled true )
		#(biggerCursors false )
		#(browseWithPrettyPrint false )
		#(caseSensitiveFinds false )
		#(checkForSlips true )
		#(cmdDotEnabled true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(menuKeyboardControl true )
		#(optionalButtons true )
		#(extraDebuggerButtons true )
		#(subPixelRenderFonts true )
		#(thoroughSenders true )
		#(cheapWindowReframe false )
		#(syntaxHighlightingAsYouType true )
		#(tapAndHoldEmulatesButton2 true )
		#(clickGrabsMorphs false )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(wantsMenuIcons true )
	)!

PreferenceNG class removeSelector: #initialize!

!methodRemoval: PreferenceNG class #initialize stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
initialize
    	ThePreferences ifNil: [ThePreferences _ Dictionary new].
	#(gui font programming system) do: [: category | 
		(self perform: (#pref, category capitalized) asSymbol) do: [:aPrefArray |
			self installDefault: aPrefArray in: category] ].
	self installHaloPreferencesWith: self iconicHaloSpecifications.
	self installMiscPreferences.
	self defaultFontSize: #standardFonts.
	self setDefaultFont: FontFamily defaultFamilyName.!

PreferenceNG class removeSelector: #saveCategory:to:!

!methodRemoval: PreferenceNG class #saveCategory:to: stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
saveCategory: categorySymbol to: aFileEntry
	| myPref |
	myPref _ self selectCategory: categorySymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: 	(myPref collect: [:aPref | aPref name -> aPref ]) asDictionary!

PreferenceNG class removeSelector: #machineSlow!

!methodRemoval: PreferenceNG class #machineSlow stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
machineSlow
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
		(methodAnnotations #(timeStamp messageCategory packages changeSets) )
		(classAnnotations  #(instanceMethodsCount classMethodsCount) )
		(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount) )
	)!

PreferenceNG class removeSelector: #machineSmalltalk80!

!methodRemoval: PreferenceNG class #machineSmalltalk80 stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
machineSmalltalk80
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
	)!

PreferenceNG class removeSelector: #installMiscPreferences!

!methodRemoval: PreferenceNG class #installMiscPreferences stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	PreferenceNG 
		name: #haloHandleSize category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 5 // 3 max: 16].
	PreferenceNG
		name: #roundedButtonRadius 	category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 8 // 14].
	PreferenceNG
		name: #roundedWindowRadius 	category: #gui value: [(PreferenceNG at: #standardListFont) pointSize].
	PreferenceNG
		name: #scrollbarThickness category: #gui 		value: [(PreferenceNG at: #windowTitleFont) pointSize + 2].
	PreferenceNG name: #classFinder category: #programming value: [ BrowserWindow findClass ].
	PreferenceNG name: #defaultAuthorName category: #programming value: [Utilities authorName].!

PreferenceNG class removeSelector: #installHaloPreferencesWith:!

!methodRemoval: PreferenceNG class #installHaloPreferencesWith: stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
installHaloPreferencesWith: anArray
	| aColor |
	^ PreferenceNG 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each |
			aColor _ Color.
			each fourth do: [ :sel | aColor _ aColor perform: sel].
			HaloSpec new 
				horizontalPlacement: each second
				verticalPlacement: each third 
				color: aColor
				iconSymbol: each fifth
				addHandleSelector: each first
				hoverHelp: each sixth])!

PreferenceNG class removeSelector: #prefGui!

!methodRemoval: PreferenceNG class #prefGui stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
prefGui
	^ #( 
		#(balloonHelpEnabled true )
		#(biggerCursors false )		
		#(cacheDisplayContentWhenMovingMorphs true )
		#(cheapWindowReframe false )		
		#(clickGrabsMorphs false )	
		#(ctrlArrowsScrollHorizontally false ) 
		#(drawKeyboardFocusIndicator true )
		#(focusFollowsMouse true )
		#(focusIndicatorWidth 1)
		#(fullScreenLeavesDeskMargins true )
		#(haloEnclosesFullBounds true )
		#(halosShowCoordinateSystem true )
		#(menuKeyboardControl true )
		#(optionalButtons true )		
		#(selectiveHalos true )
		#(tapAndHoldEmulatesButton2 true )
		#(tileResizerInWindowMenu true )
		#(wantsMenuIcons true )
	)!

PreferenceNG class removeSelector: #saveAllTo:!

!methodRemoval: PreferenceNG class #saveAllTo: stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
saveAllTo: aFileEntry
" Save all the preferences to a file "
	SmartRefStream dumpOnFile: aFileEntry object: ThePreferences!

PreferenceNG class removeSelector: #save:to:!

!methodRemoval: PreferenceNG class #save:to: stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
save: nameSymbol to: aFileEntry
" Save one preference to a file, even for a sole preference we save in a Dictionary"
	| myPref |
	myPref _ self instanceAt: nameSymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: {myPref name -> myPref} asDictionary!

PreferenceNG class removeSelector: #iconicHaloSpecifications!

!methodRemoval: PreferenceNG class #iconicHaloSpecifications stamp: 'Install-5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st 7/5/2022 10:30:14'!
iconicHaloSpecifications
"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles 
that may be used in the iconic halo scheme"

^ #(	"selector					horiz			vert			color info				icon key"
(addDismissHandle:						left			top			(red)				haloDismissIcon 					'Remove')
(addMenuHandle:						leftCenter			top			(blue lighter)				haloMenuIcon 					'Menu')
(addGrabHandle:						center			top			(black)				haloGrabIcon 					'Pick up')
(addDragHandle:						rightCenter			top			(brown)				haloDragIcon 					'Move')
(addDupHandle:						right			top			(green)				haloDuplicateIcon     					'Duplicate')	
(addExploreHandle:						left			topCenter			(orange)				haloDebugIcon 					'Explore')
(addDebugHandle:						right			topCenter			(orange)				haloDebugIcon 					'Debug')
(addCollapseHandle:						left			center			(tan)				haloCollapseIcon 					'Collapse')
(addScaleHandle:						right			center			(blue)				haloScaleIcon 					'Change scale')
(addRotateHandle:						left			bottom			(blue)				haloRotateIcon 					'Rotate')
(addHelpHandle:						center			bottom			(lightBlue)				haloHelpIcon 					'Help')
(addResizeHandle:						right			bottom			(yellow)				haloResizeIcon 					'Change size')
	"FIXME - Currently non-functional...
	(addRecolorHandle:						right			bottomCenter			(magenta darker)						haloColorIcon 						'Change color')	"
)!

PreferenceNG initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5335-PreferenceSet-Hilaire-2022Jun22-22h01m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5335] on 30 June 2022 at 4:14:23 pm'!

Smalltalk renameClassNamed: #PreferenceNG as: #Preference!

!classRenamed: #PreferenceNG as: #Preference stamp: 'Install-5336-Rename-PreferenceNG-as-Preference-JuanVuletich-2022Jun30-16h11m-jmv.001.cs.st 7/5/2022 10:30:14'!
Smalltalk renameClassNamed: #PreferenceNG as: #Preference!
!PreferenceSet commentStamp: '<historical>' prior: 50393702!
                           I hold a set of preferences. An application may want to instanciate me to hold its related preferences.
- contents :  a Dictionary whose keys are preference names (symbol) and value a Preference instance.!
!PluggableTextModel methodsFor: 'misc' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356731 overrides: 16968693!
      refetch
	"Answer true if actualContents was actually fetched."
	textGetter
		ifNil: [
			actualContents ifNil: [
				self actualContents: Text new ].
			^false ]
		ifNotNil: [
			self actualContents: (Text
				initialFont: (Preference at: #standardCodeFont)
				stringOrText: (textProvider perform: textGetter)).
			self changed: #refetched.
			^true ]! !
!Workspace methodsFor: 'shout styling' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354752!
    shouldStyle

	^shouldStyle ifNil: [ Preference at: #shoutInWorkspaces]! !
!Workspace methodsFor: 'user interface support' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354759 overrides: 16968885!
 allowStylingWithEmphasis
	"Disabled by default for faster styling of large contents, as text metrics are not affected by styling."

	^ Preference at: #stylingWithEmphasisInWorkspaces! !
!Workspace methodsFor: 'user interface support' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354769 overrides: 16968910!
                 fullPrintIt

	^fullPrintIt ifNil: [ Preference at: #fullPrintItInWorkspaces]! !
!TextProvider methodsFor: 'contents' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356745!
                          acceptedContents
	^ Text
		initialFont: (Preference at: #standardCodeFont)
		stringOrText: self acceptedStringOrText! !
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354775!
                annotationForClassDefinitionFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Class definition for ';
			nextPutAll: aClass name.
		(Preference at: #classAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#instanceMethodsCount] -> [
					strm
						print: (aClass theNonMetaClass selectors size);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (aClass theMetaClass selectors size);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (aClass theNonMetaClass linesOfCode);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 6/30/2022 16:12:31' prior: 50354804!
  annotationForSelector: aSelector ofClass: aClass 
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	^ String streamContents: [ :strm |
		(Preference at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp _ self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						strm
							print: ((aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm | cm linesOfCode]);
							nextPutAll: ' lines of code' ].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount _ Smalltalk numberOfSendersOf: aSelector.
						sendersCount _ sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount _ implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp _ VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						(aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm |
							(CodePackage packageOfMethod: cm methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList _ (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ] ].! !
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354938!
                         annotationForSystemCategory: aCategory
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'System Category: ';
			nextPutAll: aCategory.
		(Preference at: #systemCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#classCount] -> [
					strm
						print: (SystemOrganization listAtCategoryNamed: aCategory) size;
						nextPutAll: ' classes' ].
				[#instanceMethodsCount] -> [
					strm
						print: (SystemOrganization instanceMethodCountOf: aCategory);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (SystemOrganization classMethodCountOf: aCategory);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (SystemOrganization linesOfCodeOf: aCategory);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'contents' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354972!
                 contentsSymbol
	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"

	^ contentsSymbol ifNil: [
		contentsSymbol _ (Preference at: #browseWithPrettyPrint)
					ifTrue:
						[#prettyPrint]
					ifFalse:
						[#source]]! !
!CodeProvider methodsFor: 'diffs' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354987!
       defaultDiffsSymbol
	"Answer the code symbol to use when generically switching to diffing"

	^ (Preference at: #diffsWithPrettyPrint)
		ifTrue: [
			#prettyLineDiffs]
		ifFalse: [
			#lineDiffs]! !
!Browser methodsFor: 'class functions' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356752!
   classCommentText
	"return the text to display for the comment of the currently selected class"
	| theClass |
	theClass _ self selectedClassOrMetaClass.
	^ Text
		initialFont: (Preference at: #standardCodeFont)
		stringOrText:
			((theClass notNil and: [ theClass hasComment ])
				ifTrue: [ theClass comment ]
				ifFalse: [ '' ]).! !
!Browser methodsFor: 'class functions' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354996!
                         createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"
	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		aClass instVarNames do: [ :aName | | newMessage setter |
			(aClass canUnderstand: aName asSymbol) ifFalse: [
				newMessage _ aName , '
	"Answer the value of ' , aName , '"

	^ ' , aName.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ].
			(aClass canUnderstand: (setter _ aName , ':') asSymbol) ifFalse: [
				newMessage _ setter , ' anObject
	"Set the value of ' , aName , '"

	' , aName , ' ' ,
					((Preference at: #leftArrowAssignmentsInGeneratedCode)
						ifTrue: [ '_' ]
						ifFalse: [ ':=' ]) , ' anObject'.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ]]]! !
!Browser class methodsFor: 'class list' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355029!
                              disableListClassesHierarchically
	
	^Preference at: #listClassesHierarchically put: false! !
!Browser class methodsFor: 'class list' stamp: 'jmv 6/30/2022 16:12:31' prior: 50355035!
          enableListClassesHierarchically
	
	^Preference at: #listClassesHierarchically put: true! !
!Browser class methodsFor: 'class list' stamp: 'jmv 6/30/2022 16:12:29' prior: 50355041!
            listClassesHierarchically
	
	^Preference at: #listClassesHierarchically! !
!CodeFileBrowser methodsFor: 'edit pane' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355047 overrides: 16796178!
       selectedMessage
	"Answer a copy of the source code for the selected message selector."

	| class selector answer |
	class _ self selectedClassOrMetaClass.
	selector _ self selectedMessageName.
	answer _ class sourceCodeAt: selector.
	(self classOrMetaClassOrganizer isRemoved: selector) ifTrue: [
		^ Text
			string: answer
			attribute: TextColor red ].
	(Preference at: #browseWithPrettyPrint) ifTrue: [
		answer _ class compilerClass new
						format: answer in: class notifying: nil ].
	self showingAnyKindOfDiffs ifTrue: [
		answer _ self
			methodDiffFor: answer
			selector: self selectedMessageName ].
	^ answer! !
!ChangeList methodsFor: 'initialization-release' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355071 overrides: 16920235!
                           initialize
	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"

	contentsSymbol _ (Preference at: #diffsInChangeList)
		ifTrue:
			[self defaultDiffsSymbol]
		ifFalse:
			[#source].
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	super initialize! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356766!
            compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| change class s1 s2 differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	change _ changeList at: listIndex.
	((class _ change changeClass) notNil
			and: [class includesSelector: change methodSelector])
		ifTrue: [
			s1 _ (class sourceCodeAt: change methodSelector) asPlainString.
			s2 _ change string.
			s1 = s2
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords _ self shouldDiffWords.
			differDesc _ diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: s1 to: s2
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: (Preference at: #standardCodeFont)))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!Debugger class methodsFor: 'class initialization' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355086!
                    openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	<primitive: 19> "Simulation guard"

	(self errorRecursion not and: [Preference at: #logDebuggerStackToFile]) ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	ErrorRecursion ifTrue: [
		ErrorRecursion _ false.
		contentsStringOrNil
			ifNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString]
			ifNotNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString, String newLineString, contentsStringOrNil ]].
	ErrorRecursion _ true.
	[self informExistingDebugger: aContext label: aString.
	(Debugger context: aContext)
		openNotifierContents: contentsStringOrNil
		label: aString.] ensure: [ ErrorRecursion _ false ].
	Processor activeProcess suspend.
! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355122!
            openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	debugger
		process: interruptedProcess
		context: interruptedProcess suspendedContext.
	debugger externalInterrupt: true.

	(Preference at: #logDebuggerStackToFile) ifTrue:
		[(aString includesSubString: 'Space') & 
			(aString includesSubString: 'low') ifTrue: [
				Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug']].

	^ debugger
		openNotifierContents: nil
		label: aString
! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355149!
                 openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	(Preference at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!FileList methodsFor: 'initialization' stamp: 'jmv 6/30/2022 16:12:31' prior: 50355997!
        initialDirectoryList

	| initialDirectoryListFromPreferences wrapperCreator |
	wrapperCreator _ [ :directoryEntry |
		FileDirectoryWrapper
			with: directoryEntry
			name: (directoryEntry name ifNil: [ '/' ])
			model: self ].
	(initialDirectoryListFromPreferences _ Preference at: #initialFileListDirectories) 
		caseOf: {
			[ #roots ] -> [ 	| dirList |
				dirList _ DirectoryEntry roots collect: wrapperCreator.
				dirList isEmpty ifTrue: [
					dirList _ Array with: (FileDirectoryWrapper 
						with: directory
						name: directory localName 
						model: self) ].
				^ dirList ].
			[ #image ] -> [ 
				^ { wrapperCreator value: DirectoryEntry smalltalkImageDirectory } ].
			[ #vm  ] -> [ 
				^ { wrapperCreator value: DirectoryEntry vmDirectory } ].
			[ #current ] -> [
				^ { wrapperCreator value: DirectoryEntry currentDirectory } ] }
		otherwise: [ ^ initialDirectoryListFromPreferences collect: wrapperCreator ]! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356802!
                        fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font _ Preference at: #standardListFont.
	spaceWidth _ font widthOf: $ .
	nameStr _ entry isDirectory
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd _ namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr _ nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr _ (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits _ entry fileSize printString size.
	sizeStr _ entry fileSize printStringWithCommas.
	sizeDigitsAndCommas _ sizeStr size.
	spacesToAdd _ sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd _ spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr _ (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces _ String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356862!
                    listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject
	"Make the list be those file names which match the patterns."

	| sizePad selected newList namePad sizeWithCommasPad font |
	directory ifNil: [^#()].
	selected _ Set new.
	patternsThatSelect do: [ :pat |
		directory childrenDo: [ :entry |
			(entry isDirectory
				ifTrue: [ showDirsInFileList ]
				ifFalse: [ self doesPattern: pat allow: entry])
					ifTrue: [ selected add: entry ]]].
	newList _ selected copy.
	patternsThatReject do: [ :pat |
		selected do: [ :entry |
			(entry isDirectory not and: [ pat match: entry name]) ifTrue: [
				newList remove: entry ]]].
		
	newList _ newList asArray sort: self sortBlock.
	font _ Preference at: #standardListFont.
	namePad _ newList inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printString size.
	sizeWithCommasPad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printStringWithCommas size.
	newList _ newList collect: [ :e |
		self fileNameFormattedFrom: e namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad ].
	^ newList! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 6/30/2022 16:12:31' prior: 50356903!
                 computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: (Preference at: #aaFontsColormapDepth).
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: `Color white` ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355200!
                       whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |

	(Preference at: #thoroughSenders)
		ifTrue: [ who _ self thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte ]
		ifFalse: [ 
			who _ Set new.
			self selectorsAndMethodsDo: [:sel :method |
				((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]]) ifTrue: [
					((literal isVariableBinding) not or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
						or: [(method indexOfLiteral: literal) ~= 0]]) ifTrue: [who add: sel]]]].
		
	^self rejectSelectorsFrom: who thatReferenceTo: literal byte: specialByte ! !
!Message methodsFor: 'stub creation' stamp: 'jmv 6/30/2022 16:12:31' prior: 50355231!
                              addSetterCodeOn: stream 
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ((Preference at: #leftArrowAssignmentsInGeneratedCode)
			ifTrue: [ ' _ ' ]
			ifFalse: [ ' := ' ]);
		nextPutAll: self arguments first argumentName ! !
!SystemDictionary methodsFor: 'image, changes name' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357751!
                         defaultUserChangesName
	"Answer the default full path to the changes file corresponding to the image file name."
	"
	Smalltalk defaultUserChangesName
	"
	^(FileIOAccessor default baseNameFor: self imageName), 
		(Preference at: #userChangesFileNameExtension)! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356030!
                           handleUserInterrupt
	| p |
	"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
	p _ UISupervisor newUIProcessIfNeeded.
	p ifNil: [
		p _ Sensor shiftPressed | (Preference at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preference at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		p == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(p name beginsWith: '[system]') ifTrue: [
			 ('Process {', p printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			p isTerminated
				ifTrue: [ ('Process {', p printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ UISupervisor userInterrupt: p ]] fork
		]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355243!
                        logError: errMsg inContext: aContext to: baseFilename
	"Log the error message and a stack trace to the given file.
	Smalltalk logError: 'test error message' inContext: thisContext to: 'testErr.txt'
	"

	| localFilename file |
	localFilename _ (Preference at: #debugLogTimestamp)
		ifTrue: [ baseFilename, '-', Utilities dateTimeSuffix, '.log' ]
		ifFalse: [ baseFilename, '.log' ].
	file _ DirectoryEntry smalltalkImageDirectory // localFilename.
	[
		file forceWriteStreamDo: [ :stream |
	 	 	stream nextPutAll: errMsg; newLine.
			aContext errorReportOn: stream ]
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"
	[
 	 	StdIOWriteStream stdout newLine; nextPutAll: errMsg.
		StdIOWriteStream stdout newLine; nextPutAll: 'See '; nextPutAll: file pathName.
		StdIOWriteStream stdout newLine.
		aContext shortErrorReportOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout flush
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 6/30/2022 16:12:31' prior: 50356062!
                     abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal _ 0.  bCount _ 0.
	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		Smalltalk allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount _ bCount + 1).
			cl selectors do: [:selector |
				m _ cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	Smalltalk allBehaviorsDo: [:b | b zapOrganization].
	Smalltalk closeSourceFiles.
	Preference at: #warnIfNoChangesFile put: false.
	Preference at: #warnIfNoSourcesFile put: false! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353538!
            reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preference at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356100!
 askConfirmationOnQuit
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk askConfirmationOnQuit
	"
	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSet allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges ]].
	"dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ]."
	dirtyPackages _ ChangeSet allChangeSets anySatisfy: [ :any | any codePackage notNil and: [ any hasUnsavedChanges ]].
	baseCSdirty & dirtyPackages ifTrue: [
		^self confirm: 'There are both unsaved Packages', String newLineString,
			'and unsaved Changes to Cuis core.', String newLineString,
			'If you continue, all unsaved changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	dirtyPackages ifTrue: [
		^self confirm: 'There are unsaved Packages.', String newLineString,
			'If you continue, their changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	(Preference at: #askConfirmationOnQuit) ifTrue: [
		^self confirm: 'Do you really want to exit Cuis without saving the image?' ].
	^true! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356149!
  setPlatformPreferences
	"Set some platform specific preferences on system startup"
	| platform specs |
	(Preference at: #automaticPlatformSettings) ifFalse:[^self].
	platform _ self platformName.
	specs _ 	#(	
					(soundStopWhenDone false)
					(soundQuickStart false)
			).
	platform = 'Win32' ifTrue:[
		specs _ #(	
					(soundStopWhenDone true)
					(soundQuickStart false)
				)].
	platform = 'Mac OS' ifTrue:[
		specs _ #(	
					(soundStopWhenDone false)
					(soundQuickStart true)
				)].
	specs do: [:tuple |
		Preference name: tuple first category: #system value: (tuple last == #true) 	]
! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356172!
assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	(Preference at: #autoNumberUserChanges) ifTrue: [
		oldUserChanges _ Smalltalk defaultUserChangesName asFileEntry.
		oldUserChanges exists ifTrue: [
			directory _ oldUserChanges parent.
			oldUserChangesName _ directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine ].
	StartupStamp _ nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356205!
       openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or Lf/CrLf mixups."
	"Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes msg wmsg entry |
	msg _ 'Cuis cannot locate XfileRef
Please check that the file is named properly and is in the
same directory as this image.'.
	wmsg _ 'Cuis cannot write to XfileRef.

Please check that you have write permission for this file.

You won''t be able to save this image correctly until you fix this.'.

	"Do not open source files if internalized (i.e. notNil)"
	sources _ SourceFiles at: 1.
	sources ifNil: [
		entry _ Smalltalk defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry _ Smalltalk alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources _ [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preference at: #warnIfNoSourcesFile ])
		ifTrue: [
			Smalltalk platformName = 'Mac OS' ifTrue: [
				msg _ msg , String newLineString, 'Make sure the sources file is not an Alias.'].
			self inform: (msg copyReplaceAll: 'XfileRef' with: 'the sources file named ' , entry pathName) ].

	"Do not open source files if internalized (i.e. notNil)"
	changes _ (SourceFiles at: 2) ifNil: [ 
		entry _ Smalltalk defaultChangesName asFileEntry.
		[ entry appendStream ] on: FileWriteError do: [ nil ] ].
	(changes isNil and: [Preference at: #warnIfNoChangesFile])
		ifTrue: [self inform: (wmsg copyReplaceAll: 'XfileRef' with: 'the changes file named ' , entry pathName)].
	ChangesInitialFileSize _ changes ifNotNil: [ changes position ].

	SourceFiles _ Array with: sources with: changes! !
!SystemDictionary methodsFor: 'ui' stamp: 'jmv 6/30/2022 16:12:30' prior: 50393494!
beep
	"
	Smalltalk beep
	"
	Preference soundsEnabled ifTrue: [
		Smalltalk
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'jmv 6/30/2022 16:12:31' prior: 50356264!
      hasToRestoreChanges

	^(Preference at: #checkLostChangesOnStartUp) and: [ 
		self withChangesFileDo: [ :changesFile | self hasToRestoreChangesFrom: changesFile ]].
	! !
!Exception methodsFor: 'priv handling' stamp: 'jmv 6/30/2022 16:12:29' prior: 50356273!
                               evaluateHandlerBlock: aBlock

	| handlerEx |
	handlerBlockNotCurtailed := false.
	^[
			| answer |
			answer _ [aBlock valueWithPossibleArgument: self] on: Exception do: [:ex | handlerEx _ ex.  ex pass].
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			handlerBlockNotCurtailed _ true.
			answer
	] ifCurtailed:
		[
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			(handlerBlockNotCurtailed not and: [handlerEx isNil or: [handlerEx handlerBlockNotCurtailed not]])
				ifTrue: [
					"Please see
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000800.html
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000809.html
					Also see the rest of the tread in detail.
					This is work in progress."
					(Preference at: #allowNonLocalReturnsInExceptionHandlers)
						ifFalse: [ self error: 'Exception handler blocks must not do non local returns' ]
						ifTrue: [
							(Preference at: #warnAboutNonLocalReturnsInExceptionHandlers)
								ifTrue: [ 'It is advisable to avoid method returns (non local returns) in exception handler blocks' print ].
							handlerBlockNotCurtailed _ true ].
					]
				ifFalse: [handlerBlockNotCurtailed _ true]
		]! !
!NegativePowerError methodsFor: 'exceptionDescription' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356319 overrides: 16780646!
                        defaultAction

	"Disable this preference to have Float nan answer (if Float receiver or argument) or Error message"
	| answer |
	(Preference at: #askToInstallComplexPackage) ifTrue: [
		answer _ PopUpMenu
			withCaption:
'Square (or even) Root of a negative Number:
Complex number support is not loaded
Would you like me to load it for you now?'
			chooseFrom: #(
				'Load Complex package'
				'Do not load Complex package'
				'Do not load Complex package and don''t ask again').
		answer = 1 ifTrue: [
			Feature require: #'Complex'.
			Smalltalk at: #Complex ifPresent: [ :cplx |
				^ (cplx basicReal: receiver imaginary: 0) perform: selector withArguments: arguments ]].
		answer = 3 ifTrue: [
			(Preference at: #askToInstallComplexPackage put: false)]].
	^ super defaultAction! !
!Parser methodsFor: 'scanning' stamp: 'jmv 6/30/2022 16:13:25' prior: 50358427!
                            transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a series of consecutive vertical bars, up arrows, colons and regular binary selector characters.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain.
	Another special case is binary selectors ending in $-, like in
	1@-2
	This could be interpreted as `1 @ -2` or `1 @- 2`. Preference #atMinusDigitMeaning tells what to do."

	| toMakeBinary |
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	"Note: Also include #binary, to allow stuff like #+| where a special character comes after after a regular binary operator character. "
	toMakeBinary _ #(binary verticalBar upArrow colon).
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here _ here asPlainString.
	hereType _ #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			(token == #- and: [source peekBack isDigit])
				ifTrue: [
					(Preference at: #atMinusDigitMeaning) == #disabled
						"Disallow `1@-2`. Insists on some whitespace to disambiguate."
						ifTrue: [ ^self expected: 'A space character after selector' ].
					(Preference at: #atMinusDigitMeaning) == #st80
						ifTrue: [ ^self ].				"interpret `1@-2` like `1 @ -2`"
					"Assume (Preference at: #atMinusDigitMeaning) == #ansiSmalltalk
					interpret `1@-2` like `1 @- 2`, i.e. consider #@- a valid binary selector"
					].
			here _ here , token asPlainString.
			hereEnd _ hereEnd + 1.
			self scanToken ].! !
!BlockNode methodsFor: 'printing' stamp: 'jmv 6/30/2022 16:12:31' prior: 50355277 overrides: 16906201!
                            printOn: aStream indent: level
	| separateLines |
	aStream nextPut: $[.
	self
		printArgumentsOn: aStream
		indent: level.
	separateLines _ (self
		printTemporaries: temporaries
		on: aStream
		doPrior: [ aStream space ]) or: [arguments notNil and: [arguments notEmpty] ].
	(Preference at: #prettyPrintRectangularBlocks)
		ifTrue: [
			"If args+temps > 0 and statements > 1 (or just one complex statement),
			put all statements on separate lines"
			separateLines
				ifTrue: [
					(statements size > 1 or: [
						statements size = 1 and: [ statements first isComplex ]])
							ifTrue: [ aStream newLineTab: (1 max: level) ]
							ifFalse: [ aStream space ] ]
				ifFalse: [
					(statements size = 1 and: [ statements first isComplex not ])
						ifTrue: [ aStream space ]]]
		ifFalse: [
			self isComplex
				ifTrue: [ aStream newLineTab: (1 max: level) ]
				ifFalse: [ aStream space ] ].
	((self printStatementsOn: aStream indent: level) > 0 and: [ aStream peekLast ~= $] ])
		ifTrue: [ aStream space ].
	aStream nextPut: $]! !
!BlockNode methodsFor: 'testing' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355313 overrides: 16906470!
             printsInNewLine
	"Used for pretty printing to determine whether to start a new line"

	(Preference at: #prettyPrintRectangularBlocks) ifFalse: [ ^false ].
	^super printsInNewLine! !
!TempVariableNode methodsFor: 'testing' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355323 overrides: 16977637!
                             assignmentCheck: encoder at: location
	^((self isBlockArg and: [(Preference at: #allowBlockArgumentAssignment) not])
	    or: [self isMethodArg])
			ifTrue: [location]
			ifFalse: [-1]! !
!Editor methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356347!
                     setIndices: shiftPressed forward: forward
	"Little helper method that sets the moving and fixed indices according to some flags."
	| indices |
	indices _ Dictionary new.
	(shiftPressed and:[Preference at: #selectionsMayShrink])
		ifTrue: [
			indices at: #moving put: self pointIndex.
			indices at: #fixed put: self markIndex
		] ifFalse: [
			forward
				ifTrue:[
					indices at: #moving put: self stopIndex.
					indices at: #fixed put: self startIndex.
				] ifFalse: [
					indices at: #moving put: self startIndex.
					indices at: #fixed put: self stopIndex.
				]
		].
	^indices! !
!TextEditor methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356369!
                              findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where _ model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [Preference at: #caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 6/30/2022 16:12:31' prior: 50355332!
        browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry |
	(Preference at: #alternativeBrowseIt) ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol _ self selectedSymbol ifNil: [
		self
			evaluateSelectionAndDo: [ :result | result class name ]
			ifFail: [ ^morph flash ]
			profiled: false].

	aSymbol first isUppercase
		ifTrue: [
			anEntry _ (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry _ anEntry class].
			BrowserWindow fullOnClass: anEntry selector: nil]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !
!Preference class methodsFor: 'event handlers' stamp: 'jmv 6/30/2022 16:12:30' prior: 50394395!
                         defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preference name: #standardListFont category: #font value: font.
	Preference name: #standardMenuFont category: #font value: font.
	Preference name: #standardCodeFont category: #font value: font.
	Preference name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preference name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preference at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font
" Copied to PreferenceSet "! !
!Preference class methodsFor: 'event handlers' stamp: 'jmv 6/30/2022 16:12:31' prior: 50394430!
                          machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray |
	prefArray _ self perform: (#machine, machinePref value capitalized) asSymbol.
	prefArray do: [:array | 		Preference at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]
" Copied to PreferenceSet "! !
!Preference class methodsFor: 'event handlers' stamp: 'jmv 6/30/2022 16:12:30' prior: 50394452!
                           pointer: pointerPref
	| enabled |
	enabled _ pointerPref value == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 		Preference at: aPref put: enabled]
" Copied to PreferenceSet "! !
!Preference class methodsFor: 'fonts' stamp: 'jmv 6/30/2022 16:12:30' prior: 50394472!
                              setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	Preference
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (Preference at: #standardListFont) pointSize.}.
				{#standardMenuFont. (Preference at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (Preference at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (Preference at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (Preference at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
" Copied to PreferenceSet "! !
!Preference class methodsFor: 'fonts' stamp: 'jmv 6/30/2022 16:12:30' prior: 50394499!
         setDefaultFont: fontFamilyName spec: defaultFontsSpec
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font _ font emphasized: triplet third ].
		Preference at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
" Copied to PreferenceSet "! !
!PreferenceSet methodsFor: 'instance creation' stamp: 'jmv 6/30/2022 16:12:30' prior: 50393720!
                               name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
"If I exist, I am updated with the newer sent data "
	(nameSymbol isSymbol or: [categorySymbol isSymbol]) ifFalse: 
		[self error: 'Preference Name & Category are not valid symbol.'].
	^ contents 
		at: nameSymbol
		ifPresent: [:thePref |
			thePref 
				description: aString;
				category: categorySymbol;
				value: aValue;
				yourself]
		ifAbsent: [ | newPref |
			newPref _ Preference new ::
				name: nameSymbol 
				description: aString 
				category: categorySymbol 
				type: aType 
				value: aValue.
			contents at: nameSymbol put: newPref ].
	! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 6/30/2022 16:12:30' prior: 50394086!
                     installDefault: anArray in: category
" Description of preference in Array: name - value - type (optional) - event handler (optional) "
	| myPref |
	myPref _ self sysPreferences 
		name: anArray first 
		description: '' 
		category: category 
		type: (anArray at: 3 ifAbsent: [Preference detectType: anArray second]) value: anArray second.
		
	anArray size = 4 ifTrue: [ "fourth record is an event listener hooked to Preference"
		myPref when: #preferenceChanged send: anArray fourth to: PreferenceSet.
		myPref triggerEvent: #preferenceChanged with: myPref]
	! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 6/30/2022 16:12:30' prior: 50394128!
          installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	self sysPreferences 

		name: #haloHandleSize 
		category: #gui 
		value: [(Preference at: #standardListFont) pointSize * 5 // 3 max: 16];
	
		name: #roundedButtonRadius 	
		category: #gui 
		value: [(Preference at: #standardListFont) pointSize * 8 // 14];
		
		name: #roundedWindowRadius 	
		category: #gui 
		value: [(Preference at: #standardListFont) pointSize] ;
		
		name: #scrollbarThickness 
		category: #gui 		
		value: [(Preference at: #windowTitleFont) pointSize + 2];
		
		name: #classFinder 
		category: #programming 
		value: [ BrowserWindow findClass ];
		
		name: #defaultAuthorName 
		category: #programming 
		value: [Utilities authorName].! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'jmv 6/30/2022 16:12:30' prior: 50394231!
                           defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preference name: #standardListFont category: #font value: font.
	Preference name: #standardMenuFont category: #font value: font.
	Preference name: #standardCodeFont category: #font value: font.
	Preference name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preference name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preference at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356979!
            standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| grid allowedArea maxLevel |
	"NOTE: following copied from strictlyStaggeredInitialFrameFor:"
	allowedArea _ self maximumUsableArea insetBy: (
		self scrollBarSetback @ self screenTopSetback extent: `0@0`
	).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
	^ ((allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) 
		min: `52@40` * (Preference at: #standardCodeFont) lineSpacing) rounded! !
!Cursor class methodsFor: 'accessing' stamp: 'jmv 6/30/2022 16:12:31' prior: 50353606!
        defaultCursor
	"Answer the instance of me that is the shape of an arrow slanted left."
	^ (Preference at: #biggerCursors)
		ifTrue: [ CursorWithAlpha biggerNormal ]
		ifFalse: [ self cursorAt: #normalCursorWithMask ].! !
!Cursor class methodsFor: 'current cursor' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353616!
       currentCursor: aCursor 
	"Make the instance of cursor, aCursor, be the current cursor. Display it. 
	Create an error if the argument is not a Cursor."

	CurrentCursor _ aCursor.
	(Preference at: #biggerCursors)
		ifTrue: [
			[ ^aCursor asBigCursor installCursor] 
				on: Error do: nil  "fall through "].
	aCursor installCursor! !
!BitBltCanvasEngine methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357003!
                         setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: `Color transparent`).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			(Preference at: #subPixelRenderFonts) and: [ foregroundColor = `Color black` or: [ 
				(Preference at: #subPixelRenderColorFonts) and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= `Color black` or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preference at: #properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = `Color black` ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display."
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355359!
                      syntheticST80Glyphs
	"Build and answer a derivative that includes ST-80 glyphs:
	a left arrow instead of the underscore, and an up arrow instead of the caret."

	| derivative |
	derivative _ self copy.
	derivative
		name: self name , 'ST80';
		perform: (Preference at: #assignmentGlyphSelector).
	^ derivative! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 6/30/2022 16:12:29' prior: 50355372!
               displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos x1 |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastIndex _ line first.
	tabCount _ 0.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions.
		backgroundColor ifNotNil: [
			x1 _ destX.
			((Preference at: #backgroundColorFillsAllBackground) and: [startIndex > line last]) ifTrue: [
				x1 _ rightMargin ].
			canvas
				fillRectangle: (lastPos corner: x1 @ (line bottom + textTopLeft y))
				color: backgroundColor.
			((Preference at: #backgroundColorFillsAllBackground) and: [stopCondition = #tab]) ifTrue: [
				canvas
					fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
					color: backgroundColor ]].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 6/30/2022 16:12:30' prior: 50358085!
                               promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				fontFamily includesAscii
					ifTrue: [Preference setDefaultFont: fontFamily familyName ]
					ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]]]].! !
!Morph methodsFor: 'events' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353629!
                       mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."

	(Preference at: #focusFollowsMouse)
		ifTrue: [evt hand releaseKeyboardFocus: self].
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: evt ].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353646!
            displayBoundsForHalo
	"Answer the rectangle to be used as the inner dimension of my halos.
	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."

	^ (Preference at: #haloEnclosesFullBounds)
		ifFalse: [ self displayBounds ]
		ifTrue: [ self displayFullBounds ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 6/30/2022 16:12:31' prior: 50353659!
              addHandlesTo: aHaloMorph box: box
	"Add halo handles to the halo.  Apply the halo filter if appropriate"

	(Preference at: #haloSpecifications) do: [ :aSpec |
		(self
			wantsHaloHandleWithSelector: aSpec addHandleSelector
			inHalo: aHaloMorph) ifTrue: [
		aHaloMorph
			perform: aSpec addHandleSelector
			with: aSpec ]].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353675!
                           haloShowsCoordinateSystem

	^Preference at: #halosShowCoordinateSystem! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 6/30/2022 16:12:31' prior: 50353681!
                         wantsBalloon
	"Answer true if receiver wants to show a balloon help text is a few moments."

	^ (self balloonText notNil) and: [Preference at: #balloonHelpEnabled]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353690!
                            wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	(#(addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].

	(Preference at: #selectiveHalos) ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addResizeHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily | self okayToScaleEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addScaleHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToScaleEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !
!HandMorph methodsFor: 'double click support' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353722!
            waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel

	"Wait until the difference between click, or drag gesture is known, then inform the given morph what transpired." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: nil
			dblClick: nil
			dblClickAndHalf: nil
			tripleClick: nil
			event: evt
			sendMouseButton2Activity: (Preference at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'jmv 6/30/2022 16:12:29' prior: 50353744!
              waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel

	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (Preference at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'jmv 6/30/2022 16:12:31' prior: 50353792!
            waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel dragSel: dragSel
	
	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: dragSel
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (Preference at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2022 16:12:31' prior: 50353816 overrides: 16909517!
                              morphPosition: aPoint
	"Change the position of this morph. Argument is in owner's coordinates."

	| prevTranslation |
	prevTranslation _ location translation.
	location _ location withTranslation: aPoint.
	"Ask if translation effectively changed, after possible conversion to 32 bit Float in AffineTransformation. "
	location translation = prevTranslation ifFalse: [
		self isDrawnBySoftware
			ifTrue: [
				(Preference at: #cacheDisplayContentWhenMovingMorphs)
					ifTrue: [
						"We are caching whatever is in the Display below us. Thefore, there's no need
						to do an invalidation that would trigger the redraw of everything below us."
						self needsRedraw: true ]
					ifFalse:  [
						"No caching of stuff below us. Just invalidate and redraw."
						self redrawNeeded ]]
			ifFalse: [
				lastPosition _ nil.		"Not nil if carrying morphs at that moment"
				prevFullBounds _ nil "Any saved patch is no longer relevant"]].! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353849!
                           generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp mouseScrollDirection |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [
		(keyValue = 9 and: [(modifiers anyMask: 1) and: [Smalltalk platformName = 'unix']])
			ifTrue: [
				"Linux VMs don't generate shift-tab keystroke. Turn #keyUp into #keystroke"
				pressType _ EventSensor eventKeyChar ]
			ifFalse: [type _ #keyUp ]].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [ 											"Control key pressed"
			keyValue < 27 ifTrue: [ 										"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [   									"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [ 			"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96   						"shift not pressed: conver to lowercase letter" ]]]].
			"On Windows, ctrl-backSpace is reported as ctrl-forwardDelete. But keyDown is ok, so we can know and fix."
			(keyValue = 127 and: [ lastKeyDownValue = 8 ])
				ifTrue: [ keyValue _ 8 ].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]].
		(modifiers anyMask: 8) ifTrue: [ 									"CmdAlt key pressed (or Control key pressed, and #shouldControlEmulateAltFor: just answered true)"
			(modifiers anyMask: 1) ifTrue: [								"Shift pressed"
				| i |
				"It seems that for ctrl-shifted keys and cmd-shifted keys, the VM incorrectly reports the UNSHIFTED character.
				Correct this, at least for common cmd-shortcuts, and for the US keyboard... Sigh...
				(This has only been observed on Mac VMs, but seems harmless if proper shifted character is reported (as in Linux), as this wil be NOP)
				(On Windows, the situation is even worse: ctrl-{ is not even reported as a keystroke event. Only keyDown and keyUp.)"
				"#($' $, $. $9 $0 $[ $]) -> #($'' $< $> $( $) ${) $}"
				i _ #[39 44 46 57 48 91 93 ] indexOf: keyValue.
				i > 0 ifTrue: [
					keyValue _ #[34 60 62 40 41 123 125] at: i ]]]].
	buttons _ modifiers bitShift: 3.
	"Linux and Windows VM send keyboard ctrl-upArrow and ctrl-downArrow when the user tries to scroll using the mouse wheel
	Mac VM sends cmd-option-ctrl-shift-upArrow and cmd-option-ctrl-shift-downArrow for trackpad vertical scroll gestures,
		and cmd-option-ctrl-shift-leftArrow and cmd-option-ctrl-shift-rightArrow for horizontal scroll gestures.
	This way of reporting scroll events by the VM also enables scrolling using the keyboard (actually, we can't tell if user gesture was on Mouse, Trackpad or Keyboard).
	But ctrl-shift and cmdAlt-shift are needed used for selecting while moving by word, line, etc.
	Additionally, #ctrlArrowsScrollHorizontally allows chosing between keyboard horizontal scroll and moving word by word in text editors."
	mouseScrollDirection _ nil.
	"Ctrl for Keyboard or Mouse wheel gestures. All modifiers for Trackpad gestures."
	(buttons = InputSensor controlKey or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 30
			ifTrue: [mouseScrollDirection _ #up]
		ifFalse: [keyValue = 31
			ifTrue: [mouseScrollDirection _ #down]]].
	"Ctrl for Keyboard or Mouse wheel gestures, only if preference is set. All modifiers for Trackpad gestures."
	((buttons = InputSensor controlKey and: [Preference at: #ctrlArrowsScrollHorizontally]) or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 28
			ifTrue: [mouseScrollDirection _ #left]
		ifFalse: [keyValue = 29
			ifTrue: [mouseScrollDirection _ #right]]].
	mouseScrollDirection ifNotNil: [
		^ MouseScrollEvent new
			setType: #mouseScroll
			position: self morphPosition
			direction: mouseScrollDirection
			buttons: buttons
			hand: self
			stamp: stamp ].
	^ KeyboardEvent new
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!WorldMorph methodsFor: 'drawing' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357907!
                        displayWorld
	"Update this world's display."

	| deferredUpdateVMMode allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time. ?? revisar."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"Restore world canvas under hands and their carried morphs"
	(Preference at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		hands do: [ :h | h restoreSavedPatchOn: canvas ]].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	canvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage _ canvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	canvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self handsToDrawForDamage: allDamage do: [ :h |
		(Preference at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage _ (h savePatchFrom: canvas) quickMerge: allDamage ]
			ifFalse: [ allDamage _ h displayFullBoundsForPatch quickMerge: allDamage ].
		canvas fullDrawHand: h .
		h needsRedraw: false ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		allDamage ifNotNil: [
			"Drawing was done to off-Display canvas. Copy content to Display"
			canvas showAt: self viewBox origin invalidRect: allDamage ]].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	allDamage ifNotNil: [
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: allDamage ]].! !
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 6/30/2022 16:12:30' prior: 50361279!
        doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(Preference at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	canvas ensureCurrentMorphIsWorld.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow.! !
!WorldMorph methodsFor: 'world menu' stamp: 'jmv 6/30/2022 16:12:29' prior: 50357581!
         invokeWorldMenu
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	| menu |
	menu _ (TheWorldMenu new 
		world: self
		hand: self activeHand) buildWorldMenu.
	menu addTitle: Preference desktopMenuTitle.
	menu popUpInWorld: self! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 6/30/2022 16:12:31' prior: 50354091 overrides: 16878712!
         adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(Preference at: #cheapWindowReframe) or: [millisecondSinceLast > 200]]) ifTrue: [
			owner displayBounds newRectFrom: [ :f |
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner morphExtentInWorld ]].! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357080!
                          addTitle: aString
	| titleMorph s pp w |
	titleMorph _ BoxedMorph new noBorder.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line |
		s _ LabelMorph new
			contents: line;
			font: (Preference at: #standardMenuFont) bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 24) @ (pp y).
	self addMorphKeepMorphHeight: titleMorph.
	^titleMorph morphWidth! !
!StringRequestMorph methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354112!
                          getUserResponseOrCancel: aBlock
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."
	| w delay done canceled |
	w _ self world.
	w isNil ifTrue: [^ response asString].
	done _ false.
	canceled _ false.
	(Preference at: #focusFollowsMouse) ifFalse: [self textBox focusText].
	acceptBlock _ [:aString| done _ true].
	cancelBlock _ [done _ true. canceled _ true].
	delay _ Delay forMilliseconds: 10.
	[done not and: [self isInWorld]] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	canceled ifTrue: [^ aBlock value].
	^ response asString! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354143!
                      request: queryString centeredAt: aPoint initialAnswer: defaultAnswer validationBlock: validationBlock acceptBlock: acceptBlock cancelBlock: cancelBlock
	| answer |
	answer _ self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer;
		validationBlock: validationBlock;
		acceptBlock: acceptBlock;
		cancelBlock: cancelBlock.
	self runningWorld addMorph: answer centeredNear: aPoint - self deltaToTextPane.
	(Preference at: #focusFollowsMouse) ifFalse: [answer textBox focusText].
	^ answer! !
!StringRequestMorph class methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357101!
      deltaToTextPane
	"Answer a distance to translate an instance of the receiver by when it is opened in the world in order to have the hand be over the text pane (so the text pane has focus).
	Distance is relative to font size"
	| e |
	e _ (Preference at: #windowTitleFont) lineSpacing.
	^ (0)@(0.5 * e)! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357114!
                    defaultHeight

	^ ((Preference at: #windowTitleFont) lineSpacing * 2 * self scale) asInteger! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355467!
              addDebugHandle: handleSpec

	(Preference at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doDebug:with: ]
! !
!HaloMorph methodsFor: 'handles' stamp: 'jmv 6/30/2022 16:12:31' prior: 50355475!
                           addExploreHandle: handleSpec

	(Preference at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doExplore:with: ]
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357593!
                       addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient. Return the handle."

	| handle aPoint colorToUse form icon e |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	e _ (Preference at: #haloHandleSize) asPoint.
	handle morphPosition: aPoint-(e//2) extent: e.
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				form extent = e ifFalse: [ 
					": Non default size, scale that bugger!!"
					form _ form  ": Be as smooth as possible, these images are small."
						magnify: form boundingBox
						to: e
						smoothing: 2 ].
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^ handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357634!
        addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph verticalNamePosition namePosition nameBackground |
	nameBackground _ BoxedMorph new noBorder
		color: ((target is: #SystemWindow)
			ifTrue: [target windowColor]
			ifFalse: [`Color lightBlue alpha: 0.9`]).
	nameMorph _ LabelMorph contents: aString.
	nameMorph color: `Color black`.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	verticalNamePosition _ haloBox bottom + (Preference at: #haloHandleSize).
	namePosition _ haloBox width - nameMorph morphWidth // 2 + haloBox left @ verticalNamePosition.
	self addMorph: nameBackground.
	nameBackground morphPosition: namePosition - 2.
	self addMorph: nameMorph.
	nameMorph morphPosition: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357662!
         handlesBox
	"handlesBox is in local coordinates.
	We assume we are direct submorph of the world, without any scaling or rotation."

	| minSide hs c e box |
	hs _ Preference at: #haloHandleSize.
	minSide _ 4 * hs.
	e _ extent + (hs*2) max: minSide@minSide.
	c _ extent // 2 + self morphPosition.
	box _ Rectangle center: c extent: e.
	self world ifNotNil: [ :w | box _ box intersect: (w viewBox insetBy: (hs@hs corner: hs@(hs*3))) ].
	"Make it local"
	^box translatedBy: self morphPosition negated.
! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 6/30/2022 16:12:29' prior: 50355484 overrides: 16794207!
                   drawOn: aCanvas

	(Preference at: #showLinesInHierarchyViews) ifTrue:[
		self drawLinesOn: aCanvas ]! !
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2022 16:12:29' prior: 50357121 overrides: 16794195!
      initialize
	super initialize.
	self color: `Color black`.
	font _ Preference at: #standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !
!InnerListMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357130 overrides: 16893209!
                 fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preference at: #standardListFont).! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355491!
 installEditorAndTextComposition
	"Install an editor for my textComposition. Install also the textComposition."
	| e tc |
	
	"Editor and TextComposition are assigned here atomically."
	e _ model editorClass new morph: self.
	e model: model.
	tc _ TextComposition new.
	"Keep critical section short"
	self mutex critical: [
		editor _ e.
		textComposition _ tc.
		tc
			setModel: model;
			extentForComposing: self extentForComposing.
		e textComposition: tc.
		tc editor: e ].
	e setEmphasisHereFromText.
	tc composeAll.
	e resetState.
	self fit.
	self selectionChanged.

	"Add extras. Text Styler and Autocompleter"
	self stylerClass:
		((Preference at: #syntaxHighlightingAsYouType) ifTrue: [
			model textStylerClass ]).
	self autoCompleterClass:
		model autoCompleterClass! !
!LabelMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2022 16:12:30' prior: 50358769 overrides: 16893209!
             fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preference at: #standardListFont).
	self fitContents.! !
!IndentingListItemMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357137 overrides: 50397652!
                 fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preference at: #standardListFont).! !
!IndentingListItemMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357144!
                  initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel

	| o |
	container _ hostList.
	complexContents _ anObject.
	self initWithContents: anObject asString font: (Preference at: #standardListFont) emphasis: nil.
	indentLevel _ 0.
	isExpanded _ false.
 	nextSibling _ firstChild _ nil.
	priorMorph ifNotNil: [
		priorMorph nextSibling: self.
	].
	o _ anObject withoutListWrapper.
	icon _ o ifNotNil: [ (o respondsTo: #icon) ifTrue: [ o icon ] ].
	icon isSymbol ifTrue: [ icon _ Theme current perform: icon ].
	indentLevel _ newLevel.
! !
!UpdatingLabelMorph class methodsFor: 'new-morph participation' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357166 overrides: 16895515!
   initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (Preference at: #windowTitleFont)
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357181 overrides: 16877690!
                               initialize
	"initialize the state of the receiver"
	super initialize.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ Preference at: #standardMenuFont.
	self contents: ''.! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357192!
                  fontToUse
	| fontToUse |
	fontToUse := font ifNil: [Preference at: #standardButtonFont].
	"
	Could add emphasis...
	^(emphasis isNil or: [emphasis = 0]) 
		ifTrue: [fontToUse]
		ifFalse: [fontToUse emphasized: emphasis]
	"
	^fontToUse! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357204 overrides: 16893272!
minimumExtent
	
	| unit |
	unit :=  (Preference at: #windowTitleFont) pointSize.
	^label 
		ifNil: [ (unit+2) @ (unit+2) ] "Assume title button"
		ifNotNil: [ (4 * unit) @ (3 * unit) ] "Assure some space for text."
! !
!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 6/30/2022 16:12:29' prior: 50354163 overrides: 16911743!
              initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ #showIfNeeded.

	"initialize the receiver's scrollBars"
	scrollBar _ ScrollBar new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ ScrollBar new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ Preference at: #drawKeyboardFocusIndicator.
	self addMorph: scrollBar.
	self addMorph: hScrollBar.
	self updateScrollBarsBounds.
	self innerMorphClass ifNotNil: [ :contentsClass |
		self scroller: contentsClass new ].! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 6/30/2022 16:12:29' prior: 50354184 overrides: 16794207!
        drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle 
			borderWidth: (Preference at: #focusIndicatorWidth)
			color: Theme current focusIndicator ]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354197 overrides: 16892287!
 mouseEnter: event
	super mouseEnter: event.
	(Preference at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'drawing' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354205 overrides: 16794207!
             drawOn: aCanvas
	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: (Preference at: #focusIndicatorWidth)
			color: Theme current focusIndicator ].! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354217 overrides: 16892287!
     mouseEnter: event
	super mouseEnter: event.
	(Preference at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357215 overrides: 16912008!
            fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preference at: #standardListFont).! !
!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354225 overrides: 16794207!
             drawOn: aCanvas
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"
	| bw bc |
	self flag: #todo.
	"Integrate this method with the Theme system. --cbr"
	super drawOn: aCanvas.
	bw _ Preference at: #focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [ "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan ]
			ifFalse: [
				scroller hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ]
					ifFalse: [
						scroller hasUnacceptedEdits ifTrue: [ bc _ Color red ]]]].
	(drawKeyboardFocusIndicator and: [ scroller hasKeyboardFocus ])
		ifTrue: [ bc ifNil: [ bc _ Theme current focusIndicator ]]
		ifFalse: [
			bc ifNotNil: [
				bc _ bc
					alphaMixed: 0.4
					with: Color white ]].
	bc ifNotNil: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: bw
			color: bc ].! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354262 overrides: 16892287!
                               mouseEnter: event
	super mouseEnter: event.
	(Preference at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: scroller ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357221!
   drawLabelOn: aCanvas

	| x0 y0 f w availableW l |
	f _ Preference at: #windowTitleFont.
	x0 _  f lineSpacing * 5 + borderWidth.
	y0 _ borderWidth * 6 // 10.
	availableW _ extent x - x0.
	l _ labelString.
	w _ f widthOfString: l.
	[ w > availableW ] whileTrue: [
		l _ l squeezedTo: (1.0 * l size * availableW / w) truncated.
		l isEmpty ifTrue: [ ^self ].
		w _ f widthOfString: l ].
	aCanvas
		drawString: l
		at: x0@y0
		font: f
		color: Theme current windowLabel
		embossed: Theme current embossedTitles! !
!SystemWindow methodsFor: 'events' stamp: 'jmv 6/30/2022 16:12:29' prior: 50356476 overrides: 16892107!
                          wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph"
	^aMorph isWorldMorph or:[Preference at: #systemWindowEmbedOK]! !
!SystemWindow methodsFor: 'label' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357240!
                 labelHeight
	"Answer the height for the window label."
	^ (Preference at: #windowTitleFont) lineSpacing+1! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/30/2022 16:12:31' prior: 50354269!
 addTileResizerMenuTo: aMenu
	"We can look at preferences here to decide what too do"
	(Preference at: #tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 		action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 				action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 		action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 	action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asPlainString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].
	^aMenu.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 6/30/2022 16:12:29' prior: 50356484!
                              closeBoxHit
	"The user clicked on the close-box control in the window title.  For Mac users only, the Mac convention of option-click-on-close-box is obeyed if the mac option key is down."

	(Preference at: #dismissAllOnOptionClose) ifTrue:
		[Sensor rawMacOptionKeyPressed ifTrue:
			[^ self world closeUnchangedWindows]].
	self delete
! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357248 overrides: 16959689!
                     initialExtent

	^`540@400` * (Preference at: #standardCodeFont) lineSpacing // 14! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355519!
                   buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(Preference at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preference at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355544!
                          buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."
	
	| codePane |
	
	codePane := self createCodePaneMorph.	
	(Preference at: #shiftClickShowsImplementors)
		ifTrue: [ self addShiftClickEventHandlerFor: codePane ].
		
	^codePane! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355556!
     optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"

	| aList textConstructor |
	textConstructor _ [ :string :backgroundColor | 
		string asText addAttribute: (TextBackgroundColor color: backgroundColor) ].

	aList _ #(
		(10	'browse'			browseMethodFull							'view this method in a browser')
		(11	'senders' 			browseSendersOfMessages							'browse senders of...' 						browseSendersOfMethod)
		(16	'implementors'			browseMessages							'browse implementors of...' 						browseImplementors)
		(12	'versions'			browseVersions							'browse versions')), 

		((Preference at: #decorateBrowserButtons)
			ifTrue: [
				{{13	. 'inheritance'.	 #methodInheritance. 	'Browse Method Inheritance

', (textConstructor value: 'green' value: `Color green muchLighter`),': sends to super
', (textConstructor value: 'tan' value: `Color tan`), ': has override(s)
', (textConstructor value: 'mauve' value: `Color blue muchLighter`), ': both of the above
', (textConstructor value: 'pink' value: `Color red muchLighter`), ': is an override but doesn''t call super
', (textConstructor value: 'pinkish tan' value: `Color r: 0.94 g: 0.823 b: 0.673`), ': has override(s), also is an override but doesn''t call super
'}}]
			ifFalse: [
				{#(13	'inheritance'		 methodInheritance	 'browse method inheritance')}]),

		#(
		(12	'hierarchy'			browseHierarchy							'browse class hierarchy')
		(10	'inst vars'			browseInstVarRefs							'inst var refs...')
		(11	'class vars'			browseClassVarRefs							'class var refs...')
		(10	'show...'			offerWhatToShowMenu							'menu of what to show in lower pane')).

	^ aList! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355611!
                   decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	(Preference at: #decorateBrowserButtons)
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		`Color tan`.							"no sends to super. there is an override in some subclass"
		`Color red`.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		`Color red`.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		`Color red muchLighter`.			"doesn't have sub; has super but doesn't call it"
		`Color r: 0.94 g: 0.823 b: 0.673`.		"has sub; has super but doesn't call it"
		`Color green muchLighter`.			"doesn't have sub; has super and callsl it"
		`Color blue muchLighter`.			"has sub; has super and callsl it"

	} at: flags + 1.
	Theme current useUniformColors
		ifTrue: [
			aButton color: (self buttonColor mixed: 0.8 with: aColor) ]
		ifFalse: [
			aButton color: aColor ]! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355670 overrides: 50397946!
 buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code _ self buildMorphicCodePane.
	comment _ self buildMorphicCommentPane.
	separator _ LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons _ LayoutMorph newColumn.
	(Preference at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	(Preference at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50388635!
 buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	classList _ self buildMorphicClassList.
	classColumn _ self buildMorphicClassColumnWith: classList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (Preference at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50388680 overrides: 50388597!
                              buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model setSelectedSystemCategory: model systemCategoryList first.
	sysCatList _ PluggableListMorph
			model: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:
			mainView: self
			menuGetter: #codeFileListMenu
			keystrokeAction: #codeFileListKey:from:.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList _ PluggableListMorph
			model: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:
			mainView: self
			menuGetter: #messageCategoryMenu
			keystrokeAction: nil.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (Preference at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!MessageSetWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:31' prior: 50355704 overrides: 50398096!
   buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(Preference at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preference at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357358 overrides: 16959689!
                              initialExtent
	^`540@300` * (Preference at: #standardCodeFont) lineSpacing // 14! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355730 overrides: 50397946!
                            buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons _ LayoutMorph newColumn.
	h _ self defaultButtonPaneHeight.
	(Preference at: #optionalButtons) ifTrue: [
		h _ self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preference at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357365 overrides: 16959689!
                            initialExtent
	^ `640 @ 320` * (Preference at: #standardCodeFont) lineSpacing // 14! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357968!
  open: model label: aString message: messageString
	
	((Preference at: #usePreDebugWindow) or: [messageString notNil])
		ifTrue: [self forceOpen: model label: aString message: messageString]
		ifFalse: [model openFullMorphicLabel: aString ]! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50393503!
                volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	model currentDirectorySelected
		ifNil: [ aMenu add: 'initial directory' action: #yourself :: isEnabled: false ]
		ifNotNil: [ :selectedWrapper |
	aMenu 
		add: (Preference isInitialFileListDirectory: selectedWrapper item)
			asMenuItemTextPrefix, 'initial directory'
		action: #toggleInitialDirectory ::
			setBalloonText: 'The selected directory is an initial director for new file list windows' ].
	initialDirectoriesMenu _ MenuMorph new.
	#(
		(roots  'default roots' 'Use the usual root directories. Drives on Windows; "/" on Unix')
	   	(image 'image directory' 'Use the directory with Smalltalk image')
		(vm 'VM directory' 'Use the virtual machine directory')
		(current 'current directory' 'Use the current directory; usually the directory the VM was started in')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: Preference
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357372 overrides: 16959689!
                          initialExtent

	^`600@325` * (Preference at: #standardCodeFont) lineSpacing // 14! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357379 overrides: 16959689!
                     initialExtent

	^`300@500` * (Preference at: #standardCodeFont) lineSpacing // 14! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354428!
                    addItemsFromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object. If nil, use defaultTarget. If a Symbol, send it as message to defaultTarget to get real target.
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item wantsIcons |
	wantsIcons _ Preference at: #wantsMenuIcons.
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ self addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object ifAbsent: [defaultTarget].
				realTarget isSymbol ifTrue: [ realTarget _ defaultTarget perform: realTarget ].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						self
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						self
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				wantsIcons ifTrue: [
					dict
						at: #icon
						ifPresent: [ :symbolOrFormOrNil |
							item setIcon: symbolOrFormOrNil ]].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]]! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354481!
                             addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preference at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW _ Theme current titleBarButtonsExtent x.
	closeButton _ PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; color: `Color transparent`.
	pinButton _ PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; color: `Color transparent`.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW);
			color: `Color transparent`;
			addMorph: closeButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357385!
     addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w newMorph |
	
	newMorph _ BoxedMorph new noBorder.
	newMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line | | font |
		font _ Preference at: #standardMenuFont.
		s _ LabelMorph new
			contents: line;
			font: (titleMorph
				ifNil: [ font bold ]
				ifNotNil: [ font italic ])..
		newMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ newMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	newMorph morphExtent: (w + 16) @ (pp y).
	titleMorph
		 ifNil: [
			titleMorph _ newMorph.
			self addMorphFront: titleMorph ]
		ifNotNil: [ self addMorphBack: newMorph ].
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/30/2022 16:12:29' prior: 50354531!
          popUpAt: aPoint forHand: hand in: aWorld
	"Present this menu at the given point under control of the given hand.  Allow keyboard input into the menu."

	^ self 
		popUpAt: aPoint 
		forHand: hand 
		in: aWorld 
		allowKeyboard: (Preference at: #menuKeyboardControl)! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356542 overrides: 16892107!
             wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph.  A single-item MenuMorph is in effect a button rather than a menu, and as such should not be reluctant to be dropped into another object."

	^ (aMorph isWorldMorph or: [submorphs size = 1]) or:
		[Preference at: #systemWindowEmbedOK]! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354543!
 invokeModal
	"Invoke this menu and don't return until the user has chosen a value.
	See example below on how to use modal menu morphs."
	^ self invokeModal: (Preference at: #menuKeyboardControl)

	"
	| menu sub entry |
	menu _ MenuMorph new.
	1 to: 3 do: [:i |
		entry _ 'Line', i printString.
		sub _ MenuMorph new.
		menu add: entry subMenu: sub.
		#('Item A' 'Item B' 'Item C')  do:[:subEntry|
			sub add: subEntry target: menu 
				action: #modalSelection: argument: {entry. subEntry}]].
	menu invokeModal.
	"! !
!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357419!
                      listFont

	^Preference at: #standardListFont! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 6/30/2022 16:12:29' prior: 50357682 overrides: 16896706!
  sendEventTo: aMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		self isFindClassShortcut
			ifTrue: [ ^ (Preference at: #classFinder) value ].
		self isCloseWindowShortcut
			ifTrue: [ ^ self closeCurrentWindowOf: aMorph ].
		^ aMorph processKeystroke: self ].
	type == #keyDown ifTrue: [
		^ aMorph processKeyDown: self ].
	type == #keyUp ifTrue: [ 
		^ aMorph processKeyUp: self ].
	^ super sendEventTo: aMorph.! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 6/30/2022 16:12:29' prior: 50357980 overrides: 16896679!
                   dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt _ false.
	grabAMorph _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self) ifTrue: [
				eventHandler _ aMorph.
				aMorphHandlesIt _ true ].
			"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
			self mouseButton1Pressed ifTrue: [
				aMorph owner ifNotNil: [ :o |
					(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
						grabAMorph _ true ]]]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((Preference at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((Preference at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(Preference at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ aMorph is: #SystemWindow :: ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 6/30/2022 16:12:30' prior: 50393547!
     preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: {
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		Preference.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		Preference.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#readAdditionalTrueTypeFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preference.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354659!
            fullDraw: aMorph
	"Draw the full Morphic structure on us"
	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."

	aMorph visible ifFalse: [^ self].
	self into: aMorph.

	currentMorph layoutSubmorphsIfNeeded.

	currentMorph isKnownFailing ifTrue: [
		self canvasToUse drawCurrentAsError.
		self outOfMorph.
		^ self].

	(currentMorph isOwnedByHand and: [
			(Preference at: #cheapWindowReframe) and: [currentMorph is: #SystemWindow]]) ifTrue: [
		self drawCurrentAsOutline.
		self outOfMorph.
		^ self].

	"Draw current Morph and submorphs"	
	self canvasToUse drawCurrentAndSubmorphs.

	self outOfMorph! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357424!
                     buttonPaneHeight
	"Answer the user's preferred default height for button panes."

	^(Preference at: #standardButtonFont) lineSpacing * 14 // 8! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:30' prior: 50358733!
                          fullScreenDeskMargin
	^ (Preference at: #fullScreenLeavesDeskMargins) ifTrue: [48] ifFalse: [0]! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357432!
         layoutAdjusterThickness

	self flag: #todo.  "Revisit this; consider moving proportional stuff out of Theme entirely."
	
	^ (Preference at: #standardListFont) pointSize // 3! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357699!
                           roundedButtonRadius
	"Only effective if #roundButtons answers true.
	Provide a reasonable default for subclasses."
	^ Preference at: #roundedButtonRadius! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:31' prior: 50357707!
               roundedWindowRadius
	"Only effective if #roundWindowCorners answers true.
	Provide a reasonable default for subclasses."
	^Preference at: #roundedWindowRadius! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357715!
          scrollbarThickness
	^ Preference at: #scrollbarThickness! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357441!
                titleBarButtonsExtent
	"Answer the extent to use for close & other title bar buttons.  
	The label height is used to be proportional to the fonts preferences."
	| e |
	e _ (Preference at: #windowTitleFont) pointSize * 13 // 10.
	^e@e! !
!Theme methodsFor: 'other options' stamp: 'jmv 6/30/2022 16:12:29' prior: 50357452!
                               windowBorderWidth
	| w |
	w _ (Preference at: #standardListFont) pointSize / 11.
	w _ w * (self roundWindowCorners ifTrue: [4] ifFalse: [2]).
	^ w rounded max: 1! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/30/2022 16:12:29' prior: 50355763!
                            italic
	^(Preference at: #italicsInShout)
		ifTrue: [ #italic ]
		ifFalse: [ #normal ]! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357461!
           changeFontSizes

	| options menu preference  |
	preference _ Preference instanceAt: #guiElementsSize.
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		(menu add: pair first target: preference action: #value: argument: pair second)
			isSelected: preference value == pair second  ].
	menu popUpInWorld: self runningWorld.! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 6/30/2022 16:12:31' prior: 50353528!
  useMenuIcons
	Preference at: #wantsMenuIcons put: true! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 6/30/2022 16:12:30' prior: 50353533!
           useNoMenuIcons
	Preference at: #wantsMenuIcons put: false! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356555!
              fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	nameToUse _ self name.
	nameToUse _ nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse _ (Preference at: #changeSetVersionNumbers)
				ifTrue: [
					DirectoryEntry currentDirectory
						nextNameFor: nameToUse coda: '-', Utilities authorInitials
						extension: 'cs.st' ]
				ifFalse: [ (nameToUse , '.' , Utilities dateTimeSuffix , '.cs.st') asFileName ].
		
	nameToUse asFileEntry writeStreamDo: [ :stream |
		stream timeStamp.
		self fileOutPreambleOn: stream.
		self fileOutOn: stream.
		self fileOutPostscriptOn: stream ].
	
	self hasUnsavedChanges: false.
	(Preference at: #checkForSlips) 		ifFalse: [^ self].
	slips _ self checkForSlips.
	(slips notEmpty
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357720!
   preambleTemplate
	"Answer a string that will form the default contents for a change set's preamble.
	Just a first stab at what the content should be."

	^ String streamContents: [:strm |
		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."
		strm tab;tab; nextPutAll: self name.
		strm newLine; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.
		strm newLine; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: (Preference at: #defaultAuthorName).
		strm newLine; newLine; nextPutAll: '<your descriptive text goes here>"']
"
ChangeSet changeSetForBaseSystem preambleTemplate
"! !
!ChangeSet class methodsFor: 'services' stamp: 'jmv 6/30/2022 16:12:31' prior: 50356598!
          install: aFileEntry
	"File in the entire contents of the file specified by the name provided.
	Do not affect the user change sets, store changes in separate one"

	ChangeSet installing: aFileEntry name do: [ self fileIn: aFileEntry ].
	(Preference at: #transcriptLogVerbose) ifTrue: [
		('Installed ChangeSet: ', aFileEntry name) print]! !
!CodeFile methodsFor: 'fileIn/fileOut' stamp: 'jmv 6/30/2022 16:12:31' prior: 50356612!
                    fileIn
	| doitsMark |
	doitsMark := 1.
	doIts isEmpty ifFalse:[doitsMark := self askForDoits].
	doitsMark = 4 ifTrue: [^nil].
	doitsMark = 2 ifTrue:[self fileInDoits].
	classOrder do:[:cls|
		cls fileInDefinition.
	].
	classes do:[:cls|
		(Preference at: #transcriptLogVerbose) ifTrue: [
			Transcript newLine; show:'Filing in ', cls name].
		cls fileInMethods.
		cls hasMetaclass ifTrue:[cls theMetaClass fileInMethods].
	].
	doitsMark = 3 ifTrue: [ self fileInDoits ]! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 6/30/2022 16:12:31' prior: 50356630!
              install
	"Create, install and answer a (sub)instance of CodePackage
	Replace all existing code in the possibly existing CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS _ ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS _ nil ].
		pckClass _ CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				((self packageName asIdentifier: true), 'Package') = ee name ifTrue: [
					ee fileInDefinitionAndMetaclass.
					pckClass _ Smalltalk at: ee name ]]].
		newCodePackage _ pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.

		fullName asFileEntry readStreamDo: [ :stream | stream fileInAnnouncing: 'Installing ', localName, '...' ].
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].

	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	(Preference at: #transcriptLogVerbose) ifTrue: [
		Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
		Smalltalk cleanOutUndeclared.
		Undeclared notEmpty ifTrue: [
			('Undeclared: ', Undeclared printString) print ]].
	^newCodePackage! !
!TestResult methodsFor: 'logging' stamp: 'jmv 6/30/2022 16:12:31' prior: 50356700!
                   reportAboutToRun: aTestCase
	(Preference at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'Will run: '; print: aTestCase; newLine]! !
!TestResult methodsFor: 'logging' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356708!
reportFailed: aTestCase because: anException
	(Preference at: #transcriptLogVerbose) ifTrue: [
		Transcript print: anException; newLine].! !
!TestResult methodsFor: 'logging' stamp: 'jmv 6/30/2022 16:12:30' prior: 50356716!
reportPassed: aTestCase
	(Preference at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'finished.'; newLine]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355770 overrides: 16930632!
                             privateFormatAndConvert
	"Perform any formatting of formattedText necessary and store or a formatted copy in formattedText"
	(Preference at: #syntaxHighlightingAsYouTypeAnsiAssignment) ifTrue: [
		self convertAssignmentsToAnsi ].
	(Preference at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) ifTrue: [
		self convertAssignmentsToLeftArrow ]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355785 overrides: 16930636!
                       privateStyle

	| alpha end start count startIndexes c hue |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	(Preference at: #highlightBlockNesting) ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 10.0 min: 1.0.
			hue _ depth * 60.
			c _ Color h: hue s: 0.2 v: 0.5 alpha: alpha.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor color: c ) 
				from: start 
				to: end ]]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'jmv 6/30/2022 16:12:29' prior: 50355810!
                ansiAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeAnsiAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeLeftArrowAssignment
	to be turned off"
	(Preference at: #syntaxHighlightingAsYouTypeAnsiAssignment) 		ifTrue: [
		Preference at: #syntaxHighlightingAsYouTypeLeftArrowAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355825!
              leftArrowAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeLeftArrowAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeAnsiAssignment
	to be turned off"
	(Preference at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) 		ifTrue:[
		Preference at: #syntaxHighlightingAsYouTypeAnsiAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'class initialization' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355841 overrides: 16904184!
             initialize  
	"Clear styleTable and textAttributesByPixelSize cache so that they will 
	reinitialize.	 

		SHTextStylerST80 initialize
	" 
	
	styleTable := nil.
	textAttributes := nil.	
	"We want to be  informed at preference changes"
	(Preference instanceAt: #syntaxHighlightingAsYouTypeAnsiAssignment)
		when: #preferenceChanged
		send: #ansiAssignmentPreferenceChanged
		to: self.
	(Preference instanceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment)
		when: #preferenceChanged
		send: #leftArrowAssignmentPreferenceChanged
		to: self! !
!PopUpMenu methodsFor: 'accessing' stamp: 'jmv 6/30/2022 16:12:30' prior: 50357483!
           frameHeight
	"Designed to avoid the entire frame computation (includes MVC form),
	since the menu may well end up being displayed in Morphic anyway."
	| nItems |
	nItems _ 1 + labelString lineCount.
	^ (nItems * (Preference at: #standardMenuFont) lineSpacing) + 4 "border width"! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 6/30/2022 16:12:31' prior: 50367565!
     startUpNonModalWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self 
		startUpNonModalWithCaption: captionOrNil 
		at: Sensor mousePoint 
		allowKeyboard: (Preference at: #menuKeyboardControl)! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 6/30/2022 16:12:30' prior: 50364960!
                             startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean
	"This menu is too big to fit comfortably on the screen.
	Break it up into smaller chunks, and manage the relative indices.
	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

"
(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; newLine]. s skipBack])
		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'.
"
	| nLines nLinesPer allLabels from to subset subLines index |
	allLabels := labelString lines.
	nLines _ allLabels size.
	lineArray ifNil: [lineArray _ Array new].
	nLinesPer _ segmentHeight // (Preference at: #standardMenuFont) lineSpacing - 5.
	from := 1.
	[ true ] whileTrue: [
		to := (from + nLinesPer) min: nLines.
		subset := (allLabels copyFrom: from to: to) asOrderedCollection.
		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])
			before: subset first.
		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].
		subLines _ (Array with: 1) , subLines.
		index := (PopUpMenu labels: subset printStringWithNewline lines: subLines)
					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
		index = 1
			ifTrue: [from := to + 1.
					from > nLines ifTrue: [ from := 1 ]]
			ifFalse: [index = 0 ifTrue: [^ 0].
					^ from + index - 2]]! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 6/30/2022 16:12:30' prior: 50354702!
startUpWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self 
		startUpWithCaption: captionOrNil 
		at: Sensor mousePoint 
		allowKeyboard: (Preference at: #menuKeyboardControl)! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'jmv 6/30/2022 16:12:30' prior: 50355862!
  preferredAssignmentOperator

	^ (Preference at: #leftArrowAssignmentsInGeneratedCode)
		ifTrue: [ '_' ]
		ifFalse: [ ':=' ]! !

SHTextStylerST80 initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5336-Rename-PreferenceNG-as-Preference-JuanVuletich-2022Jun30-16h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5335] on 30 June 2022 at 4:20:20 pm'!
!PreferenceSet class methodsFor: 'migration' stamp: 'hlsf 6/24/2022 10:08:59'!
                             migrate
" Migrate from Preference class var to PreferenceSet. 
I will copy the Preference dictionary into a PreferenceSet instance, 
then assign this PreferenceSet instance to the global variable Preferences "
| preferences |
	preferences _ self new.
	preferences instVarNamed: #contents put: Preference allPreferences.
	Smalltalk at: #Preferences put: preferences ! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

PreferenceSet migrate
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5337-MigrationMethod-HilaireFernandes-2022Jun30-16h14m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5337] on 30 June 2022 at 6:10:34 pm'!
!Preference commentStamp: 'jmv 6/30/2022 18:00:11' prior: 50352828!
                 My instance is a Preference whose value is of a given class (type), or follow the description of the type instance

- name, category: symbol
- description: string
- type: a class (Boolean, String, Color, BlockClosure, etc.) or an instance (collection, intervale, etc.)
- value: an object whose class match type or the instance description of the type

Modus Operendi
- To create a Preference, invoke the instance creation class method (Preference name:description:category:type:value:). The new preference is automatically remembered. If a preference with same name already exist, its instance is updated with the new provided data and its instance returned.
- To access, invoke as dictionary (Preferences at: #biggerCursors), a short cut exist (Preference biggerCursors)
- When a preference value is changed with its #value message, an event #preferenceChanged is triggered.
- Tools can listen to a specific #preferenceChanged event: 
	(Preference instanceAt: #guiElementSize) when: #preferenceChanged send: #shakeScreen: to: myTool
By default the Preference class listen to a few event to adjust the behavior of the image to some preference changes.	
!
!PluggableTextModel methodsFor: 'misc' stamp: 'hlsf 6/23/2022 11:21:51' prior: 50394977 overrides: 16968693!
                refetch
	"Answer true if actualContents was actually fetched."
	textGetter
		ifNil: [
			actualContents ifNil: [
				self actualContents: Text new ].
			^false ]
		ifNotNil: [
			self actualContents: (Text
				initialFont: (Preferences at: #standardCodeFont)
				stringOrText: (textProvider perform: textGetter)).
			self changed: #refetched.
			^true ]! !
!Workspace methodsFor: 'shout styling' stamp: 'hlsf 6/23/2022 11:21:59' prior: 50394991!
  shouldStyle

	^shouldStyle ifNil: [ Preferences at: #shoutInWorkspaces]! !
!Workspace methodsFor: 'user interface support' stamp: 'hlsf 6/23/2022 11:21:54' prior: 50394997 overrides: 16968885!
                               allowStylingWithEmphasis
	"Disabled by default for faster styling of large contents, as text metrics are not affected by styling."

	^ Preferences at: #stylingWithEmphasisInWorkspaces! !
!Workspace methodsFor: 'user interface support' stamp: 'hlsf 6/23/2022 11:21:57' prior: 50395007 overrides: 16968910!
               fullPrintIt

	^fullPrintIt ifNil: [ Preferences at: #fullPrintItInWorkspaces]! !
!TextProvider methodsFor: 'contents' stamp: 'hlsf 6/23/2022 11:22:01' prior: 50395013!
                        acceptedContents
	^ Text
		initialFont: (Preferences at: #standardCodeFont)
		stringOrText: self acceptedStringOrText! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 6/23/2022 11:22:21' prior: 50395020!
              annotationForClassDefinitionFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Class definition for ';
			nextPutAll: aClass name.
		(Preferences at: #classAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#instanceMethodsCount] -> [
					strm
						print: (aClass theNonMetaClass selectors size);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (aClass theMetaClass selectors size);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (aClass theNonMetaClass linesOfCode);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 6/23/2022 11:22:27' prior: 50395048!
annotationForSelector: aSelector ofClass: aClass 
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp _ self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						strm
							print: ((aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm | cm linesOfCode]);
							nextPutAll: ' lines of code' ].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount _ Smalltalk numberOfSendersOf: aSelector.
						sendersCount _ sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount _ implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp _ VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						(aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm |
							(CodePackage packageOfMethod: cm methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList _ (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ] ].! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 6/23/2022 11:22:31' prior: 50395182!
                       annotationForSystemCategory: aCategory
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'System Category: ';
			nextPutAll: aCategory.
		(Preferences at: #systemCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#classCount] -> [
					strm
						print: (SystemOrganization listAtCategoryNamed: aCategory) size;
						nextPutAll: ' classes' ].
				[#instanceMethodsCount] -> [
					strm
						print: (SystemOrganization instanceMethodCountOf: aCategory);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (SystemOrganization classMethodCountOf: aCategory);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (SystemOrganization linesOfCodeOf: aCategory);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'contents' stamp: 'hlsf 6/23/2022 11:22:33' prior: 50395216!
               contentsSymbol
	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"

	^ contentsSymbol ifNil: [
		contentsSymbol _ (Preferences at: #browseWithPrettyPrint)
					ifTrue:
						[#prettyPrint]
					ifFalse:
						[#source]]! !
!CodeProvider methodsFor: 'diffs' stamp: 'hlsf 6/23/2022 11:22:35' prior: 50395231!
     defaultDiffsSymbol
	"Answer the code symbol to use when generically switching to diffing"

	^ (Preferences at: #diffsWithPrettyPrint)
		ifTrue: [
			#prettyLineDiffs]
		ifFalse: [
			#lineDiffs]! !
!Browser methodsFor: 'class functions' stamp: 'hlsf 6/23/2022 11:22:39' prior: 50395240!
 classCommentText
	"return the text to display for the comment of the currently selected class"
	| theClass |
	theClass _ self selectedClassOrMetaClass.
	^ Text
		initialFont: (Preferences at: #standardCodeFont)
		stringOrText:
			((theClass notNil and: [ theClass hasComment ])
				ifTrue: [ theClass comment ]
				ifFalse: [ '' ]).! !
!Browser methodsFor: 'class functions' stamp: 'hlsf 6/23/2022 11:22:42' prior: 50395254!
                       createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"
	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		aClass instVarNames do: [ :aName | | newMessage setter |
			(aClass canUnderstand: aName asSymbol) ifFalse: [
				newMessage _ aName , '
	"Answer the value of ' , aName , '"

	^ ' , aName.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ].
			(aClass canUnderstand: (setter _ aName , ':') asSymbol) ifFalse: [
				newMessage _ setter , ' anObject
	"Set the value of ' , aName , '"

	' , aName , ' ' ,
					((Preferences at: #leftArrowAssignmentsInGeneratedCode)
						ifTrue: [ '_' ]
						ifFalse: [ ':=' ]) , ' anObject'.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ]]]! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 6/23/2022 11:22:44' prior: 50395287!
                            disableListClassesHierarchically
	
	^Preferences at: #listClassesHierarchically put: false! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 6/23/2022 11:22:46' prior: 50395293!
        enableListClassesHierarchically
	
	^Preferences at: #listClassesHierarchically put: true! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 6/23/2022 11:22:48' prior: 50395299!
          listClassesHierarchically
	
	^Preferences at: #listClassesHierarchically! !
!CodeFileBrowser methodsFor: 'edit pane' stamp: 'hlsf 6/23/2022 11:22:50' prior: 50395305 overrides: 16796178!
     selectedMessage
	"Answer a copy of the source code for the selected message selector."

	| class selector answer |
	class _ self selectedClassOrMetaClass.
	selector _ self selectedMessageName.
	answer _ class sourceCodeAt: selector.
	(self classOrMetaClassOrganizer isRemoved: selector) ifTrue: [
		^ Text
			string: answer
			attribute: TextColor red ].
	(Preferences at: #browseWithPrettyPrint) ifTrue: [
		answer _ class compilerClass new
						format: answer in: class notifying: nil ].
	self showingAnyKindOfDiffs ifTrue: [
		answer _ self
			methodDiffFor: answer
			selector: self selectedMessageName ].
	^ answer! !
!ChangeList methodsFor: 'initialization-release' stamp: 'hlsf 6/23/2022 11:22:56' prior: 50395329 overrides: 16920235!
                         initialize
	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"

	contentsSymbol _ (Preferences at: #diffsInChangeList)
		ifTrue:
			[self defaultDiffsSymbol]
		ifFalse:
			[#source].
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	super initialize! !
!ChangeList methodsFor: 'menu actions' stamp: 'hlsf 6/23/2022 11:22:53' prior: 50395343!
          compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| change class s1 s2 differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	change _ changeList at: listIndex.
	((class _ change changeClass) notNil
			and: [class includesSelector: change methodSelector])
		ifTrue: [
			s1 _ (class sourceCodeAt: change methodSelector) asPlainString.
			s2 _ change string.
			s1 = s2
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords _ self shouldDiffWords.
			differDesc _ diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: s1 to: s2
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: (Preferences at: #standardCodeFont)))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!Debugger class methodsFor: 'class initialization' stamp: 'hlsf 6/23/2022 11:22:58' prior: 50395379!
                  openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	<primitive: 19> "Simulation guard"

	(self errorRecursion not and: [Preferences at: #logDebuggerStackToFile]) ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	ErrorRecursion ifTrue: [
		ErrorRecursion _ false.
		contentsStringOrNil
			ifNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString]
			ifNotNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString, String newLineString, contentsStringOrNil ]].
	ErrorRecursion _ true.
	[self informExistingDebugger: aContext label: aString.
	(Debugger context: aContext)
		openNotifierContents: contentsStringOrNil
		label: aString.] ensure: [ ErrorRecursion _ false ].
	Processor activeProcess suspend.
! !
!Debugger class methodsFor: 'opening' stamp: 'hlsf 6/23/2022 11:23:01' prior: 50395415!
          openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	debugger
		process: interruptedProcess
		context: interruptedProcess suspendedContext.
	debugger externalInterrupt: true.

	(Preferences at: #logDebuggerStackToFile) ifTrue:
		[(aString includesSubString: 'Space') & 
			(aString includesSubString: 'low') ifTrue: [
				Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug']].

	^ debugger
		openNotifierContents: nil
		label: aString
! !
!Debugger class methodsFor: 'opening' stamp: 'hlsf 6/23/2022 11:23:03' prior: 50395442!
               openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!FileList methodsFor: 'initialization' stamp: 'hlsf 6/23/2022 11:23:09' prior: 50395492!
      initialDirectoryList

	| initialDirectoryListFromPreferences wrapperCreator |
	wrapperCreator _ [ :directoryEntry |
		FileDirectoryWrapper
			with: directoryEntry
			name: (directoryEntry name ifNil: [ '/' ])
			model: self ].
	(initialDirectoryListFromPreferences _ Preferences at: #initialFileListDirectories) 
		caseOf: {
			[ #roots ] -> [ 	| dirList |
				dirList _ DirectoryEntry roots collect: wrapperCreator.
				dirList isEmpty ifTrue: [
					dirList _ Array with: (FileDirectoryWrapper 
						with: directory
						name: directory localName 
						model: self) ].
				^ dirList ].
			[ #image ] -> [ 
				^ { wrapperCreator value: DirectoryEntry smalltalkImageDirectory } ].
			[ #vm  ] -> [ 
				^ { wrapperCreator value: DirectoryEntry vmDirectory } ].
			[ #current ] -> [
				^ { wrapperCreator value: DirectoryEntry currentDirectory } ] }
		otherwise: [ ^ initialDirectoryListFromPreferences collect: wrapperCreator ]! !
!FileList methodsFor: 'volume list and pattern' stamp: 'hlsf 6/23/2022 11:23:05' prior: 50395525!
                      fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font _ Preferences at: #standardListFont.
	spaceWidth _ font widthOf: $ .
	nameStr _ entry isDirectory
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd _ namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr _ nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr _ (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits _ entry fileSize printString size.
	sizeStr _ entry fileSize printStringWithCommas.
	sizeDigitsAndCommas _ sizeStr size.
	spacesToAdd _ sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd _ spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr _ (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces _ String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .! !
!FileList methodsFor: 'volume list and pattern' stamp: 'hlsf 6/23/2022 11:23:11' prior: 50395585!
                  listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject
	"Make the list be those file names which match the patterns."

	| sizePad selected newList namePad sizeWithCommasPad font |
	directory ifNil: [^#()].
	selected _ Set new.
	patternsThatSelect do: [ :pat |
		directory childrenDo: [ :entry |
			(entry isDirectory
				ifTrue: [ showDirsInFileList ]
				ifFalse: [ self doesPattern: pat allow: entry])
					ifTrue: [ selected add: entry ]]].
	newList _ selected copy.
	patternsThatReject do: [ :pat |
		selected do: [ :entry |
			(entry isDirectory not and: [ pat match: entry name]) ifTrue: [
				newList remove: entry ]]].
		
	newList _ newList asArray sort: self sortBlock.
	font _ Preferences at: #standardListFont.
	namePad _ newList inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printString size.
	sizeWithCommasPad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printStringWithCommas size.
	newList _ newList collect: [ :e |
		self fileNameFormattedFrom: e namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad ].
	^ newList! !
!Color class methodsFor: 'colormaps' stamp: 'hlsf 6/23/2022 11:23:15' prior: 50395626!
               computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: (Preferences at: #aaFontsColormapDepth).
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: `Color white` ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'hlsf 6/23/2022 11:23:19' prior: 50395687!
                     whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |

	(Preferences at: #thoroughSenders)
		ifTrue: [ who _ self thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte ]
		ifFalse: [ 
			who _ Set new.
			self selectorsAndMethodsDo: [:sel :method |
				((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]]) ifTrue: [
					((literal isVariableBinding) not or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
						or: [(method indexOfLiteral: literal) ~= 0]]) ifTrue: [who add: sel]]]].
		
	^self rejectSelectorsFrom: who thatReferenceTo: literal byte: specialByte ! !
!Message methodsFor: 'stub creation' stamp: 'hlsf 6/23/2022 11:23:21' prior: 50395718!
                            addSetterCodeOn: stream 
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ((Preferences at: #leftArrowAssignmentsInGeneratedCode)
			ifTrue: [ ' _ ' ]
			ifFalse: [ ' := ' ]);
		nextPutAll: self arguments first argumentName ! !
!SystemDictionary methodsFor: 'image, changes name' stamp: 'hlsf 6/23/2022 11:25:26' prior: 50395730!
                       defaultUserChangesName
	"Answer the default full path to the changes file corresponding to the image file name."
	"
	Smalltalk defaultUserChangesName
	"
	^(FileIOAccessor default baseNameFor: self imageName), 
		(Preferences at: #userChangesFileNameExtension)! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'hlsf 6/24/2022 09:45:41' prior: 50395742!
                         handleUserInterrupt
	| p |
	"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
	p _ UISupervisor newUIProcessIfNeeded.
	p ifNil: [
		p _ Sensor shiftPressed | (Preferences at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preferences at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		p == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(p name beginsWith: '[system]') ifTrue: [
			 ('Process {', p printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			p isTerminated
				ifTrue: [ ('Process {', p printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ UISupervisor userInterrupt: p ]] fork
		]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'hlsf 6/23/2022 11:25:37' prior: 50395774!
                     logError: errMsg inContext: aContext to: baseFilename
	"Log the error message and a stack trace to the given file.
	Smalltalk logError: 'test error message' inContext: thisContext to: 'testErr.txt'
	"

	| localFilename file |
	localFilename _ (Preferences at: #debugLogTimestamp)
		ifTrue: [ baseFilename, '-', Utilities dateTimeSuffix, '.log' ]
		ifFalse: [ baseFilename, '.log' ].
	file _ DirectoryEntry smalltalkImageDirectory // localFilename.
	[
		file forceWriteStreamDo: [ :stream |
	 	 	stream nextPutAll: errMsg; newLine.
			aContext errorReportOn: stream ]
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"
	[
 	 	StdIOWriteStream stdout newLine; nextPutAll: errMsg.
		StdIOWriteStream stdout newLine; nextPutAll: 'See '; nextPutAll: file pathName.
		StdIOWriteStream stdout newLine.
		aContext shortErrorReportOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout flush
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'hlsf 6/23/2022 11:23:28' prior: 50395808!
                   abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal _ 0.  bCount _ 0.
	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		Smalltalk allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount _ bCount + 1).
			cl selectors do: [:selector |
				m _ cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	Smalltalk allBehaviorsDo: [:b | b zapOrganization].
	Smalltalk closeSourceFiles.
	Preferences at: #warnIfNoChangesFile put: false.
	Preferences at: #warnIfNoSourcesFile put: false! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'hlsf 6/23/2022 11:25:51' prior: 50395845!
         reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'hlsf 6/23/2022 11:25:12' prior: 50395913!
                               askConfirmationOnQuit
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk askConfirmationOnQuit
	"
	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSet allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges ]].
	"dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ]."
	dirtyPackages _ ChangeSet allChangeSets anySatisfy: [ :any | any codePackage notNil and: [ any hasUnsavedChanges ]].
	baseCSdirty & dirtyPackages ifTrue: [
		^self confirm: 'There are both unsaved Packages', String newLineString,
			'and unsaved Changes to Cuis core.', String newLineString,
			'If you continue, all unsaved changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	dirtyPackages ifTrue: [
		^self confirm: 'There are unsaved Packages.', String newLineString,
			'If you continue, their changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	(Preferences at: #askConfirmationOnQuit) ifTrue: [
		^self confirm: 'Do you really want to exit Cuis without saving the image?' ].
	^true! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'hlsf 6/24/2022 09:44:43' prior: 50395961!
setPlatformPreferences
	"Set some platform specific preferences on system startup"
	| platform specs |	

	(Preferences at: #automaticPlatformSettings) ifFalse:[^self].
	platform _ self platformName.
	specs _ 	#(	
					(soundStopWhenDone false)
					(soundQuickStart false)
			).
	platform = 'Win32' ifTrue:[
		specs _ #(	
					(soundStopWhenDone true)
					(soundQuickStart false)
				)].
	platform = 'Mac OS' ifTrue:[
		specs _ #(	
					(soundStopWhenDone false)
					(soundQuickStart true)
				)].
	specs do: [:tuple |
		Preferences name: tuple first category: #system value: (tuple last == #true) 	]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'hlsf 6/23/2022 11:25:23' prior: 50395983!
                            assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	(Preferences at: #autoNumberUserChanges) ifTrue: [
		oldUserChanges _ Smalltalk defaultUserChangesName asFileEntry.
		oldUserChanges exists ifTrue: [
			directory _ oldUserChanges parent.
			oldUserChangesName _ directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine ].
	StartupStamp _ nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'hlsf 6/24/2022 09:45:48' prior: 50396016!
     openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or Lf/CrLf mixups."
	"Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes msg wmsg entry |
	msg _ 'Cuis cannot locate XfileRef
Please check that the file is named properly and is in the
same directory as this image.'.
	wmsg _ 'Cuis cannot write to XfileRef.

Please check that you have write permission for this file.

You won''t be able to save this image correctly until you fix this.'.

	"Do not open source files if internalized (i.e. notNil)"
	sources _ SourceFiles at: 1.
	sources ifNil: [
		entry _ Smalltalk defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry _ Smalltalk alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources _ [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preferences at: #warnIfNoSourcesFile ])
		ifTrue: [
			Smalltalk platformName = 'Mac OS' ifTrue: [
				msg _ msg , String newLineString, 'Make sure the sources file is not an Alias.'].
			self inform: (msg copyReplaceAll: 'XfileRef' with: 'the sources file named ' , entry pathName) ].

	"Do not open source files if internalized (i.e. notNil)"
	changes _ (SourceFiles at: 2) ifNil: [ 
		entry _ Smalltalk defaultChangesName asFileEntry.
		[ entry appendStream ] on: FileWriteError do: [ nil ] ].
	(changes isNil and: [Preferences at: #warnIfNoChangesFile])
		ifTrue: [self inform: (wmsg copyReplaceAll: 'XfileRef' with: 'the changes file named ' , entry pathName)].
	ChangesInitialFileSize _ changes ifNotNil: [ changes position ].

	SourceFiles _ Array with: sources with: changes! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'hlsf 6/23/2022 11:25:32' prior: 50396082!
 hasToRestoreChanges

	^(Preferences at: #checkLostChangesOnStartUp) and: [ 
		self withChangesFileDo: [ :changesFile | self hasToRestoreChangesFrom: changesFile ]].
	! !
!Exception methodsFor: 'priv handling' stamp: 'hlsf 6/23/2022 11:26:45' prior: 50396091!
                             evaluateHandlerBlock: aBlock

	| handlerEx |
	handlerBlockNotCurtailed := false.
	^[
			| answer |
			answer _ [aBlock valueWithPossibleArgument: self] on: Exception do: [:ex | handlerEx _ ex.  ex pass].
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			handlerBlockNotCurtailed _ true.
			answer
	] ifCurtailed:
		[
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			(handlerBlockNotCurtailed not and: [handlerEx isNil or: [handlerEx handlerBlockNotCurtailed not]])
				ifTrue: [
					"Please see
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000800.html
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000809.html
					Also see the rest of the tread in detail.
					This is work in progress."
					(Preferences at: #allowNonLocalReturnsInExceptionHandlers)
						ifFalse: [ self error: 'Exception handler blocks must not do non local returns' ]
						ifTrue: [
							(Preferences at: #warnAboutNonLocalReturnsInExceptionHandlers)
								ifTrue: [ 'It is advisable to avoid method returns (non local returns) in exception handler blocks' print ].
							handlerBlockNotCurtailed _ true ].
					]
				ifFalse: [handlerBlockNotCurtailed _ true]
		]! !
!NegativePowerError methodsFor: 'exceptionDescription' stamp: 'hlsf 6/23/2022 11:26:55' prior: 50396137 overrides: 16780646!
                     defaultAction

	"Disable this preference to have Float nan answer (if Float receiver or argument) or Error message"
	| answer |
	(Preferences at: #askToInstallComplexPackage) ifTrue: [
		answer _ PopUpMenu
			withCaption:
'Square (or even) Root of a negative Number:
Complex number support is not loaded
Would you like me to load it for you now?'
			chooseFrom: #(
				'Load Complex package'
				'Do not load Complex package'
				'Do not load Complex package and don''t ask again').
		answer = 1 ifTrue: [
			Feature require: #'Complex'.
			Smalltalk at: #Complex ifPresent: [ :cplx |
				^ (cplx basicReal: receiver imaginary: 0) perform: selector withArguments: arguments ]].
		answer = 3 ifTrue: [
			(Preferences at: #askToInstallComplexPackage put: false)]].
	^ super defaultAction! !
!Parser methodsFor: 'scanning' stamp: 'hlsf 6/24/2022 09:29:19' prior: 50396165!
                         transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a series of consecutive vertical bars, up arrows, colons and regular binary selector characters.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain.
	Another special case is binary selectors ending in $-, like in
	1@-2
	This could be interpreted as `1 @ -2` or `1 @- 2`. Preference #atMinusDigitMeaning tells what to do."

	| toMakeBinary |
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	"Note: Also include #binary, to allow stuff like #+| where a special character comes after after a regular binary operator character. "
	toMakeBinary _ #(binary verticalBar upArrow colon).
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here _ here asPlainString.
	hereType _ #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			(token == #- and: [source peekBack isDigit])
				ifTrue: [
					(Preferences at: #atMinusDigitMeaning) == #disabled
						"Disallow `1@-2`. Insists on some whitespace to disambiguate."
						ifTrue: [ ^self expected: 'A space character after selector' ].
					(Preferences at: #atMinusDigitMeaning) == #st80
						ifTrue: [ ^self ].				"interpret `1@-2` like `1 @ -2`"
					"Assume (Preferences at: #atMinusDigitMeaning) == #ansiSmalltalk
					interpret `1@-2` like `1 @- 2`, i.e. consider #@- a valid binary selector"
					].
			here _ here , token asPlainString.
			hereEnd _ hereEnd + 1.
			self scanToken ].! !
!BlockNode methodsFor: 'printing' stamp: 'hlsf 6/24/2022 09:29:25' prior: 50396228 overrides: 16906201!
                        printOn: aStream indent: level
	| separateLines |
	aStream nextPut: $[.
	self
		printArgumentsOn: aStream
		indent: level.
	separateLines _ (self
		printTemporaries: temporaries
		on: aStream
		doPrior: [ aStream space ]) or: [arguments notNil and: [arguments notEmpty] ].
	(Preferences at: #prettyPrintRectangularBlocks)
		ifTrue: [
			"If args+temps > 0 and statements > 1 (or just one complex statement),
			put all statements on separate lines"
			separateLines
				ifTrue: [
					(statements size > 1 or: [
						statements size = 1 and: [ statements first isComplex ]])
							ifTrue: [ aStream newLineTab: (1 max: level) ]
							ifFalse: [ aStream space ] ]
				ifFalse: [
					(statements size = 1 and: [ statements first isComplex not ])
						ifTrue: [ aStream space ]]]
		ifFalse: [
			self isComplex
				ifTrue: [ aStream newLineTab: (1 max: level) ]
				ifFalse: [ aStream space ] ].
	((self printStatementsOn: aStream indent: level) > 0 and: [ aStream peekLast ~= $] ])
		ifTrue: [ aStream space ].
	aStream nextPut: $]! !
!BlockNode methodsFor: 'testing' stamp: 'hlsf 6/24/2022 09:29:28' prior: 50396264 overrides: 16906470!
           printsInNewLine
	"Used for pretty printing to determine whether to start a new line"

	(Preferences at: #prettyPrintRectangularBlocks) ifFalse: [ ^false ].
	^super printsInNewLine! !
!TempVariableNode methodsFor: 'testing' stamp: 'hlsf 6/24/2022 09:29:31' prior: 50396274 overrides: 16977637!
                           assignmentCheck: encoder at: location
	^((self isBlockArg and: [(Preferences at: #allowBlockArgumentAssignment) not])
	    or: [self isMethodArg])
			ifTrue: [location]
			ifFalse: [-1]! !
!Editor methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:29:36' prior: 50396283!
                   setIndices: shiftPressed forward: forward
	"Little helper method that sets the moving and fixed indices according to some flags."
	| indices |
	indices _ Dictionary new.
	(shiftPressed and:[Preferences at: #selectionsMayShrink])
		ifTrue: [
			indices at: #moving put: self pointIndex.
			indices at: #fixed put: self markIndex
		] ifFalse: [
			forward
				ifTrue:[
					indices at: #moving put: self stopIndex.
					indices at: #fixed put: self startIndex.
				] ifFalse: [
					indices at: #moving put: self startIndex.
					indices at: #fixed put: self stopIndex.
				]
		].
	^indices! !
!TextEditor methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:29:40' prior: 50396305!
                            findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where _ model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [Preferences at: #caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'hlsf 6/24/2022 09:29:42' prior: 50396336!
      browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry |
	(Preferences at: #alternativeBrowseIt) ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol _ self selectedSymbol ifNil: [
		self
			evaluateSelectionAndDo: [ :result | result class name ]
			ifFail: [ ^morph flash ]
			profiled: false].

	aSymbol first isUppercase
		ifTrue: [
			anEntry _ (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry _ anEntry class].
			BrowserWindow fullOnClass: anEntry selector: nil]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !
!Preference class methodsFor: 'event handlers' stamp: 'jmv 6/30/2022 18:00:13' prior: 50396363!
                        defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preference name: #standardListFont category: #font value: font.
	Preference name: #standardMenuFont category: #font value: font.
	Preference name: #standardCodeFont category: #font value: font.
	Preference name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preference name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preferences at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font
" Copied to PreferenceSet "! !
!Preference class methodsFor: 'fonts' stamp: 'jmv 6/30/2022 18:05:27' prior: 50396424!
  setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	Preference
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (Preferences at: #standardListFont) pointSize.}.
				{#standardMenuFont. (Preferences at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (Preferences at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (Preferences at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (Preferences at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
" Copied to PreferenceSet "! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 6/30/2022 18:05:16' prior: 50396515!
                        installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	self sysPreferences 

		name: #haloHandleSize 
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 5 // 3 max: 16];
	
		name: #roundedButtonRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 8 // 14];
		
		name: #roundedWindowRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize] ;
		
		name: #scrollbarThickness 
		category: #gui 		
		value: [(Preferences at: #windowTitleFont) pointSize + 2];
		
		name: #classFinder 
		category: #programming 
		value: [ BrowserWindow findClass ];
		
		name: #defaultAuthorName 
		category: #programming 
		value: [Utilities authorName].! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'jmv 6/30/2022 18:00:31' prior: 50396544!
                       defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preference name: #standardListFont category: #font value: font.
	Preference name: #standardMenuFont category: #font value: font.
	Preference name: #standardCodeFont category: #font value: font.
	Preference name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preference name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preferences at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'hlsf 6/24/2022 09:30:12' prior: 50396578!
          standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| grid allowedArea maxLevel |
	"NOTE: following copied from strictlyStaggeredInitialFrameFor:"
	allowedArea _ self maximumUsableArea insetBy: (
		self scrollBarSetback @ self screenTopSetback extent: `0@0`
	).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
	^ ((allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) 
		min: `52@40` * (Preferences at: #standardCodeFont) lineSpacing) rounded! !
!Cursor class methodsFor: 'accessing' stamp: 'hlsf 6/24/2022 09:30:19' prior: 50396602!
      defaultCursor
	"Answer the instance of me that is the shape of an arrow slanted left."
	^ (Preferences at: #biggerCursors)
		ifTrue: [ CursorWithAlpha biggerNormal ]
		ifFalse: [ self cursorAt: #normalCursorWithMask ].! !
!Cursor class methodsFor: 'current cursor' stamp: 'hlsf 6/24/2022 09:30:15' prior: 50396612!
     currentCursor: aCursor 
	"Make the instance of cursor, aCursor, be the current cursor. Display it. 
	Create an error if the argument is not a Cursor."

	CurrentCursor _ aCursor.
	(Preferences at: #biggerCursors)
		ifTrue: [
			[ ^aCursor asBigCursor installCursor] 
				on: Error do: nil  "fall through "].
	aCursor installCursor! !
!BitBltCanvasEngine methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:30:28' prior: 50396626!
                       setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: `Color transparent`).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			(Preferences at: #subPixelRenderFonts) and: [ foregroundColor = `Color black` or: [ 
				(Preferences at: #subPixelRenderColorFonts) and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= `Color black` or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preferences at: #properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = `Color black` ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display."
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'hlsf 6/24/2022 09:30:30' prior: 50396703!
                  syntheticST80Glyphs
	"Build and answer a derivative that includes ST-80 glyphs:
	a left arrow instead of the underscore, and an up arrow instead of the caret."

	| derivative |
	derivative _ self copy.
	derivative
		name: self name , 'ST80';
		perform: (Preferences at: #assignmentGlyphSelector).
	^ derivative! !
!MorphicScanner methodsFor: 'scanning' stamp: 'hlsf 6/24/2022 09:30:54' prior: 50396716!
             displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos x1 |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastIndex _ line first.
	tabCount _ 0.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions.
		backgroundColor ifNotNil: [
			x1 _ destX.
			((Preferences at: #backgroundColorFillsAllBackground) and: [startIndex > line last]) ifTrue: [
				x1 _ rightMargin ].
			canvas
				fillRectangle: (lastPos corner: x1 @ (line bottom + textTopLeft y))
				color: backgroundColor.
			((Preferences at: #backgroundColorFillsAllBackground) and: [stopCondition = #tab]) ifTrue: [
				canvas
					fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
					color: backgroundColor ]].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 6/30/2022 18:07:35' prior: 50396811!
                             promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				fontFamily includesAscii
					ifTrue: [PreferenceSet setDefaultFont: fontFamily familyName ]
					ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]]]].! !
!Morph methodsFor: 'events' stamp: 'hlsf 6/24/2022 09:31:13' prior: 50396836!
                   mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."

	(Preferences at: #focusFollowsMouse)
		ifTrue: [evt hand releaseKeyboardFocus: self].
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: evt ].! !
!Morph methodsFor: 'geometry' stamp: 'hlsf 6/24/2022 09:31:06' prior: 50396853!
          displayBoundsForHalo
	"Answer the rectangle to be used as the inner dimension of my halos.
	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."

	^ (Preferences at: #haloEnclosesFullBounds)
		ifFalse: [ self displayBounds ]
		ifTrue: [ self displayFullBounds ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 6/24/2022 09:31:02' prior: 50396866!
            addHandlesTo: aHaloMorph box: box
	"Add halo handles to the halo.  Apply the halo filter if appropriate"

	(Preferences at: #haloSpecifications) do: [ :aSpec |
		(self
			wantsHaloHandleWithSelector: aSpec addHandleSelector
			inHalo: aHaloMorph) ifTrue: [
		aHaloMorph
			perform: aSpec addHandleSelector
			with: aSpec ]].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 6/24/2022 09:31:10' prior: 50396882!
                         haloShowsCoordinateSystem

	^Preferences at: #halosShowCoordinateSystem! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 6/24/2022 09:31:15' prior: 50396888!
                       wantsBalloon
	"Answer true if receiver wants to show a balloon help text is a few moments."

	^ (self balloonText notNil) and: [Preferences at: #balloonHelpEnabled]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 6/24/2022 09:31:20' prior: 50396897!
                          wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	(#(addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].

	(Preferences at: #selectiveHalos) ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addResizeHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily | self okayToScaleEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addScaleHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToScaleEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 6/24/2022 09:31:47' prior: 50396929!
          waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel

	"Wait until the difference between click, or drag gesture is known, then inform the given morph what transpired." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: nil
			dblClick: nil
			dblClickAndHalf: nil
			tripleClick: nil
			event: evt
			sendMouseButton2Activity: (Preferences at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 6/24/2022 09:31:50' prior: 50396951!
            waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel

	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (Preferences at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 6/24/2022 09:31:54' prior: 50396999!
          waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel dragSel: dragSel
	
	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: dragSel
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (Preferences at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'geometry' stamp: 'hlsf 6/24/2022 09:31:43' prior: 50397023 overrides: 16909517!
                            morphPosition: aPoint
	"Change the position of this morph. Argument is in owner's coordinates."

	| prevTranslation |
	prevTranslation _ location translation.
	location _ location withTranslation: aPoint.
	"Ask if translation effectively changed, after possible conversion to 32 bit Float in AffineTransformation. "
	location translation = prevTranslation ifFalse: [
		self isDrawnBySoftware
			ifTrue: [
				(Preferences at: #cacheDisplayContentWhenMovingMorphs)
					ifTrue: [
						"We are caching whatever is in the Display below us. Thefore, there's no need
						to do an invalidation that would trigger the redraw of everything below us."
						self needsRedraw: true ]
					ifFalse:  [
						"No caching of stuff below us. Just invalidate and redraw."
						self redrawNeeded ]]
			ifFalse: [
				lastPosition _ nil.		"Not nil if carrying morphs at that moment"
				prevFullBounds _ nil "Any saved patch is no longer relevant"]].! !
!HandMorph methodsFor: 'private events' stamp: 'hlsf 6/24/2022 09:31:30' prior: 50397056!
                         generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp mouseScrollDirection |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [
		(keyValue = 9 and: [(modifiers anyMask: 1) and: [Smalltalk platformName = 'unix']])
			ifTrue: [
				"Linux VMs don't generate shift-tab keystroke. Turn #keyUp into #keystroke"
				pressType _ EventSensor eventKeyChar ]
			ifFalse: [type _ #keyUp ]].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [ 											"Control key pressed"
			keyValue < 27 ifTrue: [ 										"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [   									"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [ 			"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96   						"shift not pressed: conver to lowercase letter" ]]]].
			"On Windows, ctrl-backSpace is reported as ctrl-forwardDelete. But keyDown is ok, so we can know and fix."
			(keyValue = 127 and: [ lastKeyDownValue = 8 ])
				ifTrue: [ keyValue _ 8 ].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]].
		(modifiers anyMask: 8) ifTrue: [ 									"CmdAlt key pressed (or Control key pressed, and #shouldControlEmulateAltFor: just answered true)"
			(modifiers anyMask: 1) ifTrue: [								"Shift pressed"
				| i |
				"It seems that for ctrl-shifted keys and cmd-shifted keys, the VM incorrectly reports the UNSHIFTED character.
				Correct this, at least for common cmd-shortcuts, and for the US keyboard... Sigh...
				(This has only been observed on Mac VMs, but seems harmless if proper shifted character is reported (as in Linux), as this wil be NOP)
				(On Windows, the situation is even worse: ctrl-{ is not even reported as a keystroke event. Only keyDown and keyUp.)"
				"#($' $, $. $9 $0 $[ $]) -> #($'' $< $> $( $) ${) $}"
				i _ #[39 44 46 57 48 91 93 ] indexOf: keyValue.
				i > 0 ifTrue: [
					keyValue _ #[34 60 62 40 41 123 125] at: i ]]]].
	buttons _ modifiers bitShift: 3.
	"Linux and Windows VM send keyboard ctrl-upArrow and ctrl-downArrow when the user tries to scroll using the mouse wheel
	Mac VM sends cmd-option-ctrl-shift-upArrow and cmd-option-ctrl-shift-downArrow for trackpad vertical scroll gestures,
		and cmd-option-ctrl-shift-leftArrow and cmd-option-ctrl-shift-rightArrow for horizontal scroll gestures.
	This way of reporting scroll events by the VM also enables scrolling using the keyboard (actually, we can't tell if user gesture was on Mouse, Trackpad or Keyboard).
	But ctrl-shift and cmdAlt-shift are needed used for selecting while moving by word, line, etc.
	Additionally, #ctrlArrowsScrollHorizontally allows chosing between keyboard horizontal scroll and moving word by word in text editors."
	mouseScrollDirection _ nil.
	"Ctrl for Keyboard or Mouse wheel gestures. All modifiers for Trackpad gestures."
	(buttons = InputSensor controlKey or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 30
			ifTrue: [mouseScrollDirection _ #up]
		ifFalse: [keyValue = 31
			ifTrue: [mouseScrollDirection _ #down]]].
	"Ctrl for Keyboard or Mouse wheel gestures, only if preference is set. All modifiers for Trackpad gestures."
	((buttons = InputSensor controlKey and: [Preferences at: #ctrlArrowsScrollHorizontally]) or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 28
			ifTrue: [mouseScrollDirection _ #left]
		ifFalse: [keyValue = 29
			ifTrue: [mouseScrollDirection _ #right]]].
	mouseScrollDirection ifNotNil: [
		^ MouseScrollEvent new
			setType: #mouseScroll
			position: self morphPosition
			direction: mouseScrollDirection
			buttons: buttons
			hand: self
			stamp: stamp ].
	^ KeyboardEvent new
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!WorldMorph methodsFor: 'drawing' stamp: 'hlsf 6/24/2022 09:46:04' prior: 50397237!
                      displayWorld
	"Update this world's display."

	| deferredUpdateVMMode allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time. ?? revisar."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"Restore world canvas under hands and their carried morphs"
	(Preferences at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		hands do: [ :h | h restoreSavedPatchOn: canvas ]].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	canvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage _ canvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	canvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self handsToDrawForDamage: allDamage do: [ :h |
		(Preferences at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage _ (h savePatchFrom: canvas) quickMerge: allDamage ]
			ifFalse: [ allDamage _ h displayFullBoundsForPatch quickMerge: allDamage ].
		canvas fullDrawHand: h .
		h needsRedraw: false ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		allDamage ifNotNil: [
			"Drawing was done to off-Display canvas. Copy content to Display"
			canvas showAt: self viewBox origin invalidRect: allDamage ]].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	allDamage ifNotNil: [
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: allDamage ]].! !
!WorldMorph methodsFor: 'update cycle' stamp: 'hlsf 6/24/2022 09:32:01' prior: 50397297!
     doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(Preferences at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	canvas ensureCurrentMorphIsWorld.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow.! !
!WorldMorph methodsFor: 'world menu' stamp: 'jmv 6/30/2022 18:07:48' prior: 50397373!
        invokeWorldMenu
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	| menu |
	menu _ (TheWorldMenu new 
		world: self
		hand: self activeHand) buildWorldMenu.
	menu addTitle: PreferenceSet desktopMenuTitle.
	menu popUpInWorld: self! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'hlsf 6/24/2022 09:32:07' prior: 50397386 overrides: 16878712!
     adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(Preferences at: #cheapWindowReframe) or: [millisecondSinceLast > 200]]) ifTrue: [
			owner displayBounds newRectFrom: [ :f |
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner morphExtentInWorld ]].! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'hlsf 6/24/2022 09:32:10' prior: 50397407!
                        addTitle: aString
	| titleMorph s pp w |
	titleMorph _ BoxedMorph new noBorder.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line |
		s _ LabelMorph new
			contents: line;
			font: (Preferences at: #standardMenuFont) bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 24) @ (pp y).
	self addMorphKeepMorphHeight: titleMorph.
	^titleMorph morphWidth! !
!StringRequestMorph methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:32:16' prior: 50397428!
                        getUserResponseOrCancel: aBlock
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."
	| w delay done canceled |
	w _ self world.
	w isNil ifTrue: [^ response asString].
	done _ false.
	canceled _ false.
	(Preferences at: #focusFollowsMouse) ifFalse: [self textBox focusText].
	acceptBlock _ [:aString| done _ true].
	cancelBlock _ [done _ true. canceled _ true].
	delay _ Delay forMilliseconds: 10.
	[done not and: [self isInWorld]] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	canceled ifTrue: [^ aBlock value].
	^ response asString! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'hlsf 6/24/2022 09:32:19' prior: 50397459!
                    request: queryString centeredAt: aPoint initialAnswer: defaultAnswer validationBlock: validationBlock acceptBlock: acceptBlock cancelBlock: cancelBlock
	| answer |
	answer _ self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer;
		validationBlock: validationBlock;
		acceptBlock: acceptBlock;
		cancelBlock: cancelBlock.
	self runningWorld addMorph: answer centeredNear: aPoint - self deltaToTextPane.
	(Preferences at: #focusFollowsMouse) ifFalse: [answer textBox focusText].
	^ answer! !
!StringRequestMorph class methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:32:13' prior: 50397478!
    deltaToTextPane
	"Answer a distance to translate an instance of the receiver by when it is opened in the world in order to have the hand be over the text pane (so the text pane has focus).
	Distance is relative to font size"
	| e |
	e _ (Preferences at: #windowTitleFont) lineSpacing.
	^ (0)@(0.5 * e)! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'hlsf 6/24/2022 09:32:22' prior: 50397491!
                  defaultHeight

	^ ((Preferences at: #windowTitleFont) lineSpacing * 2 * self scale) asInteger! !
!HaloMorph methodsFor: 'handles' stamp: 'hlsf 6/24/2022 09:32:29' prior: 50397497!
            addDebugHandle: handleSpec

	(Preferences at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doDebug:with: ]
! !
!HaloMorph methodsFor: 'handles' stamp: 'hlsf 6/24/2022 09:32:31' prior: 50397505!
                         addExploreHandle: handleSpec

	(Preferences at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doExplore:with: ]
! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:32:36' prior: 50397513!
                     addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient. Return the handle."

	| handle aPoint colorToUse form icon e |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	e _ (Preferences at: #haloHandleSize) asPoint.
	handle morphPosition: aPoint-(e//2) extent: e.
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				form extent = e ifFalse: [ 
					": Non default size, scale that bugger!!"
					form _ form  ": Be as smooth as possible, these images are small."
						magnify: form boundingBox
						to: e
						smoothing: 2 ].
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^ handle! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:32:39' prior: 50397554!
      addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph verticalNamePosition namePosition nameBackground |
	nameBackground _ BoxedMorph new noBorder
		color: ((target is: #SystemWindow)
			ifTrue: [target windowColor]
			ifFalse: [`Color lightBlue alpha: 0.9`]).
	nameMorph _ LabelMorph contents: aString.
	nameMorph color: `Color black`.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	verticalNamePosition _ haloBox bottom + (Preferences at: #haloHandleSize).
	namePosition _ haloBox width - nameMorph morphWidth // 2 + haloBox left @ verticalNamePosition.
	self addMorph: nameBackground.
	nameBackground morphPosition: namePosition - 2.
	self addMorph: nameMorph.
	nameMorph morphPosition: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:32:43' prior: 50397582!
       handlesBox
	"handlesBox is in local coordinates.
	We assume we are direct submorph of the world, without any scaling or rotation."

	| minSide hs c e box |
	hs _ Preferences at: #haloHandleSize.
	minSide _ 4 * hs.
	e _ extent + (hs*2) max: minSide@minSide.
	c _ extent // 2 + self morphPosition.
	box _ Rectangle center: c extent: e.
	self world ifNotNil: [ :w | box _ box intersect: (w viewBox insetBy: (hs@hs corner: hs@(hs*3))) ].
	"Make it local"
	^box translatedBy: self morphPosition negated.
! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'hlsf 6/24/2022 09:32:45' prior: 50397602 overrides: 16794207!
                 drawOn: aCanvas

	(Preferences at: #showLinesInHierarchyViews) ifTrue:[
		self drawLinesOn: aCanvas ]! !
!InnerListMorph methodsFor: 'initialization' stamp: 'hlsf 6/24/2022 09:32:49' prior: 50397609 overrides: 16794195!
    initialize
	super initialize.
	self color: `Color black`.
	font _ Preferences at: #standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !
!InnerListMorph methodsFor: 'geometry' stamp: 'hlsf 6/24/2022 09:32:47' prior: 50397618 overrides: 16893209!
               fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preferences at: #standardListFont).! !
!InnerTextMorph methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:32:52' prior: 50397624!
                               installEditorAndTextComposition
	"Install an editor for my textComposition. Install also the textComposition."
	| e tc |
	
	"Editor and TextComposition are assigned here atomically."
	e _ model editorClass new morph: self.
	e model: model.
	tc _ TextComposition new.
	"Keep critical section short"
	self mutex critical: [
		editor _ e.
		textComposition _ tc.
		tc
			setModel: model;
			extentForComposing: self extentForComposing.
		e textComposition: tc.
		tc editor: e ].
	e setEmphasisHereFromText.
	tc composeAll.
	e resetState.
	self fit.
	self selectionChanged.

	"Add extras. Text Styler and Autocompleter"
	self stylerClass:
		((Preferences at: #syntaxHighlightingAsYouType) ifTrue: [
			model textStylerClass ]).
	self autoCompleterClass:
		model autoCompleterClass! !
!LabelMorph methodsFor: 'geometry' stamp: 'hlsf 6/24/2022 09:32:56' prior: 50397652 overrides: 16893209!
           fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preferences at: #standardListFont).
	self fitContents.! !
!IndentingListItemMorph methodsFor: 'geometry' stamp: 'hlsf 6/24/2022 09:32:58' prior: 50397660 overrides: 50401926!
               fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preferences at: #standardListFont).! !
!IndentingListItemMorph methodsFor: 'initialization' stamp: 'hlsf 6/24/2022 09:33:01' prior: 50397667!
                initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel

	| o |
	container _ hostList.
	complexContents _ anObject.
	self initWithContents: anObject asString font: (Preferences at: #standardListFont) emphasis: nil.
	indentLevel _ 0.
	isExpanded _ false.
 	nextSibling _ firstChild _ nil.
	priorMorph ifNotNil: [
		priorMorph nextSibling: self.
	].
	o _ anObject withoutListWrapper.
	icon _ o ifNotNil: [ (o respondsTo: #icon) ifTrue: [ o icon ] ].
	icon isSymbol ifTrue: [ icon _ Theme current perform: icon ].
	indentLevel _ newLevel.
! !
!UpdatingLabelMorph class methodsFor: 'new-morph participation' stamp: 'hlsf 6/24/2022 09:33:04' prior: 50397689 overrides: 16895515!
 initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (Preferences at: #windowTitleFont)
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'hlsf 6/24/2022 09:33:06' prior: 50397704 overrides: 16877690!
                             initialize
	"initialize the state of the receiver"
	super initialize.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ Preferences at: #standardMenuFont.
	self contents: ''.! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'hlsf 6/24/2022 09:33:08' prior: 50397715!
                fontToUse
	| fontToUse |
	fontToUse := font ifNil: [Preferences at: #standardButtonFont].
	"
	Could add emphasis...
	^(emphasis isNil or: [emphasis = 0]) 
		ifTrue: [fontToUse]
		ifFalse: [fontToUse emphasized: emphasis]
	"
	^fontToUse! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'hlsf 6/24/2022 09:33:11' prior: 50397726 overrides: 16893272!
                              minimumExtent
	
	| unit |
	unit :=  (Preferences at: #windowTitleFont) pointSize.
	^label 
		ifNil: [ (unit+2) @ (unit+2) ] "Assume title button"
		ifNotNil: [ (4 * unit) @ (3 * unit) ] "Assure some space for text."
! !
!PluggableScrollPane methodsFor: 'initialization' stamp: 'hlsf 6/24/2022 09:33:14' prior: 50397737 overrides: 16911743!
            initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ #showIfNeeded.

	"initialize the receiver's scrollBars"
	scrollBar _ ScrollBar new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ ScrollBar new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ Preferences at: #drawKeyboardFocusIndicator.
	self addMorph: scrollBar.
	self addMorph: hScrollBar.
	self updateScrollBarsBounds.
	self innerMorphClass ifNotNil: [ :contentsClass |
		self scroller: contentsClass new ].! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'hlsf 6/24/2022 09:33:16' prior: 50397758 overrides: 16794207!
      drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle 
			borderWidth: (Preferences at: #focusIndicatorWidth)
			color: Theme current focusIndicator ]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'hlsf 6/24/2022 09:33:18' prior: 50397770 overrides: 16892287!
                               mouseEnter: event
	super mouseEnter: event.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'drawing' stamp: 'hlsf 6/24/2022 09:33:20' prior: 50397778 overrides: 16794207!
           drawOn: aCanvas
	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: (Preferences at: #focusIndicatorWidth)
			color: Theme current focusIndicator ].! !
!PluggableListMorph methodsFor: 'events' stamp: 'hlsf 6/24/2022 09:33:24' prior: 50397790 overrides: 16892287!
   mouseEnter: event
	super mouseEnter: event.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'hlsf 6/24/2022 09:33:21' prior: 50397798 overrides: 16912008!
          fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (Preferences at: #standardListFont).! !
!TextModelMorph methodsFor: 'drawing' stamp: 'hlsf 6/24/2022 09:33:28' prior: 50397805 overrides: 16794207!
           drawOn: aCanvas
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"
	| bw bc |
	self flag: #todo.
	"Integrate this method with the Theme system. --cbr"
	super drawOn: aCanvas.
	bw _ Preferences at: #focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [ "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan ]
			ifFalse: [
				scroller hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ]
					ifFalse: [
						scroller hasUnacceptedEdits ifTrue: [ bc _ Color red ]]]].
	(drawKeyboardFocusIndicator and: [ scroller hasKeyboardFocus ])
		ifTrue: [ bc ifNil: [ bc _ Theme current focusIndicator ]]
		ifFalse: [
			bc ifNotNil: [
				bc _ bc
					alphaMixed: 0.4
					with: Color white ]].
	bc ifNotNil: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: bw
			color: bc ].! !
!TextModelMorph methodsFor: 'events' stamp: 'hlsf 6/24/2022 09:33:30' prior: 50397842 overrides: 16892287!
                             mouseEnter: event
	super mouseEnter: event.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: scroller ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'hlsf 6/24/2022 09:33:41' prior: 50397849!
 drawLabelOn: aCanvas

	| x0 y0 f w availableW l |
	f _ Preferences at: #windowTitleFont.
	x0 _  f lineSpacing * 5 + borderWidth.
	y0 _ borderWidth * 6 // 10.
	availableW _ extent x - x0.
	l _ labelString.
	w _ f widthOfString: l.
	[ w > availableW ] whileTrue: [
		l _ l squeezedTo: (1.0 * l size * availableW / w) truncated.
		l isEmpty ifTrue: [ ^self ].
		w _ f widthOfString: l ].
	aCanvas
		drawString: l
		at: x0@y0
		font: f
		color: Theme current windowLabel
		embossed: Theme current embossedTitles! !
!SystemWindow methodsFor: 'events' stamp: 'hlsf 6/24/2022 09:33:46' prior: 50397869 overrides: 16892107!
                        wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph"
	^aMorph isWorldMorph or:[Preferences at: #systemWindowEmbedOK]! !
!SystemWindow methodsFor: 'label' stamp: 'hlsf 6/24/2022 09:33:44' prior: 50397877!
               labelHeight
	"Answer the height for the window label."
	^ (Preferences at: #windowTitleFont) lineSpacing+1! !
!SystemWindow methodsFor: 'menu' stamp: 'hlsf 6/24/2022 09:33:37' prior: 50397883!
                               addTileResizerMenuTo: aMenu
	"We can look at preferences here to decide what too do"
	(Preferences at: #tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 		action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 				action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 		action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 	action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asPlainString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].
	^aMenu.! !
!SystemWindow methodsFor: 'open/close' stamp: 'hlsf 6/24/2022 09:33:39' prior: 50397925!
                            closeBoxHit
	"The user clicked on the close-box control in the window title.  For Mac users only, the Mac convention of option-click-on-close-box is obeyed if the mac option key is down."

	(Preferences at: #dismissAllOnOptionClose) ifTrue:
		[Sensor rawMacOptionKeyPressed ifTrue:
			[^ self world closeUnchangedWindows]].
	self delete
! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:33:48' prior: 50397940 overrides: 16959689!
                   initialExtent

	^`540@400` * (Preferences at: #standardCodeFont) lineSpacing // 14! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:33:54' prior: 50397946!
                 buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:33:56' prior: 50397971!
                       buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."
	
	| codePane |
	
	codePane := self createCodePaneMorph.	
	(Preferences at: #shiftClickShowsImplementors)
		ifTrue: [ self addShiftClickEventHandlerFor: codePane ].
		
	^codePane! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:34:06' prior: 50397983!
   optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"

	| aList textConstructor |
	textConstructor _ [ :string :backgroundColor | 
		string asText addAttribute: (TextBackgroundColor color: backgroundColor) ].

	aList _ #(
		(10	'browse'			browseMethodFull							'view this method in a browser')
		(11	'senders' 			browseSendersOfMessages							'browse senders of...' 						browseSendersOfMethod)
		(16	'implementors'			browseMessages							'browse implementors of...' 						browseImplementors)
		(12	'versions'			browseVersions							'browse versions')), 

		((Preferences at: #decorateBrowserButtons)
			ifTrue: [
				{{13	. 'inheritance'.	 #methodInheritance. 	'Browse Method Inheritance

', (textConstructor value: 'green' value: `Color green muchLighter`),': sends to super
', (textConstructor value: 'tan' value: `Color tan`), ': has override(s)
', (textConstructor value: 'mauve' value: `Color blue muchLighter`), ': both of the above
', (textConstructor value: 'pink' value: `Color red muchLighter`), ': is an override but doesn''t call super
', (textConstructor value: 'pinkish tan' value: `Color r: 0.94 g: 0.823 b: 0.673`), ': has override(s), also is an override but doesn''t call super
'}}]
			ifFalse: [
				{#(13	'inheritance'		 methodInheritance	 'browse method inheritance')}]),

		#(
		(12	'hierarchy'			browseHierarchy							'browse class hierarchy')
		(10	'inst vars'			browseInstVarRefs							'inst var refs...')
		(11	'class vars'			browseClassVarRefs							'class var refs...')
		(10	'show...'			offerWhatToShowMenu							'menu of what to show in lower pane')).

	^ aList! !
!CodeWindow methodsFor: 'updating' stamp: 'hlsf 6/24/2022 09:34:00' prior: 50398038!
                 decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	(Preferences at: #decorateBrowserButtons)
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		`Color tan`.							"no sends to super. there is an override in some subclass"
		`Color red`.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		`Color red`.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		`Color red muchLighter`.			"doesn't have sub; has super but doesn't call it"
		`Color r: 0.94 g: 0.823 b: 0.673`.		"has sub; has super but doesn't call it"
		`Color green muchLighter`.			"doesn't have sub; has super and callsl it"
		`Color blue muchLighter`.			"has sub; has super and callsl it"

	} at: flags + 1.
	Theme current useUniformColors
		ifTrue: [
			aButton color: (self buttonColor mixed: 0.8 with: aColor) ]
		ifFalse: [
			aButton color: aColor ]! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:34:14' prior: 50398096 overrides: 50402223!
                               buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code _ self buildMorphicCodePane.
	comment _ self buildMorphicCommentPane.
	separator _ LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons _ LayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 18:03:12' prior: 50398129!
                               buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	classList _ self buildMorphicClassList.
	classColumn _ self buildMorphicClassColumnWith: classList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (Preferences at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 6/30/2022 18:03:14' prior: 50398174 overrides: 50388597!
                             buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model setSelectedSystemCategory: model systemCategoryList first.
	sysCatList _ PluggableListMorph
			model: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:
			mainView: self
			menuGetter: #codeFileListMenu
			keystrokeAction: #codeFileListKey:from:.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList _ PluggableListMorph
			model: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:
			mainView: self
			menuGetter: #messageCategoryMenu
			keystrokeAction: nil.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (Preferences at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!MessageSetWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:34:29' prior: 50398221 overrides: 50402374!
 buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:34:31' prior: 50398247 overrides: 16959689!
                           initialExtent
	^`540@300` * (Preferences at: #standardCodeFont) lineSpacing // 14! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:34:36' prior: 50398254 overrides: 50402223!
                          buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons _ LayoutMorph newColumn.
	h _ self defaultButtonPaneHeight.
	(Preferences at: #optionalButtons) ifTrue: [
		h _ self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:34:38' prior: 50398288 overrides: 16959689!
                         initialExtent
	^ `640 @ 320` * (Preferences at: #standardCodeFont) lineSpacing // 14! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'hlsf 6/24/2022 09:34:40' prior: 50398294!
open: model label: aString message: messageString
	
	((Preferences at: #usePreDebugWindow) or: [messageString notNil])
		ifTrue: [self forceOpen: model label: aString message: messageString]
		ifFalse: [model openFullMorphicLabel: aString ]! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 6/30/2022 18:08:28' prior: 50398305!
               volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	model currentDirectorySelected
		ifNil: [ aMenu add: 'initial directory' action: #yourself :: isEnabled: false ]
		ifNotNil: [ :selectedWrapper |
	aMenu 
		add: (Preference isInitialFileListDirectory: selectedWrapper item)
			asMenuItemTextPrefix, 'initial directory'
		action: #toggleInitialDirectory ::
			setBalloonText: 'The selected directory is an initial director for new file list windows' ].
	initialDirectoriesMenu _ MenuMorph new.
	#(
		(roots  'default roots' 'Use the usual root directories. Drives on Windows; "/" on Unix')
	   	(image 'image directory' 'Use the directory with Smalltalk image')
		(vm 'VM directory' 'Use the virtual machine directory')
		(current 'current directory' 'Use the current directory; usually the directory the VM was started in')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: Preferences
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:35:07' prior: 50398350 overrides: 16959689!
                        initialExtent

	^`600@325` * (Preferences at: #standardCodeFont) lineSpacing // 14! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'hlsf 6/24/2022 09:35:09' prior: 50398357 overrides: 16959689!
                   initialExtent

	^`300@500` * (Preferences at: #standardCodeFont) lineSpacing // 14! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 6/24/2022 09:35:18' prior: 50398363!
                  addItemsFromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object. If nil, use defaultTarget. If a Symbol, send it as message to defaultTarget to get real target.
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item wantsIcons |
	wantsIcons _ Preferences at: #wantsMenuIcons.
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ self addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object ifAbsent: [defaultTarget].
				realTarget isSymbol ifTrue: [ realTarget _ defaultTarget perform: realTarget ].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						self
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						self
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				wantsIcons ifTrue: [
					dict
						at: #icon
						ifPresent: [ :symbolOrFormOrNil |
							item setIcon: symbolOrFormOrNil ]].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]]! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 6/24/2022 09:35:22' prior: 50398416!
                           addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preferences at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW _ Theme current titleBarButtonsExtent x.
	closeButton _ PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; color: `Color transparent`.
	pinButton _ PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; color: `Color transparent`.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW);
			color: `Color transparent`;
			addMorph: closeButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 6/24/2022 09:35:26' prior: 50398466!
   addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w newMorph |
	
	newMorph _ BoxedMorph new noBorder.
	newMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line | | font |
		font _ Preferences at: #standardMenuFont.
		s _ LabelMorph new
			contents: line;
			font: (titleMorph
				ifNil: [ font bold ]
				ifNotNil: [ font italic ])..
		newMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ newMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	newMorph morphExtent: (w + 16) @ (pp y).
	titleMorph
		 ifNil: [
			titleMorph _ newMorph.
			self addMorphFront: titleMorph ]
		ifNotNil: [ self addMorphBack: newMorph ].
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'hlsf 6/24/2022 09:35:32' prior: 50398499!
        popUpAt: aPoint forHand: hand in: aWorld
	"Present this menu at the given point under control of the given hand.  Allow keyboard input into the menu."

	^ self 
		popUpAt: aPoint 
		forHand: hand 
		in: aWorld 
		allowKeyboard: (Preferences at: #menuKeyboardControl)! !
!MenuMorph methodsFor: 'control' stamp: 'hlsf 6/24/2022 09:35:34' prior: 50398511 overrides: 16892107!
           wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph.  A single-item MenuMorph is in effect a button rather than a menu, and as such should not be reluctant to be dropped into another object."

	^ (aMorph isWorldMorph or: [submorphs size = 1]) or:
		[Preferences at: #systemWindowEmbedOK]! !
!MenuMorph methodsFor: 'modal control' stamp: 'hlsf 6/24/2022 09:35:29' prior: 50398524!
                               invokeModal
	"Invoke this menu and don't return until the user has chosen a value.
	See example below on how to use modal menu morphs."
	^ self invokeModal: (Preferences at: #menuKeyboardControl)

	"
	| menu sub entry |
	menu _ MenuMorph new.
	1 to: 3 do: [:i |
		entry _ 'Line', i printString.
		sub _ MenuMorph new.
		menu add: entry subMenu: sub.
		#('Item A' 'Item B' 'Item C')  do:[:subEntry|
			sub add: subEntry target: menu 
				action: #modalSelection: argument: {entry. subEntry}]].
	menu invokeModal.
	"! !
!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'hlsf 6/24/2022 09:35:37' prior: 50398544!
                    listFont

	^Preferences at: #standardListFont! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'hlsf 6/24/2022 09:35:41' prior: 50398549 overrides: 16896706!
sendEventTo: aMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		self isFindClassShortcut
			ifTrue: [ ^ (Preferences at: #classFinder) value ].
		self isCloseWindowShortcut
			ifTrue: [ ^ self closeCurrentWindowOf: aMorph ].
		^ aMorph processKeystroke: self ].
	type == #keyDown ifTrue: [
		^ aMorph processKeyDown: self ].
	type == #keyUp ifTrue: [ 
		^ aMorph processKeyUp: self ].
	^ super sendEventTo: aMorph.! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'hlsf 6/24/2022 09:35:52' prior: 50398567 overrides: 16896679!
                 dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt _ false.
	grabAMorph _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self) ifTrue: [
				eventHandler _ aMorph.
				aMorphHandlesIt _ true ].
			"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
			self mouseButton1Pressed ifTrue: [
				aMorph owner ifNotNil: [ :o |
					(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
						grabAMorph _ true ]]]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(Preferences at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ aMorph is: #SystemWindow :: ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'hlsf 6/24/2022 09:36:20' prior: 50398767!
     fullDraw: aMorph
	"Draw the full Morphic structure on us"
	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."

	aMorph visible ifFalse: [^ self].
	self into: aMorph.

	currentMorph layoutSubmorphsIfNeeded.

	currentMorph isKnownFailing ifTrue: [
		self canvasToUse drawCurrentAsError.
		self outOfMorph.
		^ self].

	(currentMorph isOwnedByHand and: [
			(Preferences at: #cheapWindowReframe) and: [currentMorph is: #SystemWindow]]) ifTrue: [
		self drawCurrentAsOutline.
		self outOfMorph.
		^ self].

	"Draw current Morph and submorphs"	
	self canvasToUse drawCurrentAndSubmorphs.

	self outOfMorph! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:36:23' prior: 50398791!
                   buttonPaneHeight
	"Answer the user's preferred default height for button panes."

	^(Preferences at: #standardButtonFont) lineSpacing * 14 // 8! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:39:31' prior: 50398799!
                        fullScreenDeskMargin
	^ (Preferences at: #fullScreenLeavesDeskMargins) ifTrue: [48] ifFalse: [0]! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:39:45' prior: 50398805!
       layoutAdjusterThickness

	self flag: #todo.  "Revisit this; consider moving proportional stuff out of Theme entirely."
	
	^ (Preferences at: #standardListFont) pointSize // 3! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:39:51' prior: 50398814!
                         roundedButtonRadius
	"Only effective if #roundButtons answers true.
	Provide a reasonable default for subclasses."
	^ Preferences at: #roundedButtonRadius! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:39:53' prior: 50398822!
             roundedWindowRadius
	"Only effective if #roundWindowCorners answers true.
	Provide a reasonable default for subclasses."
	^Preferences at: #roundedWindowRadius! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:39:55' prior: 50398830!
        scrollbarThickness
	^ Preferences at: #scrollbarThickness! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:39:57' prior: 50398835!
              titleBarButtonsExtent
	"Answer the extent to use for close & other title bar buttons.  
	The label height is used to be proportional to the fonts preferences."
	| e |
	e _ (Preferences at: #windowTitleFont) pointSize * 13 // 10.
	^e@e! !
!Theme methodsFor: 'other options' stamp: 'hlsf 6/24/2022 09:40:15' prior: 50398846!
                             windowBorderWidth
	| w |
	w _ (Preferences at: #standardListFont) pointSize / 11.
	w _ w * (self roundWindowCorners ifTrue: [4] ifFalse: [2]).
	^ w rounded max: 1! !
!Theme methodsFor: 'private - shout mappings' stamp: 'hlsf 6/24/2022 09:39:36' prior: 50398855!
                          italic
	^(Preferences at: #italicsInShout)
		ifTrue: [ #italic ]
		ifFalse: [ #normal ]! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 6/24/2022 09:39:13' prior: 50398861!
         changeFontSizes
	| options menu preference  |
	preference _ Preferences instanceAt: #guiElementsSize.
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		(menu add: pair first target: preference action: #value: argument: pair second)
			isSelected: preference value == pair second  ].
	menu popUpInWorld: self runningWorld.! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 6/24/2022 09:39:59' prior: 50398883!
 useMenuIcons
	Preferences at: #wantsMenuIcons put: true! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 6/24/2022 09:40:01' prior: 50398888!
         useNoMenuIcons
	Preferences at: #wantsMenuIcons put: false! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'hlsf 6/24/2022 09:40:32' prior: 50398893!
            fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	nameToUse _ self name.
	nameToUse _ nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse _ (Preferences at: #changeSetVersionNumbers)
				ifTrue: [
					DirectoryEntry currentDirectory
						nextNameFor: nameToUse coda: '-', Utilities authorInitials
						extension: 'cs.st' ]
				ifFalse: [ (nameToUse , '.' , Utilities dateTimeSuffix , '.cs.st') asFileName ].
		
	nameToUse asFileEntry writeStreamDo: [ :stream |
		stream timeStamp.
		self fileOutPreambleOn: stream.
		self fileOutOn: stream.
		self fileOutPostscriptOn: stream ].
	
	self hasUnsavedChanges: false.
	(Preferences at: #checkForSlips) 		ifFalse: [^ self].
	slips _ self checkForSlips.
	(slips notEmpty
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'hlsf 6/24/2022 09:40:38' prior: 50398935!
preambleTemplate
	"Answer a string that will form the default contents for a change set's preamble.
	Just a first stab at what the content should be."

	^ String streamContents: [:strm |
		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."
		strm tab;tab; nextPutAll: self name.
		strm newLine; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.
		strm newLine; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: (Preferences at: #defaultAuthorName).
		strm newLine; newLine; nextPutAll: '<your descriptive text goes here>"']
"
ChangeSet changeSetForBaseSystem preambleTemplate
"! !
!ChangeSet class methodsFor: 'services' stamp: 'hlsf 6/24/2022 09:40:34' prior: 50398958!
        install: aFileEntry
	"File in the entire contents of the file specified by the name provided.
	Do not affect the user change sets, store changes in separate one"

	ChangeSet installing: aFileEntry name do: [ self fileIn: aFileEntry ].
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		('Installed ChangeSet: ', aFileEntry name) print]! !
!CodeFile methodsFor: 'fileIn/fileOut' stamp: 'hlsf 6/24/2022 09:40:42' prior: 50398972!
                  fileIn
	| doitsMark |
	doitsMark := 1.
	doIts isEmpty ifFalse:[doitsMark := self askForDoits].
	doitsMark = 4 ifTrue: [^nil].
	doitsMark = 2 ifTrue:[self fileInDoits].
	classOrder do:[:cls|
		cls fileInDefinition.
	].
	classes do:[:cls|
		(Preferences at: #transcriptLogVerbose) ifTrue: [
			Transcript newLine; show:'Filing in ', cls name].
		cls fileInMethods.
		cls hasMetaclass ifTrue:[cls theMetaClass fileInMethods].
	].
	doitsMark = 3 ifTrue: [ self fileInDoits ]! !
!CodePackageFile methodsFor: 'services' stamp: 'hlsf 6/24/2022 09:40:48' prior: 50398990!
            install
	"Create, install and answer a (sub)instance of CodePackage
	Replace all existing code in the possibly existing CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS _ ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS _ nil ].
		pckClass _ CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				((self packageName asIdentifier: true), 'Package') = ee name ifTrue: [
					ee fileInDefinitionAndMetaclass.
					pckClass _ Smalltalk at: ee name ]]].
		newCodePackage _ pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.

		fullName asFileEntry readStreamDo: [ :stream | stream fileInAnnouncing: 'Installing ', localName, '...' ].
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].

	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
		Smalltalk cleanOutUndeclared.
		Undeclared notEmpty ifTrue: [
			('Undeclared: ', Undeclared printString) print ]].
	^newCodePackage! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 6/24/2022 09:40:50' prior: 50399060!
                 reportAboutToRun: aTestCase
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'Will run: '; print: aTestCase; newLine]! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 6/24/2022 09:40:53' prior: 50399067!
                              reportFailed: aTestCase because: anException
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		Transcript print: anException; newLine].! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 6/24/2022 09:40:54' prior: 50399074!
                              reportPassed: aTestCase
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'finished.'; newLine]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:41:47' prior: 50399082 overrides: 16930632!
                           privateFormatAndConvert
	"Perform any formatting of formattedText necessary and store or a formatted copy in formattedText"
	(Preferences at: #syntaxHighlightingAsYouTypeAnsiAssignment) ifTrue: [
		self convertAssignmentsToAnsi ].
	(Preferences at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) ifTrue: [
		self convertAssignmentsToLeftArrow ]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'hlsf 6/24/2022 09:41:51' prior: 50399097 overrides: 16930636!
                    privateStyle

	| alpha end start count startIndexes c hue |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	(Preferences at: #highlightBlockNesting) ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 10.0 min: 1.0.
			hue _ depth * 60.
			c _ Color h: hue s: 0.2 v: 0.5 alpha: alpha.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor color: c ) 
				from: start 
				to: end ]]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'hlsf 6/24/2022 09:40:59' prior: 50399122!
              ansiAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeAnsiAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeLeftArrowAssignment
	to be turned off"
	(Preferences at: #syntaxHighlightingAsYouTypeAnsiAssignment) 		ifTrue: [
		Preferences at: #syntaxHighlightingAsYouTypeLeftArrowAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'hlsf 6/24/2022 09:41:43' prior: 50399137!
           leftArrowAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeLeftArrowAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeAnsiAssignment
	to be turned off"
	(Preferences at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) 		ifTrue:[
		Preferences at: #syntaxHighlightingAsYouTypeAnsiAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'class initialization' stamp: 'hlsf 6/24/2022 09:41:05' prior: 50399153 overrides: 16904184!
          initialize  
	"Clear styleTable and textAttributesByPixelSize cache so that they will 
	reinitialize.	 

		SHTextStylerST80 initialize
	" 
	
	styleTable := nil.
	textAttributes := nil.	
	"We want to be  informed at preference changes"
	(Preferences instanceAt: #syntaxHighlightingAsYouTypeAnsiAssignment)
		when: #preferenceChanged
		send: #ansiAssignmentPreferenceChanged
		to: self.
	(Preferences instanceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment)
		when: #preferenceChanged
		send: #leftArrowAssignmentPreferenceChanged
		to: self! !
!PopUpMenu methodsFor: 'accessing' stamp: 'hlsf 6/24/2022 09:41:53' prior: 50399173!
        frameHeight
	"Designed to avoid the entire frame computation (includes MVC form),
	since the menu may well end up being displayed in Morphic anyway."
	| nItems |
	nItems _ 1 + labelString lineCount.
	^ (nItems * (Preferences at: #standardMenuFont) lineSpacing) + 4 "border width"! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 6/24/2022 09:41:54' prior: 50399185!
   startUpNonModalWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self 
		startUpNonModalWithCaption: captionOrNil 
		at: Sensor mousePoint 
		allowKeyboard: (Preferences at: #menuKeyboardControl)! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 6/24/2022 09:42:07' prior: 50399198!
                           startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean
	"This menu is too big to fit comfortably on the screen.
	Break it up into smaller chunks, and manage the relative indices.
	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

"
(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; newLine]. s skipBack])
		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'.
"
	| nLines nLinesPer allLabels from to subset subLines index |
	allLabels := labelString lines.
	nLines _ allLabels size.
	lineArray ifNil: [lineArray _ Array new].
	nLinesPer _ segmentHeight // (Preferences at: #standardMenuFont) lineSpacing - 5.
	from := 1.
	[ true ] whileTrue: [
		to := (from + nLinesPer) min: nLines.
		subset := (allLabels copyFrom: from to: to) asOrderedCollection.
		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])
			before: subset first.
		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].
		subLines _ (Array with: 1) , subLines.
		index := (PopUpMenu labels: subset printStringWithNewline lines: subLines)
					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
		index = 1
			ifTrue: [from := to + 1.
					from > nLines ifTrue: [ from := 1 ]]
			ifFalse: [index = 0 ifTrue: [^ 0].
					^ from + index - 2]]! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 6/24/2022 09:42:09' prior: 50399247!
                              startUpWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self 
		startUpWithCaption: captionOrNil 
		at: Sensor mousePoint 
		allowKeyboard: (Preferences at: #menuKeyboardControl)! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'hlsf 6/24/2022 09:42:12' prior: 50399259!
preferredAssignmentOperator

	^ (Preferences at: #leftArrowAssignmentsInGeneratedCode)
		ifTrue: [ '_' ]
		ifFalse: [ ':=' ]! !

SHTextStylerST80 initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5338-UseGlobal-Preferences-JuanVuletich-2022Jun30-17h54m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5337] on 30 June 2022 at 6:50:24 pm'!
!SystemDictionary methodsFor: 'ui' stamp: 'jmv 6/30/2022 18:49:27' prior: 50396073!
   beep
	"
	Smalltalk beep
	"
	(Preferences at: #soundsEnabled) ifTrue: [
		Smalltalk
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 6/30/2022 18:39:49' prior: 50394069!
           init
" Not name #initialize to avoid auto start at class installation "
	#(gui font programming system) with: #(prefGui prefFont prefProgramming prefSystem) do: [ :category :selector |
		(self perform: selector) do: [ :aPrefArray |
			self installDefault: aPrefArray in: category ] ].
	self installHaloPreferencesWith: self iconicHaloSpecifications.
	self installMiscPreferences.
	self defaultFontSize: #standardFonts.
	self setDefaultFont: FontFamily defaultFamilyName.! !
!PreferenceSet class methodsFor: 'file list' stamp: 'jmv 6/30/2022 18:42:00'!
                        isInitialFileListDirectory: aDirectoryEntry
	"Answer true if aDirectoryEntry is an initial directory entry."

	| currentValue |
	(currentValue _ Preferences at: #initialFileListDirectories) isSymbol 		ifTrue: [ ^ false ].
	^ currentValue includes: aDirectoryEntry! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 6/30/2022 18:42:28' prior: 50402584!
                        volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	model currentDirectorySelected
		ifNil: [ aMenu add: 'initial directory' action: #yourself :: isEnabled: false ]
		ifNotNil: [ :selectedWrapper |
	aMenu 
		add: (PreferenceSet isInitialFileListDirectory: selectedWrapper item)
			asMenuItemTextPrefix, 'initial directory'
		action: #toggleInitialDirectory ::
			setBalloonText: 'The selected directory is an initial director for new file list windows' ].
	initialDirectoriesMenu _ MenuMorph new.
	#(
		(roots  'default roots' 'Use the usual root directories. Drives on Windows; "/" on Unix')
	   	(image 'image directory' 'Use the directory with Smalltalk image')
		(vm 'VM directory' 'Use the virtual machine directory')
		(current 'current directory' 'Use the current directory; usually the directory the VM was started in')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: Preferences
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !

Preference class removeSelector: #isInitialFileListDirectory:!

!methodRemoval: Preference class #isInitialFileListDirectory: stamp: 'Install-5339-Preferences-oddsAndEnds-JuanVuletich-2022Jun30-18h34m-jmv.001.cs.st 7/5/2022 10:30:15'!
isInitialFileListDirectory: x
^false!

Preference class removeSelector: #soundsEnabled!

!methodRemoval: Preference class #soundsEnabled stamp: 'Install-5339-Preferences-oddsAndEnds-JuanVuletich-2022Jun30-18h34m-jmv.001.cs.st 7/5/2022 10:30:15'!
soundsEnabled
^true!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences name: #soundsEnabled category: #system value: true
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5339-Preferences-oddsAndEnds-JuanVuletich-2022Jun30-18h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5337] on 30 June 2022 at 6:59:04 pm'!
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 6/30/2022 18:58:09'!
     disableFocusFollowsMouse
	Preferences name: #focusFollowsMouse category: #gui value: false! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 6/30/2022 18:58:19'!
                            enableFocusFollowsMouse
	Preferences name: #focusFollowsMouse category: #gui value: true! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 6/30/2022 18:56:28' prior: 50398663!
          preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: {
			{
				#label 			-> 		'Focus follows mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#readAdditionalTrueTypeFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5340-Preferences-TheWorldMenu-JuanVuletich-2022Jun30-18h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5337] on 30 June 2022 at 7:13:37 pm'!
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 6/30/2022 19:10:15' prior: 50400788!
                installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	self sysPreferences

		name: #haloHandleSize 
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 5 // 3 max: 16];
	
		name: #roundedButtonRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 8 // 14];
		
		name: #roundedWindowRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize] ;
		
		name: #scrollbarThickness 
		category: #gui 		
		value: [(Preferences at: #windowTitleFont) pointSize + 2];
		
		name: #classFinder 
		category: #programming 
		value: [ BrowserWindow findClass ];
		
		name: #defaultAuthorName 
		category: #programming 
		value: [Utilities authorName].! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'jmv 6/30/2022 19:10:06' prior: 50400817!
                        defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preferences name: #standardListFont category: #font value: font.
	Preferences name: #standardMenuFont category: #font value: font.
	Preferences name: #standardCodeFont category: #font value: font.
	Preferences name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preferences name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preferences at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font! !

Preference class removeSelector: #menuIcon:!

!methodRemoval: Preference class #menuIcon: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
menuIcon: wantsMenuIconsPref
	Theme current class beCurrent
" Copied to PreferenceSet "!

Preference class removeSelector: #name:description:category:type:value:!

!methodRemoval: Preference class #name:description:category:type:value: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
"If I exist, I am updated with the newer sent data "
	(nameSymbol isSymbol or: [categorySymbol isSymbol]) ifFalse: 
		[self error: 'Preference Name & Category are not valid symbol.'].
	^ ThePreferences 
		at: nameSymbol
		ifPresent: [:thePref |
			thePref 
				description: aString;
				category: categorySymbol;
				value: aValue;
				yourself]
		ifAbsent: [ | newPref |
			newPref _ self new ::
				name: nameSymbol 
				description: aString 
				category: categorySymbol 
				type: aType 
				value: aValue.
			ThePreferences at: nameSymbol put: newPref ].
" Copied to PreferenceSet "!

Preference class removeSelector: #name:category:value:!

!methodRemoval: Preference class #name:category:value: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
name: nameSymbol category: categorySymbol value: aValue
	self name: nameSymbol description: nil category: categorySymbol type: nil value: aValue 
" Copied to PreferenceSet "!

Preference class removeSelector: #machine:!

!methodRemoval: Preference class #machine: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray |
	prefArray _ self perform: (#machine, machinePref value capitalized) asSymbol.
	prefArray do: [:array | 		Preference at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]
" Copied to PreferenceSet "!

Preference class removeSelector: #fontSizes!

!methodRemoval: Preference class #fontSizes stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
fontSizes
	^ `{
		#tinyFonts -> 7 .
		#verySmallFonts -> 9 .
		#smallFonts ->11 .
		#standardFonts -> 14 .
		#largeFonts -> 18 .
		#veryLargeFonts -> 24 .
		#hugeFonts -> 32} asDictionary`
" Copied to PreferenceSet "!

Preference class removeSelector: #pointer:!

!methodRemoval: Preference class #pointer: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
pointer: pointerPref
	| enabled |
	enabled _ pointerPref value == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 		Preference at: aPref put: enabled]
" Copied to PreferenceSet "!

Preference class removeSelector: #openPreferencesInspector!

!methodRemoval: Preference class #openPreferencesInspector stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
openPreferencesInspector
	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"
	
	self allPreferences inspectWithLabel: 'Preferences'
" Copied to PreferenceSet "!

Preference class removeSelector: #desktopMenuTitle!

!methodRemoval: Preference class #desktopMenuTitle stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
desktopMenuTitle
"I have project to get rid of this one"
	^ 'World' 
" Copied to PreferenceSet "!

Preference class removeSelector: #assignmentGlyph:!

!methodRemoval: Preference class #assignmentGlyph: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
assignmentGlyph: assignmentPref
" #assignmentGliphSelector changed "
	AbstractFont withAllSubclassesDo: [ :fontClass | fontClass assignmentGlyphSelectorPreferenceChanged ]
" Copied to PreferenceSet "!

Preference class removeSelector: #setDefaultFont:!

!methodRemoval: Preference class #setDefaultFont: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	Preference
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (Preferences at: #standardListFont) pointSize.}.
				{#standardMenuFont. (Preferences at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (Preferences at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (Preferences at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (Preferences at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
" Copied to PreferenceSet "!

Preference class removeSelector: #setDefaultFont:spec:!

!methodRemoval: Preference class #setDefaultFont:spec: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
setDefaultFont: fontFamilyName spec: defaultFontsSpec
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font _ font emphasized: triplet third ].
		Preference at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
" Copied to PreferenceSet "!

Preference class removeSelector: #defaultFontSize:!

!methodRemoval: Preference class #defaultFontSize: stamp: 'Install-5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st 7/5/2022 10:30:15'!
defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	Preference name: #standardListFont category: #font value: font.
	Preference name: #standardMenuFont category: #font value: font.
	Preference name: #standardCodeFont category: #font value: font.
	Preference name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	Preference name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	Preferences at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^ font
" Copied to PreferenceSet "!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5341-Cleanup-JuanVuletich-2022Jun30-18h59m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5341] on 30 June 2022 at 7:32:06 pm'!

Preference class removeSelector: #selectCategory:!

!methodRemoval: Preference class #selectCategory: stamp: 'Install-5342-Cleanup-JuanVuletich-2022Jun30-19h21m-jmv.001.cs.st 7/5/2022 10:30:15'!
selectCategory: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]
" Copied to PreferenceSet "!

Preference class removeSelector: #at:put:!

!methodRemoval: Preference class #at:put: stamp: 'Install-5342-Cleanup-JuanVuletich-2022Jun30-19h21m-jmv.001.cs.st 7/5/2022 10:30:15'!
at: symbolName put: aValue
	| myPref |
	myPref _ self instanceAt: symbolName. 
	myPref value: aValue
" Copied to PreferenceSet "!

Preference class removeSelector: #categories!

!methodRemoval: Preference class #categories stamp: 'Install-5342-Cleanup-JuanVuletich-2022Jun30-19h21m-jmv.001.cs.st 7/5/2022 10:30:15'!
categories
	| categories |
	categories _ Set new.
	ThePreferences values do: [:aPreference | categories add: aPreference category].
	^ categories sorted
" Copied to PreferenceSet "!

Preference class removeSelector: #instanceAt:!

!methodRemoval: Preference class #instanceAt: stamp: 'Install-5342-Cleanup-JuanVuletich-2022Jun30-19h21m-jmv.001.cs.st 7/5/2022 10:30:15'!
instanceAt: symbolName
	^ ThePreferences at: symbolName ifAbsent: [self error: 'Unknown preference ', symbolName ]
" Copied to PreferenceSet "!

Preference class removeSelector: #allPreferences!

!methodRemoval: Preference class #allPreferences stamp: 'Install-5342-Cleanup-JuanVuletich-2022Jun30-19h21m-jmv.001.cs.st 7/5/2022 10:30:15'!
allPreferences
	^ ThePreferences 
" Copied to PreferenceSet "!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PreferenceSet installMiscPreferences!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5342-Cleanup-JuanVuletich-2022Jun30-19h21m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5341] on 30 June 2022 at 7:32:36 pm'!

Object subclass: #Preference
	instanceVariableNames: 'name description category value type '
	classVariableNames: 'ThePreferences '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #Preference category: #'System-Support' stamp: 'Install-5343-Cleanup-JuanVuletich-2022Jun30-19h32m-jmv.001.cs.st 7/5/2022 10:30:15'!
Object subclass: #Preference
	instanceVariableNames: 'name description category value type'
	classVariableNames: 'ThePreferences'
	poolDictionaries: ''
	category: 'System-Support'!

Preference class removeSelector: #doesNotUnderstand:!

!methodRemoval: Preference class #doesNotUnderstand: stamp: 'Install-5343-Cleanup-JuanVuletich-2022Jun30-19h32m-jmv.001.cs.st 7/5/2022 10:30:15'!
doesNotUnderstand: aMessage
	aMessage hasArguments ifTrue: [^ super doesNotUnderstand: aMessage].
	^ self at: aMessage selector
" Copied to PreferenceSet "!

Preference class removeSelector: #at:!

!methodRemoval: Preference class #at: stamp: 'Install-5343-Cleanup-JuanVuletich-2022Jun30-19h32m-jmv.001.cs.st 7/5/2022 10:30:15'!
at: symbolName
	^ (self instanceAt: symbolName) value
" Copied to PreferenceSet "!

Object subclass: #Preference
	instanceVariableNames: 'name description category value type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #Preference category: #'System-Support' stamp: 'Install-5343-Cleanup-JuanVuletich-2022Jun30-19h32m-jmv.001.cs.st 7/5/2022 10:30:15'!
Object subclass: #Preference
	instanceVariableNames: 'name description category value type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5343-Cleanup-JuanVuletich-2022Jun30-19h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5341] on 30 June 2022 at 7:53:07 pm'!
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'jmv 6/30/2022 19:51:02' prior: 50394265!
                      machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray selector |
	selector _ machinePref caseOf: {
			[#default]		 		-> [#machineDefault].
			[#slow] 				-> [#machineSlow].
			[#smalltalk80] 				-> [#machineSmalltalk80] }
		otherwise: [ #default ].
	prefArray _ self perform: selector.
	prefArray do: [:array | 		self sysPreferences at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]! !

PreferenceSet class removeSelector: #migrate!

!methodRemoval: PreferenceSet class #migrate stamp: 'Install-5344-Cleanup-JuanVuletich-2022Jun30-19h32m-jmv.001.cs.st 7/5/2022 10:30:15'!
migrate
" Migrate from Preference class var to PreferenceSet. 
I will copy the Preference dictionary into a PreferenceSet instance, 
then assign this PreferenceSet instance to the global variable Preferences "
| preferences |
	preferences _ self new.
	preferences instVarNamed: #contents put: Preference allPreferences.
	Smalltalk at: #Preferences put: preferences !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5344-Cleanup-JuanVuletich-2022Jun30-19h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5344] on 1 July 2022 at 8:26:48 pm'!
!TestCase methodsFor: 'assertions' stamp: 'jmv 7/1/2022 19:55:24'!
               assert: actual equalsExpected: expected
	^ self
		assert: actual = expected
		description: [ self comparingStringBetween: expected and: actual ]
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5345-assert-equalsExpected-JuanVuletich-2022Jul01-20h26m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5344] on 1 July 2022 at 8:47:11 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/1/2022 20:47:04' prior: 50337978!
   newUIProcessIfNeeded
	"Answer is not nil only if a new process was created."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isBlocked | oldUIProcess isSuspended | oldUIProcess isTerminated ifTrue: [
			oldUIProcess 	animatedUI ifNotNil: [ :guiRootObject |
				self spawnNewMorphicProcessFor: guiRootObject.
				^oldUIProcess ]]].
	^nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5346-UserInterruptOnBlockedUIProcess-JuanVuletich-2022Jul01-20h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5346] on 2 July 2022 at 4:46:25 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/2/2022 16:45:28' prior: 16975442!
                   newProcessIfUI: suspendedProcess
	"Answer the UI we created a new process for.
	If not an UI process, still guarantee that the UI process is runnable."

	suspendedProcess animatedUI ifNotNil: [ :guiRootObject |
		self spawnNewMorphicProcessFor: guiRootObject.
		^guiRootObject ].
	UISupervisor newUIProcessIfNeeded ifNotNil: [ :oldUIProcess |
		oldUIProcess isTerminated ifFalse: [
			oldUIProcess terminate ]].
	^nil
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5347-DebuggerMightNeedNewUIProcess-provideIt-JuanVuletich-2022Jul02-16h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5347] on 3 July 2022 at 7:02:28 pm'!

PreferenceSet class removeSelector: #menuIcon:!

!methodRemoval: PreferenceSet class #menuIcon: stamp: 'Install-5348-MigrateEventListenersToPreferenceSet-HilaireFernandes-2022Jul03-18h52m-hlsf.001.cs.st 7/5/2022 10:30:15'!
menuIcon: wantsMenuIconsPref
	Theme current class beCurrent!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
(Preferences allPreferences select: [:each |
	each actionMap notNil ]) valuesDo: [:aPref | | messageSend |
		messageSend _ aPref actionMap at: #preferenceChanged.
		messageSend receiver = Preference ifTrue: [
		messageSend receiver: PreferenceSet]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5348-MigrateEventListenersToPreferenceSet-HilaireFernandes-2022Jul03-18h52m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5347] on 3 July 2022 at 10:20:12 pm'!
!PreferenceSet methodsFor: 'initialization' stamp: 'hlsf 7/3/2022 22:15:45' overrides: 16920235!
                  initialize
	super initialize.
	contents _ Dictionary new.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5349-PreferenceSet-Initialize-Hilaire-2022Jul03-22h19m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5349] on 4 July 2022 at 10:22:28 am'!
!Parser methodsFor: 'error handling' stamp: 'jmv 7/4/2022 10:12:51' prior: 16907406 overrides: 16931658!
                notify: string at: location
	| adjustedLocation |
	adjustedLocation _ location - self sourceDelta.
	requestor
		ifNil: [
			(encoder == self or: [encoder isNil]) ifTrue: [
				^ self fail ]. "failure setting up syntax error"
			SyntaxErrorNotification
				inClass: encoder classEncoding
				category: category
				withCode: 
					(source contents
						copyReplaceFrom: adjustedLocation
						to: adjustedLocation - 1
						with: string , ' ->')
				doitFlag: doitFlag
				errorMessage: string
				location: adjustedLocation]
		ifNotNil: [
			requestor
				notify: string , ' ->'
				at: adjustedLocation
				in: source].
	^self fail! !
!Parser methodsFor: 'scanning' stamp: 'jmv 7/4/2022 10:00:32' prior: 50400529!
                    transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a series of consecutive vertical bars, up arrows, colons and regular binary selector characters.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain.
	Another special case is binary selectors ending in $-, like in
	1@-2
	This could be interpreted as `1 @ -2` or `1 @- 2`. Preference #atMinusDigitMeaning tells what to do."

	| toMakeBinary |
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	"Note: Also include #binary, to allow stuff like #+| where a special character comes after after a regular binary operator character. "
	toMakeBinary _ #(binary verticalBar upArrow colon).
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here _ here asPlainString.
	hereType _ #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			(token == #- and: [hereChar isDigit])
				ifTrue: [
					(Preferences at: #atMinusDigitMeaning) == #disabled
						"Disallow `1@-2`. Insists on some whitespace to disambiguate."
						ifTrue: [ ^self expected: 'A space character after selector' ].
					(Preferences at: #atMinusDigitMeaning) == #st80
						ifTrue: [ ^self ].				"interpret `1@-2` like `1 @ -2`"
					"Assume (Preferences at: #atMinusDigitMeaning) == #ansiSmalltalk
					interpret `1@-2` like `1 @- 2`, i.e. consider #@- a valid binary selector"
					].
			here _ here , token asPlainString.
			hereEnd _ hereEnd + 1.
			self scanToken ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5350-ParserFix-JuanVuletich-2022Jul04-10h21m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5350] on 4 July 2022 at 5:26:53 pm'!
!UISupervisor class methodsFor: 'services' stamp: 'jar 7/4/2022 17:08:26'!
                              isUIProcessRunning
	"Is the currently running process the UI Process?"

	^UIProcess isRunning! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/4/2022 17:05:34' prior: 50404183!
 newProcessIfUI: suspendedProcess
	"Answer the UI we created a new process for.
	If not an UI process, still guarantee that the UI process is runnable."

	suspendedProcess animatedUI ifNotNil: [ :guiRootObject |
		self spawnNewMorphicProcessFor: guiRootObject.
		^guiRootObject ].
	^nil
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/4/2022 17:24:14' prior: 16975452!
  spawnNewMorphicProcessFor: guiRootObject
	"
	Safe to run anytime, as the old Morphic process will end by itself.
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.
	"
	| previousUIProcess |
	previousUIProcess _ UIProcess.
	UIProcess _ guiRootObject runProcess.
	previousUIProcess ifNotNil: [ previousUIProcess animatedUI: nil ].
	UIProcess resume! !
!WorldMorph methodsFor: 'interaction loop' stamp: 'jar 7/4/2022 17:07:42' prior: 16982206!
mainLoop

	
	self clearWaitDelay.
	canvas isNil ifTrue: [
		self setMainCanvas ].
	self redrawNeeded.
	[
		self doOneCycle.
		UISupervisor isUIProcessRunning ]
			whileTrue: []! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
[
	UISupervisor ui ifNotNil: [ :morphicWorld |
		UISupervisor stopUIProcess.
		UISupervisor spawnNewMorphicProcessFor: morphicWorld ].
] forkAt: ProcessorScheduler userBackgroundPriority!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5351-LetMorphicProcessEndByItself-JaromirMatas-JuanVuletich-2022Jul04-17h04m-jmv.003.cs.st----!

'From Cuis 6.0 [latest update: #5351] on 5 July 2022 at 10:03:31 am'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 7/5/2022 09:41:43' prior: 50399812!
    openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| guiRootObject |
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	guiRootObject _ UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new
			process: process
			context: context.
		debugger interruptedProcessUI: guiRootObject.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 7/5/2022 09:39:26' prior: 50400112!
handleUserInterrupt
	| processToInterrupt |
	"If the UI process is not ready to run, the UI was not responsive, and most likely that's why the user pressed
	the interrupt key. Make GUI responsive again, and let them debug the process that made UI not responsive."
	processToInterrupt _ UISupervisor newUIProcessIfNeeded.
	processToInterrupt ifNil: [
		"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
		processToInterrupt _ Sensor shiftPressed | (Preferences at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preferences at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		processToInterrupt == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(processToInterrupt name beginsWith: '[system]') ifTrue: [
			 ('Process {', processToInterrupt printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			processToInterrupt isTerminated
				ifTrue: [ ('Process {', processToInterrupt printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ UISupervisor userInterrupt: processToInterrupt ]] fork
		].! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jar 7/5/2022 12:12:00' prior: 50404354!
               newProcessIfUI: processBeingSuspended
	"processBeingSuspended has been suspended or is about to be.
	Answer the UI we created a new process for.
	If not an UI process, still guarantee that the UI process is runnable."

	processBeingSuspended animatedUI ifNotNil: [ :guiRootObject |
		self spawnNewMorphicProcessFor: guiRootObject.
		^guiRootObject ].
	UISupervisor newUIProcessIfNeeded.
	^nil
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/5/2022 09:36:34' prior: 50404161!
                       newUIProcessIfNeeded
	"If the system needs a UIProcess (we know because UIProcess is not nil),
	then ensure that the UIProcess is ready to run, in order to hava a responsive UI.
	If we needed to create a new UI process, answer the old one, as it is most likely the
	process the user is interested in debugging. See senders."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isBlocked | oldUIProcess isSuspended | oldUIProcess isTerminated ifTrue: [
			oldUIProcess 	animatedUI ifNotNil: [ :guiRootObject |
				self spawnNewMorphicProcessFor: guiRootObject.
				^oldUIProcess ]]].
	^nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5352-newProcessIfUI-tweaks-clarifications-JaromirMatas-JuanVuletich-2022Jul05-10h00m-jmv.001.cs.st----!

----QUIT----(5 July 2022 10:30:19) Cuis6.0-5352.image priorSource: 1785051!

----STARTUP---- (22 July 2022 17:17:02) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5352.image!


'From Cuis 6.0 [latest update: #5354] on 5 July 2022 at 4:20:53 pm'!
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 7/5/2022 16:20:26' prior: 50380352 overrides: 50365979!
nextPutAll: aStringOrBytes
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this stream. All 3 kinds of Strings are UTF-8 encoded."

	| bytes |
	aStringOrBytes isEmpty ifTrue: [ ^self ].
	bytes _ aStringOrBytes.
	(aStringOrBytes is: #ByteArray) ifFalse: [
		bytes _ aStringOrBytes asUtf8Bytes.
		numberOfCodePointsWritten ifNotNil: [
			"As aStringOrBytes is a kind of String, not utf-8 byteArray, we can use its size."
			numberOfCodePointsWritten _ numberOfCodePointsWritten + aStringOrBytes size ]].
	super nextPutAll: bytes.
	lastWrittenElement _ aStringOrBytes last.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5353-Utf8EncodedWriteStream-fix-JuanVuletich-2022Jul05-16h20m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5355] on 5 July 2022 at 4:57:47 pm'!
!Utf8String methodsFor: 'converting' stamp: 'jmv 7/5/2022 16:57:21' overrides: 16934119!
reversed
	"
	'frog' asUtf8String reversed
	"
	^Utf8String fromUtf32Words: self asUtf32Words reversed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5354-Utf8String-reversed-JuanVuletich-2022Jul05-16h45m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5356] on 5 July 2022 at 8:48:46 pm'!
!Preference methodsFor: 'accessing' stamp: 'jmv 7/5/2022 20:45:11' prior: 50352920!
                            type
	(type inheritsFrom: CharacterSequence) ifTrue: [ type _ CharacterSequence ].
	^ type! !
!Preference methodsFor: 'accessing' stamp: 'jmv 7/5/2022 20:45:00' prior: 50352932!
              value: aValue	
	self isTypeAClass 
		ifTrue: [
			(aValue isKindOf: self type) ifFalse: [self error: aValue printString, ' is not a ', type printString].
			value _ aValue ]
		ifFalse: [ "Should be handled somehow by the preference editor "
			value _ aValue].
	self triggerEvent: #preferenceChanged with: self! !
!Preference class methodsFor: 'helpers' stamp: 'jmv 7/5/2022 20:47:22' prior: 50353153!
              detectType: anObject
"When the type is not provided, we can try to deduce it "

	(anObject isKindOf: CharacterSequence) ifTrue: [ ^CharacterSequence ].
	^ anObject class name
		caseOf: {
			[#True] -> [Boolean].
			[#False] -> [Boolean].
			[#StrikeFont] -> [AbstractFont].
			[#TrueTypeFont ] -> [AbstractFont]
		}
		otherwise: [anObject class]
! !

Preference removeSelector: #accept:!

!methodRemoval: Preference #accept: stamp: 'Install-5355-Preference-CharacterSequence-asAType-JuanVuletich-2022Jul05-20h44m-jmv.001.cs.st 7/22/2022 17:17:09'!
accept: aVisitor
	| visitMethod |
	self isTypeAClass 
		ifTrue: [ visitMethod _ ('visit', type name, 'Preference:') asSymbol ]
		ifFalse: [visitMethod _ ('visit', type species asString, 'Preference:') asSymbol ].
	^ aVisitor perform: visitMethod with: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5355-Preference-CharacterSequence-asAType-JuanVuletich-2022Jul05-20h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5356] on 5 July 2022 at 8:53:49 pm'!
!Utf8Symbol methodsFor: 'object serialization' stamp: 'jmv 7/5/2022 20:52:50' overrides: 16902743!
                              comeFullyUpOnReload: smartRefStream
	"
	(Object unStream: (ReferenceStream streamedRepresentationOf: #hello)) = #hello
	"
	^self asString asSymbol! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5356-Utf8String-serialization-JuanVuletich-2022Jul05-20h48m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5356] on 6 July 2022 at 6:46:34 am'!
!Collection methodsFor: 'testing' stamp: 'jmv 7/5/2022 23:07:48'!
                           canHoldCodePoints
	"Why not?"
	^true! !

SequenceableCollection removeSelector: #canHoldCodePoints!

!methodRemoval: SequenceableCollection #canHoldCodePoints stamp: 'Install-5357-canHoldCodePoints-MoveUpToCollection-JuanVuletich-2022Jul06-06h46m-jmv.001.cs.st 7/22/2022 17:17:09'!
canHoldCodePoints
	"Why not?"
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5357-canHoldCodePoints-MoveUpToCollection-JuanVuletich-2022Jul06-06h46m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5357] on 6 July 2022 at 9:33:57 am'!
!Character methodsFor: 'comparing' stamp: 'jmv 7/6/2022 06:49:21' prior: 50368901!
                    >= aCharacter 
	"Answer whether the receiver is greater than or equal to the argument."

	aCharacter isUnicodeCodePoint ifTrue: [ ^aCharacter <= self ].
	^(self < aCharacter) not! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 7/6/2022 09:28:10' prior: 50368909!
                < aCodePointOrCharacter
	self asCharacter ifNotNil: [ :selfAsChar |
		aCodePointOrCharacter asCharacter ifNotNil: [ :aChar |
			^selfAsChar < aChar ].
		^true ].
	aCodePointOrCharacter asCharacter ifNotNil: [ :aChar |
		^false ].
	^self codePoint < aCodePointOrCharacter codePoint! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 7/6/2022 09:29:22' prior: 50368914!
          <= aCodePointOrCharacter
	self = aCodePointOrCharacter ifTrue: [ ^true ].
	^ self < aCodePointOrCharacter! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 7/6/2022 09:30:37' prior: 50368919!
                         > aCodePointOrCharacter
	self = aCodePointOrCharacter ifTrue: [ ^false ].
	^ (self < aCodePointOrCharacter) not! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 7/6/2022 09:29:50' prior: 50368924!
                   >= aCodePointOrCharacter
	^ (self < aCodePointOrCharacter) not! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5358-UnicodeCodePoint-comparisons-JuanVuletich-2022Jul06-09h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5358] on 6 July 2022 at 8:32:45 am'!
!Utf8String class methodsFor: 'services' stamp: 'jmv 7/6/2022 08:29:15'!
    compare: string1 with: string2
	"Return 1, 2 or 3, if string1 is <, =, or > string2.
	Case sensitive.
	Can handle any kind of Character sequences.
	Slower than implementation in String class"

	| len1 len2 c1 c2 |

	len1 _ string1 size.
	len2 _ string2 size.
	1 to: (len1 min: len2) do: [ :i |
		c1 _ string1 at: i.
		c2 _ string2 at: i.
		c1 = c2 ifFalse: [
			c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].
	len1 = len2 ifTrue: [^ 2].
	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 7/6/2022 08:32:19' prior: 50391270!
                < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 1].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 1]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character and UnicodeCodePoint"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (Utf8String compare: self with: aString) = 1! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 7/6/2022 08:32:15' prior: 50391297!
           <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) <= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) <= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character and UnicodeCodePoint"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (Utf8String compare: self with: aString) <= 2! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 7/6/2022 08:32:11' prior: 50391353!
                            > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 3].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 3]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character and UnicodeCodePoint"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (Utf8String compare: self with: aString) = 3! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 7/6/2022 08:32:08' prior: 50391380!
            >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) >= 2].
		(aString isUtf8String and: [aString isAscii]) ifTrue: [
			"aString is also an ascii Utf8String. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) >= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character and UnicodeCodePoint"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (Utf8String compare: self with: aString) >= 2! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5359-Utf8String-comparisons-JuanVuletich-2022Jul06-08h12m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5359] on 6 July 2022 at 9:11:34 am'!
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/6/2022 09:02:50' prior: 16954318!
           numberOfSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	"
	| count specialFlag specialByte |
	count _ 0.
	specialFlag _ self hasSpecialSelector: aSymbol ifTrueSetByte: [ :b | specialByte _ b ].
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			((method hasLiteral: aSymbol) or: [specialFlag and: [(method scanFor: specialByte)]])
				ifTrue: [ count _ count + 1 ]]].
	^ count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5360-FasterApproxSenderCountForSpecialSelectors-JuanVuletich-2022Jul06-09h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5352] on 6 July 2022 at 10:57:03 am'!
!Preference methodsFor: 'accessing' stamp: 'hlsf 7/6/2022 10:45:40'!
                nameDetailed
"Provide a detailed name if possible, alternatively turn the symbolic name to a nicer aspect for the reader"
	^ description isEmptyOrNil 
		ifTrue: [name capitalized] ifFalse: [description]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5361-Preference-nameDetailed-HilaireFernandes-2022Jul06-10h03m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5362] on 6 July 2022 at 5:08:45 pm'!
!Utf8String commentStamp: 'jmv 7/6/2022 17:08:03' prior: 50350967!
                              String like objects handling Unicode code points, encoded as UTF-8 bytes.
Based on https://github.com/svenvc/UTF8String by Sven Van Caekenberghe. Good ideas and implementation. Thanks Sven!!

Install VectorGraphics / TrueType support, and play with the class side demo methods.!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 7/6/2022 17:08:27' prior: 50352104!
            knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 						'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 						'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 						'Fernando Olivero')
	#('FernanodOlivero' 						'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 						'Gabriel Omar Cotelli')
	#('GC' 						'Gast√≥n Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 						'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 						'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 						'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 						'Marcus Denker')
	#('marcus.denker' 						'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 						'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 		'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 						'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'						'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'						'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'						'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'						'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'						'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 						'Stephane Ducasse')
	#('stephaneducasse'	 					'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 						'Masato Sumi')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 						'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 						'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5362-Credit-SvenVanCaekenberghe-forUtf8String-JuanVuletich-2022Jul06-13h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5362] on 7 July 2022 at 12:03:33 pm'!
!SequenceableCollection methodsFor: 'converting' stamp: 'jmv 7/7/2022 10:37:44'!
          thatCanBeModified
	"By default, SequenceableCollections can handle #at:put:"

	^self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 7/7/2022 10:36:08' overrides: 50405183!
               thatCanBeModified
	"Because Utf8String instances don't support #at:put:"

	^ArrayOfCharactersAndCodePoints withAll: self! !
!WriteStream methodsFor: 'private' stamp: 'jmv 7/7/2022 10:44:06' prior: 50361513 overrides: 50361502!
                             on: aCollection
	"Initialize the stream to write over all of aCollection.
	The collection contents are considered useless (most likely nil).
	Overwrite them.
	In the case of ReadWriteStream, for read operations, stream appears empty until stuff is added."

	super on: aCollection thatCanBeModified.
	readLimit _ 0.
	writeLimit _ aCollection size! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5363-ReadWriteStream-on-Utf8String-JuanVuletich-2022Jul07-12h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5362] on 7 July 2022 at 12:05:35 pm'!
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:09:54' prior: 16944555 overrides: 16856335!
                    atEnd
	"Answer whether the receiver is at its end.  "
	
	collection ifNotNil: [
		position < readLimit ifTrue: [ ^false ] ].
	"
	^self primAtEnd: fileID
	"
	^self position = self size! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 10:53:07' prior: 16944956 overrides: 50365284!
         upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"See comment at PositionableStream.
	Fast version."

	| pos buffer count skipSeparator tryAgain |
	skipSeparator _ delimiterIsTerminator ifTrue: [0] ifFalse: [1].
	collection ifNotNil: [
		(position < readLimit and: [
			(pos _ collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [
				pos > 0 ] ]) ifTrue: [
					^ collection copyFrom: position + 1 to: (position _ pos) - skipSeparator ] ].

	pos _ self position.
	buffer _ self next: 2000.
	(count _ buffer indexOf: delimiter) > 0 ifTrue: [
		"Found the delimiter part way into buffer"
		self position: pos + count.
		^ buffer copyFrom: 1 to: count - skipSeparator].

	self atEnd ifTrue: [
		"Never found it, and hit end of file"
		^ delimiterIsTerminator ifTrue: [self position: pos. nil] ifFalse: [buffer]].

	"Never found it, but there's more..."
	tryAgain _ self upTo: delimiter delimiterIsTerminator: delimiterIsTerminator.
	tryAgain ifNil: [
		self position: pos.
		^ nil ].
	^ buffer, tryAgain.! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:09:47' prior: 50377541 overrides: 16914201!
                        atEnd
	"Answer whether the receiver is at its end.  "
	
	collection ifNotNil: [
		position < readLimit ifTrue: [ ^false ] ].
	"
	^self primAtEnd: fileID
	"
	^self position = self size! !

UniFileStream removeSelector: #upTo:delimiterIsTerminator:!

!methodRemoval: UniFileStream #upTo:delimiterIsTerminator: stamp: 'Install-5364-upTodelimiterIsTerminator-atEnd-bugFix-JuanVuletich-2022Jul07-12h03m-jmv.001.cs.st 7/22/2022 17:17:10'!
upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"See comment at PositionableStream.
	Fast version to speed up nextChunk"

	| pos buffer count skipSeparator tryAgain |

self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.
	skipSeparator _ delimiterIsTerminator ifTrue: [0] ifFalse: [1].
	collection ifNotNil: [
		(position < readLimit and: [
			(pos _ collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [
				pos > 0 ] ]) ifTrue: [
					^ collection copyFrom: position + 1 to: (position _ pos) - skipSeparator ] ].

	pos _ self position.
	buffer _ self next: 2000.
	(count _ buffer indexOf: delimiter) > 0 ifTrue: [
		"Found the delimiter part way into buffer"
		self position: pos + count.
		^ buffer copyFrom: 1 to: count - skipSeparator].

	self atEnd ifTrue: [
		"Never found it, and hit end of file"
		^ delimiterIsTerminator ifTrue: [self position: pos. nil] ifFalse: [buffer]].

	"Never found it, but there's more..."
	tryAgain _ self upTo: delimiter delimiterIsTerminator: delimiterIsTerminator.
	tryAgain ifNil: [
		self position: pos.
		^ nil ].
	^ buffer, tryAgain.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5364-upTodelimiterIsTerminator-atEnd-bugFix-JuanVuletich-2022Jul07-12h03m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5364] on 7 July 2022 at 11:37:02 am'!
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:36:25' prior: 50389578 overrides: 16982981!
                         next: anInteger putAll: aStringOrBytes startingAt: startIndex
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this file. All 3 kinds of Strings are UTF-8 encoded.
	Optimized only for ByteArray, the common use."

	(aStringOrBytes is: #ByteArray) ifFalse: [
		(startIndex = 1 and: [anInteger = aStringOrBytes size])ifTrue: [
			^self nextPutAll: aStringOrBytes].
		^self nextPutAll: (aStringOrBytes copyFrom: startIndex to: startIndex+anInteger-1) ].

	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [ 
		position < readLimit ifTrue: [ self flushReadBuffer ] ].
	self primWrite: fileID from: aStringOrBytes startingAt: startIndex count: anInteger.
	lastWrittenElement _ aStringOrBytes at: anInteger.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5365-UniFileStream-nextPutAllStartingAt-JuanVuletich-2022Jul07-11h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5364] on 7 July 2022 at 11:57:27 am'!
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:47:21'!
                 nextBytes: n into: aBytesOrWordsObject startingAt: startIndex
	"Read n bytes or words into the given aBytesOrWordsObject.
	Return aBytesOrWordsObject or a partial copy if less than
	n elements have been read."
	
	| count  newN newStartIndex |
	collection 
		ifNil: [ 
			newN := n.
			newStartIndex := startIndex ]
		ifNotNil: [
			aBytesOrWordsObject class isBytes 
				ifFalse: [ 
					position < readLimit ifTrue: [ self flushReadBuffer ].
					newN := n.
					newStartIndex := startIndex ]
				ifTrue: [
					| available |
					(available := readLimit - position) > 0 
						ifFalse: [ available := 0 ]
						ifTrue: [
							| bufferedCount |
							bufferedCount := n min: available.
							aBytesOrWordsObject
								replaceFrom: startIndex
								to: startIndex + bufferedCount - 1
								with: collection
								startingAt: position + 1.
							position := position + bufferedCount.
							bufferedCount = n ifTrue: [ ^aBytesOrWordsObject ] ].
					newN := n - available.
					newStartIndex := startIndex + available ] ].
	count := self primRead: fileID into: aBytesOrWordsObject
				startingAt: newStartIndex count: newN.
	count = newN
		ifTrue:[ ^aBytesOrWordsObject ]
		ifFalse:[ ^aBytesOrWordsObject copyFrom: 1 to: newStartIndex + count - 1 ]! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:47:53' prior: 16944737 overrides: 50365262!
                    next: n into: aBytesOrWordsObject startingAt: startIndex
	"Read n bytes or words into the given aBytesOrWordsObject.
	Return aBytesOrWordsObject or a partial copy if less than
	n elements have been read."
	
	^self nextBytes: n into: aBytesOrWordsObject startingAt: startIndex! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:53:22' prior: 16944818 overrides: 50365271!
             nextWordsInto: aBitmap
	"Note: The file primitives automatically adjust for word based objects."

	self nextBytes: aBitmap basicSize into: aBitmap startingAt: 1.
	aBitmap restoreEndianness.
	^ aBitmap! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:57:07' prior: 50377724!
                 nextBytes: n into: aBytesOrWordsObject startingAt: startIndex
	"Read n bytes or words into the given aBytesOrWordsObject.
	Return aBytesOrWordsObject or a partial copy if less than
	n elements have been read."
	
	| count  newN newStartIndex |
	collection 
		ifNil: [ 
			newN := n.
			newStartIndex := startIndex ]
		ifNotNil: [
			aBytesOrWordsObject class isBytes 
				ifFalse: [ 
					position < readLimit ifTrue: [ self flushReadBuffer ].
					newN := n.
					newStartIndex := startIndex ]
				ifTrue: [
					| available |
					(available := readLimit - position) > 0 
						ifFalse: [ available := 0 ]
						ifTrue: [
							| bufferedCount |
							bufferedCount := n min: available.
							aBytesOrWordsObject
								replaceFrom: startIndex
								to: startIndex + bufferedCount - 1
								with: collection
								startingAt: position + 1.
							position := position + bufferedCount.
							bufferedCount = n ifTrue: [ ^aBytesOrWordsObject ] ].
					newN := n - available.
					newStartIndex := startIndex + available ] ].
	count := self primRead: fileID into: aBytesOrWordsObject
				startingAt: newStartIndex count: newN.
	count = newN
		ifTrue:[ ^aBytesOrWordsObject ]
		ifFalse:[ ^aBytesOrWordsObject copyFrom: 1 to: newStartIndex + count - 1 ]! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 11:53:44' prior: 50389598 overrides: 50365271!
                         nextWordsInto: aBitmap
	"Note: The file primitives automatically adjust for word based objects."

	self nextBytes: aBitmap basicSize into: aBitmap startingAt: 1.
	aBitmap restoreEndianness.
	^ aBitmap! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 7/7/2022 11:49:51' prior: 16854639!
                            copyFile: fileStream1 toFile: fileStream2
	| buffer |
	buffer := ByteArray new: 50000.
	[fileStream1 atEnd] whileFalse: [
		fileStream2 nextPutAll: (fileStream1 nextBytes: buffer size into: buffer startingAt: 1)].! !

UniFileStream removeSelector: #next:into:startingAt:!

!methodRemoval: UniFileStream #next:into:startingAt: stamp: 'Install-5366-Utf8Stream-nextBytesintostartingAt-JuanVuletich-2022Jul07-11h37m-jmv.001.cs.st 7/22/2022 17:17:10'!
next: n into: aBytesOrWordsObject startingAt: startIndex
	"Read n bytes or words into the given aBytesOrWordsObject.
	Return aBytesOrWordsObject or a partial copy if less than
	n elements have been read."
	
	| count  newN newStartIndex |
true ifTrue: [
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt. "ojo"
"si se que son bytes quizas preferir
nextBytes: n into: aBytesOrWordsObject startingAt: startIndex
"
].
	collection 
		ifNil: [ 
			newN := n.
			newStartIndex := startIndex ]
		ifNotNil: [
			aBytesOrWordsObject class isBytes 
				ifFalse: [ 
					position < readLimit ifTrue: [ self flushReadBuffer ].
					newN := n.
					newStartIndex := startIndex ]
				ifTrue: [
					| available |
					(available := readLimit - position) > 0 
						ifFalse: [ available := 0 ]
						ifTrue: [
							| bufferedCount |
							bufferedCount := n min: available.
							aBytesOrWordsObject
								replaceFrom: startIndex
								to: startIndex + bufferedCount - 1
								with: collection
								startingAt: position + 1.
							position := position + bufferedCount.
							bufferedCount = n ifTrue: [ ^aBytesOrWordsObject ] ].
					newN := n - available.
					newStartIndex := startIndex + available ] ].
	count := self primRead: fileID into: aBytesOrWordsObject
				startingAt: newStartIndex count: newN.
	count = newN
		ifTrue:[ ^aBytesOrWordsObject ]
		ifFalse:[ ^aBytesOrWordsObject copyFrom: 1 to: newStartIndex + count - 1 ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5366-Utf8Stream-nextBytesintostartingAt-JuanVuletich-2022Jul07-11h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5366] on 7 July 2022 at 2:32:07 pm'!
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 7/7/2022 14:31:18' prior: 50389713!
    fileDoesNotExistUserHandling: fullFileName

	| selection newName |
	selection _ (PopUpMenu labels:
'create a new file
choose another name
cancel')
			startUpWithCaption: fullFileName asFileEntry name, '
does not exist.'.
	selection = 1 ifTrue:
		[^ self new open: fullFileName forWrite: true].
	selection = 2 ifTrue:
		[ newName _ self request: 'Enter a new file name'
						initialAnswer:  fullFileName.
		^ FileIOAccessor default privateWriteableFile: newName asFileEntry ].
	self halt! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5367-cleanup-JuanVuletich-2022Jul07-14h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5366] on 7 July 2022 at 2:34:24 pm'!
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 14:34:02' prior: 50389611 overrides: 16983319!
  padToEndIfCantTruncate
	"Only makes sense for file streams with existing content.
	On file systems that don't support truncating this is needed.
	If truncating is supported, try that first"

	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."

	| pad |
	self atEnd ifTrue: [^ self].
	self truncate.
	self atEnd ifTrue: [^ self].
	pad := Character space numericValue.
	self nextPutAll: (ByteArray new: ((self size - self position) min: 20000) 
							withAll: pad)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5368-cleanup-JuanVuletich-2022Jul07-14h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5368] on 7 July 2022 at 3:08:36 pm'!
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 14:50:33' overrides: 16983053!
   resetToStart
	super resetToStart.
	lastWrittenElement _ nil.! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 14:45:02' prior: 50405329 overrides: 16982981!
         next: anInteger putAll: aStringOrBytes startingAt: startIndex
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this file. All 3 kinds of Strings are UTF-8 encoded.
	Optimized only for ByteArray, the common use."

	(aStringOrBytes is: #ByteArray) ifFalse: [
		(startIndex = 1 and: [anInteger = aStringOrBytes size])ifTrue: [
			^self nextPutAll: aStringOrBytes].
		^self nextPutAll: (aStringOrBytes copyFrom: startIndex to: startIndex+anInteger-1) ].

	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [ 
		position < readLimit ifTrue: [ self flushReadBuffer ] ].
	self primWrite: fileID from: aStringOrBytes startingAt: startIndex count: anInteger.
	lastWrittenElement _ aStringOrBytes at: startIndex+anInteger-1.! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 14:49:36' prior: 50386414 overrides: 16983042!
                             position: pos
	"Set the receiver's position as indicated."

	collection ifNotNil: [
		position < readLimit ifTrue: [
			| newPosition |
			newPosition := pos - (self primGetPosition: fileID) + readLimit.
			newPosition < 0 ifTrue: [
					| offsetPos |
					self primSetPosition: fileID to: (offsetPos := pos - (collection size // 4) max: 0).
					readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
					position := pos - offsetPos.
					^self ].
			newPosition < readLimit 
				ifTrue: [
					position := newPosition.
					^self ]
				ifFalse: [
					readLimit := position := 0 ] ] ].
	self primSetPosition: fileID to: pos.
	lastWrittenElement _ nil.! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 14:48:27' prior: 50389735 overrides: 16982981!
           next: anInteger putAll: aStringOrBytes startingAt: startIndex
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this file. All 3 kinds of Strings are UTF-8 encoded.
	Optimized only for ByteArray, the common use."

	(aStringOrBytes is: #ByteArray) ifFalse: [
		(startIndex = 1 and: [anInteger = aStringOrBytes size])ifTrue: [
			^self nextPutAll: aStringOrBytes].
		^self nextPutAll: (aStringOrBytes copyFrom: startIndex to: startIndex+anInteger-1) ].

	super next: anInteger putAll: aStringOrBytes startingAt: startIndex.
	lastWrittenElement _ aStringOrBytes at: startIndex+anInteger-1.
	numberOfCodePointsWritten _ nil.	"We can no longer know"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5369-cleanup-JuanVuletich-2022Jul07-15h07m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5368] on 7 July 2022 at 3:24:51 pm'!
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 15:24:39' prior: 50389638!
 readInto: byteArray startingAt: startIndex count: count
	"Read into the given array as specified, and return the count
	actually transferred.  index and count are in units of bytes or
	longs depending on whether the array is Bitmap, String or ByteArray"
	
	^(self nextBytes: count into: byteArray startingAt: startIndex) size - startIndex + 1
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5370-cleanup-JuanVuletich-2022Jul07-15h08m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5370] on 7 July 2022 at 3:48:40 pm'!
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 15:44:56' prior: 50386382 overrides: 16983042!
         position: pos
	"Argument is a byte position"

	super position: pos.
	lastWrittenElement _ nil.
	numberOfCodePointsWritten _ nil.! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 15:45:55' prior: 50389749 overrides: 50364304!
                            skip
	"Leave an empty byte position."

	self skip: 1! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 15:46:23' prior: 50389760 overrides: 50368843!
        skip: n
	"Skips the next amount bytes in the byte store."

	self position: (self position + n min: self size).! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 15:47:02' prior: 50389771 overrides: 50364310!
              skipBack
	"Overwrite last written byte."

	self skip: -1.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5371-Utf8EncodedWriteStream-positioning-JuanVuletich-2022Jul07-15h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5371] on 7 July 2022 at 4:00:15 pm'!

Utf8EncodedWriteStream removeSelector: #withAttributes:do:!

!methodRemoval: Utf8EncodedWriteStream #withAttributes:do: stamp: 'Install-5372-Cleanup-JuanVuletich-2022Jul07-15h59m-jmv.001.cs.st 7/22/2022 17:17:10'!
withAttributes: attributes do: streamBlock 
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.!

Utf8EncodedWriteStream removeSelector: #withAttribute:do:!

!methodRemoval: Utf8EncodedWriteStream #withAttribute:do: stamp: 'Install-5372-Cleanup-JuanVuletich-2022Jul07-15h59m-jmv.001.cs.st 7/22/2022 17:17:10'!
withAttribute: aTextAttribute do: streamBlock
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.!

UniFileStream removeSelector: #withAttributes:do:!

!methodRemoval: UniFileStream #withAttributes:do: stamp: 'Install-5372-Cleanup-JuanVuletich-2022Jul07-15h59m-jmv.001.cs.st 7/22/2022 17:17:10'!
withAttributes: attributes do: streamBlock 
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.!

UniFileStream removeSelector: #withAttribute:do:!

!methodRemoval: UniFileStream #withAttribute:do: stamp: 'Install-5372-Cleanup-JuanVuletich-2022Jul07-15h59m-jmv.001.cs.st 7/22/2022 17:17:10'!
withAttribute: aTextAttribute do: streamBlock
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5372-Cleanup-JuanVuletich-2022Jul07-15h59m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5371] on 7 July 2022 at 4:10:11 pm'!
!Utf8String methodsFor: 'converting' stamp: 'svc 5/5/2022 09:10:50' prior: 50369640 overrides: 50379654!
   asUtf8String
	"Convert me to an Utf8String"
	
	^ self! !
!Utf8String methodsFor: 'testing' stamp: 'svc 5/5/2022 09:20:36' prior: 50351550 overrides: 16823965!
 isEmpty
	"Return true when I am empty, when I do not contain any characters"
	
	^ bytes isEmpty! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5373-attribution-JuanVuletich-2022Jul07-16h09m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5373] on 7 July 2022 at 4:19:39 pm'!
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 7/7/2022 16:19:21' prior: 50377786 overrides: 50365979!
      nextPutAll: aStringOrBytes
	"Argument can be String, Utf8String, Utf32String or ByteArray.
	Write to this file. All 3 kinds of Strings are UTF-8 encoded."

	| bytes |
	aStringOrBytes isEmpty ifTrue: [ ^self ].
	bytes _ aStringOrBytes.
	(aStringOrBytes is: #ByteArray) ifFalse: [
		bytes _ aStringOrBytes asUtf8Bytes].
	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [ 
		position < readLimit ifTrue: [ self flushReadBuffer ] ].
	self primWrite: fileID from: bytes startingAt: 1 count: bytes basicSize.
	lastWrittenElement _ aStringOrBytes last.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5374-bugfix-JuanVuletich-2022Jul07-16h19m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5374] on 7 July 2022 at 4:28:03 pm'!

UniFileStream removeSelector: #findString:!

!methodRemoval: UniFileStream #findString: stamp: 'Install-5375-Cleanup-JuanVuletich-2022Jul07-16h27m-jmv.001.cs.st 7/22/2022 17:17:10'!
findString: string
	"Fast version of #upToAll: to find a String in a file starting from the beginning.
	Returns the position and also sets the position there.
	If string is not found 0 is returned and position is unchanged."
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.!

UniFileStream removeSelector: #findStringFromEnd:!

!methodRemoval: UniFileStream #findStringFromEnd: stamp: 'Install-5375-Cleanup-JuanVuletich-2022Jul07-16h27m-jmv.001.cs.st 7/22/2022 17:17:10'!
findStringFromEnd: string
	"Fast version to find a String in a file starting from the end.
	Returns the position and also sets the position there.
	If string is not found 0 is returned and position is unchanged."
self flag: #unicodeNeedsImprovement.
'--------' print.
thisContext printStack: 10.
self halt.!

StandardFileStream removeSelector: #findString:!

!methodRemoval: StandardFileStream #findString: stamp: 'Install-5375-Cleanup-JuanVuletich-2022Jul07-16h27m-jmv.001.cs.st 7/22/2022 17:17:10'!
findString: string
	"Fast version of #upToAll: to find a String in a file starting from the beginning.
	Returns the position and also sets the position there.
	If string is not found 0 is returned and position is unchanged."

	| pos buffer count oldPos sz |
	oldPos _ self position.
	self reset.
	sz _ self size.
	pos _ 0.
	buffer _ String new: 2000.
	[ buffer := self nextInto: buffer.
	(count _ buffer findString: string) > 0
		ifTrue: ["Found the string part way into buffer"
			self position: pos.
			self next: count - 1.
			^self position ].
	pos _ ((pos + 2000 - string size) min: sz).
	self position: pos.
	pos = sz] whileFalse.
	"Never found it, and hit end of file"
	self position: oldPos.
	^0!

StandardFileStream removeSelector: #findStringFromEnd:!

!methodRemoval: StandardFileStream #findStringFromEnd: stamp: 'Install-5375-Cleanup-JuanVuletich-2022Jul07-16h27m-jmv.001.cs.st 7/22/2022 17:17:10'!
findStringFromEnd: string
	"Fast version to find a String in a file starting from the end.
	Returns the position and also sets the position there.
	If string is not found 0 is returned and position is unchanged."

	| pos buffer count oldPos |
	oldPos _ self position.
	self setToEnd.
	pos _ self position.
	[ pos _ ((pos - 2000 + string size) max: 0).  "the [+ string size] allows for the case where the end of the search string is at the beginning of the current buffer"
	self position: pos.
	buffer _ self next: 2000.
	(count _ buffer findString: string) > 0
		ifTrue: ["Found the string part way into buffer"
			self position: pos.
			self next: count-1.  "use next instead of position:, so that CrLfFileStream can do its magic if it is being used"
			^self position].
	pos = 0] whileFalse.
	"Never found it, and hit beginning of file"
	self position: oldPos.
	^0!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5375-Cleanup-JuanVuletich-2022Jul07-16h27m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5323] on 27 June 2022 at 1:02:10 pm'!

Object subclass: #FileIOAccessor
	instanceVariableNames: 'slash drives '
	classVariableNames: 'Default ConcreteFileStreamClass '
	poolDictionaries: ''
	category: 'System-File System'!

!classDefinition: #FileIOAccessor category: 'System-File System' stamp: 'Install-5376-AllowActivationOfUtf8Files-JuanVuletich-2022Jun27-12h41m-jmv.001.cs.st 7/22/2022 17:17:10'!
Object subclass: #FileIOAccessor
	instanceVariableNames: 'slash drives'
	classVariableNames: 'ConcreteFileStreamClass Default'
	poolDictionaries: ''
	category: 'System-File System'!
!TextModel methodsFor: 'as yet unclassified' stamp: 'jmv 6/27/2022 12:45:17'!
       saveOn: stream
	"Saves the model to the given stream"
	stream binary.
	stream nextPutAll: self actualContents asPlainString.! !
!FileIOAccessor class methodsFor: 'class initialization' stamp: 'jmv 6/27/2022 12:54:23'!
      concreteStreamClass: aFileStreamClass
	"
	FileIOAccessor concreteStreamClass: StandardFileStream
	FileIOAccessor concreteStreamClass: UniFileStream
	"
	ConcreteFileStreamClass _ aFileStreamClass.
	Smalltalk closeSourceFiles; openSourceFiles.! !
!FileIOAccessor class methodsFor: 'class initialization' stamp: 'jmv 6/27/2022 12:59:47'!
                 useExtendedAsciiFiles
	"
	Use Extended Ascii (ISO 8859-15 plus a few Greek and Math symbols) for files.
	Only support instances of String.
	This is the traditional, pre-Unicode way for Cuis.

	FileIOAccessor useExtendedAsciiFiles
	"
	FileIOAccessor concreteStreamClass: StandardFileStream! !
!FileIOAccessor class methodsFor: 'class initialization' stamp: 'jmv 6/27/2022 13:00:27'!
  useUtf8Files
	"
	Use UTF-8 encoded Unicode files.
	Supports both regular String and Unicode Utf8String.
	The use of multi-byte Unicode:
		- Will save files that require an Unicode enabled Cuis to be read.
		- For tools to work properly, the use of a TrueType fonts is required.

	FileIOAccessor useUtf8Files
	"
	FileIOAccessor concreteStreamClass: UniFileStream! !
!FileDoesNotExistException methodsFor: 'exceptionDescription' stamp: 'jmv 6/27/2022 12:41:31' prior: 16853833 overrides: 16848979!
                defaultAction
	"The default action taken if the exception is signaled."


	^ readOnly
		ifTrue: [ FileIOAccessor default concreteStreamClass readOnlyFileDoesNotExistUserHandling: fileName ]
		ifFalse: [ FileIOAccessor default concreteStreamClass  fileDoesNotExistUserHandling: fileName ]! !
!FileIOAccessor methodsFor: 'accessing' stamp: 'jmv 6/27/2022 12:51:19' prior: 16854740!
    concreteStreamClass
	"
	FileIOAccessor default concreteStreamClass
	"
	ConcreteFileStreamClass ifNil: [
		ConcreteFileStreamClass _ Smalltalk
			at: #StandardFileStream
			ifAbsent: [ Smalltalk at: #UniFileStream ]].
	^ConcreteFileStreamClass! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 6/27/2022 12:45:31' prior: 16960061!
              saveContentsTo: fileName
	"Saves the contents to the given filename"
	self hasSaveAs ifFalse: [^self].
	fileName asFileEntry writeStreamDo: [ :stream |
		model saveOn: stream ].
	self notifyUserWith: 'Contents saved'.! !

FileIOAccessor removeSelector: #concreteStreamClass:!

FileStream class removeSelector: #concreteStream!

!methodRemoval: FileStream class #concreteStream stamp: 'Install-5376-AllowActivationOfUtf8Files-JuanVuletich-2022Jun27-12h41m-jmv.001.cs.st 7/22/2022 17:17:10'!
concreteStream
	"Who should we really direct class queries to?  9/21/96 tk"
	^ StandardFileStream!

TextModel removeSelector: #saveOn:as:!

!methodRemoval: TextModel #saveOn:as: stamp: 'Install-5376-AllowActivationOfUtf8Files-JuanVuletich-2022Jun27-12h41m-jmv.001.cs.st 7/22/2022 17:17:10'!
saveOn: stream as: format
	"Saves the model to the given stream"
	stream binary.
	stream nextPutAll: self actualContents asPlainString.!

Object subclass: #FileIOAccessor
	instanceVariableNames: 'slash drives'
	classVariableNames: 'ConcreteFileStreamClass Default'
	poolDictionaries: ''
	category: 'System-File System'!

!classDefinition: #FileIOAccessor category: 'System-File System' stamp: 'Install-5376-AllowActivationOfUtf8Files-JuanVuletich-2022Jun27-12h41m-jmv.001.cs.st 7/22/2022 17:17:10'!
Object subclass: #FileIOAccessor
	instanceVariableNames: 'slash drives'
	classVariableNames: 'ConcreteFileStreamClass Default'
	poolDictionaries: ''
	category: 'System-File System'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5376-AllowActivationOfUtf8Files-JuanVuletich-2022Jun27-12h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5353] on 5 July 2022 at 11:56:18 am'!

ActiveModel subclass: #TextModel
	instanceVariableNames: 'actualContents undoRedoCommands lastEditTimeStamp '
	classVariableNames: 'UnicodeContentsHandling '
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #TextModel category: #'System-Text' stamp: 'Install-5377-AllowUnicodeTextEditors-JuanVuletich-2022Jul05-11h31m-jmv.001.cs.st 7/22/2022 17:17:10'!
ActiveModel subclass: #TextModel
	instanceVariableNames: 'actualContents undoRedoCommands lastEditTimeStamp'
	classVariableNames: 'UnicodeContentsHandling'
	poolDictionaries: ''
	category: 'System-Text'!
!TextModel class methodsFor: 'handling of Unicode' stamp: 'jmv 7/5/2022 11:43:15'!
       useExtendedAsciiEditors
	"
	Text editors will work on instances of String and Character.
	The supported character set is Extended ASCII, this is ISO 8859-15 plus some selected Greek letters, Math symbols and assorted characters.
	See #initializeUnicodeCodePoints
	This is appropriate when using StrikeFonts, but can also be used with TrueType.
	This mode can be used both with ExtendedAscii files or Utf8Files.
	See #useExtendedAsciiFiles and #useUtf8Files
	See also #useUtf8Editors
	TextModel useExtendedAsciiEditors
	"
	UnicodeContentsHandling _ #useExtendedAsciiEditors! !
!TextModel class methodsFor: 'handling of Unicode' stamp: 'jmv 7/5/2022 11:51:51'!
             useNonConvertingEditors
	"
	Text editors will work both on instances of String/Character or Utf8String/UnicodeCodePoints.
	No conversions will be done.
	See also #useExtendedAsciiEditors and #useUtf8Editors
	The use of Utf8String requires TrueType fonts and Utf8Files (if saving to files is desired).
	TextModel useNonConvertingEditors
	"
	UnicodeContentsHandling _ nil! !
!TextModel class methodsFor: 'handling of Unicode' stamp: 'jmv 7/5/2022 11:46:25'!
                        useUtf8Editors
	"
	Text editors will work on instances of Utf8String and UnicodeCodePoint.
	This supports the whole Unicode Code Point range
	Requires the use of TrueType fonts. StrikeFonts can not be used.
	Requires the use of Utf8Files. ExtendedAscii files can not be used.
	See #useUtf8Files and #useExtendedAsciiFiles.
	See also #useExtendedAsciiEditors
	TextModel useUtf8Editors
	"
	Feature require: 'VectorGraphics'.
	FileIOAccessor useUtf8Files.
	UnicodeContentsHandling _ #useUtf8Editors! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/27/2022 13:05:24'!
asByteStringOrText
	"Answer is either a String or a Text including a String"

	^self asByteString! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/25/2022 17:11:23'!
              asUtf8StringOrText
	"Answer is either an Utf8String or a Text including an Utf8String"

	^self asUtf8String! !
!Text methodsFor: 'converting' stamp: 'jmv 6/27/2022 13:05:58'!
                 asByteStringOrText
	"Answer is either a String or a Text including a String"

	string isByteString ifTrue: [ ^self ].
	^Text string: string asByteString runs: runs! !
!Text methodsFor: 'converting' stamp: 'jmv 6/25/2022 17:11:26'!
                         asUtf8StringOrText
	"Answer is either an Utf8String or a Text including an Utf8String"

	string isUtf8String ifTrue: [ ^self ].
	^Text string: string asUtf8String runs: runs! !
!TextModel methodsFor: 'accessing' stamp: 'jmv 6/27/2022 15:07:21' prior: 16968653!
                           basicActualContents: aTextOrString
	"Do not throw events."
	| prevContents |
	prevContents _ actualContents.
	actualContents _ aTextOrString asText.
	UnicodeContentsHandling = #useUtf8Editors ifTrue: [
		actualContents _ actualContents asUtf8StringOrText ]
		ifFalse: [
			UnicodeContentsHandling = #useExtendedAsciiEditors ifTrue: [
				actualContents _ actualContents asByteStringOrText ]].
	actualContents = prevContents ifFalse: [	"Compares only characters, not attributes"
		undoRedoCommands resetToStart.
		lastEditTimeStamp _ nil ]! !
!TextModel methodsFor: 'initialization' stamp: 'jmv 6/27/2022 14:57:13' prior: 16968863 overrides: 16920235!
                     initialize
	"Initialize the state of the receiver with its default contents."

	undoRedoCommands _ ReadWriteStream on: #().
	self basicActualContents: ''.! !
!FileIOAccessor class methodsFor: 'class initialization' stamp: 'jmv 7/5/2022 11:55:19' prior: 50405995!
                         useExtendedAsciiFiles
	"
	Use Extended Ascii (ISO 8859-15 plus a few Greek and Math symbols) for files.
	Only support instances of String and Character.
	Disables UTF-8 text editing by default.
	This is the traditional, pre-Unicode way for Cuis.

	FileIOAccessor useExtendedAsciiFiles
	"
	TextModel useNonConvertingEditors.
	FileIOAccessor concreteStreamClass: StandardFileStream! !

ActiveModel subclass: #TextModel
	instanceVariableNames: 'actualContents undoRedoCommands lastEditTimeStamp'
	classVariableNames: 'UnicodeContentsHandling'
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #TextModel category: #'System-Text' stamp: 'Install-5377-AllowUnicodeTextEditors-JuanVuletich-2022Jul05-11h31m-jmv.001.cs.st 7/22/2022 17:17:10'!
ActiveModel subclass: #TextModel
	instanceVariableNames: 'actualContents undoRedoCommands lastEditTimeStamp'
	classVariableNames: 'UnicodeContentsHandling'
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5377-AllowUnicodeTextEditors-JuanVuletich-2022Jul05-11h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5377] on 7 July 2022 at 9:19:09 pm'!
!SystemDictionary methodsFor: 'image, changes name' stamp: 'jmv 7/7/2022 20:14:13' prior: 16952358!
                   changeImageNameTo: aString
	self imageName: aString asByteString.
	LastImageName _ self imageName! !
!Parser methodsFor: 'primitives' stamp: 'jmv 7/7/2022 20:36:18' prior: 16907652!
          primitive: aNameString module: aModuleStringOrNil error: errorCodeVariableOrNil
	"Create named primitive with optional error code."
	
	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])
		ifFalse: [ ^ self expected: 'Named primitive' ].
	self allocateLiteral: (Array 
		with: (aModuleStringOrNil isNil 
			ifFalse: [ aModuleStringOrNil asByteString asSymbol ])
		with: aNameString asByteString asSymbol
		with: 0 with: 0).
	errorCodeVariableOrNil ifNotNil:
		[encoder floatTemp: (encoder bindTemp: errorCodeVariableOrNil) nowHasDef].
	^117! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5378-ByteStringAsArgumentsToPrimitives-JuanVuletich-2022Jul07-21h17m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5377] on 7 July 2022 at 9:27:58 pm'!
!FileList methodsFor: 'private' stamp: 'jmv 7/7/2022 21:25:09' prior: 50389997!
                 readContentsBrief: brevityFlag
	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first part characters. Don't create a file if it doesn't already exist."
	| fileSize firstPart firstPartSize |
firstPartSize _ 1e6.
directory // fileName readStreamDo: [ :f |
	f ifNil: [^ 'For some reason, this file cannot be read' halt].
	(brevityFlag not or: [(fileSize _ f size) <= (1.2*firstPartSize) ]) ifTrue: [
		acceptedContentsCache _ f contentsOfEntireFile.
		brevityState _ #fullFile.   "don't change till actually read"
		^ acceptedContentsCache ].

	"if brevityFlag is true, don't display long files when first selected"
	firstPart := f next: 1e6.
].
	acceptedContentsCache _
'File ''{1}'' is {2} characters long.
You may use the ''get'' command to read the entire file.

Here are the first {3} characters...
------------------------------------------
{4}
------------------------------------------
... end of the first {3} characters.' format: {fileName. fileSize. firstPartSize. firstPart}.
	brevityState := #briefFile.   "don't change till actually read"
	^ acceptedContentsCache! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5379-readContentsBrief-tweaks-JuanVuletich-2022Jul07-21h19m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5379] on 7 July 2022 at 10:23:36 pm'!
!TextModel methodsFor: 'misc' stamp: 'jmv 7/7/2022 22:16:10' prior: 16968693!
                      refetch
	"Nothing here. Answer true if actualContents was actually fetched."
	self basicActualContents: self actualContents.
	^false! !
!TextModel class methodsFor: 'handling of Unicode' stamp: 'jmv 7/7/2022 21:55:40' prior: 50406156!
                     useUtf8Editors
	"
	Text editors will work on instances of Utf8String and UnicodeCodePoint.
	This supports the whole Unicode Code Point range
	Requires the use of TrueType fonts. StrikeFonts can not be used.
	Requires the use of Utf8Files. ExtendedAscii files can not be used.
	See #useUtf8Files and #useExtendedAsciiFiles.
	See also #useExtendedAsciiEditors
	TextModel useUtf8Editors
	"
	Feature require: 'VectorGraphics'.
	FileIOAccessor useUtf8Files.
	UnicodeContentsHandling _ #useUtf8Editors.
	UISupervisor ui ifNotNil: [ :w | w whenUIinSafeState: [ w fontPreferenceChanged ]].! !
!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 7/7/2022 21:51:10' prior: 16870856 overrides: 16893209!
       fontPreferenceChanged

	super fontPreferenceChanged.
	hasUnacceptedEdits
		ifTrue: [ model basicActualContents: model actualContents ]
		ifFalse: [ model refetch ].
	self updateFromTextComposition.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 7/7/2022 21:37:17' prior: 50403581!
                              preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: {
			{
				#label 			-> 		'Focus follows mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Use Unicode text'.
				#object 			-> 		TextModel.
				#selector 			-> 		#useUtf8Editors.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load the VectorGraphics package, use TrueType fonts, and Unicode text.'
			} asDictionary.
			{
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#readAdditionalTrueTypeFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5380-UseUnicode-WorldMenuOption-JuanVuletich-2022Jul07-22h23m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5380] on 9 July 2022 at 4:27:37 pm'!
!Preference methodsFor: 'accessing' stamp: 'hlsf 5/17/2022 21:49:10'!
                        accept: aVisitor
	| visitMethod |
	self isTypeAClass 
		ifTrue: [ visitMethod _ ('visit', type name, 'Preference:') asSymbol ]
		ifFalse: [visitMethod _ ('visit', type species asString, 'Preference:') asSymbol ].
	^ aVisitor perform: visitMethod with: self! !
!Preference methodsFor: 'accessing' stamp: 'jmv 7/9/2022 16:26:16' prior: 50404606!
        type
	(type == String) ifTrue: [ type _ CharacterSequence ].
	^ type! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5381-Preference-fixRecentBreakage-JuanVuletich-2022Jul09-16h25m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5305] on 7 July 2022 at 10:45:13 pm'!
!TranscriptMorph methodsFor: 'drawing' stamp: 'and 7/5/2022 00:19:48' overrides: 16891474!
           adoptWidgetsColor: paneColor
	color = self defaultColor ifTrue: [
		color _ Theme current paneBackgroundFrom: paneColor.
	].
	super adoptWidgetsColor: paneColor.! !
!Transcript class methodsFor: 'displaying' stamp: 'and 7/5/2022 00:20:31' prior: 16973948!
displayTextOn: aCanvasOrSelf in: aRectangle
	"See senders"
	| font count string x y fh innerR index |
	font _ FontFamily defaultFamilyAndPointSize.
	innerR _ aRectangle insetBy: self padding.
	x _ innerR left.
	y _ innerR top.
	fh _ font lineSpacing.
	count _ lastIndex - firstIndex \\ self maxEntries + 1 min: innerR height // fh - 1.
	index _ lastIndex - count \\ self maxEntries + 1.
	count timesRepeat: [
		string _ entries at: index.	
		aCanvasOrSelf drawString: string at: x@y font: font color: Theme current text.
		y _ y + fh.
		index _ index \\ self maxEntries + 1 ].
	string _ unfinishedEntry contents.
	aCanvasOrSelf drawString: string at: x@y font: font color: Theme current text! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'and 7/5/2022 00:18:37' prior: 16974095 overrides: 16794207!
                              drawOn: aCanvas
	"If we don't call super, clipping fails if zoomed / rotated, and nothing is shown."
	super drawOn: aCanvas.
	aCanvas clippingByCurrentMorphDo: [
		aCanvas
			fillRectangle: self morphLocalBounds
			color: color.
		Transcript displayTextOn: aCanvas in: self morphLocalBounds ].
	self displayBounds ifNotNil: [ :r |
		Transcript bounds:r ].
	self updateWorkspace! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5382-FixTranscriptDarkTheme-AlanDao-and.001.cs.st----!

'From Cuis 6.0 [latest update: #5382] on 9 July 2022 at 4:32:50 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 7/9/2022 16:32:27' prior: 50404949!
                 knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 						'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 						'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 						'Fernando Olivero')
	#('FernanodOlivero' 						'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 						'Gabriel Omar Cotelli')
	#('GC' 						'Gast√≥n Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 						'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 						'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 						'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 						'Marcus Denker')
	#('marcus.denker' 						'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 						'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 		'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 						'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'						'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'						'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'						'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'						'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'						'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 						'Stephane Ducasse')
	#('stephaneducasse'	 					'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 						'Masato Sumi')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 						'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 						'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5383-AddAlanAsKnownContributor-JuanVuletich-2022Jul09-16h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5382] on 9 July 2022 at 4:46:46 pm'!
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 7/9/2022 16:46:11' prior: 16952610!
                   installLowSpaceWatcher
	"Start a process to watch for low-space conditions."
	"
	Smalltalk installLowSpaceWatcher
	"

	[
		self stopLowSpaceWatcher.
		LowSpaceProcess _ [self lowSpaceWatcher] newProcess.
		LowSpaceProcess priority: Processor lowIOPriority + 5.
		LowSpaceProcess name: '[system] Low Space Watcher'.
		LowSpaceProcess resume.
	] valueUnpreemptively
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5384-installLowSpaceWatcher-robustAgainstAbuse-JuanVuletich-2022Jul09-16h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5382] on 9 July 2022 at 4:49:34 pm'!
!Process methodsFor: 'accessing' stamp: 'jmv 7/9/2022 16:48:40' prior: 16917355!
 priority: anInteger 
	"Set the receiver's priority to anInteger."
	priority _ anInteger min: Processor highestPriority max: Processor lowestPriority.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5385-IgnoreInvalidProcessPriorities-clampToValid-JuanVuletich-2022Jul09-16h46m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5385] on 11 July 2022 at 4:31:01 pm'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 7/11/2022 16:11:18'!
                               openOn: process context: context label: title fullView: bool guiRootObject: guiRootObject
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new
			process: process
			context: context.
		debugger interruptedProcessUI: guiRootObject.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 7/11/2022 16:27:51' prior: 16838402!
    openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self lowSpaceChoices , (msgString ifNil: [ '' ]) ]
		ifFalse: [ msgString ].
	interruptedProcessUI _ UISupervisor newProcessIfUI: interruptedProcess.
	UISupervisor whenUIinSafeState: [
		PreDebugWindow
			forceOpen: self
			label: label
			message: msg ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfNeeded.
	] fork.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 7/11/2022 16:21:56' prior: 50404413!
                               openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| guiRootObject |
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	guiRootObject _ UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		self openOn: process context: context label: title fullView: bool guiRootObject: guiRootObject
		].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfNeeded.
	] fork.
	process suspend.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/11/2022 16:25:35' prior: 50404508!
                      newProcessIfUI: processBeingSuspended
	"processBeingSuspended has been suspended or is about to be.
	Answer the UI we created a new process for.
	If not an UI process, still guarantee that the UI process is runnable."

	processBeingSuspended animatedUI ifNotNil: [ :guiRootObject |
		self spawnNewMorphicProcessFor: guiRootObject.
		^guiRootObject ].
	^nil
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5386-MoreRobustDebuggerOpen-JuanVuletich-2022Jul11-16h30m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5386] on 11 July 2022 at 6:53:16 pm'!
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 7/11/2022 18:43:02' prior: 16950483 overrides: 16903568!
              request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock

	| morph world |
	morph _ self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer.
	world _ self runningWorld.
	world ifNil: [
		| answer |
		answer _ nil.
		UISupervisor whenUIinSafeState: [ answer _ self request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock ].
		 [ answer isNil ] whileTrue: [ Processor yield ].
		^answer ].
	world addMorph: morph centeredNear: world activeHand morphPosition - self deltaToTextPane.
	^ morph getUserResponseOrCancel: cancelBlock! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 7/11/2022 18:47:24' prior: 16857050!
                      request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"
	FillInTheBlankMorph request: 'What is your favorite color?'
	"

	^ self request: queryString initialAnswer: '' onCancel: nil! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 7/11/2022 18:46:55' prior: 16857066 overrides: 16903539!
                     request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"
	FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'
		"

	^ self request: queryString initialAnswer: defaultAnswer onCancel: nil! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 7/11/2022 18:48:56' prior: 16857113!
                  request: queryString initialAnswer: defaultAnswer onCancel: aBlock
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Evaluate aBlock if the user cancels."
	"
	FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'
		onCancel: [ 'plase play the game!!' ]
		"
	| w |
	w _ self runningWorld.
	w ifNil: [
		| answer |
		answer _ nil.
		UISupervisor whenUIinSafeState: [ answer _ self request: queryString initialAnswer: defaultAnswer onCancel: aBlock ].
		 [ answer isNil ] whileTrue: [ Processor yield ].
		^answer ].
	^ (self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: w activeHand morphPosition
		onCancelReturn: nil
		acceptOnCR: true)
			ifNil: aBlock! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 7/11/2022 18:46:31' prior: 16857135!
         request: queryString onCancel: aBlock
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Evaluate aBlock if the user cancels."
	"
	FillInTheBlankMorph 
		request: 'What is your favorite color?'
		onCancel: [ 'plase play the game!!' ]
	"

	^ self request: queryString initialAnswer: '' onCancel: aBlock! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 7/11/2022 18:51:27' prior: 50393414!
      invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w actHand delay |
	w _ self runningWorld.
	w ifNil: [
		| answer |
		answer _ nil.
		UISupervisor whenUIinSafeState: [ answer _ self invokeModal: allowKeyboardControl ].
		 [ answer isNil ] whileTrue: [ Processor yield ].
		^answer ].
	actHand _ w activeHand.
	w doOneMinimalCycleNow.
	self popUpAt: actHand morphPosition allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	delay _ Delay forMilliseconds: 10.
	[ self isInWorld and: [self isModalInvokationDone not] ] whileTrue: [
		self comeToFront.
		w doOneMinimalCycleNow. delay wait ].
	self delete.
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 7/11/2022 18:38:29' prior: 50393438!
        invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	| w delay |
	w _ self runningWorld.
	w ifNil: [
		| answer |
		answer _ nil.
		UISupervisor whenUIinSafeState: [ answer _ self invokeAt: aPoint allowKeyboard: aBoolean ].
		 [ answer isNil ] whileTrue: [ Processor yield ].
		^answer ].
	w doOneMinimalCycleNow.
	self popUpAt: aPoint allowKeyboard: aBoolean.
	done _ false.
	delay _ Delay forMilliseconds: 20.
	[ done not and: [self isInWorld] ] whileTrue: [
		self comeToFront.
		w doOneMinimalCycleNow. delay wait ].
	^ mvcSelection ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5387-MoreRobustModalQueries-JuanVuletich-2022Jul11-18h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5324] on 4 July 2022 at 9:21:16 pm'!
!SourceCodeInterval methodsFor: 'source code' stamp: 'FB 7/4/2022 21:16:00' prior: 50370432!
expandUntilStatementEndOn: aSourceCode

	| nextDotIdx |
	
	nextDotIdx := aSourceCode findDelimiters: '.' startingAt: self last.
	^SourceCodeInterval
		from: self first
		to: (nextDotIdx min: aSourceCode size)
	! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 7/4/2022 21:18:15' prior: 50371284!
 replaceRange: aSourceCodeInterval withNewSourceCode: newSourceCode inMethod: aCompiledMethod

	| currentUpdates sourceCodeReplacement|
	
	sourceCodeReplacement := newSourceCode.
	((aSourceCodeInterval last < aCompiledMethod sourceCode size) and: [((aCompiledMethod sourceCode at: aSourceCodeInterval last + 1) = $.)]
		and: [newSourceCode endsWith: '.']) ifTrue: [sourceCodeReplacement := newSourceCode copyUpToLast: $.].
	"It's important to use < and not <= because temporaries declarations are added to the changes collection
	after the changes concerning the inlining of the implementor code, but they need to be replaced first - Fernando"
	currentUpdates := updatedSendersCode at: aCompiledMethod methodReference ifAbsent: (SortedCollection 
		sortBlock: [ :left :right | left key first < right key first ]).
	currentUpdates add: (aSourceCodeInterval -> sourceCodeReplacement).
	updatedSendersCode at: aCompiledMethod methodReference put: currentUpdates.
	! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 7/4/2022 20:15:49' prior: 50371388!
                  addParenthesesIfNeededTo: anExpression

	"TODO: duplicated code in InlineTemporaryVariable"

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |

 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) = $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) = $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [^anExpression]
		ifFalse: [ (anExpression endsWith: '.')
			ifTrue: [^('(', anExpression copyUpToLast: $.), ').']
	 		ifFalse: [^'(', anExpression, ')']
		].! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 7/4/2022 21:17:27' prior: 50387480!
                buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference removingReturn: removeReturn

	| inlinedStatements senderCompleteSourceRanges argumentsAndTemporariesReplacements indentation |

	senderCompleteSourceRanges := aMessageNodeReference methodNode completeSourceRanges.
	self calculateReplacementsFrom: aMessageNodeReference
		usingRanges: senderCompleteSourceRanges.

	self declareTemporariesIfNeededFor: aMessageNodeReference.
	argumentsAndTemporariesReplacements := self replacementsMapForMessageSend: aMessageNodeReference.

	indentation := self indentationUpTo: aMessageNodeReference completeSourceRange first in: aMessageNodeReference compiledMethod sourceCode.
	inlinedStatements := (statementsToInline size > 1) 
		ifTrue: [((statementsToInline allButLast
			 collect: [:aStatementToInline |
				self sourceCodeOfImplementorStatement: aStatementToInline withReplacements: argumentsAndTemporariesReplacements 
					removingReturn: removeReturn.])
				reduce: [:aStatementWithReplacements :nextStatementWithReplacements |
					aStatementWithReplacements, Character newLineCharacter asString, indentation,
						(nextStatementWithReplacements copyReplaceAll: String newLineString with: String newLineString asTokens: false)]), 
					Character newLineCharacter asString]
		ifFalse: [''].
	inlinedStatements := inlinedStatements, (self sourceCodeOfImplementorStatement: statementsToInline last 
		withReplacements: argumentsAndTemporariesReplacements removingReturn: removeReturn).

	^inlinedStatements.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 7/4/2022 20:30:03' prior: 50371450!
    buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference usedInNode: aParseNode

	| inlinedStatements argumentsAndTemporariesReplacements senderCompleteSourceRanges usageNodeSourceRange
	 inlinedUsageStatement statementsWithReplacements indentation |

	senderCompleteSourceRanges := aMessageNodeReference methodNode completeSourceRanges.
	usageNodeSourceRange := (self findRangesOf: aParseNode in: senderCompleteSourceRanges) first.

	self calculateReplacementsFrom: aMessageNodeReference
		usingRanges: senderCompleteSourceRanges.

	self declareTemporariesIfNeededFor: aMessageNodeReference.
	argumentsAndTemporariesReplacements := self replacementsMapForMessageSend: aMessageNodeReference.
	
	statementsWithReplacements := statementsToInline allButLast collect: [:aStatementToInline |
		self sourceCodeOfImplementorStatement: aStatementToInline withReplacements: argumentsAndTemporariesReplacements removingReturn: true].
	statementsWithReplacements add: (self sourceCodeOfImplementorStatement: statementsToInline last 
		withReplacements: argumentsAndTemporariesReplacements removingReturn: true).
	
	indentation := self indentationUpTo: usageNodeSourceRange first in: aMessageNodeReference compiledMethod sourceCode.

	statementsWithReplacements size > 1
		ifTrue: [inlinedStatements := indentation, ((statementsWithReplacements allButLast)
			reduce: [:aStatementWithReplacements :nextStatementWithReplacements |
				aStatementWithReplacements, String newLineString, indentation, (nextStatementWithReplacements
					copyReplaceAll: String newLineString with: String newLineString, indentation asTokens: false) ])]
		 ifFalse: [inlinedStatements := ''].
	inlinedUsageStatement := self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
		lastStatement: statementsToInline last replacement: statementsWithReplacements last.

	statementsWithReplacements size > 1
		ifTrue: [inlinedStatements := inlinedStatements, String newLineString, indentation, inlinedUsageStatement]
		ifFalse: [inlinedStatements := inlinedUsageStatement ].

	^inlinedStatements.! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 7/4/2022 19:52:35' prior: 50371621!
                   sourceCodeOfImplementorStatement: aStatementToInline withReplacements: replacementsDict removingReturn: removeReturn

	| sourceRange originalSourceCode statementReplacements implementorSourceCode |

	implementorSourceCode := methodToInline sourceCode.
	sourceRange := (self findRangesOf: aStatementToInline in: implementorCompleteSourceRanges) anyOne
		asSourceCodeInterval expandUntilStatementEndOn: implementorSourceCode.
	originalSourceCode := implementorSourceCode copyFrom: sourceRange first to: sourceRange last.
	"Replacements must be adjusted because the statement string begins at index 1 instead of the
	original position on the source code"
	statementReplacements := ((replacementsDict associations select: [:anAssociation | sourceRange includesAllOf: (anAssociation key)])
		collect: [:anAssociation | ((anAssociation key first - sourceRange first + 1) to: (anAssociation key last - sourceRange first + 1)) -> anAssociation value])
		asSortedCollection: [ :left :right | left key first < right key first ].

	"Remove the return character if present"
	(removeReturn and: [aStatementToInline isReturn]) ifTrue: [statementReplacements add: (1 to: 1) -> ''].
	^(originalSourceCode copyReplacing: statementReplacements).! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 7/4/2022 20:51:41' prior: 50371659!
       statementWithMessageSend: aMessageNodeReference usedIn: aParseNode inlinedWith: anExpression addingParentheses: addParentheses

	| sourceRangeOfUsage enclosingNodeSourceRange normalizedMessageSendRange expression|

	enclosingNodeSourceRange := (self findRangesOf: aParseNode in: aMessageNodeReference methodNode completeSourceRanges) first.
	sourceRangeOfUsage := aMessageNodeReference completeSourceRange.
	normalizedMessageSendRange := (sourceRangeOfUsage first - enclosingNodeSourceRange first + 1)
					to: (sourceRangeOfUsage last - enclosingNodeSourceRange first + 1).
	"If the expression we are replacing is not at the end of the enclosing node, and it ends with a dot, we must remove it in order for it to be a valid statement"
	expression := ((sourceRangeOfUsage last < enclosingNodeSourceRange last) and: [anExpression endsWith: '.']) 
		ifTrue: [anExpression allButLast] ifFalse: [anExpression].
	expression := addParentheses ifTrue: [self addParenthesesIfNeededTo: expression] ifFalse: [expression].

	^(aMessageNodeReference compiledMethod sourceCode copyFrom: enclosingNodeSourceRange first to: enclosingNodeSourceRange last)
		copyReplacing: (Array with: ((normalizedMessageSendRange -> expression)))! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 7/4/2022 20:29:50' prior: 50371690!
                   statementWithMessageSend: aMessageNodeReference usedIn: aParseNode lastStatement: implementorLastStatementToInline
	replacement: lastStatementWithReplacements

	| inlinedStatementContainingMessageSend |

	implementorLastStatementToInline expr isMessageNode
		ifTrue: [ | senderSourceRange enclosingNode |
			senderSourceRange := aMessageNodeReference completeSourceRange.
			(aMessageNodeReference methodNode parseNodesPathAt: senderSourceRange first
				ifAbsent: [self shouldNotHappen])
					detect: [:aNodeAndRange | (aNodeAndRange value includesAllOf: senderSourceRange)
						and: [aNodeAndRange value first <= senderSourceRange first]]
					ifFound: [:aNodeAndRange |
						enclosingNode := aNodeAndRange key.
					]
					ifNone: [self shouldNotHappen].
			inlinedStatementContainingMessageSend := self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
				inlinedWith: lastStatementWithReplacements addingParentheses: enclosingNode isMessageNode.
		]
		ifFalse: [
			inlinedStatementContainingMessageSend := self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
				inlinedWith: lastStatementWithReplacements addingParentheses: false.
		].

	^inlinedStatementContainingMessageSend.! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 7/4/2022 20:36:29' prior: 50371789!
                       inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReferenceWithReturnValue

	| enclosingBlock |
	
	enclosingBlock := self enclosingBlockOf: aMessageNodeReferenceWithReturnValue.
	(self parseNode: enclosingBlock returns: aMessageNodeReferenceWithReturnValue messageNode)
		ifTrue: [^self inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReferenceWithReturnValue
			removingReturn: false].

	"Find the outermost statement containing the usage to inline that's inside the enclosing block"
	self findOutermostStatementContaining: aMessageNodeReferenceWithReturnValue enclosedBy: enclosingBlock
		ifFound: [ :outermostNodeAndRange |
			self inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReferenceWithReturnValue
				usedInParseNode: outermostNodeAndRange	 key
		]
		ifNone: [ 
			self inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReferenceWithReturnValue
				removingReturn: true
		]




	! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 7/4/2022 20:47:31' prior: 50371843!
                    inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeWithReturnValueReference usedInParseNode: aParseNode

	| inlinedStatements sourceRangeOfUsage senderMethod|
	
	inlinedStatements := self buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeWithReturnValueReference
		usedInNode: aParseNode.

	senderMethod := aMessageNodeWithReturnValueReference compiledMethod.
	sourceRangeOfUsage := self findSourceRangeOf: aParseNode in: senderMethod.
	
	self replaceRange: sourceRangeOfUsage withNewSourceCode: inlinedStatements inMethod: senderMethod.


	! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 7/4/2022 20:22:13' prior: 50371865!
  inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReference removingReturn: removeReturn

	| inlinedStatements sourceRangeToReplace senderMethod senderSourceCode |
	
	senderMethod := aMessageNodeReference compiledMethod.
	senderSourceCode := aMessageNodeReference compiledMethod sourceCode.
	
	statementsToInline isEmpty
		ifTrue: [
			inlinedStatements := ''.
			sourceRangeToReplace := aMessageNodeReference completeSourceRange asSourceCodeInterval
				expandUntilStartOfNextStatementOn: senderSourceCode.
		]
		ifFalse: [
			inlinedStatements := self buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference
				removingReturn: removeReturn.
			removeReturn
				ifTrue: [sourceRangeToReplace := aMessageNodeReference completeSourceRange]
				ifFalse: 	[
					(self enclosingBlockOf: aMessageNodeReference) nodesDo: [:aNode |
						(aNode isReturn and: [aNode expr equivalentTo: aMessageNodeReference messageNode ])
							ifTrue: [sourceRangeToReplace := (self findSourceRangeOf: aNode in: senderMethod)
								asSourceCodeInterval expandUntilStartOfNextStatementOn: senderSourceCode ] ]
				].
		].

	self replaceRange: sourceRangeToReplace withNewSourceCode: inlinedStatements inMethod: senderMethod.



	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5388-InlineMethodFix-FernandoBalboa-2022Jun29-18h34m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5388] on 12 July 2022 at 9:03:58 am'!
!VariableNode methodsFor: 'testing' stamp: 'HAW 7/12/2022 09:01:26' prior: 16977680 overrides: 16906410!
                           isSelfPseudoVariable
	"Answer if this ParseNode represents the 'self' pseudo-variable."

	^ key = 'self' or: [ name = 'self'  or: [name = '{{self}}']]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5389-VariableNodeFix-HernanWilkinson-2022Jul12-09h01m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5389] on 12 July 2022 at 2:14:41 pm'!

Object subclass: #UISupervisor
	instanceVariableNames: ''
	classVariableNames: 'UIProcess UI '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #UISupervisor category: #'System-Support' stamp: 'Install-5390-StoreUiRootAtUISupervisor-JuanVuletich-2022Jul12-14h03m-jmv.001.cs.st 7/22/2022 17:17:10'!
Object subclass: #UISupervisor
	instanceVariableNames: ''
	classVariableNames: 'UI UIProcess'
	poolDictionaries: ''
	category: 'System-Support'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:08:10' prior: 50404368!
              spawnNewMorphicProcessFor: guiRootObject
	"
	Safe to run anytime, as the old Morphic process will end by itself.
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.
	"
	| previousUIProcess previousUI |
	previousUI _ UI.
	previousUIProcess _ UIProcess.
	UI _ guiRootObject.
	UIProcess _ guiRootObject runProcess.
	previousUIProcess ifNotNil: [ previousUIProcess animatedUI: nil ].
	UIProcess resume! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:10:32' prior: 16975462!
          stopUIProcess
	UIProcess ifNotNil: [
		UIProcess animatedUI: nil.
		UIProcess terminate ].
	UI _ nil .
	UIProcess _ nil.! !
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 7/12/2022 14:08:49' prior: 16982214!
        runProcess
	
	| process |
	
	process _ [ self mainLoop ] newProcess.
	process
		priority: Processor userSchedulingPriority;
		name: 'Morphic UI';
		animatedUI: self.
		"remove #animatedUI:"
	
	^ process! !

Object subclass: #UISupervisor
	instanceVariableNames: ''
	classVariableNames: 'UI UIProcess'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #UISupervisor category: #'System-Support' stamp: 'Install-5390-StoreUiRootAtUISupervisor-JuanVuletich-2022Jul12-14h03m-jmv.001.cs.st 7/22/2022 17:17:10'!
Object subclass: #UISupervisor
	instanceVariableNames: ''
	classVariableNames: 'UI UIProcess'
	poolDictionaries: ''
	category: 'System-Support'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5390-StoreUiRootAtUISupervisor-JuanVuletich-2022Jul12-14h03m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5389] on 12 July 2022 at 2:29:56 pm'!
!UISupervisor class methodsFor: 'accessing' stamp: 'jmv 7/12/2022 14:20:06'!
                    animatedUIOf: aProcess
	"
	UISupervisor animatedUIOf: UIProcess
	[ (UISupervisor animatedUIOf: Processor activeProcess) print ] fork
	"
	^aProcess == UIProcess ifTrue: [ ^UI ]! !
!UISupervisor class methodsFor: 'accessing' stamp: 'jmv 7/12/2022 14:22:22'!
isUIProcess: aProcess
	^UIProcess == aProcess! !
!UISupervisor class methodsFor: 'accessing' stamp: 'jmv 7/12/2022 14:19:26' overrides: 16903785!
              runningWorld
	"
	UISupervisor runningWorld
	[ UISupervisor runningWorld print ] fork
	"
	^Processor activeProcess == UIProcess ifTrue: [ ^UI ]! !
!Object methodsFor: 'morphic' stamp: 'jmv 7/12/2022 14:17:36' prior: 16903785!
                               runningWorld
	"Answer a morphic world that is the current UI focus.
	This is the UI root animated by the active Process.
	This method could answer nil, if not in an UI process!!"

	^UISupervisor runningWorld! !
!Debugger methodsFor: 'private' stamp: 'jmv 7/12/2022 14:23:47' prior: 16838823!
                            resumeProcess
	| mustTerminateActive mustRedisplay |
	mustRedisplay _ self runningWorld.
	savedCursor
		ifNotNil: [savedCursor activateCursor].
	mustTerminateActive _ false.
	interruptedProcess isTerminated ifFalse: [
		self runningWorld = interruptedProcessUI ifTrue: [
			mustTerminateActive _ true ].
		interruptedProcess resume ].
	"if old process was terminated, just terminate current one"
	interruptedProcess _ nil.
	contextStackIndex _ 0.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	mustRedisplay ifNotNil: [ :w | UISupervisor whenUIinSafeState: [ w displayWorld ]].
	"restart low space handler"
	Smalltalk installLowSpaceWatcher.
	"If this process was the UI process, then it will terminate and never return to caller."
	mustTerminateActive
		ifTrue: [ Processor terminateActive ]! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 7/12/2022 14:22:41' prior: 16800195!
              catchThePig: aProcess
	| rule |
	"nickname, allow-stop, allow-debug"
	rule _ (ProcessBrowser rulesFor: aProcess) first.

	(UISupervisor isUIProcess: aProcess)
		ifTrue: [ "aProcess debugWithTitle: 'Interrupted from the CPUWatcher'." ]
		ifFalse: [
			rule ifFalse: [ ^self ].
			ProcessBrowser suspendProcess: aProcess.
			self openWindowForSuspendedProcess: aProcess ]! !
!Process methodsFor: 'printing' stamp: 'jmv 7/12/2022 14:28:05' prior: 50343617!
                          browserPrintStringFull: aBoolean

	^String streamContents: [ :stream |
		aBoolean ifTrue: [
			stream
				nextPutAll: self statusString;
				space ].
		priority printOn: stream.
		stream nextPutAll: ' ('.
		self hash printOn: stream.
		stream
			nextPutAll: ') ';
			nextPutAll: self name.
		(UISupervisor animatedUIOf: self) ifNotNil: [ :ui |
			stream nextPutAll: ' - '.
			ui printOn: stream ].
		aBoolean ifTrue: [
			stream
				nextPutAll: ': ';
				nextPutAll: suspendedContext printString ]]! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:26:09' prior: 50406977!
           newProcessIfUI: processBeingSuspended
	"processBeingSuspended has been suspended or is about to be.
	Answer the UI we created a new process for.
	If not an UI process, still guarantee that the UI process is runnable."

	processBeingSuspended == UIProcess ifTrue: [
		self spawnNewMorphicProcessFor: UI.
		^UI ].
	^nil
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:26:58' prior: 50404526!
 newUIProcessIfNeeded
	"If the system needs a UIProcess (we know because UIProcess is not nil),
	then ensure that the UIProcess is ready to run, in order to hava a responsive UI.
	If we needed to create a new UI process, answer the old one, as it is most likely the
	process the user is interested in debugging. See senders."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isBlocked | oldUIProcess isSuspended | oldUIProcess isTerminated ifTrue: [
			oldUIProcess == UIProcess ifTrue: [
				self spawnNewMorphicProcessFor: UI.
				^oldUIProcess ]]].
	^nil! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:24:22' prior: 50407628!
           spawnNewMorphicProcessFor: guiRootObject
	"
	Safe to run anytime, as the old Morphic process will end by itself.
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.
	"
	UI _ guiRootObject.
	UIProcess _ guiRootObject runProcess.
	UIProcess resume! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:24:30' prior: 50407644!
  stopUIProcess
	UIProcess ifNotNil: [
		UIProcess terminate ].
	UI _ nil.
	UIProcess _ nil.! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:27:39' prior: 16975468!
   ui
	^UI! !
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 7/12/2022 14:24:45' prior: 50407651!
                         runProcess
	
	| process |
	process _ [ self mainLoop ] newProcess.
	process
		priority: Processor userSchedulingPriority;
		name: 'Morphic UI'.
	^ process! !

Process removeSelector: #animatedUI!

!methodRemoval: Process #animatedUI stamp: 'Install-5391-anumatedUI-remove-JuanVuletich-2022Jul12-14h14m-jmv.001.cs.st 7/22/2022 17:17:10'!
animatedUI
	"If we are an UI process, answer the root object of that UI.
	For a Morphic process, it is the Morphic World.
	Answer nil if not an UI process."

	^self triggerEvent: #animatedUI!

Process removeSelector: #animatedUI:!

!methodRemoval: Process #animatedUI: stamp: 'Install-5391-anumatedUI-remove-JuanVuletich-2022Jul12-14h14m-jmv.001.cs.st 7/22/2022 17:17:10'!
animatedUI: anUIRoot
	"Let us know that we are running a certain UI.
	In Morphic, anUIRoot should be the World being run.
	We use the event system to avoid the need to add an ivar to us."

	self removeActionsForEvent: #animatedUI.
	anUIRoot ifNotNil: [
		self when: #animatedUI send: #yourself to: anUIRoot ]!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Process allSubInstancesDo: [ :p | p removeActionsForEvent: #animatedUI ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5391-anumatedUI-remove-JuanVuletich-2022Jul12-14h14m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5389] on 12 July 2022 at 2:49:39 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/12/2022 14:48:05'!
             uiProcess: aProcess
	UIProcess _ aProcess! !
!Debugger methodsFor: 'private' stamp: 'jmv 7/12/2022 14:49:29' prior: 50407724!
  resumeProcess
	| mustRedisplay |
	mustRedisplay _ self runningWorld.
	savedCursor
		ifNotNil: [savedCursor activateCursor].
	interruptedProcess isTerminated ifFalse: [
		(UISupervisor isUIProcessRunning and: [ UISupervisor ui == interruptedProcessUI]) ifTrue: [
			UISupervisor uiProcess: interruptedProcess ].
		interruptedProcess resume ].
	"if old process was resumed, just let the current one terminate"
	interruptedProcess _ nil.
	contextStackIndex _ 0.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	mustRedisplay ifNotNil: [ :w | UISupervisor whenUIinSafeState: [ w displayWorld ]].
	"restart low space handler"
	Smalltalk installLowSpaceWatcher.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5392-bugfix-UIProcess-consistency-JuanVuletich-2022Jul12-14h29m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5393] on 13 July 2022 at 3:01:25 pm'!
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 7/13/2022 15:01:00' prior: 50407002 overrides: 16903568!
   request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock

	| morph world |
	morph _ self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer.
	world _ self runningWorld.
	world ifNil: [
		| answer |
		answer _ self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [ answer _ self request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	world addMorph: morph centeredNear: world activeHand morphPosition - self deltaToTextPane.
	^ morph getUserResponseOrCancel: cancelBlock! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 7/13/2022 15:01:04' prior: 50407057!
                        request: queryString initialAnswer: defaultAnswer onCancel: aBlock
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Evaluate aBlock if the user cancels."
	"
	FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'
		onCancel: [ 'plase play the game!!' ]
		"
	| w |
	w _ self runningWorld.
	w ifNil: [
		| answer |
		answer _ self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [ answer _ self request: queryString initialAnswer: defaultAnswer onCancel: aBlock ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	^ (self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: w activeHand morphPosition
		onCancelReturn: nil
		acceptOnCR: true)
			ifNil: aBlock! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 7/13/2022 15:00:56' prior: 50407102!
                               invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w actHand delay |
	w _ self runningWorld.
	w ifNil: [
		| answer |
		answer _ self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [ answer _ self invokeModal: allowKeyboardControl ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	actHand _ w activeHand.
	w doOneMinimalCycleNow.
	self popUpAt: actHand morphPosition allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	delay _ Delay forMilliseconds: 10.
	[ self isInWorld and: [self isModalInvokationDone not] ] whileTrue: [
		self comeToFront.
		w doOneMinimalCycleNow. delay wait ].
	self delete.
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 7/13/2022 15:00:52' prior: 50407132!
          invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	| w delay |
	w _ self runningWorld.
	w ifNil: [
		| answer |
		answer _ self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [ answer _ self invokeAt: aPoint allowKeyboard: aBoolean ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	w doOneMinimalCycleNow.
	self popUpAt: aPoint allowKeyboard: aBoolean.
	done _ false.
	delay _ Delay forMilliseconds: 20.
	[ done not and: [self isInWorld] ] whileTrue: [
		self comeToFront.
		w doOneMinimalCycleNow. delay wait ].
	^ mvcSelection ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5393-FixFor5387-nilNotAValidMarkerObject-JuanVuletich-2022Jul13-15h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5393] on 14 July 2022 at 1:16:26 pm'!
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 7/14/2022 13:09:54'!
         doOneCycle: delay
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(Preferences at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			delay setDelay: wait; wait ].

	"Record start time of this cycle, and do cycle"
	canvas ensureCurrentMorphIsWorld.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow.! !
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 7/14/2022 13:15:35' prior: 16982171!
                    clearWaitDelay
	waitDelay ifNotNil: [
		waitDelay unschedule.
		waitDelay _ nil ].! !
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 7/14/2022 13:15:33' prior: 50404382!
              mainLoop
	| d |

	"Needed if for some reason Cuis is started with an earlier DateTime than the image was saved.
	Might happen, especially on RasPi or other systems without an RTC"
	lastCycleTime _ Time localMillisecondClock.
	lastAlarmTime _ 0.

	canvas isNil ifTrue: [
		self setMainCanvas ].
	self redrawNeeded.
	d _ Delay forMilliseconds: 50.
	[
		self doOneCycle: d.
		UISupervisor isUIProcessRunning ]
			whileTrue: []! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui clearWaitDelay.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5394-AvoidPossibleRaceConditionOnMorphicDelay-JuanVuletich-2022Jul14-13h13m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5394] on 14 July 2022 at 1:19:19 pm'!

WorldMorph removeSelector: #clearWaitDelay!

!methodRemoval: WorldMorph #clearWaitDelay stamp: 'Install-5395-cleanup-JuanVuletich-2022Jul14-13h17m-jmv.001.cs.st 7/22/2022 17:17:10'!
clearWaitDelay
	waitDelay ifNotNil: [
		waitDelay unschedule.
		waitDelay _ nil ].!

WorldMorph removeSelector: #doOneCycle!

!methodRemoval: WorldMorph #doOneCycle stamp: 'Install-5395-cleanup-JuanVuletich-2022Jul14-13h17m-jmv.001.cs.st 7/22/2022 17:17:10'!
doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(Preferences at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	canvas ensureCurrentMorphIsWorld.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5395-cleanup-JuanVuletich-2022Jul14-13h17m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5394] on 14 July 2022 at 1:27:16 pm'!
!Debugger methodsFor: 'private' stamp: 'jmv 7/14/2022 13:27:09' prior: 50407902!
             resumeProcess
	| mustTerminateActive mustRedisplay |
	mustRedisplay _ self runningWorld.
	savedCursor
		ifNotNil: [savedCursor activateCursor].
	mustTerminateActive _ false.
	interruptedProcess isTerminated ifFalse: [
		(UISupervisor isUIProcessRunning and: [ UISupervisor ui == interruptedProcessUI]) ifTrue: [
			UISupervisor uiProcess: interruptedProcess.
			mustTerminateActive _ true ].
		interruptedProcess resume ].
	interruptedProcess _ nil.
	contextStackIndex _ 0.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	mustRedisplay ifNotNil: [ :w | UISupervisor whenUIinSafeState: [ w displayWorld ]].
	"restart low space handler"
	Smalltalk installLowSpaceWatcher.
	"If this process was the UI process, and we just resumed the old one,
	then terminate us and never return to caller."
	mustTerminateActive
		ifTrue: [ Processor terminateActive ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5396-DoTerminateAuxDebuggerUIProcess-JuanVuletich-2022Jul14-13h19m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5396] on 14 July 2022 at 8:01:17 pm'!
!WorldMorph methodsFor: 'stepping' stamp: 'jmv 7/14/2022 18:27:35'!
                        runDeferredUIMessages
	"Processing the queue until empty is wrong if a block in it calls #addDeferredUIMessage: itself, because this loop will never end.
	Instead, process no more than entries already in queue befor we start iterating!!"
	| readyToProcess |
	readyToProcess _ deferredUIMessages size.
	readyToProcess timesRepeat: [
		deferredUIMessages nextOrNil ifNotNil: [ :block |
			block value ]].! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/14/2022 19:50:25' prior: 50407803!
           newUIProcessIfNeeded
	"If the system needs a UIProcess (we know because UIProcess is not nil),
	then ensure that the UIProcess is ready to run, in order to hava a responsive UI.
	If we needed to create a new UI process, answer the old one, as it is most likely the
	process the user is interested in debugging. See senders."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isBlocked | oldUIProcess isSuspended | oldUIProcess isTerminated ifTrue: [
			self spawnNewMorphicProcessFor: UI.
			^oldUIProcess ]].
	^nil! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/14/2022 19:14:50' prior: 50407824!
                     spawnNewMorphicProcessFor: guiRootObject
	"
	Safe to run anytime, as the old Morphic process will end by itself.
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.
	"
	"If the old one gets resumed, don't step on each other feet"
	UIProcess ifNotNil: [UIProcess priority: UIProcess priority-1].
	UI _ guiRootObject.
	UIProcess _ guiRootObject runProcess.
	UIProcess resume! !
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 7/14/2022 18:45:46' prior: 50408071!
          doOneCycle: delay
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(Preferences at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			delay setDelay: wait; wait ].

	self doOneCycleNow.! !
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 7/14/2022 19:22:12' prior: 50361363!
              doOneCycleNow
	"Immediately do one cycle of the interaction loop.
	Only used for a few tests."
	"See #eventTickler"
	| hadAny |
	lastCycleTime _ Time localMillisecondClock.
	Cursor currentCursor = (Cursor cursorAt: #waitCursor) ifTrue: [ Cursor defaultCursor activateCursor ].
	"Repair visual damage."
	self checkForNewScreenSize.
	canvas ensureCurrentMorphIsWorld.
	self displayWorldSafely.
	"Run steps, alarms and deferred UI messages"
	self runDeferredUIMessages.
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.
	"Process user input events. Run all event triggered code."
	hadAny _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAny _ hadAny | h processEventQueue ].
	"The default is the primary hand"
	activeHand _ self hands first.
	"Run any deferred UI messages that were enqueued during this cycle before the inter cycle pause."
	self runDeferredUIMessages.
	lastCycleHadAnyEvent _ hadAny.
	^hadAny! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 7/14/2022 20:00:31' prior: 50402943!
                    fullDraw: aMorph
	"Draw the full Morphic structure on us"

	"The main canvas should only be drawn by the UI process.
	If some other process has been ser as the UI process, don't continue, as breakage is likely."
	world ifNotNil: [
		world canvas == self ifTrue: [
			UISupervisor isUIProcessRunning ifFalse: [^self]]].
	aMorph visible ifFalse: [^ self].

	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."
	self into: aMorph.

	currentMorph layoutSubmorphsIfNeeded.

	currentMorph isKnownFailing ifTrue: [
		self canvasToUse drawCurrentAsError.
		self outOfMorph.
		^ self].

	(currentMorph isOwnedByHand and: [
			(Preferences at: #cheapWindowReframe) and: [currentMorph is: #SystemWindow]]) ifTrue: [
		self drawCurrentAsOutline.
		self outOfMorph.
		^ self].

	"Draw current Morph and submorphs"	
	self canvasToUse drawCurrentAndSubmorphs.

	self outOfMorph! !

WorldMorph removeSelector: #runStepMethods!

!methodRemoval: WorldMorph #runStepMethods stamp: 'Install-5397-RobustMorphicAgainstTesterMalice-JuanVuletich-2022Jul14-19h48m-jmv.001.cs.st 7/22/2022 17:17:10'!
runStepMethods
	"Perform periodic activity inbetween event cycles"
	| readyToProcess |

	"Processing the queue until empty is wrong if a block in it calls #addDeferredUIMessage: itself, because this loop will never end.
	Instead, process no more than entries already in queue befor we start iterating!!"
	readyToProcess _ deferredUIMessages size.
	readyToProcess timesRepeat: [
		deferredUIMessages nextOrNil ifNotNil: [ :block |
			block value
		]
	].
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5397-RobustMorphicAgainstTesterMalice-JuanVuletich-2022Jul14-19h48m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5397] on 15 July 2022 at 4:47:21 pm'!
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 7/15/2022 16:46:11' prior: 50408142!
                      mainLoop
	| d |

	"Needed if for some reason Cuis is started with an earlier DateTime than the image was saved.
	Might happen, especially on RasPi or other systems without an RTC"
	lastCycleTime _ Time localMillisecondClock.
	lastAlarmTime _ 0.

	canvas isNil ifTrue: [
		self setMainCanvas ].
	self displayWorld.
	d _ Delay forMilliseconds: 50.
	[
		self doOneCycle: d.
		UISupervisor isUIProcessRunning ]
			whileTrue: []! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5398-RedrawWorldOnNewUIProcess-JuanVuletich-2022Jul15-16h45m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5397] on 15 July 2022 at 4:57:52 pm'!
!Process methodsFor: 'printing' stamp: 'jmv 7/15/2022 16:50:49' prior: 50407769!
                     browserPrintStringFull: aBoolean

	^String streamContents: [ :stream |
		stream
			nextPutAll: self statusString;
			space.
		priority printOn: stream.
		stream nextPutAll: ' ('.
		self hash printOn: stream.
		stream
			nextPutAll: ') ';
			nextPutAll: self name.
		(UISupervisor animatedUIOf: self) ifNotNil: [ :ui |
			stream nextPutAll: ' - '.
			ui printOn: stream ].
		aBoolean ifTrue: [
			stream
				nextPutAll: ': ';
				nextPutAll: suspendedContext printString ]]! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 7/15/2022 16:56:57' prior: 50408346!
     spawnNewMorphicProcessFor: guiRootObject
	"
	Safe to run anytime, as the old Morphic process will end by itself.
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.
	"
	"If the old one gets resumed, don't step on each other feet"
	UIProcess ifNotNil: [
		UIProcess
			name: 'Formerly: ', UIProcess name;
			priority: UIProcess priority-1].
	UI _ guiRootObject.
	UIProcess _ guiRootObject runProcess.
	UIProcess resume! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5399-BetterProcessNameInProcessBrowser-JuanVuletich-2022Jul15-16h47m-jmv.001.cs.st----!

----QUIT----(22 July 2022 17:18:36) Cuis6.0-5399.image priorSource: 2332882!

----STARTUP---- (14 September 2022 16:06:18) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5399.image!


'From Cuis 6.0 [latest update: #5399] on 23 July 2022 at 7:21:44 pm'!
!MenuItemMorph methodsFor: 'accessing' stamp: 'HAW 7/23/2022 19:21:29' prior: 50339557!
                         contentsWithMarkers: aString inverse: inverse 
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString _ nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString _ aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`.
	marker lock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5400-KeepsMenuItem-HernanWilkinson-2022Jul23-17h51m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5400] on 25 July 2022 at 8:12:10 am'!

Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups optionsChanger rootMenu menuDefinitionSelector subMenuItemsDefinition itemsDefinition '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #DynamicMenuBuilder category: #'Morphic-Menus' stamp: 'Install-5401-MenuBuildinSubMenuSupport-HernanWilkinson-2022Jul23-19h50m-HAW.003.cs.st 9/14/2022 16:06:22'!
Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups optionsChanger rootMenu menuDefinitionSelector subMenuItemsDefinition itemsDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuMorph methodsFor: 'construction' stamp: 'HAW 7/25/2022 07:42:50'!
    addItemFromDictionary: aMenuItemDefinition
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object. If nil, use defaultTarget. If a Symbol, send it as message to defaultTarget to get real target.
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form
		#submenuOf - optional label of the parent menu this item should belong to"
		
	| realTarget  item |
	
	realTarget _ aMenuItemDefinition at: #object ifAbsent: [defaultTarget].
	realTarget isSymbol ifTrue: [ realTarget _ defaultTarget perform: realTarget ].
	
	item _ self addItemFromDictionary: aMenuItemDefinition targeting: realTarget.
	
	(Preferences at: #wantsMenuIcons) ifTrue: [ aMenuItemDefinition at: #icon ifPresent: [ :symbolOrFormOrNil | item setIcon: symbolOrFormOrNil ]].
	aMenuItemDefinition at: #balloonText ifPresent: [ :balloonText | item setBalloonText: balloonText ].
	
	^item! !
!MenuMorph methodsFor: 'construction' stamp: 'HAW 7/25/2022 07:42:50'!
                       addItemFromDictionary: aMenuItemDefinition targeting: realTarget

	| label selector argumentList |
	
	label := aMenuItemDefinition at: #label.
	selector := aMenuItemDefinition at: #selector.
	argumentList := aMenuItemDefinition at: #arguments ifAbsent: [ #() ].
	
	^ label isSymbol
		ifTrue: [
			self
				addUpdating: label
				target: realTarget
				action: selector
				argumentList: argumentList ]
		ifFalse: [
			self
				add: label
				target: realTarget
				action: selector
				argumentList: argumentList ]! !
!MenuMorph methodsFor: 'construction' stamp: 'HAW 7/25/2022 07:36:27'!
                   addItemFromDictionaryOrNil: aMenuItemDefinitionOrNil 
	"See addItemFromDictionary: for definition of the expected Dictionary.
	Note: nil elements will add a line."

	^aMenuItemDefinitionOrNil
		ifNil: [ self addLine ]
		ifNotNil: [ self addItemFromDictionary: aMenuItemDefinitionOrNil ].
	
	! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/23/2022 22:02:15'!
   addGroupSeparationTo: aMenuMorph 
	
	aMenuMorph addLine ! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:20:26'!
              addGroupedItemsFrom: anItemsDefinition toMenu: aMenu 

	| theGroups |
	
	theGroups := anItemsDefinition groupBy: [ :item | item at: #itemGroup ].
	theGroups keys asSortedCollection 
		do: [ :group | self addItemsOfGroup: (theGroups at: group) to: aMenu ]
		separatedBy: [ self addGroupSeparationTo: aMenu ].
! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:21:02'!
                  addGroupedItemsToMenu
	
	self addGroupedItemsFrom: self rootItemsDefinition toMenu: rootMenu .
	! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:31:31'!
      addItemsOfGroup: group to: aMenu 

	| groupMenuOptions addedMenuItem |
	
	groupMenuOptions := group asSortedCollection: [ :leftItem :rightItem | (leftItem at: #itemOrder) < (rightItem at: #itemOrder) ].
	
	groupMenuOptions do: [ :options | 
		addedMenuItem := aMenu addItemFromDictionaryOrNil: options.
		self addSubMenuTo: addedMenuItem].! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:59:56'!
                   addSubMenuTo: aMenuItem

	subMenuItemsDefinition 
		at: aMenuItem contents
		ifPresent: [ :subMenuDefinition | self addSubMenuTo: aMenuItem from: subMenuDefinition ]
		ifAbsent: []! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:15:31'!
                  addSubMenuTo: aMenuItem from: subMenuDefinition

	| subMenu |

	subMenu := MenuMorph new.
	"Add the menu items recursively to the parent menu item - Hernan"
	self addGroupedItemsFrom: subMenuDefinition toMenu: subMenu .
	aMenuItem subMenu: subMenu! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:24:05'!
               createRootMenu

	rootMenu := self hasTitle ifTrue: [ MenuMorph entitled: title] ifFalse: [ MenuMorph new ].
	rootMenu defaultTarget: defaultTarget! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:59:56'!
                    initializeSubMenusDefinition

	^ subMenuItemsDefinition := (itemsDefinition select: [ :item | item includesKey: #submenuOf ]) groupBy: [ :item | item at: #submenuOf ]! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:20:39'!
rootItemsDefinition

	^ itemsDefinition reject: [ :item | item includesKey: #submenuOf ]! !
!DynamicMenuBuilder class methodsFor: 'examples' stamp: 'HAW 7/25/2022 08:10:47'!
                  exampleItemWithoutSubMenu

	^ {
		#itemGroup 			-> 		10.
		#itemOrder 			-> 		10.
		#label 			-> 		'item without submenu'.
		#selector 			-> 		#printString.
		#icon 			-> 		#editFindReplaceIcon
	} asDictionary! !
!DynamicMenuBuilder class methodsFor: 'examples' stamp: 'HAW 7/25/2022 07:58:33'!
                         exampleWithSubMenus

	(self buildTitled: 'Example with Sub Menus' targeting: nil collectingMenuOptionsWith: #exampleWithSubMenusDefinition) openInWorld ! !
!DynamicMenuBuilder class methodsFor: 'examples' stamp: 'HAW 7/25/2022 08:11:37'!
                  exampleWithSubMenusDefinition

	| topItemWithSubMenus subItemWithSubMenu |
	
	topItemWithSubMenus := 'top item with submenu...'.
	subItemWithSubMenu := 'subitem with submenu...'.
	
	^ {
			self exampleItemWithoutSubMenu.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		topItemWithSubMenus.
				#selector 			-> 		nil.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> topItemWithSubMenus .
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'subitem without submenu'.
				#selector 		-> 		#printString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> topItemWithSubMenus .
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		subItemWithSubMenu.
				#selector 		-> 		#printString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> topItemWithSubMenus.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'another subitem without submenu'.
				#selector 		-> 		#printString.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> subItemWithSubMenu.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 	10.
				#label 			-> 		'sub sub item without submenu'.
				#selector 		-> 		#printString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
		}
	! !
!MenuMorph methodsFor: 'construction' stamp: 'HAW 7/25/2022 07:43:35' prior: 50402642!
           addItemsFromDictionaries: aMenuItemsDefinition
	
	"see addItemFromDictionary: for expected dictionary definition"
	
	aMenuItemsDefinition do: [ :menuItemDefinition | self addItemFromDictionaryOrNil: menuItemDefinition ]! !
!MenuMorph methodsFor: 'construction' stamp: 'HAW 7/25/2022 07:48:03' prior: 16882681!
          addLine
	"Append a divider line to this menu. Suppress duplicate lines."

	| lastMorph |
	
	submorphs isEmpty ifTrue: [^ self].
	
	lastMorph := self lastSubmorph.
	lastMorph class == MenuLineMorph
		ifFalse: [
			lastMorph := MenuLineMorph new.
			self addMorphBack: lastMorph ].
		
	^lastMorph 
! !
!DynamicMenuBuilder methodsFor: 'initialization' stamp: 'HAW 7/25/2022 07:21:30' prior: 16845398!
                  initializeTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector changingThemWith: anOptionsChangerBlock

	title := aTitle.
	defaultTarget := aDefaultTarget.
	menuDefinitionSelector := aMenuOptionsSelector.
	optionsChanger := anOptionsChangerBlock ! !
!DynamicMenuBuilder methodsFor: 'building' stamp: 'HAW 7/25/2022 07:59:50' prior: 16845410!
      build

	self 
		createRootMenu;
	 	collectMenuOptions;
		changeOptions;
		initializeSubMenusDefinition;
		addGroupedItemsToMenu.		
			
	^ rootMenu.! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:20:39' prior: 16845447!
   changeOptions

	optionsChanger value: itemsDefinition! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:21:30' prior: 16845452!
 classesProvidingMenuOptions

	^(Smalltalk allClassesImplementing: menuDefinitionSelector) select: [ :aClass | aClass isMeta ]! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/25/2022 07:21:30' prior: 16845459!
                         collectMenuOptions

	itemsDefinition := OrderedCollection new.
	self classesProvidingMenuOptions do: [ :aClass | itemsDefinition addAll: (aClass soleInstance perform: menuDefinitionSelector) ].
	! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/25/2022 07:21:54' prior: 16845481!
              targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector

	^self titled: self noTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector

! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/25/2022 07:22:10' prior: 16845490!
                         titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector

	^self titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector changingThemWith: [ :options | ]! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/25/2022 07:22:23' prior: 16845500!
                 titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector changingThemWith: anOptionsChangerBlock

	^self new initializeTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector changingThemWith: anOptionsChangerBlock

! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/25/2022 07:22:41' prior: 16845516!
                           buildTargeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector

	^(self targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector) build! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/25/2022 07:22:47' prior: 16845524!
            buildTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector

	^(self titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector) build! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/25/2022 07:22:55' prior: 16845533!
              buildTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector changingThemWith: anOptionsChangerBlock

	^(self titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuDefinitionSelector changingThemWith: anOptionsChangerBlock) build! !

DynamicMenuBuilder class removeSelector: #exampleMenuWithSubMenues!

DynamicMenuBuilder class removeSelector: #exampleMenuWithSubMenuesDefinition!

DynamicMenuBuilder class removeSelector: #exampleWithSubMenues!

DynamicMenuBuilder class removeSelector: #example!

DynamicMenuBuilder class removeSelector: #exampleWithSubMenuesDefinition!

DynamicMenuBuilder class removeSelector: #itemWithoutSubMenu!

DynamicMenuBuilder removeSelector: #addGroupedMenuOptionsToMenu!

!methodRemoval: DynamicMenuBuilder #addGroupedMenuOptionsToMenu stamp: 'Install-5401-MenuBuildinSubMenuSupport-HernanWilkinson-2022Jul23-19h50m-HAW.003.cs.st 9/14/2022 16:06:23'!
addGroupedMenuOptionsToMenu
	
	groups := items groupBy: [ :item | item at: #itemGroup ].
	groups keys asSortedCollection 
		do: [ :group | self addMenuOptionsOfGroup: group ]
		separatedBy: [ self addGroupSeparation ].
!

DynamicMenuBuilder removeSelector: #addGroupedMenuOptionsToMenu2!

DynamicMenuBuilder removeSelector: #addMenuOptionsOfGroup:to:with:!

DynamicMenuBuilder removeSelector: #addItemsOfGroup:to:with:!

DynamicMenuBuilder removeSelector: #addMenuOptionsOfGroup:!

!methodRemoval: DynamicMenuBuilder #addMenuOptionsOfGroup: stamp: 'Install-5401-MenuBuildinSubMenuSupport-HernanWilkinson-2022Jul23-19h50m-HAW.003.cs.st 9/14/2022 16:06:23'!
addMenuOptionsOfGroup: group

	| groupMenuOptions |
	
	groupMenuOptions := (groups at: group) asSortedCollection: [ :leftItem :rightItem | (leftItem at: #itemOrder) < (rightItem at: #itemOrder) ].
	menu addItemsFromDictionaries: groupMenuOptions.!

DynamicMenuBuilder removeSelector: #initializeSubmenusDefinition!

DynamicMenuBuilder removeSelector: #createMenu!

!methodRemoval: DynamicMenuBuilder #createMenu stamp: 'Install-5401-MenuBuildinSubMenuSupport-HernanWilkinson-2022Jul23-19h50m-HAW.003.cs.st 9/14/2022 16:06:23'!
createMenu

	menu := self hasTitle ifTrue: [ MenuMorph entitled: title] ifFalse: [ MenuMorph new ].
	menu defaultTarget: defaultTarget!

DynamicMenuBuilder removeSelector: #addGroupedItemsFrom:toMenu:with:!

DynamicMenuBuilder removeSelector: #build2!

DynamicMenuBuilder removeSelector: #addGroupedMenuOptions:toMenu:with:!

DynamicMenuBuilder removeSelector: #initializeSubmenuesDefinition!

DynamicMenuBuilder removeSelector: #addGroupSeparation!

!methodRemoval: DynamicMenuBuilder #addGroupSeparation stamp: 'Install-5401-MenuBuildinSubMenuSupport-HernanWilkinson-2022Jul23-19h50m-HAW.003.cs.st 9/14/2022 16:06:23'!
addGroupSeparation 

	menu addLine
	!

MenuMorph removeSelector: #addMenuItemFrom:targeting:!

MenuMorph removeSelector: #addItemsFromDictionaries:with:!

Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuDefinitionSelector rootMenu itemsDefinition optionsChanger subMenuItemsDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #DynamicMenuBuilder category: #'Morphic-Menus' stamp: 'Install-5401-MenuBuildinSubMenuSupport-HernanWilkinson-2022Jul23-19h50m-HAW.003.cs.st 9/14/2022 16:06:23'!
Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuDefinitionSelector rootMenu itemsDefinition optionsChanger subMenuItemsDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5401-MenuBuildinSubMenuSupport-HernanWilkinson-2022Jul23-19h50m-HAW.003.cs.st----!

'From Cuis 6.0 [latest update: #5401] on 28 July 2022 at 6:05:47 pm'!
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/28/2022 18:05:11' prior: 50408772!
                             addSubMenuTo: aMenuItem from: subMenuDefinition

	| subMenu |

	subMenu := MenuMorph new.
	subMenu defaultTarget: defaultTarget.
	"Add the menu items recursively to the parent menu item - Hernan"
	self addGroupedItemsFrom: subMenuDefinition toMenu: subMenu .
	aMenuItem subMenu: subMenu! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5402-KeepMenuTarget-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5400] on 29 July 2022 at 9:56:58 am'!
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 7/29/2022 09:56:38'!
refactoringsLabel

	^ 'refactorings'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5403-refatoringsLabel-HernanWilkinson-2022Jul29-09h55m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5401] on 28 July 2022 at 6:36:40 pm'!
!RefactoringMenues class methodsFor: 'editor menus' stamp: 'HAW 7/28/2022 18:35:08' prior: 50370880!
          smalltalkEditorMenuOptions

	^`{
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		10.
				#label 			-> 	RefactoringMenues refactoringsLabel.
				#selector 		-> 		#yourself.
				#icon 			-> 		#listAddIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Rename... (R)'.
				#selector 		-> 		#contextualRename.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Extract as Parameter... (1)'.
				#selector 		-> 		#contextualExtractAsParameter.
				#icon 			-> 		#listAddIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Add Parameter... (A)'.
				#selector 		-> 		#contextualAddParameter.
				#icon 			-> 		#listAddIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'Remove Parameter... (S)'.
				#selector 		-> 		#contextualRemoveParameter.
				#icon 			-> 		#listRemoveIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Extract Temporary... (J)'.
				#selector 		-> 		#extractToTemporary.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Extract Method... (K)'.
				#selector 		-> 		#extractMethod.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Inline Temporary... (2)'.
				#selector 		-> 		#inlineTemporaryVariable.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Inline Method... (3)'.
				#selector 		-> 		#contextualInlineMethod.
				#icon 			-> 		#saveAsIcon
		} asDictionary.		
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Temporary to Instance Variable (O)'.
				#selector 		-> 		#temporaryToInstanceVariable.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Push Up Instance Variable'.
				#selector 		-> 		#contextualPushUpInClassDefinition.
				#icon 			-> 		#goTopIcon
		} asDictionary.
		{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Push Down Instance Variable'.
				#selector 		-> 		#contextualPushDownInClassDefinition.
				#icon 			-> 		#goBottomIcon
		} asDictionary.
	
	}`! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 7/28/2022 18:12:44' prior: 16924175!
     classListMenuOptions

	^ `{
			{
				#itemGroup 	-> 		5.
				#itemOrder 		-> 		10.
				#label 			-> 	RefactoringMenues refactoringsLabel.
				#selector 		-> 		#yourself.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'insert superclass...'.
				#object 			-> 		#model.
				#selector 		-> 		#insertSuperclass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'safely remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#safelyRemoveClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'add inst var...'.
				#selector 		-> 		#addInstVar.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename inst var...'.
				#selector 		-> 		#renameInstVar.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove inst var...'.
				#selector 		-> 		#removeInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 			20.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove all unreferenced inst var...'.
				#selector 		-> 		#removeAllUnreferencedInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'push up inst var...'.
				#selector 		-> 		#pushUpInstanceVariable.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		60.
				#label 			-> 		'push down inst var...'.
				#selector 		-> 		#pushDownInstanceVariable.
				#icon 			-> 		#goBottomIcon
			} asDictionary.				
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 			30.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename global...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameGlobal.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
	}`.
	! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 7/28/2022 18:33:52' prior: 16924252!
                 messageListMenuOptions

	^ `{
			{
				#itemGroup 	-> 		5.
				#itemOrder 		-> 		10.
				#label 			-> 		RefactoringMenues refactoringsLabel.
				#selector 		-> 		#yourself.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		15.
				#label 			-> 		'change keyword order...'.
				#selector 		-> 		#changeKeywordOrder.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'inline method... (3)'.
				#selector 		-> 		#inlineMethod.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'move to instance/class method'.
				#selector 		-> 		#moveToInstanceOrClassMethod.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#submenuOf -> RefactoringMenues refactoringsLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'push down'.
				#selector 		-> 		#pushDownSelector.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
		}`.
	! !

RefactoringMenues class removeSelector: #smalltalkEditorRefactoringMenuOptions!

!methodRemoval: RefactoringMenues class #smalltalkEditorRefactoringMenuOptions stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
smalltalkEditorRefactoringMenuOptions

	^`{
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		30.
				#label 			-> 		'Add Parameter... (A)'.
				#selector 		-> 		#contextualAddParameter.
				#icon 			-> 		#listAddIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		35.
				#label 			-> 		'Extract as Parameter... (1)'.
				#selector 		-> 		#contextualExtractAsParameter.
				#icon 			-> 		#listAddIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		40.
				#label 			-> 		'Remove Parameter... (S)'.
				#selector 		-> 		#contextualRemoveParameter.
				#icon 			-> 		#listRemoveIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		50.
				#label 			-> 		'Temporary to Instance Variable (O)'.
				#selector 		-> 		#temporaryToInstanceVariable.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		60.
				#label 			-> 		'Push Up Instance Variable'.
				#selector 		-> 		#contextualPushUpInClassDefinition.
				#icon 			-> 		#goTopIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		70.
				#label 			-> 		'Push Down Instance Variable'.
				#selector 		-> 		#contextualPushDownInClassDefinition.
				#icon 			-> 		#goBottomIcon
		} asDictionary.
		{
				#itemGroup 		-> 		35.
				#itemOrder 		-> 		80.
				#label 			-> 		'Inline Method... (3)'.
				#selector 		-> 		#contextualInlineMethod.
				#icon 			-> 		#saveAsIcon
		} asDictionary.
	}`!

RefactoringMenues class removeSelector: #messageRefactoringMenuOptions!

!methodRemoval: RefactoringMenues class #messageRefactoringMenuOptions stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
messageRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		15.
				#label 			-> 		'change keyword order...'.
				#selector 		-> 		#changeKeywordOrder.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'push down'.
				#selector 		-> 		#pushDownSelector.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		60.
				#label 			-> 		'move to instance/class method'.
				#selector 		-> 		#moveToInstanceOrClassMethod.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		70.
				#label 			-> 		'inline method... (3)'.
				#selector 		-> 		#inlineMethod.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
	}`.

	!

RefactoringMenues class removeSelector: #classRefactoringMenuOptions!

!methodRemoval: RefactoringMenues class #classRefactoringMenuOptions stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
classRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'insert superclass...'.
				#object 			-> 		#model.
				#selector 		-> 		#insertSuperclass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'safely remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#safelyRemoveClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'add inst var...'.
				#selector 		-> 		#addInstVar.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename inst var...'.
				#selector 		-> 		#renameInstVar.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove inst var...'.
				#selector 		-> 		#removeInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 			20.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove all unreferenced inst var...'.
				#selector 		-> 		#removeAllUnreferencedInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'push up inst var...'.
				#selector 		-> 		#pushUpInstanceVariable.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		60.
				#label 			-> 		'push down inst var...'.
				#selector 		-> 		#pushDownInstanceVariable.
				#icon 			-> 		#goBottomIcon
			} asDictionary.				
			{
				#itemGroup 	-> 			30.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename global...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameGlobal.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
	}`.
	!

BrowserWindow removeSelector: #openMessageRefactoringMenu!

!methodRemoval: BrowserWindow #openMessageRefactoringMenu stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
openMessageRefactoringMenu

	^self messageRefactoringMenu popUpInWorld!

BrowserWindow removeSelector: #messageRefactoringMenu!

!methodRemoval: BrowserWindow #messageRefactoringMenu stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
messageRefactoringMenu

	^DynamicMenuBuilder buildTitled: 'Refactorings' targeting: self collectingMenuOptionsWith: #messageRefactoringMenuOptions.!

BrowserWindow removeSelector: #openClassRefactoringMenu!

!methodRemoval: BrowserWindow #openClassRefactoringMenu stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
openClassRefactoringMenu

	^self classRefactoringMenu popUpInWorld!

BrowserWindow removeSelector: #classRefactoringMenu!

!methodRemoval: BrowserWindow #classRefactoringMenu stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
classRefactoringMenu

	^DynamicMenuBuilder buildTitled: 'Refactorings' targeting: self collectingMenuOptionsWith: #classRefactoringMenuOptions.!

SmalltalkEditor removeSelector: #refactoringMenu!

!methodRemoval: SmalltalkEditor #refactoringMenu stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
refactoringMenu

	^DynamicMenuBuilder
		buildTitled: 'More refactorings'
		targeting: self
		collectingMenuOptionsWith: #smalltalkEditorRefactoringMenuOptions.!

SmalltalkEditor removeSelector: #openSmalltalkEditorRefactoringMenu!

!methodRemoval: SmalltalkEditor #openSmalltalkEditorRefactoringMenu stamp: 'Install-5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st 9/14/2022 16:06:23'!
openSmalltalkEditorRefactoringMenu

	^self refactoringMenu popUpInWorld!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5404-RefactoringSubMenus-HernanWilkinson-2022Jul28-18h05m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5403] on 29 July 2022 at 9:26:13 am'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/28/2022 18:41:30'!
                       openLabel

	^'Open'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5405-openLabel-HernanWilkinson-2022Jul29-09h25m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5401] on 28 July 2022 at 7:11:50 pm'!
!Workspace class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:44:56'!
                            worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		20.
			#label 			->			'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!Transcripter class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:45:56'!
 worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		30.
			#itemOrder 		-> 		20.
			#label 			->			'Emergency Evaluator'.
			#object 			-> 		Transcripter.
			#selector 		-> 		#emergencyEvaluator.
			#icon 			-> 		#emblemImportantIcon.
			#balloonText 	-> 		'When all else fails...'.
		} asDictionary}`! !
!TextEditor class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:46:17'!
 worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		10.
			#label 			->			'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:46:31'!
    worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->			'Installed Packages'.
			#object 			-> 		CodePackageListWindow.
			#selector 		-> 		#openPackageList.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:46:36'!
          worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		30.
			#label 			->			'Browser'.
			#object 			-> 		BrowserWindow.
			#selector 		-> 		#openBrowser.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:46:44' overrides: 50409718!
              worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		40.
			#label 			->			'Message Names'.
			#object 			-> 		MessageNamesWindow.
			#selector 		-> 		#openMessageNames.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:46:50'!
    worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		20.
			#label 			->			'Change Sorter'.
			#object 			-> 		ChangeSorterWindow.
			#selector 		-> 		#openChangeSorter.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:46:55'!
                           worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		10.
			#label 			->			'File List'.
			#object 			-> 		FileListWindow.
			#selector 		-> 		#openFileList.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary}`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:47:00'!
                           worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		30.
			#itemOrder 		-> 		10.
			#label 			->			'Process Browser'.
			#object 			-> 		ProcessBrowserWindow.
			#selector 		-> 		#openProcessBrowser.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:47:04'!
                               worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		20.
			#label 			->			'SUnit Test Runner'.
			#object 			-> 		TestRunnerWindow.
			#selector 		-> 		#openTestRunner.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary}`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'HAW 7/28/2022 18:47:07'!
                    worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 				-> 	10.
			#itemOrder 				-> 	50.
			#label 				->	'Transcript'.
			#object 				-> 	TranscriptWindow.
			#selector 				-> 	#openTranscript.
			#icon 				-> 	#printerIcon.
			#balloonText 				-> 	'A window showing contents of the System Transcript'.
		} asDictionary}`! !
!PackageInstallerWindow class methodsFor: 'as yet unclassified' stamp: 'HAW 7/28/2022 18:47:11'!
                             worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->	'Package Installer'.
			#object 			-> 	PackageInstallerWindow.
			#selector 		-> 		#open.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for installing local Cuis packages.'.
		} asDictionary}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/28/2022 19:10:17' prior: 16970533!
         worldMenuOptions

	^`{{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		10.
		#label 				-> 		TheWorldMenu openLabel.
		#selector 				-> 		#yourself.
		#icon 				-> 		#openIcon.
		#balloonText				-> 		'Submenu to open various system tools'.
	} asDictionary.
	{
		#submenuOf  				-> 		TheWorldMenu openLabel.
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		10.
		#label 				->		'Package Downloader'.
		#selector 				-> 		#openPackageDownloader.
		#icon 				-> 		#packageIcon.
		#balloonText 				-> 		'A tool for downloading Cuis packages from the internet.'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		20.
		#label 				-> 		'New morph...'.
		#selector				-> 		#newMorph.
		#icon 				-> 		#morphsIcon.
		#balloonText 				-> 		'Offers a variety of ways to create new objects'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		30.
		#label 				-> 		'Preferences...'.
		#selector 				-> 		#openPreferencesMenu.
		#icon 				-> 		#preferencesIcon.
		#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		40.
		#label 				-> 		'Windows...'.
		#selector 				-> 		#openWindowsMenu.
		#icon 				-> 		#windowIcon.
		#balloonText 				-> 		'Manage open windows'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		50.
		#label 				-> 		'Help...'.
		#selector 				-> 		#openHelpMenu.
		#icon 				-> 		#helpIcon.
		#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
	} asDictionary.
	{
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		10.
		#label 				-> 		'Changes...'.
		#selector 				-> 		#openChangesMenu.
		#icon 				-> 		#changesIcon.
		#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
	} asDictionary.
	{
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		20.
		#label 				-> 		'Debug...'.
		#selector 				-> 		#openDebugMenu.
		#icon 				-> 		#debugIcon.
		#balloonText 				-> 		'a menu of debugging items'.
	} asDictionary.
	{
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		30.
		#label 				-> 		'Restore Display'.
		#object 				-> 		#myWorld.
		#selector 				-> 		#restoreDisplay.
		#icon 				-> 		#displayIcon.
		#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		10.
		#label 				-> 		'Save Image'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveImage.
		#icon 				-> 		#saveIcon.
		#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		20.
		#label 				-> 		'Save Image as...'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveAs.
		#icon 				-> 		#saveAsIcon.
		#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		30.
		#label 				-> 		'Save Release and Quit'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveAsNewReleaseAndQuit.
		#icon 				-> 		#saveAsNewVersionIcon.
		#balloonText 				-> 		('Save as a new release of Cuis.\',
								'Clear all user preferences and user state (class vars).\',
								'Use an updated version-stamped name\',
								'and save the image with that name on disk.\',
								'Quit Cuis.') withNewLines.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		40.
		#label 				-> 		'Save Image and Quit'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveAndQuit.
		#icon 				-> 		#saveAndQuitIcon.
		#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		50.
		#label 				-> 		'Quit without saving'.
		#selector 				-> 		#quitSession.
		#icon 				-> 		#quitIcon.
		#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
								'Ask for confirmation if there are unsaved changes.') withNewLines.
	} asDictionary.
}`! !

TheWorldMenu class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: TheWorldMenu class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->	'Package Downloader'.
			#selector 		-> 		#openPackageDownloader.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for downloading Cuis packages from the internet.'.
		} asDictionary}`!

TheWorldMenu removeSelector: #openLabel!

TheWorldMenu removeSelector: #openMenu!

!methodRemoval: TheWorldMenu #openMenu stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
openMenu
	"Build the open window menu for the world."

	^(DynamicMenuBuilder buildTitled: 'Open...' targeting: self collectingMenuOptionsWith: #worldMenuForOpenGroup) 
		addStayUpIcons;
		yourself
	!

TheWorldMenu removeSelector: #openOpenMenu!

!methodRemoval: TheWorldMenu #openOpenMenu stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
openOpenMenu

	self doPopUp: self openMenu!

PackageInstallerWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: PackageInstallerWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->	'Package Installer'.
			#object 			-> 	PackageInstallerWindow.
			#selector 		-> 		#open.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for installing local Cuis packages.'.
		} asDictionary}`!

TranscriptWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: TranscriptWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 				-> 	10.
			#itemOrder 				-> 	50.
			#label 				->	'Transcript'.
			#object 				-> 	TranscriptWindow.
			#selector 				-> 	#openTranscript.
			#icon 				-> 	#printerIcon.
			#balloonText 				-> 	'A window showing contents of the System Transcript'.
		} asDictionary}`!

TestRunnerWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: TestRunnerWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		20.
			#label 			->			'SUnit Test Runner'.
			#object 			-> 		TestRunnerWindow.
			#selector 		-> 		#openTestRunner.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary}`!

ProcessBrowserWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: ProcessBrowserWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		30.
			#itemOrder 		-> 		10.
			#label 			->			'Process Browser'.
			#object 			-> 		ProcessBrowserWindow.
			#selector 		-> 		#openProcessBrowser.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`!

FileListWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: FileListWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		10.
			#label 			->			'File List'.
			#object 			-> 		FileListWindow.
			#selector 		-> 		#openFileList.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary}`!

ChangeSorterWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: ChangeSorterWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		20.
			#label 			->			'Change Sorter'.
			#object 			-> 		ChangeSorterWindow.
			#selector 		-> 		#openChangeSorter.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`!

MessageNamesWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: MessageNamesWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		40.
			#label 			->			'Message Names'.
			#object 			-> 		MessageNamesWindow.
			#selector 		-> 		#openMessageNames.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`!

BrowserWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: BrowserWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		30.
			#label 			->			'Browser'.
			#object 			-> 		BrowserWindow.
			#selector 		-> 		#openBrowser.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`!

CodePackageListWindow class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: CodePackageListWindow class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->			'Installed Packages'.
			#object 			-> 		CodePackageListWindow.
			#selector 		-> 		#openPackageList.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`!

TextEditor class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: TextEditor class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		10.
			#label 			->			'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`!

Transcripter class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: Transcripter class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		30.
			#itemOrder 		-> 		20.
			#label 			->			'Emergency Evaluator'.
			#object 			-> 		Transcripter.
			#selector 		-> 		#emergencyEvaluator.
			#icon 			-> 		#emblemImportantIcon.
			#balloonText 	-> 		'When all else fails...'.
		} asDictionary}`!

Workspace class removeSelector: #worldMenuForOpenGroup!

!methodRemoval: Workspace class #worldMenuForOpenGroup stamp: 'Install-5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st 9/14/2022 16:06:23'!
worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		20.
			#label 			->			'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5406-WorldOpenMenuAsSubMenu-HernanWilkinson-2022Jul28-18h36m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5400] on 29 July 2022 at 10:00:00 am'!
!PreferenceSet class methodsFor: 'services' stamp: 'HAW 7/29/2022 09:51:32'!
           openPreferencesInspector
	"Open a window on the current set of preferences choices, allowing the user to view and change their settings"
	Preferences openPreferencesInspector! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5407-openPreferencesInspector-HernanWilkinson-2022Jul29-09h56m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5405] on 29 July 2022 at 9:34:39 am'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/28/2022 19:16:05'!
            preferencesLabel

	^'Preferences'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5408-preferencesLabel-HernanWilkinson-2022Jul29-09h34m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5401] on 28 July 2022 at 7:27:09 pm'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/28/2022 19:24:51'!
 preferencesMenuOptions

	^`{
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Focus follows mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Click to focus'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'Use Unicode text'.
				#object 			-> 		TextModel.
				#selector 			-> 		#useUtf8Editors.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load the VectorGraphics package, use TrueType fonts, and Unicode text.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		40.
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		50.
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		60.
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#readAdditionalTrueTypeFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		70.
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		80.
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'All preferences...'.
				#object 			-> 		PreferenceSet.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`	
	! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/28/2022 19:25:14' prior: 50409836!
        worldMenuOptions

	^`{{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		10.
		#label 				-> 		TheWorldMenu openLabel.
		#selector 				-> 		#yourself.
		#icon 				-> 		#openIcon.
		#balloonText				-> 		'Submenu to open various system tools'.
	} asDictionary.
	{
		#submenuOf  				-> 		TheWorldMenu openLabel.
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		10.
		#label 				->		'Package Downloader'.
		#selector 				-> 		#openPackageDownloader.
		#icon 				-> 		#packageIcon.
		#balloonText 				-> 		'A tool for downloading Cuis packages from the internet.'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		20.
		#label 				-> 		'New morph...'.
		#selector				-> 		#newMorph.
		#icon 				-> 		#morphsIcon.
		#balloonText 				-> 		'Offers a variety of ways to create new objects'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		30.
		#label 				-> 		TheWorldMenu preferencesLabel.
		#selector 				-> 		#yourself.
		#icon 				-> 		#preferencesIcon.
		#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		40.
		#label 				-> 		'Windows...'.
		#selector 				-> 		#openWindowsMenu.
		#icon 				-> 		#windowIcon.
		#balloonText 				-> 		'Manage open windows'.
	} asDictionary.
	{
		#itemGroup 				-> 		10.
		#itemOrder 				-> 		50.
		#label 				-> 		'Help...'.
		#selector 				-> 		#openHelpMenu.
		#icon 				-> 		#helpIcon.
		#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
	} asDictionary.
	{
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		10.
		#label 				-> 		'Changes...'.
		#selector 				-> 		#openChangesMenu.
		#icon 				-> 		#changesIcon.
		#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
	} asDictionary.
	{
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		20.
		#label 				-> 		'Debug...'.
		#selector 				-> 		#openDebugMenu.
		#icon 				-> 		#debugIcon.
		#balloonText 				-> 		'a menu of debugging items'.
	} asDictionary.
	{
		#itemGroup 				-> 		20.
		#itemOrder 				-> 		30.
		#label 				-> 		'Restore Display'.
		#object 				-> 		#myWorld.
		#selector 				-> 		#restoreDisplay.
		#icon 				-> 		#displayIcon.
		#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		10.
		#label 				-> 		'Save Image'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveImage.
		#icon 				-> 		#saveIcon.
		#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		20.
		#label 				-> 		'Save Image as...'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveAs.
		#icon 				-> 		#saveAsIcon.
		#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		30.
		#label 				-> 		'Save Release and Quit'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveAsNewReleaseAndQuit.
		#icon 				-> 		#saveAsNewVersionIcon.
		#balloonText 				-> 		('Save as a new release of Cuis.\',
								'Clear all user preferences and user state (class vars).\',
								'Use an updated version-stamped name\',
								'and save the image with that name on disk.\',
								'Quit Cuis.') withNewLines.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		40.
		#label 				-> 		'Save Image and Quit'.
		#object 				-> 		Smalltalk.
		#selector 				-> 		#saveAndQuit.
		#icon 				-> 		#saveAndQuitIcon.
		#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
	} asDictionary.
	{
		#itemGroup 				-> 		30.
		#itemOrder 				-> 		50.
		#label 				-> 		'Quit without saving'.
		#selector 				-> 		#quitSession.
		#icon 				-> 		#quitIcon.
		#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
								'Ask for confirmation if there are unsaved changes.') withNewLines.
	} asDictionary.
}, TheWorldMenu preferencesMenuOptions`! !

TheWorldMenu removeSelector: #openPreferencesMenu!

!methodRemoval: TheWorldMenu #openPreferencesMenu stamp: 'Install-5409-PreferenceAsSubMenu-HernanWilkinson-2022Jul28-19h11m-HAW.001.cs.st 9/14/2022 16:06:23'!
openPreferencesMenu
	"Build and show the preferences menu for the world."

	self doPopUp: self preferencesMenu!

TheWorldMenu removeSelector: #preferencesMenu!

!methodRemoval: TheWorldMenu #preferencesMenu stamp: 'Install-5409-PreferenceAsSubMenu-HernanWilkinson-2022Jul28-19h11m-HAW.001.cs.st 9/14/2022 16:06:23'!
preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: {
			{
				#label 			-> 		'Focus follows mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Use Unicode text'.
				#object 			-> 		TextModel.
				#selector 			-> 		#useUtf8Editors.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load the VectorGraphics package, use TrueType fonts, and Unicode text.'
			} asDictionary.
			{
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#readAdditionalTrueTypeFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5409-PreferenceAsSubMenu-HernanWilkinson-2022Jul28-19h11m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5409] on 29 July 2022 at 10:24:00 am'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 10:22:25'!
   additionalMenuOptions

	^`{
		{
			#submenuOf  				-> 		TheWorldMenu openLabel.
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		10.
			#label 				->		'Package Downloader'.
			#selector 				-> 		#openPackageDownloader.
			#icon 				-> 		#packageIcon.
			#balloonText 				-> 		'A tool for downloading Cuis packages from the internet.'.
		} asDictionary.
	
	}`	
	! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 10:23:26'!
 worldMainMenuOptions

	^`{
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu openLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#openIcon.
			#balloonText				-> 		'Submenu to open various system tools'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		20.
			#label 				-> 		'New morph...'.
			#selector				-> 		#newMorph.
			#icon 				-> 		#morphsIcon.
			#balloonText 				-> 		'Offers a variety of ways to create new objects'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		30.
			#label 				-> 		TheWorldMenu preferencesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#preferencesIcon.
			#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		40.
			#label 				-> 		'Windows...'.
			#selector 				-> 		#openWindowsMenu.
			#icon 				-> 		#windowIcon.
			#balloonText 				-> 		'Manage open windows'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		50.
			#label 				-> 		'Help...'.
			#selector 				-> 		#openHelpMenu.
			#icon 				-> 		#helpIcon.
			#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		10.
			#label 				-> 		'Changes...'.
			#selector 				-> 		#openChangesMenu.
			#icon 				-> 		#changesIcon.
			#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		20.
			#label 				-> 		'Debug...'.
			#selector 				-> 		#openDebugMenu.
			#icon 				-> 		#debugIcon.
			#balloonText 				-> 		'a menu of debugging items'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				-> 		'Restore Display'.
			#object 				-> 		#myWorld.
			#selector 				-> 		#restoreDisplay.
			#icon 				-> 		#displayIcon.
			#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		10.
			#label 				-> 		'Save Image'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveImage.
			#icon 				-> 		#saveIcon.
			#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		20.
			#label 				-> 		'Save Image as...'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAs.
			#icon 				-> 		#saveAsIcon.
			#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		30.
			#label 				-> 		'Save Release and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAsNewReleaseAndQuit.
			#icon 				-> 		#saveAsNewVersionIcon.
			#balloonText 				-> 		('Save as a new release of Cuis.\',
									'Clear all user preferences and user state (class vars).\',
									'Use an updated version-stamped name\',
									'and save the image with that name on disk.\',
									'Quit Cuis.') withNewLines.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		40.
			#label 				-> 		'Save Image and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAndQuit.
			#icon 				-> 		#saveAndQuitIcon.
			#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		50.
			#label 				-> 		'Quit without saving'.
			#selector 				-> 		#quitSession.
			#icon 				-> 		#quitIcon.
			#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
									'Ask for confirmation if there are unsaved changes.') withNewLines.
		} asDictionary.
	}`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5410-Refactor-HernanWilkinson-2022Jul29-10h22m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5409] on 29 July 2022 at 10:24:22 am'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 10:16:19' prior: 50410404!
        worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5411-Refactor-HernanWilkinson-2022Jul29-10h24m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5411] on 29 July 2022 at 3:30:32 pm'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 15:24:16'!
   windowsLabel

	^'Windows'! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 15:28:20'!
                  windowsMenuOptions

	^`{
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Tile open windows'.
				#object          ->       					TileResizeMorph.
				#selector 			-> 		#tileOpenWindows.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Tile open windows'.
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		60.
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Delete Both of the Above'.
				#selector 			-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 15:29:27' prior: 50410682!
              worldMainMenuOptions

	^`{
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu openLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#openIcon.
			#balloonText				-> 		'Submenu to open various system tools'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		20.
			#label 				-> 		'New morph...'.
			#selector				-> 		#newMorph.
			#icon 				-> 		#morphsIcon.
			#balloonText 				-> 		'Offers a variety of ways to create new objects'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		30.
			#label 				-> 		TheWorldMenu preferencesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#preferencesIcon.
			#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		40.
			#label 				-> 		TheWorldMenu windowsLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#windowIcon.
			#balloonText 				-> 		'Manage open windows'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		50.
			#label 				-> 		'Help...'.
			#selector 				-> 		#openHelpMenu.
			#icon 				-> 		#helpIcon.
			#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		10.
			#label 				-> 		'Changes...'.
			#selector 				-> 		#openChangesMenu.
			#icon 				-> 		#changesIcon.
			#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		20.
			#label 				-> 		'Debug...'.
			#selector 				-> 		#openDebugMenu.
			#icon 				-> 		#debugIcon.
			#balloonText 				-> 		'a menu of debugging items'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				-> 		'Restore Display'.
			#object 				-> 		#myWorld.
			#selector 				-> 		#restoreDisplay.
			#icon 				-> 		#displayIcon.
			#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		10.
			#label 				-> 		'Save Image'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveImage.
			#icon 				-> 		#saveIcon.
			#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		20.
			#label 				-> 		'Save Image as...'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAs.
			#icon 				-> 		#saveAsIcon.
			#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		30.
			#label 				-> 		'Save Release and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAsNewReleaseAndQuit.
			#icon 				-> 		#saveAsNewVersionIcon.
			#balloonText 				-> 		('Save as a new release of Cuis.\',
									'Clear all user preferences and user state (class vars).\',
									'Use an updated version-stamped name\',
									'and save the image with that name on disk.\',
									'Quit Cuis.') withNewLines.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		40.
			#label 				-> 		'Save Image and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAndQuit.
			#icon 				-> 		#saveAndQuitIcon.
			#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		50.
			#label 				-> 		'Quit without saving'.
			#selector 				-> 		#quitSession.
			#icon 				-> 		#quitIcon.
			#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
									'Ask for confirmation if there are unsaved changes.') withNewLines.
		} asDictionary.
	}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 15:28:40' prior: 50410815!
    worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions`! !

TheWorldMenu removeSelector: #openWindowsMenu!

!methodRemoval: TheWorldMenu #openWindowsMenu stamp: 'Install-5412-WIndowsSubMenu-HernanWilkinson-2022Jul29-15h23m-HAW.001.cs.st 9/14/2022 16:06:23'!
openWindowsMenu
	"Build the windows menu for the world."

	self doPopUp: self windowsMenu!

TheWorldMenu removeSelector: #windowsMenu!

!methodRemoval: TheWorldMenu #windowsMenu stamp: 'Install-5412-WIndowsSubMenu-HernanWilkinson-2022Jul29-15h23m-HAW.001.cs.st 9/14/2022 16:06:23'!
windowsMenu
        "Build the windows menu for the world."

	^ (self menu: 'Windows')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Tile open windows'.
				#object          ->       					TileResizeMorph.
				#selector 			-> 		#tileOpenWindows.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Tile open windows'.
			} asDictionary.
			{
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#label 			-> 		'Delete Both of the Above'.
				#selector 			-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'
			} asDictionary.
		}`!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5412-WIndowsSubMenu-HernanWilkinson-2022Jul29-15h23m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5411] on 29 July 2022 at 4:23:33 pm'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 16:19:31'!
                     helpLabel

	^'Help'! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 16:21:32' prior: 50336088!
        helpMenuOptions
	
	^ `{
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#aboutThisSystem.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'current version information.'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Terse Guide to Cuis'.
				#selector 		-> 		#openTerseGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comment Browser'.
				#selector 		-> 		#openCommentGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCodeManagementInCuis.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCuisAndGitHub.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'GitHub usage pattern.'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 	-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 	-> 		'a window full of useful expressions.'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'VM Statistics'.
				#selector 		-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 	-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#submenuOf -> TheWorldMenu helpLabel.
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Space Left'.
				#selector 		-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 	-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 16:22:30' prior: 50411027!
                            worldMainMenuOptions

	^`{
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu openLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#openIcon.
			#balloonText				-> 		'Submenu to open various system tools'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		20.
			#label 				-> 		'New morph...'.
			#selector				-> 		#newMorph.
			#icon 				-> 		#morphsIcon.
			#balloonText 				-> 		'Offers a variety of ways to create new objects'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		30.
			#label 				-> 		TheWorldMenu preferencesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#preferencesIcon.
			#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		40.
			#label 				-> 		TheWorldMenu windowsLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#windowIcon.
			#balloonText 				-> 		'Manage open windows'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		50.
			#label 				-> 		TheWorldMenu helpLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#helpIcon.
			#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		10.
			#label 				-> 		'Changes...'.
			#selector 				-> 		#openChangesMenu.
			#icon 				-> 		#changesIcon.
			#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		20.
			#label 				-> 		'Debug...'.
			#selector 				-> 		#openDebugMenu.
			#icon 				-> 		#debugIcon.
			#balloonText 				-> 		'a menu of debugging items'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				-> 		'Restore Display'.
			#object 				-> 		#myWorld.
			#selector 				-> 		#restoreDisplay.
			#icon 				-> 		#displayIcon.
			#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		10.
			#label 				-> 		'Save Image'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveImage.
			#icon 				-> 		#saveIcon.
			#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		20.
			#label 				-> 		'Save Image as...'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAs.
			#icon 				-> 		#saveAsIcon.
			#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		30.
			#label 				-> 		'Save Release and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAsNewReleaseAndQuit.
			#icon 				-> 		#saveAsNewVersionIcon.
			#balloonText 				-> 		('Save as a new release of Cuis.\',
									'Clear all user preferences and user state (class vars).\',
									'Use an updated version-stamped name\',
									'and save the image with that name on disk.\',
									'Quit Cuis.') withNewLines.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		40.
			#label 				-> 		'Save Image and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAndQuit.
			#icon 				-> 		#saveAndQuitIcon.
			#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		50.
			#label 				-> 		'Quit without saving'.
			#selector 				-> 		#quitSession.
			#icon 				-> 		#quitIcon.
			#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
									'Ask for confirmation if there are unsaved changes.') withNewLines.
		} asDictionary.
	}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 16:21:43' prior: 50411153!
                           worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions,
		TheWorldMenu helpMenuOptions`! !

TheWorldMenu removeSelector: #helpMenu!

!methodRemoval: TheWorldMenu #helpMenu stamp: 'Install-5413-HelpSubMenu-HernanWilkinson-2022Jul29-15h30m-HAW.001.cs.st 9/14/2022 16:06:23'!
helpMenu
	"Build the help menu for the world."

	^ DynamicMenuBuilder buildTitled: 'Help...' targeting: self collectingMenuOptionsWith: #helpMenuOptions.
!

TheWorldMenu removeSelector: #openHelpMenu!

!methodRemoval: TheWorldMenu #openHelpMenu stamp: 'Install-5413-HelpSubMenu-HernanWilkinson-2022Jul29-15h30m-HAW.001.cs.st 9/14/2022 16:06:23'!
openHelpMenu
	"Build and show the help menu for the world."

	self doPopUp: self helpMenu!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5413-HelpSubMenu-HernanWilkinson-2022Jul29-15h30m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5411] on 29 July 2022 at 5:23:54 pm'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 16:24:37'!
                  changesLabel

	^'Changes'! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 17:22:32'!
                  changesMenuOptions

	^`{
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Change Sorter'.
				#object 			-> 		ChangeSorterWindow.
				#selector 		-> 		#openChangeSorter.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Install New Updates'.
				#object 			-> 		ChangeSet.
				#selector 		-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Browse my Changes'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Recently logged Changes...'.
				#object 			-> 		ChangeList.
				#selector 		-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Save World as morph file'.
				#selector 		-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 17:23:08' prior: 50411424!
                  worldMainMenuOptions

	^`{
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu openLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#openIcon.
			#balloonText				-> 		'Submenu to open various system tools'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		20.
			#label 				-> 		'New morph...'.
			#selector				-> 		#newMorph.
			#icon 				-> 		#morphsIcon.
			#balloonText 				-> 		'Offers a variety of ways to create new objects'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		30.
			#label 				-> 		TheWorldMenu preferencesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#preferencesIcon.
			#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		40.
			#label 				-> 		TheWorldMenu windowsLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#windowIcon.
			#balloonText 				-> 		'Manage open windows'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		50.
			#label 				-> 		TheWorldMenu helpLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#helpIcon.
			#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu changesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#changesIcon.
			#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		20.
			#label 				-> 		'Debug...'.
			#selector 				-> 		#openDebugMenu.
			#icon 				-> 		#debugIcon.
			#balloonText 				-> 		'a menu of debugging items'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				-> 		'Restore Display'.
			#object 				-> 		#myWorld.
			#selector 				-> 		#restoreDisplay.
			#icon 				-> 		#displayIcon.
			#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		10.
			#label 				-> 		'Save Image'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveImage.
			#icon 				-> 		#saveIcon.
			#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		20.
			#label 				-> 		'Save Image as...'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAs.
			#icon 				-> 		#saveAsIcon.
			#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		30.
			#label 				-> 		'Save Release and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAsNewReleaseAndQuit.
			#icon 				-> 		#saveAsNewVersionIcon.
			#balloonText 				-> 		('Save as a new release of Cuis.\',
									'Clear all user preferences and user state (class vars).\',
									'Use an updated version-stamped name\',
									'and save the image with that name on disk.\',
									'Quit Cuis.') withNewLines.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		40.
			#label 				-> 		'Save Image and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAndQuit.
			#icon 				-> 		#saveAndQuitIcon.
			#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		50.
			#label 				-> 		'Quit without saving'.
			#selector 				-> 		#quitSession.
			#icon 				-> 		#quitIcon.
			#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
									'Ask for confirmation if there are unsaved changes.') withNewLines.
		} asDictionary.
	}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 17:23:21' prior: 50411551!
                     worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions,
		TheWorldMenu helpMenuOptions,
		TheWorldMenu changesMenuOptions`! !

TheWorldMenu removeSelector: #changesMenu!

!methodRemoval: TheWorldMenu #changesMenu stamp: 'Install-5414-ChangesSubMenu-HernanWilkinson-2022Jul29-16h23m-HAW.001.cs.st 9/14/2022 16:06:23'!
changesMenu
        "Build the changes menu for the world."

	^ (self menu: 'Changes...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Change Sorter'.
				#object 			-> 		ChangeSorterWindow.
				#selector 		-> 		#openChangeSorter.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Install New Updates'.
				#object 			-> 		ChangeSet.
				#selector 		-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Browse my Changes'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#label 			-> 		'Recently logged Changes...'.
				#object 			-> 		ChangeList.
				#selector 		-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Save World as morph file'.
				#selector 		-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`!

TheWorldMenu removeSelector: #openChangesMenu!

!methodRemoval: TheWorldMenu #openChangesMenu stamp: 'Install-5414-ChangesSubMenu-HernanWilkinson-2022Jul29-16h23m-HAW.001.cs.st 9/14/2022 16:06:23'!
openChangesMenu
	"Build the changes menu for the world."

	self doPopUp: self changesMenu!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5414-ChangesSubMenu-HernanWilkinson-2022Jul29-16h23m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5411] on 29 July 2022 at 5:28:23 pm'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 17:24:24'!
                 debugLabel

	^'Debug'! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 17:27:05'!
                      debugMenuOptions

	^`{
			{
				#submenuOf  ->					TheWorldMenu debugLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#inspect.
				#icon 			-> 		#inspectIcon.
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu debugLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#explore.
				#icon 			-> 		#exploreIcon.
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu debugLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'MessageTally all Processes'.
				#selector 			-> 		#startMessageTally.
				#icon 			-> 		#systemMonitorIcon.
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu debugLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#removeAllKnownFailing.
				#icon 			-> 		#graphicsIcon.
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu debugLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#resumeAfterStepError.
				#icon 			-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#submenuOf  ->					TheWorldMenu debugLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 			-> 		#closeAllDebuggers.
				#icon 			-> 		#closeIcon.
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 17:27:50' prior: 50411658!
                     worldMainMenuOptions

	^`{
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu openLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#openIcon.
			#balloonText				-> 		'Submenu to open various system tools'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		20.
			#label 				-> 		'New morph...'.
			#selector				-> 		#newMorph.
			#icon 				-> 		#morphsIcon.
			#balloonText 				-> 		'Offers a variety of ways to create new objects'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		30.
			#label 				-> 		TheWorldMenu preferencesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#preferencesIcon.
			#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		40.
			#label 				-> 		TheWorldMenu windowsLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#windowIcon.
			#balloonText 				-> 		'Manage open windows'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		50.
			#label 				-> 		TheWorldMenu helpLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#helpIcon.
			#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu changesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#changesIcon.
			#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		20.
			#label 				-> 		TheWorldMenu debugLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#debugIcon.
			#balloonText 				-> 		'a menu of debugging items'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				-> 		'Restore Display'.
			#object 				-> 		#myWorld.
			#selector 				-> 		#restoreDisplay.
			#icon 				-> 		#displayIcon.
			#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		10.
			#label 				-> 		'Save Image'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveImage.
			#icon 				-> 		#saveIcon.
			#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		20.
			#label 				-> 		'Save Image as...'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAs.
			#icon 				-> 		#saveAsIcon.
			#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		30.
			#label 				-> 		'Save Release and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAsNewReleaseAndQuit.
			#icon 				-> 		#saveAsNewVersionIcon.
			#balloonText 				-> 		('Save as a new release of Cuis.\',
									'Clear all user preferences and user state (class vars).\',
									'Use an updated version-stamped name\',
									'and save the image with that name on disk.\',
									'Quit Cuis.') withNewLines.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		40.
			#label 				-> 		'Save Image and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAndQuit.
			#icon 				-> 		#saveAndQuitIcon.
			#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		50.
			#label 				-> 		'Quit without saving'.
			#selector 				-> 		#quitSession.
			#icon 				-> 		#quitIcon.
			#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
									'Ask for confirmation if there are unsaved changes.') withNewLines.
		} asDictionary.
	}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/29/2022 17:27:19' prior: 50411785!
             worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions,
		TheWorldMenu helpMenuOptions,
		TheWorldMenu changesMenuOptions,
		TheWorldMenu debugMenuOptions `! !

TheWorldMenu removeSelector: #openDebugMenu!

!methodRemoval: TheWorldMenu #openDebugMenu stamp: 'Install-5415-DebugSubMenu-HernanWilkinson-2022Jul29-17h23m-HAW.001.cs.st 9/14/2022 16:06:23'!
openDebugMenu

	self doPopUp: self debugMenu!

TheWorldMenu removeSelector: #debugMenu!

!methodRemoval: TheWorldMenu #debugMenu stamp: 'Install-5415-DebugSubMenu-HernanWilkinson-2022Jul29-17h23m-HAW.001.cs.st 9/14/2022 16:06:23'!
debugMenu

	^ (self menu: 'Debug...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#inspect.
				#icon 			-> 		#inspectIcon.
			} asDictionary.
			{
				#label 			-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#explore.
				#icon 			-> 		#exploreIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally all Processes'.
				#selector 		-> 		#startMessageTally.
				#icon 			-> 		#systemMonitorIcon.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#removeAllKnownFailing.
				#icon 			-> 		#graphicsIcon.
			} asDictionary.
			{
				#label 			-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#resumeAfterStepError.
				#icon 			-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#label 			-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 		-> 		#closeAllDebuggers.
				#icon 			-> 		#closeIcon.
			} asDictionary.
		}`!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5415-DebugSubMenu-HernanWilkinson-2022Jul29-17h23m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5415] on 1 August 2022 at 5:52:23 pm'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 17:40:56' prior: 16838960!
                     interruptProcess: aProcess label: labelString
	"Create a Notifier on aProcess with the given label.
	This method is called only in special system processes, like the #userInterruptWatcher and the #lowSpaceWatcher."
	|  label |

	label _ labelString,
					' - Process: ', aProcess name,
					' - Priority: ', aProcess priority printString.
	aProcess isTerminated
		ifTrue: [
			UISupervisor newProcessIfUI: aProcess.
			self notify: 'Can not debug a terminated process: ', label ]
		ifFalse: [
			aProcess suspend.
			self
				openInterrupt: label 
				onProcess: aProcess ]! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 17:51:19' prior: 50406866!
         openOn: process context: context label: title fullView: bool guiRootObject: guiRootObject
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new.
		debugger 	process: process context: context.
		debugger interruptedProcessUI: guiRootObject.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 8/1/2022 17:27:55' prior: 50404464!
                       handleUserInterrupt
	| processToInterrupt |
	"If the UI process is not ready to run, the UI was not responsive, and most likely that's why the user pressed
	the interrupt key. Make GUI responsive again, and let them debug the process that made UI not responsive."
	processToInterrupt _ UISupervisor newUIProcessIfNeeded.
	processToInterrupt ifNil: [
		"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
		processToInterrupt _ Sensor shiftPressed | (Preferences at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preferences at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		processToInterrupt == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(processToInterrupt name beginsWith: '[system]') ifTrue: [
			 ('Process {', processToInterrupt printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			processToInterrupt isTerminated
				ifTrue: [ ('Process {', processToInterrupt printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ Debugger interruptProcess: processToInterrupt label: 'User Interrupt' ]] fork
		].! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/1/2022 17:49:11' prior: 16939400!
debug: aCompiledMethod receiver: anObject in: evalContext

	| processToDebug debugger |
	debugger _ Debugger new.
	processToDebug _ [
		aCompiledMethod
			valueWithReceiver: anObject
			arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ]).
		debugger sendProceeds.
	] newProcess name: 'debugIt'.
	debugger process: processToDebug context: processToDebug suspendedContext.
	debugger openFullMorphicLabel: 'Debug it'.
	[debugger interruptedContext method == aCompiledMethod]
		whileFalse: [debugger send]! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 8/1/2022 17:25:10' prior: 50407788!
                       newProcessIfUI: processBeingSuspended
	"processBeingSuspended has been suspended or is about to be.
	Answer the UI we created a new process for."

	processBeingSuspended == UIProcess ifTrue: [
		self spawnNewMorphicProcessFor: UI.
		^UI ].
	^nil
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"! !
!TestCase methodsFor: 'debugging - private' stamp: 'jmv 8/1/2022 17:49:07' prior: 16961745!
            openDebuggerOnFailingTestMethod

	| processToDebug compiledMethod debugger |

	compiledMethod _ self methodForTest.
	
	processToDebug _ [ [ self performTest ] ensure: [
		self tearDown.
		self tearDownResources]] newProcess name: 'debugIt'.
	
	debugger _ Debugger new
		process: processToDebug 
		context: processToDebug suspendedContext.
	debugger openFullMorphicLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod] whileFalse: [debugger send].
! !

UISupervisor class removeSelector: #userInterrupt:!

!methodRemoval: UISupervisor class #userInterrupt: stamp: 'Install-5416-Debugger-cleanup-JuanVuletich-2022Aug01-17h18m-jmv.001.cs.st 9/14/2022 16:06:23'!
userInterrupt: aProcess
	"Open a debugger."

	Debugger interruptProcess: aProcess label: 'User Interrupt'.!

Debugger removeSelector: #openFullNoSuspendLabel:!

!methodRemoval: Debugger #openFullNoSuspendLabel: stamp: 'Install-5416-Debugger-cleanup-JuanVuletich-2022Aug01-17h18m-jmv.001.cs.st 9/14/2022 16:06:23'!
openFullNoSuspendLabel: aString
	"Create and schedule a full debugger with the given label. Do not terminate the current active process."

	self openFullMorphicLabel: aString.
	interruptedProcessUI _ UISupervisor newProcessIfUI: interruptedProcess!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5416-Debugger-cleanup-JuanVuletich-2022Aug01-17h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5415] on 1 August 2022 at 5:58:06 pm'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 17:54:08' prior: 50406943!
           openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| guiRootObjectOrNil |
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	guiRootObjectOrNil _ UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		self openOn: process context: context label: title fullView: bool guiRootObject: guiRootObjectOrNil
		].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfNeeded.
	] fork.
	process suspend.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 17:54:15' prior: 50412142!
                openOn: process context: context label: title fullView: bool guiRootObject: guiRootObjectOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new.
		debugger 	process: process context: context.
		debugger interruptedProcessUI: guiRootObjectOrNil.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5417-Debugger-Cleanup-JuanVuletich-2022Aug01-17h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5415] on 1 August 2022 at 6:04:27 pm'!

CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC savedCursor labelString interruptedProcessUI sendProceeds '
	classVariableNames: 'ErrorRecursion '
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!classDefinition: #Debugger category: #'Tools-Debugger' stamp: 'Install-5418-Debugger-Cleanup-JuanVuletich-2022Aug01-17h58m-jmv.001.cs.st 9/14/2022 16:06:23'!
CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC savedCursor labelString interruptedProcessUI sendProceeds'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!
!Debugger methodsFor: 'code pane' stamp: 'jmv 8/1/2022 18:02:01' prior: 16838037!
                               pcRange
	"Answer the indices in the source code for the method corresponding to 
	the selected context's program counter value."

	contextStackIndex = 0 ifTrue:
		[^1 to: 0].
	self selectedContext isDead ifTrue:
		[^1 to: 0].
	^self selectedContext debuggerMap
		rangeForPC: self selectedContext pc
		contextIsActiveContext: contextStackIndex = 1! !
!Debugger methodsFor: 'context stack (message list)' stamp: 'jmv 8/1/2022 18:00:02' prior: 16838082!
                             expandStack
	"A Notifier is being turned into a full debugger.  Show a substantial amount of stack in the context pane."

	self newStack: (contextStackTop stackOfSize: Debugger defaultDebugStackSize).
	contextStackIndex _ 0.
	receiverInspector _ Inspector inspect: nil.
	contextVariablesInspector _ ContextVariablesInspector inspect: nil.! !
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 8/1/2022 18:02:15' prior: 16838347!
               where
	"Select the expression whose evaluation was interrupted."

	self contextStackIndex: contextStackIndex oldContextWas: self selectedContext
! !
!Debugger methodsFor: 'private' stamp: 'jmv 8/1/2022 18:02:10' prior: 16838791!
                           process: aProcess context: aContext

	interruptedProcess _ aProcess.
	contextStackTop _ aContext.
	self newStack: (contextStackTop stackOfSize: 1).
	contextStackIndex _ 1.! !
!Debugger class methodsFor: 'instance creation' stamp: 'jmv 8/1/2022 18:00:18' prior: 16838919!
                 informExistingDebugger: aContext label: aString
	"Walking the context chain, we try to find out if we're in a debugger stepping situation.
	If we find the relevant contexts, we must rearrange them so they look just like they would
	if the methods were excuted outside of the debugger."
	| ctx quickStepMethod oldSender baseContext |
	ctx _ thisContext.
	quickStepMethod _ ContextPart compiledMethodAt: #quickSend:to:with:super:.
	[ctx sender == nil or: [ctx sender method == quickStepMethod]] whileFalse: [ctx _ ctx sender].
	ctx sender ifNil: [^self].
	baseContext _ ctx.
	"baseContext is now the context created by the #quickSend... method."
	oldSender _ ctx _ ctx sender home sender.
	"oldSender is the context which originally sent the #quickSend... method"
	[ctx == nil or: [ctx receiver isKindOf: self]] whileFalse: [ctx _ ctx sender].
	ctx == nil ifTrue: [^self].
	"ctx is the context of the Debugger method #doStep"
	ctx receiver labelString: aString.
	baseContext swapSender: baseContext sender sender sender.	"remove intervening contexts"
	thisContext swapSender: oldSender.	"make myself return to debugger"
	ErrorRecursion _ false.
	^aContext! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 17:58:40' prior: 50399785!
     openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	debugger 	process: interruptedProcess context: interruptedProcess suspendedContext.

	(Preferences at: #logDebuggerStackToFile) ifTrue:
		[(aString includesSubString: 'Space') & 
			(aString includesSubString: 'low') ifTrue: [
				Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug']].

	^ debugger
		openNotifierContents: nil
		label: aString
! !

Debugger removeSelector: #proceedValue!

!methodRemoval: Debugger #proceedValue stamp: 'Install-5418-Debugger-Cleanup-JuanVuletich-2022Aug01-17h58m-jmv.001.cs.st 9/14/2022 16:06:23'!
proceedValue
	"Answer the value to return to the selected context when the interrupted 
	process proceeds."

	^proceedValue!

Debugger removeSelector: #externalInterrupt:!

!methodRemoval: Debugger #externalInterrupt: stamp: 'Install-5418-Debugger-Cleanup-JuanVuletich-2022Aug01-17h58m-jmv.001.cs.st 9/14/2022 16:06:23'!
externalInterrupt: aBoolean

	externalInterrupt _ aBoolean !

Debugger removeSelector: #proceedValue:!

!methodRemoval: Debugger #proceedValue: stamp: 'Install-5418-Debugger-Cleanup-JuanVuletich-2022Aug01-17h58m-jmv.001.cs.st 9/14/2022 16:06:23'!
proceedValue: anObject 
	"Set the value to be returned to the selected context when the interrupted 
	process proceeds."

	proceedValue _ anObject!

Debugger removeSelector: #selectPC!

!methodRemoval: Debugger #selectPC stamp: 'Install-5418-Debugger-Cleanup-JuanVuletich-2022Aug01-17h58m-jmv.001.cs.st 9/14/2022 16:06:23'!
selectPC
	"Toggle the flag telling whether to automatically select the expression 
	currently being executed by the selected context."

	selectingPC _ selectingPC not!

CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI sendProceeds'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!classDefinition: #Debugger category: #'Tools-Debugger' stamp: 'Install-5418-Debugger-Cleanup-JuanVuletich-2022Aug01-17h58m-jmv.001.cs.st 9/14/2022 16:06:23'!
CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI sendProceeds'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5418-Debugger-Cleanup-JuanVuletich-2022Aug01-17h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5418] on 2 August 2022 at 3:05:52 pm'!

CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI sendProceeds '
	classVariableNames: 'ErrorRecursion '
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!classDefinition: #Debugger category: #'Tools-Debugger' stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI sendProceeds'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!

TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!classDefinition: #Inspector category: #'Tools-Inspector' stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 18:17:35'!
                openDebugging: aBlock to: aCompiledMethod label: aString
	| processToDebug debugger |
	debugger _ Debugger new.
	processToDebug _ aBlock newProcess name: 'debugIt'.
	debugger process: processToDebug context: processToDebug suspendedContext.
	debugger openFullMorphicLabel: aString.
	[debugger interruptedContext method == aCompiledMethod]
		whileFalse: [debugger send]! !
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 8/1/2022 18:28:00' prior: 16838315!
                 send
	"Send the selected message in the accessed method, and take control in 
	the method invoked to allow further step or send."

	self checkContextSelection.
	interruptedProcess step: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn.
! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 18:13:25' prior: 50399749!
                           openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	<primitive: 19> "Simulation guard"

	(self errorRecursion not and: [Preferences at: #logDebuggerStackToFile]) ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	ErrorRecursion ifTrue: [
		ErrorRecursion _ false.
		contentsStringOrNil
			ifNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString]
			ifNotNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString, String newLineString, contentsStringOrNil ]].
	ErrorRecursion _ true.
	[self informExistingDebugger: aContext label: aString.
	(Debugger new
		process: Processor activeProcess
		context: aContext)
			openNotifierContents: contentsStringOrNil
			label: aString ] ensure: [ ErrorRecursion _ false ].
	Processor activeProcess suspend.
! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 8/1/2022 18:27:40' prior: 50412227!
 debug: aCompiledMethod receiver: anObject in: evalContext

	Debugger
		openDebugging: [
			aCompiledMethod
				valueWithReceiver: anObject
				arguments: (evalContext ifNil: [ #() ] ifNotNil: [ { evalContext } ])]
		to: aCompiledMethod
		label: 'Debug it'.! !
!TestCase methodsFor: 'debugging - private' stamp: 'jmv 8/1/2022 18:30:15' prior: 50412260!
openDebuggerOnFailingTestMethod

	Debugger
		openDebugging: [
			[ self performTest ] ensure: [
			self tearDown.
			self tearDownResources]]
		to: self methodForTest
		label: 'Debug failed test ', self printString.! !

Inspector removeSelector: #context:!

!methodRemoval: Inspector #context: stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
context: ctxt
	"Set the context of inspection. Currently only used by my subclass ClosureEnvInspector. The inst var is here because we do primitiveChangeClassTo: between subclasses (see inspect:) between different subclasses, but also context could be used as a general concept in all inspectors"

	context := ctxt!

Debugger class removeSelector: #context:!

!methodRemoval: Debugger class #context: stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
context: aContext 
	"Answer an instance of me for debugging the active process starting with the given context."
	^ self new
		process: Processor activeProcess
		context: aContext!

Debugger removeSelector: #receiverInspectorObject:context:!

!methodRemoval: Debugger #receiverInspectorObject:context: stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
receiverInspectorObject: obj context: ctxt

	"set context before object so it can refer to context when building field list"
	receiverInspector context: ctxt.
	receiverInspector object: obj.
!

Debugger removeSelector: #initialize!

!methodRemoval: Debugger #initialize stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
initialize
	sendProceeds _ false!

Debugger removeSelector: #sendProceeds!

!methodRemoval: Debugger #sendProceeds stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
sendProceeds
	sendProceeds _ true!

CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!classDefinition: #Debugger category: #'Tools-Debugger' stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!

TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!classDefinition: #Inspector category: #'Tools-Inspector' stamp: 'Install-5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st 9/14/2022 16:06:23'!
TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5419-Cleanup-JuanVuletich-2022Aug02-15h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5415] on 1 August 2022 at 6:46:19 pm'!

CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI '
	classVariableNames: 'ErrorRecursion '
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!classDefinition: #Debugger category: #'Tools-Debugger' stamp: 'Install-5420-Debugger-cleanup-JuanVuletich-2022Aug01-18h31m-jmv.001.cs.st 9/14/2022 16:06:23'!
CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI'
	classVariableNames: 'ErrorRecursion'
	poolDictionaries: ''
	category: 'Tools-Debugger'!
!Debugger commentStamp: 'jmv 8/1/2022 18:43:33' prior: 16837723!
                   I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.!
!Debugger class methodsFor: 'instance creation' stamp: 'jmv 8/1/2022 18:44:15' prior: 50412467!
        informExistingDebugger: aContext label: aString
	"Walking the context chain, we try to find out if we're in a debugger stepping situation.
	If we find the relevant contexts, we must rearrange them so they look just like they would
	if the methods were excuted outside of the debugger."
	| ctx quickStepMethod oldSender baseContext |
	ctx _ thisContext.
	quickStepMethod _ ContextPart compiledMethodAt: #quickSend:to:with:super:.
	[ctx sender == nil or: [ctx sender method == quickStepMethod]] whileFalse: [ctx _ ctx sender].
	ctx sender ifNil: [^self].
	baseContext _ ctx.
	"baseContext is now the context created by the #quickSend... method."
	oldSender _ ctx _ ctx sender home sender.
	"oldSender is the context which originally sent the #quickSend... method"
	[ctx == nil or: [ctx receiver isKindOf: self]] whileFalse: [ctx _ ctx sender].
	ctx == nil ifTrue: [^self].
	"ctx is the context of the Debugger method #doStep"
	ctx receiver labelString: aString.
	baseContext swapSender: baseContext sender sender sender.	"remove intervening contexts"
	thisContext swapSender: oldSender.	"make myself return to debugger"
	^aContext! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/1/2022 18:45:10' prior: 50412673!
                              openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	<primitive: 19> "Simulation guard"

	(Preferences at: #logDebuggerStackToFile) ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	self informExistingDebugger: aContext label: aString.
	(Debugger new
		process: Processor activeProcess
		context: aContext)
			openNotifierContents: contentsStringOrNil
			label: aString.
	Processor activeProcess suspend.! !

Debugger class removeSelector: #errorRecursion!

!methodRemoval: Debugger class #errorRecursion stamp: 'Install-5420-Debugger-cleanup-JuanVuletich-2022Aug01-18h31m-jmv.001.cs.st 9/14/2022 16:06:23'!
errorRecursion
	ErrorRecursion ifNil: [
		ErrorRecursion _ false ].
	^ErrorRecursion!

Debugger class removeSelector: #releaseClassCachedState!

!methodRemoval: Debugger class #releaseClassCachedState stamp: 'Install-5420-Debugger-cleanup-JuanVuletich-2022Aug01-18h31m-jmv.001.cs.st 9/14/2022 16:06:23'!
releaseClassCachedState

	ErrorRecursion _ nil!

CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Debugger'!

!classDefinition: #Debugger category: #'Tools-Debugger' stamp: 'Install-5420-Debugger-cleanup-JuanVuletich-2022Aug01-18h31m-jmv.001.cs.st 9/14/2022 16:06:23'!
CodeProvider subclass: #Debugger
	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector savedCursor labelString interruptedProcessUI'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Debugger'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5420-Debugger-cleanup-JuanVuletich-2022Aug01-18h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5420] on 2 August 2022 at 3:19:54 pm'!
!ContextPart methodsFor: 'private' stamp: 'jmv 8/2/2022 15:14:57' prior: 16833054!
                               doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and
	 arguments are given as arguments to this message. If successful, push result and return
	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes
	 execution needs to be intercepted and simulated to avoid execution running away."

	| value |
	"Judicious use of primitive 19 (a null primitive that doesn't do anything) prevents
	 the debugger from entering various run-away activities such as spawning a new
	 process, etc.  Injudicious use results in the debugger not being able to debug
	 interesting code, such as the debugger itself.  hence use primitive 19 with care :-)"
	"Smalltalk browseAllSelect: [:m| m primitive = 19]"
	primitiveIndex = 19 ifTrue: [
		Debugger
			openContext: self
			label:'Code simulation error'
			contents: nil].

	((primitiveIndex between: 201 and: 222)
	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:
		[((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"
		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"
			[^receiver simulateValueWithArguments: arguments caller: self].
		 primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"
			[^receiver simulateValueWithArguments: arguments first caller: self]].

	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"
		[^self send: arguments first to: receiver with: arguments allButFirst super: false].
	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"
		[^self send: arguments first to: receiver with: (arguments at: 2) lookupIn: (self objectClass: receiver)].
	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"
		[^self send: arguments first to: receiver with: (arguments at: 2) lookupIn: (arguments at: 3)].

	"Mutex>>primitiveEnterCriticalSection
	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSection"
	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:
		[| effective |
		 effective := Processor activeProcess effectiveProcess.
		 "active == effective"
		 value := primitiveIndex = 186
					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]
					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].
		 ^(self isPrimFailToken: value)
			ifTrue: [value]
			ifFalse: [self push: value]].

	primitiveIndex = 188 ifTrue: "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"
		[((self objectClass: (arguments at: 1)) == Array
		  and: [(self objectClass: (arguments at: 2)) includesBehavior: CompiledMethod]) ifFalse:
			[^ContextPart primitiveFailTokenFor: #'bad argument'].
		 (arguments at: 2) numArgs = (arguments at: 1) size ifFalse:
			[^ContextPart primitiveFailTokenFor: #'bad number of arguments'].
		 (arguments at: 2) primitive > 0 ifTrue:
			[(arguments at: 2) isQuick ifTrue:
				[^self push: (receiver withArgs: (arguments at: 1) executeMethod: (arguments at: 2))].
			 ^self doPrimitive: (arguments at: 2) primitive method: (arguments at: 2) receiver: receiver args: (arguments at: 1)].
		 ^MethodContext
			sender: self
			receiver: receiver
			method: (arguments at: 2)
			arguments: (arguments at: 1)].

	"Closure primitives"
	(primitiveIndex = 200 and: [self == receiver]) ifTrue:
		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"
		[^self push: (BlockClosure
						outerContext: receiver
						startpc: pc + 2
						numArgs: arguments first
						copiedValues: arguments last)].

	primitiveIndex = 118 ifTrue: "[receiver:]tryPrimitive:withArgs:; avoid recursing in the VM"
		[(arguments size = 3
		  and: [(self objectClass: arguments second) == SmallInteger
		  and: [(self objectClass: arguments last) == Array]]) ifTrue:
			[^self doPrimitive: arguments second method: meth receiver: arguments first args: arguments last].
		 (arguments size = 2
		 and: [(self objectClass: arguments first) == SmallInteger
		 and: [(self objectClass: arguments last) == Array]]) ifFalse:
			[^ContextPart primitiveFailTokenFor: nil].
		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].

	value := primitiveIndex = 120 "FFI method"
				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]
				ifFalse:
					[primitiveIndex = 117 "named primitives"
						ifTrue: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]
						ifFalse:
							["should use self receiver: receiver tryPrimitive: primitiveIndex withArgs: arguments but this is only in later VMs"
							receiver tryPrimitive: primitiveIndex withArgs: arguments]].

	^(self isPrimFailToken: value)
		ifTrue: [value]
		ifFalse: [self push: value]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5421-cleanup-JuanVuletich-2022Aug02-15h07m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 10:10:18 am'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/2/2022 17:44:37' prior: 50412646!
                       openDebugging: aBlock to: aCompiledMethod label: aString
	"Create a new process to debug aBlock, and step into it."

	| processToDebug debugger |
	debugger _ Debugger new.
	processToDebug _ aBlock newProcess name: 'debugIt'.
	debugger process: processToDebug context: processToDebug suspendedContext.
	debugger openFullMorphicLabel: aString.
	[debugger interruptedContext method == aCompiledMethod]
		whileFalse: [debugger send]! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 8/2/2022 20:32:21' prior: 50408563!
                  spawnNewMorphicProcessFor: guiRootObject
	"
	Safe to run anytime, as the old Morphic process will end by itself.
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.
	"
	"If the old one gets resumed, don't step on each other feet"
	UIProcess ifNotNil: [
		UIProcess
			name: 'Formerly: ', UIProcess name;
			priority: UIProcess priority-1.
		UIProcess isRunning ifTrue: [ Processor yield ]].
	UI _ guiRootObject.
	UIProcess _ guiRootObject runProcess.
	UIProcess resume! !
!UISupervisor class methodsFor: 'accessing' stamp: 'jmv 8/2/2022 18:00:40' prior: 50407693!
      animatedUIOf: aProcess
	"
	UISupervisor animatedUIOf: UIProcess
	[ (UISupervisor animatedUIOf: Processor activeProcess) print ] fork
	"
	^aProcess == UIProcess ifTrue: [ UI ]! !
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 8/2/2022 20:23:20' prior: 50408361!
                       doOneCycle: delay
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	self doOneCycleNow.

	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(Preferences at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			delay setDelay: wait; wait ].! !
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 8/2/2022 20:19:56' prior: 50408421!
               doOneCycleNow
	"Immediately do one cycle of the interaction loop.
	Only used for a few tests."
	"See #eventTickler"
	| hadAny |
	lastCycleTime _ Time localMillisecondClock.
	Cursor currentCursor = (Cursor cursorAt: #waitCursor) ifTrue: [ Cursor defaultCursor activateCursor ].
	"Repair visual damage."
	self checkForNewScreenSize.
	canvas ensureCurrentMorphIsWorld.
	self displayWorldSafely.
	"Run steps, alarms and deferred UI messages"
	self runDeferredUIMessages.
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.
	"Process user input events. Run all event triggered code."
	hadAny _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAny _ hadAny | h processEventQueue ].
	"The default is the primary hand"
	activeHand _ self hands first.
	"Run any deferred UI messages that were enqueued during this cycle before the inter cycle pause."
	self runDeferredUIMessages.
	lastCycleHadAnyEvent _ hadAny.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5422-World-waitAfterCycle-NewUIProcess-yield-JuanVuletich-2022Aug03-10h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 10:26:18 am'!
!Process methodsFor: 'debugging' stamp: 'jmv 8/3/2022 10:24:48'!
                   debugContext: context title: title
	"Open debugger on self with context shown on top"

	| topCtxt |
	self isTerminated ifTrue: [^ self error: 'can not debug a terminated process'].
	topCtxt _ self isRunning ifTrue: [thisContext] ifFalse: [self suspendedContext].
	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].
	Debugger openOn: self context: context label: title fullView: true.
! !
!Process methodsFor: 'debugging' stamp: 'jmv 8/3/2022 10:25:21'!
                             debugWithTitle: title
	"Open debugger on self"

	| context |
	context _ self isRunning ifTrue: [thisContext] ifFalse: [self suspendedContext].
	self debugContext: context title: title! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 8/2/2022 18:04:26'!
                       newUIProcess
	"Start a new UI process for the current UI.
	The current UI process (if any) will exit at the end of the current UI cycle."

	self spawnNewMorphicProcessFor: UI.! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 8/2/2022 18:11:19'!
                               newUIProcessIfCurrentCantRun
	"If the system needs a UIProcess (we know because UIProcess is not nil),
	then ensure that the UIProcess is ready to run, in order to hava a responsive UI.
	If we needed to create a new UI process, answer the old one, as it is most likely the
	process the user is interested in debugging. See senders."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isBlocked | oldUIProcess isSuspended | oldUIProcess isTerminated ifTrue: [
			self spawnNewMorphicProcessFor: UI.
			^oldUIProcess ]].
	^nil! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 10:13:01' prior: 50406906!
                     openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self lowSpaceChoices , (msgString ifNil: [ '' ]) ]
		ifFalse: [ msgString ].
	interruptedProcessUI _ UISupervisor newProcessIfUI: interruptedProcess.
	UISupervisor whenUIinSafeState: [
		PreDebugWindow
			forceOpen: self
			label: label
			message: msg ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 10:13:06' prior: 50412310!
                        openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| guiRootObjectOrNil |
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	guiRootObjectOrNil _ UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		self openOn: process context: context label: title fullView: bool guiRootObject: guiRootObjectOrNil
		].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.
	process suspend.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 8/3/2022 10:22:01' prior: 16918691!
                          debugProcess: aProcess
"	self resumeProcess: aProcess."
	aProcess debugWithTitle: 'Interrupted from the Process Browser'.
! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 8/3/2022 10:13:10' prior: 50412183!
    handleUserInterrupt
	| processToInterrupt |
	"If the UI process is not ready to run, the UI was not responsive, and most likely that's why the user pressed
	the interrupt key. Make GUI responsive again, and let them debug the process that made UI not responsive."
	processToInterrupt _ UISupervisor newUIProcessIfCurrentCantRun.
	processToInterrupt ifNil: [
		"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
		processToInterrupt _ Sensor shiftPressed | (Preferences at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preferences at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		processToInterrupt == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(processToInterrupt name beginsWith: '[system]') ifTrue: [
			 ('Process {', processToInterrupt printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			processToInterrupt isTerminated
				ifTrue: [ ('Process {', processToInterrupt printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ Debugger interruptProcess: processToInterrupt label: 'User Interrupt' ]] fork
		].! !
!UnhandledError methodsFor: 'priv handling' stamp: 'jmv 8/2/2022 17:13:59' prior: 16976066!
                  devDefaultAction

	Processor activeProcess
		debugContext: exception signalerContext
		title: exception description.! !
!StackSizeWatcher methodsFor: 'private' stamp: 'jmv 8/3/2022 10:22:05' prior: 16944267!
                debug: aProcess

	aProcess debugWithTitle: 'Interrupted - Stack too deep'.
! !

UISupervisor class removeSelector: #newUIProcessIfNeeded!

!methodRemoval: UISupervisor class #newUIProcessIfNeeded stamp: 'Install-5423-cleanup-JuanVuletich-2022Aug03-10h10m-jmv.001.cs.st 9/14/2022 16:06:23'!
newUIProcessIfNeeded
	"If the system needs a UIProcess (we know because UIProcess is not nil),
	then ensure that the UIProcess is ready to run, in order to hava a responsive UI.
	If we needed to create a new UI process, answer the old one, as it is most likely the
	process the user is interested in debugging. See senders."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isBlocked | oldUIProcess isSuspended | oldUIProcess isTerminated ifTrue: [
			self spawnNewMorphicProcessFor: UI.
			^oldUIProcess ]].
	^nil!

Process removeSelector: #debug:title:!

!methodRemoval: Process #debug:title: stamp: 'Install-5423-cleanup-JuanVuletich-2022Aug03-10h10m-jmv.001.cs.st 9/14/2022 16:06:23'!
debug: context title: title
	"Open debugger on self with context shown on top"

	self debug: context title: title full: false!

Process removeSelector: #debugFullWithTitle:!

!methodRemoval: Process #debugFullWithTitle: stamp: 'Install-5423-cleanup-JuanVuletich-2022Aug03-10h10m-jmv.001.cs.st 9/14/2022 16:06:23'!
debugFullWithTitle: title
	"Open debugger on self"

	| context |
	context _ self isRunning ifTrue: [thisContext] ifFalse: [self suspendedContext].
	self debug: context title: title full: true!

Process removeSelector: #debug:title:full:!

!methodRemoval: Process #debug:title:full: stamp: 'Install-5423-cleanup-JuanVuletich-2022Aug03-10h10m-jmv.001.cs.st 9/14/2022 16:06:23'!
debug: context title: title full: bool
	"Open debugger on self with context shown on top"

	| topCtxt |
	self isTerminated ifTrue: [^ self error: 'can not debug a terminated process'].
	topCtxt _ self isRunning ifTrue: [thisContext] ifFalse: [self suspendedContext].
	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].
	Debugger openOn: self context: context label: title fullView: bool.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5423-cleanup-JuanVuletich-2022Aug03-10h10m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 10:31:09 am'!
!Debugger class methodsFor: 'constants' stamp: 'jmv 8/2/2022 16:46:24'!
          lowSpaceMessage
	"Return a notifier message string to be presented when space is running low."

	^ 'Warning!! Cuis is almost out of memory!!

Low space detection is now disabled. It will be restored when you close or proceed from this error notifier. Don''t panic, but do proceed with caution.

Here are some suggestions:

- If you suspect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem.

- If you want this computation to finish, then make more space available (read on) and choose "proceed" in this debugger. Here are some ways to make more space available...
   > Close any windows that are not needed.
   > Get rid of some large objects (e.g., images).
   > Leave this window on the screen, choose "save as..." from the screen menu, quit, restart the Squeak VM with a larger memory allocation, then restart the image you just saved, and choose "proceed" in this window.

- If you want to investigate further, choose "debug" in this window.  Do not use the debugger "fullStack" command unless you are certain that the stack is not very deep. (Trying to show the full stack will definitely use up all remaining memory if the low-space problem is caused by an infinite recursion!!).

'
! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 10:30:44' prior: 50413344!
                      openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self class lowSpaceMessage, (msgString ifNil: [ '' ]) ]
		ifFalse: [ msgString ].
	interruptedProcessUI _ UISupervisor newProcessIfUI: interruptedProcess.
	UISupervisor whenUIinSafeState: [
		PreDebugWindow
			forceOpen: self
			label: label
			message: msg ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.! !

Debugger removeSelector: #lowSpaceChoices!

!methodRemoval: Debugger #lowSpaceChoices stamp: 'Install-5424-lowSpaceMessage-moveToClassSide-JuanVuletich-2022Aug03-10h26m-jmv.001.cs.st 9/14/2022 16:06:23'!
lowSpaceChoices
	"Return a notifier message string to be presented when space is running low."

	^ 'Warning!! Cuis is almost out of memory!!

Low space detection is now disabled. It will be restored when you close or proceed from this error notifier. Don''t panic, but do proceed with caution.

Here are some suggestions:

- If you suspect an infinite recursion (the same methods calling each other again and again), then close this debugger, and fix the problem.

- If you want this computation to finish, then make more space available (read on) and choose "proceed" in this debugger. Here are some ways to make more space available...
   > Close any windows that are not needed.
   > Get rid of some large objects (e.g., images).
   > Leave this window on the screen, choose "save as..." from the screen menu, quit, restart the Squeak VM with a larger memory allocation, then restart the image you just saved, and choose "proceed" in this window.

- If you want to investigate further, choose "debug" in this window.  Do not use the debugger "fullStack" command unless you are certain that the stack is not very deep. (Trying to show the full stack will definitely use up all remaining memory if the low-space problem is caused by an infinite recursion!!).

'
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5424-lowSpaceMessage-moveToClassSide-JuanVuletich-2022Aug03-10h26m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 10:38:55 am'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 10:34:37' prior: 50412121!
                              interruptProcess: aProcess label: labelString
	"Create a Notifier on aProcess with the given label.
	This method is called only in special system processes, like the #userInterruptWatcher and the #lowSpaceWatcher."
	|  label |

	label _ labelString,
					' - Process: ', aProcess name,
					' - Priority: ', aProcess priority printString.

	aProcess suspend.
	self
		openInterrupt: label 
		onProcess: aProcess! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 8/3/2022 10:34:10' prior: 16952659!
     lowSpaceWatcher
	"Wait until the low space semaphore is signalled, then take appropriate actions."

	| p |
	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [
		self garbageCollect <= self lowSpaceThreshold ifTrue: [
			"free space must be above threshold before starting low space watcher"
			^ Smalltalk primitiveBeep ]].

	LowSpaceSemaphore _ Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"

	LowSpaceSemaphore wait.  "wait for a low space condition..."

	self primSignalAtBytesLeft: 0.  "disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess _ nil.
	"Note: user now unprotected until the low space watcher is re-installed"

	p _ Processor preemptedProcess.
	p isTerminated ifFalse: [
		p suspend.
		Debugger interruptProcess: p label: 'Space is low' ]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 8/3/2022 10:32:53' prior: 50413423!
    handleUserInterrupt
	| processToInterrupt |
	"If the UI process is not ready to run, the UI was not responsive, and most likely that's why the user pressed
	the interrupt key. Make GUI responsive again, and let them debug the process that made UI not responsive."
	processToInterrupt _ UISupervisor newUIProcessIfCurrentCantRun.
	processToInterrupt ifNil: [
		"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
		processToInterrupt _ Sensor shiftPressed | (Preferences at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preferences at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		processToInterrupt == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(processToInterrupt name beginsWith: '[system]') ifTrue: [
			 ('Process {', processToInterrupt printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			processToInterrupt isTerminated
				ifTrue: [ ('Process {', processToInterrupt printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ Debugger interruptProcess: processToInterrupt label: 'User Interrupt' ]
		] fork
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5425-refactor-JuanVuletich-2022Aug03-10h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 10:44:56 am'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 10:41:28'!
      open2On: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new.
		debugger 	process: process context: context.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 10:39:22' prior: 50413593!
          openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self class lowSpaceMessage, (msgString ifNil: [ '' ]) ]
		ifFalse: [ msgString ].
	UISupervisor newProcessIfUI: interruptedProcess.
	UISupervisor whenUIinSafeState: [
		PreDebugWindow
			forceOpen: self
			label: label
			message: msg ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.! !
!Debugger methodsFor: 'private' stamp: 'jmv 8/2/2022 18:00:56' prior: 50412458!
                process: aProcess context: aContext

	interruptedProcess _ aProcess.
	interruptedProcessUI _ UISupervisor animatedUIOf: interruptedProcess.
	contextStackTop _ aContext.
	self newStack: (contextStackTop stackOfSize: 1).
	contextStackIndex _ 1.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 10:41:55' prior: 50413381!
                    openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		self open2On: process context: context label: title fullView: bool
		].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.
	process suspend.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 8/3/2022 10:42:25' prior: 50412247!
             newProcessIfUI: processBeingSuspended
	"processBeingSuspended has been suspended or is about to be.
	Answer the UI we created a new process for."

	processBeingSuspended == UIProcess ifTrue: [
		self spawnNewMorphicProcessFor: UI ]
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"! !

Debugger class removeSelector: #openOn:context:label:fullView:guiRootObject:!

!methodRemoval: Debugger class #openOn:context:label:fullView:guiRootObject: stamp: 'Install-5426-refactor-JuanVuletich-2022Aug03-10h38m-jmv.001.cs.st 9/14/2022 16:06:24'!
openOn: process context: context label: title fullView: bool guiRootObject: guiRootObjectOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new.
		debugger 	process: process context: context.
		debugger interruptedProcessUI: guiRootObjectOrNil.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]!

Debugger removeSelector: #interruptedProcessUI:!

!methodRemoval: Debugger #interruptedProcessUI: stamp: 'Install-5426-refactor-JuanVuletich-2022Aug03-10h38m-jmv.001.cs.st 9/14/2022 16:06:24'!
interruptedProcessUI: aWorld
	interruptedProcessUI _ aWorld!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5426-refactor-JuanVuletich-2022Aug03-10h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 10:50:31 am'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 10:48:26'!
  open2On: process context: context label: title usePreDebugWindow: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	[
		| debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new.
		debugger 	process: process context: context.
		bool
			ifTrue: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]
			ifFalse: [ debugger openFullMorphicLabel: title ]
	]
		on: UnhandledError
		do: [ :exOuter | | errorDescription |
			errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
				([ exOuter description ]
					on: UnhandledError
					do: [ :exInner |
						exInner return: 'a ' , exInner class printString ]) , ':'.
			self primitiveError: errorDescription ]! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 10:48:52'!
                       openProcess: process context: context label: title
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		self open2On: process context: context label: title usePreDebugWindow: false 	].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.
	process suspend.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !
!Process methodsFor: 'debugging' stamp: 'jmv 8/2/2022 17:34:31' prior: 50413290!
                           debugContext: context title: title
	"Open debugger on self with context shown on top"

	| topCtxt |
	self isTerminated ifTrue: [^ self error: 'can not debug a terminated process'].
	topCtxt _ self isRunning ifTrue: [thisContext] ifFalse: [self suspendedContext].
	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].
	Debugger openProcess: self context: context label: title.! !

Debugger class removeSelector: #openOn:context:label:fullView:!

!methodRemoval: Debugger class #openOn:context:label:fullView: stamp: 'Install-5427-cleanup-JuanVuletich-2022Aug03-10h44m-jmv.001.cs.st 9/14/2022 16:06:24'!
openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		self open2On: process context: context label: title fullView: bool
		].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.
	process suspend.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"!

Debugger class removeSelector: #open2On:context:label:fullView:!

!methodRemoval: Debugger class #open2On:context:label:fullView: stamp: 'Install-5427-cleanup-JuanVuletich-2022Aug03-10h44m-jmv.001.cs.st 9/14/2022 16:06:24'!
open2On: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger _ self new.
		debugger 	process: process context: context.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription _ 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5427-cleanup-JuanVuletich-2022Aug03-10h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 11:06:35 am'!
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 11:05:45'!
                   openWindow2Label: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil

	[
		bool
			ifTrue: [
				PreDebugWindow
					open: self
					label: label
					message: preDebugMessageOrNil ]
			ifFalse: [ self openFullMorphicLabel: label ]
	]
		on: UnhandledError
		do: [ :exOuter | | errorDescription |
			errorDescription _ 'Error while trying to open Debugger' , String newLineString , 
				'Orginal error: ' , label asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
			self primitiveError: errorDescription ]! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 11:00:11' prior: 50413820!
                           openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self class lowSpaceMessage, (msgString ifNil: [ '' ]) ]
		ifFalse: [ msgString ].
	UISupervisor whenUIinSafeState: [
		self openWindow2Label: label usePreDebugWindow: true preDebugMessage: msg ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 11:04:05' prior: 50413971!
                    open2On: process context: context label: label usePreDebugWindow: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	| debugger |
	"In case an error in Morphic code got us here, ensure mouse focus has been released"
	true runningWorld ifNotNil: [ :rWorld |
		rWorld activeHand ifNotNil: [ :aHand |
			aHand releaseMouseFocus ]].
	debugger _ self new.
	debugger 	process: process context: context.
	debugger openWindow2Label: label usePreDebugWindow: bool preDebugMessage: nil.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 10:55:52' prior: 50412911!
openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	| debugger |
	<primitive: 19> "Simulation guard"

	(Preferences at: #logDebuggerStackToFile) ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	self informExistingDebugger: aContext label: aString.

	debugger _ Debugger new.
	debugger 		process: Processor activeProcess context: aContext.
	debugger 	openNotifierContents: contentsStringOrNil label: aString.
	Processor activeProcess suspend.! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 8/3/2022 11:05:33' prior: 50402573!
                         open: model label: aString message: messageString
	|  window |

	window _ self new.
	window
		model: model;
		buildMorphicWindowMessage: messageString print.
	aString ifNotNil: [ window setLabel: aString ].

	window openInWorld.! !

PreDebugWindow class removeSelector: #forceOpen:label:message:!

!methodRemoval: PreDebugWindow class #forceOpen:label:message: stamp: 'Install-5428-refactor-JuanVuletich-2022Aug03-10h50m-jmv.001.cs.st 9/14/2022 16:06:24'!
forceOpen: model label: aString message: messageString
		
	|  window |
	
	window _ self new.
	window
		model: model;
		buildMorphicWindowMessage: messageString print.
	aString ifNotNil: [ window setLabel: aString ].
	
	window openInWorld !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5428-refactor-JuanVuletich-2022Aug03-10h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 11:38:48 am'!
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 11:10:23'!
 openWindowLabel: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."

	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	UISupervisor whenUIinSafeState: [
		self openWindow2Label: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 11:36:34' prior: 50414223!
           openContext: aContext label: label contents: contentsStringOrNil
	"Open a notifier (a PreDebugWindow) in response to an error, halt, or notify.
	A PreDebugWindow just shows a short view of the sender stack and provides a menu that lets the user open a full debugger.
	The context argument is in the active process stack."

	| debugger |
	<primitive: 19> "Simulation guard"

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk logError: label inContext: aContext to: 'CuisDebug'].
	self informExistingDebugger: aContext label: label.

	debugger _ Debugger new.
	debugger 		process: Processor activeProcess context: aContext.
	debugger openWindowLabel: label usePreDebugWindow: true preDebugMessage: contentsStringOrNil.
	Processor activeProcess suspend.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 11:33:32' prior: 50414009!
         openProcess: process context: context label: labelString
	"Open a Debugger on an existing process."

	| debugger logFile label |
	<primitive: 19> "Simulation guard"
	label _ labelString,
					' - Process: ', process name,
					' - Priority: ', process priority printString.
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		logFile _ 'CuisDebug'.
		(labelString beginsWith: 'Space is low')
			ifTrue: [logFile _ 'LowSpaceDebug'].
		Smalltalk logError: label inContext: context to: logFile ].

	UISupervisor newProcessIfUI: process.
	
	debugger _ Debugger new.
	debugger process: process context: context.
	debugger openWindowLabel: label usePreDebugWindow: false preDebugMessage: nil.
	process suspend.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 8/2/2022 17:35:58' prior: 50413700!
                             lowSpaceWatcher
	"Wait until the low space semaphore is signalled, then take appropriate actions."

	| p |
	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [
		self garbageCollect <= self lowSpaceThreshold ifTrue: [
			"free space must be above threshold before starting low space watcher"
			^ Smalltalk primitiveBeep ]].

	LowSpaceSemaphore _ Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"

	LowSpaceSemaphore wait.  "wait for a low space condition..."

	self primSignalAtBytesLeft: 0.  "disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess _ nil.
	"Note: user now unprotected until the low space watcher is re-installed"

	p _ Processor preemptedProcess.
	p isTerminated ifFalse: [
		p suspend.
		Debugger openProcess: p context: p suspendedContext label: 'Space is low' ]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 8/2/2022 18:11:21' prior: 50413731!
             handleUserInterrupt
	| processToInterrupt |
	"If the UI process is not ready to run, the UI was not responsive, and most likely that's why the user pressed
	the interrupt key. Make GUI responsive again, and let them debug the process that made UI not responsive."
	processToInterrupt _ UISupervisor newUIProcessIfCurrentCantRun.
	processToInterrupt ifNil: [
		"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
		processToInterrupt _ Sensor shiftPressed | (Preferences at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preferences at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		processToInterrupt == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(processToInterrupt name beginsWith: '[system]') ifTrue: [
			 ('Process {', processToInterrupt printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			processToInterrupt isTerminated
				ifTrue: [ ('Process {', processToInterrupt printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [	Debugger openProcess: processToInterrupt context: processToInterrupt suspendedContext label: 'User Interrupt' ]
		] fork
	].! !

Debugger class removeSelector: #interruptProcess:label:!

!methodRemoval: Debugger class #interruptProcess:label: stamp: 'Install-5429-refactor-JuanVuletich-2022Aug03-11h06m-jmv.001.cs.st 9/14/2022 16:06:24'!
interruptProcess: aProcess label: labelString
	"Create a Notifier on aProcess with the given label.
	This method is called only in special system processes, like the #userInterruptWatcher and the #lowSpaceWatcher."
	|  label |

	label _ labelString,
					' - Process: ', aProcess name,
					' - Priority: ', aProcess priority printString.

	aProcess suspend.
	self
		openInterrupt: label 
		onProcess: aProcess!

Debugger class removeSelector: #interruptProcess:label:preDebugMessage:!

Debugger class removeSelector: #openInterrupt:onProcess:!

!methodRemoval: Debugger class #openInterrupt:onProcess: stamp: 'Install-5429-refactor-JuanVuletich-2022Aug03-11h06m-jmv.001.cs.st 9/14/2022 16:06:24'!
openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	debugger 	process: interruptedProcess context: interruptedProcess suspendedContext.

	(Preferences at: #logDebuggerStackToFile) ifTrue:
		[(aString includesSubString: 'Space') & 
			(aString includesSubString: 'low') ifTrue: [
				Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug']].

	^ debugger
		openNotifierContents: nil
		label: aString
!

Debugger class removeSelector: #openInterrupt:onProcess:preDebugMessage:!

Debugger class removeSelector: #open2On:context:label:usePreDebugWindow:!

!methodRemoval: Debugger class #open2On:context:label:usePreDebugWindow: stamp: 'Install-5429-refactor-JuanVuletich-2022Aug03-11h06m-jmv.001.cs.st 9/14/2022 16:06:24'!
open2On: process context: context label: label usePreDebugWindow: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	| debugger |
	"In case an error in Morphic code got us here, ensure mouse focus has been released"
	true runningWorld ifNotNil: [ :rWorld |
		rWorld activeHand ifNotNil: [ :aHand |
			aHand releaseMouseFocus ]].
	debugger _ self new.
	debugger 	process: process context: context.
	debugger openWindow2Label: label usePreDebugWindow: bool preDebugMessage: nil.!

Debugger removeSelector: #openNotifierContents:label:!

!methodRemoval: Debugger #openNotifierContents:label: stamp: 'Install-5429-refactor-JuanVuletich-2022Aug03-11h06m-jmv.001.cs.st 9/14/2022 16:06:24'!
openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self class lowSpaceMessage, (msgString ifNil: [ '' ]) ]
		ifFalse: [ msgString ].
	UISupervisor whenUIinSafeState: [
		self openWindow2Label: label usePreDebugWindow: true preDebugMessage: msg ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5429-refactor-JuanVuletich-2022Aug03-11h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 11:47:01 am'!
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 11:45:44' prior: 50414279!
       openWindowLabel: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil
	"Create and schedule a full debugger, or just a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."

	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	"In case an error in Morphic code got us here, ensure mouse focus has been released"
	true runningWorld ifNotNil: [ :rWorld |
		rWorld activeHand ifNotNil: [ :aHand |
			aHand releaseMouseFocus ]].

	UISupervisor whenUIinSafeState: [
		self openWindow2Label: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil ].
	"This is in case the UI process is (for example) blocked before it processes deferred blocks."
	[
		(Delay forMilliseconds: 200) wait.
		UISupervisor newUIProcessIfCurrentCantRun.
	] fork.
	interruptedProcess suspend.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 11:45:54' prior: 50414311!
             openContext: aContext label: label contents: contentsStringOrNil
	"Open a notifier (a PreDebugWindow) in response to an error, halt, or notify.
	A PreDebugWindow just shows a short view of the sender stack and provides a menu that lets the user open a full debugger.
	The context argument is in the active process stack."

	| debugger |
	<primitive: 19> "Simulation guard"

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk logError: label inContext: aContext to: 'CuisDebug'].
	self informExistingDebugger: aContext label: label.

	debugger _ Debugger new.
	debugger 		process: Processor activeProcess context: aContext.
	debugger openWindowLabel: label usePreDebugWindow: true preDebugMessage: contentsStringOrNil.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 11:45:48' prior: 50414338!
           openProcess: process context: context label: labelString
	"Open a Debugger on an existing process."

	| debugger logFile label |
	<primitive: 19> "Simulation guard"
	label _ labelString,
					' - Process: ', process name,
					' - Priority: ', process priority printString.
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		logFile _ 'CuisDebug'.
		(labelString beginsWith: 'Space is low')
			ifTrue: [logFile _ 'LowSpaceDebug'].
		Smalltalk logError: label inContext: context to: logFile ].

	UISupervisor newProcessIfUI: process.
	
	debugger _ Debugger new.
	debugger process: process context: context.
	debugger openWindowLabel: label usePreDebugWindow: false preDebugMessage: nil.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5430-refactor-JuanVuletich-2022Aug03-11h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5432] on 3 August 2022 at 2:33:54 pm'!
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 8/3/2022 13:10:31'!
  millisecondsSinceLastCycle
	"
	self runningWorld millisecondsSinceLastCycle
	"
	^Time localMillisecondClock - lastCycleTime! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 8/3/2022 13:58:47' prior: 50414398!
   handleUserInterrupt
	| processToInterrupt |
	"If the UI process is not ready to run, the UI was not responsive, and most likely that's why the user pressed
	the interrupt key. Make GUI responsive again, and let them debug the process that made UI not responsive."
	processToInterrupt _ UISupervisor newUIProcessIfCurrentCantRun.
	processToInterrupt ifNil: [
		"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
		processToInterrupt _ Sensor shiftPressed | (Preferences at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(Preferences at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		processToInterrupt == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(processToInterrupt name beginsWith: '[system]') ifTrue: [
			 ('Process {', processToInterrupt printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			processToInterrupt isTerminated
				ifTrue: [ ('Process {', processToInterrupt printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [	Debugger openProcess: processToInterrupt context: processToInterrupt suspendedContext label: 'User Interrupt' ]
		] fork "Forked so the #userInterruptWatcher process continues."
	].! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 8/3/2022 14:23:22' prior: 50413324!
             newUIProcessIfCurrentCantRun
	"If the system needs a UIProcess (we know because UIProcess is not nil),
	then ensure that the UIProcess is ready to run, in order to hava a responsive UI.
	If we needed to create a new UI process, answer the old one, as it is most likely the
	process the user is interested in debugging. See senders."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isBlocked | oldUIProcess isSuspended | oldUIProcess isTerminated ifTrue: [
			self spawnNewMorphicProcessFor: UI.
			^oldUIProcess ].
		UI millisecondsSinceLastCycle > 500 ifTrue: [
			self spawnNewMorphicProcessFor: UI.
			^oldUIProcess ].
		].
	^nil! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 8/3/2022 14:03:11' prior: 50413163!
                               spawnNewMorphicProcessFor: guiRootObject
	"
	Safe to run anytime, as the old Morphic process will end by itself.
	UISupervisor spawnNewMorphicProcessFor: UISupervisor ui.
	"
	| doYield |
	doYield _ false.
	"If the old one gets resumed, don't step on each other feet"
	UIProcess ifNotNil: [
		UIProcess
			name: 'Formerly: ', UIProcess name;
			priority: UIProcess priority-1.
		UIProcess isRunning ifTrue: [ doYield _ true ]].
	UI _ guiRootObject.
	UIProcess _ guiRootObject runProcess.
	UIProcess resume.
	doYield ifTrue: [ Processor yield ]! !
!WorldMorph methodsFor: 'stepping' stamp: 'jmv 8/3/2022 14:17:00' prior: 50408310!
           runDeferredUIMessages
	"Processing the queue until empty is wrong if a block in it calls #addDeferredUIMessage: itself, because this loop will never end.
	Instead, process no more than entries already in queue befor we start iterating!!"
	| readyToProcess |
	readyToProcess _ deferredUIMessages size.
	readyToProcess timesRepeat: [
		UISupervisor isUIProcessRunning ifFalse: [ ^self ].
		deferredUIMessages nextOrNil ifNotNil: [ :block |
			block value ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5431-fix-JuanVuletich-2022Aug03-14h30m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5431] on 3 August 2022 at 12:32:34 pm'!
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 12:32:03'!
                   openContext: aContext label: label preDebugMessage: contentsStringOrNil
	"Open a notifier (a PreDebugWindow) in response to an error, halt, or notify.
	A PreDebugWindow just shows a short view of the sender stack and provides a menu that lets the user open a full debugger.
	The context argument is in the active process stack."

	| debugger |
	<primitive: 19> "Simulation guard"

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk logError: label inContext: aContext to: 'CuisDebug'].
	self informExistingDebugger: aContext label: label.

	debugger _ Debugger new.
	debugger 		process: Processor activeProcess context: aContext.
	debugger openWindowLabel: label usePreDebugWindow: true preDebugMessage: contentsStringOrNil.! !
!ContextPart methodsFor: 'private' stamp: 'jmv 8/3/2022 12:32:07' prior: 50412983!
       doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and
	 arguments are given as arguments to this message. If successful, push result and return
	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes
	 execution needs to be intercepted and simulated to avoid execution running away."

	| value |
	"Judicious use of primitive 19 (a null primitive that doesn't do anything) prevents
	 the debugger from entering various run-away activities such as spawning a new
	 process, etc.  Injudicious use results in the debugger not being able to debug
	 interesting code, such as the debugger itself.  hence use primitive 19 with care :-)"
	"Smalltalk browseAllSelect: [:m| m primitive = 19]"
	primitiveIndex = 19 ifTrue: [
		Debugger
			openContext: self
			label:'Code simulation error'
			preDebugMessage: nil].

	((primitiveIndex between: 201 and: 222)
	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:
		[((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"
		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"
			[^receiver simulateValueWithArguments: arguments caller: self].
		 primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"
			[^receiver simulateValueWithArguments: arguments first caller: self]].

	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"
		[^self send: arguments first to: receiver with: arguments allButFirst super: false].
	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"
		[^self send: arguments first to: receiver with: (arguments at: 2) lookupIn: (self objectClass: receiver)].
	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"
		[^self send: arguments first to: receiver with: (arguments at: 2) lookupIn: (arguments at: 3)].

	"Mutex>>primitiveEnterCriticalSection
	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSection"
	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:
		[| effective |
		 effective := Processor activeProcess effectiveProcess.
		 "active == effective"
		 value := primitiveIndex = 186
					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]
					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].
		 ^(self isPrimFailToken: value)
			ifTrue: [value]
			ifFalse: [self push: value]].

	primitiveIndex = 188 ifTrue: "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"
		[((self objectClass: (arguments at: 1)) == Array
		  and: [(self objectClass: (arguments at: 2)) includesBehavior: CompiledMethod]) ifFalse:
			[^ContextPart primitiveFailTokenFor: #'bad argument'].
		 (arguments at: 2) numArgs = (arguments at: 1) size ifFalse:
			[^ContextPart primitiveFailTokenFor: #'bad number of arguments'].
		 (arguments at: 2) primitive > 0 ifTrue:
			[(arguments at: 2) isQuick ifTrue:
				[^self push: (receiver withArgs: (arguments at: 1) executeMethod: (arguments at: 2))].
			 ^self doPrimitive: (arguments at: 2) primitive method: (arguments at: 2) receiver: receiver args: (arguments at: 1)].
		 ^MethodContext
			sender: self
			receiver: receiver
			method: (arguments at: 2)
			arguments: (arguments at: 1)].

	"Closure primitives"
	(primitiveIndex = 200 and: [self == receiver]) ifTrue:
		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"
		[^self push: (BlockClosure
						outerContext: receiver
						startpc: pc + 2
						numArgs: arguments first
						copiedValues: arguments last)].

	primitiveIndex = 118 ifTrue: "[receiver:]tryPrimitive:withArgs:; avoid recursing in the VM"
		[(arguments size = 3
		  and: [(self objectClass: arguments second) == SmallInteger
		  and: [(self objectClass: arguments last) == Array]]) ifTrue:
			[^self doPrimitive: arguments second method: meth receiver: arguments first args: arguments last].
		 (arguments size = 2
		 and: [(self objectClass: arguments first) == SmallInteger
		 and: [(self objectClass: arguments last) == Array]]) ifFalse:
			[^ContextPart primitiveFailTokenFor: nil].
		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].

	value := primitiveIndex = 120 "FFI method"
				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]
				ifFalse:
					[primitiveIndex = 117 "named primitives"
						ifTrue: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]
						ifFalse:
							["should use self receiver: receiver tryPrimitive: primitiveIndex withArgs: arguments but this is only in later VMs"
							receiver tryPrimitive: primitiveIndex withArgs: arguments]].

	^(self isPrimFailToken: value)
		ifTrue: [value]
		ifFalse: [self push: value]! !
!MethodContext methodsFor: 'private' stamp: 'jmv 8/3/2022 12:32:11' prior: 50337918!
                cannotReturn: result
	closureOrNil ifNotNil: [
		^self cannotReturn: result to: sender].
	Debugger
		openContext: thisContext
		label: 'computation has been terminated'
		preDebugMessage: nil! !
!Warning methodsFor: 'exceptionDescription' stamp: 'jmv 8/3/2022 12:32:15' prior: 16978791 overrides: 16899936!
             defaultAction
	"The user should be notified of the occurrence of an exceptional occurrence and given an option of continuing or aborting the computation. The description of the occurrence should include any text specified as the argument of the #signal: message."

	Debugger
		openContext: thisContext
		label: 'Warning'
		preDebugMessage: self messageText.
	self resume! !

Debugger class removeSelector: #openContext:label:contents:!

!methodRemoval: Debugger class #openContext:label:contents: stamp: 'Install-5432-tweak-JuanVuletich-2022Aug03-12h32m-jmv.001.cs.st 9/14/2022 16:06:24'!
openContext: aContext label: label contents: contentsStringOrNil
	"Open a notifier (a PreDebugWindow) in response to an error, halt, or notify.
	A PreDebugWindow just shows a short view of the sender stack and provides a menu that lets the user open a full debugger.
	The context argument is in the active process stack."

	| debugger |
	<primitive: 19> "Simulation guard"

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk logError: label inContext: aContext to: 'CuisDebug'].
	self informExistingDebugger: aContext label: label.

	debugger _ Debugger new.
	debugger 		process: Processor activeProcess context: aContext.
	debugger openWindowLabel: label usePreDebugWindow: true preDebugMessage: contentsStringOrNil.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5432-tweak-JuanVuletich-2022Aug03-12h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5433] on 3 August 2022 at 3:27:52 pm'!
!Transcript class methodsFor: 'displaying' stamp: 'jmv 8/3/2022 15:27:21' prior: 16973931!
                               displayOnDisplay
	"To be called directly, not from Morphic.
	See #displayOnCanvas:in:"
	"
	1 to: 2000 do: [ :i | i print ].
	1 to: 750 do: [ :i | i print ].
	Transcript displayOnDisplay.
	Display forceToScreen
	"
	self displayEngine.
	displayEngine clipRect: bounds.
	displayEngine
		fill: bounds fillColor: `Color veryVeryLightGray` rule: Form over.
	self displayTextOn: self in: bounds.! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 8/3/2022 15:20:20' prior: 16974005!
                             drawString: s at: pt font: font color: aColor
	"Answer position to place next glyph
	Answer nil if nothing was done"

	displayEngine colorMap: nil.
	^font
		onBitBltCanvasEngine: displayEngine
		displayString: s
		from: 1
		to: s size
		at: pt roundedHAFZ
		color: aColor! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 8/3/2022 15:26:50' prior: 50406571 overrides: 16794207!
  drawOn: aCanvas
	"If we don't call super, clipping fails if zoomed / rotated, and nothing is shown."
	super drawOn: aCanvas.
	aCanvas clippingByCurrentMorphDo: [
		aCanvas
			fillRectangle: self morphLocalBounds
			color: color.
		Transcript displayTextOn: aCanvas in: self morphLocalBounds ].
	Transcript bounds: (self externalizeBoundsToWorld: self morphLocalBounds)
				encompassingIntegerRectangle.
	self updateWorkspace! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5433-Transcript-fix-JuanVuletich-2022Aug03-15h22m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5421] on 3 August 2022 at 11:55:12 am'!
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/3/2022 11:51:50' prior: 50414569!
                       openWindowLabel: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil
	"Create and schedule a full debugger, or just a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."

	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	"In case an error in Morphic code got us here, ensure mouse focus has been released"
	true runningWorld ifNotNil: [ :rWorld |
		rWorld activeHand ifNotNil: [ :aHand |
			aHand releaseMouseFocus ]].

	UISupervisor whenUIinSafeState: [
		interruptedProcess suspend.
		self openWindow2Label: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil ].
	"Ensure the Debugger is opened in a new UI process.
	This avoid unresponsive UI if the interruptedProcess is the UI current UI process, but also if the UI is busy, blocked or suspended."
	UISupervisor newUIProcess.! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 8/3/2022 11:53:51' prior: 50414635!
                  openProcess: process context: context label: labelString
	"Open a Debugger on an existing process."

	| debugger logFile label |
	<primitive: 19> "Simulation guard"
	label _ labelString,
					' - Process: ', process name,
					' - Priority: ', process priority printString.
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		logFile _ 'CuisDebug'.
		(labelString beginsWith: 'Space is low')
			ifTrue: [logFile _ 'LowSpaceDebug'].
		Smalltalk logError: label inContext: context to: logFile ].

	debugger _ Debugger new.
	debugger process: process context: context.
	debugger openWindowLabel: label usePreDebugWindow: false preDebugMessage: nil.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !

UISupervisor class removeSelector: #newProcessIfUI:!

!methodRemoval: UISupervisor class #newProcessIfUI: stamp: 'Install-5434-StartNewUIProcessWhenOpeningDebugger-JuanVuletich-2022Aug03-11h47m-jmv.001.cs.st 9/14/2022 16:06:24'!
newProcessIfUI: processBeingSuspended
	"processBeingSuspended has been suspended or is about to be.
	Answer the UI we created a new process for."

	processBeingSuspended == UIProcess ifTrue: [
		self spawnNewMorphicProcessFor: UI ]
	"
	|s|
	s := Semaphore new.
	[1/0. s signal] fork.
	s wait
	"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5434-StartNewUIProcessWhenOpeningDebugger-JuanVuletich-2022Aug03-11h47m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5434] on 4 August 2022 at 11:45:07 am'!
!Utf8String methodsFor: 'accessing' stamp: 'jmv 8/4/2022 11:43:22' prior: 50392914!
                       findString: subString startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	| arg startByteIndex byteIndex |
	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		subString isByteString ifTrue: [
			^String findString: subString in: bytes startingAt: start ].
		subString isUtf8String ifTrue: [
			^subString isAscii
				ifFalse: [ 0 ] "Won't be found, incudes non ASCII stuff, but we're ASCII"
				ifTrue: [ String findString: subString bytes in: bytes startingAt: start ]]].

	arg _ subString asUtf8BytesOrByteString.
	"Do UTF-8 encoding as needed."
	startByteIndex _ self byteIndexAt: start.
	byteIndex _ String findString: arg in: bytes startingAt: startByteIndex.
	^self codePointIndexAt: byteIndex! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 8/4/2022 11:42:58' prior: 50392654!
    findStringCaseInsensitive: subString startingAt: start
	"Answer the index in this String at which the substring key first occurs, at or beyond start.
	If no match is found, zero will be returned."

	"Fast lane. Use String implementation for ASCII only instances."
	self isAscii ifTrue: [
		subString isByteString ifTrue: [
			^String findStringIgnoreCase: subString in: bytes startingAt: start ].
		subString isUtf8String ifTrue: [
			^subString isAscii
				ifFalse: [ 0 ] "Won't be found, incudes non ASCII stuff, but we're ASCII"
				ifTrue: [ String findStringIgnoreCase: subString bytes in: bytes startingAt: start ]]].

"caseSensitive = false is very expensive. Do better."
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^self asLowercase findString: subString asLowercase startingAt: start! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5435-Utf8Fix-JuanVuletich-2022Aug04-11h42m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5435] on 5 August 2022 at 11:46:50 am'!
!SequenceableCollection methodsFor: 'converting' stamp: 'jmv 8/5/2022 11:41:43' prior: 50365874!
                 asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	^self! !
!String methodsFor: 'converting' stamp: 'jmv 8/5/2022 11:41:59' prior: 50365882!
     thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult"
	^ArrayOfCharactersAndCodePoints withAll: self! !
!ArrayOfCharactersAndCodePoints methodsFor: 'converting' stamp: 'jmv 8/5/2022 11:41:49' prior: 50365902 overrides: 50415243!
                 asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	^Utf8String newFrom: self! !
!Text methodsFor: 'converting' stamp: 'jmv 8/5/2022 11:41:52' prior: 50365907 overrides: 50415243!
                               asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	self setString: string asStreamResult setRuns: runs.
	^self! !
!Text methodsFor: 'converting' stamp: 'jmv 8/5/2022 11:46:29' prior: 50365912!
                 thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult	"
	string _ string thatCanHoldCodePoints! !
!LimitedWriteStream methodsFor: 'as yet unclassified' stamp: 'jmv 8/5/2022 11:45:40' prior: 16880795 overrides: 50365979!
                           nextPutAll: aCollection

	position + aCollection size > limit ifTrue: [
		super nextPutAll: (aCollection copyFrom: 1 to: (limit - position max: 0)).
		limitBlock value.
		^self
	].
	super nextPutAll: aCollection.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5436-LimitedWriteStream-fix-JuanVuletich-2022Aug05-11h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5436] on 5 August 2022 at 12:11:45 pm'!
!Utf32String methodsFor: 'copying' stamp: 'jmv 8/5/2022 12:11:26' prior: 50364123 overrides: 16934134!
                   , aStringOrText
	^ aStringOrText appendToString: self! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 8/5/2022 12:11:29' prior: 50380626 overrides: 16934134!
 , aStringOrText
	^ aStringOrText appendToString: self! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5437-Utf8String-fix-JuanVuletich-2022Aug05-12h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5437] on 5 August 2022 at 3:51:13 pm'!
!Debugger methodsFor: 'initialization' stamp: 'jmv 8/5/2022 15:51:00' prior: 50415087!
           openWindowLabel: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil
	"Create and schedule a full debugger, or just a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."

	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	"In case an error in Morphic code got us here, ensure mouse focus has been released"
	true runningWorld ifNotNil: [ :rWorld |
		rWorld activeHand ifNotNil: [ :aHand |
			aHand releaseMouseFocus ]].

	UISupervisor whenUIinSafeState: [
		"Suspend it as early as possible"
		interruptedProcess suspend.
		self openWindow2Label: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil ].
	"Ensure the Debugger is opened in a new UI process.
	This avoid unresponsive UI if the interruptedProcess is the UI current UI process, but also if the UI is busy, blocked or suspended."
	UISupervisor newUIProcess.
	"Suspend it as early as possible"
	interruptedProcess suspend.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5438-Debugger-fix-JuanVuletich-2022Aug05-15h51m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5438] on 6 August 2022 at 10:39:09 am'!
!CharacterSet class methodsFor: 'instance creation' stamp: 'jmv 8/6/2022 10:38:46' prior: 50379576!
                            ascii
	"return a set containing just all the 7 bit ASCII Characters"

	| set |
	set _ self new.
	0 to: 27 do: [ :ascii |
		set add: (Character numericValue: ascii) ].
	"Cuis Characters use 28, 29, 30, 31 for arrows.
	This behavior sould be removed when Cuis files are converted to use only UTF-8.
	See also #nextUtf8BytesAndCodePointInto:into:, #nonAscii and #isAscii:"
	32 to: 127 do: [ :ascii |
		set add: (Character numericValue: ascii) ].
	^set! !
!CharacterSet class methodsFor: 'instance creation' stamp: 'jmv 8/6/2022 10:38:42' prior: 50379585!
                        nonAscii
	"return a set containing all Characters that are not 7 bit ASCII"

	| set |
	set _ self new.
	"Cuis Characters use these for arrows.
	This behavior sould be removed when Cuis files are converted to use only UTF-8.
	See also #nextUtf8BytesAndCodePointInto:into:, #ascii and #isAscii:"
	28 to: 31 do: [ :ascii |
		set add: (Character numericValue: ascii) ].
	128 to: 255 do: [ :ascii |
		set add: (Character numericValue: ascii) ].
	^set! !
!String class methodsFor: 'services' stamp: 'jmv 8/6/2022 10:38:38' prior: 50379600!
          isAscii: aStringOrByteArray
	"Return true if all bytes in argument are less than 128.
	This means it is a pure 7-bit ASCII.
	Valid both for instances of String (possibly with accented latin letters or other Character)
	and for utf-8 encoded ByteArrays.
	In these cases, the bytes represent the same ascii string both as String and as Utf8.
	Note: Consider codes 28, 29, 30, 31 as non ascii, as they are used in Cuis for Unicode arrows.
	See also #nextUtf8BytesAndCodePointInto:into:, #ascii and #nonAscii"

	^ (String
		findFirstInString: aStringOrByteArray
		inSet: `(CharacterSet nonAscii) byteArrayMap`
		startingAt: 1)
			= 0! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 8/6/2022 10:38:36' prior: 50377814!
    nextUtf8BytesAndCodePointInto: bytesBlock into: codePointBlock
	"Find the next UTF-8 CodePoint from this file, assuming next byte is ISO 8859-15 if invalid UTF-8,
	or nil if at the end of the file."

	| bytesConsumed previousPosition |
	previousPosition _ self position.
	bytesConsumed _ 0.
	self nextByte ifNotNil: [ :byte1 |
		"Cuis 8 bit Characters use a nonstandard meaning for codes 28, 29, 30, 31.
		#utf8BytesAndCodePointAt:in:into:into: will treat any non-valid byte sequence as Cuis Characters.
		But this doesn't include codes 28, 29, 30, 31 that are valid ASCII bytes (and therefore, valid UTF-8).
		Consider them here, as this is needed to process legacy Cuis source code.
		This behavior sould be removed when Cuis files are converted to use only UTF-8.
		See also #ascii, #nonAscii and #isAscii:"
		(byte1 between: 28 and: 31)
			ifTrue: [
				Character
					utf8BytesAndCodePointFor: 226
					byte2: 134
					byte3: (byte1//2) + (byte1\\2*2) + 130
					byte4: nil
					into: bytesBlock
					into: codePointBlock.
				bytesConsumed _ 1 ]
			ifFalse: [
				bytesConsumed _ Character
					utf8BytesAndCodePointFor: byte1
					byte2: self nextByte
					byte3: self nextByte
					byte4: self nextByte
					into: bytesBlock
					into: codePointBlock ]].
	self position: previousPosition + bytesConsumed.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5439-CharacterArrows-areNot-ASCII-JuanVuletich-2022Aug06-10h35m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5440] on 8 August 2022 at 2:43:18 pm'!
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 8/8/2022 14:43:10' prior: 50400388!
     openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems.
	Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes entry msg wmsg |

	"Do not open source files if internalized (i.e. notNil)"
	sources _ SourceFiles at: 1.
	sources ifNil: [
		entry _ Smalltalk defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry _ Smalltalk alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources _ [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preferences at: #warnIfNoSourcesFile ])
		ifTrue: [
				msg _ 'Cuis cannot locate the sources file named ' , entry pathName, '.', String newLineString,
					'Please check that the file is properly named and is in the same directory as this image.'.
				Smalltalk platformName = 'Mac OS' ifTrue: [
					msg _ msg , String newLineString, 'Make sure the sources file is not an Alias.'].
			[
				(Delay forSeconds: 1) wait.
				self inform: msg
			] forkAt: Processor activePriority -1.
		].

	"Do not open source files if internalized (i.e. notNil)"
	changes _ (SourceFiles at: 2) ifNil: [ 
		entry _ Smalltalk defaultChangesName asFileEntry.
		[ entry appendStream ] on: FileWriteError do: [ nil ] ].
	(changes isNil and: [Preferences at: #warnIfNoChangesFile])
		ifTrue: [
			wmsg _ 'Cuis cannot write to the changes file named ' , entry pathName, '.', String newLineString, String newLineString,
				'Please check that you have write permission for this file.', String newLineString, String newLineString,
				'You won''t be able to save this image correctly until you fix this.'.
			[
				(Delay forSeconds: 1) wait.
				self inform: wmsg
			] forkAt: Processor activePriority -1 
		].
	ChangesInitialFileSize _ changes ifNotNil: [ changes position ].

	SourceFiles _ Array with: sources with: changes.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5440-AvoidFreezeOnMissingSources-JuanVuletich-2022Aug08-14h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5434] on 4 August 2022 at 4:20:39 pm'!
!TheWorldMenu class methodsFor: 'instance creation' stamp: 'hlsf 8/7/2022 12:48:06'!
                           getMenuIn: aWorld at: anActiveHand
	^ (self new :: world: aWorld 	hand: anActiveHand)
		buildWorldMenu! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'hlsf 8/4/2022 16:10:05' prior: 50394038!
                         prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'hlsf 8/4/2022 15:59:48' prior: 50403691!
                         installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	self sysPreferences

		name: #haloHandleSize 
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 5 // 3 max: 16];
	
		name: #roundedButtonRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 8 // 14];
		
		name: #roundedWindowRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize] ;
		
		name: #scrollbarThickness 
		category: #gui 		
		value: [(Preferences at: #windowTitleFont) pointSize + 2];
		
		name: #classFinder 
		category: #programming 
		value: [ BrowserWindow findClass ];
		
		name: #defaultAuthorName 
		category: #programming 
		value: [Utilities authorName];
		
		name: #worldMenu
		category: #system
		value: TheWorldMenu ! !
!WorldMorph methodsFor: 'world menu' stamp: 'hlsf 8/4/2022 16:20:07' prior: 50401646!
        invokeWorldMenu
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	| menu |
	menu _ (Preferences at: #worldMenu) getMenuIn: self at: self activeHand.
	menu popUpInWorld: self! !
!TheWorldMenu methodsFor: 'construction' stamp: 'hlsf 8/4/2022 16:08:32' prior: 16969916!
                           buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	^(DynamicMenuBuilder buildTargeting: self collectingMenuOptionsWith: #worldMenuOptions)
		addStayUpIcons;
		addTitle: 'World';
		yourself
	
	! !

TheWorldMenu class removeSelector: #getMenuIn:with:!

TheWorldMenu class removeSelector: #world:hand:!

PreferenceSet class removeSelector: #desktopMenuTitle!

!methodRemoval: PreferenceSet class #desktopMenuTitle stamp: 'Install-5441-WorldMenuPreferences-HilaireFernandes-2022Aug04-15h41m-hlsf.002.cs.st 9/14/2022 16:06:24'!
desktopMenuTitle
"I have project to get rid of this one"
	^ 'World'   !

"Postscript:
Install the the desktop menu title as a preference entry"
Preferences name: #worldMenu category: #system value: TheWorldMenu.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5441-WorldMenuPreferences-HilaireFernandes-2022Aug04-15h41m-hlsf.002.cs.st----!

'From Haver 6.0 [latest update: #5441] on 10 August 2022 at 2:54:53 pm'!
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'KLG 8/10/2022 14:50:03' prior: 16911485 overrides: 50387888!
                    mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	row _ self rowAtLocation: localEventPosition.

	row = 0 ifTrue: [
		^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
	scroller highlightedRow: row.

	w _ self owningWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Different from PluggableListMorph. There, we highlight on mouse down, and act on mouse up.
		Here, we act on mouse down, because we support dragging of selection, so mouse up will
		only happen after user is finished dragging. In order to get the highlight visible for the user,
		update the model on next world cycle."
		UISupervisor whenUIinSafeState: [
			"Set or clear new primary selection (listIndex)"
			dragOnOrOff == true
				ifTrue: [self setSelectionIndex: row]
				ifFalse: [self setSelectionIndex: 0].
			"Need to restore the old one, due to how model works, and set new one."
			oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
			self listSelectionAt: row put: dragOnOrOff ].
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: (
			aMouseButtonEvent shiftPressed ifFalse: [
				(self valueOfProperty: #allowsItemDrag) = true
						ifTrue: [ #dragEvent:localPosition: ] ifFalse: [ nil ] ])! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5442-DNDForPluggableListMorphOfMany-GeraldKlix-2022Aug09-18h29m-KLG.001.cs.st----!

'From Cuis 6.0 [latest update: #5442] on 10 August 2022 at 5:42:52 pm'!
!Debugger methodsFor: 'initialization' stamp: 'jar 8/10/2022 17:41:40' prior: 50415313!
               openWindowLabel: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil
	"Create and schedule a full debugger, or just a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."

	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	"In case an error in Morphic code got us here, ensure mouse focus has been released"
	self runningWorld ifNotNil: [ :rWorld |
		rWorld activeHand ifNotNil: [ :aHand |
			aHand releaseMouseFocus ]].

	UISupervisor whenUIinSafeState: [
		"Suspend it as early as possible"
		interruptedProcess suspend.
		self openWindow2Label: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil ].
	"Ensure the Debugger is opened in a new UI process.
	This avoid unresponsive UI if the interruptedProcess is the UI current UI process, but also if the UI is busy, blocked or suspended."
	UISupervisor newUIProcess.
	"Suspend it as early as possible"
	interruptedProcess suspend.! !
!UISupervisor class methodsFor: 'accessing' stamp: 'jar 8/6/2022 09:17:00' prior: 50407706 overrides: 50407714!
                    runningWorld
	"
	UISupervisor runningWorld
	[ UISupervisor runningWorld print ] fork
	"
	^self animatedUIOf: Processor activeProcess! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5443-runningWorld-cleanup-JaromirMatas-2022Aug10-17h40m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5443] on 13 August 2022 at 4:22:43 pm'!
!MouseClickState methodsFor: 'actions' stamp: 'jmv 8/13/2022 16:20:47' prior: 16897848!
                    handleEvent: aMouseEvent from: aHand
	"Process the given mouse event to detect a click, double-click, or drag.
	Return true if the event should be processed by the sender, false if it shouldn't.
	NOTE: This method heavily relies on getting *all* mouse button events."

	| timedOut distance |
	timedOut _ (aMouseEvent timeStamp - lastClickDown timeStamp) > self class doubleClickTimeout.
	timedOut ifTrue: [ aHand dontWaitForMoreClicks ].
	distance _ (aMouseEvent eventPosition - lastClickDown eventPosition) r.
	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.
	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."
	aMouseEvent isMouseDown ifTrue: [
		lastClickDown _ aMouseEvent.
		buttonDownCount _ buttonDownCount + 1 ].
	aMouseEvent isMouseUp ifTrue: [
		buttonUpCount _ buttonUpCount + 1 ].

	"Drag, or tap & hold"
	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [
		distance > 0 ifTrue: [
			aHand dontWaitForMoreClicks.
			dragSelector
				ifNotNil: [ self didDrag ]
				"If we have already moved, then it won't be a double or triple click... why wait?"
				ifNil: [ self didClick ].
			^ false ].
		timedOut ifTrue: [
			aHand dontWaitForMoreClicks.
			"Simulate button 2 via tap & hold. Useful for opening menus on pen computers."
			sendMouseButton2Activity ifTrue: [
				clickClient mouseButton2Activity ].
			^ false ]].

	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks (distance must be significant, the movement needs to be intentional)."
	(buttonDownCount = 4 or: [ timedOut or: [ distance > 2 ]]) ifTrue: [
		aHand dontWaitForMoreClicks.
		^ false ].

	"Simple click."
	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [
		self didClick ].

	"Click & hold"
	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [
		self didClickAndHalf ].

	"Double click."
	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [
		self didDoubleClick ].

	"Double click & hold."
	(buttonDownCount = 3 and: [ buttonUpCount = 2]) ifTrue: [
		self didDoubleClickAndHalf ].

	"Triple click"
	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [
		self didTripleClick ].

	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"
	^ aMouseEvent isMouseDown! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5444-FixForMissedDoubleClicks-JuanVuletich-2022Aug13-16h22m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5443] on 13 August 2022 at 4:50:18 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 8/13/2022 16:34:35'!
     invalidDrop: aDropEvent
	"A drag and drop operation was requested, but it was not accepted.
	Some morphs may want to do somthing in this case. Let them."! !
!InnerListMorph methodsFor: 'events-processing' stamp: 'jmv 8/13/2022 16:49:08' overrides: 50415878!
                              invalidDrop: aDropEvent
	"A drag and drop operation was requested, but it was not accepted.
	Usually the user just meant to click, and the small drag was unintended."

	| droppedMorph localPosition row |
	droppedMorph _ aDropEvent contents.
	((droppedMorph is: #DraggingGuideMorph) and: [
		(droppedMorph valueOfProperty: #dragSource) == owner]) ifTrue: [
			localPosition _ self internalizeFromWorld: aDropEvent eventPosition.
			row _ self rowAtLocation: localPosition ifNone: [].
			self selectedRow: row.
			aDropEvent wasHandled: true ].! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 8/13/2022 16:39:04' prior: 16844638 overrides: 16896679!
                    dispatchWith: aMorph
	"Drop is done on the innermost target that accepts it."
	| dropped |

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^#rejected ].

	"Go looking if any of our submorphs wants it"
	aMorph submorphsDo: [ :eachChild |
		(eachChild dispatchEvent: self) == #rejected ifFalse: [
			^self ]].

	(aMorph rejectsEvent: self) ifFalse: [
		aMorph allowsMorphDrop ifTrue: [
			"Do a symmetric check if both morphs like each other"
			dropped _ self contents.
			((aMorph wantsDroppedMorph: dropped event: self)	"I want her"
				and: [dropped wantsToBeDroppedInto: aMorph])		"she wants me"
					ifTrue: [ ^ self sendEventTo: aMorph ]].
		aMorph invalidDrop: self.
		wasHandled ifTrue: [
			self contents justDroppedInto: aMorph event: self.
			^self].
	].
	^#rejected! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5445-1-pixelDrop-means-click-JuanVuletich-2022Aug13-16h22m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5443] on 13 August 2022 at 5:05:56 pm'!

ListItemWrapper removeSelector: #acceptDroppingObject:!

!methodRemoval: ListItemWrapper #acceptDroppingObject: stamp: 'Install-5446-cleanup-JuanVuletich-2022Aug13-16h50m-jmv.001.cs.st 9/14/2022 16:06:24'!
acceptDroppingObject: anotherItem

	^item acceptDroppingObject: anotherItem!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5446-cleanup-JuanVuletich-2022Aug13-16h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5443] on 13 August 2022 at 4:46:06 pm'!
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 8/13/2022 16:39:04'!
                         moreMenuLabel

	^'more'! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 8/13/2022 16:42:45'!
                  classListMoreMenuOptions

	^ `{			
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'unsent methods'.
				#selector 		-> 		#browseUnusedMethods.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'browse all methods defined by this class that have no senders'
			} asDictionary.
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'unreferenced inst vars'.
				#selector 		-> 		#showUnreferencedInstVars.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'show a list of all instance variables that are not referenced in methods'
			} asDictionary.
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'unreferenced class vars'.
				#selector 		-> 		#showUnreferencedClassVars.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'show a list of all class variables that are not referenced in methods'
			} asDictionary.
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'subclass template'.
				#object 			-> 		#model.
				#selector 		-> 		#makeNewSubclass.
				#icon 			->			#classIcon.
				#balloonText 	-> 		'put a template into the code pane for defining of a subclass of this class'
			} asDictionary.
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			->			#instanceIcon.
				#balloonText 	-> 		'give me a sample instance of this class, if possible'
			} asDictionary.
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			->			#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class'
			} asDictionary.
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			->			#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class and of all of its subclasses'
			} asDictionary.
			{
				#submenuOf -> BrowserWindow moreMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'create inst var accessors'.
				#object 			-> 		#model.
				#selector 		-> 		#createInstVarAccessors.
				#icon 			->			#sendReceiveIcon.
				#balloonText 	-> 		'compile instance-variable access methods for any instance variables that do not yet have them'
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 8/13/2022 16:43:41' prior: 16797763!
              classListMenuOptions

	^ `{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 			-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'browse protocol (p)'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutClass.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		5.
				#label 			-> 		'show classes hierarchically'.
				#object 			-> 		#model.
				#selector 			-> 		#enableListClassesHierarchically.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		6.
				#label 			-> 		'show classes alphabetically'.
				#object 			-> 		#model.
				#selector 			-> 		#enableListClassesAlphabetically.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'show definition'.
				#object 			-> 		#model.
				#selector 			-> 		#editClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'show comment'.
				#object 			-> 		#model.
				#selector 			-> 		#editComment.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 			-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 			-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'class var refs...'.
				#selector 			-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'class vars'.
				#selector 			-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'class refs (N)'.
				#selector 			-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'rename class... (R)'.
				#object 			-> 		#model.
				#selector 			-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'copy class...'.
				#object 			-> 		#model.
				#selector 			-> 		#copyClass.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'remove class (x)'.
				#object 			-> 		#model.
				#selector 			-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		70.
				#itemOrder 			-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 			-> 		#runClassTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		70.
				#itemOrder 			-> 		20.
				#label 			-> 		BrowserWindow moreMenuLabel.
				#selector 			-> 		#yourself.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}, BrowserWindow classListMoreMenuOptions`.
	! !

BrowserWindow class removeSelector: #classListMenu2Options!

!methodRemoval: BrowserWindow class #classListMenu2Options stamp: 'Install-5447-ClassListMoreOptionsAsSubmenu-HernanWilkinson-2022Aug13-16h39m-HAW.001.cs.st 9/14/2022 16:06:24'!
classListMenu2Options

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'unsent methods'.
				#selector 		-> 		#browseUnusedMethods.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'browse all methods defined by this class that have no senders'
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'unreferenced inst vars'.
				#selector 		-> 		#showUnreferencedInstVars.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'show a list of all instance variables that are not referenced in methods'
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'unreferenced class vars'.
				#selector 		-> 		#showUnreferencedClassVars.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'show a list of all class variables that are not referenced in methods'
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'subclass template'.
				#object 			-> 		#model.
				#selector 		-> 		#makeNewSubclass.
				#icon 			->			#classIcon.
				#balloonText 	-> 		'put a template into the code pane for defining of a subclass of this class'
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			->			#instanceIcon.
				#balloonText 	-> 		'give me a sample instance of this class, if possible'
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			->			#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class'
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			->			#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class and of all of its subclasses'
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'create inst var accessors'.
				#object 			-> 		#model.
				#selector 		-> 		#createInstVarAccessors.
				#icon 			->			#sendReceiveIcon.
				#balloonText 	-> 		'compile instance-variable access methods for any instance variables that do not yet have them'
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu.
				#icon 			->			#listAddIcon.
				#balloonText 	-> 		'return to the standard class-list menu'
			} asDictionary.
		}`!

BrowserWindow removeSelector: #classListMenu2!

!methodRemoval: BrowserWindow #classListMenu2 stamp: 'Install-5447-ClassListMoreOptionsAsSubmenu-HernanWilkinson-2022Aug13-16h39m-HAW.001.cs.st 9/14/2022 16:06:24'!
classListMenu2
	"Set up the menu to apply to the receiver's class list when the shift key is down"

	^DynamicMenuBuilder buildTargeting: self collectingMenuOptionsWith: #classListMenu2Options.
	!

CodeWindow removeSelector: #offerClassListMenu!

!methodRemoval: CodeWindow #offerClassListMenu stamp: 'Install-5447-ClassListMoreOptionsAsSubmenu-HernanWilkinson-2022Aug13-16h39m-HAW.001.cs.st 9/14/2022 16:06:24'!
offerClassListMenu
	"Offer the shifted class-list menu."

	^ self classListMenu popUpInWorld!

CodeWindow removeSelector: #offerClassListMenu2!

!methodRemoval: CodeWindow #offerClassListMenu2 stamp: 'Install-5447-ClassListMoreOptionsAsSubmenu-HernanWilkinson-2022Aug13-16h39m-HAW.001.cs.st 9/14/2022 16:06:24'!
offerClassListMenu2
	"Offer the shifted class-list menu."

	^ self classListMenu2 popUpInWorld!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5447-ClassListMoreOptionsAsSubmenu-HernanWilkinson-2022Aug13-16h39m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5443] on 13 August 2022 at 5:25:29 pm'!
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 8/13/2022 16:51:47'!
    editingMenuLabel

	^'Editing'! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 8/13/2022 16:59:29'!
                    smalltalkEditorEditingMenuOptions
	
	^`{
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editingMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
		}`
! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 8/13/2022 16:59:33' prior: 16941186!
                         smalltalkEditorMenuOptions
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'Debug it (D)'.
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		60.
				#label 			-> 		'Profile it'.
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		5.
				#label 			-> 	SmalltalkEditor editingMenuLabel.
				#selector 		-> 		#yourself.
				#icon 			-> 		#textEditorIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}, SmalltalkEditor smalltalkEditorEditingMenuOptions `! !

SmalltalkEditor class removeSelector: #smalltalkEditorMenu2Options!

!methodRemoval: SmalltalkEditor class #smalltalkEditorMenu2Options stamp: 'Install-5448-SmalltalkEditorSubMenus-HernanWilkinson-2022Aug13-16h46m-HAW.001.cs.st 9/14/2022 16:06:24'!
smalltalkEditorMenu2Options
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`
!

SmalltalkEditor removeSelector: #openMenu2!

!methodRemoval: SmalltalkEditor #openMenu2 stamp: 'Install-5448-SmalltalkEditorSubMenus-HernanWilkinson-2022Aug13-16h46m-HAW.001.cs.st 9/14/2022 16:06:24'!
openMenu2
	
	self openMenu: self getMenu2
	!

SmalltalkEditor removeSelector: #openMenu!

!methodRemoval: SmalltalkEditor #openMenu stamp: 'Install-5448-SmalltalkEditorSubMenus-HernanWilkinson-2022Aug13-16h46m-HAW.001.cs.st 9/14/2022 16:06:24'!
openMenu
	
	self openMenu: self getMenu 
	!

SmalltalkEditor removeSelector: #getMenu2!

!methodRemoval: SmalltalkEditor #getMenu2 stamp: 'Install-5448-SmalltalkEditorSubMenus-HernanWilkinson-2022Aug13-16h46m-HAW.001.cs.st 9/14/2022 16:06:24'!
getMenu2
	
	^self createMenuCollectingOptionsWith: #smalltalkEditorMenu2Options!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5448-SmalltalkEditorSubMenus-HernanWilkinson-2022Aug13-16h46m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5448] on 15 August 2022 at 4:18:29 pm'!
!TestRunner methodsFor: 'menus' stamp: 'jmv 8/15/2022 16:17:04' prior: 16962535!
                            terminateRun
"
	running ifNotNil: [ running terminate. running _ nil ].
"
	running debugWithTitle: 'Interrupted Test'
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5449-TerminateOpensDebugger-JuanVuletich-2022Aug15-16h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5448] on 16 August 2022 at 11:23:54 am'!
!PositionableStream methodsFor: 'testing' stamp: 'jmv 8/16/2022 11:20:00'!
            atStart
	"Answer whether the receiver is at the start position."

	^position = 0.! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/16/2022 11:22:46' prior: 16801716!
                       scanUpTo: stopPosition informing: barBlock
	
	[
		file skipSeparators.
		file position < stopPosition
	] whileTrue: [	
		barBlock value: file position.
		"A line starting with $!! means a specific ChangeRecord type"
		((file atStart or: [ file peekBack isLineSeparator]) and: [ file peekFor: $!! ])
			ifTrue: [ self scanSpecificChangeRecordType]
			ifFalse: [ self scanDoIt ]]! !

ChangeList removeSelector: #scanSpecificChangeRecordTypeIfNotAtEnd:!

!methodRemoval: ChangeList #scanSpecificChangeRecordTypeIfNotAtEnd: stamp: 'Install-5450-ChangeList-fix-JuanVuletich-2022Aug16-10h56m-jmv.001.cs.st 9/14/2022 16:06:24'!
scanSpecificChangeRecordTypeIfNotAtEnd: prevChar

	(prevChar notNil and: [ prevChar isLineSeparator ]) ifTrue: [self scanSpecificChangeRecordType]!

ChangeList removeSelector: #notSeparatorChar!

!methodRemoval: ChangeList #notSeparatorChar stamp: 'Install-5450-ChangeList-fix-JuanVuletich-2022Aug16-10h56m-jmv.001.cs.st 9/14/2022 16:06:24'!
notSeparatorChar

	| prevChar |
	
	[file atEnd not and: [file peek isSeparator]] whileTrue: [prevChar _ file next].
	
	^prevChar!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5450-ChangeList-fix-JuanVuletich-2022Aug16-10h56m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5450] on 16 August 2022 at 11:57:10 am'!
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 8/16/2022 11:50:48'!
                               clickedAt: localEventPosition maybeDeselect: allowDeselecting
	"The mouse came up within the list; take appropriate action"
	"No change if model is locked"

	| row |
	row _ self rowAtLocation: localEventPosition.
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [ ^ self ]].
	(autoDeselect == false and:  [row = 0 ]) ifTrue: [ ^ self ].
	(autoDeselect and: [ row == self visualSelectionIndex ])
		ifTrue: [
			allowDeselecting ifTrue: [
				self setSelectionIndex: 0 ]]
		ifFalse: [ self setSelectionIndex: row ]! !
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 8/16/2022 11:51:54' overrides: 50415878!
                           invalidDrop: aDropEvent
	"A drag and drop operation was requested, but it was not accepted.
	Usually the user just meant to click, and the small drag was unintended."

	| droppedMorph localEventPosition |
	droppedMorph _ aDropEvent contents.
	((droppedMorph is: #DraggingGuideMorph) and: [
		(droppedMorph valueOfProperty: #dragSource) == self]) ifTrue: [
			localEventPosition _ self internalizeFromWorld: aDropEvent eventPosition.
			self clickedAt: localEventPosition maybeDeselect: true.
			aDropEvent wasHandled: true ].! !
!InnerListMorph methodsFor: 'events-processing' stamp: 'jmv 8/16/2022 11:52:56' prior: 50415887 overrides: 50415878!
                          invalidDrop: aDropEvent
	"A drag and drop operation was requested, but it was not accepted.
	Usually the user just meant to click, and the small drag was unintended."

	owner invalidDrop: aDropEvent.! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/16/2022 11:51:04' prior: 16910755 overrides: 16911870!
       mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"The mouse came up within the list; take appropriate action"

	self clickedAt: localEventPosition maybeDeselect: aMouseButtonEvent mouseButton1Changed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5451-ChangeSet5445WasBuggy-FixIt-JuanVuletich-2022Aug16-11h54m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5451] on 16 August 2022 at 8:48:42 pm'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 8/16/2022 20:44:22'!
     logStartupDebugAid: stuff
	"
	Transcript
		showOnDisplay: false;
		logToFile: true;
		logToStdout: true.
	Smalltalk at: #LogStartupDebugAids put: true.
	Smalltalk logStartupDebugAid: 'stuff'
	"
	self logStartupDebugAids ifTrue: [
		self logStartupError: stuff ].! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 8/16/2022 20:18:11'!
             logStartupDebugAids
	"
	Smalltalk logStartupDebugAids
	"
	^self at: #LogStartupDebugAids ifAbsent: false! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 8/16/2022 20:31:11'!
           logStartupError: stuff
	"
	Smalltalk logStartupError: 'stuff'
	"
	Transcript
		logToFile: true;
		logToStdout: true.
	stuff print ! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 8/16/2022 20:44:32' prior: 16955279!
                       snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
	"This is the main method for image save and / or quit.
	See senders."
	"WARNING: Current process will be killed. UI Process will be restarted"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic
	checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
	| activeProc |
	activeProc _ Processor activeProcess.
	[ | isARealStartup guiRootObject guiRootObjectClass |
	save not & quit
		ifTrue: [
			(SourceFiles at: 2) ifNotNil: [ :changes |
				ChangesInitialFileSize ifNotNil: [ changes truncate: ChangesInitialFileSize ]]]
		ifFalse: [
			self
				logSnapshot: save
				andQuit: quit ].
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each |
			each isInWorld ifTrue: [
				each delete.]].
		UISupervisor ui tearDownDesktop.
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.
	"These could be moved to some #shutDown"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	"Stuff needed to relaunch UI on startup"
	guiRootObjectClass _ UISupervisor ui class.
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [ activeProc terminate ].
	guiRootObject ifNotNil: [ guiRootObject releaseCachedState ].
	"Clean Globals"
	Smalltalk
		at: #Sensor
		put: nil.
	Smalltalk
		at: #Display
		put: nil.
	Smalltalk closeSourceFiles.
	Smalltalk
		at: #SourceFiles
		put: nil.
	Smalltalk allClassesDo: [ :cls |
		cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [
		Smalltalk allClassesDo: [ :cls |
			cls releaseClassState ]].
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [
		Smalltalk printStuffToCleanOnImageSave.
		"Remove this call to actually see the image clean report."
		Transcript clear.
		].
	"Do image save & quit as apropriate"
	(Cursor cursorAt: #writeCursor) activateCursor.
	save
		ifTrue: [
			"The snapshot primitive answers false if it was just called to do the snapshot.
			But image startup is resumed by returning (again) from the primitive, but this time answering true."
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].

	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk
		at: #Sensor
		put: nil.
	Smalltalk
		at: #Display
		put: DisplayScreen new.
	Smalltalk
		at: #SourceFiles
		put: (Array new: 2).
	self logStartupDebugAid: 'To #openSourceFiles'.
	Smalltalk openSourceFiles.
	"Here, startup begins!! (isARealStartup might be nil)"
	self logStartupDebugAid: 'To #initClassCachedState'.
	Smalltalk allClassesDo: [ :cls |
		cls initClassCachedState ].
	self logStartupDebugAid: 'To #doStartUp:'.
	self doStartUp: isARealStartup == true.
	self logStartupDebugAid: 'To #spawnNewMorphicProcessFor: ', guiRootObject printString.
	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ guiRootObjectClass newWorld ]).
	self logStartupDebugAid: 'To #restoreLostChangesIfNecessary'.
	self restoreLostChangesIfNecessary.
	clearAllStateFlag ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #recreateDefaultDesktop'.
			guiRootObject recreateDefaultDesktop; restoreDisplay ]]
	ifFalse: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #restoreDisplay'.
			guiRootObject restoreDisplay ]].
	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #processCommandLineArguments'.
			self processCommandLineArguments.
			self logStartupDebugAid: 'To #launchApp'.
			AppLauncher launchApp ]].
	"Now it's time to raise an error"
	isARealStartup ifNil: [ self logStartupError: 'Failed to write image file (disk full?)' ]]
		forkAt: Processor timingPriority - 1
		named: 'Startup process'.! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 8/16/2022 20:32:16' prior: 50415475!
                 openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems.
	Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes entry msg wmsg |

	"Do not open source files if internalized (i.e. notNil)"
	sources _ SourceFiles at: 1.
	sources ifNil: [
		entry _ Smalltalk defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry _ Smalltalk alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources _ [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preferences at: #warnIfNoSourcesFile ])
		ifTrue: [
				msg _ 'Cuis cannot locate the sources file named ' , entry pathName, '.', String newLineString,
					'Please check that the file is properly named and is in the same directory as this image.'.
				Smalltalk platformName = 'Mac OS' ifTrue: [
					msg _ msg , String newLineString, 'Make sure the sources file is not an Alias.'].
			self logStartupError: msg.
		].

	"Do not open source files if internalized (i.e. notNil)"
	changes _ (SourceFiles at: 2) ifNil: [ 
		entry _ Smalltalk defaultChangesName asFileEntry.
		[ entry appendStream ] on: FileWriteError do: [ nil ] ].
	(changes isNil and: [Preferences at: #warnIfNoChangesFile])
		ifTrue: [
			wmsg _ 'Cuis cannot write to the changes file named ' , entry pathName, '.', String newLineString, String newLineString,
				'Please check that you have write permission for this file.', String newLineString, String newLineString,
				'You won''t be able to save this image correctly until you fix this.'.
			self logStartupError: wmsg.
		].
	ChangesInitialFileSize _ changes ifNotNil: [ changes position ].

	SourceFiles _ Array with: sources with: changes.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5452-startupDebugAids-JuanVuletich-2022Aug16-20h46m-jmv.001.cs.st----!

'From Haver 6.0 [latest update: #5448] on 16 August 2022 at 9:03:11 pm'!
!FileList methodsFor: 'own services' stamp: 'KLG 8/16/2022 21:00:29' prior: 50389983!
               viewContentsInWorkspace
	"View the contents of my selected file in a new workspace"

	| aString aName |
	directory // fileName readStreamDo: [ :stream |
		stream ifNil: [^ 'For some reason, this file cannot be read'].
		aString _ stream upToEnd.
		aName _ stream localName ].

	(Workspace new contents: aString) 
		openLabel: 'Workspace from ', aName ::
			setProperty: #lastFilenameUsedToSave
			toValue: aName
		! !
!SystemWindow methodsFor: 'user interface' stamp: 'KLG 8/16/2022 20:56:47' prior: 16960050!
  saveContents
	"Prompts the user for a file name and saves the contents to the file"

	self hasSaveAs ifFalse: [ ^ self ].
	self
		request: 'Enter file name'
		initialAnswer: (self valueOfProperty: #lastFilenameUsedToSave ifAbsent: [ '' ])
		verifying: [ :aString |
			aString notEmpty ]
		do: [ :fileName |
			self saveContentsTo: fileName ].! !
!SystemWindow methodsFor: 'user interface' stamp: 'KLG 8/16/2022 20:51:21' prior: 50406046!
          saveContentsTo: fileName
	"Saves the contents to the given filename"

	self hasSaveAs ifFalse: [^self].
	fileName asFileEntry writeStreamDo: [ :stream |
		model saveOn: stream ].
	self 
		setProperty: #lastFilenameUsedToSave toValue: fileName;
		notifyUserWith: 'Contents saved'.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5453-RememberLastFilenameUsedForSaveAs-GeraldKlix-2022Aug16-10h56m-KLG.001.cs.st----!

'From Cuis 6.0 [latest update: #5453] on 17 August 2022 at 10:16:53 am'!
!SmalltalkEditor class methodsFor: 'menu' stamp: 'jmv 8/17/2022 10:16:46' prior: 50416305!
                  editingMenuLabel

	^'Edit'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5454-Edit-isTheCommonNameForThis-JuanVuletich-2022Aug17-10h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5434] on 16 August 2022 at 9:00:09 pm'!
!ContextPart methodsFor: 'private' stamp: 'jar 7/22/2022 21:49:53'!
           unwindAndStop: aProcess
	"I'm a helper method to #terminate; I create and answer
	 a helper stack for a terminating process to unwind itself from."

	^(ContextPart contextEnsure: [self unwindTo: nil]) 
		privSender: [aProcess suspend] asContext
! !
!SystemDictionary methodsFor: 'system attributes' stamp: 'eem 1/1/2022 17:39:00'!
                     processSuspensionUnblocks
	"Answer whether the suspend primitive backs up a process waiting on a
	 condition variable to before the send or not. The original behaviour was to
	 remove a process from its condition variable (Semaphore, Mutex; both kinds
	 of LinkedList).  Hence resuming would allow the process past the condition
	 variable, and hence required special behaviour in Process>>signalException:.
	 The new behaviour is to back up a blocked process one bytecode so that if
	 and when resumed it enters the wait state.  It also implies that the suspend
	 primitive answers nil if the process is blocked, and only answers a list when
	 suspending a runnable process that is not the active process.

	 To be clear, this method answers true on VMs with the old behaviour and
	  false on those with the new."

	^((self vmParameterAt: 65) ifNil: 0) noMask: 32! !
!Process methodsFor: 'changing process state' stamp: 'jar 8/15/2022 12:48:39'!
             suspendAndUnblock
	"ar 12/7/2007 17:10:
	 Primitive. Stop the process that the receiver represents in such a way 
	 that it can be restarted at a later time (by sending the receiver the 
	 message resume). If the receiver represents the activeProcess, suspend it. 
	 Otherwise remove the receiver from the list of waiting processes.
	 The return value of this method is the list the receiver was previously on (if any)."

	<primitive: 88 error: ec>
	"ar 12/7/2007 17:10:
	 This is fallback code for VMs which only support the old primitiveSuspend which 
	 would not accept processes that are waiting to be run."
	 ^myList ifNotNil: "this allows us to use suspend multiple times"
		[:oldList|
		 myList _ nil.
		 oldList remove: self ifAbsent: [].
		 oldList]! !
!Process methodsFor: 'private' stamp: 'jar 8/15/2022 12:47:58'!
      suspendAndReleaseCriticalSection
	"Figure out if we are terminating a process that is in the ensure: block of a critical section."

	| oldList |
	"Suspend and unblock the receiver from a condition variable using suspend primitive #88.
	 It answers the list the receiver was on before the suspension."
	oldList _ 	self suspendAndUnblock.
	suspendedContext ifNil: [^self].
	(oldList class == Semaphore and: [
		suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue: [
			suspendedContext _ suspendedContext home	]! !
!ContextPart methodsFor: 'private-exceptions' stamp: 'jar 7/22/2022 21:43:25' prior: 50333367!
       runUntilReturnFrom: aContext
	"Run the receiver (which must be a stack top context) until aContext returns. Avoid a context that cannot return. 
	Note: to avoid infinite recursion of MNU error inside unwind blocks, implement e.g. a wrapper around the message 
	sentTo: receiver in #doesNotUnderstand:. Note: This method was meant to be used exclusively by #unwindTo."

	| here unwindBottom newTop |
	here _ thisContext.
	"Avoid a context that cannot return (see Note 1 below)"
	unwindBottom _ self findContextSuchThat: [:ctx | ctx == aContext or: [ctx selector = #cannotReturn:]].
	newTop _ unwindBottom sender.
	"Insert ensure context under unwindBottom in self's stack (see Note 2 below)"
	unwindBottom insertSender: (self class contextEnsure: [here jump]).
	self jump.  "Control jumps to top (see Note 2 below)"
	"Control resumes here once the above inserted ensure block is executed"
	^newTop  "Return the new top context (see Note 3 below)"

	"Note 1: returning from #cannotReturn's sender would crash the VM so we install a guard ensure context right 
	above it and after returning here the unwind will continue safely. Try running and debugging this example 
	(avoid Proceeding the BCR error though; it may indeed crash the image):
	[[[] ensure: [^2]] ensure: [^42]] fork"

	"Note 2: the receiver is run by jumping directly to it (the active process abandons thisContext and executes 
	the receiver on its own stack; the receiver is its top context). However, before jumping to top we insert an ensure 
	block under unwindBottom context that will execute a jump back to thisContext when evaluated. The inserted 
	guard ensure context is removed once control jumps back to thisContext."

	"Note 3: it doesn't matter newTop is not a proper stack top context because #unwindTo will only use it as a starting 
	point in the search for the next unwind context and the computation will never return here. Cf. the pattern in 
	#runUntilErrorOrReturnFrom:: removing the inserted ensure context by stepping until popped when executing 
	non-local returns is not applicable here and would fail tests testTerminateInNestedEnsureWithReturn1 through 4."
! !
!ContextPart methodsFor: 'private-exceptions' stamp: 'jar 7/22/2022 21:38:54' prior: 50333438!
                         unwindTo: aContext

	| top ctxt outerMost |
	"If the receiver represents a block already halfways through an unwind, complete that unwind block
	first; if there are multiple such nested unwind blocks, try to complete the outer-most one; all nested 
	unwind blocks will be completed in the process; see tests in UnwindTest, testTerminationDuringUnwind. 
	Note: Halfway-through blocks have already set the complete variable (tempAt: 2) in their defining
	#ensure:/#ifCurtailed contexts from nil to true; we'll search for the bottom-most one.
	Note: #findNextUnwindContextUpTo: starts searching from the receiver's sender so we must check 
	whether the receiver itself is an unwind context as well; see testTerminateEnsureAsStackTop."
	ctxt _ top _ self.
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt:2) ifNotNil: [
			outerMost _ ctxt].
		ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	outerMost ifNotNil: [top _ top runUntilReturnFrom: outerMost].

	"By now no halfway-through unwind blocks are on the stack. Create a new top context for each 
	pending unwind block (tempAt: 1) and execute it on the unwind block's stack to execute non-local 
	returns correctly. Cf. the unwind pattern in #resume:through:. In #unwindTo, using #value instead of 
	#runUntilReturnFrom: would lead to an incorrect evaluation of non-local returns on the wrong stack. 
	Note: top points to the former outerMost sender now, i.e. to the next unexplored context."
	ctxt _ top ifNil: [^self].
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt: 2) ifNil: [
			ctxt tempAt: 2 put: true.
			top _ (ctxt tempAt: 1) asContextWithSender: ctxt.
			top runUntilReturnFrom: top].
		ctxt _ ctxt findNextUnwindContextUpTo: aContext]
! !
!DelayWaitTimeout methodsFor: 'signaling' stamp: 'jar 8/15/2022 14:24:26' prior: 16842010 overrides: 16841563!
               signalWaitingProcess
	"Release the given process from the semaphore it is waiting on.
	This method relies on running at highest priority so that it cannot be preempted
	by the process being released."
	beingWaitedOn := false.
	"Release the process but only if it is still waiting on its original list"
	process suspendingList == delaySemaphore ifTrue:[
		expired := true.
		process suspendAndUnblock; resume.
	].
! !
!Process methodsFor: 'changing process state' stamp: 'jar 8/15/2022 14:04:58' prior: 16917055!
suspend
	"eem 1/3/2022 10:38:
	 Primitive. Suspend the receiver, aProcess, such that it can be executed again
	 by sending #resume. If the given process is not the active process, take it off
	 its corresponding list. If the list was not its run queue assume it was on some
	 condition variable (Semaphore, Mutex) and back up its pc to the send that
	 invoked the wait state the process entered.  Hence when the process resumes
	 it will reenter the wait state. Answer the list the receiver was previously on iff
	 it was not active and not blocked, otherwise answer nil."

	<primitive: 578 error: ec>
	"This is fallback code for VMs which only support the old primitiveSuspend 88.
	 Note: in this case some tests may fail and some methods assuming the revised
	 suspend semantics described above may not work entirely as expected (e.g.
	 Context >> #releaseCriticalSection or Process >> #signalException)."
	 ^self suspendAndUnblock! !
!Process methodsFor: 'changing process state' stamp: 'jar 7/22/2022 22:22:22' prior: 50338000!
                        terminate 
	"Stop the process that the receiver represents forever. Unwind to execute pending ensure: and
	 ifCurtailed: blocks before terminating; allow all unwind blocks to run; if they are currently in
	 progress, let them finish. If the process is in the middle of a #critical: section, release it properly."
	
	"If terminating the active process, create a parallel stack and run unwinds from there;
	 if terminating a suspended process, create a parallel stack for the process being terminated
	 and resume the suspended process to complete its termination from the parallel stack. Use
	 a priority higher than the active priority to make the process that invoked the termination
	 wait for its completion."

	"If terminating a suspended process (including runnable or blocked), always suspend the 
	 terminating process first so it doesn't accidentally get woken up. Equally important is the
	 side effect of the suspension. In 2022 a new suspend semantics has been introduced:
	 the revised #suspend backs up a process waiting on a conditional variable to the send that
	 invoked the wait state, while the pre-2022 #suspend simply removed the process from
	 the conditional variable's list it was previously waiting on; figure out if we are terminating
	 the process while waiting in Semaphore>>critical:. In this case, pop the suspendedContext
	 so that we leave the ensure: block inside Semaphore>>critical: without signaling the semaphore.
	 Execute termination wrapped in #valueEnsured to ensure it completes even if the terminator
	 process itself gets terminated before it's finished; see testTerminateInTerminate."

	self isActiveProcess ifTrue: [
		^(thisContext unwindAndStop: self) jump].

	[	| terminator |
		self suspendAndReleaseCriticalSection.
		suspendedContext ifNil: [^self].
		terminator _ Semaphore new.
		suspendedContext bottomContext insertSender: (ContextPart contextEnsure: [terminator signal]).
		self suspendedContext: (suspendedContext unwindAndStop: self);
			priority: Processor activePriority;
			resume.
		terminator wait.
	] valueEnsured! !
!Process methodsFor: 'signaling' stamp: 'eem 6/27/2022 11:08:00' prior: 16917594!
             signalException: anException
	"Signal an exception in the receiver process...if the receiver is currently
	suspended, the exception will get signaled when the receiver is resumed.  If 
	the receiver is blocked on a Semaphore, it will be immediately re-awakened
	and the exception will be signaled; if the exception is resumed, then the receiver
	will return to a blocked state unless the blocking Semaphore has excess signals"

	"If we are the active process, go ahead and signal the exception"
	 self isActiveProcess ifTrue: [^anException signal].

	"One could raise an error here but that would force clients to employ a guard.
	 Since a terminated process can have no response to a signal (there is no
	 where for a handler to exist) it is legitimate to simply discard the signal."
	suspendedContext ifNil: [^self].

	"Suspend myself first to ensure that I won't run away
	 in the midst of the following modifications."
	self isSuspended ifFalse:
		[self suspend].

	"Add a new block context to the stack that will signal the exception (jar 6/27/2022)"
	suspendedContext _ 
		[anException signal. thisContext sender jump] asContextWithSender: suspendedContext.
	"Since this block is not called in a normal way, we need to take care
	that it doesn't directly return to the caller (because that could have 
	the potential to push an unwanted object on the caller's stack).
	Workspace example:
		p := [Semaphore new wait] fork.
		Processor yield.
		p signalException: Notification
	"
	^self resume! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5455-terminate-suspend-enhancements-JaromirMatas-2022Aug15-12h47m-jar.cs.st----!

'From Cuis 6.0 [latest update: #5454] on 17 August 2022 at 11:08:18 am'!
!Process methodsFor: 'test support' stamp: 'jar 8/17/2022 10:59:42' prior: 16917637!
                           suspendPrimitivelyOrFail
	"Test support. Execute primitive 578, or fail.
	(We used to call primitive 88, the old suspend primitive, replaced by 578 in 2022)"

	<primitive: 578 error: ec>
	^self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5456-suspendPrimitivelyOrFail-update-JaromirMatas-2022Aug17-10h59m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5454] on 17 August 2022 at 11:16:50 am'!

Process removeSelector: #pvtSignal:list:!

!methodRemoval: Process #pvtSignal:list: stamp: 'Install-5457-Cleanup-JaromirMatas-2022Aug17-11h08m-jar.001.cs.st 9/14/2022 16:06:24'!
pvtSignal: anException list: aList
	"Private. This method is used to signal an exception from another
	process...the receiver must be the active process.  If the receiver 
	was previously waiting on a Semaphore, then return the process
	to the waiting state after signaling the exception and if the Semaphore
	has not been signaled in the interim"

	"Since this method is not called in a normal way, we need to take care
	that it doesn't directly return to the caller (because I believe that could
	have the potential to push an unwanted object on the caller's stack)."

	| blocker |
	self isActiveProcess ifFalse: [^self].
	anException signal.
	blocker := Semaphore new.
	[self suspend.
	suspendedContext := suspendedContext swapSender: nil.
	aList class == Semaphore 
		ifTrue:
			[aList isSignaled
				ifTrue: 
					[aList wait.  "Consume the signal that would have restarted the receiver"
					self resume]
				ifFalse:
					["Add us back to the Semaphore's list (and remain blocked)"
					myList := aList.
					aList add: self]]
		ifFalse: [self resume]] fork.
	blocker wait.


!

Process removeSelector: #signal:!

!methodRemoval: Process #signal: stamp: 'Install-5457-Cleanup-JaromirMatas-2022Aug17-11h08m-jar.001.cs.st 9/14/2022 16:06:24'!
signal: anException
	"Signal an exception in the receiver process...if the receiver is currently
	suspended, the exception will get signaled when the receiver is resumed.  If 
	the receiver is blocked on a Semaphore, it will be immediately re-awakened
	and the exception will be signaled; if the exception is resumed, then the receiver
	will return to a blocked state unless the blocking Semaphore has excess signals"

	"If we are the active process, go ahead and signal the exception"
	self isRunning ifTrue: [^anException signal].

	"Add a new method context to the stack that will signal the exception"
	suspendedContext := MethodContext
		sender: suspendedContext
		receiver: self
		method: (self class methodDict at: #pvtSignal:list:)
		arguments: (Array with: anException with: myList).

	"If we are on a list to run, then suspend and restart the receiver 
	(this lets the receiver run if it is currently blocked on a semaphore).  If
	we are not on a list to be run (i.e. this process is suspended), then when the
	process is resumed, it will signal the exception"

	myList ifNotNil: [self suspend; resume].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5457-Cleanup-JaromirMatas-2022Aug17-11h08m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5457] on 17 August 2022 at 1:14:10 pm'!
!Process methodsFor: 'testing' stamp: 'jmv 8/17/2022 13:13:28' prior: 16917813!
                      isTerminated
	"Answer if the receiver is terminated. A process is considered terminated
	if the suspendedContext is the bottomContext and the pc is at the endPC"

	| ctx |
	self isRunning ifTrue: [^ false].
	suspendedContext isNil ifTrue: [ ^true ].
	suspendedContext isBottomContext ifTrue: [
		^suspendedContext isDead or: [suspendedContext atEnd] ].

	"This will only happen if prim 578 in #suspend fails because we are running on an old VM,
	and #suspendAndUnblock gets called"
	suspendedContext method == (Process>>#suspend) ifFalse: [^false].
	suspendedContext atEnd ifFalse: [^false].
	ctx _ suspendedContext sender.
	^ ctx isBottomContext and: [
		ctx isDead or: [ctx atEnd]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5458-isTerminated-fixForOlderVMs-JuanVuletich-2022Aug17-13h08m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5458] on 17 August 2022 at 3:39:48 pm'!
!Process methodsFor: 'testing' stamp: 'jmv 8/17/2022 15:38:56' prior: 50417612!
             isTerminated
	"Answer if the receiver is terminated. A process is considered terminated
	if the suspendedContext is the bottomContext and the pc is at the endPC,
	or if all sender context are at the endPC, up to the bottomContext."

	| ctx |
	self isRunning ifTrue: [^ false].
	suspendedContext isNil ifTrue: [ ^true ].
	ctx _ suspendedContext.
	[
		"Any context that can further run means we're not terminated"
		(ctx isDead or: [ctx atEnd]) ifFalse: [ ^false ].
		"But if we already checked the whole chain, we're done"
		ctx isBottomContext ifTrue: [ ^true ].
		ctx _ ctx sender ] repeat.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5459-isTerminated-cleaner-JuanVuletich-2022Aug17-15h12m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5324] on 12 July 2022 at 7:15:01 pm'!
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 7/12/2022 18:58:46'!
                              assertTemporaryIsNotAssignedAfterUsedInBlock
	
	| assignmentToTemporaryPositions |
	
	assignmentToTemporaryPositions := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodNode 
		thatMatch: [:assignmentRange | rangeOfNodeDeclaringTemporary includesAllOf: assignmentRange.].
	
	methodNode completeSourceRanges associationsDo: [:parseNodeAndRanges | (parseNodeAndRanges key isBlockNode 
		and: [parseNodeAndRanges value anySatisfy: [:range | (rangeOfNodeDeclaringTemporary includesAllOf: range) 
				and: [assignmentToTemporaryPositions anySatisfy: [:tempPosition | tempPosition first > range last]]]])
					ifTrue: [self class signalTemporaryAssignedAfterUsedInBlock]]
	
! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 7/12/2022 18:23:57'!
signalTemporaryAssignedAfterUsedInBlock

	^self refactoringError: (self temporaryAssignedAfterUsedInBlockErrorMessage)





! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 7/12/2022 18:24:47'!
            temporaryAssignedAfterUsedInBlockErrorMessage

	^'Temporary is assigned after being referenced in a block'.





! !
!InlineTemporaryVariable methodsFor: 'applying' stamp: 'FB 7/12/2022 18:52:14' prior: 50373286 overrides: 16923675!
                       apply
	
	self usageToInlineIsTemporaryDeclaration
		ifTrue: [self inlineFromTemporaryDeclaration]
		ifFalse: [self inlineFromNonDeclarationUsage].

	self compileChanges.

! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 7/12/2022 18:52:32' prior: 50373530!
                            inlineAssignment

	| endOfNextAssignmentIndex endOfRefactoringScopeIndex |

	endOfNextAssignmentIndex := self findLastIndexOfFirstAssignmentAfter: assignmentToInlineRange.
	self assertTemporaryIsNotAssignedAfterUsedInBlock.
	self computeEndOfNodeEnclosingAssignment.
	endOfRefactoringScopeIndex := endOfNextAssignmentIndex ifNil: [endOfNodeEnclosingAssignment ].
	"self halt".
	self inlineAssignment: assignmentToInlineRange upTo: endOfRefactoringScopeIndex.

	(self atMostOneAssignment and: [self noReferencesToTemporaryAfter: endOfRefactoringScopeIndex ])
		ifTrue: [self removeTemporaryVariableDeclaration].




! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 7/12/2022 19:07:10' prior: 50373551!
inlineAssignment: assignmentToInline upTo: anIndex

	| assignmentNode assignmentNodeValue expression expressionRange |

	assignmentNode := self assignmentNodeToInline: assignmentToInline.
	assignmentNodeValue := assignmentNode value.
	expressionRange := (methodNode completeSourceRangesOf: assignmentNodeValue ifAbsent: [self shouldNotHappen])
		detect: [:range | assignmentToInline includesAllOf: range].
	expression := methodNode sourceText copyFrom: expressionRange first to: expressionRange last.

	self inlineAssignmentNode: assignmentNode withExpression: expression upTo: anIndex;
		removeAssignment: assignmentToInline.! !
!InlineTemporaryVariableApplier class methodsFor: 'refactoring - creation' stamp: 'FB 7/5/2022 18:28:22' prior: 50391939!
                on: anEditor for: aSelectionInterval of: aMethodToRefactor

	| noTempFoundBlock tempToInline usageInterval |

	noTempFoundBlock := [
		"This case will usually end in a failure because a temporary variable is not related to the selected interval"
		tempToInline := anEditor wordUnder: aSelectionInterval first.
		usageInterval := aSelectionInterval.
	].
	
	anEditor
		withNodeUnderCursorDo: [:aNode | | methodNode sourceRanges |
			methodNode := aMethodToRefactor methodNode.
			sourceRanges := methodNode completeSourceRanges.
			(aNode isVariableNode and: [methodNode argumentNames noneSatisfy: [:argument | argument = aNode name]])
				ifTrue: [
					tempToInline := aNode name.
					usageInterval := self findSourceRangeOfNode: aNode containingIndex: anEditor startIndex using: sourceRanges.
				]
				ifFalse: [ | assignmentNodeAndRange |
					assignmentNodeAndRange := (methodNode parseNodesPathAt: aSelectionInterval first ifAbsent: 	[self shouldNotHappen.])
						detect: [:aNodeAndRange | aNodeAndRange key isAssignmentNode]
						ifNone: [noTempFoundBlock value].
					tempToInline ifNil: [
						tempToInline := assignmentNodeAndRange key variable name.
						usageInterval := self findLeftmostSourceRangeOfNode: assignmentNodeAndRange key variable
							inside: assignmentNodeAndRange value using: sourceRanges.
					]
				]
		]
		ifAbsent: [
			noTempFoundBlock value.
		].

	^self new initializeOn: anEditor codeProvider forTemporary: tempToInline
		at: usageInterval of: aMethodToRefactor ! !

InlineTemporaryVariable class removeSelector: #signalTemporaryUsedInBlockSurroundedWithAssignments!

!methodRemoval: InlineTemporaryVariable class #signalTemporaryUsedInBlockSurroundedWithAssignments stamp: 'Install-5460-InlineTempFix-FernandoBalboa-2022Jul04-21h21m-FB.001.cs.st 9/14/2022 16:06:24'!
signalTemporaryUsedInBlockSurroundedWithAssignments

	^self refactoringError: self temporaryUsedInBlockSurroundedWithAssignmentsErrorMessage
!

InlineTemporaryVariable class removeSelector: #temporaryUsedInBlockSurroundedWithAssignmentsErrorMessage!

!methodRemoval: InlineTemporaryVariable class #temporaryUsedInBlockSurroundedWithAssignmentsErrorMessage stamp: 'Install-5460-InlineTempFix-FernandoBalboa-2022Jul04-21h21m-FB.001.cs.st 9/14/2022 16:06:24'!
temporaryUsedInBlockSurroundedWithAssignmentsErrorMessage

	^'Temporary is used in block and has multiple assignments'.!

InlineTemporaryVariable removeSelector: #assertTemporaryNotUsedInBlockBetween:and:!

!methodRemoval: InlineTemporaryVariable #assertTemporaryNotUsedInBlockBetween:and: stamp: 'Install-5460-InlineTempFix-FernandoBalboa-2022Jul04-21h21m-FB.001.cs.st 9/14/2022 16:06:24'!
assertTemporaryNotUsedInBlockBetween: assignmentToInline and: anIndex

	| temporaryPositionsBetweenAssignmentAndIndex |

	temporaryPositionsBetweenAssignmentAndIndex := (methodNode consolidateAsCollection: (methodNode rangeForNode: oldVariableNode
		ifAbsent: [self shouldNotHappen ]))
			select: [:aPosition | aPosition first > assignmentToInline last and: [aPosition last < anIndex]].

	temporaryPositionsBetweenAssignmentAndIndex do: [:aPosition | ((methodNode parseNodesPathAt: aPosition first ifAbsent: [self shouldNotHappen])
		anySatisfy: [:aNodeAndRange | aNodeAndRange key isBlockNode
			and: [aNodeAndRange key ~= methodOrBlockNodeDeclaringTemporary ]
			and: [(aNodeAndRange value includesAllOf: rangeOfNodeDeclaringTemporary) not ]])
				ifTrue: [self class signalTemporaryUsedInBlockSurroundedWithAssignments]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5460-InlineTempFix-FernandoBalboa-2022Jul04-21h21m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5324] on 18 August 2022 at 7:35:44 pm'!
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 8/18/2022 19:06:13' prior: 50417674!
          assertTemporaryIsNotAssignedAfterUsedInBlock
	
	| assignmentToTemporaryPositions |
	
	assignmentToTemporaryPositions := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodNode 
		thatMatch: [:assignmentRange | rangeOfNodeDeclaringTemporary includesAllOf: assignmentRange.].
	
	methodNode completeSourceRanges associationsDo: [:parseNodeAndRanges | (parseNodeAndRanges key isBlockNode 
		and: [parseNodeAndRanges value anySatisfy: [:range | (rangeOfNodeDeclaringTemporary includesAllOf: range)
				and: [(methodNode positionsForTemporaryVariable: variableToInline ifAbsent: [#()]) 
					anySatisfy: [:tempReferenceInterval | range includesAllOf: tempReferenceInterval]]
				and: [assignmentToTemporaryPositions anySatisfy: [:tempAssignmentPosition | tempAssignmentPosition first > range last]]]])
					ifTrue: [self class signalTemporaryAssignedAfterUsedInBlock]]
	
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5461-InlineTempFix-FernandoBalboa-2022Jul12-19h15m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5461] on 20 August 2022 at 5:35:18 pm'!
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 8/20/2022 17:34:38'!
editMenuLabel

	^'Edit'! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 8/20/2022 17:34:38' prior: 50416309!
          smalltalkEditorEditingMenuOptions
	
	^`{
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#submenuOf -> SmalltalkEditor editMenuLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
		}`
! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 8/20/2022 17:34:38' prior: 50416422!
      smalltalkEditorMenuOptions
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'Debug it (D)'.
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		60.
				#label 			-> 		'Profile it'.
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		5.
				#label 			-> 	SmalltalkEditor editMenuLabel.
				#selector 		-> 		#yourself.
				#icon 			-> 		#textEditorIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}, SmalltalkEditor smalltalkEditorEditingMenuOptions `! !

SmalltalkEditor class removeSelector: #editingMenuLabel!

!methodRemoval: SmalltalkEditor class #editingMenuLabel stamp: 'Install-5462-EditMenuRecompile-HernanWilkinson-2022Aug20-17h34m-HAW.001.cs.st 9/14/2022 16:06:24'!
editingMenuLabel

	^'Edit'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5462-EditMenuRecompile-HernanWilkinson-2022Aug20-17h34m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5462] on 20 August 2022 at 7:36:21 pm'!
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 8/20/2022 19:33:29'!
                renameSystemCategory: oldName to: newName.

	"If it's a top category, rename subcategories first:"
	(self withSubCategoriesOf: oldName) reverseDo: [ :each |
		self renameCategory: each to: newName, (each allButFirst: oldName size)]
	! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 8/20/2022 19:16:16'!
        subCategoriesOf: aRootCategoryName

	^self categoriesMatching: (self subCategoriesPatternOf: aRootCategoryName)
	! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 8/20/2022 19:16:16'!
subCategoriesPatternOf: aRootCategoryName

	^ aRootCategoryName,'-*'! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 8/20/2022 19:34:51'!
             withSubCategoriesOf: aRootCategoryName

	"Returns the root category and subcategories if they exist
	The order is important because it is assumed like that in some senders
	If aRootCategoryName does not exist as category, it will return it anyway - Hernan"
	^(OrderedCollection with: aRootCategoryName) 
		addAll: (self subCategoriesOf: aRootCategoryName);
		yourself.
	
	! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 8/20/2022 19:14:35' prior: 50345201!
      removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 8/20/2022 19:30:35' prior: 50335118!
                         renameSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection
	
	21-Mar-2012 jmv Note: This is not recorded appropriately in change sets.
	The easiest solution is to trigger #classRecategorized for all classes in the category.
	But this is not a real solution, as the resulting changeset would not do a rename,
	but create a new category (that would go to the bottom) with all the classes.
	
	In the meantime, disable the menu entry. This is not so important after all.
	"
	| oldName newName |
	selectedSystemCategory ifNil: [^ self].  "no selection"
	oldName _ selectedSystemCategory.
	newName _ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName _ aString asSymbol.
			systemOrganizer renameSystemCategory: oldName to: newName.
			self setSelectedSystemCategory: newName.
			self changed: #systemCategoryRoots]! !
!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'HAW 8/20/2022 19:08:08' prior: 50359493!
  fileOutCategory: aCategoryRoot
	"FileOut all the classes in the named system category."

	DirectoryEntry smalltalkImageDirectory // (aCategoryRoot asFileName , '.st') writeStreamDo: [ :fileStream |
		(self withSubCategoriesOf: aCategoryRoot) do: [ :category | 
			self fileOutCategory: category on: fileStream initializing: true ]]! !
!SystemOrganizer methodsFor: 'remove' stamp: 'HAW 8/20/2022 19:15:35' prior: 16958824!
                          removeSystemCategory: category
	"remove all the classes associated with the category and its subcategories.
	If category does not exist, it does nothing"

	(self withSubCategoriesOf: category) reverseDo: [ :categoryToRemove |
		(self superclassOrderIn: categoryToRemove) reverseDo: [ :class | class removeFromSystem].
		self removeCategory: categoryToRemove ]! !

SystemOrganizer removeSelector: #withAllSubCategoriesOf:!

SystemOrganizer removeSelector: #removeCategoriesMatching:!

!methodRemoval: SystemOrganizer #removeCategoriesMatching: stamp: 'Install-5463-SystemOrganizerImprovement-HernanWilkinson-2022Aug20-18h49m-HAW.001.cs.st 9/14/2022 16:06:24'!
removeCategoriesMatching: matchString
	"Remove all matching categories with their classes"
	(self categoriesMatching: matchString) do:
		[:c | self removeSystemCategory: c]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5463-SystemOrganizerImprovement-HernanWilkinson-2022Aug20-18h49m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5463] on 21 August 2022 at 8:19:11 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5464-CategorizationOfRemoveSystemCategory-HernanWilkinson-2022Aug21-20h16m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5464] on 22 August 2022 at 8:44:14 am'!
!InstructionStream methodsFor: 'decoding' stamp: 'jmv 8/22/2022 08:36:54'!
atEnd: aPC

	^ aPC > self method endPC! !
!ContextPart methodsFor: 'query' stamp: 'jmv 8/22/2022 08:40:24'!
                    isDeadOrAtEnd
	"Doing
	aMethodContext isDead or: [aMethodContext isAtEnd]
	can occasionally break. It is possible for pc to become nil in between the calls."

	^ pc
		ifNil: [ true ]
		ifNotNil: [ :aPC | self atEnd: pc ]! !
!MethodContext methodsFor: 'testing' stamp: 'jmv 8/22/2022 08:37:03' overrides: 50418328!
      atEnd: aPC
	^ self isExecutingBlock
		ifTrue: [ self closure startpc + self closure size - 1 = aPC ]
		ifFalse: [ aPC >= self method endPC ]! !
!InstructionStream methodsFor: 'decoding' stamp: 'jmv 8/22/2022 08:37:22' prior: 16873353!
                     atEnd

	^ self atEnd: pc! !
!InstructionStream methodsFor: 'scanning' stamp: 'jmv 8/22/2022 08:35:06' prior: 16873472!
         peekInstruction
	"Return the next bytecode instruction as a message that an InstructionClient would understand.  The pc remains unchanged."

	| currentPc instr |
	currentPc _ pc.
	instr _ self nextInstruction.
	pc _ currentPc.
	^ instr! !
!Process methodsFor: 'testing' stamp: 'jmv 8/22/2022 08:40:59' prior: 50417644!
 isTerminated
	"Answer if the receiver is terminated. A process is considered terminated
	if the suspendedContext is the bottomContext and the pc is at the endPC,
	or if all sender context are at the endPC, up to the bottomContext."

	| ctx |
	self isRunning ifTrue: [^ false].
	suspendedContext isNil ifTrue: [ ^true ].
	ctx _ suspendedContext.
	[
		"Any context that can further run means we're not terminated"
		ctx isDeadOrAtEnd ifFalse: [ ^false ].
		"But if we already checked the whole chain, we're done"
		ctx isBottomContext ifTrue: [ ^true ].
		ctx _ ctx sender ] repeat.! !

MethodContext removeSelector: #atEnd!

!methodRemoval: MethodContext #atEnd stamp: 'Install-5465-isTerminated-fix-JuanVuletich-2022Aug22-08h34m-jmv.001.cs.st 9/14/2022 16:06:25'!
atEnd
	^ self isExecutingBlock
		ifTrue: [ self closure startpc + self closure size - 1 = self pc ]
		ifFalse: [ self pc >= self method endPC ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5465-isTerminated-fix-JuanVuletich-2022Aug22-08h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5463] on 22 August 2022 at 12:34:06 pm'!
!Debugger class methodsFor: 'opening' stamp: 'HAW 8/22/2022 12:31:12' prior: 50414791!
                   openContext: aContext label: label preDebugMessage: contentsStringOrNil
	"Open a notifier (a PreDebugWindow) in response to an error, halt, or notify.
	A PreDebugWindow just shows a short view of the sender stack and provides a menu that lets the user open a full debugger.
	The context argument is in the active process stack."

	| debugger |
	<primitive: 19> "Simulation guard"

	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk logError: label inContext: aContext to: 'CuisDebug'].
	self informExistingDebugger: aContext label: label.

	debugger _ self new.
	debugger 		process: Processor activeProcess context: aContext.
	debugger openWindowLabel: label usePreDebugWindow: true preDebugMessage: contentsStringOrNil.! !
!Debugger class methodsFor: 'opening' stamp: 'HAW 8/22/2022 11:57:45' prior: 50413146!
       openDebugging: aBlock to: aCompiledMethod label: aString
	"Create a new process to debug aBlock, and step into it."

	| processToDebug debugger |
	debugger _ self new.
	processToDebug _ aBlock newProcess name: 'debugIt'.
	debugger process: processToDebug context: processToDebug suspendedContext.
	debugger openFullMorphicLabel: aString.
	[debugger interruptedContext method == aCompiledMethod]
		whileFalse: [debugger send]! !
!Debugger class methodsFor: 'opening' stamp: 'HAW 8/22/2022 12:31:03' prior: 50415128!
                             openProcess: process context: context label: labelString
	"Open a Debugger on an existing process."

	| debugger logFile label |
	<primitive: 19> "Simulation guard"
	label _ labelString,
					' - Process: ', process name,
					' - Priority: ', process priority printString.
	(Preferences at: #logDebuggerStackToFile) ifTrue: [
		logFile _ 'CuisDebug'.
		(labelString beginsWith: 'Space is low')
			ifTrue: [logFile _ 'LowSpaceDebug'].
		Smalltalk logError: label inContext: context to: logFile ].

	debugger _ self new.
	debugger process: process context: context.
	debugger openWindowLabel: label usePreDebugWindow: false preDebugMessage: nil.
	"
[1/0] fork.
5 seconds asDelay wait.
self error: 'error'.
	"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5466-DebuggerAsSelfOnClassMethods-HernanWilkinson-2022Aug21-20h19m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5466] on 25 August 2022 at 9:29:48 am'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 8/25/2022 09:29:22' prior: 16957933!
         processCommandLineArgument: rawArgStream storeStartUpScriptArgsOn: startUpScriptArgs
	"
	Smalltalk processCommandLineArguments
	
	A possible example (duplicated single quotes: '' should be double quotes, but not allowed in a Smalltalk comment):
	Squeak.exe Cuis4.2-2211x.image -r RequiredFeature1 -rRequiredFeature2 -d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine'' -s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parametro al script ->>>--// 3''
	"
	| p data entry |
	p _ rawArgStream next.

	(p size > 1 and: [p first = $-]) ifTrue: [
		"If the command is not included in p, it is next argument"
		p size = 2
			ifTrue: [
				"as in 		-r RequiredFeature1"
				data _ rawArgStream next ]
			ifFalse: [
				"as in 		-rRequiredFeature2"
				data _ p copyFrom: 3 to: p size ].
		p second caseOf: {
			[ $r ] -> [		"as in 		-rRequiredFeature2"
				{ 'Feature require: '. data } print.
				[ Feature require: data ] on: UnhandledError do: [:ex | ex return] ].
			[ $d ] -> [		"as in 		-d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine''        (duplicated singleQuotes should read doubleQuote)"
				{ 'Compiler evaluate: '. data } print.
				[ Compiler evaluate: data ] on: UnhandledError do: [:ex | ex return] ].
			[$l ] -> ["file in the file"
				{ 'File in: '. data} print.
				[(CodeFile newFromFile: data asFileEntry) fileIn] on: UnhandledError do: [:ex | ex return]].
			[ $s ] -> [		"as in 		-s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parametro al script ->>>--// 3'' 			(duplicated singleQuotes should read doubleQuote)"
				[ rawArgStream atEnd ] whileFalse: [
					startUpScriptArgs nextPut: rawArgStream next ].
				"Can use 'Smalltalk startUpScriptArguments' inside the startUp script
				{ 'Compiler evaluate contents of file named: '. data. ' arguments: '. Smalltalk startUpScriptArguments } print."
				entry _ data asFileEntry.
				entry exists ifTrue: [
					entry readStreamDo: [ :stream |
						[ Compiler evaluate: stream contentsOfEntireFile ] on: UnhandledError do: [:ex | ex return]]].
				"Maybe we decide to clear them after startup script execution
				startUpScriptArguments _ nil" ]
		}
		otherwise: []
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5467-commandLineArgsProc-fix-JuanVuletich-2022Aug25-09h29m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5467] on 6 September 2022 at 9:24:09 am'!
!Character methodsFor: 'printing' stamp: 'jmv 9/6/2022 09:05:00' prior: 16808298 overrides: 16902975!
      printOn: aStream 
	aStream nextPut: $$.
	aStream nextPut: self.
	self isAlphaNumeric ifFalse: [
		aStream nextPut: $(.
		aStream nextPutAll: self hex.
		aStream nextPut: $) ].! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 9/6/2022 09:03:28' prior: 50389333 overrides: 16902975!
printOn: aStream 
	aStream nextPut: $$.
	self asCharacter ifNotNil: [ :c | aStream nextPut: c ].
	aStream nextPut: $(.
	aStream nextPutAll: self hex.
	aStream nextPut: $).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5468-Character-UnicodeCodePoint-better-printOn-JuanVuletich-2022Sep06-09h23m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5467] on 6 September 2022 at 9:24:57 am'!
!ArrayOfCharactersAndCodePoints methodsFor: 'converting' stamp: 'jmv 9/6/2022 09:16:55'!
                     encompassLine: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| left rightCr rightNull |
	left _ (self lastIndexOf: `Character newLineCharacter` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (self indexOf: `Character newLineCharacter` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	rightNull _ (self indexOf: `Character null` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	^left to: (rightCr min: rightNull)! !
!ArrayOfCharactersAndCodePoints methodsFor: 'converting' stamp: 'jmv 9/4/2022 00:04:58'!
            encompassParagraph: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| left rightCr rightNull |
	left _ (self lastIndexOf: `Character newLineCharacter` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (self indexOf: `Character newLineCharacter` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size]).
	rightNull _ (self indexOf: `Character null` startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.
	^left to: (rightCr min: rightNull)! !
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 9/6/2022 09:19:53' prior: 50387003!
  encompassLine: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte left nullPosition right |
	argumentLeftByte _ self byteIndexAt: aCodePointInterval first.
	argumentRightByte _ self byteIndexAt: aCodePointInterval last.

	"Find byte position and code point position following last newLine before us."
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent: [0]) + 1.
	left _ self codePointIndexAt: leftByte.

	"Find byte position and code point position for next newLine. Don't include it."
	right _ count.
	rightCrByte _ bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte).
	rightCrByte = 0 ifFalse: [
		right _ (self codePointIndexAt: rightCrByte)-1].

	"But stop before if any nulls. Don't include them!!"
	nullPosition _ bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte).
	nullPosition = 0 ifFalse: [
		right _ right min: ((self codePointIndexAt: nullPosition)-1) ].

	^left to: right! !
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 9/6/2022 09:10:44' prior: 50387038!
                  encompassParagraph: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte left nullPosition right |
	argumentLeftByte _ self byteIndexAt: aCodePointInterval first.
	argumentRightByte _ self byteIndexAt: aCodePointInterval last.

	"Find byte position and code point position following last newLine before us."
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent: [0]) + 1.
	left _ self codePointIndexAt: leftByte.

	"Find byte position and code point position for next newLine. Include it."
	right _ count.
	rightCrByte _ bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte).
	rightCrByte = 0 ifFalse: [
		right _ self codePointIndexAt: rightCrByte].

	"But stop before if any nulls. Don't include them!!"
	nullPosition _ bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte).
	nullPosition = 0 ifFalse: [
		right _ right min: ((self codePointIndexAt: nullPosition)-1) ].

	^left to: right! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5469-UTF8-encompassParagraphAndLineFix-JuanVuletich-2022Sep06-09h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5469] on 6 September 2022 at 9:41:55 am'!
!BlockClosure methodsFor: 'private' stamp: 'jmv 9/6/2022 09:41:25' prior: 16791595!
                              grabProcessorFor: milliseconds onTimeout: timeoutBlock
	"Evaluate the receiver (block), without the possibility of preemption by regular priority processes.
	If not finished after milliseconds, evaluate timeoutBlock and restore original priority.
	Use with care!!"
	"Based on #valueUnpreemptively"
	
	| activeProcess oldPriority result done |
	activeProcess _ Processor activeProcess.
	oldPriority _ activeProcess priority.
	done _ false.
	
	activeProcess priority: Processor highIOPriority + Processor lowIOPriority // 2.
	milliseconds ifNotNil: [
		[
			(Delay forMilliseconds: milliseconds) wait.
			done ifFalse: [
				activeProcess
					suspend;
					priority: oldPriority.
				timeoutBlock value.
				"The timeoutBlock might terminate it, or even resume it!!"
				activeProcess isSuspended ifTrue: [
					activeProcess resume ]]
		] forkAt: Processor highIOPriority named: '#grabProcessorFor:onTimeout:' ].

	result _ self ensure: [
		done _ true.
		activeProcess priority: oldPriority].
	
	"Yield after restoring priority to give the preempted processes a chance to run"
	Processor yield.
	^result! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5470-grabProcessor-tweak-JuanVuletich-2022Sep06-09h39m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5470] on 6 September 2022 at 9:58:02 am'!
!Debugger methodsFor: 'initialization' stamp: 'jmv 9/6/2022 09:57:18' prior: 50415733!
        openWindowLabel: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil
	"Create and schedule a full debugger, or just a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."

	| safeBlockAlreadyRan |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor defaultCursor activateCursor.
	"In case an error in Morphic code got us here, ensure mouse focus has been released"
	self runningWorld ifNotNil: [ :rWorld |
		rWorld activeHand ifNotNil: [ :aHand |
			aHand releaseMouseFocus ]].

	safeBlockAlreadyRan _ false.
	UISupervisor whenUIinSafeState: [
		safeBlockAlreadyRan _ true.
		"Suspend it as early as possible"
		interruptedProcess suspend.
		self openWindow2Label: label usePreDebugWindow: bool preDebugMessage: preDebugMessageOrNil ].
	"Ensure the Debugger is opened in a new UI process.
	This avoid unresponsive UI if the interruptedProcess is the UI current UI process, but also if the UI is busy, blocked or suspended."
	UISupervisor newUIProcess.
	"Suspend it as early as possible"
	safeBlockAlreadyRan ifFalse: [
		interruptedProcess suspend ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5471-Debugger-fix-JuanVuletich-2022Sep06-09h53m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5460] on 27 August 2022 at 12:27:01 am'!
!ContextPart methodsFor: 'query' stamp: 'jar 8/27/2022 00:26:17'!
     isDone
	"Answer if the receiver has no unexecuted code left."

	self isDead ifTrue: [^true].
	self isBottomContext ifTrue: [^self atEnd].
	self atEnd ifTrue: [^self sender isDone].
	^false! !
!Process methodsFor: 'testing' stamp: 'jar 8/26/2022 18:17:14' prior: 50418364!
                isTerminated
	"Answer if the receiver is terminated. A healthy process is considered 
	 terminated if the suspendedContext has no unexecuted code left."

	self isRunning ifTrue: [^ false].
	^suspendedContext isNil or: [suspendedContext isDone]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5472-better-isTerminated-JaromirMatas-2022Aug26-18h17m-jar.isTerminated.cs.st----!

'From Cuis 6.0 [latest update: #5472] on 6 September 2022 at 10:09:33 pm'!
!Inspector methodsFor: 'constants' stamp: 'jmv 9/6/2022 22:05:01' prior: 16871898!
                               printStringLimit

	^4000! !
!Character methodsFor: 'printing' stamp: 'jmv 9/6/2022 22:01:14' prior: 50418559 overrides: 16902975!
                              printOn: aStream 
	aStream nextPut: $$.
	aStream nextPut: self.
	self numericValue <= 32 ifTrue: [
		aStream nextPut: $(.
		aStream nextPutAll: self hex.
		aStream nextPut: $) ].! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 9/6/2022 21:56:28' prior: 50389327 overrides: 16902865!
                             isLiteral
self flag: #unicodeNeedsImprovement.
"If #storeOn: calls
	self asCharacter ifNotNil: [ :c | c storeOn: aStream ].
then this method can be
	^ self asCharacter notNil
or
	self asCharacter ifNotNil: [ :c | ^c isLiteral ].
	^false
"
	^super isLiteral! !
!Array methodsFor: 'printing' stamp: 'jmv 9/6/2022 21:49:02' prior: 16780933 overrides: 16781394!
                          storeOn: aStream 
	"Use the literal form if possible."

	self isLiteral
		ifTrue: [
			aStream nextPut: $#; nextPut: $(.
			self do: [ :element | 
				element storeOn: aStream.
				aStream space].
			aStream nextPut: $)]
		ifFalse: [super storeOn: aStream]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5473-Array-storeOn-fix-betterCharacter-printOn-JuanVuletich-2022Sep06-22h08m-jmv.001.cs.st----!

'From Haver 6.0 [latest update: #5466] on 25 August 2022 at 9:16:55 pm'!
!MenuItemMorph methodsFor: 'events' stamp: 'KLG 8/25/2022 21:11:47' overrides: 16892263!
 mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition
	"Create a copy of me or my submenu."

	aMouseButtonEvent shiftPressed ifTrue: [
		subMenu
			ifNil: [ self duplicate ]
			ifNotNil: [
				(subMenu duplicate)
					addTitle: contents;
					addStayUpIcons;
					stayUp;
					adjustSubmorphsLayout;
					yourself ] ::
						openInHand ].
	^ super mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5474-DuplicateMenuStuffOnShiftMouseButton2-GeraldKlix-2022Aug24-21h33m-KLG.001.cs.st----!

'From Cuis 6.0 [latest update: #5473] on 7 September 2022 at 9:26:37 am'!
!UserInputEvent methodsFor: 'printing' stamp: 'jmv 9/7/2022 09:17:45' overrides: 16902975!
                   printOn: aStream
	super printOn: aStream.
	aStream
		nextPut: $(;
		print: buttons;
		nextPut: $)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5475-Better-Event-printOn-JuanVuletich-2022Sep07-09h26m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5473] on 7 September 2022 at 9:28:13 am'!
!HaloMorph methodsFor: 'event handling' stamp: 'KLG 9/7/2022 09:27:35' prior: 16864621!
                     popUpFor: aMorph handPosition: handPosition hand: hand

	hand halo: self.
	hand world addMorphFront: self.
	self target: aMorph.
	positionOffset _ handPosition - aMorph morphPositionInWorld.
	hand newMouseFocus: self.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5476-HalosGrabMouseFocus-GeraldKlix-2022Sep07-09h26m-KLG.001.cs.st----!

'From Cuis 6.0 [latest update: #5476] on 7 September 2022 at 9:59:35 am'!
!Object methodsFor: 'copying' stamp: 'jmv 9/7/2022 09:58:22' prior: 16901961!
          postCopy
	"self is a shallow copy, subclasses should copy fields as necessary to complete the full copy.
	Also clear any ivars that should be initialized lazyly."

	^ self! !
!Object methodsFor: 'copying' stamp: 'jmv 9/7/2022 09:55:04' prior: 16901987!
   veryDeepCopy
	"Do a full copy of an object graph.
	Some classes might chose not to include some ivars.
	For example, aMorph owner is only included 'weakely'.
	See #storeDataOn:, and in particular Morph>>storeDataOn:
	
	This method is included for comatibility with other Smalltalks and for reference.
	Each class should decide how to copy its instances.
	For example, Morph>>copy.
	Implementing #copy appropriately, and just calling it is better style than calling #veryDeepCopy (except, maybe, in low level, system code)"

	^ Object unStream: (ReferenceStream streamedRepresentationOf: self)! !
!Morph methodsFor: 'fileIn/out' stamp: 'jmv 9/7/2022 09:56:50' prior: 16892907 overrides: 16902803!
        storeDataOn: aDataStream
	"Let all Morphs be written out.  All owners are weak references.  They only go out if the owner is in the tree being written."
	| cntInstVars cntIndexedVars ti instVarNames |

	"block my owner unless he is written out by someone else"
	cntInstVars _ self class instSize.
	cntIndexedVars _ self basicSize.
	instVarNames _ self class allInstVarNames.
	ti _ 1.  
	((instVarNames at: ti) = 'owner') & (Morph superclass == Object) ifFalse: [
		self error: 'this method is out of date'].
	aDataStream
		beginInstance: self class
		size: cntInstVars + cntIndexedVars.
	1 to: cntInstVars do: [ :i |
		(instVarNames at: i) caseOf: {
				['owner']  					-> [aDataStream nextPutWeak: owner]. 	"owner only written if in our tree"
				['id']  					-> [ aDataStream nextPut: (id bitAnd: 255) ].  "Clear id, but keep flags."
				['privateDisplayBounds']					-> [ aDataStream nextPut: nil ].  "Lazy initialized."
			}
			otherwise: [ aDataStream nextPut: (self instVarAt: i)]].
	1 to: cntIndexedVars do: [ :i |
		aDataStream nextPut: (self basicAt: i)]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5477-Morph-duplicate-fix-JuanVuletich-2022Sep07-09h58m-jmv.001.cs.st----!

'From Haver 6.0 [latest update: #5477] on 8 September 2022 at 2:52:20 pm'!
!CodeWindow methodsFor: 'menu commands' stamp: 'KLG 9/8/2022 14:35:49'!
browseHierarchyAndReplaceMe
	"Create and schedule a new hierarchy browser on the currently selected class or meta.
	Resize and position it over me and dismiss me."

	model hierarchyBrowser ifNotNil: [ :newBrowser | | newBrowserWindow |
		newBrowserWindow _ HierarchyBrowserWindow
			openNoSysCat: newBrowser
			label: newBrowser labelString.
		newBrowser assureSelectionsShow.
		newBrowserWindow
			morphPositionInWorld: self morphPositionInWorld;
			morphExtentInWorld: self morphExtentInWorld.
		self dismissMorph ]! !
!CodeWindow methodsFor: 'menu commands' stamp: 'KLG 9/8/2022 14:27:42'!
               browseMethodFullAndReplaceMe
	"Create and schedule a full Browser and then select the current class and message.
	Resize and position it over me and dismiss me."

	model selectedClassOrMetaClass ifNotNil: [ :myClass | | newBrowserWindow |
		newBrowserWindow _ BrowserWindow
			fullOnClass: myClass 
			selector: model selectedMessageName.
		newBrowserWindow
			morphPositionInWorld: self morphPositionInWorld;
			morphExtentInWorld: self morphExtentInWorld.
		self dismissMorph ]! !
!CodeWindow methodsFor: 'menu commands' stamp: 'KLG 9/8/2022 14:49:49'!
                     methodInheritanceAndReplaceMe
	"Create and schedule a method browser on the inheritance of implementors.
	Resize and position it over me and dismiss me."

	| newBrowser |
	(newBrowser _ self methodInheritance) == self ifFalse: [
		newBrowser
			morphPositionInWorld: self morphPositionInWorld;
			morphExtentInWorld: self morphExtentInWorld.
		self dismissMorph ]
	! !
!SystemDictionary methodsFor: 'browsing' stamp: 'KLG 9/8/2022 14:48:26' prior: 16956636!
                      browseMessageList: methodReferences name: labelString autoSelect: autoSelectString
	"Create and schedule a MessageSet browser on the message list."

	| messageListSize title |

	messageListSize _ methodReferences size.
	messageListSize = 0 ifTrue: [^ PopUpMenu inform: ('There are no\' , labelString) withNewLines ].

	title _ messageListSize > 1
		ifFalse: [ labelString ]
		ifTrue: [ '[', messageListSize printString, '] ', labelString].

	^ MessageSetWindow
		openMessageList: methodReferences
		label: title
		autoSelect: autoSelectString! !
!CodeWindow methodsFor: 'GUI building' stamp: 'KLG 9/8/2022 14:45:06' prior: 50402260!
       optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"

	| aList textConstructor |
	textConstructor _ [ :string :backgroundColor | 
		string asText addAttribute: (TextBackgroundColor color: backgroundColor) ].

	aList _ #(
		(10	'browse'			browseMethodFull							'view this method in a browser'							browseMethodFullAndReplaceMe)
		(11	'senders' 			browseSendersOfMessages							'browse senders of...'							browseSendersOfMethod)
		(16	'implementors'			browseMessages							'browse implementors of...' 							browseImplementors)
		(12	'versions'			browseVersions							'browse versions')), 

		((Preferences at: #decorateBrowserButtons)
			ifTrue: [
				{{13	. 'inheritance'.	 #methodInheritance. 	'Browse Method Inheritance

', (textConstructor value: 'green' value: `Color green muchLighter`),': sends to super
', (textConstructor value: 'tan' value: `Color tan`), ': has override(s)
', (textConstructor value: 'mauve' value: `Color blue muchLighter`), ': both of the above
', (textConstructor value: 'pink' value: `Color red muchLighter`), ': is an override but doesn''t call super
', (textConstructor value: 'pinkish tan' value: `Color r: 0.94 g: 0.823 b: 0.673`), ': has override(s), also is an override but doesn''t call super
'. #methodInheritanceAndReplaceMe }}]
			ifFalse: [
				{#(13	'inheritance'		 methodInheritance	 'browse method inheritance'. #methodInheritanceAndReplaceMe)}]),

		#(
		(12	'hierarchy'			browseHierarchy							'browse class hierarchy'							browseHierarchyAndReplaceMe)
		(10	'inst vars'			browseInstVarRefs							'inst var refs...')
		(11	'class vars'			browseClassVarRefs							'class var refs...')
		(10	'show...'			offerWhatToShowMenu							'menu of what to show in lower pane')).

	^ aList! !
!CodeWindow methodsFor: 'menu commands' stamp: 'KLG 9/8/2022 14:41:23' prior: 16822316!
       methodInheritance
	"Create and schedule a method browser on the inheritance of implementors."

	| list aClassNonMeta isMeta theClassOrMeta aClass sel |
	aClass _ model selectedClassOrMetaClass.
	sel _ model selectedMessageName.
	aClass ifNil: [ ^ self ].
	sel ifNil: [ ^ self ].
	aClassNonMeta _ aClass theNonMetaClass.
	isMeta _ aClassNonMeta ~~ aClass.
	list _ OrderedCollection new.
	aClass allSuperclasses reverseDo: [ :cl |
		(cl includesSelector: sel) ifTrue: [
			list addLast: (MethodReference class: cl selector: sel) ]].
	aClassNonMeta
		allSubclassesWithLevelDo: [ :cl :level |
			theClassOrMeta _ isMeta
				ifTrue: [ cl class ]
				ifFalse: [ cl ].
			(theClassOrMeta includesSelector: sel) ifTrue: [
				list addLast: (MethodReference class: theClassOrMeta selector: sel) ]]
		startingLevel: 0.
	^ Smalltalk
		browseMessageList: list
		name: 'Inheritance of ' , sel.! !
!BrowserWindow class methodsFor: 'GUI building' stamp: 'KLG 9/8/2022 14:30:16' prior: 16797646!
            fullOnClass: aClass selector: aSelector
	"Open a new full browser set to class."

	| browser |
	browser _ Browser new.
	browser setClass: aClass selector: aSelector.
	^ self open: browser label: browser labelString! !
!BrowserWindow class methodsFor: 'instance creation' stamp: 'KLG 9/8/2022 14:37:14' prior: 16798351!
 openNoSysCat: model label: aString

	^ self new
		model: model;
		buildNoSysCatMorphicWindow;
		setLabel: aString;
		openInWorld! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5478-MoreSecondaryActionsForCodeWindows-GeraldKlix-2022Sep08-14h14m-KLG.001.cs.st----!

'From Cuis 6.0 [latest update: #5466] on 27 August 2022 at 9:16:15 pm'!
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 8/27/2022 21:12:02'!
         messageSendIsInsideMessageNode: aMessageNodeReference

	| completeSourceRanges |
	
	completeSourceRanges := aMessageNodeReference methodNode completeSourceRanges.
	aMessageNodeReference methodNode nodesDo: [:aNode | 
		(aNode isMessageNode and: 	[(self findRangesOf: aNode in: completeSourceRanges) 
			anySatisfy: [:aMessageNodeRange |
				| messageSendRange |
				messageSendRange := aMessageNodeReference completeSourceRange.
				(aMessageNodeRange includesAllOf: messageSendRange) and: [aMessageNodeRange ~= messageSendRange]]
			])
				ifTrue: [^true]
	].
	
	^false! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 8/27/2022 21:06:09' prior: 50407217!
                       addParenthesesIfNeededTo: anExpression

	"TODO: duplicated code in InlineTemporaryVariable"

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |
	
 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) = $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) = $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [^anExpression]
		ifFalse: [ (anExpression endsWith: '.')
			ifTrue: [^('(', anExpression copyUpToLast: $.), ').']
	 		ifFalse: [^'(', anExpression, ')']
		].! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 8/27/2022 21:14:38' prior: 50407446!
              statementWithMessageSend: aMessageNodeReference usedIn: aParseNode lastStatement: implementorLastStatementToInline
	replacement: lastStatementWithReplacements

	| requiresParenthesis |

	requiresParenthesis := (implementorLastStatementToInline expr isMessageNode) 
		and:[ self messageSendIsInsideMessageNode: aMessageNodeReference].
	
	^self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
				inlinedWith: lastStatementWithReplacements addingParentheses: requiresParenthesis.
		! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5479-InlineMethod-FernandoBalboa-2022Aug25-21h32m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5466] on 27 August 2022 at 10:36:39 pm'!
!InlineMethodUsagesStepWindow class methodsFor: 'instance creation' stamp: 'FB 8/27/2022 22:32:15' prior: 50373228!
               openFrom: anInlineMethodApplier

	| window messageSendsSet |

	messageSendsSet := InlineMethodMessageSendsSet applier: anInlineMethodApplier.
	
	messageSendsSet autoSelectString: anInlineMethodApplier implementors first selector.

	window := self open: messageSendsSet label: 'Message sends of #', anInlineMethodApplier selectorToInline, ' to Refactor'.
	window initializeFrom: anInlineMethodApplier.

	^window.! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 8/27/2022 22:24:30' prior: 50374235!
    messageSendsRangesOf: aSelector

	"To use polimorphysm with MethodReference - Fernando"

	^Array with: completeSourceRange! !

InlineMethodMessageSendsSet removeSelector: #messageSendsRangesOf:!

!methodRemoval: InlineMethodMessageSendsSet #messageSendsRangesOf: stamp: 'Install-5480-InlineMethod-FernandoBalboa-2022Aug27-21h16m-FB.001.cs.st 9/14/2022 16:06:25'!
messageSendsRangesOf: aMessageNodeReference

	| messageSend |

	messageSend := applier messageSendAt: self messageListIndex ifAbsent: [ ^#()  ].
	messageSend completeSourceRange isEmpty
		ifTrue: [^#()]
		ifFalse: [^Array with: messageSend completeSourceRange]

	!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5480-InlineMethod-FernandoBalboa-2022Aug27-21h16m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5466] on 2 September 2022 at 5:47:03 pm'!
!InlineMethodUsagesStepWindow class methodsFor: 'instance creation' stamp: 'FB 9/2/2022 17:43:18' prior: 50419300!
                  openFrom: anInlineMethodApplier

	| window messageSendsSet |

	messageSendsSet := InlineMethodMessageSendsSet applier: anInlineMethodApplier.
	
	messageSendsSet autoSelectString: anInlineMethodApplier selectorToInline.

	window := self open: messageSendsSet label: 'Message sends of #', anInlineMethodApplier selectorToInline, ' to Refactor'.
	window initializeFrom: anInlineMethodApplier.

	^window.! !
!MessageNodeReference methodsFor: 'accesing' stamp: 'FB 8/28/2022 21:49:46' prior: 50419316!
               messageSendsRangesOf: aSelector

	"To use polimorphysm with MethodReference - Fernando"

	^self isMessageListTitle ifTrue: [#()] ifFalse: [Array with: completeSourceRange].! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 8/28/2022 23:12:50' prior: 50407292!
     buildInlinedSourceCodeStatementsFrom: statementsToInline withParametersFrom: aMessageNodeReference usedInNode: aParseNode

	| inlinedStatements argumentsAndTemporariesReplacements senderCompleteSourceRanges usageNodeSourceRange
	 inlinedUsageStatement statementsWithReplacements indentation |
	
	senderCompleteSourceRanges := aMessageNodeReference methodNode completeSourceRanges.
	usageNodeSourceRange := (self findRangesOf: aParseNode in: senderCompleteSourceRanges) first.

	self calculateReplacementsFrom: aMessageNodeReference
		usingRanges: senderCompleteSourceRanges.

	self declareTemporariesIfNeededFor: aMessageNodeReference.
	argumentsAndTemporariesReplacements := self replacementsMapForMessageSend: aMessageNodeReference.
	
	statementsWithReplacements := statementsToInline allButLast collect: [:aStatementToInline |
		self sourceCodeOfImplementorStatement: aStatementToInline withReplacements: argumentsAndTemporariesReplacements removingReturn: true].
	statementsWithReplacements add: (self sourceCodeOfImplementorStatement: statementsToInline last 
		withReplacements: argumentsAndTemporariesReplacements removingReturn: true).
	
	indentation := self indentationUpTo: usageNodeSourceRange first in: aMessageNodeReference compiledMethod sourceCode.

	statementsWithReplacements size > 1
		ifTrue: [inlinedStatements := (statementsWithReplacements allButLast)
			reduce: [:aStatementWithReplacements :nextStatementWithReplacements |
				aStatementWithReplacements, String newLineString, indentation, (nextStatementWithReplacements
					copyReplaceAll: String newLineString with: String newLineString, indentation asTokens: false) ]]
		 ifFalse: [inlinedStatements := ''].
	inlinedUsageStatement := self statementWithMessageSend: aMessageNodeReference usedIn: aParseNode
		lastStatement: statementsToInline last replacement: statementsWithReplacements last.

	statementsWithReplacements size > 1
		ifTrue: [inlinedStatements := inlinedStatements, String newLineString, indentation, inlinedUsageStatement]
		ifFalse: [inlinedStatements := inlinedUsageStatement ].

	^inlinedStatements.! !
!InlineMethod methodsFor: 'inlining - private' stamp: 'FB 9/2/2022 17:45:26' prior: 50407488!
             inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReferenceWithReturnValue

	| enclosingBlock |
	
	enclosingBlock := self enclosingBlockOf: aMessageNodeReferenceWithReturnValue.
	(self parseNode: enclosingBlock returns: aMessageNodeReferenceWithReturnValue messageNode)
		ifTrue: [^self inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReferenceWithReturnValue
			removingReturn: false].

	"Find the outermost statement containing the usage to inline that's inside the enclosing block"
	self findOutermostStatementContaining: aMessageNodeReferenceWithReturnValue enclosedBy: enclosingBlock
		ifFound: [ :outermostNodeAndRange |
			self inlineStatements: statementsToInline ofMessageWithReturnValue: aMessageNodeReferenceWithReturnValue
				usedInParseNode: outermostNodeAndRange	 key
		]
		ifNone: [ 
			self inlineStatements: statementsToInline ofMessageWithoutAssigningPossibleReturnValue: aMessageNodeReferenceWithReturnValue
				removingReturn: true
		]




	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5481-InlineMethod-FernandoBalboa-2022Aug27-22h36m-FB.001.cs.st----!

'From Cuis 6.0 [latest update: #5466] on 11 September 2022 at 8:38:37 pm'!
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 9/11/2022 20:30:18'!
     assertTemporaryNotAssignedInBlock

	methodNode completeSourceRangesDo: [:node :ranges |
		
		(node isBlockNode and: [ranges first last < usageToInline first] and: [
			(self selectCompleteRangesOfAssignmentsToTemporaryFrom: node 
				thatMatch: 	[:assignmentRange | rangeOfNodeDeclaringTemporary includesAllOf: assignmentRange ]) isEmpty not.
		]) ifTrue: [self class signalTemporaryIsAssignedInsideInBlockBeforeReference]
	]! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 9/11/2022 19:44:54'!
                               signalTemporaryIsAssignedInsideInBlockBeforeReference

	^self refactoringError: (self temporaryIsAssignedInBlockBeforeReferenceErrorMessage)





! !
!InlineTemporaryVariable class methodsFor: 'errors' stamp: 'FB 9/11/2022 19:45:59'!
                      temporaryIsAssignedInBlockBeforeReferenceErrorMessage

	^'Temporary to inline is previously is assigned inside a block'





! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 9/11/2022 19:02:44' prior: 50417890!
          assertTemporaryIsNotAssignedAfterUsedInBlock
	
	| assignmentToTemporaryPositions |
	
	assignmentToTemporaryPositions := self selectCompleteRangesOfAssignmentsToTemporaryFrom: methodNode 
		thatMatch: [:assignmentRange | rangeOfNodeDeclaringTemporary includesAllOf: assignmentRange.].
	
	methodNode completeSourceRanges associationsDo: [:parseNodeAndRanges | (parseNodeAndRanges key isBlockNode 
		and: [parseNodeAndRanges value anySatisfy: [:range | (rangeOfNodeDeclaringTemporary includesAllOf: range)
				and: [(methodNode positionsForTemporaryVariable: variableToInline ifAbsent: [#()]) 
					anySatisfy: [:tempReferenceInterval | range includesAllOf: tempReferenceInterval]]
				and: [assignmentToTemporaryPositions anySatisfy: [:tempAssignmentPosition | tempAssignmentPosition first > range last]]]])
					ifTrue: [self class signalTemporaryAssignedAfterUsedInBlock]]
	
! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 9/11/2022 20:27:56' prior: 50417723!
                            inlineAssignment

	| endOfNextAssignmentIndex endOfRefactoringScopeIndex |

	endOfNextAssignmentIndex := self findLastIndexOfFirstAssignmentAfter: assignmentToInlineRange.
	self assertTemporaryNotAssignedInBlock.
	self assertTemporaryIsNotAssignedAfterUsedInBlock.
	self computeEndOfNodeEnclosingAssignment.
	endOfRefactoringScopeIndex := endOfNextAssignmentIndex ifNil: [endOfNodeEnclosingAssignment ].
	
	self inlineAssignment: assignmentToInlineRange upTo: endOfRefactoringScopeIndex.

	(self atMostOneAssignment and: [self noReferencesToTemporaryAfter: endOfRefactoringScopeIndex ])
		ifTrue: [self removeTemporaryVariableDeclaration].




! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5482-InlineTemporary-FernandoBalboa-2022Sep02-17h47m-FB.001.cs.st----!

'From Haver 6.0 [latest update: #5477] on 14 September 2022 at 11:51:37 am'!
!TextModelMorph methodsFor: 'accept/cancel' stamp: 'KLG 9/14/2022 11:44:26'!
                              acceptOnAny: aBoolean 
	"Accept on any keystroke."
	
	self scroller acceptOnAny: aBoolean ! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'KLG 9/14/2022 11:49:11' prior: 50337201!
    processKeystrokeEvent: evt
	| action |

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action value ] ].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action value ] ].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	"Only accept (on any) if we have unaccepted edits, otherwise the morph will flash."
	hasUnacceptedEdits and: [ acceptOn == #any ] :: ifTrue: [ self acceptContents ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5483-TextMorphsAcceptOnAny-GeraldKlix-2022Sep14-11h51m-KLG.001.cs.st----!

----QUIT----(14 September 2022 16:06:32) Cuis6.0-5483.image priorSource: 2461882!