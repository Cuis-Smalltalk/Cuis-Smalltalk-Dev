'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 7 November 2016 at 2:55:32 pm'!


----SNAPSHOT----#(7 November 2016 2:55:51.944389 pm) Cuis5.0-2974.image priorSource: 0!

----QUIT----#(7 November 2016 2:55:56.449389 pm) Cuis5.0-2974.image priorSource: 92!

----STARTUP----#(17 November 2016 12:32:16.520522 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-2974.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 16 November 2016 at 3:55:25 pm'!
!Integer class methodsFor: 'instance creation' stamp: 'jmv 11/16/2016 15:37:15' prior: 16860879!
                             readFrom: aStream base: base
	"Answer an instance of one of my concrete subclasses. Initial minus sign
	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
	allowed--use Number readFrom: for that. Answer zero (not an error) if
	there are no digits."

	| digit value neg cc atLeastOneDigitRead |
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	atLeastOneDigitRead _ false.
	[ aStream atEnd ]
		whileFalse: [
			cc _ aStream next.
			digit _ cc digitValue.
			(digit < 0 or: [digit >= base])
				ifTrue: [
					aStream skip: -1.
					atLeastOneDigitRead ifFalse: [self error: 'At least one digit expected here'].
					^neg
						ifTrue: [value negated]
						ifFalse: [value]].
			value _ value * base + digit.
			atLeastOneDigitRead _ true ].
	neg ifTrue: [^ value negated].
	^ value! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2975-Integer-readFrom-cleanup-JuanVuletich-2016Nov16-15h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2975] on 17 November 2016 at 9:08:34 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:06:59' prior: 16891425!
           peek
	"Answer what would be returned if the message next were sent to the 
	receiver. If the receiver is at the end, answer nil."

	| nextObject |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^nil].
	nextObject _ self next.
	position _ position - 1.
	^nextObject! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 09:07:20' prior: 16913380!
    peek
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	| next |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^ nil].
	next _ self basicNext.
	self position: self position - 1.
	^ next! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2976-peek-Optimization-JuanVuletich-2016Nov17-09h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2975] on 17 November 2016 at 9:18:37 am'!
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:42'!
                               nextDouble64BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ])
			readStream nextDouble64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ])
			readStream nextDouble64BigEndian: true
	"
	| bytes |
	bytes _ self next: 8.
	^ bytes doubleAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:40'!
            nextDouble64Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 8.
	bytes doubleAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:38'!
      nextFloat32BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ])
			readStream nextFloat32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ])
			readStream nextFloat32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes floatAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:34'!
                  nextFloat32Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ]) hex 'DB0F4940'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ]) hex '40490FDB'
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes floatAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
                    nextSignedInt16BigEndian: bigEndian
	"Answer the next  signed, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) 
			readStream nextSignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) 
			readStream nextSignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes shortAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
          nextSignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 16-bit integer on this (binary) stream.

	(16r10000-12345) hex '16rCFC7'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes shortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
nextSignedInt32BigEndian: bigEndian
	"Answer the next signed, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) 
			readStream nextSignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) 
			readStream nextSignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes longAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
          nextSignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 32-bit integer on this (binary) stream.

	(16r100000000-123456) hex '16rFFFE1DC0'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes longAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:18'!
                      nextUnsignedInt16BigEndian: bigEndian
	"Answer the next unsigned, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) 
			readStream nextUnsignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) 
			readStream nextUnsignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes unsignedShortAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                         nextUnsignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 16-bit integer on this (binary) stream.

	12345 hex  '16r3039'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes unsignedShortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:19'!
                            nextUnsignedInt32BigEndian: bigEndian
	"Answer the next unsigned, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) 
			readStream nextUnsignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) 
			readStream nextUnsignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes unsignedLongAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                        nextUnsignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 32-bit integer on this (binary) stream.

	123456 hex '16r1E240'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes unsignedLongAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 6/14/2013 20:02'!
                   nextNumber
	"Answer a number from the stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element = $- or: [element = $)]]]] whileFalse.
	element ifNil: [^nil].
	self skip: -1.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
               nextNumber: n 
	"Answer the next n bytes as a positive Integer or LargePositiveInteger.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"
	| s |
	s _ 0.
	1 to: n do: 
		[:i | s _ (s bitShift: 8) bitOr: self next asInteger].
	^ s normalize! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
                 nextNumber: n put: v 
	"Append to the receiver the argument, v, which is a positive 
	SmallInteger or a LargePositiveInteger, as the next n bytes.
	Possibly pad with leading zeros.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"

	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].
	^ v
! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!
                             nextString
	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."

	| aString length |

	"read the length in binary mode"
	self binary.
	length _ self next.		"first byte."
	length >= 192 ifTrue: [length _ length - 192.
		1 to: 3 do: [:ii | length _ length * 256 + self next]].
	aString _ String new: length.

	"read the characters in ASCII mode"
	self ascii.
	self nextInto: aString.
	^aString! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 4/16/2001 17:56'!
                 nextStringPut: s 
	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."

	| length |
	(length _ s size) < 192
		ifTrue: [self nextPut: length]
		ifFalse: 
			[self nextPut: (length digitAt: 4)+192.
			self nextPut: (length digitAt: 3).
			self nextPut: (length digitAt: 2).
			self nextPut: (length digitAt: 1)].
	self nextPutAll: s asByteArray.
	^s! !

DummyStream removeSelector: #nextDouble64BigEndian:!

DummyStream removeSelector: #nextDouble64BigEndian:!

DummyStream removeSelector: #nextDouble64Put:bigEndian:!

DummyStream removeSelector: #nextDouble64Put:bigEndian:!

DummyStream removeSelector: #nextNumber:put:!

DummyStream removeSelector: #nextNumber:put:!

DummyStream removeSelector: #nextSignedInt16BigEndian:!

DummyStream removeSelector: #nextSignedInt16BigEndian:!

DummyStream removeSelector: #nextSignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt32BigEndian:!

DummyStream removeSelector: #nextSignedInt32BigEndian:!

DummyStream removeSelector: #nextSignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextStringPut:!

DummyStream removeSelector: #nextStringPut:!

DummyStream removeSelector: #nextUnsignedInt16BigEndian:!

DummyStream removeSelector: #nextUnsignedInt16BigEndian:!

DummyStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt32BigEndian:!

DummyStream removeSelector: #nextUnsignedInt32BigEndian:!

DummyStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

DataStream removeSelector: #readStringOld!

DataStream removeSelector: #readStringOld!

PositionableStream removeSelector: #nextDouble64BigEndian:!

PositionableStream removeSelector: #nextDouble64BigEndian:!

PositionableStream removeSelector: #nextDouble64Put:bigEndian:!

PositionableStream removeSelector: #nextDouble64Put:bigEndian:!

PositionableStream removeSelector: #nextFloat32BigEndian:!

PositionableStream removeSelector: #nextFloat32BigEndian:!

PositionableStream removeSelector: #nextFloat32Put:bigEndian:!

PositionableStream removeSelector: #nextFloat32Put:bigEndian:!

PositionableStream removeSelector: #nextNumber!

PositionableStream removeSelector: #nextNumber!

PositionableStream removeSelector: #nextNumber:!

PositionableStream removeSelector: #nextNumber:!

PositionableStream removeSelector: #nextNumber:put:!

PositionableStream removeSelector: #nextNumber:put:!

PositionableStream removeSelector: #nextSignedInt16BigEndian:!

PositionableStream removeSelector: #nextSignedInt16BigEndian:!

PositionableStream removeSelector: #nextSignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt32BigEndian:!

PositionableStream removeSelector: #nextSignedInt32BigEndian:!

PositionableStream removeSelector: #nextSignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextString!

PositionableStream removeSelector: #nextString!

PositionableStream removeSelector: #nextStringOld!

PositionableStream removeSelector: #nextStringOld!

PositionableStream removeSelector: #nextStringPut:!

PositionableStream removeSelector: #nextStringPut:!

PositionableStream removeSelector: #nextUnsignedInt16BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

Stream removeSelector: #nextStringOld!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2977-Stream-refactor-JuanVuletich-2016Nov17-09h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2977] on 17 November 2016 at 10:29:07 am'!
!PositionableStream methodsFor: 'testing' stamp: 'jmv 11/17/2016 10:28:06' prior: 16891536!
         atEnd
	"Answer whether the receiver can access any more objects."

	^position >= readLimit! !
!ReadStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:59:57' prior: 16897965!
            next
	"Answer the next object in the Stream represented by the receiver."

	^position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:35' prior: 16946385!
             nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position _ position + 1.
			^collection at: position put: anObject]! !
!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:45' prior: 16898094!
   next
	"Return the next object in the Stream represented by the receiver."

	"treat me as a FIFO"
	^ position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 10:00:56' prior: 16913098!
   basicNext
	"Answer the next byte from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2978-RemoveObsoletePrimCalls-JuanVuletich-2016Nov17-10h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2977] on 17 November 2016 at 10:31:18 am'!

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOReadStream commentStamp: '<historical>' prior: 0!
     Standard Input Stream.

A basic problem/restriction with this code is that currently the VM runs multiple VM threads within a single OS thread.

This means that waiting on StdIn blocks the VM, suspending all Smalltalk code.!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOWriteStream commentStamp: '<historical>' prior: 0!
               Standard Output/Error Streams.!
!StdIOReadStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 10:12:24'!
                  openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:01:57'!
                          next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !
!StdIOReadStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:47:10'!
                     printOn: aStream
	"Put a printed version of the receiver onto aStream."

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!StdIOReadStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 09:45:28'!
    primRead: id into: byteArray startingAt: startIndex count: count
	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."

	<primitive: 'primitiveFileRead' module: 'FilePlugin'>
	self error: 'File read failed'! !
!StdIOReadStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 09:46:36'!
               stdin
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stdinHandle 
		name: 'stdin'.
	^newSelf! !
!StdIOReadStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:47'!
                        stdinHandle

	^ StdIOWriteStream stdioHandles at: 1! !
!StdIOWriteStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 10:14:32'!
                          openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:19:51'!
                         flush
	"Flush pending changes"
	^self primFlush: fileID! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:18:42'!
                         nextPut: char
	"Write the given character to this file."

	buffer1 at: 1 put: char.
	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.
	^ char
! !
!StdIOWriteStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:35:56'!
                       printOn: aStream
	"Put a printed version of the receiver onto aStream.  1/31/96 sw"

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:20:17'!
                       primFlush: id
	"Flush pending changes to the disk"

	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>! !
!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:19:14'!
    primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	(FileWriteError fileName: name)
		signal: (self closed
			ifTrue: [ 'File [', name, '] is closed' ]
			ifFalse: [ 'File [', name, '] write failed' ])! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 10:15:08'!
stderr
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stderrHandle 
		name: 'stderr'.
	^newSelf! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 10:15:11'!
            stdout
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stdoutHandle 
		name: 'stdout'.
	^newSelf! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:20'!
                    stderrHandle

	^ self stdioHandles at: 3! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:09'!
  stdioHandles
" answer handles: #(stdin stdout stderr) "
	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>
	self primitiveFailed! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:12'!
                    stdoutHandle

	^ self stdioHandles at: 2! !

Smalltalk removeClassNamed: #StdIOFileStream!

Smalltalk removeClassNamed: #StdIOFileStream!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2979-NewStdIO-JuanVuletich-2016Nov17-10h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2979] on 17 November 2016 at 10:51:20 am'!
!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 10:48:18'!
                              newLine
	"Append a newLine character to the receiver.
	The Cuis convention is to use lf on output."

	self nextPut: Character newLineCharacter! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2980-stdout-newLine-JuanVuletich-2016Nov17-10h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2980] on 17 November 2016 at 11:51:03 am'!

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked '
	classVariableNames: 'StdIn '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position '
	classVariableNames: 'StdOut StdErr '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:43'!
                    peek
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!
	
	Do not advance the stream!!"

	"Multiple calls to #peek don't make new reads"
	peeked ifFalse: [
		self privateRead.
		peeked _ true ].

	"peeked is always true on exit"
	^buffer1 at: 1! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:33:22'!
                 peekFor: aCharacter 
	"Answer false and do not move over the next element if it is not equal to the argument, aCharacter 
	Answer true and increment the position for accessing elements, if the next element is equal to anObject."

	| nextChar |
	nextChar _ self peek.
	aCharacter = nextChar ifTrue: [
		self next.
		^ true].
	^ false! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:24:52'!
     privateRead
	"Read one Character.
	Private."
	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	count = 1 ifFalse: [ buffer1 at: 1 put: nil ]! !
!StdIOReadStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:45:00'!
                      releaseClassCachedState

	StdIn _ nil! !
!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 11:08:02'!
   space
	"Append a space character to the receiver."

	self nextPut: Character space! !
!StdIOWriteStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:44:50'!
              releaseClassCachedState

	StdOut _ nil.
	StdErr _ nil! !
!StdIOReadStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 11:13:30' prior: 50332252!
         openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1.
	peeked _ false! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:44' prior: 50332266!
                         next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	"If last call was #peek, not #next, then just answer cached value."
	peeked
		ifFalse: [ self privateRead ]
		ifTrue: [ peeked _ false ].

	"peeked is always false on exit"
	^buffer1 at: 1! !
!StdIOReadStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:45:39' prior: 50332298!
                stdin
	StdIn ifNil: [
		StdIn _ self basicNew.
		StdIn 
			openOnHandle: self stdinHandle 
			name: 'stdin' ].
	^StdIn! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:13' prior: 50332367!
                            stderr
	StdErr ifNil: [
		StdErr _ self basicNew.
		StdErr 
			openOnHandle: self stderrHandle 
			name: 'stderr' ].
	^StdErr! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:37' prior: 50332374!
                     stdout
	StdOut ifNil: [
		StdOut _ self basicNew.
		StdOut 
			openOnHandle: self stdoutHandle 
			name: 'stdout' ].
	^StdOut! !

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2981-StdIn-peek-peekFor-JuanVuletich-2016Nov17-11h08m-jmv.1.cs.st----!

----SNAPSHOT----#(17 November 2016 12:32:45.272939 pm) Cuis5.0-2981.image priorSource: 181!

----QUIT----#(17 November 2016 12:33:33.533688 pm) Cuis5.0-2981.image priorSource: 29844!

----STARTUP----#(14 December 2016 2:33:04.156577 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-2981.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 17 November 2016 at 5:11:35 pm'!
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 11/17/2016 17:08:04' prior: 16906186!
                              copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize _ self size - (stop - start + 1) + replacementCollection size.
	endReplacement _ start - 1 + replacementCollection size.
	newSequenceableCollection _ self species new: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 11/17/2016 16:54:39' prior: 16903350!
        setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		(classOrMetaClass isNil or: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript]) ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2982-CodeColorizerFix-JuanVuletich-2016Nov17-17h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 17 November 2016 at 5:18:27 pm'!
!DummyStream methodsFor: 'as yet unclassified' stamp: 'KenD 11/5/2016 16:17:09'!
           space! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2983-DummyStream-space-KenDickey-2016Nov17-17h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 18 November 2016 at 10:49:39 am'!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/3/2015 10:19' prior: 16935004!
                       newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu subMenu catDict shortCat class |
	menu _ self menu: 'Add a new morph'.
	menu

		add: 'From Clipboard'
		target: myHand
		action: #pasteMorph;
		
		add: 'From Alphabetical List'
		subMenu: self alphabeticalMorphMenu.
	menu addLine.
		
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.
	SystemOrganization categories do: [ :cat |
		((cat beginsWith: 'Morphic-') and: [ (#('Morphic-Menus' 'Morphic-Support' ) includes: cat) not ]) ifTrue: [
			shortCat _ (cat
				copyFrom: 'Morphic-' size + 1
				to: cat size).
			(SystemOrganization listAtCategoryNamed: cat) do: [ :cName |
				class _ Smalltalk at: cName.
				((class inheritsFrom: Morph) and: [ class includeInNewMorphMenu ]) ifTrue: [
					(catDict includesKey: shortCat)
						ifTrue: [ (catDict at: shortCat) addLast: class ]
						ifFalse: [
							catDict
								at: shortCat
								put: (OrderedCollection with: class) ]]]]].
	catDict keys sort do: [ :categ |
		subMenu _ MenuMorph new.
		((catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ]) do: [ :cl |
			subMenu
				add: cl name
				target: self
				selector: #newMorphOfClass:event:
				argument: cl ].
		menu
			add: categ
			subMenu: subMenu ].

	self doPopUp: menu.! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2984-NewMorphMenuFix-JuanVuletich-2016Nov18-10h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2984] on 30 November 2016 at 2:56:21 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:52:08'!
     with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."
	| n result |
	n _ self size.
	otherCollection size = n ifFalse: [ self error: 'otherCollection must be the same size' ].
	thirdCollection size = n ifFalse: [ self error: 'thirdCollection must be the same size' ].
	result _ self species new: n.
	1 to: n do: [ :index | 
		result at: index put:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/25/2016 12:15:27'!
                     with: otherCollection with: thirdCollection do: threeArgBlock 
	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."
	| n |
	n _ self size.
	otherCollection size = n ifFalse: [self error: 'otherCollection must be the same size'].
	thirdCollection size = n ifFalse: [self error: 'thirdCollection must be the same size'].
	1 to: n do: [ :index |
		threeArgBlock
			value: (self at: index)
			value: (otherCollection at: index)
			value: (thirdCollection at: index)]! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:51:19'!
                      with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result _ self species new: self size.
	1 to: self size do: [ :index |
		result addLast:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2985-withwithdo-withwithdcollect-JuanVuletich-2016Nov30-14h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2984] on 30 November 2016 at 3:22:11 pm'!
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:04:11'!
                         += anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v + anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) + (anObject at: i)) ]]! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/25/2016 11:41:25'!
                -= anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v - anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) - (anObject at: i)) ]]! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:21:00'!
                derivative
	| displaced answer |
	displaced _ self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first - self first.	"Some reasonable zero"
	answer _ self copy.
	answer -= displaced.
	^answer! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/29/2016 14:23:32'!
 integral
	| answer |
	answer _ self copy.
	2 to: answer size do: [ :i |
		answer at: i put: (answer at: i) + (answer at: i-1) ].
	^answer! !

FloatArray removeSelector: #derivative!

FloatArray removeSelector: #derivative!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2986-Collection-derivative-integral-JuanVuletich-2016Nov30-14h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:42:22 am'!
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:39'!
        step
	(target isNil or: [target isInWorld not]) ifTrue: [self delete]! !
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:41'!
                       stepTime
	^ 100! !
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:38'!
             wantsSteps
	^ true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2987-DeleteHaloWhenMorphIsDeleted-LucianoEstebanNotarfrancesco-2016Nov26-08h41m-len.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:46:53 am'!
!MenuMorph methodsFor: 'keyboard control' stamp: 'len 6/11/2016 20:40' prior: 16867064!
           keyboardFocusChange: aBoolean
	"Notify change due to green border for keyboard focus"

	aBoolean ifFalse: [self deleteIfPopUp: nil].
	self redrawNeeded! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2988-AvoidManuesHangingAround-LucianoEstebanNotarfrancesco-2016Nov26-08h42m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:52:37 am'!
!SequenceableCollection methodsFor: 'copying' stamp: 'len 4/18/2016 22:08'!
                      shuffledBy: aGenerator
	"To answer a mutable collection when receiver is, for example, an Interval."
	^ (self collect: [ :each | each ]) shuffleBy: aGenerator! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2989-ShuffledBy-LucianoEstebanNotarfrancesco-2016Nov26-08h46m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:02:48 am'!
!SystemDictionary methodsFor: 'browsing' stamp: 'len 6/9/2016 23:23'!
   browseAllPrimitives
	self browseAllSelect: [:each| each primitive ~= 0 and: [(each primitive between: 256 and: 291) not]]
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2990-SmalltalkBrowseAllPrimitives-LucianoEstebanNotarfrancesco-2016Nov26-08h52m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:03:51 am'!
!SystemDictionary methodsFor: 'retrieving' stamp: 'len 11/26/2016 09:03:25' prior: 16921461!
                              allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection special aList byte |

	#(23 48 'fred' (new open:label:)) size.
"Example above should find #open:label:, though it is deeply embedded here."

	aCollection _ OrderedCollection new.
	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].
	self allBehaviorsDo: [:class |
		aList _ class whichSelectorsReferTo: aLiteral special: special byte: byte.
		aList do: [ :sel |
			"For special selectors, look for the literal in the source code.
			Otherwise, for example, searching for senders of #== will include senders of #ifNil.
			Except for #at:put:, because it has two arguments and won't find it in the source code like that."
			(byte isNil or: [aLiteral = #at:put: or: [
				((class sourceCodeAt: sel)
					findString: aLiteral) > 0]]) ifTrue: [

				aCollection add: (
					MethodReference new
						setStandardClass: class 
						methodSymbol: sel
				)
			]
		]
	].
	^ aCollection! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2991-SendersOfatput-LucianoEstebanNotarfrancesco-2016Nov26-09h02m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:06:05 am'!
!String methodsFor: 'testing' stamp: 'len 11/26/2016 09:05:35'!
         isAlphaNumeric
	"Answer true if the receiver contains only letters or digits."
	^ self allSatisfy: [:each| each isAlphaNumeric]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2992-StringisAlphaNumeric-LucianoEstebanNotarfrancesco-2016Nov26-09h03m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:08:39 am'!
!Form methodsFor: 'fileIn/Out' stamp: 'len 8/1/2016 08:13' prior: 16847779!
                  printOn: aStream
	aStream isText
		ifTrue:
			[aStream withAttribute: (TextAnchor new anchoredFormOrMorph: self) do: [aStream nextPut: $*].
			^ self].
	aStream
		nextPutAll: self class name;
		nextPut: $(; print: width;
		nextPut: $x; print: height;
		nextPut: $x; print: depth;
		nextPut: $)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2993-FormPrintOnTextForWorkspaces-LucianoEstebanNotarfrancesco-2016Nov26-09h06m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2993] on 5 December 2016 at 8:17:22 am'!
!Morph methodsFor: 'printing' stamp: 'jmv 12/5/2016 08:16:19' prior: 16876467!
  printOn: aStream 
	"Add the identity of the receiver to a stream"
	aStream isText
		ifTrue: [
			aStream
				withAttribute: (TextAnchor new anchoredFormOrMorph: (owner ifNil: [self] ifNotNil: [self imageForm:32]))
				do: [ aStream nextPut: $* ].
			^ self].
	super printOn: aStream. "a(n) className"
	aStream 
		nextPut: $(;
		print: self identityHash;
		nextPut: $).
	self valueOfProperty: #morphName ifPresentDo: [ :x | aStream nextPutAll: x asString]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2994-MorphPrintOnTextEnh-JuanVuletich-2016Dec05-08h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2994] on 5 December 2016 at 9:46:02 am'!
!Integer methodsFor: 'comparing' stamp: 'len 12/5/2016 09:46:00' prior: 16859447!
                       hash
	"Hash is reimplemented because = is implemented.
	| s |
	s _ (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	^self hashMultiply! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

Set rehashAllSets!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2995-Integer-hash-LucianoEstebanNotarfrancesco-2016Dec05-09h39m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2986] on 2 December 2016 at 4:40:51 pm'!
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 12/2/2016 15:47:08' prior: 16848280!
                         flippedBy: direction
	"Return a copy of the receiver flipped either #vertical, #horizontal or #both. (#both is a 180 degrees rotation)
	Form lena display.
	(Form lena flippedBy: #vertical) display.
	(Form lena flippedBy: #horizontal) display.
	(Form lena flippedBy: #both) display.
	"
	| newForm quad |
	newForm _ self class extent: self extent depth: depth.
	quad _ self boundingBox innerCorners.
	quad _ (
		direction caseOf: {
			[ #vertical ] 		-> [#(2 1 4 3)].
			[ #horizontal ] 	-> [#(4 3 2 1)].
			[ #both ] 			-> [#(3 4 1 2)]})
		collect: [:i | quad at: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
"	newForm offset: (self offset flippedBy: direction centerAt: aPoint)."
	^ newForm
"
[Sensor isAnyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p |
[ Sensor isAnyButtonPressed ] whileFalse: [
	f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 _ f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p ]
"! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2996-Form-FlippedBy-both-JuanVuletich-2016Dec02-15h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2996] on 9 December 2016 at 9:12:18 am'!
!StringMorph methodsFor: 'initialization' stamp: 'jmv 12/9/2016 09:09:45' prior: 16918230!
                       initialize
	super initialize.
	font _ nil.
	emphasis _ 0.
	self contents: 'String Morph'
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2997-StringMorph-fix-JuanVuletich-2016Dec09-09h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 29 November 2016 at 9:10:32 pm'!
!OrderedCollection methodsFor: 'converting' stamp: 'len 11/29/2016 08:54:14'!
           asNewArray
	^ array copyFrom: firstIndex to: lastIndex! !
!OrderedCollection class methodsFor: 'instance creation' stamp: 'len 11/28/2016 19:18:39'!
           newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self new: aCollection size)
		resetTo: 1;
		addAll: aCollection;
		yourself! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'len 11/28/2016 10:50:21' prior: 16883972!
                 collect: aBlock 
	"Evaluate aBlock with each of my elements as the argument. Collect the 
	resulting values into a collection that is like me. Answer the new 
	collection. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection _ self species new: self size.
	newCollection resetTo: 1.
	firstIndex to: lastIndex do: [ :index |
		newCollection addLast: (aBlock value: (array at: index))].
	^ newCollection! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2998-OrderedCollectionTweaks-LucianoEstebanNotarfrancesco-2016Nov26-09h08m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2995] on 6 December 2016 at 8:16:54 pm'!

RectangleLikeMorph subclass: #ResizeMorph
	instanceVariableNames: 'gridLineWidth gridColor selectionColor outlineMorph grid from to action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #ResizeMorph category: #'Morphic-Views'!
RectangleLikeMorph subclass: #ResizeMorph
	instanceVariableNames: 'gridLineWidth gridColor selectionColor outlineMorph grid from to action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!SystemWindow methodsFor: 'resize/collapse' stamp: 'bp 10/18/2015 12:18'!
             resize
	| resizeMorph |
	resizeMorph _ ResizeMorph new morphExtent: 200@150.
	resizeMorph action: [self resize: (resizeMorph selectionRectangle: Display extent)].
	resizeMorph morphPosition: self world activeHand morphPosition.
	resizeMorph openInWorld
	! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 22:22'!
                 action: aBlock
	action _ aBlock! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/18/2015 18:00'!
                drawGridOn: aCanvas
	0 to: grid x do: [:i |
		| x |
		x _ i * (extent x - gridLineWidth) / grid x.
		aCanvas line: x @ 0 to: x @ (extent y - 2) width: gridLineWidth color: gridColor].
	0 to: grid y do: [:i |
		| y |
		y _ i * (extent y - gridLineWidth) / grid y.
		aCanvas line: 0 @ y to: (extent x - 2) @ y width: gridLineWidth color: gridColor]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:02'!
                     drawOn: aCanvas
	super drawOn: aCanvas.
	from ifNotNil: [aCanvas fillRectangle: (self selectionRectangle: extent) color: selectionColor].
	self drawGridOn: aCanvas! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 19:00'!
            grid: aPoint
	grid _ aPoint! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 19:00'!
                    handlesMouseDown: aMouseButtonEvent
	^true! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:51'!
     initialize
	super initialize.
	extent _ 400@300.
	color _ Color white.
	grid _ 8@6.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:18'!
                  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Color black;
		color: Color transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:17'!
    mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition.
	outlineMorph delete.
	action ifNotNil: [
		action value.
		self delete]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 21:32'!
                               mouseMove: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 21:25'!
              printOn: aStream
	super printOn: aStream.
	aStream space; print: from; space; print: to! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:14'!
                        selectTo: localEventPosition
	| newTo |
	newTo _ self toGridPoint: localEventPosition.
	newTo ~= to ifTrue: [
		to _ newTo.
		self redrawNeeded.
		self updateOutlineMorph]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:35'!
    selectionRectangle: aRectangle
	^(from corner: to + 1) scaledBy: aRectangle // grid! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:34'!
                            toGridPoint: aPoint
	^(aPoint min: extent - 1) // (extent // grid)! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:15'!
             updateOutlineMorph
	| rectangle |
	rectangle _ self selectionRectangle: Display extent.
	outlineMorph
		morphPosition: rectangle origin extent: rectangle extent;
		show! !
!SystemWindow methodsFor: 'menu' stamp: 'bp 10/11/2015 21:42' prior: 16926424!
     buildWindowMenu

	| aMenu |

	aMenu _ MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' action: #relabel;
		add: 'window color...' action: #setWindowColor;
		addLine;
		add: 'send to back' action: #sendToBack;
		add: 'make next-to-topmost' action: #makeSecondTopmost;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ]) action: #toggleStickiness;
		addLine;
		add: 'close' action: #delete;
		add: 'collapse' action: #collapse;
		add: 'expand / contract' action: #expandBoxHit;
		addLine;
		add: 'resize...' action: #resize;
		add: 'resize full' action: #resizeFull;
		add: 'resize top' action: #resizeTop;
		add: 'resize left' action: #resizeLeft;
		add: 'resize bottom' action: #resizeBottom;
		add: 'resize right' action: #resizeRight;
		add: 'resize top left' action: #resizeTopLeft;
		add: 'resize top right' action: #resizeTopRight;
		add: 'resize bottom left' action: #resizeBottomLeft;
		add: 'resize bottom right' action: #resizeBottomRight.

	^ aMenu! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2999-ResizeMorph-BernhardPieber-2016Dec06-20h13m-bp.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 9 December 2016 at 10:27:21 am'!
!PasteUpMorph methodsFor: 'printing' stamp: 'jmv 12/9/2016 10:25:13' prior: 16887389!
  printOn: aStream
	"Reimplemented to add a tag showing that the receiver is currently functioning as a 'world', if it is"

	self isWorldMorph
		ifTrue: [aStream nextPutAll: ' [world]']
		ifFalse: [super printOn: aStream]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3000-PasteUpMorph-print-fix-JuanVuletich-2016Dec09-10h25m-jmv.1.cs.st----!

----SNAPSHOT----#(14 December 2016 2:33:22.856051 pm) Cuis5.0-3000.image priorSource: 29937!

----QUIT----#(14 December 2016 2:33:35.179869 pm) Cuis5.0-3000.image priorSource: 54545!

----STARTUP----#(19 December 2016 1:35:42.981648 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3000.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 15 December 2016 at 12:11:15 pm'!
!Point methodsFor: 'printing' stamp: 'jmv 12/15/2016 10:20:58'!
printStringFractionDigits: placesDesired
	^(x printStringFractionDigits: placesDesired), '@', (y printStringFractionDigits: placesDesired)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3001-Point-printStringFractionDigits-JuanVuletich-2016Dec15-10h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 16 December 2016 at 3:13:12 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 12/16/2016 15:05:52' prior: 16924259!
                             browseMyChanges
	"Browse only the changes (in the changes file) by the current author.
	Smalltalk browseMyChanges
	"
	self browseAllSelect: [ :method |
       method fileIndex > 1 "only look at changes file"
               and: [ method timeStamp beginsWith: Utilities authorInitials, ' ' ]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3002-BrowseMyChanges-fix-JuanVuletich-2016Dec16-15h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 12:44:03 pm'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/17/2016 22:38:52' prior: 16819446!
                initialPC
	"Answer the program counter for the receiver's first bytecode."
	^ (self numLiterals + 1) * Smalltalk wordSize + 1! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 12/17/2016 22:37:27' prior: 16920388!
lowSpaceThreshold 
	"Answer the low space threshold. When the amount of free memory (after garbage collection)
	 falls below this limit, the system is in serious danger of completely exhausting memory and
	 crashing. This limit should be made high enough to allow the user open a debugger to diagnose
	 a problem or to save the image.  In a stack-based VM such as Cog contexts for activations in
	 the stack zone will have to be created as the debugger opens, requiring additional headroom."

	| slotsForDebugger slotsForContextsOnStackPages |
	slotsForDebugger := 65536. "Arbitrary guess"
	slotsForContextsOnStackPages :=
		(self vmParameterAt: 42)
			ifNil: [0]
			ifNotNil:
				[:numStackPages| | headerSize numActivationsPerPage maxContextSize |
				numActivationsPerPage := 40. "Design goal of the Cog VM"
				headerSize := 2. "64-bytes for Spur"
				maxContextSize := MethodContext instSize + CompiledMethod fullFrameSize + headerSize.
				numStackPages * numActivationsPerPage * maxContextSize].
	^slotsForDebugger + slotsForContextsOnStackPages * self wordSize! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3003-FixFor64BitSpur-JuanVuletich-2016Dec19-12h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 12:54:39 pm'!
!Parser methodsFor: 'primitives' stamp: 'nice 9/6/2013 00:48' prior: 16885817!
                      externalFunctionDeclaration
	"Parse the function declaration for a call to an external library."
	| descriptorClass callType modifier retType externalName args argType module fn |
	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent: [ ^ false ].
	callType := descriptorClass callingConventionFor: here.
	callType == nil ifTrue:[^false].
	[modifier := descriptorClass callingConventionModifierFor: token.
	 modifier notNil] whileTrue:
		[self advance.
		 callType := callType bitOr: modifier].
	"Parse return type"
	self advance.
	retType := self externalType: descriptorClass.
	retType == nil ifTrue:[^self expected:'return type'].
	"Parse function name or index"
	externalName := here.
	(self match: #string) 
		ifTrue:[externalName := externalName asSymbol]
		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].
	(self match: #leftParenthesis) ifFalse:[^self expected:'argument list'].
	args := WriteStream on: Array new.
	[self match: #rightParenthesis] whileFalse:[
		argType := self externalType: descriptorClass.
		argType == nil ifTrue:[^self expected:'argument'].
		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType]].
	(self matchToken: 'module:') ifTrue:[
		module := here.
		(self match: #string) ifFalse:[^self expected: 'String'].
		module := module asSymbol].
	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|
		fn := xfn name: externalName 
				module: module 
				callType: callType
				returnType: retType
				argumentTypes: args contents.
		self allocateLiteral: fn].
	(self matchToken: 'error:')
		ifTrue:
			[| errorCodeVariable |
			 errorCodeVariable := here.
			(hereType == #string
			 or: [hereType == #word]) ifFalse:[^self expected: 'error code (a variable or string)'].
			 self advance.
			 self addPragma: (Pragma keyword: #primitive:error: arguments: (Array with: 120 with: errorCodeVariable)).
			 fn ifNotNil: [fn setErrorCodeName: errorCodeVariable]]
		ifFalse:
			[self addPragma: (Pragma keyword: #primitive: arguments: #(120))].
	^true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3004-externalFunctionDeclaration-JuanVuletich-2016Dec19-12h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 1:08:36 pm'!

SmallInteger class
	instanceVariableNames: 'minVal maxVal '!

!classDefinition: 'SmallInteger class' category: #'Kernel-Numbers'!
SmallInteger class
	instanceVariableNames: 'minVal maxVal'!
!SmallInteger class methodsFor: 'class initialization' stamp: 'jmv 12/19/2016 13:03:09'!
                    initMinValAndMaxVal
	| next val |
	val := -32768. "Assume at least 16 bits"
	[next := val + val.
	 next class == self] whileTrue:
		[val := next].
	minVal := val.
	maxVal := -1 - val! !
!SystemDictionary methodsFor: 'image' stamp: 'jmv 12/19/2016 13:04:12' prior: 16925538!
              wordSize
	"Answer the size in bytes of an object pointer or word in the object memory.
	The value does not change for a given image, but may be modified by a SystemTracer
	when converting the image to another format. The value is cached in WordSize to
	avoid the performance overhead of repeatedly consulting the VM."

	"Smalltalk wordSize"

	^ WordSize ifNil: [
		SmallInteger initMinValAndMaxVal.
		WordSize := [self vmParameterAt: 40] on: Error do: [4]]! !

SmallInteger class
	instanceVariableNames: 'minVal maxVal'!

!classDefinition: 'SmallInteger class' category: #'Kernel-Numbers'!
SmallInteger class
	instanceVariableNames: 'minVal maxVal'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmallInteger initMinValAndMaxVal!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3005-SmallInteger-minVal-maxVal-part1-JuanVuletich-2016Dec19-12h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3005] on 19 December 2016 at 1:12:20 pm'!
!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:06:38' prior: 16909182!
    maxVal
	"Answer the maximum value for a SmallInteger."

	"Ensure word size is properly set. If so, maxVal is also set."
	Smalltalk wordSize.
	^maxVal! !
!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:07:24' prior: 16909186!
         minVal
	"Answer the minimum value for a SmallInteger."

	"Ensure word size is properly set. If so, minVal is also set."
	Smalltalk wordSize.
	^minVal! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3006-SmallInteger-minVal-maxVal-part2-JuanVuletich-2016Dec19-13h11m-jmv.1.cs.st----!

----SNAPSHOT----#(19 December 2016 1:35:50.759973 pm) Cuis5.0-3006.image priorSource: 54639!

----QUIT----#(19 December 2016 1:36:04.087323 pm) Cuis5.0-3006.image priorSource: 62549!

----STARTUP----#(19 December 2016 1:44:23.302825 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3006.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3006] on 19 December 2016 at 1:42:27 pm'!
!SmallFloat64 commentStamp: '<historical>' prior: 16908181!
 My instances represent 64-bit Floats whose exponent fits in 8 bits as immediate objects. This representation is only available on 64-bit systems, not 32-bit systems.!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmallFloat64 tryPrimitive: 161 withArgs: #(999).
!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3007-SmallFloat64-fixHash-forSpur64Conversion-JuanVuletich-2016Dec19-13h41m-jmv.1.cs.st----!

----SNAPSHOT----#(19 December 2016 1:44:31.161473 pm) Cuis5.0-3007.image priorSource: 62643!

----QUIT----#(19 December 2016 1:44:42.243314 pm) Cuis5.0-3007.image priorSource: 63669!

----STARTUP----#(2 January 1901 12:00:00.287686024 am) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3007.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3007] on 22 December 2016 at 4:05:04 pm'!
!LargePositiveInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
                isLarge
	^true! !
!SmallInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
           isLarge
	^false! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 23:01'!
                           long64At: index bigEndian: bigEndian
	"Return a 64-bit signed integer quantity starting from the given byte index."

	| value |
	value := self unsignedLong64At: index bigEndian: bigEndian.
	value digitLength < 8 ifTrue: [ ^value ].
	(value digitAt: 8) < 16r80 ifTrue: [ ^value ].
	^value - 16r10000000000000000! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 22:57'!
                    long64At: index put: value bigEndian: bigEndian
	"Store a 64-bit signed integer quantity starting from the given byte index."
	
	^self
		unsignedLong64At: index
		put: (value negative
			ifFalse: [ value ]
			ifTrue: [ value + 16r10000000000000000 ])
		bigEndian: bigEndian! !
!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:36'!
                        unsignedLong64At: index bigEndian: bigEndian
	"Return a 64-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."

	| byte |
	SmallInteger maxVal >  1073741823 ifTrue:
		[bigEndian
			ifTrue: "64-bit SmallIntegers have a 3 bit tag and a sign bit, so the most positive value has 16rF as its top byte."
				[(byte := self at: index) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)) bitShift: 8)
						+ (self at: index + 4) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)]]
			ifFalse:
				[(byte := self at: index + 7) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 4)) bitShift: 8)
						+ (self at: index + 3) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)]]].
	bigEndian ifFalse: [
		(byte := self at: index + 7) = 0 ifFalse: [
			^(LargePositiveInteger new: 8)
				replaceFrom: 1 to: 8 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 6) = 0 ifFalse: [
			^(LargePositiveInteger new: 7)
				replaceFrom: 1 to: 7 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 5) = 0 ifFalse: [
			^(LargePositiveInteger new: 6)
				replaceFrom: 1 to: 6 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 4) = 0 ifFalse: [
			^(LargePositiveInteger new: 5)
				replaceFrom: 1 to: 5 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 3) <= 16r3F ifFalse: [
			^(LargePositiveInteger new: 4)
				replaceFrom: 1 to: 4 with: self startingAt: index;
				normalize ].
		^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
	(byte := self at: index) = 0 ifFalse: [
		^(LargePositiveInteger new: 8)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: (self at: index + 1);
			digitAt: 8 put: byte;
			normalize ].
	(byte := self at: index + 1) = 0 ifFalse: [	
		^(LargePositiveInteger new: 7)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: byte;
			normalize ].
	(byte := self at: index + 2) = 0 ifFalse: [	
		^(LargePositiveInteger new: 6)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: byte;
			normalize ].
	(byte := self at: index + 3) = 0 ifFalse: [	
		^(LargePositiveInteger new: 5)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: byte;
			normalize ].		
	(byte := self at: index + 4) <= 16r3F ifFalse: [
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: byte;
			normalize ].
	^(((byte bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:18'!
        unsignedLong64At: index put: value bigEndian: bigEndian
	"Store a 64-bit unsigned integer quantity starting from the given byte index"
	
	| i j |
	value isLarge ifTrue: [
		i := value digitLength.
		bigEndian ifFalse: [
			self
				replaceFrom: index
					to: index + i - 1
					with: value 
					startingAt: 1;
				replaceFrom: index + i
					to: index + 7
					with: #[0 0 0 0 0 0 0 0]
					startingAt: 1.
			^value ].
		j := index + 8.
		i <= 7 ifTrue: [
			self
				replaceFrom: index
				to: j - i - 1
				with: #[0 0 0 0 0 0 0 0]
				startingAt: 1 ].
		[ 1 <= i ] whileTrue: [
			self at: j - i put: (value digitAt: i).
			i := i - 1 ].
		^value ].
	bigEndian ifFalse: [
		j := index - 1.
		i := value.
		[ 1 <= i ] whileTrue: [
			self at: (j := j + 1) put: (i bitAnd: 16rFF).
			i := i bitShift: -8 ].
		self replaceFrom: j + 1
			to: index + 7
			with: #[0 0 0 0 0 0 0 0]
			startingAt: 1.
		^value ].
	j := index + 8.
	i := value.
	[ 1 <= i ] whileTrue: [
		self at: (j := j - 1) put: (i bitAnd: 16rFF).
		i := i bitShift: -8 ].
	self replaceFrom: index
		to: j - 1
		with: #[0 0 0 0 0 0 0 0]
		startingAt: 1.
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:28' prior: 16793638!
                    longAt: index bigEndian: bigEndian
	"Return a 32-bit integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	
	| byte result |
	bigEndian ifFalse: [
		(byte := self at: index + 3) <= 16r7F ifTrue: [ "Is the result non-negative?"
			byte <= 16r3F ifTrue: [
				^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
			^(LargePositiveInteger new: 4)
				replaceFrom: 1
					to: 4
					with: self
					startingAt: index;
				normalize ].
		"Negative"
		byte >= 16rC0 ifTrue: [
			^-1 - (((((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index) bitXor: 16rFF)) ].
		(result := LargeNegativeInteger new: 4)
			digitAt: 4 put: ((self at: index + 3) bitXor: 16rFF);
			digitAt: 3 put: ((self at: index + 2) bitXor: 16rFF);
			digitAt: 2 put: ((self at: index + 1) bitXor: 16rFF).
		(byte := ((self at: index) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
			^result
				digitAt: 1 put: byte;
				normalize ].
		^result
			digitAt: 1 put: 16rFF;
			- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this." ].
	(byte := self at: index) <= 16r7F ifTrue: [ "Is the result non-negative?"
		byte <= 16r3F ifTrue: [
			^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3) ].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize ].
	"Negative"
	16rC0 <= byte ifTrue: [
		^-1 - (((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index + 3) bitXor: 16rFF)) ].
	(result := LargeNegativeInteger new: 4)
		digitAt: 4 put: (byte bitXor: 16rFF);
		digitAt: 3 put: ((self at: index + 1) bitXor: 16rFF);
		digitAt: 2 put: ((self at: index + 2) bitXor: 16rFF).
	(byte := ((self at: index + 3) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
		^result
			digitAt: 1 put: byte;
			normalize ].
	^result 
		digitAt: 1 put: 16rFF;
		- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this."! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 17:13' prior: 16793658!
             longAt: index put: value bigEndian: bigEndian
	"Store a 32-bit signed integer quantity starting from the given byte index"
	
	| v v2 |
	value isLarge ifTrue: [
		bigEndian ifFalse: [
			value positive ifTrue: [
				self 
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			v := 0.
			[ v <= 3 and: [ (v2 := ((value digitAt: v + 1) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
				self at: index + v put: 0.
				v := v + 1 ].
			self at: index + v put: v2.
			v := v + 1.
			[ v <= 3 ] whileTrue: [
				self at: index + v put: ((value digitAt: (v := v + 1)) bitXor: 16rFF) ].
			^value ].
		value positive ifTrue: [
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index + 3 put: (value digitAt: 1).
			^value ].
		v := 3.
		[ 0 <= v and: [ (v2 := ((value digitAt: 4 - v) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
			self at: index + v put: 0.
			v := v - 1 ].
		self at: index + v put: v2.
		[ 0 <= (v := v - 1) ] whileTrue: [
			self at: index + v put: ((value digitAt: 4 - v) bitXor: 16rFF) ].
		^value ].
	v := value bitShift: -24.
	0 <= (v := (v bitAnd: 16r7F) - (v bitAnd: 16r80)) ifFalse: [
		v := v + 16r100 ].
	bigEndian ifFalse: [
		self 
			at: index put: (value bitAnd: 16rFF);
			at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
			at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
			at: index + 3 put: v.
		^value ].
	self
		at: index put: v;
		at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
		at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
		at: index + 3 put: (value bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16' prior: 16793680!
      shortAt: index bigEndian: bigEndian
	"Return a 16-bit signed integer quantity starting from the given byte index"

	| result |
	result := bigEndian
		ifFalse: [ ((self at: index + 1) bitShift: 8) + (self at: index) ]
		ifTrue: [ ((self at: index) bitShift: 8) + (self at: index + 1) ].
	result < 16r8000 ifTrue: [ ^result ].
	^result - 16r10000! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16' prior: 16793690!
   shortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit signed integer quantity starting from the given byte index"
	
	| unsignedValue |
	(unsignedValue := value) < 0 ifTrue: [
		unsignedValue := unsignedValue + 16r10000 ].
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (unsignedValue bitShift: -8);
			at: index put: (unsignedValue bitAnd: 16rFF).
		^value ].
	self
		at: index put: (unsignedValue bitShift: -8);
		at: index + 1 put: (unsignedValue bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:20' prior: 16793700!
                  unsignedLongAt: index bigEndian: bigEndian
	"Return a 32-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	| byte |
	bigEndian ifTrue:
		[((byte := self at: index) <= 16r3F
		 or: [SmallInteger maxVal >  1073741823]) ifTrue:
			[^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize].
	((byte := self at: index + 3) <= 16r3F
	 or: [SmallInteger maxVal >  1073741823]) ifTrue:
		[^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)].
	^(LargePositiveInteger new: 4)
		replaceFrom: 1 to: 4 with: self startingAt: index;
		normalize! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33' prior: 16793720!
  unsignedLongAt: index put: value bigEndian: bigEndian
	"Store a 32-bit unsigned integer quantity starting from the given byte index"
	
	value isLarge
		ifTrue: [
			bigEndian ifFalse: [
				self
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index +3 put: (value digitAt: 1) ]
		ifFalse: [
			bigEndian ifFalse: [
				self 
					at: index put: (value bitAnd: 16rFF);
					at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
					at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
					at: index + 3 put: (value bitShift: -24).
				^value ].
			self 
				at: index put: (value bitShift: -24);
				at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
				at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
				at: index + 3 put: (value bitAnd: 16rFF) ].
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33' prior: 16793740!
                 unsignedShortAt: index bigEndian: bigEndian
	"Return a 16-bit unsigned integer quantity starting from the given byte index"

	bigEndian ifFalse: [ ^((self at: index + 1) bitShift: 8) + (self at: index) ].
	^((self at: index) bitShift: 8) + (self at: index + 1)
	! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 15:29' prior: 16793751!
                     unsignedShortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit unsigned integer quantity starting from the given byte index"
	
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (value bitShift: -8);
			at: index put: (value bitAnd: 16rFF).
		^value ].
	self
		at: index put: (value bitShift: -8);
		at: index+1 put: (value bitAnd: 16rFF).
	^value! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3008-ByteArray-UpdateToSqueak-JuanVuletich-2016Dec22-15h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3008] on 26 December 2016 at 2:54:38 pm'!
!Float64Array methodsFor: 'accessing' stamp: 'jmv 12/26/2016 14:53:06' prior: 16846088!
            floatAt: index put: aFloat
	"Store the argument (e.g., 64 bit Float) at the given index
	Use the same internal representation as BoxedFloat64. I.e. a BoxedFloat64 and a Float64Array of size 1 hold the same bits.
	Allow subclasses to redefine #at:put:"

	"This breaks with SmallFloat64"
	"self replaceWordsFrom: index * 2 - 1 to: index * 2  with: aFloat asFloat startingAt: 1."

	"Float >>basicAt: acts as if Floats were stored in big endian format. Our instances are in platform endianess."
	Smalltalk isLittleEndian
		ifTrue: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 2).
			self basicAt: index * 2 put: (aFloat basicAt: 1) ]
		ifFalse: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 1).
			self basicAt: index * 2 put: (aFloat basicAt: 2) ].
	^aFloat! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3009-Float64Array-fixForSmallFloats-JuanVuletich-2016Dec26-14h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3009] on 27 December 2016 at 12:14:57 pm'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/27/2016 12:14:33' prior: 16922764!
                         saveAsNewVersion
	"Save the image/changes using the next available version number."
	"
	Smalltalk saveAsNewVersion
	"
	| fileName newName changesName systemVersion |
	self okayToSave ifFalse: [ ^ self ].
	systemVersion _ SystemVersion current.
	fileName _ String streamContents: [ :strm |
		strm
			nextPutAll: 'Cuis';
			print: systemVersion versionMajor;
			nextPut: $.;
			print: systemVersion versionMinor;
			nextPut: $-;
			print: systemVersion highestUpdate.
		Smalltalk isSpur ifTrue: [
			strm nextPutAll: '-spur'.
			Smalltalk wordSize = 8 ifTrue: [
				strm nextPutAll: '-64' ]]].
	newName _ fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName _ DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName _ self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		^ self inform:
'There is already .changes file of the desired name,
', newName, '
curiously already present, even though there is
no corresponding .image file.   Please remedy
manually and then repeat your request.' ].
	"Try to clear all user state, including all class vars, preferences, etc"
	self saveAs: newName andQuit: false clearAllClassState: true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3010-saveAsNewVersion-spur64-JuanVuletich-2016Dec27-12h14m-jmv.1.cs.st----!

----SNAPSHOT----#(2 January 1901 12:00:00.287686028 am) Cuis5.0-3010.image priorSource: 63763!

----QUIT----#(2 January 1901 12:00:01.300992248 am) Cuis5.0-3010.image priorSource: 81495!

----STARTUP----#(1 January 1901 12:00:01.008123888 am) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3010.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3009] on 27 December 2016 at 9:51:30 am'!
!Float64Array methodsFor: 'accessing' stamp: 'jmv 12/27/2016 09:51:21' prior: 50334111!
                             floatAt: index put: aNumber
	"Store the argument (e.g., 64 bit Float) at the given index
	Use the same internal representation as BoxedFloat64. I.e. a BoxedFloat64 and a Float64Array of size 1 hold the same bits.
	Allow subclasses to redefine #at:put:"

	"This breaks with SmallFloat64"
	"self replaceWordsFrom: index * 2 - 1 to: index * 2  with: aFloat asFloat startingAt: 1."

	"Float >>basicAt: acts as if Floats were stored in big endian format. Our instances are in platform endianess."
	| aFloat |
	aFloat _ aNumber asFloat.
	Smalltalk isLittleEndian
		ifTrue: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 2).
			self basicAt: index * 2 put: (aFloat basicAt: 1) ]
		ifFalse: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 1).
			self basicAt: index * 2 put: (aFloat basicAt: 2) ].
	^aFloat! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3011-Float64Array-fixForSmallIntegers-JuanVuletich-2016Dec27-09h51m-jmv.1.cs.st----!

----SNAPSHOT----#(2 January 1901 12:00:01.758557225 am) Cuis5.0-3011.image priorSource: 81591!

----QUIT----#(2 January 1901 12:00:00.91421204 am) Cuis5.0-3011.image priorSource: 82989!

----STARTUP----#(18 January 2017 10:33:47.310842 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3011.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3011] on 29 December 2016 at 11:02:24 am'!

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!Inspector methodsFor: 'user commands' stamp: 'jmv 12/29/2016 10:58:58'!
                            inspectSelection
	self selection inspect! !
!ObjectExplorer methodsFor: 'user commands' stamp: 'jmv 12/29/2016 11:01:35'!
      inspectSelection
	self object inspect! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:55:06'!
         doubleClick: aMouseButtonEvent localPosition: localEventPosition

	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	^ self model perform: doubleClickSelector! !
!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:55:42'!
                 doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:41:28'!
              doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:53:49' prior: 16853080!
   mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [ ^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 10:59:15' prior: 16831023!
 buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| upperMorph receiverInspector receiverInspectorText contextVariableInspector contextVariableInspectorText bottomMorph |

	upperMorph _ PluggableListMorph
		model: model 
		listGetter: #contextStackList
		indexGetter: #contextStackIndex
		indexSetter: #toggleContextStackIndex:
		mainView: self
		menuGetter: #contextStackMenu
		keystrokeAction: #contextStackKey:from:.

	receiverInspector _ PluggableListMorph
			model: model receiverInspector
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #receiverFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	receiverInspector doubleClickSelector: #inspectSelection.
	receiverInspectorText _ TextModelMorph
			textProvider: model receiverInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	contextVariableInspector _ PluggableListMorph
			model: model contextVariablesInspector 
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #contextFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	contextVariableInspector doubleClickSelector: #inspectSelection.
	contextVariableInspectorText _ TextModelMorph
			textProvider: model contextVariablesInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.

	bottomMorph _ LayoutMorph newRow.
	bottomMorph
		addMorph: receiverInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: receiverInspectorText proportionalWidth: 0.3;
		addAdjusterAndMorph: contextVariableInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: contextVariableInspectorText proportionalWidth: 0.3.

	self layoutMorph
		addMorph: upperMorph proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:06' prior: 16857200!
                    buildMorphicWindow
	" Inspector openOn: SystemOrganization "
	| contentsText list upperRow evaluatorText label |
	"Build widgets. We'll assemble them below."
	list _ PluggableListMorph
			model: model 
			listGetter: #fieldList
			indexGetter: #selectionIndex
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #fieldListMenu
			keystrokeAction: #inspectorKey:from:.
	list doubleClickSelector: #inspectSelection.
	contentsText _ TextModelMorph
			textProvider: model
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	evaluatorText _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	"Upper row has two widgets, side by side: the list of variables at the left side, and the variable contents pane at the right side."
	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: list proportionalWidth: 0.3;
		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.
	"Inspector Window has two rows: At the top, the one we just bult. Below it, the evaluation pane."
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.7;
		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.
	"Set label"
	label _ [model object printStringLimitedTo: 64]
		on: UnhandledError
		do: [:ex | ex return: model object class printString, ' (printing failed)'].
	(label includesSubString: model object  class name)
		ifFalse: [label _ model object  class name, ': ', label].
	self setLabel: label! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:46' prior: 16883288!
buildMorphicWindow

	| textMorph |
	listMorph _ HierarchicalListMorph
			model: model
			listGetter: #getList
			indexGetter: #getCurrentSelection
			indexSetter: #noteNewSelection:
			mainView: self
			menuGetter: #genericMenu
			keystrokeAction: #explorerKey:from:.
	listMorph autoDeselect: false.
	listMorph doubleClickSelector: #inspectSelection.
	textMorph _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: listMorph proportionalHeight: 0.8;
		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.
	self setLabel: (model rootObject printStringLimitedTo: 64)! !
!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 12/29/2016 10:50:28' prior: 16883479!
             openWeightExplorer
	"Create and schedule a Weight Explorer on the receiver's model's currently selected object."

	^WeightTracer openExplorerOn: model object! !

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3012-DoubleClickOpensInspector-JuanVuletich-2016Dec29-10h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3012] on 29 December 2016 at 11:30:18 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/29/2016 11:29:52' prior: 16902537!
                           parseExternalCall
	self scanNext.
	self failWhen: currentToken isNil.
	self scanPast: #externalCallType.
	currentToken = '*' 
		ifTrue: [self scanPast: #externalCallTypePointerIndicator].
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: 	[
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentTokenFirst == $(.
	self scanPast: #leftParenthesis.
	[currentTokenFirst ~~ $)] 
		whileTrue: [
			self failWhen: currentToken isNil.
			self scanPast: #externalCallType.
			currentToken = '*' 
				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].
	self scanPast: #rightParenthesis.
	currentToken = 'module:' 
		ifTrue: [
			self scanPast: #module.
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3013-Shout-ExternalCallFix-JuanVuletich-2016Dec29-11h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3013] on 29 December 2016 at 3:36:31 pm'!
!CompiledMethod methodsFor: 'file in/out' stamp: 'jmv 12/29/2016 15:25:13' prior: 16820644!
               storeDataOn: aDataStream
	"Store myself on a DataStream.  I am a mixture of objects and raw data bytes.  Only use this for blocks.  Normal methodDictionaries should not be put out using ReferenceStreams.  Their fileOut should be attached to the beginning of the file."

	| byteLength lits |
	"No inst vars of the normal type"
	byteLength _ self basicSize.
	aDataStream
		beginInstance: self class
		size: byteLength.
	lits _ self numLiterals + 1.	"counting header"
	1 to: lits do:
		[:ii | aDataStream nextPut: (self objectAt: ii)].
	lits*Smalltalk wordSize+1 to: byteLength do:
		[:ii | aDataStream byteStream nextPut: (self basicAt: ii)].
			"write bytes straight through to the file"! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 12/29/2016 15:27:40' prior: 16827456!
                   readMethod
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod lits |

	instSize _ (byteStream nextUnsignedInt32BigEndian: true) - 1.
	refPosn _ self getCurrentReference.
	className _ self next.
	newClass _ Smalltalk at: className asSymbol.

	xxHeader _ self next.
		"nArgs _ (xxHeader >> 24) bitAnd: 16rF."
		"nTemps _ (xxHeader >> 18) bitAnd: 16r3F."
		"largeBit _ (xxHeader >> 17) bitAnd: 1."
	nLits _ (xxHeader >> 9) bitAnd: 16rFF.
		"primBits _ ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."
	byteCodeSizePlusTrailer _ instSize - (newClass instSize "0") - (nLits + 1 * Smalltalk wordSize).

	newMethod _ newClass 
		newMethod: byteCodeSizePlusTrailer
		header: xxHeader.

	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	self beginReference: newMethod.
	lits _ newMethod numLiterals + 1.	"counting header"
	2 to: lits do:
		[:ii | newMethod objectAt: ii put: self next].
	lits*Smalltalk wordSize+1 to: newMethod basicSize do:
		[:ii | newMethod basicAt: ii put: byteStream next].
			"Get raw bytes directly from the file"
	self setCurrentReference: refPosn.  "before returning to next"
	^ newMethod! !
!DataStream methodsFor: 'other' stamp: 'jmv 12/29/2016 15:36:22' prior: 16827907!
            vacantRef
	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference
	 position' to identify a reference that's not yet filled in. This must be a
	 value that won't be used as an ordinary reference. Cf. outputReference: and
	 readReference. -- 
	 NOTE: We could use a different type ID for vacant-refs rather than writing
		object-references with a magic value. (The type ID and value are
		overwritten by ordinary object-references when weak refs are fullfilled.)"

	"In 32 bit Cuis it was:"
	"^ SmallInteger maxVal"

	"Use that very same value even if in 64 bit Cuis.
	This means that DataStreams are limited to 1GibiBytes in size."
	^16r3FFFFFFF! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3014-DataStream-FixFor64Bits-JuanVuletich-2016Dec29-15h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 10 December 2016 at 10:41:46 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/10/2016 01:38:21'!
                              xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	token _ Compiler evaluate: buffer contents.
	tokenType _ #literal! !
!Character methodsFor: 'testing' stamp: 'jmv 12/10/2016 01:26:44' prior: 16800539!
               isValidInIdentifiers
	"Can c be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ #( $_ ) statePointsTo: self ]! !
!CompiledMethod methodsFor: 'comparing' stamp: 'jmv 12/10/2016 01:27:06' prior: 16819629!
  = method
	| numLits lit1 lit2 |

	"Any object is equal to itself"
	self == method ifTrue: [ ^ true ].

	"Answer whether the receiver implements the same code as the 
	argument, method."
	(method is: #CompiledMethod) ifFalse: [ ^false ].
	self size = method size ifFalse: [ ^false ].
	self header = method header ifFalse: [ ^false ].
	self initialPC to: self endPC do: [ :i |
		(self at: i) = (method at: i) ifFalse: [ ^false ]].
	(numLits _ self numLiterals) ~= method numLiterals ifTrue: [ ^false ].

	"Dont bother checking FFI and named primitives''
	jmv: Does this make any sense?
	 (#(117 120) includes: self primitive) ifTrue: [^ true]."

	 "properties"
	(self properties analogousCodeTo: method properties) ifFalse: [
		^false ].

	"#penultimateLiteral is selector (or properties, just compared, above)
	Last literal is #methodClass.
	Don't compare them. Two methods might be equal even if they have different selector (or none at all)
	or are installed in different classes (or none at all)"
	1 to: numLits-2 do: [ :i |
		lit1 _ self literalAt: i.
		lit2 _ method literalAt: i.
		lit1 = lit2 ifFalse: [
			(i = 1 and: [ #(117 120) includes: self primitive ])
				ifTrue: [
					lit1 isArray
						ifTrue: [
							(lit2 isArray and: [ lit1 allButLast = lit2 allButLast ]) ifFalse: [
								^false ]]
						ifFalse: [ "ExternalLibraryFunction"
							(lit1 analogousCodeTo: lit2) ifFalse: [
								^false ]]]
				ifFalse: [
					 lit1 isFloat
						ifTrue: [
							"Floats match if values are close, due to roundoff error."
							(lit1 closeTo: lit2) ifFalse: [ ^false ].
							self flag: 'just checking'. self halt ]
						ifFalse: [
							"any other discrepancy is a failure"
							^ false ]]]].
	^true! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 12/10/2016 01:26:17' prior: 16904329!
     initTypeTable
	| newTable |
	newTable := Array new: 256 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"

	1 to: 255
		do: [:index |
			(Character numericValue: index) isValidInIdentifiers
				ifTrue: [
					"Digits and $_ are overwritten later"
					newTable at: index put: #xLetter ]].

	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable atAll:  '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.

	newTable at: Scanner doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 12/10/2016 01:42:02' prior: 16901958!
                             scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator or: [c == $`]]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 12/10/2016 10:24:38' prior: 16902078!
    isBinarySelectorCharacter: aCharacter

	aCharacter isValidInIdentifiers ifTrue: [^false].
	aCharacter isSeparator ifTrue: [^false].

	('"#$'':().;[]{}_`'  includes: aCharacter) 
		ifTrue:[^false].
	aCharacter numericValue = Scanner doItCharacterValue ifTrue: [^false "the doIt char"].
	aCharacter numericValue = 0 ifTrue: [^false].
	"Any other char is ok as a binary selector char."
	^true! !

Scanner removeSelector: #scanStringStruct!

Scanner removeSelector: #scanStringStruct!

Scanner removeSelector: #scanStringStruct:!

Scanner removeSelector: #scanStringStruct:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Scanner initTypeTable!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3015-Backticks-JuanVuletich-2016Dec10-10h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3015] on 29 December 2016 at 4:06:32 pm'!
!LiteralNode methodsFor: 'printing' stamp: 'jmv 12/29/2016 16:06:13' prior: 16865098!
                             printOn: aStream indent: level

	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream nextPutAll: '###'; nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream nextPutAll: '##'; nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ key storeOn: aStream ]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $`.
					]
			]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3016-Backticks-SupportInDecompiler-JuanVuletich-2016Dec29-15h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 10:57:00 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/30/2016 10:29:16' prior: 50334659!
  xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	token _ [ Compiler evaluate: buffer contents ] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3017-Backticks-betterErrorMessages-JuanVuletich-2016Dec30-10h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 11:00:38 am'!
!Editor class methodsFor: 'class initialization' stamp: 'jmv 12/30/2016 11:00:14' prior: 16836909!
               initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c |
		c basicInitialize ]! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/30/2016 10:34:01' prior: 16931735!
        enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (String with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (String with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^true! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 12/30/2016 10:33:45' prior: 16933087!
        basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< #enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:				'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:		'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R	#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y	#makeUppercase:		'Force selection to uppercase')
		#(		$U	#changeLineEndsToLf:	'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:		'Move cursor to start of text')
		#(		$L	#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z	#redo:						'Redo (multiple levels)')
		#(		$X	#makeLowercase:		'Force selection to lowercase')
		#(		$C	#compareToClipboard:	'Compare argument to clipboard')

		#(		$ 	#selectWord:				'Select the current word as with double clicking')
	)! !
!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 12/30/2016 10:36:10' prior: 16910578!
                     selectWord
	"Select delimited text or word--the result of double-clicking."

	| leftDelimiters rightDelimiters |
	"Warning. Once me (jmv) added Character crCharacter to the delimiters, to make double-click at and of line select whole line.
	This had the bad effect that if a class name is the last word of a line, double-click would correctly select it, but after that,
	doing ctrl-b to browse it would select the whole line..."
	leftDelimiters _ '([{<|''"`'.
	rightDelimiters _ ')]}>|''"`'.
	^self selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters! !

Editor initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3018-Backticks-editorSupport-JuanVuletich-2016Dec30-10h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 11:01:51 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:03'!
                     parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'scan' stamp: 'tween 2/17/2007 14:51' prior: 50334790!
 scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:08' prior: 16902861!
                              parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst == $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst == $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst == $[ ifTrue: [^self parseBlock].
	currentTokenFirst == $` ifTrue: [^self parseBacktick].
	currentTokenFirst == ${ 
		ifTrue: [
			self scanPast: #leftBrace.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3019-Backticks-BetterShoutSupport-JuanVuletich-2016Dec30-11h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3019] on 30 December 2016 at 11:46:58 am'!
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 12/30/2016 11:44:19' prior: 50332635!
                     setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		classOrMetaClass ifNotNil: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3020-AvoidUnwantedSubscriptInClassDefinitions-JuanVuletich-2016Dec30-11h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3020] on 2 January 2017 at 2:27:29 pm'!
!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/2/2017 14:18:06'!
                       usePreDebugWindow
	^ self
		valueOfFlag: #usePreDebugWindow
		ifAbsent: [ false ].! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:03'!
   initialFrameIn: aWorld
	^RealEstateAgent initialFrameFor: self world: aWorld! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 1/2/2017 14:13:23'!
     initialFrameIn: aWorld
	| e |
	e _ self runningWorld morphExtent.
	^(0@0 corner: e) insetBy: e // 10! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:12' prior: 16926575!
 openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect _ self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse) "
	WorldState addDeferredUIMessage: [ self activate ]! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 1/2/2017 14:19:05' prior: 16892694!
        open: model label: aString message: messageString
	|  window |
	Preferences usePreDebugWindow
		ifTrue: [
			window _ self new.
			window
				model: model;
				buildMorphicWindowMessage: messageString print.
			aString ifNotNil: [ window setLabel: aString ].
			 window openInWorld ]
		ifFalse: [
			model openFullMorphicLabel: aString ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3021-DebuggerUsabilityEnh-JuanVuletich-2017Jan02-14h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3021] on 3 January 2017 at 9:34:24 pm'!
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/3/2017 21:22:43'!
                         nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ super nextPutAllString: aString withAttributes: attributesArray ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 21:21:34'!
          isCompatibleWithContents: aCollection

	collection class == aCollection class
		ifTrue: [ ^ true ].

	(aCollection isString and: [ collection is: #Text])
		ifTrue: [ ^ true ].

	^ false! !
!PositionableStream methodsFor: 'testing' stamp: 'jmv 1/3/2017 10:57:48' prior: 16891569!
         isText
	"Return true if the receiver is a Text stream"
	^collection is: #Text! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/3/2017 21:22:51' prior: 16946406!
                          nextPutAll: aCollection

	| newEnd |
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd _ position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position _ newEnd.! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:15' prior: 16946621!
                             withAttribute: aTextAttribute do: streamBlock
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	collection addAttribute: aTextAttribute from: pos1+1 to: self position.
	^ val! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:19' prior: 16946627!
                withAttributes: attributes do: streamBlock 
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	attributes do: [:attribute |
		collection
			addAttribute: attribute
			from: pos1 + 1
			to: self position].
	^ val! !

Text class removeSelector: #streamContents:!

Text class removeSelector: #streamContents:!

Smalltalk removeClassNamed: #TextStream!

Smalltalk removeClassNamed: #TextStream!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3022-TextStream-removal-JuanVuletich-2017Jan03-21h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3022] on 4 January 2017 at 10:42:00 am'!
!SmallInteger methodsFor: 'system primitives' stamp: 'jmv 1/4/2017 10:35:09' prior: 16909090!
     digitAt: n 
	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."
	n > Smalltalk wordSize ifTrue: [^ 0].
	self < 0
		ifTrue: 
			[self = SmallInteger minVal ifTrue: [
				"Can't negate minVal -- treat specially"
				^ Smalltalk wordSize = 4
					ifTrue: [ #(0 0 0 64) at: n ]
					ifFalse: [ #(0 0 0 0 0 0 0 16) at: n ]].
			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]
		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3023-SmallInteger-digitAt-fixFor64Bits-JuanVuletich-2017Jan04-10h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3022] on 4 January 2017 at 10:46:32 am'!

Integer class removeSelector: #byte1:byte2:byte3:byte4:!

Integer class removeSelector: #byte1:byte2:byte3:byte4:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3024-Integer-from4Bytes-removal-JuanVuletich-2017Jan04-10h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3024] on 6 January 2017 at 10:05:27 am'!
!WeakArray class methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:56:14'!
startUp
	"Do it even if just continuing after image snapshot"
	self restartFinalizationProcess! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 1/6/2017 09:59:32'!
                      doStartUp: isARealStartup
	"
	isARealStartup
		true: system is coming up (VM and image just started)
		false: we have just saved an image snapshot, but didn't quit.
	"

	"Here, startup begins!!"
	Cursor normal activateCursor.
	self setGCParameters.
	isARealStartup ifTrue: [
		self clearExternalObjects ].
	self readCommandLineArguments.
	self processStartUpList: isARealStartup.
	isARealStartup ifTrue: [
		self setPlatformPreferences.
		self setStartupStamp ]! !
!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:52:14' prior: 16785037!
                        startUp
	"This message is sent to registered classes when the system is coming up, or after an image save."! !
!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:53:18' prior: 16785042!
                          startUp: isARealStartup
	"This message is sent to registered classes, with isARealStartup = true when the system is coming up,
	and with isARealStartup = false after a snapshot (image save, no quit).
	Classes caring about the difference should reimplement this method."

	^ self startUp! !
!WeakArray class methodsFor: 'class initialization' stamp: 'jmv 1/6/2017 09:49:16' prior: 16943683!
                          initialize
	"
	WeakArray initialize.
	SystemDictionary initialize.
	"

	self restartFinalizationProcess! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:53:30' prior: 16922685!
                   processStartUpList: isARealStartup
	"Send #startUp to each class that needs to run initialization after a snapshot."

	EndianCache _ self calcEndianness.
	self send: #startUp: toClassesNamedIn: StartUpList with: isARealStartup! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:55:41' prior: 16922813!
                        send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is ia real startup (or just continue after image save) (for #startUp:).
	If any name cannot be found, then remove it from the list."

	| removals class |
	removals _ OrderedCollection new.
	startUpOrShutDownList do:
		[:name |
		class _ self at: name ifAbsent: nil.
		class
			ifNil: [removals add: name]
			ifNotNil: [
				class isInMemory ifTrue: [
					class perform: startUpOrShutDown with: argument]]].

	"Remove any obsolete entries, but after the iteration"
	"Well, not. Better just ignore them. Maybe it is stuff, like SoundPlayer, that was moved to optional packages, and can be loaded again anytime."
	"startUpOrShutDownList removeAll: removals"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:59:34' prior: 16922908!
                       snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ ProjectX ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ ProjectX ui ]."
	ProjectX stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: 1024@768 depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	ProjectX spawnNewMorphicProcessFor: (world ifNil: [ PasteUpMorph newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !

SystemDictionary removeSelector: #startup:!

SystemDictionary removeSelector: #startup:!

WeakArray class removeSelector: #startUp:!

WeakArray class removeSelector: #startUp:!

WeakArray initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3025-RestartFinalizationAfterImageSave-JuanVuletich-2017Jan06-09h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:55:29 am'!
!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'jmv 1/13/2017 09:39:07'!
                 bitXor: arg
	"Primitive 36 deals with only 64-bit values (up to 8 byte LargeIntegers).
	The inherited <primitive: 'primDigitBitXor' module:'LargeIntegers'> deals with 
	arbitrary sized large integers, but is much slower.
	This method gives a performance improvement for integers using 32 to 64 bits on 32 bit VMs,
	but only for 62 to 64 bits on 64 bits VMs.
	See http://forum.world.st/Integer-arithmetic-and-bit-operations-in-Squeak-and-Pharo-32bit-amp-64bit-tc4928994.html#none
	"

    <primitive:36>
    ^super bitXor: arg! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3026-LargeInteger-bitXor-performanceImprov-JuanVuletich-2017Jan13-09h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:55:58 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:43'!
                 parseStringOrSymbol

	currentTokenFirst == $' ifTrue: [ ^self parseString ].
	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].
	self error! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 1/13/2017 09:53:38' prior: 16902728!
                         parsePrimitive
	self scanNext.
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: [
			self failUnless: currentTokenFirst == $'.
			self parseString.
			currentToken = 'module:' 
				ifTrue: [
					self scanPast: #module.
					self failUnless: currentTokenFirst == $'.
					self parseString]].
	currentToken = 'error:' ifTrue: [
		self scanPast: #primitive. "there's no rangeType for error"
		self isName
			ifTrue: [ self scanPast: #patternTempVar ]
			ifFalse: [ self parseStringOrSymbol ] ].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3027-ShoutFix-JuanVuletich-2017Jan13-09h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:59:33 am'!
!Float methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:46' prior: 16845694!
                    replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !
!LargePositiveInteger methodsFor: 'system primitives' stamp: 'jmv 1/13/2017 09:58:53' prior: 16862796!
            replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!String methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:04' prior: 16917188!
                    replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:31' prior: 16779882!
                     replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!ByteArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:38' prior: 16793800!
                 replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!Float64Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:50' prior: 16846133!
              replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !
!FloatArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:24' prior: 16846632!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!RunNotArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:00' prior: 16901681!
               replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Copied from Array"
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!WordArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:38' prior: 16945290!
                            replaceFrom: start to: stop with: replacement startingAt: repStart 

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart ! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 1/13/2017 09:57:27' prior: 16787571!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3028-GrabErrorCodeForPrim105-JuanVuletich-2017Jan13-09h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3028] on 14 January 2017 at 8:18:04 am'!
!Point commentStamp: 'jmv 12/30/2016 17:39:06' prior: 16890200!
                  I represent an x-y pair of numbers usually designating a location on the screen.

When dealing with display coordinates, the y axis is usually considered to increase downwards. However, the standard math convention is to consider it increasing upwards. 
Points don't need to know about this. In the first case, theta increases clockwise. In the second case, it increases counter-clockwise, also the standard math convention.

Any method that doesn't follow this (because it assumes one specific convention) include this fact in the selector and in a comment.

My instances are immutable. See #privateSetX:setY:!
!Point methodsFor: 'private' stamp: 'jmv 12/11/2016 10:28:44'!
                             privateSetX: xValue setY: yValue
	"Points are immutable. Right now this is by convention, but we'll make this enfoced by VM.
	Do not all this method, except from instance creation."
	x _ xValue.
	y _ yValue! !
!Point methodsFor: 'copying' stamp: 'pb 10/29/2016 18:18:07'!
                shallowCopy
	"Immutable"
	^ self.! !
!Object class methodsFor: 'instance creation' stamp: 'jmv 12/30/2016 17:33:31' prior: 16882941!
                           unStream: aByteArray
	^ ReferenceStream unStream: aByteArray! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 12/30/2016 17:33:27' prior: 16828091!
                          unStream: aByteArray

	^(self on: ((RWBinaryOrTextStream with: aByteArray) reset; binary)) next! !
!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:14:00' prior: 16890866!
                               r: rho degrees: degrees
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		rho: rho
		theta: degrees asFloat degreesToRadians.! !
!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:12:53' prior: 16890873!
       rho: rho theta: radians
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		x: rho asFloat * radians cos
		y: rho asFloat * radians sin.! !
!Point class methodsFor: 'instance creation' stamp: 'jmv 12/11/2016 10:28:50' prior: 16890880!
                             x: anX y: anY
	"Answer an instance of me with supplied coordinates."

	^self new privateSetX: anX setY: anY! !

Point removeSelector: #setR:degrees:!

Point removeSelector: #setR:degrees:!

Point removeSelector: #setRho:theta:!

Point removeSelector: #setRho:theta:!

Point removeSelector: #setX:setY:!

Point removeSelector: #setX:setY:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3029-Point-immutable-PhilBellalouna-2017Jan14-08h15m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3029] on 14 January 2017 at 8:53:02 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/14/2017 08:52:09' prior: 16920588!
     knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 					'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('BenComan' 			'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 					'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 					'Doug Way')
	#('dgd' 					'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhn'	 				'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DM' 					'Duncan Mak')
	#('DSM' 					'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 					'Hari Balaraman')
	#('hjh' 					'Hannes Hirzel')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 					'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 					'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 					'Mike Rutenberg')
	#('mga' 					'Markus Galli')
	#('mha' 					'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 					'Peter Keeler')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 					'Paul McDonough')
	#('r++' 					'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 					'Ron Teitelbaum')
	#('rr' 						'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 					'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 					'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 					'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sqr' 					'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 					'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 					'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 					'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3030-AddHernanAndGeraToKnownAuthors-JuanVuletich-2017Jan14-08h52m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 10 January 2017 at 8:09:15 pm'!

Object subclass: #TestResultForDebuggingAndInspection
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestResultForDebuggingAndInspection category: #'Tools-Testing'!
Object subclass: #TestResultForDebuggingAndInspection
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!CompiledMethod methodsFor: 'testing' stamp: 'HernanWilkinson 1/10/2017 18:22:10'!
                       isTestMethod

    ^ (self methodClass is: #TestCaseClass) 
		and: [ ((self selector beginsWith: 'test') or: [ (self selector beginsWith: 'should')]) 
		and: [ self numArgs isZero ] ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:14'!
                      acceptAndTest
	
	^self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:34'!
   acceptAndTestAll
	
	^self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ]
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:04:06'!
                 acceptThenTestMethodAndSuite: aSuiteBuilder
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod _ model textProvider currentCompiledMethod.
	self runAndDebuggIfNecessary: potencialTestMethod.
	^(self runTestSuite: (aSuiteBuilder value: potencialTestMethod)) hasPassed
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 18:50:03'!
                     flashWith: aColor

	^morph flashWith: aColor! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 18:50:21'!
flashWithGreen

	^self flashWith: Color green

	
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:03:07'!
                        runAndDebuggIfNecessary: aPotentialTestMethod

	aPotentialTestMethod isTestMethod ifTrue: [
		aPotentialTestMethod methodClass debug: aPotentialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:04:42'!
       runTestSuite: aTestSuite

	| suiteRunResult |
	 
	suiteRunResult _ aTestSuite run.
	suiteRunResult hasPassed 
		ifTrue: [self flashWithGreen ]
		ifFalse: [ suiteRunResult forDebuggingAndInspection inspect ].
		
	^suiteRunResult 

	
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:52'!
 testSuiteForCategoryOf: aClass

	| testCaseClasses |
	
	testCaseClasses _ (SystemOrganization listAtCategoryNamed: aClass category)
		collect: [ :aClassName | Smalltalk classNamed: aClassName ]
		thenSelect: [ :aClassInCategory | aClassInCategory is: #TestCaseClass ].
		
	
	^testCaseClasses
		inject: (TestSuite named: 'Test of Category ', aClass category)
		into: [ :suite :testCaseClass | testCaseClass addToSuiteFromSelectors: suite ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:34:58'!
                      testSuiteOf: aPotentialTestCaseClass

	^(aPotentialTestCaseClass is: #TestCaseClass)
		ifTrue: [ aPotentialTestCaseClass buildSuite ]
		ifFalse: [ TestSuite named: 'Tests of ', aPotentialTestCaseClass name ]! !
!DisplayScreen methodsFor: 'displaying' stamp: 'HernanWilkinson 1/10/2017 18:45:48'!
                        flash: aRectangle with: aColor

	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle.
	(Delay forMilliseconds: 100) wait.
	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle! !
!Morph methodsFor: 'macpal' stamp: 'HernanWilkinson 1/10/2017 18:49:44'!
                           flashWith: aColor

	self morphBoundsInWorld ifNotNil: [ :r | Display flash: r with: aColor ]! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 15:56:51'!
             confirmAcceptAnyway

	^ self confirm: 
'Caution!! Contents were saved
elsewhere since you started
editing them here.  Accept anyway?'! !
!TestCase class methodsFor: 'Testing' stamp: 'HernanWilkinson 1/10/2017 16:29:48'!
    is: aSymbol

	^aSymbol == #TestCaseClass or: [ super is: aSymbol ]! !
!TestResult methodsFor: 'Inspecting' stamp: 'HernanWilkinson 1/10/2017 16:33:03'!
        forDebuggingAndInspection

	^TestResultForDebuggingAndInspection on: self! !
!TestResultForDebuggingAndInspection methodsFor: 'initialization' stamp: 'HernanWilkinson 1/10/2017 16:34:56'!
    initializeOn: aTestResult

	testResult _ aTestResult! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HernanWilkinson 1/10/2017 17:49:59'!
                               print: aCollectionOfTestCases startingWith: header on: aStream
	
	aCollectionOfTestCases
		do: [ :aTestCase |
			aStream 
				nextPutAll: header;
				space;
				nextPutAll: aTestCase class name;
				nextPutAll: ' debug: #';
				nextPutAll: aTestCase selector ]
		separatedBy: [ aStream newLine ].
		
	! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HernanWilkinson 1/10/2017 17:49:05'!
      printOn: aStream

	aStream print: testResult.
	aStream newLine.
	
	self print: testResult errors startingWith: '"E"' on: aStream.
	self print: testResult failures startingWith: '"F"' on: aStream.
	! !
!TestResultForDebuggingAndInspection methodsFor: 'running' stamp: 'HernanWilkinson 1/10/2017 18:14:09'!
               reRun

	| suite |
	 
	suite _ TestSuite new.
	suite addTests: testResult tests.
	
	testResult _ suite run.! !
!TestResultForDebuggingAndInspection class methodsFor: 'instance creation' stamp: 'HernanWilkinson 1/10/2017 16:34:28'!
                          on: aTestResult

	^self new initializeOn: aTestResult! !
!TextEditor methodsFor: 'menu messages' stamp: 'HernanWilkinson 1/10/2017 16:00:24' prior: 16932076!
  acceptContents
	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"
	^morph acceptContents! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 19:58:01' prior: 16910705!
  initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'HernanWilkinson 1/10/2017 17:47:44' prior: 16857247!
                     initialExtent

	^600@325! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 19:46:39' prior: 16855583!
 acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar setValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3031-TDDSupport-0-HernanWilkinson.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 10 January 2017 at 8:09:22 pm'!
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:06'!
         acceptAndTest: aKeyboardEvent

	^self acceptAndTest! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:34'!
                acceptAndTestAll: aKeyboardEvent

	^self acceptAndTestAll! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:02:27'!
          debugIt: aKeyboardEvent

	self debugIt.
	^true! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 20:03:23' prior: 16910661!
                   cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debut it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 19:58:01' prior: 50336244!
                           initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 19:46:39' prior: 50336309!
                           acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar setValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

Editor initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3032-TDDSupport-1-HernanWilkinson.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 12 January 2017 at 5:14:29 pm'!
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:05:16'!
 askForSuperclassOf: aClass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass withAllSuperclasses.
	chosenClassIndex _ PopUpMenu
		withCaption: 'Define #', aSelector, ' in which class?'
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:09:46'!
    create

	self shouldBeAbleToCreateMethod 
		ifTrue: [ self createMethod ]
		ifFalse: [ self inform: 'Only available for doesNotUndertand:' ]! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:04:29'!
   createMethod

	| message chosenClass interruptedContext |
	
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	self implement: message inClass: chosenClass.
! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:01:22'!
           shouldBeAbleToCreateMethod

	^self interruptedContext selector == #doesNotUnderstand:! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 17:04:50' prior: 16831115!
           customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	^#(
		('Restart'		restart				'reset this context to its start.')
		('Into'			send					'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'	fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Create'		create 				'create method'))! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 17:06:02' prior: 16892577!
             buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	(aDebugger shouldBeAbleToCreateMethod) ifTrue: [
		triads add: { 'Create'. #createMethod. 'create the missing method' }
	].
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!PreDebugWindow methodsFor: 'button actions' stamp: 'HAW 1/12/2017 17:06:43' prior: 16892636!
            createMethod
	"Should only be called when this Debugger was created in response to a
	MessageNotUnderstood exception. Create a stub for the method that was
	missing and proceed into it."
	
	model createMethod.
	self debug
! !

PreDebugWindow removeSelector: #askForSuperclassOf:toImplement:ifCancel:!

PreDebugWindow removeSelector: #askForSuperclassOf:toImplement:ifCancel:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3033-CreateMethodSupport-HernanWilkinson-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 12 January 2017 at 6:54:23 pm'!
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:29:00'!
                      allSuperclassesUpTo: aSuperclass
	
	| superclasses |
	
	^ superclass = aSuperclass
		ifTrue: [ OrderedCollection with: aSuperclass]
		ifFalse: [superclasses _ superclass allSuperclassesUpTo: aSuperclass.
			superclasses addFirst: superclass.
			superclasses]! !
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:30:53'!
       withAllSuperclassesUpTo: aSuperclass

	| classes |
	
	classes _ self allSuperclassesUpTo: aSuperclass.
	classes addFirst: self.
	
	^ classes! !
!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:48:35'!
    arguments

	| arguments |

	arguments _ Array new: self selector numArgs.
	1 to: arguments size do: [ :index | arguments at: index put: (self tempAt: index)].

	^arguments.
	
	! !
!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:47:30'!
messageForYourself

	^Message selector: self selector arguments: self arguments.
	! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:14'!
 askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass withAllSuperclassesUpTo: aSuperclass. 
	chosenClassIndex _ PopUpMenu
		withCaption: 'Define #', aSelector, ' in which class?'
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:45:03'!
    createMethodOnSubclassResponsibility

	| message chosenClass subclassResponsibilityContext |
	
	subclassResponsibilityContext _ self interruptedContext sender sender.
	message _ subclassResponsibilityContext messageForYourself.
	
	chosenClass _ self
		askForSuperclassOf: subclassResponsibilityContext receiver class
		upTo: subclassResponsibilityContext method methodClass
		toImplement: message selector
		ifCancel: [^self].
		
	self implement: message inClass: chosenClass context: subclassResponsibilityContext 

! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:43:11'!
              createMethodWhenDoesNotUndertand

	| message chosenClass interruptedContext |
	
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	
	self implement: message inClass: chosenClass context: self selectedContext

! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:43:25'!
                         implement: aMessage inClass: aClass context: aContext 
	
	aClass
		compile: aMessage createStubMethod
		classified: (self askForCategoryIn: aClass default: 'as yet unclassified').
		
	aContext privRefreshWith: (aClass lookupSelector: aMessage selector).
	aMessage arguments withIndexDo: [ :arg :index | aContext tempAt: index put: arg ].
	self resetContext: aContext! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:28'!
     wasInterrupedOnDoesNotUnderstand

	^self interruptedContext selector == #doesNotUnderstand:! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:25:23'!
                        wasInterruptedOnSubclassResponsibility

	^self interruptedContext sender ifNil: [ false ] ifNotNil: [ :senderContext | senderContext selector == #subclassResponsibility ]! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:48' prior: 50336540!
                         askForSuperclassOf: aClass toImplement: aSelector ifCancel: cancelBlock

	^self askForSuperclassOf: aClass upTo: ProtoObject toImplement: aSelector ifCancel: cancelBlock
! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:46:00' prior: 50336561!
                         createMethod

	self wasInterrupedOnDoesNotUnderstand ifTrue: [ ^self createMethodWhenDoesNotUndertand ].
	self wasInterruptedOnSubclassResponsibility ifTrue: [ ^self createMethodOnSubclassResponsibility ].
	
	self inform: 'Only available for #doesNotUndertand: and #subclassResponsibility' ! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:47' prior: 50336574!
 shouldBeAbleToCreateMethod

	^self wasInterrupedOnDoesNotUnderstand or: [ self wasInterruptedOnSubclassResponsibility]! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:46:32' prior: 50336580!
          customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	^#(
		('Restart'		restart				'reset this context to its start.')
		('Into'			send					'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'	fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Create'		createMethod		'create method'))! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35' prior: 50336599!
          buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !

Debugger removeSelector: #create!

Debugger removeSelector: #create!

Debugger removeSelector: #implement:inClass:!

Debugger removeSelector: #implement:inClass:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3034-CreateMethodSupport-HernanWilkinson-1-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3032] on 14 January 2017 at 9:09:47 am'!
!Theme methodsFor: 'menus' stamp: 'jmv 1/14/2017 09:09:05' prior: 16936064!
                             miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current class beCurrent!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3035-AddIconsForTDDSupport-JuanVuletich-2017Jan14-09h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3035] on 16 January 2017 at 11:04:32 am'!

(Smalltalk classNamed: 'Taskbar') ifNotNil: [ :tbClass |
	PasteUpMorph allInstancesDo: [ :w | w hideTaskbar ].
	tbClass allInstancesDo: [ :each | each delete ]]!

StringMorph subclass: #UpdatingStringMorph
	instanceVariableNames: 'target getSelector stepTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #UpdatingStringMorph category: #'Morphic-Widgets'!
StringMorph subclass: #UpdatingStringMorph
	instanceVariableNames: 'target getSelector stepTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!UpdatingStringMorph commentStamp: 'jmv 1/5/2013 23:49' prior: 0!
        UpdatingStringMorph new
     target: [self runningWorld activeHand morphPosition asString];
     getSelector: #value;
     stepTime: 10;
     openInWorld!

LayoutMorph subclass: #TaskbarMorph
	instanceVariableNames: 'viewBox scale'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Taskbar'!

!classDefinition: #TaskbarMorph category: #'Tools-Taskbar'!
LayoutMorph subclass: #TaskbarMorph
	instanceVariableNames: 'viewBox scale'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Taskbar'!
!TaskbarMorph commentStamp: '<historical>' prior: 0!
      A simple task bar written for Cuis.

dashBoard contains views/controls
viewBox contains graphic buttons of "iconized" windows/morphs.
scale allows 1x 2x 4x tarkbar height. [scale= 1,2,4]!
!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/15/2017 18:51:02'!
                  taskbarIncludesAllWindows
	"
	true: All windows are included in Taskbar
	false: Only collapsed windows are included in Taskbar
	"
	^ self
		valueOfFlag: #taskbarIncludesAllWindows
		ifAbsent: [ true ].! !
!Morph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 18:06:45'!
                   taskbar
	^self world ifNotNil: [ :w | w taskbar ]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/15/2017 14:52:58'!
showAndComeToFront

	self show; comeToFront! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:14'!
   addedMorph: aMorph
	"Notify the receiver that the given morph was just added."
	super addedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasOpened: aMorph ]! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:07'!
            removedMorph: aMorph
	"Notify the receiver that aMorph was just removed from its children"
	super removedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasDeleted: aMorph ]! !
!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 18:57:53'!
      taskbarDeleted
	taskbar _ nil! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
                     getSelector: aSymbol
	getSelector _ aSymbol! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:18'!
       stepTime

	^stepTime! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
                              stepTime: aNumber
	stepTime _ aNumber! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
             target: anObject
	target _ anObject! !
!UpdatingStringMorph methodsFor: 'initialization' stamp: 'jmv 9/13/2013 09:23'!
         initialize
	super initialize.
	target _ self.
	getSelector _ #contents.
	stepTime _ 50! !
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jmv 2/27/2016 20:07'!
                            stepAt: millisecondSinceLast

	self contents: (target perform: getSelector)! !
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jmv 1/4/2013 13:18'!
        wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run"

	^true! !
!UpdatingStringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:25:27'!
                fitContents
	"Don't shrink each time contents change.
	Might shrink during layout"
	self morphExtent: (extent max: self measureContents)! !
!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'jmv 4/15/2014 09:26'!
                     initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (AbstractFont familyName: 'DejaVu' pointSize: 22) 
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:41'!
                        buttonFor: aMorph
	
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model == aMorph
				ifTrue: [ ^button ]]
	].
	^nil! !
!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:30'!
           scale

	 ^ scale ifNil: [ self defaultScale ] ifNotNil: [ scale ]! !
!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:00'!
                        notifyDisplayResize
	Display
		when: #screenSizeChanged
		send: #screenSizeChanged
		to: self.
	self screenSizeChanged! !
!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:14'!
   screenSizeChanged
	"Respond to change in screen size by repositioning self to bottom of screen"
	
"	Transcript newLine; print: 'Taskbar screenSizeChanged'.
"
	| y e |
	WorldState addDeferredUIMessage: [
		self world ifNotNil: [ :w |
			y _ w morphExtent y - self defaultHeight.
			e _ self internalizeDistance: w morphExtent x @ self defaultHeight.
			self morphPosition: 0@y extent: e ]]! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:51'!
            defaultHeight

	^ Preferences windowTitleFont height * 2 * self scale! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:19'!
           defaultScale

	 ^ 1! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/8/2017 16:57:33'!
                              initialize
	super initialize.
	viewBox _ LayoutMorph newRow color: self defaultColor.
	self
		addMorph: UpdatingStringMorph initializedInstance
		layoutSpec:  (LayoutSpec morphWidthProportionalHeight: 1.0).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			minorDirectionPadding: #right).
	viewBox separation: 5
! !
!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:44:53'!
    is: aSymbol
	^ aSymbol == #TaskbarMorph or: [ super is: aSymbol ]! !
!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:47:41'!
                       isSticky
	"answer whether the receiver is Sticky"
	^true! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:42:23'!
                              addButtonFor: aMorph

	| button |
	button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
	button
		color: self color;
		icon: (aMorph imageForm: 32);
		setBalloonText: aMorph label.
	viewBox
		addMorph: button
		fixedWidth: self defaultHeight! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:20:11'!
                       removeButtonFor: aMorph

	(self buttonFor: aMorph) ifNotNil: [ :b |
		b delete ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:49:21'!
      restoreAll
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model showAndComeToFront ]	]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:23:09'!
           wasCollapsed: aMorph
	"Add a button for aMorph if not already there (see #taskbarIncludesAllWindows)"

	(self buttonFor: aMorph) ifNil: [
		self addButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:25:27'!
               wasDeleted: aMorph
	"aMorph was deleted. Remove button for aMorph"

	self removeButtonFor: aMorph! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:19:22'!
                     wasMadeVisible: aMorph
	"aMorph is now visible. Remove button for aMorph if appropriate (see #taskbarIncludesAllWindows)"

	Preferences taskbarIncludesAllWindows ifFalse: [
		self removeButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:21:15'!
         wasOpened: aMorph
	"aMorph was added to the world. Add button for aMorph if appropriate (see #taskbarIncludesAllWindows)"
	
	Preferences taskbarIncludesAllWindows ifTrue: [
		self addButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/15/2017 18:57:58'!
delete

	| w |
	self restoreAll.
	super delete.
	w _ self world ifNil: [ self runningWorld ].
	Display removeActionsWithReceiver: self.
	w ifNotNil: [ w taskbarDeleted ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/16/2017 09:52:23'!
 noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	Preferences taskbarIncludesAllWindows ifTrue: [
		aMorph submorphsDo: [ :m |
			m == self ifFalse: [
				self addButtonFor: m ]]].
	self notifyDisplayResize! !
!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:14:11'!
                        handlesMouseDown: aMouseButtonEvent

	^ true! !
!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:10:57'!
             mouseButton2Activity

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	menu
		addLine;
		add: 'Normal Height' action: #scaleNormal;
		add: 'Scale x 2' action: #scaleX2;
		add: 'Scale x 4' action: #scaleX4.
	menu popUpInWorld! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:01:25'!
                   scale: anInteger

	(anInteger between: 1 and: 4) ifFalse: [ self error: 'scale should be 1 2 or 4' ].
	scale := anInteger.
	self screenSizeChanged. "rescale self"
	viewBox ifNotNil: [ "rescale buttons"
		viewBox submorphs do: [ :button | 
			button layoutSpec fixedWidth: self defaultHeight
		]
	]! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:49'!
               scaleNormal

	self scale: 1! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:52'!
                             scaleX2

	self scale: 2! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:55'!
 scaleX4

	self scale: 4! !
!TaskbarMorph class methodsFor: 'system startup' stamp: 'jmv 1/8/2017 16:47:17'!
                    initClassCachedState

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each notifyDisplayResize ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 1/15/2017 18:24:25' prior: 16874345!
              visible: aBoolean
	"set the 'visible' attribute of the receiver to aBoolean"

	self visible == aBoolean
		ifTrue: [ ^ self ].
	aBoolean ifFalse: [
		self redrawNeeded ].
	self setProperty: #visible toValue: aBoolean.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	aBoolean ifTrue: [
		self redrawNeeded.
		self taskbar ifNotNil: [ :tb |
			tb wasMadeVisible: self ]]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 1/15/2017 14:58:58' prior: 16875692!
                               comeToFrontAndAddHalo
	self show.
	self comeToFront.
	self addHalo! !
!Morph methodsFor: 'menus' stamp: 'jmv 1/15/2017 18:24:40' prior: 16876276!
              collapse
	"If taskbar not visible, just hide."

	self hide.
	self taskbar
		ifNotNil: [ :tb | tb wasCollapsed: self ]! !
!Morph methodsFor: 'menus' stamp: 'jmv 1/15/2017 14:59:12' prior: 16876281!
                           expand
	
	self show.
	self comeToFront! !
!Morph methodsFor: 'testing' stamp: 'jmv 1/15/2017 15:04:18' prior: 16876985!
        isCollapsed

	^ self visible not! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/8/2017 16:44:57' prior: 16887743!
    allNonWindowRelatedSubmorphs
	"Answer all non-window submorphs that are not flap-related"

	^submorphs 
		reject: [ :m | (m is: #SystemWindow) or: [ m is: #TaskbarMorph ] ]! !
!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 14:43:48' prior: 16887920!
                           showTaskbar

	taskbar ifNil: [
		taskbar _ TaskbarMorph newRow.
		taskbar openInWorld: self ]! !
!StringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:22:53' prior: 16918181!
          measureContents
	| f |
	f _ self fontToUse.
	^((f widthOfString: contents) max: 3)  @ f height! !

TaskbarMorph removeSelector: #intoWorld:!

PasteUpMorph removeSelector: #isCollapsed:!

PasteUpMorph removeSelector: #isCollapsed:!

PasteUpMorph removeSelector: #minimize:!

PasteUpMorph removeSelector: #minimize:!

PasteUpMorph removeSelector: #restore:!

PasteUpMorph removeSelector: #restore:!

PasteUpMorph removeSelector: #taskbar:!

PasteUpMorph removeSelector: #taskbar:!

PasteUpMorph allInstancesDo: [ :w | w showTaskbar ]!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3036-NewTaskbar-JuanVuletich-2017Jan16-10h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3036] on 17 January 2017 at 11:13:18 am'!
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 1/17/2017 10:51:52'!
                          initialExtent
	^ RealEstateAgent standardWindowExtent * 3 // 2! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 1/17/2017 11:12:27' prior: 16898269!
                    maximumUsableAreaInWorld: aWorldOrNil

	| allowedArea |
	allowedArea _ Display boundingBox.
	aWorldOrNil ifNotNil: [
		allowedArea _ allowedArea intersect: aWorldOrNil viewBox.
		aWorldOrNil taskbar ifNotNil: [ :tb |
			allowedArea _ (allowedArea areasOutside: tb morphBoundsInWorld) first ]].
	^allowedArea
! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/17/2017 11:00:35' prior: 16887247!
                  privateExtent: newExtent

	^ (super privateExtent: newExtent)
		ifTrue: [
			self buildMagnifiedBackgroundImage.
			worldState clearCanvas ]; yourself! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 1/17/2017 10:56:23' prior: 16887422!
           viewBox

	^ worldState
		ifNotNil: [
			 0@0 extent: extent ]
		ifNil: [
			self world viewBox ]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/17/2017 11:05:24' prior: 16887834!
   restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	WorldState addDeferredUIMessage: [ Cursor normal activateCursor ]! !
!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 1/17/2017 11:04:44' prior: 16887959!
        newWorld
	"
[
	ProjectX stopUIProcess.
	ProjectX spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: 0@0 extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !
!WorldState methodsFor: 'canvas' stamp: 'jmv 1/17/2017 10:57:47' prior: 16945711!
          ensureNonDisplayCanvas
	(canvas isNil or: [
		canvas drawsOnDisplay or: [
		(canvas extent ~= world morphExtent) or: [
		canvas form depth ~= Display depth]]]) ifTrue: [
			"allocate a new offscreen canvas the size of the window"
			self setCanvas: (BitBltCanvas withExtent: world morphExtent depth: Display depth)]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 1/17/2017 11:05:18' prior: 16946039!
         tryDeferredUpdatingAndSetCanvasFor: aWorld
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		aWorld morphPosition: 0@0 extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 7/28/2015 08:35' prior: 16946090!
                  displayWorld: aWorld submorphs: submorphs
	"Update this world's display."

	| deferredUpdateVMMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvasFor: aWorld.

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	canvas newClipRect: nil.
	handsToDraw reverseDo: [ :h | canvas fullDrawHand: h ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		"Drawing was done to off-Display canvas. Copy content to Display"
		canvas showAt: aWorld viewBox origin invalidRects: allDamage ].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	Display forceDamageToScreen: allDamage.

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].! !

WorldState removeSelector: #viewBox!

WorldState removeSelector: #viewBox!

WorldState removeSelector: #viewBox:!

WorldState removeSelector: #viewBox:!

DebuggerWindow removeSelector: #initialFrameIn:!

DebuggerWindow removeSelector: #initialFrameIn:!

PasteUpMorph removeSelector: #viewBox:!

PasteUpMorph removeSelector: #viewBox:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3037-WindowsAvoidTaskbarArea-JuanVuletich-2017Jan17-10h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3037] on 18 January 2017 at 10:36:09 am'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/18/2017 10:34:55' prior: 50337247!
                  addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/18/2017 10:35:05' prior: 50337310!
                      noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	Preferences taskbarIncludesAllWindows ifTrue: [
		aMorph submorphsDo: [ :m |
			self addButtonFor: m ]].
	self notifyDisplayResize! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3038-TaskbarTweaks-JuanVuletich-2017Jan18-10h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3038] on 18 January 2017 at 7:35:13 pm'!
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:20:57'!
   fileMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory fileMatching: '*.image'.
	DirectoryEntry smalltalkImageDirectory fileMatching: 'x*.image'.
"
	self filesDo: [ :file |
		(pattern match: file name)
			ifTrue: [ ^ file ]].
	^ nil! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:13:59' prior: 16834484!
                directoriesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifFalse: [
			aBlock value: each ]]! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:19:42' prior: 16834701!
                              directoryMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'C*Pack*'.
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'xC*Pack*'.
"
	self directoriesDo: [ :directory |
		(pattern match: directory name)
			ifTrue: [ ^ directory ]].
	^ nil! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:14:17' prior: 16834493!
            filesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifTrue: [
			aBlock value: each ]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3039-DirectoryEntryTweaks-JuanVuletich-2017Jan18-19h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3039] on 18 January 2017 at 10:26:44 pm'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/18/2017 22:25:29' prior: 50337608!
                           addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3040-DontWasteMemoryOnTaskbarButtons-JuanVuletich-2017Jan18-22h26m-jmv.1.cs.st----!

----SNAPSHOT----#(18 January 2017 10:34:09.714849 pm) Cuis5.0-3040.image priorSource: 83085!

----QUIT----#(18 January 2017 10:34:25.559349 pm) Cuis5.0-3040.image priorSource: 193640!

----STARTUP----#(2 January 1901 12:00:01.075640272 am) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3040.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3040] on 22 January 2017 at 9:33:48 pm'!
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/22/2017 21:17:32' prior: 50337463!
                  privateExtent: newExtent

	^ (super privateExtent: newExtent)
		ifTrue: [
			self buildMagnifiedBackgroundImage.
			worldState ifNotNil: [
				worldState clearCanvas ]];
		yourself! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 1/22/2017 21:25:10' prior: 16926091!
                   drawOn: aCanvas

	| titleColor roundCorners |

	titleColor _ self widgetsColor.
	self isTopWindow
		ifTrue: [ titleColor _ titleColor lighter ].

	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			"Round corners. Optional title gradient."
			self drawRoundedFrameOn: aCanvas color: titleColor ]
		ifFalse: [
			"No round corners. No title gradient."
			self drawClassicFrameOn: aCanvas color: titleColor ].
	Theme current minimalWindows
		ifFalse: [
			labelString ifNotNil: [self drawLabelOn: aCanvas]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 1/22/2017 21:31:40' prior: 16866779!
                       popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	"Needed if not the real world but an inner PasteUpMorph"
	| positionInWorld |
	positionInWorld _ aWorld internalizeFromWorld: aWorld activeHand morphPosition.
	^self
		popUpAt: positionInWorld
		forHand: aWorld activeHand
		in: aWorld
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3041-Fix-clearCanvas-DNU-JuanVuletich-2017Jan22-21h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 3 December 2016 at 9:04:32 am'!
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:13'!
                          montgomeryDigitBase
	"Answer the base used by Montgomery algorithm."
	^1 << self montgomeryDigitLength! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:27'!
                        montgomeryDigitLength
	"Answer the number of bits composing a digit in Montgomery algorithm.
	Primitive use either 8 or 32 bits digits"
	<primitive: 'primMontgomeryDigitLength' module:'LargeIntegers'>
	^8 "Legacy plugin which did not have this primitive did use 8 bits digits"! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:14'!
          montgomeryDigitMax
	"Answer the maximum value of a digit used in Montgomery algorithm."
	
	^1 << self montgomeryDigitLength - 1! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:16'!
                               montgomeryNumberOfDigits
	"Answer the number of montgomery digits required to represent the receiver."
	^self digitLength * 8 + (self montgomeryDigitLength - 1) // self montgomeryDigitLength! !
!Integer methodsFor: 'mathematical functions' stamp: 'nice 1/16/2013 18:38' prior: 16859768!
 raisedTo: n modulo: m
	"Answer the modular exponential.
	Note: this implementation is optimized for case of large integers raised to large powers."
	| a s mInv |
	n = 0 ifTrue: [^1].
	(self >= m or: [self < 0]) ifTrue: [^self \\ m raisedTo: n modulo: m].
	n < 0 ifTrue: [^(self reciprocalModulo: m) raisedTo: n negated modulo: m].
	(n < 4096 or: [m even])
		ifTrue:
			["Overhead of Montgomery method might cost more than naive divisions, use naive"
			^self slidingLeftRightRaisedTo: n modulo: m].
	
	mInv := self montgomeryDigitBase - ((m bitAnd: self montgomeryDigitMax) reciprocalModulo: self montgomeryDigitBase).
 
	"Initialize the result to R=self montgomeryDigitModulo raisedTo: m montgomeryNumberOfDigits"
	a := (1 bitShift: m montgomeryNumberOfDigits * m montgomeryDigitLength) \\ m.
	
	"Montgomerize self (multiply by R)"
	(s := self montgomeryTimes: (a*a \\ m) modulo: m mInvModB: mInv)
		ifNil:
			["No Montgomery primitive available ? fallback to naive divisions"
			^self slidingLeftRightRaisedTo: n modulo: m].

	"Exponentiate self*R"
	a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.

	"Demontgomerize the result (divide by R)"
	^a montgomeryTimes: 1 modulo: m mInvModB: mInv! !
!Integer methodsFor: 'testing' stamp: 'nice 11/14/2011 21:59' prior: 16860231!
                      isProbablyPrime
	"See isProbablyPrimeWithK:andQ: for the algoritm description."
	
	| k q |
	self <= 1 ifTrue: [ ^false ].
	self even ifTrue: [ ^self = 2 ].
	"Factor self into (2 raisedTo: k) * q + 1, where q odd"
	q := self bitShift: -1.
	k := q lowBit.
	q := q bitShift: 1 - k.
	"Repeat the probabilistic until false (the probability of false negative is null) or until probability is very low."
	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].
	"The probability of false positive after 25 iterations is less than (1/4 raisedTo: 25) < 1.0e-15"
	^true! !
!Integer methodsFor: 'private' stamp: 'nice 11/15/2011 23:13' prior: 16860590!
      isProbablyPrimeWithK: k andQ: q 
	"Algorithm P, probabilistic primality test, from
	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,
	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description..
	Note that this is a Miller Rabin test which may answer false positives (known as pseudoprimes) for at most 1/4 of the possible bases x."

	| x j y minusOne |
	"P1"
	x := (self - 2) atRandom + 1.
	"P2"
	j := 0.
	y := x raisedTo: q modulo: self.
	minusOne := self - 1.
	
	["P3"
	y = 1 ifTrue: [^j = 0].
	y = minusOne ifTrue: [^true].
	"P4"
	(j := j + 1) < k]
		whileTrue:
			[y := y squared \\ self].
	"P5"
	^false! !
!Integer methodsFor: 'private' stamp: 'nice 1/16/2013 18:40' prior: 16860675!
                      montgomeryTimes: a modulo: m mInvModB: mInv
	"Answer the result of a Montgomery multiplication
	self * a * (b raisedTo: m montgomeryNumberOfDigits) inv \\ m
	NOTE: it is assumed that:
	self montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	a montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	mInv * m \\ b = (-1 \\ b) = (b-1) (this implies m odd)
	where b = self montgomeryDigitBase
	
	Answer nil in case of absent plugin or other failure."
	
	<primitive: 'primMontgomeryTimesModulo' module:'LargeIntegers'>
	^nil! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3042-MontgomeryExponentiationFix-LucianoEstebanNotarfrancesco-2016Nov29-21h10m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3042] on 22 January 2017 at 9:49:56 pm'!
!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:11:44'!
       reciprocalModulo2: n
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if it doesn't exist."
	| xgcd |
	self == 0 ifTrue: [^ nil].
	self == 1 ifTrue: [^ 1].
	xgcd _ self xgcd: n.
	^ (xgcd at: 1) == 1 ifTrue: [^ (xgcd at: 2) \\ n]! !
!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:07:08'!
                            xgcd: anInteger
	"Extended Euclidean algorithm.
	Answer an array {x. u. v} where self * u + (anInteger * v) = x, and x = (self gcd: anInteger)."
	| a b s t sp tp r rp |
	a _ self. b _ anInteger.
	s _ 0. sp _ 1.
	t _ 1. tp _ 0.
	r _ a abs. rp _ b abs.
	[r == 0]
		whileFalse:
			[ | q temp |
			q _ rp // r.
			temp _ r. r _ rp - (q * r). rp _ temp.
			temp _ s. s _ sp - (q * s). sp _ temp.
			temp _ t. t _ tp - (q * t). tp _ temp].
	sp _ sp * b sign. tp _ tp * a sign.
	^ {rp. tp. sp}! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3043-Alternative-gcd-reciprocalModulo-LucianoEstebanNotarfrancesco-2017Jan22-21h46m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3043] on 16 February 2017 at 2:31:35 pm'!
!FileSystemEntry methodsFor: 'accessing-file name' stamp: 'jmv 2/16/2017 11:21:10' prior: 16843823!
       baseName
	^self fileAccessor baseNameFor: name! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3044-basename-fix-JuanVuletich-2017Feb16-11h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3044] on 17 February 2017 at 3:11:08 pm'!
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 2/17/2017 15:10:48' prior: 16888368!
          magnifiedIcon
	| factor magnifiedExtent w h |

	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		w _ icon width.
		h _ icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * extent x / w min: 1.0 * extent y / h.
			(factor < 1 or: [ factor > 1.7 and: [self isRoundButton]]) ifTrue: [
				magnifiedExtent _ (icon extent * factor) rounded.
				magnifiedIcon _ icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3045-magnifiedIcon-fix-JuanVuletich-2017Feb17-15h10m-jmv.1.cs.st----!

----SNAPSHOT----#(2 January 1901 12:00:01.075640278 am) Cuis5.0-3045.image priorSource: 193734!

----QUIT----#(1 January 1901 12:00:01.56749216 am) Cuis5.0-3045.image priorSource: 202527!

----STARTUP----#(6 March 2017 10:36:08.27543 am) as C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\Cuis5.0-3045.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3042] on 10 February 2017 at 5:39:28 pm'!

Object subclass: #ProgessiveTestRunner
	instanceVariableNames: 'testSuite testsStream progressBar testResult testRunIncrement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #ProgessiveTestRunner category: #'Tools-Testing'!
Object subclass: #ProgessiveTestRunner
	instanceVariableNames: 'testSuite testsStream progressBar testResult testRunIncrement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!Browser methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:32:22'!
               debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ]
! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 20:33:00'!
            runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		(ProgessiveTestRunner for: (TestSuite forClass: selectedClass)) value ]! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:47:50'!
                runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass _ Smalltalk classNamed: selectedClassName.
		suite _ TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 21:51:50'!
        runMethodTest
	
	| suite |
	
	suite _ TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgessiveTestRunner for: suite) value 
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:23:54'!
                            runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite _ TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !
!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:50'!
               testCaseClass

	self subclassResponsibility ! !
!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:40'!
                    withTestCaseClassDo: aFoundTestCaseClassBlock ifNone: aNoneBlock 
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ self testCaseClass.
	
	^potentialTestCaseClass ifNil: aNoneBlock ifNotNil: aFoundTestCaseClassBlock 
	! !
!Class methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:42:40'!
testCaseClass
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ Smalltalk classNamed: self name, 'Test'.
	
	^potentialTestCaseClass 
	
 ! !
!Metaclass methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:56:51'!
              testCaseClass

	^self soleInstance testCaseClass ! !
!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:13'!
            classesAt: aCategoryName

	^(self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName ]
		! !
!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:34'!
                          testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HAW 2/10/2017 16:03:46'!
                            acceptAndDebugTest: aKeyboardEvent 
	
	^self acceptAndDebugTest ! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:45'!
                        acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ]]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:38'!
           acceptAndWithMethodDo: aBlock
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod _ self codeProvider currentCompiledMethod.
	^potencialTestMethod 
		ifNil: [ false ]
		ifNotNil: [
			aBlock value: potencialTestMethod.
			true]! !
!ProgessiveTestRunner methodsFor: 'initialization' stamp: 'HAW 2/1/2017 19:20:06'!
                            initializeFor: aTestSuite

	testSuite _ aTestSuite.
	! !
!ProgessiveTestRunner methodsFor: 'evaluating' stamp: 'HAW 1/31/2017 11:50:37'!
                       value

	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:22'!
       calculateTestRunIncrement
	
	testRunIncrement _ 1/testsStream size! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:31'!
                              createProgressBar
		
	progressBar _ ProgressMorph label: testSuite name.
	self calculateTestRunIncrement.
	self updateProgressBarSubLabel.
	! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:43'!
                    updateDoneIncrement 

 	progressBar incrDone: testRunIncrement 
	! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 11:10:25'!
                               updateProgressBarSubLabel

	testsStream atEnd ifFalse: [
		progressBar subLabel: testsStream next printString, ' (', testsStream position printString, '/', testsStream size printString, ')' ].! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 20:05:25'!
 informAllTestPassed 
	
	PopUpMenu inform: testResult printString.
	! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 10:05:21'!
                              informNoTestToRun
		
	 PopUpMenu inform: 'No test to run'! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 2/1/2017 19:26:08'!
         openTestResultForDebuggingAndInspection

	testResult forDebuggingAndInspection inspect ! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 10:10:53'!
          showDeffects
	
	 | defects |
			
	defects _ 	testResult defects.
	defects size = 1
		ifTrue: [ defects anyOne debug ] 
		ifFalse: [ self openTestResultForDebuggingAndInspection]! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:14:08'!
                  createProgressBarAndRun

	self createProgressBar.
	[ self runSuiteShowingProgress ] fork! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:26:59'!
           registerTestSuiteAction
		
	testSuite when: #changed: send: #testRun: to: self! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:09:41'!
                    runSuite
		
	testResult _ testSuite run.	
	testResult hasPassed 
		ifTrue: [ self informAllTestPassed ] 
		ifFalse: [self showDeffects ]
	! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 11:47:58'!
                        runSuiteShowingProgress

	[ self registerTestSuiteAction. 
	progressBar openInWorld.
	self runSuite ] ensure: [
		self unregisterTestSuiteAction.
		WorldState addDeferredUIMessage: [progressBar dismissMorph] ].
	! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:19:28'!
               testRun: aTest

	self updateProgressBarSubLabel.
	self updateDoneIncrement 
	
		! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:04:32'!
                  unregisterTestSuiteAction
	
	testSuite releaseActionMap ! !
!ProgessiveTestRunner class methodsFor: 'instance creation' stamp: 'HAW 1/31/2017 09:37:34'!
       for: aTestSuite

	^self new initializeFor: aTestSuite! !
!TestCase class methodsFor: 'Instance Creation' stamp: 'HAW 2/10/2017 16:01:40'!
                      debugAsFailure: aSymbol

	^(self selector: aSymbol) debugAsFailure
			! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 20:31:47'!
              forClass: aClass

	^(aClass is: #TestCaseClass) 
		ifTrue: [ self forTestCaseClass: aClass ]
		ifFalse: [ self forNoTestCaseClass: aClass ]
! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 21:53:12'!
        forCompiledMethod: aCompiledMethod

	^aCompiledMethod isTestMethod 
		ifTrue: [ self forTestMethod: aCompiledMethod ]
		ifFalse: [ self forNoTestMethod: aCompiledMethod ]
	! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/1/2017 18:43:22'!
        forMessageCategoryNamed: aMessageCategoryName of: aClass categorizedWith: aClassOrganizer

	| suite |
	
	suite _ self named: aClass name, ' tests categorized under ',aMessageCategoryName.
	(aClassOrganizer listAtCategoryNamed: aMessageCategoryName) do: [ :selector |
		(aClass compiledMethodAt: selector) isTestMethod ifTrue: [ suite addTest: (aClass selector: selector) ]].
	
	^suite
	! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/7/2017 10:24:12'!
                  forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer 

	| testCaseClasses |
	
	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.
	
	^testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer classesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:25:51'!
   allTestCaseClassesReferencing: aClass

	^(aClass allCallsOn 
		collect: [ :aMethodReference | aMethodReference actualClass ]
		thenSelect: [ :aPotentialTestCaseClass | aPotentialTestCaseClass is: #TestCaseClass ]) asSet.! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:27:27'!
              allTestsSending: aSelector
	
	^(Smalltalk allCallsOn: aSelector) select: [:aMethodReference | 
		(aMethodReference actualClass is: #TestCaseClass) and: [aMethodReference compiledMethod isTestMethod ]].! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:08:23'!
 forClasses: classes named: name

	| suite |
	
	suite _ classes
		inject: (self named: name)
		into: [ :partialSuite :aClass | partialSuite addTests: (self forClass: aClass) tests ].
		
	^suite
		
! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:32:17'!
      forNoTestCaseClass: aClass 

	^aClass 
		withTestCaseClassDo: [ :aTestCaseClass | self forTestCaseClass: aTestCaseClass ]
		ifNone: [ self forReferencesToClass: aClass ]

! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 11:28:55'!
                               forNoTestMethod: aCompiledMethod 
	
	| allTestSenders testCaseClassesReferencingClass reducedTestSenders suite |
	
	allTestSenders _ self allTestsSending: aCompiledMethod selector.
	testCaseClassesReferencingClass _ aCompiledMethod methodClass 
		withTestCaseClassDo:  [:aTestCaseClass | Array with: aTestCaseClass ]
		ifNone: [ self allTestCaseClassesReferencing: aCompiledMethod methodClass ].
		
	reducedTestSenders _ allTestSenders select: [ :aMethodReference | testCaseClassesReferencingClass includes: aMethodReference actualClass ].
	reducedTestSenders isEmpty 
		ifTrue: [ suite _ self forClass: aCompiledMethod methodClass ]
		ifFalse: [ 
			suite _ self named: 'Tests senders of ', aCompiledMethod selector.
			reducedTestSenders do: [ :aMethodReference | suite addTest: (aMethodReference actualClass selector: aMethodReference selector)]].
	
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:33:27'!
              forReferencesToClass: aClass 

	| testCaseClasses |
	
	testCaseClasses _ self allTestCaseClassesReferencing: aClass.
		
	^testCaseClasses 
		inject: (self named: aClass name, ' all test references')
		into: [ :suite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: suite ]
	

! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:34:27'!
             forTestCaseClass: aTestCaseClass 

	| suite |
	
	suite _ aTestCaseClass buildSuite.
	suite name: aTestCaseClass name, ' tests'.
	
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:04:48'!
 forTestCaseClasses: testCaseClasses named: aName

	| suite |
	
	suite _ testCaseClasses
		inject: (self named: aName) 
		into: [:partialSuite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: partialSuite ].
		
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/4/2017 21:53:22'!
        forTestMethod: aCompiledMethod
	
	| suite |
	
	suite _ self named: 'Test'.
	suite addTest: (aCompiledMethod methodClass selector: aCompiledMethod selector).
	
	^suite
		! !
!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:23'!
   allSuperclassesUpTo: aSuperclass 

	self error: (self superclassNotValidErrorDescriptionFor: aSuperclass)! !
!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:30'!
   superclassNotValidErrorDescriptionFor: aClass 

	^aClass name, ' not in superclasses chain'! !
!Behavior methodsFor: 'system-support' stamp: 'HAW 2/4/2017 20:51:10' prior: 16785122!
          allCallsOn
	"Answer a SortedCollection of all the methods that refer to me by name or 
	as part of an association in a global dict."
	"
	^ (Smalltalk
		allCallsOn: (Smalltalk associationAt: self theNonMetaClass name))
		, (Smalltalk allCallsOn: self theNonMetaClass name)
	"

	^ Smalltalk allCallsOn: self theNonMetaClass name! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 2/4/2017 20:49:09' prior: 16923905!
                             browseAllCallsOnClass: aClass
	"Create and schedule a message browser on each method that refers to 
	aClass. For example, Smalltalk browseAllCallsOnClass: Object."
	self
		browseMessageList: aClass allCallsOn asArray sort
		name: 'Users of class ' , aClass theNonMetaClass name
		autoSelect: aClass theNonMetaClass name.! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:51:22' prior: 50336078!
        acceptAndTest
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ].
	^true! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:50:41' prior: 50336084!
                         acceptAndTestAll
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ].
	^true
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:52' prior: 50336091!
      acceptThenTestMethodAndSuite: aSuiteBuilder
	
	self acceptAndWithMethodDo: [ :aPotencialTestMethod |
		self runAndDebuggIfNecessary: aPotencialTestMethod.
		self runTestSuite: (aSuiteBuilder value: aPotencialTestMethod) ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 16:08:47' prior: 50336113!
           runAndDebuggIfNecessary: aPotencialTestMethod

	aPotencialTestMethod isTestMethod ifTrue: [
		aPotencialTestMethod methodClass debug: aPotencialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:19:02' prior: 50336121!
    runTestSuite: aTestSuite

	(ProgessiveTestRunner for: aTestSuite) value
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:49:25' prior: 50336131!
                              testSuiteForCategoryOf: aClass

	^TestSuite forSystemCategoryNamed: aClass category using: SystemOrganization 
! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:48:27' prior: 50336148!
                          testSuiteOf: aClass

	^TestSuite forClass: aClass
! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 2/10/2017 15:58:27' prior: 50336375!
                           cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debut it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 2/10/2017 15:57:40' prior: 50336429!
          initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		{'Accept & Debug Test (r)'.					#acceptAndDebugTest}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 1/31/2017 11:56:31' prior: 16813767!
        classListKey: aChar from: view 
	"Respond to a Command key.  I am a model with a list of classes and a 
	code pane, and I also have a listView that has a list of methods.  The 
	view knows how to get the list and selection."

	aChar == $r ifTrue: [^ model recent].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $x ifTrue: [^ model removeClass].
	aChar == $t ifTrue: [^ model runClassTests ].
	
	^ self messageListKey: aChar from: view! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/10/2017 17:33:25' prior: 16813782!
 messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	aChar == $D ifTrue: [^ model toggleDiffing].

	sel _ model selectedMessageName.
	aChar == $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar == $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	"The following require a class selection"
	(class _ model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar == $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar == $N ifTrue: [^ self browseClassRefs].
	aChar == $i ifTrue: [^ self methodHierarchy].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $p ifTrue: [^ self browseFullProtocol].

	"The following require a method selection"
	sel ifNotNil: [
		aChar == $o ifTrue: [^ model fileOutMessage].
		aChar == $c ifTrue: [^ model copySelector].
		aChar == $v ifTrue: [^ self browseVersions].
		aChar == $O ifTrue: [^ self openSingleMessageBrowser].
		aChar == $x ifTrue: [^ model removeMessage].
		aChar == $t ifTrue: [^ model runMethodTest].
		aChar == $r ifTrue: [^ model debugMethodTest]]! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/7/2017 10:49:07' prior: 16813824!
                   systemCatListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."

	aChar == $f ifTrue: [^ self findClass].
	aChar == $x ifTrue: [^ model removeSystemCategory].
	aChar == $t ifTrue: [ ^model runSystemCategoryTests ].
	
	^ self classListKey: aChar from: view! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:32:21' prior: 16793212!
                       classListMenu
	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList: #(
		('browse full (b)'			browseMethodFull)
		('browse hierarchy (h)'		browseHierarchy)
		('browse protocol (p)'		browseFullProtocol)
		-
		('fileOut'					fileOutClass				''		model)
		-
		('show hierarchy'			hierarchy					''		model)
		('show definition'			editClass					''		model)
		('show comment'			editComment			''		model)
		-
		('inst var refs...'				browseInstVarRefs)
		('inst var defs...'			browseInstVarDefs)
		-
		('class var refs...'			browseClassVarRefs)
		('class vars'					browseClassVariables)
		('class refs (N)'				browseClassRefs)
		-
		('rename class ...'			renameClass				''		model)
		('copy class...'				copyClass				''		model)
		('remove class (x)'			removeClass				''		model)
		-
		('Run tests (t)'		runClassTests 	''	model)
		('more...'					offerShiftedClassListMenu)).
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 19:57:02' prior: 16793244!
                 messageCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.			"All the options are for the model."
	aMenu addList: #(
		('fileOut'							fileOutMessageCategories)
		-
		('reorganize'						editMessageCategories)
		('alphabetize'						alphabetizeMessageCategories)
		('remove empty categories'		removeEmptyCategories)
		('categorize all uncategorized'		categorizeAllUncategorizedMethods)
		('new category...'					addCategory)
		-
		('rename...'							renameCategory)
		('remove'							removeMessageCategory)
		-
		('Run tests'	runMessageCategoryTests)).
	^aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 2/10/2017 17:29:43' prior: 16793264!
messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList:#(
			('what to show...'				offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry					''		model)
            	-
			('browse full (b)' 				browseMethodFull)
			('browse hierarchy (h)'			browseHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'						fileOutMessage							''		model)
			-
			('senders of... (n)'				browseSendersOfMessages)
			('implementors of... (m)'			browseMessages)
			('inheritance (i)'					methodHierarchy)
			('versions (v)'					browseVersions)
			-
			('inst var refs...'					browseInstVarRefs)
			('inst var defs...'				browseInstVarDefs)
			('class var refs...'				browseClassVarRefs)
			('class variables'				browseClassVariables)
			('class refs (N)'					browseClassRefs)
			-
			('remove method (x)'			removeMessage							''		model)
			('Run test (t)'		runMethodTest 	'' 	model)
			('Debug test (r)'		debugMethodTest 	'' 	model)
			-
			('more...'						openShiftedMessageListMenu)).
	^ aMenu
! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:52:17' prior: 16793404!
                systemCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	self flag: #renameSystemCategory.	"temporarily disabled"
	aMenu addList: #(
		('find class... (f)'				findClass)
		('recent classes... (r)'		recent									''		model)
		-
		('browse all'				browseAllClasses)
		('browse'					openSystemCategoryBrowser)
		-
		('fileOut'					fileOutSystemCategory				''		model)
		-
		('reorganize'				editSystemCategories					''		model)
		('alphabetize'				alphabetizeSystemCategories		''		model)
		-
		('update'					updateSystemCategories				''		model)
		('add item...'				addSystemCategory					''		model)
"		('rename...'					renameSystemCategory				''		model)"
		('remove'					removeSystemCategory				''		model)
		-
		('move to top'				moveSystemCategoryTop				''		model)
		('move up'					moveSystemCategoryUp				''		model)
		('move down'				moveSystemCategoryDown			''		model)
		('move to bottom' 			moveSystemCategoryBottom			''		model)
		-
		('Run tests (t)'				runSystemCategoryTests  	''	model)).
	^aMenu! !
!Theme methodsFor: 'menus' stamp: 'HAW 2/10/2017 17:30:49' prior: 50336835!
                       miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)' 'Run tests (t)' 'Run tests' 'Run test (t)' 'Accept & Debug Test (r)' 'Debug test (r)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 2/10/2017 17:37:41'!
                           should: aBlock raise: anExceptionalType withExceptionDo: assertionsBlock

	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalType withExceptionDo: assertionsBlock)
			! !
!TestCase methodsFor: 'Private' stamp: 'HAW 2/10/2017 17:38:10'!
    executeShould: aBlock inScopeOf: anExceptionType withExceptionDo: assertionsBlock

	^[aBlock value.
 	false] 
		on: anExceptionType
		do: [:exception | 
			assertionsBlock value: exception.
			exception sunitExitWith: true]! !
!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/10/2017 16:32:10' prior: 50336181!
      is: aSymbol

	^self ~= TestCase 
		and: [ aSymbol == #TestCaseClass or: [ super is: aSymbol ]]! !
!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/1/2017 19:35:57' prior: 16927731!
        shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self ~= TestCase 
		and: [ self superclass isAbstract or: [self testSelectors isEmpty]]

"$QA Ignore:Sends system method(superclass)$"
			! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HAW 2/7/2017 10:51:56' prior: 50336198!
                 print: aCollectionOfTestCases startingWith: header on: aStream
	
	aCollectionOfTestCases do: [ :aTestCase |
		aStream 
			nextPutAll: header;
			space;
			nextPutAll: aTestCase class name;
			nextPutAll: ' debug: #';
			nextPutAll: aTestCase selector;
			newLine ]
		
		
	! !

TestSuite class removeSelector: #allTestCasesReferencing:!

TestSuite class removeSelector: #allTestReferencesTo:!

TestSuite class removeSelector: #allTestsReferencing:!

TestSuite class removeSelector: #from:using:!

TestSuite class removeSelector: #fromClass:!

TestSuite class removeSelector: #fromSystemCategoryNamed:using:!

ProgessiveTestRunner removeSelector: #initializeFor:informingResultUsing:!

ProgessiveTestRunner removeSelector: #initializeFor:showingTestPassedWith:!

ProgessiveTestRunner removeSelector: #showProgressBarAndRunSuite!

SmalltalkEditor removeSelector: #acceptAndWithTestMethodDo:!

SmalltalkEditor removeSelector: #flashWith:!

SmalltalkEditor removeSelector: #flashWith:!

SmalltalkEditor removeSelector: #flashWithGreen!

SmalltalkEditor removeSelector: #flashWithGreen!

Categorizer removeSelector: #testCasesAt:!

Class removeSelector: #withTestCaseClassDo:ifNone:!

Behavior removeSelector: #withTestClassDo:ifNone:!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3046-TestRunningHelpers-HernanWilkinson-2017Jan31-09h21m-HAW.5.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3046] on 1 March 2017 at 12:34:07 pm'!
!CodeFile methodsFor: 'change record types' stamp: 'jmv 3/1/2017 12:31:23' prior: 16808869!
                          doIt: chgRec
	"See senders of #doIt "
	| string |
	string := chgRec string.
	
	"Method classification spec"
	(string beginsWith: '(''') ifTrue: [
		^ doIts add: chgRec ].
		
	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'
		match: string) ifTrue:[^self classDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('* class*instanceVariableNames:*'
		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #methodRemoval: (or similar) change type marker in the files."
	('* removeSelector: *'
		match: string) ifTrue:[^self removedMethod: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classComment change type marker in the files."
	('* comment:*'
		match: string) ifTrue:[^self msgClassComment: string with: chgRec].

	"Don't add these to a CodeFile. They will be added on save if needed."
	('* initialize'
		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"

	('''From *'
		match: string) ifTrue:[^self possibleSystemSource: chgRec].
	doIts add: chgRec.! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3047-FileCodeBrowserFix-JuanVuletich-2017Mar01-12h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3047] on 2 March 2017 at 10:50:58 am'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph oldKeyboardFocus '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph oldKeyboardFocus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuMorph commentStamp: '<historical>' prior: 16866262!
  Instance variables:
	defaultTarget 		<Object>					The default target for creating menu items
	selectedItem			<MenuItemMorph> 		The currently selected item in the receiver
	stayUp 				<Boolean>				True if the receiver should stay up after clicks!
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:47:30' prior: 16866663!
                         deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true."

	stayUp ifFalse: [ self delete ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:01' prior: 16866680!
                   popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:31' prior: 16866709!
    popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - (2 @ 8).
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:26' prior: 16866745!
       popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - (2 @ 8).
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:47:45' prior: 16866819!
                     keyStroke: aKeyboardEvent 
	| matchString char asc selectable |
	char := aKeyboardEvent keyCharacter.
	asc := char numericValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
					selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: [
							"self delete."
							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			^self delete].
	(asc = 28 or: [asc = 29]) 
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := char = Character backspace 
				ifTrue: [
					matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 3/2/2017 10:47:57' prior: 16866952!
                    handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 3/2/2017 10:47:34' prior: 16867015!
             initialize
	super initialize.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:45:33' prior: 16866023!
                               mouseEnter: evt
	"The mouse entered the receiver"
	owner ifNil: [ ^self ].
	owner selectItem: self! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/2/2017 10:36:12' prior: 16866139!
   deselect

	self isSelected: false.
	subMenu ifNotNil: [
		self removeAlarm: #deselectTimeOut ]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/2/2017 10:36:17' prior: 16866151!
       select
	self isSelected: true.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + (10@0)
									with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !

MenuItemMorph removeSelector: #activateOwnerMenu:!

MenuItemMorph removeSelector: #activateOwnerMenu:!

MenuMorph removeSelector: #activeSubmenu:!

MenuMorph removeSelector: #activeSubmenu:!

MenuMorph removeSelector: #delete!

MenuMorph removeSelector: #delete!

MenuMorph removeSelector: #popUpOwner!

MenuMorph removeSelector: #popUpOwner!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3048-MenuSimplification-JuanVuletich-2017Mar02-10h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3048] on 2 March 2017 at 4:11:32 pm'!
!Transcripter class methodsFor: 'instance creation' stamp: 'dhn 2/6/2017 13:38:40' prior: 16938922!
        newInFrame: frame
"
(Transcripter newInFrame: (0@0 extent: 100@200))
	nextPutAll: 'Hello there'; endEntry;
	newLine; print: 355.0/113; endEntry;
	readEvalPrint.
"
	| transcript |
	transcript _ self on: (String new: 100).
	transcript initInFrame: frame.
	^ transcript clear! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3049-TranscripterCommentFix-DanNorton-2017Mar02-16h10m-dhn.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:17:59 am'!
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:35:58'!
                cleanseStepList
	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."

	| deletions morphToStep |
	deletions _ nil.
	stepList do: [:entry |
		morphToStep _ entry receiver.
		morphToStep world == world ifFalse:[
			deletions ifNil: [deletions _ OrderedCollection new].
			deletions addLast: entry]].

	deletions ifNotNil:[
		deletions do: [:entry|
			self stopSteppingMorph: entry receiver]].

	self alarms copy do:[:entry|
		morphToStep _ entry receiver.
		((morphToStep is: #Morph) and: [ morphToStep world == world ]) 
			ifFalse: [ self removeAlarm: entry selector for: entry receiver ]].! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:42:28'!
      runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue msg |

	queue _ self class deferredUIMessages.
	[ (msg _ queue nextOrNil) isNil ] whileFalse: [
		msg value
	].
	self runLocalStepMethods.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:41'!
              displayWorldSafely
	"Update this world's display and keep track of errors during draw methods."

	[world displayWorld] ifError: [:err :rcvr |
		"Handle a drawing error"
		| errCtx errMorph |
		errCtx _ thisContext.
		[
			errCtx _ errCtx sender.
			"Search the sender chain to find the morph causing the problem"
			[errCtx notNil and: [ (errCtx receiver is: #Morph) not ]] 
				whileTrue:[errCtx _ errCtx sender].
			"If we're at the root of the context chain then we have a fatal drawing problem"
			errCtx ifNil:[^self handleFatalDrawingError: err].
			errMorph _ errCtx receiver.
			"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
			errMorph isKnownFailing
		] whileTrue.
		errMorph drawingFails.
		self clearCanvas.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:09'!
                         doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0 ifTrue: [
		waitDelay beingWaitedOn
			ifFalse: [ waitDelay setDelay: wait; wait ]
			ifTrue: [
				"If we are called from a different process than that of the main UI, we might be called in the main
				interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
				(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:47'!
                doOneCycleNow
	"Immediately do one cycle of the interaction loop.
	This should not be called directly, but only via doOneCycleFor:"

	| hadAnyEvent |
	"See #eventTickler"
	Cursor currentCursor = Cursor wait ifTrue: [
		Cursor normal activateCursor ].

	"Repair visual damage."
	DisplayScreen checkForNewScreenSize.
	self displayWorldSafely.

	"Run steps, alarms and deferred UI messages"
	world runStepMethods.

	"Process user input events. Run all event triggered code."
	hadAnyEvent _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ hadAnyEvent | h processEventQueue.
		activeHand _ nil ].

	"The default is the primary hand"
	activeHand _ self hands first.


	^hadAnyEvent! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:43:12'!
   tryDeferredUpdatingAndSetCanvas
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		world morphPosition: 0@0 extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:43:18'!
            displayWorldAndSubmorphs: submorphs
	"Update this world's display."

	| deferredUpdateVMMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasSubmorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	canvas newClipRect: nil.
	handsToDraw reverseDo: [ :h | canvas fullDrawHand: h ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		"Drawing was done to off-Display canvas. Copy content to Display"
		canvas showAt: world viewBox origin invalidRects: allDamage ].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	Display forceDamageToScreen: allDamage.

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12'!
        drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Color gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Color random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:39:56'!
    simpleDrawInvalidAreasSubmorphs: submorphs

	"mover todo esto al canvas, no?
	Y ver que hacer con los argumentos, etc.... Toda esta bananarama!!"

	"Redraw the damaged areas of the given canvas and clear the damage list.
	Return a collection of the areas that were redrawn.
	This simple implementation just does as requested: No optimizations are done."

	| rectsToRepair morphBounds |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	rectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.

	"Draw World"
	rectsToRepair do: [ :r |
		world drawOn: (canvas newClipRect: r) ].

	"Draw morphs"
	submorphs reverseDo: [ :morph |
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			rectsToRepair do: [ :r |
				(morphBounds intersects: r) ifTrue: [
					(canvas newClipRect: r) fullDraw: morph ]]]].

	^ rectsToRepair! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/2/2017 21:47:15'!
         runLocalStepMethods
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| now morphToStep scheduledTime |
	now _ lastCycleTime.
	self triggerAlarmsBefore: now.
	stepList isEmpty 
		ifTrue: [ ^self].
	[ stepList isEmpty not and: [ stepList first scheduledTime <= now ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: now - scheduledTime + lastStepMessage stepTime.
					lastStepMessage ifNotNil: [
							lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: now + 1).
							stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 3/2/2017 19:34:01' prior: 16887286!
 doOneCycleNow
	"see the comment in doOneCycleNowFor:
	Only used for a few tests."
	worldState doOneCycleNow! !
!PasteUpMorph methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:36:23' prior: 16887443!
                            cleanseStepList
	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."

	worldState cleanseStepList! !
!PasteUpMorph methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:42:32' prior: 16887451!
 runStepMethods

	worldState runStepMethods! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:34:54' prior: 16887760!
                          displayWorldSafely

	worldState displayWorldSafely
! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:33:20' prior: 16887765!
                 doOneCycle
	"see the comment in WorldState >> doOneCycle"

	worldState doOneCycle! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:37:11' prior: 16887829!
                   privateOuterDisplayWorld

	worldState displayWorldAndSubmorphs: submorphs
! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21' prior: 16946320!
                      experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Color green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Color gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !

WorldState removeSelector: #cleanseStepListForWorld:!

WorldState removeSelector: #cleanseStepListForWorld:!

WorldState removeSelector: #displayWorld:submorphs:!

WorldState removeSelector: #displayWorld:submorphs:!

WorldState removeSelector: #displayWorldSafely:!

WorldState removeSelector: #displayWorldSafely:!

WorldState removeSelector: #doOneCycleFor:!

WorldState removeSelector: #doOneCycleFor:!

WorldState removeSelector: #doOneCycleNowFor:!

WorldState removeSelector: #doOneCycleNowFor:!

WorldState removeSelector: #drawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #drawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #runLocalStepMethodsIn:!

WorldState removeSelector: #runLocalStepMethodsIn:!

WorldState removeSelector: #runStepMethodsIn:!

WorldState removeSelector: #runStepMethodsIn:!

WorldState removeSelector: #simpleDrawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #simpleDrawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #tryDeferredUpdatingAndSetCanvasFor:!

WorldState removeSelector: #tryDeferredUpdatingAndSetCanvasFor:!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3050-WorldState-refactor-JuanVuletich-2017Mar03-09h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:22:19 am'!
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 3/2/2017 19:58:01' prior: 50339844!
              doOneCycleNow
	"see the comment in WorldState >> doOneCycleNow
	Only used for a few tests."
	worldState doOneCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/3/2017 09:21:41' prior: 50339561!
                doOneCycleNow
	"Immediately do one cycle of the interaction loop."

	| hadAnyEvent |
	"See #eventTickler"
	Cursor currentCursor = Cursor wait ifTrue: [
		Cursor normal activateCursor ].

	"Repair visual damage."
	DisplayScreen checkForNewScreenSize.
	self displayWorldSafely.

	"Run steps, alarms and deferred UI messages"
	self runStepMethods.

	"Process user input events. Run all event triggered code."
	hadAnyEvent _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ hadAnyEvent | h processEventQueue.
		activeHand _ nil ].

	"The default is the primary hand"
	activeHand _ self hands first.


	^hadAnyEvent! !

PasteUpMorph removeSelector: #runStepMethods!

PasteUpMorph removeSelector: #runStepMethods!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3051-WorldState-refactor-JuanVuletich-2017Mar03-09h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:27:56 am'!
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 20:08:11'!
             doOneMinimalCycleNow
	"see the comment in WorldState >> doOneMinimalCycleNow"

	worldState doOneMinimalCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 20:06:48'!
      doOneMinimalCycleNow
	"Immediately do one cycle of the interaction loop.
	Only repair display and process events. For modal menus and such."

	"Repair visual damage."
	self displayWorldSafely.

	"Process user input events. Run all event triggered code."
	^activeHand processEventQueue! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 3/2/2017 20:08:34' prior: 16867177!
         invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self	
		popUpAt: actHand morphPosition
		forHand: actHand 
		allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	[ self isInWorld & self isModalInvokationDone not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:29' prior: 16865463!
                          invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self
		popUpAt: aPoint
		forHand: actHand
		allowKeyboard: aBoolean.
	done _ false.
	[ self isInWorld & done not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !
!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:24' prior: 16844196!
                   getUserResponse
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."

	| w |
	w _ self world.
	w ifNil: [^ response].
	done _ false.
	textPane focusText.
	[done] whileFalse: [w doOneMinimalCycleNow].
	self delete.
	w doOneMinimalCycleNow.
	^ response
! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 3/3/2017 09:26:42' prior: 16844289!
                             request: queryString initialAnswer: defaultAnswer centerAt: aPoint onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."
	"
	FillInTheBlankMorph
		request: 'Type something, then type [Return].'
		initialAnswer: 'yo ho ho!!'
	"

	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		setQuery: queryString
		initialAnswer: defaultAnswer
		acceptOnCR: acceptBoolean.
	aFillInTheBlankMorph responseUponCancel: returnOnCancel.
	self runningWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.
	^ aFillInTheBlankMorph getUserResponse! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3052-MenusDoReducedWorldCycle-JuanVuletich-2017Mar03-09h22m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:49:08 am'!
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 09:47:13'!
     runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| morphToStep scheduledTime |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: nowTime - scheduledTime + lastStepMessage stepTime.
					lastStepMessage ifNotNil: [
							lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: nowTime + 1).
							stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:33:59' prior: 16945643!
                            addAlarm: aSelector withArguments: argArray for: aTarget at: scheduledTime
	"Add a new alarm with the given set of parameters"

	alarms add: 
		(MorphicAlarm 
			receiver: aTarget
			selector: aSelector
			arguments: argArray
			at: scheduledTime)! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:34:03' prior: 16945653!
                    adjustAlarmTimes: nowTime
	"Adjust the alarm times after some clock weirdness (such as image-startup etc)"
	| deltaTime |
	deltaTime _ nowTime - lastAlarmTime.
	alarms do: [ :alarm |
		alarm scheduledTime: alarm scheduledTime + deltaTime ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:34:21' prior: 16945673!
                            removeAlarm: aSelector for: aTarget 
	"Remove the alarm with the given selector"

	| alarm |
	alarm := alarms 
				detect: [ :any | any receiver == aTarget and: [any selector == aSelector]]
				ifNone: nil.
	alarm ifNotNil: [ alarms remove: alarm ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:35:03' prior: 16945684!
                   triggerAlarmsBefore: nowTime
	"Trigger all pending alarms that are to be executed before nowTime."

	nowTime - lastAlarmTime > 10000
		ifTrue: [ self adjustAlarmTimes: nowTime ].
	[ alarms notEmpty and: [ alarms first scheduledTime < nowTime ]]
		whileTrue: [ alarms removeFirst valueAtTime: nowTime ].
	lastAlarmTime _ nowTime! !
!WorldState methodsFor: 'initialization' stamp: 'jmv 3/3/2017 09:33:53' prior: 16945782!
                            initialize

	activeHand _ HandMorph new.
	hands _ { activeHand }.
	damageRecorder _ DamageRecorder new.
	stepList _ Heap sortBlock: self stepListSortBlock.
	alarms _ Heap sortBlock: self alarmSortBlock.
	lastAlarmTime _ 0.
	drawingFailingMorphs _ WeakIdentitySet new.
	pause _ 20.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ false! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 09:39:18' prior: 50339438!
      cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions morphToStep |
	deletions _ nil.
	stepList do: [:entry |
		morphToStep _ entry receiver.
		morphToStep world == world ifFalse:[
			deletions ifNil: [deletions _ OrderedCollection new].
			deletions addLast: entry]].

	deletions ifNotNil:[
		deletions do: [:entry|
			self stopSteppingMorph: entry receiver]].

	alarms copy do: [ :entry |
		morphToStep _ entry receiver.
		((morphToStep is: #Morph) and: [ morphToStep world == world ]) 
			ifFalse: [ self removeAlarm: entry selector for: entry receiver ]]! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 09:46:37' prior: 50339461!
                   runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue msg |

	queue _ self class deferredUIMessages.
	[ (msg _ queue nextOrNil) isNil ] whileFalse: [
		msg value
	].
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !

WorldState removeSelector: #alarms!

WorldState removeSelector: #alarms!

WorldState removeSelector: #runLocalStepMethods!

WorldState removeSelector: #runLocalStepMethods!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3053-WorldState-refactor-JuanVuletich-2017Mar03-09h27m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:17:47 am'!

MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #StepMessage category: #'Morphic-Events'!
MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:14:28'!
     valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
"OJO!!"
lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondsSinceLast]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 11:16:08' prior: 50340125!
                runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| morphToStep scheduledTime |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: nowTime.
					lastStepMessage ifNotNil: [
						lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: nowTime + 1).
						stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !

MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #StepMessage category: #'Morphic-Events'!
MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3054-StepMessageCleanup-JuanVuletich-2017Mar03-11h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:41:31 am'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:28:02'!
                   rescheduleAfter: millisecondTimer
	"Schedule next run"
	scheduledTime _ scheduledTime + self stepTime max: millisecondTimer + 1! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:34' prior: 16945882!
          stopStepping: aMorph selector: aSelector
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph and: [ stepMsg selector == aSelector ]])! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:22' prior: 16945896!
                              stopSteppingMorph: aMorph
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select: [ :stepMsg | stepMsg receiver == aMorph])! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 11:39:10' prior: 50340297!
                runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| stepMessage |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [

			stepMessage _ stepList first.
			(stepMessage receiver shouldGetStepsFrom: world)
				ifTrue: [
					stepMessage valueAtTime: nowTime.
					"If it was not removed from the list during its own evaluation"
					stepMessage == stepList first ifTrue: [
						stepList removeFirst.
						stepMessage rescheduleAfter: nowTime.
						stepList add: stepMessage ]]

				ifFalse: [ stepList removeFirst ].
		]! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3055-SteppingCleanup-JuanVuletich-2017Mar03-11h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:55:19 am'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:55:15' prior: 50340275!
                             valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondsSinceLast]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]! !
!PasteUpMorph methodsFor: 'caching' stamp: 'jmv 3/3/2017 11:42:44' prior: 16887042!
                       releaseCachedState
	super releaseCachedState.
	backgroundImage _ nil.
	self isWorldMorph ifTrue: [
		worldState cleanseStepList.
		worldState clearCanvas ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 11:54:00' prior: 50340174!
                removeAlarm: aSelector for: aTarget 
	"Remove the alarm with the given selector"

	| alarm |
	alarm _ alarms 
				detect: [ :any | any receiver == aTarget and: [any selector == aSelector]]
				ifNone: nil.
	alarm ifNotNil: [ alarms remove: alarm ]! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:51:16' prior: 50340213!
                  cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions |
	deletions _ OrderedCollection new.
	stepList do: [ :entry |
		entry receiver world == world ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		stepList remove: entry ].

	deletions _ OrderedCollection new.
	alarms do: [ :entry |
		((entry receiver is: #Morph) and: [ entry receiver world == world ]) ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		alarms remove: entry ]! !

PasteUpMorph removeSelector: #cleanseStepList!

PasteUpMorph removeSelector: #cleanseStepList!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3056-SteppingCleanup-JuanVuletich-2017Mar03-11h41m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3056] on 3 March 2017 at 3:11:05 pm'!
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/3/2017 15:04:20' prior: 50339505!
                              doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 5
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3057-SteppingHangWorkaround-JuanVuletich-2017Mar03-15h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 7:15:45 pm'!
!TestCase methodsFor: 'Running' stamp: 'HAW 3/3/2017 19:13:13'!
                    debugAsFailureIfCanNot: handler
	
	| semaphore |
	
	self ifCanNotDebugDo: [ ^handler value].
	
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. 
	self tearDown.
	self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:09'!
                 canNotDebugMethodErrorDescription

	^self class canNotDebugMethodErrorDescription! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 18:50:08'!
           ifCanNotDebugDo: handler

	^self testMethod isQuick ifTrue: handler! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:37'!
                         signalCanNotDebugMethod 

	self error: self canNotDebugMethodErrorDescription! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:10:20'!
               testMethod 

	^self class lookupSelector: self selector! !
!TestCase class methodsFor: 'Instance Creation' stamp: 'HAW 3/3/2017 18:51:38'!
                     debugAsFailure: aSymbol ifCanNot: handler

	^(self selector: aSymbol) debugAsFailureIfCanNot: handler
	! !
!TestCase class methodsFor: 'Error Descriptions' stamp: 'HAW 3/3/2017 16:33:00'!
    canNotDebugMethodErrorDescription

	^'Quick methods can not be debugged'! !
!Browser methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:25' prior: 50338007!
         debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]
! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:39' prior: 50338094!
          acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ 
			aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]]! !
!TestCase methodsFor: 'Running' stamp: 'HAW 3/3/2017 18:49:24' prior: 16927491!
                 debugAsFailure
	
	^self debugAsFailureIfCanNot: [ self signalCanNotDebugMethod ]! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 19:13:40' prior: 16927518!
                            openDebuggerOnFailingTestMethod

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self testMethod.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ Debugger new
		process: guineaPig
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 19:14:27' prior: 16927535!
                               openDebuggerOnFailingTestMethod: semaphore

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self testMethod.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ TestCaseDebugger new
		process: guineaPig
		context: context.
	debugger doneSemaphore: semaphore.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !

TestCase class removeSelector: #debugAsFailure:!

TestCase class removeSelector: #debugAsFailure:!

TestCase removeSelector: #assertCanDebugMethod!

TestCase removeSelector: #canNotDebugQuickMethodErrorDescription!

TestCase removeSelector: #signalCanNotDebugQuickMethod!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3058-CuisCore-HernanWilkinson-2017Mar02-18h30m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3058] on 6 March 2017 at 10:14:29 am'!
!Delay class methodsFor: 'timer process' stamp: 'jmv 3/6/2017 10:13:34' prior: 16833016!
                            handleTimerEvent
	"Handle a timer event; which can be either:
		- a schedule request (ScheduledDelay notNil)
		- an unschedule request (FinishedDelay notNil)
		- a timer signal (not explicitly specified)
	We check for timer expiry every time we get a signal."
	| nowTick nextTick afterwardsTick |
	"Wait until there is work to do."
	TimingSemaphore wait.

	"Process any schedule requests"
	ScheduledDelay ifNotNil: [
		"Schedule the given delay"
		self scheduleDelay: ScheduledDelay.
		ScheduledDelay := nil.
		ScheduledDelayNilledSemaphore initSignals. 
		ScheduledDelayNilledSemaphore signal ].

	"Process any unschedule requests"
	FinishedDelay ifNotNil: [
		self unscheduleDelay: FinishedDelay.
		FinishedDelay := nil.
		FinishedDelayNilledSemaphore initSignals.
		FinishedDelayNilledSemaphore signal ].

	"Check for clock wrap-around."
	nowTick := Time millisecondClockValue.
	nowTick < ActiveDelayStartTime ifTrue: [
		"clock wrapped"
		self saveResumptionTimes.
		self restoreResumptionTimes ].
	ActiveDelayStartTime := nowTick.

	"Signal any expired delays"
	[ ActiveDelay notNil and:[ nowTick >= ActiveDelay resumptionTime ]] whileTrue: [
		ActiveDelay signalWaitingProcess.
		SuspendedDelays isEmpty 
			ifTrue: [ ActiveDelay := nil ] 
			ifFalse:[ ActiveDelay := SuspendedDelays removeFirst ]].

	"And signal when the next request is due. We sleep at most 1sec here
	as a soft busy-loop so that we don't accidentally miss signals."
	nextTick := nowTick + 1000.
	ActiveDelay ifNotNil: [
		nextTick := nextTick min: ActiveDelay resumptionTime ].
	nextTick := nextTick min: SmallInteger maxVal.

	"Since we have processed all outstanding requests, reset the timing semaphore so
	that only new work will wake us up again. Do this RIGHT BEFORE setting the next
	wakeup call from the VM because it is only signaled once so we mustn't miss it."
	TimingSemaphore initSignals.
	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.

	"This test is necessary for the obscure case that the msecs clock rolls over
	after nowTick has been computed (unlikely but not impossible). In this case we'd
	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets
	scheduled (which may not be any time soon). In any case, since handling the
	condition is easy, let's just deal with it."
	afterwardsTick _ Time millisecondClockValue.
	afterwardsTick < nowTick  						"Means clock rollover."
		ifTrue: [ TimingSemaphore signal ]. "retry"

	"It seems that #primSignal:atMilliseconds: might not signal the semaphore if the requested moment is in the past.
	This behavior was observed in Linux Spur64 VMs.
	If this happens, next delay never finishes. Usual symptom is frozen Morphic.
	If there is any risk of this happening, just do another iteration right now."
	nextTick < afterwardsTick  						"We're already late for next signal."
		ifTrue: [ TimingSemaphore signal ]. "retry"! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/5/2017 00:38:27' prior: 50340470!
                     doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3059-RealFixForSteppingFreeze-JuanVuletich-2017Mar06-10h02m-jmv.1.cs.st----!

----SNAPSHOT----#(6 March 2017 10:36:25.90543 am) Cuis5.0-3059.image priorSource: 202624!

----QUIT----#(6 March 2017 10:36:43.98243 am) Cuis5.0-3059.image priorSource: 293299!

----STARTUP----#(8 March 2017 9:34:14.372206 am) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3059.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3059] on 7 March 2017 at 9:52:45 am'!
!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 09:52:37' prior: 16937622!
                        primMillisecondClock
	"Primitive. Answer the number of milliseconds since the millisecond clock
	was last reset or rolled over. No sync to any system clock.
	Implemented by all major platforms.
	Essential. See Object documentation whatIsAPrimitive. 
	
	Time primMillisecondClock
	Time primMillisecondClock / 1000 / 60.0

	Range is  from zero to 16r1FFFFFFF.
	The VM defines MillisecondClockMask as 16r1FFFFFFF

	Overflows usually every six days.
	Still used in #localMillisecondClock if the VM doesn't implement
		Time primLocalMicrosecondClock
	"
"Not really a clock, but a timer or ticker"

	<primitive: 135>
	self primitiveFailed! !
!Delay class methodsFor: 'timer process' stamp: 'jmv 3/7/2017 09:51:10' prior: 50340660!
           handleTimerEvent
	"Handle a timer event; which can be either:
		- a schedule request (ScheduledDelay notNil)
		- an unschedule request (FinishedDelay notNil)
		- a timer signal (not explicitly specified)
	We check for timer expiry every time we get a signal."
	| nowTick nextTick afterwardsTick |
	"Wait until there is work to do."
	TimingSemaphore wait.

	"Process any schedule requests"
	ScheduledDelay ifNotNil: [
		"Schedule the given delay"
		self scheduleDelay: ScheduledDelay.
		ScheduledDelay := nil.
		ScheduledDelayNilledSemaphore initSignals. 
		ScheduledDelayNilledSemaphore signal ].

	"Process any unschedule requests"
	FinishedDelay ifNotNil: [
		self unscheduleDelay: FinishedDelay.
		FinishedDelay := nil.
		FinishedDelayNilledSemaphore initSignals.
		FinishedDelayNilledSemaphore signal ].

	"Check for clock wrap-around."
	nowTick := Time millisecondClockValue.
	nowTick < ActiveDelayStartTime ifTrue: [
		"clock wrapped"
		self saveResumptionTimes.
		self restoreResumptionTimes ].
	ActiveDelayStartTime := nowTick.

	"Signal any expired delays"
	[ ActiveDelay notNil and:[ nowTick >= ActiveDelay resumptionTime ]] whileTrue: [
		ActiveDelay signalWaitingProcess.
		SuspendedDelays isEmpty 
			ifTrue: [ ActiveDelay := nil ] 
			ifFalse:[ ActiveDelay := SuspendedDelays removeFirst ]].

	"And signal when the next request is due. We sleep at most 1sec here
	as a soft busy-loop so that we don't accidentally miss signals."
	nextTick := nowTick + 1000.
	ActiveDelay ifNotNil: [
		nextTick := nextTick min: ActiveDelay resumptionTime ].
	nextTick := nextTick min: 16r1FFFFFFF.	"MillisecondClockMask"

	"Since we have processed all outstanding requests, reset the timing semaphore so
	that only new work will wake us up again. Do this RIGHT BEFORE setting the next
	wakeup call from the VM because it is only signaled once so we mustn't miss it."
	TimingSemaphore initSignals.
	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.

	"This test is necessary for the obscure case that the msecs clock rolls over
	after nowTick has been computed (unlikely but not impossible). In this case we'd
	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets
	scheduled (which may not be any time soon). In any case, since handling the
	condition is easy, let's just deal with it."
	afterwardsTick _ Time millisecondClockValue.
	afterwardsTick < nowTick  						"Means clock rollover."
		ifTrue: [ TimingSemaphore signal ]. "retry"

	"It seems that #primSignal:atMilliseconds: might not signal the semaphore if the requested moment is in the past.
	This behavior was observed in Linux Spur64 VMs.
	If this happens, next delay never finishes. Usual symptom is frozen Morphic.
	If there is any risk of this happening, just do another iteration right now."
	nextTick < afterwardsTick  						"We're already late for next signal."
		ifTrue: [ TimingSemaphore signal ]. "retry"! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3060-Proper-MillisecondClockMask-JuanVuletich-2017Mar07-09h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3061] on 7 March 2017 at 12:20:30 pm'!
!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:16:43' prior: 16937642!
                     primUtcMicrosecondClock
	"Answer the number of microseconds since the UTC Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, the start of the 20th century, in UTC time.
	 The value is derived from the Posix epoch with a constant offset corresponding to elapsed microseconds
	 between the two epochs according to RFC 868.
	Answer is (at least usually) a  LargePositiveInteger
	Cog VMs implement this. Interpreters might not."
	"
	Time primUtcMicrosecondClock
	Time primUtcMicrosecondClock/ 1000 / 1000 / 60 / 60 / 24 / 365.25

	(Time primUtcMicrosecondClock / 1000 / 1000 + Time primUtcWithOffset second) / 60 / 60 / 24 / 365.25
	(DateAndTime now - (DateAndTime year: 1901 month: 1 day: 1)) totalSeconds / 60 / 60 / 24 / 365.25
	"
	<primitive: 240>
	^nil! !
!Delay class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:19:39'!
                       primSignal: aSemaphore atUTCMicroseconds: anInteger
	"Signal the semaphore when the UTC microsecond clock reaches the value of the second argument.
	 Fail if the first argument is neither a Semaphore nor nil.
	Fail if the second argument is not an integer (either SmallInteger or LargePositiveInteger).
	See #primUtcMicrosecondClock
	 Essential. See Object documentation whatIsAPrimitive."
	<primitive: 242>
	^self primitiveFailed! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3061-UTCDelayedSignalPrimitive-JuanVuletich-2017Mar07-12h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3061] on 7 March 2017 at 2:55:27 pm'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuMorph methodsFor: 'control' stamp: 'ar 9/17/2000 20:38'!
  activeSubmenu: aSubmenu
	activeSubMenu ifNotNil:[activeSubMenu delete].
	activeSubMenu _ aSubmenu.! !
!MenuMorph methodsFor: 'initialization' stamp: 'ar 10/10/2000 01:57'!
                    delete
	activeSubMenu ifNotNil:[activeSubMenu delete].
	^super delete! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/20/2012 00:14'!
                     activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil: [ ^false ]. "not applicable"
	(owner morphContainsPoint: (owner internalizeFromWorld: evt eventPosition))
		ifFalse: [ ^false ].
	owner activate: evt.
	^true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/7/2017 14:37:43' prior: 50339167!
                    deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	stayUp ifFalse: [ self delete ].
	popUpOwner ifNotNil: [
		popUpOwner isSelected: false.
		popUpOwner deleteIfPopUp: evt ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 5/9/2016 20:40' prior: 50339176!
          popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 17:50' prior: 50339315!
  handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:15' prior: 50339357!
     initialize
	super initialize.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 1/29/2014 23:46' prior: 50339370!
           deselect

	self isSelected: false.
	subMenu ifNotNil: [
		owner ifNotNil:[ owner activeSubmenu: nil ].
		self removeAlarm: #deselectTimeOut ]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 1/29/2014 23:44' prior: 50339376!
                          select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + (10@0)
									with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3062-FixRecentMenuBreackage-JuanVuletich-2017Mar07-14h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 7 March 2017 at 3:18:07 pm'!
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:23'!
                              methodForTest

	"Can not call it testMethod because it will be detected as test - Hernan" 

	^self class lookupSelector: self selector! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:38' prior: 50340554!
      ifCanNotDebugDo: handler

	^self methodForTest isQuick ifTrue: handler! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:45' prior: 50340608!
      openDebuggerOnFailingTestMethod

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ Debugger new
		process: guineaPig
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:50' prior: 50340625!
                            openDebuggerOnFailingTestMethod: semaphore

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ TestCaseDebugger new
		process: guineaPig
		context: context.
	debugger doneSemaphore: semaphore.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !

TestCase removeSelector: #testMethod!

TestCase removeSelector: #testMethod!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3063-FixForExtraTest-HernanWilkinson-2017Mar03-19h15m-HAW.1.cs.st----!

----SNAPSHOT----#(8 March 2017 9:34:44.802068 am) Cuis5.0-3063.image priorSource: 293390!

----QUIT----#(8 March 2017 9:34:58.446732 am) Cuis5.0-3063.image priorSource: 306631!

----STARTUP----#(13 March 2017 5:41:16.036263 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3063.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3063] on 13 March 2017 at 4:16:45 pm'!
!WriteStream methodsFor: 'accessing' stamp: 'jmv 3/12/2017 18:55:36' prior: 50335197!
 nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !
!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:08:07' prior: 16946568!
growTo: anInteger
	"Grow the collection by creating a new bigger collection and then
	copy over the contents from the old one. We grow by doubling the size.

	anInteger is the required minimal new size of the collection "

	| oldSize grownCollection newSize |
	oldSize _ collection size.
     newSize _ anInteger + (oldSize max: 20).
	grownCollection _ collection class new: newSize.
	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.
	writeLimit _ collection size! !
!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:07:28' prior: 16946596!
                  pastEndPut: anObject
	"Grow the collection.
	Then we put <anObject> at the current write position."

	self growTo: collection size + 1.
	collection at: (position _ position + 1) put: anObject! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3064-WriteStreamTweaks-JuanVuletich-2017Mar13-16h06m-jmv.1.cs.st----!

----SNAPSHOT----#(13 March 2017 5:41:23.462443 pm) Cuis5.0-3064.image priorSource: 306722!

----QUIT----#(13 March 2017 5:41:40.450702 pm) Cuis5.0-3064.image priorSource: 308528!

----STARTUP----#(19 March 2017 8:09:32.765418 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3064.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 15 March 2017 at 2:07:10 pm'!
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 3/15/2017 14:06:54' prior: 50337450!
  maximumUsableAreaInWorld: aWorldOrNil

	| allowedArea |
	allowedArea _ Display boundingBox.
	aWorldOrNil ifNotNil: [
		allowedArea _ allowedArea intersect: aWorldOrNil viewBox.
		aWorldOrNil taskbar ifNotNil: [ :tb |
			tb morphBoundsInWorld ifNotNil: [ :r |
				allowedArea _ (allowedArea areasOutside: r) first ]]].
	^allowedArea
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3065-TaskbarFix-JuanVuletich-2017Mar15-14h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 17 March 2017 at 10:25:22 am'!
!Debugger methodsFor: 'method creation' stamp: 'HAW 3/17/2017 10:24:51' prior: 50336709!
                    createMethodWhenDoesNotUndertand

	| message chosenClass interruptedContext |
	
	"The doesNotUndertand context must be selected - Hernan"
	contextStackIndex = 1 ifFalse: [ self contextStackIndex: 1 oldContextWas: self selectedContext ].
		
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	
	self implement: message inClass: chosenClass context: self selectedContext

! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3066-CreateMissingMethodInDebuggerFix-HernanWilkinson-2017Mar16-20h05m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 18 March 2017 at 10:47:28 am'!
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/18/2017 10:44:48' prior: 50338473!
                       cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debug it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3067-FixATypo-HernanWilkinson-2017Mar18-10h44m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 18 March 2017 at 8:30:03 pm'!
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 3/18/2017 20:26:59' prior: 16934784!
                            buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Preferences...'. { self. #preferencesDo}.
					'put up a menu offering many controls over appearance and system preferences.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Restore Display (r)'. { myWorld. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name\and save it under that name on disk.\Clear all user preferences and user state (class vars).' withNewLines}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the image and quit out of Cuis.'}.				
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !

TheWorldMenu removeSelector: #saveAndQuitSession!

TheWorldMenu removeSelector: #saveMenu!

TheWorldMenu removeSelector: #saveMenu!

TheWorldMenu removeSelector: #saveOptionsDo!

TheWorldMenu removeSelector: #saveOptionsDo!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3068-SaveMenuIntegrationInWorldMenu-HernanWilkinson-2017Mar18-10h53m-HAW.1.cs.st----!

----SNAPSHOT----#(19 March 2017 8:09:41.870491 pm) Cuis5.0-3068.image priorSource: 308620!

----QUIT----#(19 March 2017 8:10:01.388395 pm) Cuis5.0-3068.image priorSource: 314597!

----STARTUP----#(16 April 2017 9:00:23.300511 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3068.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3068] on 26 March 2017 at 11:30:12 pm'!
!Theme class methodsFor: 'class initialization' stamp: 'jmv 3/26/2017 23:25:17' prior: 16936878!
                     currentTheme: aTheme

	CurrentTheme := aTheme new.
	SHTextStylerST80 initialize.
	self runningWorld ifNotNil: [ :w |
		w backgroundImage ifNil: [
			w color: CurrentTheme background ]].
	SystemWindow initialize.
	BitBltCanvas releaseClassCachedState.
	self runningWorld ifNotNil: [ :w |
		CurrentTheme useTaskbar
			ifTrue: [w showTaskbar]
			ifFalse: [w hideTaskbar].
		w restoreMorphicDisplay ].
	
	^ CurrentTheme! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3069-Theme-fix-JuanVuletich-2017Mar26-23h30m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 25 March 2017 at 10:48:23 am'!
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'HAW 3/25/2017 10:48:00' prior: 16782575!
                             classComment: aString 
	"Store the comment, aString, associated with the object that refers to the 
	receiver."

	aString ifNil: [ ^classComment _ nil ].
	
	aString isRemote
		ifTrue: [classComment _ aString]
		ifFalse: [aString size = 0
			ifTrue: [classComment _ nil]
			ifFalse: [
				self error: 'use aClass classComment:'.
				classComment _ RemoteString newString: aString onFileNumber: 2]]
				"Later add priorSource and date and initials?"! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3070-ClassCommentSetterFix-HernanWilkinson-2017Mar25-10h47m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 27 March 2017 at 9:11:54 am'!
!Delay class methodsFor: 'instance creation' stamp: 'HAW 3/27/2017 09:08:00' prior: 16832891!
               forDuration: aDuration

	^ self forMilliseconds: aDuration totalMilliseconds! !

Duration removeSelector: #totalMilliSeconds!

Duration removeSelector: #totalMilliSeconds!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3071-Remove-totalMilliSeconds-HernanWilkinson-2017Mar27-09h08m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3068] on 30 March 2017 at 8:42:47 am'!
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:41:08'!
                            toggleCollapseOrShow
	"If collapsed, show me.
	If visible, collapse me."

	self visible
		ifTrue:  [ self collapse ]
		ifFalse: [ self showAndComeToFront ]! !
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:38:46' prior: 50337387!
            collapse
	"If taskbar not visible, just hide."

	self hide.
	self taskbar
		ifNotNil: [ :tb | tb wasCollapsed: self ]! !
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:38:12' prior: 50337102!
                  showAndComeToFront
	"Make me visible if not, set me on top of all other sibling morphs."
	self show; comeToFront! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 3/30/2017 08:41:28' prior: 50337683!
                      addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #toggleCollapseOrShow.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3072-taskbarButtonTogglesCollapsing-JuanVuletich-2017Mar30-08h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3072] on 30 March 2017 at 8:57:52 am'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 3/30/2017 08:54:49'!
                     aboutToCollapse: aMorph
	"Add a button for aMorph if not already there (see #taskbarIncludesAllWindows)"

	(self buttonFor: aMorph) ifNil: [
		self addButtonFor: aMorph ]! !
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:55:31' prior: 50341568!
                             collapse
	"If taskbar not visible, just hide."

	self taskbar
		ifNotNil: [ :tb | tb aboutToCollapse: self ].
	self hide! !

TaskbarMorph removeSelector: #wasCollapsed:!

TaskbarMorph removeSelector: #wasCollapsed:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3073-TaskbarFix-JuanVuletich-2017Mar30-08h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 29 March 2017 at 5:18:04 pm'!

Object subclass: #ExceptionHandlingCondition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #ExceptionHandlingCondition category: #'Exceptions Kernel'!
Object subclass: #ExceptionHandlingCondition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!ExceptionHandlingCondition commentStamp: '<historical>' prior: 0!
       I represent the protocol expected to be as condition on the exception handling message on:do:
I also define the protocol to create and combine exceptions handling conditions.
See methods #, and #- for a complemented documentation!
!ExceptionHandlingCondition commentStamp: '<historical>' prior: 50341641!
               I represent the protocol expected to be as condition on the exception handling message on:do:
I also define the protocol to create and combine exceptions handling conditions.
See methods #, and #- for a complemented documentation!

Smalltalk renameClassNamed: #ExceptionFilter as: #FilterExceptionHandlingCondition!

ExceptionHandlingCondition subclass: #FilterExceptionHandlingCondition
	instanceVariableNames: 'handleCondition filterCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #FilterExceptionHandlingCondition category: #'Exceptions Kernel'!
ExceptionHandlingCondition subclass: #FilterExceptionHandlingCondition
	instanceVariableNames: 'handleCondition filterCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

Smalltalk renameClassNamed: #ExceptionAdd as: #OrExceptionHandlingCondition!

ExceptionHandlingCondition subclass: #OrExceptionHandlingCondition
	instanceVariableNames: 'leftCondition rightCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #OrExceptionHandlingCondition category: #'Exceptions Kernel'!
ExceptionHandlingCondition subclass: #OrExceptionHandlingCondition
	instanceVariableNames: 'leftCondition rightCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!BlockClosure methodsFor: 'error handing' stamp: 'HAW 3/29/2017 15:16:01'!
                     handles: anException

	"This allows a block to be the handling condition of an exception handling.
	See Exception class>>handles:"
	
	^self value: anException ! !
!Exception class methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 15:48:57' prior: 16840211!
                 , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>,"
	
	^anExceptionHandlingCondition createOrConditionWithExceptionType: self! !
!Exception class methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 15:49:08'!
                  - anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>-"

	^anExceptionHandlingCondition createFilterConditionWithExceptionType: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:23:04'!
     createFilterConditionWithExceptionType: anExceptionType

	^FilterExceptionHandlingCondition handling: anExceptionType filtering: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:26:42'!
                 createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^FilterExceptionHandlingCondition handling: aFilterExceptionHandlingCondition filtering: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:40:33'!
         createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^FilterExceptionHandlingCondition handling: anOrExceptionHandlingCondition filtering: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:37:59'!
                   createOrConditionWithExceptionType: anExceptionType

	^OrExceptionHandlingCondition handling: anExceptionType or: self
! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:48:29'!
                               createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition handleCondition, self - aFilterExceptionHandlingCondition filterCondition 
	
	! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:09:54'!
                         createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^OrExceptionHandlingCondition handling: anOrExceptionHandlingCondition or: self! !
!ExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:29:18'!
              handles: anException 
	
	"Must return true if anException must be handle
	See also Exception class>>handles: anException"
	
	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 17:17:36'!
                            , anExceptionHandlingCondition

	"Creates a handling condition that will return true if either part of the condition handles the exception.
	It behaves like an or
	The following example will handle the exception
	[ Error signal ]
	   on:  Error, Halt 
	  do: [ :anError | ... ]
	
	The following example will also handle the exception:
	[ Halt signal ]
	   on:  Error, Halt
	  do: [ :anError | ... ]"
	
	self subclassResponsibility 
	! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:37'!
    - anExceptionHandlingCondition

	"Creates a handling condition that will not handle exceptions that meet the right side of the condition
	The following example will not handle the exception
	[ 1/0 ]
	   on:  Error - ZeroDivide 
	  do: [ :anError | ... ]
	
	The following example will handle the exception:
	[ Error signal ]
	   on:  Error - ZeroDivide 
	  do: [ :anError | ... ]
	
	Due to inconsisties that can arrise with combining #, with #- the implementation orders the in such a way that 'or conditions' go first 
	and 'filter conditions' go last. Doing so (Error - Notification) , (UnhandledError - ZeroDivide)  is converted to  Error, UnhandledError - Notification - ZeroDivide 
	Inconsisties can arrise because ZeroDivide is a subclass of Error and therefore if the condition is not ordered correctly a ZeroDivide could be handled.
	This inconsisty can be found in Pharo where the condition (Error - Notification) , (UnhandledError - ZeroDivide) does not filter ZeroDivide but 
	the condition Error, UnhandledError - Notification - ZeroDivide does filter it.
	That is the reason the implementation uses double dispatch
	"
	
	self subclassResponsibility 
	! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:31:13'!
createFilterConditionWithExceptionType: anExceptionType

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:31'!
                     createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:39'!
createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:51'!
       createOrConditionWithExceptionType: anExceptionType

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:34:31'!
                         createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:34:42'!
    createOrConditionWithOrCondition: anOrExceptionHandlingCondition 

	self subclassResponsibility ! !
!FilterExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:20:21'!
 filterCondition
	
	^filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:20:26'!
                             handleCondition
	
	^handleCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:20:41'!
                        handles: anException 
	
	^ (filterCondition handles: anException) not and: [ handleCondition handles: anException ]! !
!FilterExceptionHandlingCondition methodsFor: 'initialization' stamp: 'HAW 3/29/2017 13:45:21'!
         initializeHandling: aHandleCondition filtering: aFilterCondition 

	handleCondition _ aHandleCondition.
	filterCondition _ aFilterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:08'!
   , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createOrConditionWithFilterCondition: self! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:00'!
                          - anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createFilterConditionWithFilterCondition: self! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:56:46'!
            createFilterConditionWithExceptionType: anExceptionType

	^self class 
		handling: anExceptionType, filterCondition 
		filtering: handleCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:24'!
                   createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition - handleCondition, filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:48'!
               createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^anOrExceptionHandlingCondition, filterCondition - handleCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:56'!
                         createOrConditionWithExceptionType: anExceptionType

	^anExceptionType - handleCondition - filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:20:04'!
                          createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition handleCondition,handleCondition - aFilterExceptionHandlingCondition filterCondition - filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 15:32:33'!
                createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^anOrExceptionHandlingCondition, handleCondition - filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'printing' stamp: 'HAW 3/28/2017 17:20:55'!
                          printOn: aStream

	aStream
		print: handleCondition ;
		nextPutAll: ' - ';
		print: filterCondition ! !
!FilterExceptionHandlingCondition class methodsFor: 'instance creation' stamp: 'HAW 3/28/2017 17:18:11'!
               handling: aHandleCondition filtering: aFilterCondition 
	
	^self new initializeHandling: aHandleCondition filtering: aFilterCondition 
! !
!OrExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:55:27'!
                              leftCondition

	^leftCondition ! !
!OrExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:56:11'!
      rightCondition

	^rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:31:39'!
                               handles: anException

	^ (leftCondition handles: anException) or: [ rightCondition handles: anException ]! !
!OrExceptionHandlingCondition methodsFor: 'initialization' stamp: 'HAW 3/28/2017 17:32:20'!
                       initializeHandling: aLeftCondition or: aRightCondition

	leftCondition _ aLeftCondition.
	rightCondition _ aRightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:16'!
                        , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createOrConditionWithOrCondition: self
	! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:22'!
- anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createFilterConditionWithOrCondition: self
	! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:32:37'!
                  createFilterConditionWithExceptionType: anExceptionType

	^FilterExceptionHandlingCondition 
		handling: anExceptionType - leftCondition 
		filtering: rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:33:37'!
   createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition - leftCondition - rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:34:05'!
                     createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^ anOrExceptionHandlingCondition - leftCondition - rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:16:37'!
                              createOrConditionWithExceptionType: anExceptionType

	^self class handling: anExceptionType or: self! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 14:56:09'!
     createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^self, aFilterExceptionHandlingCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:20:32'!
                    createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^self class handling: anOrExceptionHandlingCondition or: self! !
!OrExceptionHandlingCondition methodsFor: 'printing' stamp: 'HAW 3/28/2017 17:54:46'!
    printOn: aStream
	
	aStream
		print: leftCondition;
		nextPutAll: ', ';
		print: rightCondition ! !
!OrExceptionHandlingCondition class methodsFor: 'instance creation' stamp: 'HAW 3/27/2017 15:47:32'!
                       handling: anExceptionClass or: anotherExceptionClass
 
	^self new initializeHandling: anExceptionClass or: anotherExceptionClass
! !

OrExceptionHandlingCondition removeSelector: #createOrHandlingConditionWithOrHandlingCondition:!

Exception class removeSelector: #createFilterConditionWithExceptionClass:!

Exception class removeSelector: #createHandlingConditionWithExceptionClass:!

Exception class removeSelector: #handling:!

Exception class removeSelector: #orHandlingExceptionClass:!

Smalltalk removeClassNamed: #ExceptionSet!

Smalltalk removeClassNamed: #ExceptionSet!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3074-ExceptionHandlingConditionEnh-HernanWilkinson-2017Mar26-18h04m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 29 March 2017 at 6:09:56 pm'!
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 17:59:55' prior: 50341955!
                              createOrConditionWithExceptionType: anExceptionType

	^anExceptionType, handleCondition - filterCondition ! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3075-ExceptionHandlingConditionFix-HernanWilkinson-2017Mar29-17h18m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3068] on 16 April 2017 at 7:53:58 pm'!
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/16/2017 19:53:14' prior: 16932110!
 compareToClipboard
	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."
	| s1 s2 |
	s1 _ self clipboardStringOrText string.
	s2 _ self selection ifEmpty: [self privateCurrentString].
	s1 = s2 ifTrue: [^ self inform: 'Exact match'].

	(TextModel new contents:
		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))
			openLabel: 'Comparison to Clipboard Text'! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3076-CompareToClipboardComparesSelection-JuanVuletich-2017Apr16-19h53m-jmv.1.cs.st----!

----SNAPSHOT----#(16 April 2017 9:00:39.728125 pm) Cuis5.0-3076.image priorSource: 314689!

----QUIT----#(16 April 2017 9:00:52.816126 pm) Cuis5.0-3076.image priorSource: 336438!

----STARTUP----#(14 May 2017 7:53:51.943165 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3076.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3076] on 13 May 2017 at 12:54:11 pm'!
!Integer methodsFor: 'printing' stamp: 'jmv 5/9/2017 19:45:38'!
         printOn: aStream length: minimum zeroPadded: zeroFlag
	"
	7 printOn: Transcript length: 4 padded: true. Transcript newLine.
	"
	self printOn: aStream base: 10 length: minimum padded: zeroFlag! !
!Character methodsFor: 'accessing' stamp: 'jmv 5/9/2017 19:49:32' prior: 16800371!
          digitValue
	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 
	otherwise. This is used to parse literal numbers of radix 2-36.
	$0 numericValue = 48
	$9 numericValue = 57
	$A numericValue = 65
	$Z numericValue = 90 
	$7 digitValue = 7 
	"

	| nv |
	nv _ self numericValue.
	(nv between: 48 and: 57)
		ifTrue: [ ^ nv - 48 ].
	(nv between: 65 and: 90)
		ifTrue: [ ^ nv - 55 ].
	^ -1! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3077-Integer-printPadded-JuanVuletich-2017May13-12h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3076] on 13 May 2017 at 1:02:33 pm'!
!Timespan class methodsFor: 'squeak protocol' stamp: 'jmv 5/9/2017 19:54:38'!
                      fromString: aString
	"Please call with specific subclass."

	^ self readFrom: aString readStream! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 17:48:37'!
                 readFrom: aStream 
	"Read a Week from the stream in any of the forms:  
		<year>-W<week>			(2009-W01) (ISO8601)"
	| weekNumber yearNumber firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [yearNumber := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream next = $W ifFalse: [
		self error: 'Invalid Format' ].

	weekNumber _ Integer readFrom: aStream.
	weekNumber < 1 ifTrue: [ self error: 'Invalid Format' ].
	(yearNumber < 100 and: [yearNumber >= 0])  ifTrue: [
		yearNumber _ yearNumber < 69 
			ifTrue: [2000 + yearNumber]
			ifFalse: [1900 + yearNumber]].

	^ self yearNumber: yearNumber weekNumber: weekNumber! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 10:54:55'!
                      yearNumber: yearNumber weekNumber: weekNumber

	| firstOfJanuary firstThursday thisThursday |
	firstOfJanuary _ DateAndTime year: yearNumber month: 1 day: 1.
	firstThursday _ firstOfJanuary + (4 - firstOfJanuary dayOfWeek \\ 7) days.
	thisThursday _ firstThursday + ((weekNumber-1) * 7) days.

	thisThursday yearNumber = yearNumber
		ifFalse: [ self error: 'Week does not exist' ].

	^ self including: thisThursday! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 16:41:15'!
                   readFrom: aStream 

	| year sign |
	sign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isDigit] whileFalse: [aStream skip: 1].
	year := (Integer readFrom: aStream) * sign.
	^ self yearNumber: year! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:24:09'!
     asMonth
	"Many allowed forms, see Month>>#readFrom:
		'July 1998' asMonth.
		'1998/7'asMonth.
	"

	^ Month fromString: self! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:39:13'!
                               asWeek
	"
		'2008-W52' asWeek.
		'2008-W53' asWeek. 'Invalid format!!'.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
		'2008-W52' asWeek start.
		'2009-W01' asWeek start
		'2009-W02' asWeek start
		'2009-W53' asWeek start
		'2010-W01' asWeek start
		'2010-W02' asWeek start
	"

	^ Week fromString: self! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:37:23'!
                     asYear
	"
		'2008' asYear.
		'2008' asYear start.
	"

	^ Year fromString: self! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/12/2017 10:55:06' prior: 16828675!
                    dayOfWeek

	"
	Sunday=1, ... , Saturday=7
	Monday=1, ... , Sunday=7
	'12 May 2017 ' asDate dayOfWeek = 5
	"

	^ (jdn rem: 7) + 1! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/12/2017 10:53:00' prior: 16828685!
  dayOfWeekName
	"
	'12 May 2017 ' asDate dayOfWeek = 5 
	'12 May 2017 ' asDate dayOfWeekName = #Friday 
	"

	^ Week nameOfDay: self dayOfWeek
! !
!Duration methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 10:59:51' prior: 16836040!
                      printOn: aStream
	"Format as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]
	(Duration days: 2 hours: 3 minutes: 16 seconds: 43) printString =  '2:03:16:43' 
	"
	| d h m s n |
	d _ self days abs.
	h _ self hours abs.
	m _ self minutes abs.
 	s _ self seconds abs truncated.
	n _ self nanoSeconds abs. 	self negative ifTrue: [ aStream nextPut: $- ].
	d printOn: aStream. aStream nextPut: $:.
	h printOn: aStream length: 2 zeroPadded: true.aStream nextPut: $:.
	m printOn: aStream length: 2 zeroPadded: true.aStream nextPut: $:.
	s printOn: aStream length: 2 zeroPadded: true.
	n = 0 ifFalse: [
		| z ps |
		aStream nextPut: $..
		ps _ n printString padded: #left to: 9 with: $0. 
		z _ ps findLast: [ :c | c digitValue > 0 ].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ]! !
!Date methodsFor: 'smalltalk-80' stamp: 'jmv 5/12/2017 10:54:58' prior: 16828235!
           weekdayIndex
	"Sunday=1, ... , Saturday=7
	Monday=1, ... , Sunday=7
	'12 May 2017 ' asDate weekdayIndex = 5
	"

	^ self dayOfWeek! !
!Date class methodsFor: 'squeak protocol' stamp: 'jmv 5/10/2017 21:56:27' prior: 16828417!
readFrom: aStream 
	"Read a Date from the stream in any of the forms:
		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  
		<month> <day> <year>		(April 15, 1982; 4/15/82)
		<year>-<month>-<day>		(1982-04-15) (ISO8601)"
	| day month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 31])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-DD-YY or DD-MonthName-YY or YY-MonthName-DD"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
			firstAsNumber
				ifNil: ["MonthName DD YY"
					day := Integer readFrom: aStream]
				ifNotNil: [
					year ifNil: ["DD MonthName YY"
						day := firstAsNumber]]]
		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"
			year 
				ifNil: ["MM-DD-YY or DD-MM-YY"
					firstAsNumber > 12
						ifTrue: ["DD-MM-YY"
							day := firstAsNumber.
							month := Month nameOfMonth: (Integer readFrom: aStream)]
						ifFalse: ["MM-DD-YY"
							month := Month nameOfMonth: firstAsNumber.
							day := Integer readFrom: aStream]]
				ifNotNil: ["YY-MM-DD"
					month := Month nameOfMonth: (Integer readFrom: aStream)]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	year
		ifNil: [year := Integer readFrom: aStream]
		ifNotNil: [day := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _  year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self year: year month: month day: day! !
!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 11:28:03' prior: 16873841!
                   readFrom: aStream 
	"Read a Month from the stream in any of the forms:  
		<month> <year>			(April 1982; APR-82; 4.82; APR82)  
		<month> <year>			(April, 1982; 4/82)
		<year>-<month>			(1982-04) (ISO8601)"
	"
	Month readFrom: 'July 1998' readStream
	"
	| month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-YY or YY-MonthName"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]
		ifFalse: ["MM-YY or YY-MM"
			month _ year 
				ifNil: ["MM-YY"
					Month nameOfMonth: firstAsNumber ]
				ifNotNil: ["YY-MM"
					Month nameOfMonth: (Integer readFrom: aStream)]].

	year ifNil: [
		[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
		year := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _ year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self month: month year: year! !
!Week methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 11:53:32' prior: 16944751!
           printOn: aStream
	"
		'2008-W52' asWeek.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
	"
	| thursday |
	thursday _ self start + 3 days.
	thursday yearNumber printOn: aStream.
	aStream nextPutAll: '-W'.
	(thursday dayOfYear-1 // 7 + 1) printOn: aStream length: 2 zeroPadded: true! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 10:54:04' prior: 16944773!
                    indexOfDay: aSymbol
	"
	Week indexOfDay: #Sunday = 7
	Week nameOfDay: 7 = #Sunday 
	"

	^ self dayNames indexOf: aSymbol! !
!Week class methodsFor: 'smalltalk-80' stamp: 'jmv 5/12/2017 10:53:55' prior: 16944778!
            nameOfDay: anIndex
	"
	Week indexOfDay: #Sunday = 7
	Week nameOfDay: 7 = #Sunday 
	"

	^ self dayNames at: anIndex! !
!Week class methodsFor: 'inquiries' stamp: 'jmv 5/10/2017 22:25:02' prior: 16944786!
                     dayNames

	^ #(Monday Tuesday Wednesday Thursday Friday Saturday Sunday)! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:22:17' prior: 16916294!
  asDate
	"Many allowed forms, see Date>>#readFrom:
		'2014/6/30' asDate.
		'70/12/30' asDate.
		'12/30/70' asDate.
		'30/12/70' asDate.
		'4/5/6' asDate.
		'15 April 1982' asDate.
	"

	^ Date fromString: self! !

Date class removeSelector: #fromString:!

Date class removeSelector: #fromString:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3078-WeekStartsOnMonday-NewWeekMonthYearCreationMethods-JuanVuletich-2017May13-12h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3076] on 13 May 2017 at 1:02:55 pm'!
!DateAndTime methodsFor: 'double dispatching' stamp: 'jmv 5/12/2017 17:17:21'!
  includingTimespanOf: aTimespanClass

	^ aTimespanClass includingDateAndTime: self! !
!Timespan methodsFor: 'double displatching' stamp: 'jmv 5/12/2017 17:17:18'!
                              includingTimespanOf: aTimespanClass

	^ aTimespanClass includingTimespan: self! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 16:48:47'!
                             includingDateAndTime: aDateAndTime

	^ self starting: aDateAndTime duration: Duration zero! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 17:22:59'!
                 includingTimespan: aDateAndTime

	| ending starting |
	starting _ self includingDateAndTime: aDateAndTime start.
	ending _ self includingDateAndTime: aDateAndTime end.
	starting = ending ifTrue: [ ^ starting ].
	self error: aDateAndTime printString, ' can not be included in a ', self name! !
!Date class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 16:48:52'!
              includingDateAndTime: aDateAndTime

	^self basicNew
 		start: aDateAndTime midnight;
		duration: (Duration days: 1);
		yourself! !
!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 16:48:55'!
                 includingDateAndTime: aDateAndTime
	"Months start at day 1"
	| monthStart days |
	monthStart _ DateAndTime
				year: aDateAndTime yearNumber
				month: aDateAndTime monthIndex
				day: 1.
	days _ self daysInMonth: monthStart monthIndex forYear: monthStart yearNumber.
	^ self basicNew
 		start: monthStart;
		duration: (Duration days: days);
		yourself! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 18:05:57'!
                 includingDateAndTime: aDateAndTime
	"
	Week including: '12 May 2017 ' asDate start
	(Week including: '12 May 2017 ' asDate start) start dayOfWeekName = #Monday 
	"

	| midnight weekStart |
	midnight _ aDateAndTime midnight.
	weekStart _ midnight - (midnight dayOfWeek - 1) days.

	^ self basicNew
 		start: weekStart;
		duration: (Duration weeks: 1);
		yourself! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 18:00:49'!
        includingDateAndTime: aDateAndTime
	"Answer a calendar year"

	^ self yearNumber: aDateAndTime yearNumber! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 17:18:23' prior: 16938217!
                  including: aDateAndTime

	^ aDateAndTime includingTimespanOf: self! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 17:43:17' prior: 16946731!
                               yearNumber: aYear

	| yearStart |
	yearStart _ DateAndTime year: aYear month: 1 day: 1.
	^ self basicNew
 		start: yearStart;
		duration: (Duration days: (self daysInYear: yearStart yearNumber));
		yourself! !

Year class removeSelector: #including:!

Year class removeSelector: #including:!

Week class removeSelector: #including:!

Week class removeSelector: #including:!

Month class removeSelector: #including:!

Month class removeSelector: #including:!

Date class removeSelector: #including:!

Date class removeSelector: #including:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3079-TimespanCreation-includingTimespan-JuanVuletich-2017May13-13h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3079] on 13 May 2017 at 2:18:26 pm'!
!DateAndTime methodsFor: 'private' stamp: 'jmv 5/13/2017 10:58:22'!
        substractDateAndtime: operand
	"operand is a DateAndTime or a Duration"

	| lvalue rvalue |
	offset = operand offset
		ifTrue: [
			lvalue _ self.
			rvalue _ operand ]
		ifFalse: [
			lvalue _ self asUTC.
			rvalue _ operand asUTC ].
	^ Duration
		seconds: (Time secondsInDay *(lvalue julianDayNumber - rvalue julianDayNumber)) + 
					(lvalue secondsSinceMidnight - rvalue secondsSinceMidnight)
		nanoSeconds: lvalue nanoSecond - rvalue nanoSecond! !
!DateAndTime methodsFor: 'private' stamp: 'jmv 5/13/2017 10:58:31'!
                       substractDuration: operand
	"operand is a DateAndTime or a Duration"

	^self + operand negated! !
!DateAndTime methodsFor: 'double dispatching' stamp: 'jmv 5/13/2017 10:59:45'!
               substractFrom: aDateAndTime

	^ aDateAndTime substractDateAndtime: self! !
!Duration methodsFor: 'double dispatching' stamp: 'jmv 5/13/2017 11:03:50'!
         substractFrom: aDateAndTimeOrDate

	^aDateAndTimeOrDate substractDuration: self! !
!Timespan methodsFor: 'private' stamp: 'jmv 5/13/2017 11:09:07'!
            substractDuration: aDuration

	^self class classDefinesDuration
		ifTrue: [ self class including: start - aDuration ]
		ifFalse: [ self class starting: start - aDuration duration: duration ]! !
!Timespan methodsFor: 'private' stamp: 'jmv 5/13/2017 11:18:25'!
                             substractTimespan: aTimespan

	aTimespan duration = self duration ifFalse: [
		self error: 'Can not substract Timespans of different duration' ].
	
	^self start substractDateAndtime: aTimespan start! !
!Timespan methodsFor: 'double displatching' stamp: 'jmv 5/13/2017 11:08:17'!
         substractFrom: aTimespan

	^ aTimespan substractTimespan: self! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/13/2017 11:00:53' prior: 16828596!
    - operand
	"operand is a DateAndTime or a Duration.
	Double dispatch"

	^ operand substractFrom: self! !
!Timespan methodsFor: 'ansi protocol' stamp: 'jmv 5/13/2017 14:16:21' prior: 16937995!
- aDurationOrTimespan

	^ aDurationOrTimespan substractFrom: self! !
!Timespan methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 11:13:39' prior: 16938027!
  includes: operand
	"Operand might be a Timespan or a DateAndtime"

	^ (operand is: #Timespan)
			ifTrue: [ (self includes: operand start)
						and: [ self includes: operand end ] ]
			ifFalse: [ operand between: start and: self end ]! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/13/2017 11:12:44' prior: 50342526!
                 includingTimespan: aTimespan

	| ending starting |
	starting _ self includingDateAndTime: aTimespan start.
	ending _ self includingDateAndTime: aTimespan end.
	starting = ending ifTrue: [ ^ starting ].
	self error: aTimespan printString, ' can not be included in a ', self name! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3080-TimespanLessTimespan-JuanVuletich-2017May13-14h12m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3080] on 13 May 2017 at 7:48:17 pm'!
!Week methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:37:37'!
                        weekNumber

	| thursday |
	thursday _ self start + 3 days.
	^thursday dayOfYear-1 // 7 + 1! !
!Week methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:37:18'!
                             yearNumber

	| thursday |
	thursday _ self start + 3 days.
	^thursday yearNumber! !
!Year methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:51:58'!
       yearNumber

	^ start yearNumber! !
!Week methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 14:38:20' prior: 50342455!
        printOn: aStream
	"
		'2008-W52' asWeek.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
	"
	self yearNumber printOn: aStream.
	aStream nextPutAll: '-W'.
	self weekNumber printOn: aStream length: 2 zeroPadded: true! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 14:59:27' prior: 50342469!
                       indexOfDay: aSymbol
	"
	(Week indexOfDay: #Sunday) = 7
	(Week nameOfDay: 7) = #Sunday 
	"

	^ self dayNames indexOf: aSymbol! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3081-WeekYearTweaks-JuanVuletich-2017May13-19h46m-jmv.1.cs.st----!

Cursor webLink maskForm bits: (Form extent: 16@16 
			fromArray: (#(3072 7680 7680 7680 7680 8118 8191 32767 65535 65535 65535 65535 65535 32766 32766 16380 )  collect: [:bits | bits bitShift: 16])
			offset: 0@0) bits.
Smalltalk garbageCollect.!

Form allInstances!

----SNAPSHOT----#(14 May 2017 7:54:25.719029 pm) Cuis5.0-3081.image priorSource: 336530!

----QUIT----#(14 May 2017 7:54:45.62971 pm) Cuis5.0-3081.image priorSource: 355382!

----STARTUP----#(25 May 2017 10:01:26.404971 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3081.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3081] on 16 May 2017 at 10:43:45 am'!
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 5/16/2017 10:43:40' prior: 16896077!
                             defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame oldFilledWidth oldFilledWidth2 prevContents |
	f _ AbstractFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.

	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ 0@0 extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + (0@2).
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	prevContents _ Form fromDisplay: outerFrame.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	oldFilledWidth _ 0.
	oldFilledWidth2 _ 0.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		filledWidth _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		filledWidth  > oldFilledWidth ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + (2@2) extent: filledWidth@17).
			filledWidth -200 > oldFilledWidth2
				ifFalse: [
					"Usually just request an update, to be done asynchronously."
					DisplayScreen screenUpdateRequired: outerFrame ]
				ifTrue: [
					"Once in a while, force a real screen update (warning: really slow on MacOS if done too often)"
					Display forceToScreen: outerFrame. oldFilledWidth2 _ filledWidth ].
			oldFilledWidth _ filledWidth ]].
	prevContents displayAt: outerFrame topLeft.
	self resume: result! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3082-displayProgressAt-slownessOnMacFix-JuanVuletich-2017May16-10h38m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3082] on 24 May 2017 at 12:34:49 am'!
!Collection methodsFor: 'sorting' stamp: 'jmv 5/24/2017 00:28:06'!
                           sorted
	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted "

	^self sorted: nil! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 5/24/2017 00:29:04' prior: 16805949!
                chooseInstVarAlphabeticallyThenDo: aBlock
	| allVars index |
	"Put up a menu of all the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."

	allVars _ self allInstVarNames sorted.
	allVars isEmpty ifTrue: [^ self inform: 'There are no
instance variables'].

	index _ (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	aBlock value: (allVars at: index)! !
!ClassDescription methodsFor: 'method dictionary' stamp: 'jmv 5/24/2017 00:28:55' prior: 16807219!
                              allMethodsInCategory: aSymbol
	"Answer a list of all the method categories of the receiver and all its superclasses"

	| aColl |
	aColl _ OrderedCollection new.
	self withAllSuperclasses do:
		[:aClass | aColl addAll:
			(aSymbol == ClassOrganizer allCategory
				ifTrue:
					[aClass organization allMethodSelectors]
				ifFalse:
					[aClass organization listAtCategoryNamed: aSymbol])].
	^ aColl asSet sorted

"TileMorph allMethodsInCategory: #initialization"! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 5/24/2017 00:29:09' prior: 16924088!
                    browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix _ caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList _ OrderedCollection new.
	Smalltalk allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList size > 0
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!ChangeSet methodsFor: 'method changes' stamp: 'jmv 5/24/2017 00:28:50' prior: 16797810!
                changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList _ OrderedCollection new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull _ clAssoc key asString.
		classNameInParts _ classNameInFull findTokens: ' '.

		(clAssoc value allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc value methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !

ArrayedCollection removeSelector: #asSortedArray!

ArrayedCollection removeSelector: #asSortedArray!

Collection removeSelector: #asSortedArray!

Collection removeSelector: #asSortedArray!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3083-remove-asSortedArray-JuanVuletich-2017May24-00h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 25 May 2017 at 8:17:34 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 5/25/2017 20:10:06' prior: 16859018!
                            tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		Raspi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^ ((n1 * 500000 * 1000) // t1) printStringWithCommas, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printStringWithCommas, ' sends/sec'! !
!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 5/14/2017 23:20:19' prior: 16925038!
     isRunningCogit
	"Returns true if we're running on the Cog JIT
	 (vmParameterAt: 46 is the size of the machine code zone)
	Smalltalk isRunningCogit
	"

	^(self vmParameterAt: 46)
		ifNotNil: [ :machineCodeZoneSize  | machineCodeZoneSize > 0 ]
		ifNil: [ false ]! !
!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 5/14/2017 23:20:40' prior: 16925049!
                     isSpur
	"Answer true if we are a Spur ObjectMemory.
	Spur introduces a new format of header for objects, new format for classes, etc.
	Smalltalk isSpur
	"

	^ self compactClassesArray isNil! !
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 5/14/2017 23:13:07' prior: 16925610!
                              copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak and Cuis projects. 1997-2017.'! !

Utilities class removeSelector: #compileUsingClosures!

Utilities class removeSelector: #compileUsingClosures!

Utilities class removeSelector: #decommissionTheAllCategory!

Utilities class removeSelector: #decommissionTheAllCategory!

Utilities class removeSelector: #initializeClosures!

Utilities class removeSelector: #initializeClosures!

SystemVersion class removeSelector: #currentPluginVersion!

SystemVersion class removeSelector: #currentPluginVersion!

SystemVersion class removeSelector: #parseVersionString:!

SystemVersion class removeSelector: #parseVersionString:!

SystemVersion class removeSelector: #pluginVersion:newerThan:!

SystemVersion class removeSelector: #pluginVersion:newerThan:!

SystemDictionary removeSelector: #fixSourceCodeLineEndings!

SystemDictionary removeSelector: #fixSourceCodeLineEndings!

SystemDictionary removeSelector: #makeInternalRelease!

SystemDictionary removeSelector: #makeInternalRelease!

SystemDictionary removeSelector: #removeTextCode!

SystemDictionary removeSelector: #removeTextCode!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3084-Cleanup-JuanVuletich-2017May25-20h08m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 25 May 2017 at 8:23:29 pm'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3085-Cleanup-JuanVuletich-2017May25-20h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3085] on 25 May 2017 at 9:56:27 pm'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 5/25/2017 21:56:04' prior: 50334147!
     saveAsNewVersion
	"Save the image/changes using the next available version number."
	"
	Smalltalk saveAsNewVersion
	"
	| fileName newName changesName systemVersion |
	self okayToSave ifFalse: [ ^ self ].
	systemVersion _ SystemVersion current.
	fileName _ String streamContents: [ :strm |
		strm
			nextPutAll: 'Cuis';
			print: systemVersion versionMajor;
			nextPut: $.;
			print: systemVersion versionMinor;
			nextPut: $-;
			print: systemVersion highestUpdate.
		Smalltalk isSpur
			ifTrue: [	
				Smalltalk wordSize = 4 ifTrue: [
					strm nextPutAll: '-32' ]]
			ifFalse: [
				strm nextPutAll: '-v3' ]].
	newName _ fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName _ DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName _ self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		^ self inform:
'There is already .changes file of the desired name,
', newName, '
curiously already present, even though there is
no corresponding .image file.   Please remedy
manually and then repeat your request.' ].
	"Try to clear all user state, including all class vars, preferences, etc"
	self saveAs: newName andQuit: false clearAllClassState: true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3086-NewImageFlavorNaming-JuanVuletich-2017May25-21h56m-jmv.1.cs.st----!

----SNAPSHOT----#(25 May 2017 10:01:33.374113 pm) Cuis5.0-3086-v3.image priorSource: 355472!

----QUIT----#(25 May 2017 10:01:45.270842 pm) Cuis5.0-3086-v3.image priorSource: 369192!

----STARTUP----#(14 June 2017 3:48:04.157986 pm) as C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\Cuis5.0-3086-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3086] on 29 May 2017 at 10:56:45 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 5/29/2017 22:55:50' prior: 50342972!
       tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		RasPi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec
		
		RasPi3B - StackSpur 								44,107,512 bytecodes/sec; 			2,767,863 sends/sec
		RasPi3B - CogSpur 							    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^ ((n1 * 500000 * 1000) // t1) printStringWithCommas, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printStringWithCommas, ' sends/sec'! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3087-RasPi3-tinyBenchmarks-JuanVuletich-2017May29-22h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3087] on 30 May 2017 at 2:27:08 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 5/30/2017 14:24:33' prior: 50343201!
              tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		RasPi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec
		
		RasPi3B - StackSpur 								44,107,512 bytecodes/sec; 			2,767,863 sends/sec
		RasPi3B - CogSpur 							    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		2.70GHz Core i5-6400 -CogSpur64 		3,162,934,362 bytecodes/sec; 		243,321,293 sends/sec
	
		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^ ((n1 * 500000 * 1000) // t1) printStringWithCommas, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printStringWithCommas, ' sends/sec'! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3088-CoreI5-tinyBenchmarks-JuanVuletich-2017May30-14h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3088] on 31 May 2017 at 10:25:43 am'!
!WordArray methodsFor: 'accessing' stamp: 'jmv 5/31/2017 09:48:37'!
 bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	WordArray with: 16rFF32791B :: bytesAt: 1 :: hex
	"

	| bytes word |
	bytes _ ByteArray new: 4.
	word _ self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !
!WordArray methodsFor: 'accessing' stamp: 'jmv 5/31/2017 09:53:07'!
      bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	WordArray new: 1 :: bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF] :: first hex
	"

	| word |
	word _ 0.
	4 to: 1 by: -1 do: [ :i | word _ word * 256 + (aByteArray at: i) ].
	self at: index put: word! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 5/31/2017 10:16:34'!
                bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	WordArray with: 16rFF32791B :: bytesAt: 1 :: hex
	"

	| bytes word |
	bytes _ ByteArray new: 4.
	word _ self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 5/31/2017 10:16:38'!
         bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	WordArray new: 1 :: bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF] :: first hex
	"

	| word |
	word _ 0.
	4 to: 1 by: -1 do: [ :i | word _ word * 256 + (aByteArray at: i) ].
	self at: index put: word! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3089-BytesAccessForBitmapAndWordArray-JuanVuletich-2017May31-10h25m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 28 May 2017 at 8:07:38 pm'!
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:01:43'!
     setUpResources
			
	self resources do: [:res | res isAvailable ifFalse: [^res signalInitializationError]].
! !
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:02:07'!
                tearDownResources
	
	self resources do: [:each | each reset]! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 20:03:22'!
                               runCaseAsFailure

	self setUpResources.
	self setUp.
	
	self openDebuggerOnFailingTestMethod! !
!TestSuite methodsFor: 'Running - Private' stamp: 'HAW 5/28/2017 20:04:46'!
                    setUpResources
			
	self resources do: [ :res | res isAvailable ifFalse: [^res signalInitializationError]].
	! !
!TestSuite methodsFor: 'Running - Private' stamp: 'HAW 5/28/2017 20:05:08'!
   tearDownResources
			
	self resources do: [:each | each reset]! !
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:01:57' prior: 16927482!
             debug

	self setUpResources.
	
	[(self class selector: testSelector) runCase] ensure: [self tearDownResources]
			! !
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:06:48' prior: 50340535!
                         debugAsFailureIfCanNot: handler
	
	self ifCanNotDebugDo: [ ^handler value].
	
	(self class selector: testSelector) runCaseAsFailure! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 16:11:59' prior: 16927577!
        executeShould: aBlock inScopeOf: anExceptonHandlingCondition 
	
	^self executeShould: aBlock inScopeOf: anExceptonHandlingCondition withExceptionDo: [:anException | ]
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 16:12:11' prior: 50339003!
    executeShould: aBlock inScopeOf: anExceptonHandlingCondition withExceptionDo: assertionsBlock

	^[aBlock value.
 	false] 
		on: anExceptonHandlingCondition
		do: [:exception | 
			assertionsBlock value: exception.
			exception sunitExitWith: true]! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 20:03:03' prior: 50341191!
                    openDebuggerOnFailingTestMethod

	| processToDebug context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	
	processToDebug _ [ [ self performTest ] ensure: [
		self tearDown.
		self tearDownResources]] newProcess.
	context _ processToDebug suspendedContext.
	
	debugger _ Debugger new
		process: processToDebug 
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod] whileFalse: [debugger send].
! !
!TestSuite methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:04:59' prior: 16928869!
           run

	| result |
 
	result := TestResult new.
	self setUpResources.	
	[self run: result] ensure: [self tearDownResources].
	
	^result
			! !

TestCase removeSelector: #openDebuggerOnFailingTestMethod2!

TestCase removeSelector: #openDebuggerOnFailingTestMethod:!

TestCase removeSelector: #openDebuggerOnFailingTestMethod:!

TestCase removeSelector: #runCaseAsFailure:!

TestCase removeSelector: #runCaseAsFailure:!

Smalltalk removeClassNamed: #TestCaseDebugger!

Smalltalk removeClassNamed: #TestCaseDebugger!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3090-SUnitDebugFix-HernanWilkinson-2017May23-19h28m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 28 May 2017 at 8:55:15 pm'!

MessageNode removeSelector: #test!

MessageNode removeSelector: #test!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3091-MessageNode-test-removal-HernanWilkinson-2017May28-20h54m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 28 May 2017 at 8:56:52 pm'!
!SetInspector methodsFor: 'accessing' stamp: 'HAW 5/28/2017 20:56:40' prior: 16907433!
fieldList
	
	(object isNil or: [ object array isNil]) ifTrue: [^ Set new].
	
	^ self baseFieldList, (object array withIndexCollect: [:each :i | each ifNotNil: [i printString]]) select: [:each | each notNil]! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3092-SetInspectorFix-HernanWilkinson-2017May28-20h55m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3092] on 2 June 2017 at 11:21:59 am'!
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:01:27'!
              defaultFailDescription

	^'Test failed'! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:02:09'!
                   fail

	^self failWith: self defaultFailDescription ! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:02:55'!
       failWith: aDescription

	self signalFailure: aDescription ! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:57:13'!
should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock description: aFailDescription

	^[aBlock value.
 	self failWith: aFailDescription ] 
		on: anExceptonHandlingCondition
		do: assertionsBlock ! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:58:09' prior: 16927436!
          should: aBlock

	self assert: aBlock value
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:58:16' prior: 16927439!
                            should: aBlock description: aString

	self assert: aBlock value description: aString
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:54:56' prior: 16927443!
                  should: aBlock raise: anExceptonHandlingCondition 

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: [ :anException | ]
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:00:17' prior: 16927448!
                      should: aBlock raise: anExceptonHandlingCondition description: aFailDescription

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: [:anException | ] description: aFailDescription! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:57:59' prior: 50338995!
should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock description: self defaultFailDescription! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:09:25' prior: 16927455!
                    shouldnt: aBlock

	self deny: aBlock value
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:09:20' prior: 16927458!
                            shouldnt: aBlock description: aString

	self deny: aBlock value description: aString
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:10:31' prior: 16927462!
                  shouldnt: aBlock raise: anExceptonHandlingCondition 

	^self shouldnt: aBlock raise: anExceptonHandlingCondition description: anExceptonHandlingCondition printString, ' was not expected to be raised'! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:06:04' prior: 16927468!
   shouldnt: aBlock raise: anExceptonHandlingCondition description: aFailDescription

	^aBlock 
		on: anExceptonHandlingCondition 
		do: [ :anException | self failWith: aFailDescription ]
! !

TestCase removeSelector: #executeShould:inScopeOf:!

TestCase removeSelector: #executeShould:inScopeOf:!

TestCase removeSelector: #executeShould:inScopeOf:withExceptionDo:!

TestCase removeSelector: #executeShould:inScopeOf:withExceptionDo:!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3093-TestsDebuggingImprovements-HernanWilkinson-2017Jun02-10h25m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3092] on 2 June 2017 at 4:06:08 pm'!
!Behavior methodsFor: 'user interface' stamp: 'HAW 6/2/2017 16:05:24'!
addTo: aSet referencesTo: aSymbol special: special byte: byte.
	
	self withAllSuperAndSubclassesDoGently: [ :class |
		(class whichSelectorsReferTo: aSymbol special: special byte: byte)
			do: [ :sel | aSet add: (MethodReference class: class selector: sel) ]].
	! !
!Behavior methodsFor: 'user interface' stamp: 'HAW 6/2/2017 16:05:35' prior: 16784612!
                               allLocalCallsOn: aSymbol
	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."

	| aSet special byte cls |
	
	aSet _ Set new.
	cls _ self theNonMetaClass.
	special _ Smalltalk 
		hasSpecialSelector: aSymbol
		ifTrueSetByte: [ :b | byte _ b ].
	
	cls addTo: aSet referencesTo: aSymbol special: special byte: byte.
	cls class addTo: aSet referencesTo: aSymbol special: special byte: byte.
	
	^aSet! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3094-LocalCallsFix-HernanWilkinson-2017Jun02-11h21m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3095] on 7 June 2017 at 10:50:30 am'!
!MessageSetWindow class methodsFor: 'instance creation' stamp: 'jmv 6/7/2017 10:49:13' prior: 16870573!
                             openMessageList: anArray label: aString
	"Create a standard system view for the message set on the list, anArray. 
	The label of the view is aString."

	^self open: (MessageSet messageList: anArray) label: aString! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3095-openMessageListlabel-fix-JuanVuletich-2017Jun07-10h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3094] on 3 June 2017 at 8:52:25 pm'!

MessageSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestResultWindow category: #'Tools-Testing'!
MessageSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 6/3/2017 20:40:29'!
                openTestResultWindow

	TestResultWindow openFor: testResult 
	! !
!TestCase methodsFor: 'Testing' stamp: 'HAW 6/3/2017 20:26:43'!
                              isSameAs: aTestCase

	^self class = aTestCase class and: [ testSelector = aTestCase selector ]! !
!TestResult methodsFor: 'Accessing' stamp: 'HAW 6/3/2017 20:27:28'!
                          removeFromDefectsAndAddToPassed: aPassed 

	errors 
		detect: [ :anError | anError isSameAs: aPassed ]
		ifFound: [ :anError | errors remove: anError ]
		ifNone: [ 
			failures 
				detect: [ :aFail | aFail isSameAs: aPassed ]
				ifFound: [ :aFail | failures remove: aFail ]
				ifNone: [ self error: aPassed printString, ' is not an error nor a failure' ]].
	passed add: aPassed
! !
!TestResultWindow methodsFor: 'actions' stamp: 'HAW 6/3/2017 20:51:08'!
                       debug

	model selection ifNotNil: [ :selection | | test |
		test := selection actualClass selector: selection selector.
		test debug.
		testResult removeFromDefectsAndAddToPassed: test.
		model removeMessageFromBrowserKeepingLabel. 
		self setLabel: testResult printString ]! !
!TestResultWindow methodsFor: 'actions' stamp: 'HAW 6/3/2017 20:51:12'!
  runSuite

	| suite |
	 
	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(ProgessiveTestRunner for: suite) value.
	! !
!TestResultWindow methodsFor: 'button creation' stamp: 'HAW 6/3/2017 20:51:16'!
                               createDebugButton

	^PluggableButtonMorph 
		model: self
		stateGetter: #isMessageSelected
		action: #debug
		label: 'Debug'.
! !
!TestResultWindow methodsFor: 'button creation' stamp: 'HAW 6/3/2017 20:51:20'!
              createReRunButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #runSuite
		label: 'Run Suite'.
! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:24'!
                         addButton: button to: row color: buttonColor

	button color: buttonColor.
	row addMorph: button proportionalWidth: 10! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:28'!
                          addButtonsTo: row color: buttonColor

	self addButton: self createDebugButton to: row color: buttonColor.
	self addButton: self createReRunButton to: row color: buttonColor.
	! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:32'!
buildLowerPanes

	| codeAndButtons  |

	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:36'!
  buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!TestResultWindow methodsFor: 'initialization' stamp: 'HAW 6/3/2017 20:51:40'!
  initializeFor: aTestResult 

	testResult := aTestResult ! !
!TestResultWindow methodsFor: 'testing' stamp: 'HAW 6/3/2017 20:51:46'!
                            isMessageSelected

	^model selection notNil ! !
!TestResultWindow class methodsFor: 'instance creation' stamp: 'HAW 6/3/2017 20:50:29'!
                        methodReferencesOf: tests

	^tests collect: [:aTest | MethodReference class: aTest class selector: aTest selector].
! !
!TestResultWindow class methodsFor: 'instance creation' stamp: 'HAW 6/3/2017 20:50:25'!
                openFor: aTestResult

	| window |

	window := self openMessageList: (self methodReferencesOf: aTestResult defects) label: aTestResult printString.
	window initializeFor: aTestResult.
	
	^window 

! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 6/3/2017 20:40:17' prior: 50338174!
              showDeffects
	
	 | defects |
			
	defects _ 	testResult defects.
	defects size = 1
		ifTrue: [ defects anyOne debug ] 
		ifFalse: [ self openTestResultWindow]! !

TestResult removeSelector: #forDebuggingAndInspection!

TestResult removeSelector: #forDebuggingAndInspection!

TestCase removeSelectorIfInBaseSystem: #should:raise:withMessageText:!

ProgessiveTestRunner removeSelector: #openTestResultForDebuggingAndInspection!

ProgessiveTestRunner removeSelector: #openTestResultForDebuggingAndInspection!

Smalltalk removeClassNamed: #TestResultForDebuggingAndInspection!

Smalltalk removeClassNamed: #TestResultForDebuggingAndInspection!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3096-TestResultWindow-HernanWilkinson-2017May28-21h03m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3094] on 3 June 2017 at 8:55:22 pm'!
!StringMorph methodsFor: 'drawing' stamp: 'HAW 6/3/2017 20:55:08' prior: 16918187!
               drawOn: aCanvas
	aCanvas
		drawString: (contents ifNil: [ '' ])
		at: 0@0
		font: self fontToUse
		color: color
		! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3097-StringMorph-fix-HernanWilkinson-2017Jun03-20h52m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3092] on 5 June 2017 at 12:39:46 am'!
!TheWorldMenu methodsFor: 'commands' stamp: 'pb 6/5/2017 00:35:30' prior: 16934691!
                        splitNewMorphList: list depth: d
	| middle c prev next out |
	d <= 0 ifTrue: [ ^ Array with: list ].
	middle := list size // 2 + 1.
	c := (list at: middle) name first: 3.
	prev := middle - 1.
	[
	prev > 0 and: [ ((list at: prev) name first: 3) = c ]] whileTrue: [ prev := prev - 1 ].
	next := middle + 1.
	[
	next <= list size and: [ ((list at: next) name first: 3) = c ]] whileTrue: [ next := next + 1 ].
	"Choose the better cluster"
	middle := middle - prev < (next - middle)
		ifTrue: [ prev + 1 ]
		ifFalse: [ next ].
	middle = 1 ifTrue: [ middle := next ].
	middle >= list size ifTrue: [ middle := prev + 1 ].
	(middle = 1 or: [ middle >= list size ]) ifTrue: [ ^ Array with: list ].
	out := WriteStream on: Array new.
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: 1
					to: middle - 1)
			depth: d - 1).
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: middle
					to: list size)
			depth: d - 1).
	^ out contents.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'pb 6/5/2017 00:38:53' prior: 16934754!
                          alphabeticalMorphMenu
	| list splitLists menu firstChar lastChar subMenu |
	list := Morph withAllSubclasses select: [ :m |
		m includeInNewMorphMenu ].
	list := list asArray sort: [ :c1 :c2 |
		c1 name < c2 name ].
	splitLists := self
		splitNewMorphList: list
		depth: 4.
	menu := MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstChar := i = 1
				ifTrue: [ $A ]
				ifFalse: [ 
					(splitLists at: i) first name first: 3 ].
			lastChar := i = splitLists size
				ifTrue: [ $Z ]
				ifFalse: [ 
					(splitLists at: i) last name first: 3 ].
			subMenu := MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					selector: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: firstChar asString , ' - ' , lastChar asString
				subMenu: subMenu ].
	^ menu.! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3098-MoreGranularAlphaMorphMenu-PhilBellalouna-2017Jun05-00h35m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3086] on 5 June 2017 at 11:53:55 am'!
!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 6/5/2017 11:51:33'!
                             exploreCompiledMethod
	"Open an Explorer on the CompiledMethod itself"

	self selectedMessageName ifNotNil: [
		(self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)
			explore ]! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 6/5/2017 11:46:27' prior: 50338724!
                          messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList:#(
			('what to show...'					offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry						''		model)
            	-
			('browse full (b)' 					browseMethodFull)
			('browse hierarchy (h)'			browseHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'							fileOutMessage							''		model)
			('explore CompiledMethod'		exploreCompiledMethod				''		model)
			-
			('senders of... (n)'				browseSendersOfMessages)
			('implementors of... (m)'		browseMessages)
			('inheritance (i)'					methodHierarchy)
			('versions (v)'						browseVersions)
			-
			('inst var refs...'					browseInstVarRefs)
			('inst var defs...'					browseInstVarDefs)
			('class var refs...'				browseClassVarRefs)
			('class variables'					browseClassVariables)
			('class refs (N)'					browseClassRefs)
			-
			('remove method (x)'			removeMessage							''		model)
			('Run test (t)'						runMethodTest 							'' 	model)
			('Debug test (r)'					debugMethodTest 						'' 	model)
			-
			('more...'							openShiftedMessageListMenu)).
	^ aMenu
! !
!Theme methodsFor: 'menus' stamp: 'jmv 6/5/2017 11:46:34' prior: 16935967!
      basicIcons

	"Minimal menu scheme.
	Theme current class beCurrent
	"

	^ { 
		#('open...') -> #openIcon.
		#('windows...' 'find window' 'Focus follows mouse' 'Click to focus') -> #windowIcon.
		#('help...' 'explain' 'about this system...' 'Terse Guide to Cuis' 'Class Comment Browser' 'Code management in Cuis' 'Using GitHub to host Cuis packages' ) -> #helpIcon.
		#('themes...') -> #appearanceIcon.
		#('do it (d)') -> #doItIcon.
		#('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon.
		#('save' ) -> #saveIcon.
		#('Save options...' 'save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon.
		#('save as new version') -> #saveAsNewVersionIcon.
		#('quit') -> #quitIcon.
		#('save and quit' ) -> #saveAndQuitIcon.
		#('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher' 'stop CPUWatcher')
			-> #inspectIcon.
		#('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'references finder' 'weight explorer' 'explore CompiledMethod') -> #exploreIcon.
		#('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon.
		#('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon.
		#('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript') -> #deleteIcon.
		#('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete') -> #warningIcon.
		#('do again (j)' 'Redo - multiple (Z)') -> #redoIcon.
		#('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon.
		#('copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon.
		#('paste (v)' 'Paste without Format') -> #pasteIcon.
		#('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon.
		#('paste...' 'icons...') -> #worldIcon.
}! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	Theme current class beCurrent!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3099-exploreCompiledMethod-menuOption-JuanVuletich-2017Jun05-11h19m-jmv.1.cs.st----!

----SNAPSHOT----#(14 June 2017 3:48:14.039986 pm) Cuis5.0-3099-v3.image priorSource: 369286!

----QUIT----#(14 June 2017 3:48:31.144986 pm) Cuis5.0-3099-v3.image priorSource: 400261!

----STARTUP----#(20 June 2017 5:57:20.091895 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3099-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 9 June 2017 at 12:14:01 am'!
!RectangleLikeMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:47:05'!
                   categoryInNewMorphMenu
	^ 'Kernel'! !
!PasteUpMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:51:39'!
 categoryInNewMorphMenu
	^ 'Worlds'! !
!EllipseMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:50:14'!
 categoryInNewMorphMenu
	^ 'Basic'! !
!ProgressBarMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:05:22'!
                              categoryInNewMorphMenu
	^ 'Widgets'! !
!ImageMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:54:09'!
  categoryInNewMorphMenu
	^ 'Basic'! !
!StringMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:55:41'!
   categoryInNewMorphMenu
	^ 'Basic'! !
!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:04:50'!
                           categoryInNewMorphMenu
	^ 'Widgets'! !
!LayoutMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:48:35'!
 categoryInNewMorphMenu
	^ 'Layouts'! !
!ProgressMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:10:17'!
                               categoryInNewMorphMenu
	^ 'Widgets'! !
!HaloHandleMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:53:34'!
                             categoryInNewMorphMenu
	^ 'Halos'! !
!HaloMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:53:26'!
     categoryInNewMorphMenu
	^ 'Halos'! !
!ResizeMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:56:28'!
   categoryInNewMorphMenu
	^ 'Views'! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:52:51'!
                           categoryInNewMorphMenu
	^ 'Widgets'! !
!HoverHelpMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:54:39'!
                              categoryInNewMorphMenu
	^ 'Widgets'! !
!TheWorldMenu methodsFor: 'construction' stamp: 'pb 6/9/2017 00:11:33' prior: 50332703!
 newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu subMenu catDict |
	menu _ self menu: 'Add a new morph'.
	menu
		
			add: 'From Clipboard'
			target: myHand
			action: #pasteMorph;
		
			add: 'From Alphabetical List'
			subMenu: self alphabeticalMorphMenu.
	menu addLine.
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.

	Morph allSubclassesDo: [ :eaSubclass |
		eaSubclass includeInNewMorphMenu ifTrue: [ | category |
			(eaSubclass respondsTo: #categoryInNewMorphMenu)
				ifTrue: [ category _ eaSubclass categoryInNewMorphMenu ]
				ifFalse: [ category _ 'Unknown' ].
			(catDict includesKey: category)
				ifTrue: [ (catDict at: category) add: eaSubclass ]
				ifFalse: [
					catDict
						at: category
						put: (OrderedCollection with: eaSubclass) ]]].
	catDict keys sort do: [ :categ |
		subMenu _ MenuMorph new.
		((catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ]) do: [ :cl |
			subMenu
				add: cl name
				target: self
				selector: #newMorphOfClass:event:
				argument: cl ].
		menu
			add: categ
			subMenu: subMenu ].
	self doPopUp: menu.! !

TheWorldMenu removeSelector: #newMorphOld!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3100-DynamicMorphMenuCategories-PhilBellalouna-2017Jun08-23h33m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 11 June 2017 at 8:11:06 pm'!
!TestCase class methodsFor: 'Testing' stamp: 'pb 6/11/2017 20:10:43' prior: 16927725!
                            isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"
	^ thisContext methodClass == self class.! !
!TestResource class methodsFor: 'Testing' stamp: 'pb 6/11/2017 20:10:52' prior: 16927869!
 isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"
	^ thisContext methodClass == self class.! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3101-isAbstract-PhilBellalouna-2017Jun11-20h10m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 9 June 2017 at 1:04:48 am'!
!Preferences class methodsFor: 'halos' stamp: 'pb 6/9/2017 00:46:36' prior: 16893159!
iconicHaloSpecifications
	"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles that may be used in the iconic halo scheme"

	"
	Preferences resetHaloSpecifications
	"

^ #(
	"selector						horiz				vert					color info						icon key 						balloon help
	 ---------						------				-----------			-------------------------------		---------------"
	(addCollapseHandle:		left				topCenter		(tan)							haloCollapseIcon 			'Collapse')
	(addDebugHandle:			right				topCenter		(orange)						haloDebugIcon 				'Debug')
	(addDismissHandle:			left				top				(red)							haloDismissIcon 				'Remove')
	"FIXME - Currently non-functional...
	(addRotateHandle:			left				bottom			(blue)							haloRotateIcon 				'Rotate')
	"
	(addMenuHandle:			leftCenter		top				(blue lighter)					haloMenuIcon 				'Menu')
	(addGrabHandle:				center			top				(black)							haloGrabIcon 				'Pick up')
	(addDragHandle:				rightCenter		top				(brown)						haloDragIcon 				'Move')
	(addDupHandle:				right				top				(green)						haloDuplicateIcon 			'Duplicate')	
	(addHelpHandle:				center			bottom			(lightBlue)					haloHelpIcon 				'Help')
	(addGrowHandle:			right				bottom			(yellow)						haloScaleIcon 				'Change size')
	(addFontSizeHandle:		leftCenter		bottom			(lightGreen)					haloFontSizeIcon 			'Change font')
	(addFontEmphHandle:		rightCenter		bottom			(lightBrown darker)			haloFontEmphasisIcon 		'Emphasis & alignment')
	"FIXME - Currently non-functional...
	(addRecolorHandle:			right				bottomCenter	(magenta darker)			haloColorIcon 				'Change color')
	"
)! !
!Morph methodsFor: 'halos and balloon help' stamp: 'pb 6/9/2017 00:52:09' prior: 16875868!
               wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	(#(addRotateHandle: addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].

	Preferences selectiveHalos ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addGrowHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !
!PasteUpMorph methodsFor: 'halos and balloon help' stamp: 'pb 6/9/2017 00:51:44' prior: 16887852!
             wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"
	(#(addHelpHandle: addRotateHandle: addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].
	
	self isWorldMorph ifFalse: [
		^super wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph ].

	^#(addDebugHandle: addMenuHandle: addHelpHandle:)
		statePointsTo: aSelector! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3102-Disable-Nonfunctional-Halos-PhilBellalouna-2017Jun09-00h45m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 10 June 2017 at 1:39:18 am'!
!Array methodsFor: 'printing' stamp: 'pb 6/10/2017 01:39:04' prior: 16779829!
                      isLiteral
	"Definition from Squeak"
	^ self class == Array and: [
		self allSatisfy: [ :each |
			each isLiteral ]].! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3103-Array-isLiteral-compatibility-with-Squeak-PhilBellalouna-2017Jun10-01h39m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:46:49 am'!
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/19/2017 11:45:52'!
                              fileOutCurrentVersionsOfSelections
	
	(FillInTheBlankMorph
		request: 'Enter file name'
		initialAnswer: 'Filename.st'
		onCancel: [^nil])

			asFileEntry writeStreamDo: [ :stream |
				stream timeStamp.
				self currentVersionsOfSelections do: [ :methodRef |
					methodRef actualClass
						printMethodChunk: methodRef methodSymbol
						withPreamble: true
						on: stream
						moveSource: false
						toFile: 0 ]]! !
!ChangeListWindow methodsFor: 'menu building' stamp: 'jmv 6/19/2017 11:39:03' prior: 16797171!
                           listMenu
	"Fill aMenu up so that it comprises the primary changelist-browser menu"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'change list'.
	aMenu addStayUpIcons.
	aMenu addList: #(
	('fileIn selections'							fileInSelections
			'import the selected items into the image'																			model)
	('fileOut selections...	'					fileOutSelections
			'create a new file containing the selected items'																	model)
	('fileOut current version of selections...'	fileOutCurrentVersionsOfSelections
			'create a new file containing the current (in-image) counterparts of the selected methods'					model)
	-
	('compare to current'						compareToCurrentVersion
			'open a separate window which shows the text differences between the on-file version and the in-image version.' model)
	('toggle diffing (D)'							toggleDiffing							
			'start or stop showing diffs in the code pane.'																		model)
	-
	('select new methods'						selectNewMethods
			'select methods in the file that do not currently exist in the image'												model)
	('select changes for absent classes'		selectAllForAbsentClasses
			'select methods in the file for classes that are not defined in the image'										model)
	('select all changes for this class'			selectAllForThisClass
			'select all methods in the file that belong to the currently-selected class'										model)
	('select unchanged methods'				selectUnchangedMethods	
			'select methods in the file whose in-image versions are the same as their in-file counterparts'				model)
	('select methods equivalent to current'	selectEquivalentMethods
			'select methods in the file whose in-image versions have the same behavior as their in-file counterparts'	model)
	('select methods older than current'		selectMethodsOlderThanCurrent
			'select methods in the file that are older than the one currently in the image'									model)
	('select removals of sent methods'		selectRemovalsOfSent
			'select all method removals of methods that have some sender in the image'									model)
	-
	('select all (a)'								selectAll
			'select all the items in the list'																							model)
	('deselect all'									deselectAll
			'deselect all the items in the list'																						model)
	('invert selections'							invertSelections
			'select every item that is not currently selected, and deselect every item that *is* currently selected'		model)
	-
	('browse class and method'				browseMethodFull
			'open a full browser showing the selected method')
	('browse all versions of single selection'	browseVersions
			'open a version browser showing the versions of the currently selected method')
	('browse current versions of selections'	browseCurrentVersionsOfSelections
			'open a message-list browser showing the current (in-image) counterparts of the selected methods')
	('destroy current methods of selections'	destroyCurrentCodeOfSelections
			'remove (*destroy*) the in-image counterparts of all selected methods'										model)
	-
	('remove doIts'								removeDoIts
			'remove all items that are doIts rather than definitions'																model)
	('remove older versions'					removeOlderMethodVersions
			'remove all but the most recent versions of methods in the list'													model)
	('remove up-to-date versions'				removeUpToDate
			'remove all items whose code is the same as the counterpart in-image code'									model)
	('remove empty class comments'			removeEmptyClassComments
			'remove all empty class comments'																					model)
	('remove selected items'					removeSelections
			'remove the selected items from the change-list'																	model)
	('remove unselected items'					removeNonSelections
			'remove all the items not currently selected from the change-list'												model)).
	^ aMenu! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3104-fileOutCurrentVersions-JuanVuletich-2017Jun19-11h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:07:11 am'!

FloatArray variableWordSubclass: #Colour
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #Colour category: #'Graphics-Primitives'!
FloatArray variableWordSubclass: #Colour
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!Colour commentStamp: 'jmv 6/18/2017 20:14:31' prior: 0!
                This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)
	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:
	r	amount of red, a Float between 0.0 and 1.0.
	g	amount of green, a Float between 0.0 and 1.0.
	b	amount of blue, a Float between 0.0 and 1.0.
	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)
	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.
	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.
	Here are some fun things to run in when your screen has color:
		Pen new mandala: 30 diameter: Display height-100.
		Pen new web  "Draw with the mouse, opt-click to end"
		Display fillWhite.  Pen new hilberts: 5.
		Form toothpaste: 30  "Draw with mouse, opt-click to end"

Messages:
	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.

	+ 	add two colors
	- 	subtract two colors
	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.
	/	divide a color by a factor or an array of three factors.

	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.
	saturation	Returns the saturation of the color.  0.0 to 1.0
	brightness	Returns the brightness of the color.  0.0 to 1.0

	name    Look to see if this Color has a name.
	display	Show a swatch of this color tracking the cursor.

	lightShades: thisMany		An array of thisMany colors from white to the receiver. 
	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.
	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.
	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.

	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. 

Messages to Class Color.
	red: r green: g blue: b		Return a color with the given r, g, and b components.
	r: g: b:		Same as above, for fast typing.

 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.

	pink
 	blue
	red ...	Many colors have messages that return an instance of Color.
	canUnderstand: #brown	  Returns true if #brown is a defined color.
	names		An OrderedCollection of the names of the colors.
	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.
	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.

	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.

    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array. 

   colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.

(See also comments in these classes: Form, Bitmap, BitBlt)

Default colorSpace is #sRGB. Subclasses might use other color spaces!

Colour variableWordSubclass: #TranslucentColour
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #TranslucentColour category: #'Graphics-Primitives'!
Colour variableWordSubclass: #TranslucentColour
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!TranslucentColour commentStamp: '<historical>' prior: 0!
   A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the fourth position.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.!
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                     alpha
	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TranslucentColors."

	^ 1.0
! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:34'!
    blue
	"Return the blue component of this color, a float in the range [0.0..1.0]."

	^ self at: 3! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:33:10'!
                              brightness
	"Return the brightness of this color, a float in the range [0.0..1.0].
	Color red brightness
	"

	"Do not include alpha if TranslucentColour"
	^ (self red max: self green) max: self blue! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:30'!
                        chroma
	"Return the chroma of this color, a value between 0.0 and 1.0, somewhat related to saturation.
	See http://en.wikipedia.org/wiki/HSL_and_HSV
	Color red chroma
	Color gray chroma
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	^max - min! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:28'!
                             green
	"Return the green component of this color, a float in the range [0.0..1.0]."

	^ self at: 2! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:31:54'!
                            hue
	"Return the hue of this color, an angle in the range [0.0..360.0].
	Color orange hue
	"

	| r g b max min span h |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	span _ (max - min) asFloat.
	span = 0.0 ifTrue: [ ^ 0.0 ].

	r = max ifTrue: [
		h _ ((g - b) asFloat / span) * 60.0.
	] ifFalse: [
		g = max
			ifTrue: [ h _ 120.0 + (((b - r) asFloat / span) * 60.0). ]
			ifFalse: [ h _ 240.0 + (((r - g) asFloat / span) * 60.0). ].
	].

	^h mod: 360.0! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
 icon
	"Answer a swatch to display in a menu or browser"
	^self swatch! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                         iconOrThumbnailOfSize: aNumberOrPoint 
	"Answer an appropiate form to represent the receiver"
	| form |
	form := Form extent: aNumberOrPoint asPoint asPoint depth: 32.
	form fillColor: self.
	^ form! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                        luminance
	"Return the luminance of this color, a brightness value weighted by the human eye's color sensitivity."

	^ ((299 * self red) +
	   (587 * self green) +
	   (114 * self blue)) / 1000! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:25'!
                             red
	"Return the red component of this color, a float in the range [0.0..1.0]."

	^ self at: 1! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:08'!
saturation
	"Return the saturation of this color, a value between 0.0 and 1.0.
	Color red saturation
	Color gray saturation
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	max = 0.0 ifTrue: [ ^0.0 ].
	^max - min / max! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                        swatch
	"Answer a swatch to display in a menu or browser"
	^self iconOrThumbnailOfSize: 16! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                               asNontranslucentColor
	^ self! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:20:07'!
                            bitPatternForDepth: depth
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"

	^ Bitmap with: (self pixelWordForDepth: depth)! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
               bitPatternForGrayForm
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"
	"Details: The pattern for the most recently requested depth is cached."

	^Bitmap with: (self pixelWordFor: 8 filledWith: (self luminance * 255) rounded)! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
         closestPixelValue1
	"Return the nearest approximation to this color for a monochrome Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 0].  "white"

	self luminance > 0.5
		ifTrue: [^ 0]  "white"
		ifFalse: [^ 1].  "black"! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                closestPixelValue2
	"Return the nearest approximation to this color for a 2-bit deep Form."

	| lum |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	lum _ self luminance.
	lum < 0.2 ifTrue: [^ 1].  "black"
	lum > 0.6 ifTrue: [^ 2].  "opaque white"
	^ 3  "50% gray"
! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                    closestPixelValue4
	"Return the nearest approximation to this color for a 4-bit deep Form."

	| bIndex |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	self isRed ifTrue: [^ 4].
	self isGreen ifTrue: [^ 5].
	self isBlue ifTrue: [^ 6].
	self isCyan ifTrue: [^ 7].
	self isYellow ifTrue: [^ 8].
	self isMagenta ifTrue: [^ 9].

	bIndex _ (self luminance * 8.0) rounded.  "bIndex in [0..8]"
	^ #(
		1	"black"
		10	"1/8 gray"
		11	"2/8 gray"
		12	"3/8 gray"
		3	"4/8 gray"
		13	"5/8 gray"
		14	"6/8 gray"
		15	"7/8 gray"
		2	"opaque white"
	) at: bIndex + 1.
! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                   closestPixelValue8
	"Return the nearest approximation to this color for an 8-bit deep Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 255].  "white"

	^self saturation < 0.2
		ifTrue: [
			^ self class grayToIndexMap at:(self green * 255) rounded + 1.  "nearest gray"
			]
		ifFalse: [
			"compute nearest entry in the color cube"
			40 + 
				((self red * 5) rounded * 36) +
				((self blue * 5) rounded * 6) +
				(self green * 5) rounded ]! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                  dominantColor
	^ self! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
    indexInMap: aColorMap
	"Return the index corresponding to this color in the given color map. RGB colors are truncated to 3-, 4-, or 5-bits per color component when indexing into such a colorMap.  "

	aColorMap size = 2 ifTrue: [^ (self pixelValueForDepth: 1) + 1].
	aColorMap size = 4 ifTrue: [^ (self pixelValueForDepth: 2) + 1].
	aColorMap size = 16 ifTrue: [^ (self pixelValueForDepth: 4) + 1].
	aColorMap size = 256 ifTrue: [^ (self pixelValueForDepth: 8) + 1].
	aColorMap size = 512 ifTrue: [^ (self pixelValueForDepth: 9) + 1].
	aColorMap size = 4096 ifTrue: [^ (self pixelValueForDepth: 12) + 1].
	aColorMap size = 32768 ifTrue: [^ (self pixelValueForDepth: 15) + 1].
	self error: 'unknown pixel depth'.
! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:51:40'!
                  makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Colour black]
                ifFalse: [Colour white]! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
  pixelValueForDepth: d
	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	d = 32 ifTrue: [
		"eight bits per component; top 8 bits set to all ones (opaque alpha)"
		val _ LargePositiveInteger new: 4.
		val at: 3 put: (self red * 255) rounded.
		val at: 2 put: (self green * 255) rounded.
		val at: 1 put: (self blue * 255) rounded.
		val at: 4 put: 16rFF.  "opaque alpha"
		^ val normalize].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val _ ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val _ ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val _ ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                         pixelWordFor: depth filledWith: pixelValue
	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."
	| halfword |
	depth = 32 ifTrue: [^ pixelValue].
	depth = 16
		ifTrue: [halfword _ pixelValue]
		ifFalse: [halfword _ pixelValue * 
					(#(16rFFFF				"replicates at every bit"
						16r5555 -			"replicates every 2 bits"
						16r1111 - - -			"replicates every 4 bits"
						16r0101) at: depth)	"replicates every 8 bits"].
	^ halfword bitOr: (halfword bitShift: 16)! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                              pixelWordForDepth: depth
	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."

	| pixelValue |
	pixelValue _ self pixelValueForDepth: depth.
	^ self pixelWordFor: depth filledWith: pixelValue
! !
!Colour methodsFor: 'equality' stamp: 'jmv 6/18/2017 20:38:11'!
          diff: theOther
	"Returns a number between 0.0 and 1.0.
	Color gray diff: Color red
	"
	^(self - theOther ) abs sum / self size! !
!Colour methodsFor: 'equality' stamp: 'jmv 6/18/2017 20:10:00'!
                              rgbDistance: otherColor
	"Compare two colors in distance"
"
	^ (self hue - otherColor hue) abs +
	  (self saturation - otherColor saturation) abs *10 +
	  (self brightness - otherColor brightness) abs
"
	"See http://www.compuphase.com/cmetric.htm"
	| meanRed deltaRed deltaGreen deltaBlue |
	meanRed := (self red + otherColor red) abs / 2.
	deltaRed := (self red - otherColor red) abs.
	deltaGreen := (self green - otherColor green) abs.
	deltaBlue := (self blue - otherColor blue) abs.
	
	^ ( ((2 + (meanRed / 256)) * (deltaRed * deltaRed)) +
		(4 * deltaGreen) +
		((2 + ((255 - meanRed) / 256)) * deltaBlue)
	  ) sqrt! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:10:00'!
        darkShades: thisMany
	"An array of thisMany colors from black to the receiver.  Array is of length num. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red darkShades: 12)"

	^ self class black mix: self shades: thisMany
! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:10:00'!
   lightShades: thisMany
	"An array of thisMany colors from white to self. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red lightShades: 12)"

	^ self class white mix: self shades: thisMany
! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:51:45'!
  mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Colour r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:52:45'!
     wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Colour h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Colour wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:00'!
      closestAssocFrom: aColorDict
	"Answer closest associated color in aColorDict"
"
	((Color r: 0.3 g: 0.2 b: 0.8) closestAssocFrom: (Color colorNamesDict)) explore.
"
	"Filter values for those close in hue (cheap test) then use rgbDistance"
	| closeInHue isClose close distance myHue |
	closeInHue := OrderedCollection new.
	myHue := self hue.
	isClose := [ :assoc | | delta |
		delta := ((assoc value hue) - myHue) abs.
		(delta < 20) or: [ delta > 340 ] "hues within 20 degrees"
	].
	aColorDict  associationsDo:  [ :assoc |
		(isClose value: assoc) ifTrue: [ closeInHue add: assoc ]
	].

	close := nil.
	distance := 1000. "big"
	(closeInHue size > 0)
		ifFalse: [ "fallback -- no color really close"
			aColorDict  associationsDo:  [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		]
		ifTrue: [ closeInHue do: [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		].
	
	^ close! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:51:07'!
                           closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Colour colorNamesDict)! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:51:11'!
closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Colour colorNamesDict)! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:00'!
                        closestColorFrom: aColorDict
	"Answer closest associated color"
"
	((Color lightBlue) closestColorFrom: (Color css2NamedColors)) explore..
"
	^(self closestAssocFrom: aColorDict) value! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:51:15'!
closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Colour colorNamesDict)! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:00'!
            closestNameFrom: aColorDict
	"Answer closest associated color name"
"
	((Color lightBlue) closestNameFrom: (Color namedColors)) print.
"
	^(self closestAssocFrom: aColorDict) key! !
!Colour methodsFor: 'other' stamp: 'jmv 6/18/2017 20:51:20'!
             colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Colour colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Colour methodsFor: 'other' stamp: 'jmv 6/18/2017 20:10:00'!
      name
	"Return this color's name, or description if unnamed."

	^ self printString
! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
          hexStringRGB
	"
	Color fromUser hexStringRGB
	"
	^String streamContents: [ :strm |
		(self red * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self green * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self blue * 255) rounded printOn: strm base: 16 length: 2 padded: true ]! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:53:07'!
        printOn: aStream
	 self colorName ifNotNil: [ :name |
		^ aStream
			nextPutAll: 'Colour ';
			nextPutAll: name].
	self storeOn: aStream.
! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
                  printString
	"Answer a String whose characters are a description of the receiver."
	
	^ String streamContents: [ :stream | self printOn: stream ]! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
           storeArrayOn: aStream

	aStream nextPutAll: '#('.
	self storeArrayValuesOn: aStream.
	aStream nextPutAll: ') '
! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
             storeArrayValuesOn: aStream


	self red printOn: aStream fractionDigits: 3.
	aStream space.
	self green printOn: aStream fractionDigits: 3.
	aStream space.
	self blue printOn: aStream fractionDigits: 3

! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
                 storeOn: aStream

	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPut: $)! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:55'!
   isBlack
	"Return true if the receiver represents black"
	(self at: 1) = 0.0 ifFalse: [ ^ false ].
	(self at: 2) = 0.0 ifFalse: [ ^ false ].
	(self at: 3) = 0.0 ifFalse: [ ^ false ].
	^ true! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:10:00'!
isOpaque
	^true! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:10:00'!
              isTransparent

	^ false
! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:46'!
     isWhite
	"Return true if the receiver represents white"
	(self at: 1) = 1.0 ifFalse: [ ^ false ].
	(self at: 2) = 1.0 ifFalse: [ ^ false ].
	(self at: 3) = 1.0 ifFalse: [ ^ false ].
	^ true! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                              isBlue
	"Am I considered Blue?"

	^self blue > (self green + 0.3)
		and: [self blue > (self red + 0.3)]
			and: [(self green - self red) abs < 0.4]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
        isBlueGreen
	"Am I considered BlueGreen ?"

	^self green > self red 
		and: [self red < 0.3]
			and: [(self green - self blue) abs < 0.1]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                  isBright
	"Am I considered a Bright color ?"

	^self brightness > 0.6! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                      isBrown
	"Am I considered Brown ?"

	^self red >= self green  
		and: [self green > self blue]					
			and: [(self red - self green) < 0.5]	
				and: [(self green - self blue) < 0.3]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
     isCyan
	"Am I considered Cyan ?"

	^self red < 0.05 
		and: [(self green min: self blue) > 0.5]					
			and: [(self green - self blue) abs < 0.2]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
          isDark
	"Am I considered a Dark color ?"

	^self brightness < 0.5! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                          isGray
	"Am I considered Gray  ?"

	^(self red closeTo: self green)
		and: [self blue closeTo: self green ]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                isGreen
	"Am I considered Green ?"

	^self green > (self blue + 0.3)
		and: [self blue > (self red + 0.3)]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                 isGrey
	"Am I considered Grey  ?"

	^self isGray! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
           isLight
	"Am I considered a Light color ?"

	^self brightness > 0.6! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                        isMagenta
	"Am I considered Magenta ?"

	^self green < 0.05 
		and: [(self red min: self blue) > 0.5]					
			and: [(self red - self blue) abs < 0.2]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
      isOrange
	"Am I considered Orange ?"

	^self red > ((self green max: self blue) + 0.2)  
		and: [self green > (self blue + 0.2)]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                           isPastel
	"Am I considered Pastel ?"

	^self saturation < 0.4! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                              isPink
	"Am I considered Pink ?"

	^self red > ((self green max: self blue) + 0.3)  
		and: [self blue > (self green + 0.2)]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                               isRed
	"Am I considered Red ?"

	^self red > (self green + 0.4)
		and: [self red > (self blue + 0.6)]
			and: [(self green - self blue) abs < 0.4]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
         isSaturated
	"Am I considered to be a Saturated color ?"

	^self saturation > 0.6! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
          isYellow
	"Am I considered Yellow ?"

	^self blue < 0.05 
		and: [(self red min: self green) > 0.5]					
			and: [(self red - self green) abs < 0.2]! !
!Colour methodsFor: 'testing' stamp: 'jmv 6/18/2017 20:10:00'!
         is: aSymbol
	^ aSymbol == #Color or: [ super is: aSymbol ]! !
!Colour methodsFor: 'testing' stamp: 'jmv 6/18/2017 20:10:00'!
   mightBeTranslucent
	"For Colors, answer if actually translucent or not."
	^self isOpaque not! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:14'!
                         * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Colour brown *2) display
	"
	^ Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:18'!
       + aColor
	"Answer this color mixed with the given color in an additive color space.  "
	"
	(Colour blue + Colour green) display
	"
	^ Colour new
		setRed: (self red + aColor red min: 1.0 max: 0.0)
		green: (self green + aColor green min: 1.0 max: 0.0)
		blue: (self blue + aColor blue min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:22'!
      - aColor
	"Answer aColor is subtracted from the given color in an additive color space.  "
	"
	(Color white - Color red) display
	"
	^ Colour new
		setRed: (self red - aColor red min: 1.0 max: 0.0)
		green: (self green - aColor green min: 1.0 max: 0.0)
		blue: (self blue - aColor blue min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:26'!
     / aNumber
	"Answer this color with its RGB divided by the given number. "
	"
	(Color red / 2) display
	"
	^ Colour new
		setRed: (self red / aNumber min: 1.0 max: 0.0)
		green: (self green / aNumber min: 1.0 max: 0.0)
		blue: (self blue / aNumber min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:50:50'!
            adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:50:53'!
                  adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:10:41'!
         alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifFalse: [
		^ TranslucentColour new
			setRed: self red
			green: self green
			blue: self blue
			alpha: alphaValue ]! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:50:57'!
             alphaMixed: proportion with: aColor 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)
		alpha: self alpha * frac1 + (aColor alpha * frac2)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                atLeastAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance < aFloat] whileTrue: [revisedColor _ revisedColor slightlyLighter].
	^revisedColor
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
    atMostAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance > aFloat] whileTrue: [revisedColor _ revisedColor slightlyDarker].
	^revisedColor
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:51:02'!
      blacker

	^ self alphaMixed: 0.8333 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:51:27'!
                              dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Colour h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                      darker
	"Answer a darker shade of this color."

	^ self adjustBrightness: -0.08! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
      duller

	^ self adjustSaturation: -0.03 brightness: -0.2! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                             lighter
	"Answer a lighter shade of this color."

	^ self adjustSaturation: -0.03 brightness: 0.08! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:51:59'!
                   mixed: proportion with: aColor 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColor alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:03'!
                      muchDarker

	^ self alphaMixed: 0.5 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:07'!
                              muchLighter

	^ self alphaMixed: 0.233 with: Colour white
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:12'!
                           negated
	"Return an RGB inverted color"
	^Colour
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:37:53'!
      orColorUnlike: theOther
	"If this color is a lot like theOther, then return its complement, otherwide, return self"

	^ (self diff: theOther) < 0.3
		ifTrue: [theOther negated]
		ifFalse: [self]! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                   paler
	"Answer a paler shade of this color."

	^ self adjustSaturation: -0.09 brightness: 0.09
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:16'!
                      quiteBlacker

	^ self alphaMixed: 0.8 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:19'!
                            quiteWhiter

	^ self alphaMixed: 0.6 with: Colour white! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                              slightlyDarker

	^ self adjustBrightness: -0.03
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
     slightlyLighter

	^ self adjustSaturation: -0.01 brightness: 0.03! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:24'!
                    slightlyWhiter

	^ self alphaMixed: 0.85 with: Colour white
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                         twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:01'!
 twiceLighter
	"Answer a significantly lighter shade of this color."

	^ self adjustSaturation: -0.06 brightness: 0.15! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:27'!
veryMuchDarker

	^ self alphaMixed: 0.25 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:32'!
                         veryMuchLighter

	^ self alphaMixed: 0.07 with: Colour white! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:02:05'!
                         whiter

	^ self alphaMixed: 0.8333 with: Colour white
! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:10:01'!
       attemptToMutateError
	"A color is immutable. Once a color's red, green, and blue have been initialized, you cannot change them. Instead, create a new Color and use it."

	self error: 'Color objects are immutable once created'
! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:32'!
                           basicSetRed: r green: g blue: b
	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0]."

	self
		at: 1 put: r;
		at: 2 put: g;
		at: 3 put: b! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:44'!
         setHue: hue chroma: chroma brightness: brightness
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 
	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ brightness - ((r1 max: g1) max: b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:49'!
                             setHue: hue chroma: chroma luminance: luma
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 

	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ luma - (0.299*r1) - (0.587*g1) - (0.114*b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0 
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:16:07'!
                          setHue: hue saturation: saturation brightness: brightness
	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."

	| s v hf i f p q t | 
	s _ saturation asFloat min: 1.0 max: 0.0.
	v _ brightness asFloat min: 1.0 max: 0.0.
	hf _ hue \\ 360.
	i _ hf // 60.  			"integer part of hue"
	f _ (hf \\ 60) / 60.0.         	"fractional part of hue"

	p _ (1.0 - s) * v.
	q _ (1.0 - (s * f)) * v.
	t _ (1.0 - (s * (1.0 - f))) * v.

	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].
	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].
	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].
	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].
	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].
	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].

	self error: 'implementation error'! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:13:04'!
  setRed: r green: g blue: b

	self basicSetRed: r green: g blue: b! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:48'!
                            setRed: r green: g blue: b range: range
	"Initialize this color's r, g, and b components to the given values in the range [0..r]."

	self basicSetRed: r green: g blue: b.
	self /= range! !
!Colour methodsFor: 'as yet unclassified' stamp: 'jmv 6/18/2017 20:10:01'!
                        color
	^ self! !
!Colour methodsFor: 'please remove' stamp: 'jmv 6/18/2017 21:26:21'!
          floatRGB
"to be removed"
	^ self! !
!Colour methodsFor: 'please remove' stamp: 'jmv 6/18/2017 21:26:07'!
                       setRed: r green: g blue: b colorSpace: aSymbol
	^ self setRed: r green: g blue: b! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
                            clipR: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0].
	Clip if necessary"

	^ self 
		r: (r min: 1.0 max: 0.0)
		g: (g min: 1.0 max: 0.0)
		b: (b min: 1.0 max: 0.0)! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
                            colorFrom: parm
	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"

	| aColor firstParm |
	(parm is: #Color) ifTrue: [ ^ parm ].
	parm isSymbol ifTrue: [ ^ self perform: parm ].
	(parm isSequenceableCollection and: [ parm size > 0 ])
		ifTrue: [
			firstParm _ parm first.
			firstParm isNumber ifTrue: [
				^ self fromRgbTriplet: parm].
			aColor _ self colorFrom: firstParm.
			parm withIndexDo: [ :sym :ind |
				ind > 1 ifTrue: [
					aColor _ aColor perform: sym ]].
			^ aColor].
	^ parm

"
Color colorFrom: #(blue darker)
Color colorFrom: Color blue darker
Color colorFrom: #blue
Color colorFrom: #(0.0 0.0 1.0)
"! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 21:02:20'!
                  colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Colour transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Colour transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Colour r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Colour r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Colour r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
                            fromArray: colorDef

	| answer |
	colorDef size = 0 ifTrue: [^self transparent].
	colorDef size between: 3 and: 4 :: ifFalse: [self error: 'Undefined color definition'].
	answer _ self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3).
	^colorDef size = 3
		ifTrue: [answer]
		ifFalse: [answer alpha: (colorDef at: 4)]! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
     fromRgbTriplet: list
	^ self r: list first g: list second b: list last! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
       fromString: aString
	"For HTML color spec: #FFCCAA. Also support named colors.
	See http://www.w3schools.com/cssref/css_colors_legal.asp"
	"
	Color fromString: '#FFCCAA'.
	Color fromString: 'white'.
	Color fromString: 'orange'
	Color fromString: 'rgb(255,0,98)'
	"
	(aString size = 7 and: [ aString first = $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU _ aString asUppercase.
		red _ ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green _ ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue _ ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].

	(aString beginsWith: 'rgb')
		ifTrue: [|values r g b|
				values := (aString allButFirst: 4) allButLast findTokens: ','.
				r  := (values first includes: $%)
						ifTrue: [(values first asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values first asInteger min: 255 max: 0) / 255.0].
				g := (values second includes: $%)
						ifTrue: [(values second asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values second asInteger min: 255 max: 0) / 255.0].
				b := (values third includes: $%)
						ifTrue: [(values third asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values third asInteger min: 255 max: 0) / 255.0].
				^self r: r g: g b: b].

	^self exactColorNamed: aString! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:29'!
                    gray: brightness
	"Return a gray shade with the given brightness in the range [0.0..1.0]."

	^ self new
		setRed: brightness
		green: brightness
		blue: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:31'!
          h: hue s: saturation v: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
          h: h s: s v: v alpha: alpha

	^ (self h: h s: s v: v) alpha: alpha! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:34'!
           hue: hue chroma: chroma brightness: brightness
	^self new setHue: hue chroma: chroma brightness: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:37'!
  hue: hue chroma: chroma luminance: luma
	^self new setHue: hue chroma: chroma luminance: luma! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:39'!
                hue: hue saturation: saturation brightness: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:20'!
                      new
	^ self new: 3! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:41'!
                           r: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
r: r g: g b: b alpha: alpha

	^ (self r: r g: g b: b) alpha: alpha! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:43'!
           r: r g: g b: b range: range
	"Return a color with the given r, g, and b components specified as integers in the range [0..r]. This avoids the floating point arithmetic in the red:green:blue: message and is thus a bit faster for certain applications (such as computing a sequence of colors for a palette)."

	^ self new setRed: r green: g blue: b range: range! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
       random
	"Return a random color that isn't too dark or under-saturated.
		Display fill: (10@10 extent: 200@200) fillColor: Color random
	"

	^ Random withDefaultDo: [ :random |
		self random: random ]! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
      random2
	"Return a random color with a distribution that spans over all possible colors.
		Display fill: (10@10 extent: 200@200) fillColor: Color random2
	"

	^ Random withDefaultDo: [ :random |
		self random2: random ]! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:46'!
                  random2: aRandom
	"Return a random color with a distribution that spans over all possible colors."

	^ self new
		setRed: aRandom next
		green: aRandom next
		blue: aRandom next! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:48'!
                            random: aRandom
	"Return a random color that isn't too dark or under-saturated."

	^ self new
		setHue: (360.0 * aRandom next)
		saturation: (0.3 + (aRandom next * 0.7))
		brightness: (0.4 + (aRandom next * 0.6))! !
!Colour class methodsFor: 'class initialization' stamp: 'jmv 6/18/2017 20:10:01'!
                      initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollection new.
	grayIndices _ OrderedCollection new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation = 0.0 ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !
!Colour class methodsFor: 'class initialization' stamp: 'jmv 6/18/2017 20:59:48'!
                    initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Colour r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Colour r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Colour r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Colour r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Colour r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Colour r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Colour r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Colour r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Colour r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Colour r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Colour r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Colour r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Colour r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Colour r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Colour r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Colour r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Colour r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Colour r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:58:14'!
                              colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Colour r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: i g: i b: i range: 255)].
	^ f
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:29:30'!
                         experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Colour random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Colour new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Colour new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Colour new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Colour new setHue: h chroma: selectedChroma luminance: v.
"		color _ Colour new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:10:01'!
         hotColdShades: thisMany
	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "
	"Color showColors: (Color hotColdShades: 25)"

	| n s1 s2 s3 s4 s5 |
	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].
	n _ thisMany // 5.
	s1 _ self white mix: self yellow shades: (thisMany - (n*4)).
	s2 _ self yellow mix: self red shades: n+1.
	s2 _ s2 copyFrom: 2 to: n+1.
	s3 _ self red mix: self green darker shades: n+1.
	s3 _ s3 copyFrom: 2 to: n+1.
	s4 _ self green darker mix: self blue shades: n+1.
	s4 _ s4 copyFrom: 2 to: n+1.
	s5 _ self blue mix: self black shades: n+1.
	s5 _ s5 copyFrom: 2 to: n+1.
	^ s1, s2, s3, s4, s5
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:59:58'!
                      showColorCube
	"Show a 12x12x12 color cube."
	"Color showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Colour r: r g: g b: b range: 11)]]].
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:10:01'!
  showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w _ Display width // colorList size.
	r _ 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		Display fill: r fillColor: c.
		r _ r translatedBy: w@0].
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:00:03'!
            showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Colour h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Colour h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:10:01'!
                  showHuesInteractively
	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."
	"Color showHuesInteractively"

	| p s v |
	[Sensor isAnyButtonPressed] whileFalse: [
		p _ Sensor mousePoint.
		s _ p x asFloat / 300.0.
		v _ p y asFloat / 300.0.
		self showColors: (self wheel: 12 saturation: s brightness: v)].
	^ (s min: 1.0) @ (v min: 1.0)! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:01:15'!
   wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Colour wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:01:20'!
                    wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Colour h: 0.0 s: s v: v) wheel: thisMany
! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
              aqua

	^ self colorNamesDict at: #aqua! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            beige

	^ self colorNamesDict at: #beige! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          black

	^ self colorNamesDict at: #black! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          blue

	^ self colorNamesDict at: #blue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            brightGreen

	^ self colorNamesDict at: #brightGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              brown

	^ self colorNamesDict at: #brown! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          cyan

	^ self colorNamesDict at: #cyan! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            darkBlue

	^ self colorNamesDict at: #darkBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    darkGray

	^ self colorNamesDict at: #darkGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    darkGreen

	^ self colorNamesDict at: #darkGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  darkPink

	^ self colorNamesDict at: #darkPink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    darkPurple

	^ self colorNamesDict at: #darkPurple! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
forestGreen

	^ self colorNamesDict at: #forestGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              gray

	^ self colorNamesDict at: #gray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            green

	^ self colorNamesDict at: #green! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          grey

	^ self colorNamesDict at: #grey! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            hotPink

	^ self colorNamesDict at: #hotPink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      indigo

	^ self colorNamesDict at: #indigo! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        lavender

	^ self colorNamesDict at: #lavender! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    lightBlue

	^ self colorNamesDict at: #lightBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightBrown

	^ self colorNamesDict at: #lightBrown! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
lightCyan

	^ self colorNamesDict at: #lightCyan! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightGray

	^ self colorNamesDict at: #lightGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightGreen

	^ self colorNamesDict at: #lightGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
lightMagenta

	^ self colorNamesDict at: #lightMagenta! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                            lightOrange

	^ self colorNamesDict at: #lightOrange! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              lightPink

	^ self colorNamesDict at: #lightPink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightPurple

	^ self colorNamesDict at: #lightPurple! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              lightRed

	^ self colorNamesDict at: #lightRed! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    lightYellow

	^ self colorNamesDict at: #lightYellow! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              lilac

	^ self colorNamesDict at: #lilac! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          lime

	^ self colorNamesDict at: #lime! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            limeGreen

	^ self colorNamesDict at: #limeGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  magenta

	^ self colorNamesDict at: #magenta! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      maroon

	^ self colorNamesDict at: #maroon! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        mauve

	^ self colorNamesDict at: #mauve! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          mustard

	^ self colorNamesDict at: #mustard! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      navyBlue

	^ self colorNamesDict at: #navyBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    olive

	^ self colorNamesDict at: #olive! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          oliveGreen

	^ self colorNamesDict at: #oliveGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
orange

	^ self colorNamesDict at: #orange! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        paleGreen

	^ self colorNamesDict at: #paleGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  peach

	^ self colorNamesDict at: #peach! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          periwinkle

	^ self colorNamesDict at: #periwinkle! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
pink

	^ self colorNamesDict at: #pink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            purple

	^ self colorNamesDict at: #purple! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        red

	^ self colorNamesDict at: #red! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
              royalBlue

	^ self colorNamesDict at: #royalBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  salmon

	^ self colorNamesDict at: #salmon! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        seaGreen

	^ self colorNamesDict at: #seaGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    skyBlue

	^ self colorNamesDict at: #skyBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      tan

	^ self colorNamesDict at: #tan! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
              teal

	^ self colorNamesDict at: #teal! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            transparent

	^ self colorNamesDict at: #transparent! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              turquoise

	^ self colorNamesDict at: #turquoise! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  veryDarkGray

	^ self colorNamesDict at: #veryDarkGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                            veryLightGray

	^ self colorNamesDict at: #veryLightGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                          veryVeryDarkGray

	^ self colorNamesDict at: #veryVeryDarkGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                    veryVeryLightGray

	^ self colorNamesDict at: #veryVeryLightGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                  violet

	^ self colorNamesDict at: #violet! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        white

	^ self colorNamesDict at: #white! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          yellow

	^ self colorNamesDict at: #yellow! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
           cachedColormapForGrayFrom: sourceDepth
	"Return a cached colormap for mapping from the given depth to the 8bpp grays. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex map |
	ToGrayColormaps ifNil: [
		ToGrayColormaps _ Array new: 5].
	
	srcIndex _ sourceDepth highBit min: 5.

	(ToGrayColormaps at: srcIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapForGray8bppFrom: sourceDepth.
	ToGrayColormaps at: srcIndex put: map.
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
                           cachedColormapFrom: sourceDepth to: destDepth
	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex dstIndex map |
	CachedColormaps
		ifNil: [CachedColormaps _ (1 to: 5) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit min: 5.
	dstIndex _ destDepth highBit.

	((CachedColormaps at: srcIndex) at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFrom: sourceDepth to: destDepth.
	(CachedColormaps at: srcIndex) at: dstIndex put: map.
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
 cachedColormapFromGrayTo: destDepth
	"Return a cached colormap for mapping from 8bpp grays to the given depth. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| dstIndex map |
	FromGrayColormaps
		ifNil: [FromGrayColormaps _ Array new: 6 ].

	dstIndex _ destDepth highBit.

	(FromGrayColormaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFromGray8bppForDepth: destDepth.
	FromGrayColormaps at: dstIndex put: map.
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:57:57'!
 colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Colour cachedColormapFrom: sourceDepth to: destDepth
! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
                              computeColorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color.
		Assumed not to include subpixelAA"
		^ self computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	] ifFalse: [
		"source is 16-bit or 32-bit RGB.
		Might include subpixelAA"
		^ self computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	]! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
      computeColormapForGray8bppFrom: sourceDepth
	"Compute a colorMap for translatingfrom the given depth to the 8bpp grays"
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [ :c | (c luminance * 255) rounded].
		map _ map as: Bitmap.
		^ map
		]
	ifFalse: [
		^ self computeRGBColormapForGray8 ]! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
                          computeColormapFrom: sourceDepth to: destDepth
	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map bitsPerColor |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [:c | c pixelValueForDepth: destDepth].
		map _ map as: Bitmap.
	] ifFalse: [
		"source is 16-bit or 32-bit RGB"
		destDepth > 8
			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
			ifFalse: [bitsPerColor _ 4].
		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].

	"Note: zero is transparent except when source depth is one-bit deep"
	sourceDepth > 1 ifTrue: [map at: 1 put: 0].
	^ map
! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:29'!
                           computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Colour gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:33'!
                            computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Colour white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:41'!
                           computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Colour
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: Colour white ]]]
			ifNil: [ Colour r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:48'!
                        computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Colour transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:56'!
                        computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Colour class methodsFor: 'other' stamp: 'jmv 6/18/2017 20:10:01'!
                             maskingMap: depth
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."
	"Warning: The behavior is incorrect if depth = 32.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| sizeNeeded |
	depth <= 8
		ifTrue: [sizeNeeded _ 1 bitShift: depth]
		ifFalse: [sizeNeeded _ 4096].

	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:
		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.
		MaskingMap at: 1 put: 0.  "transparent"].

	^ MaskingMap
! !
!Colour class methodsFor: 'color from user' stamp: 'jmv 6/18/2017 20:58:07'!
                    colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Colour class methodsFor: 'color from user' stamp: 'jmv 6/18/2017 20:58:24'!
      colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:10:01'!
                             colorNames
	"Answer the current dictionary of  name->color associations."

	^self colorNamesDict keys! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:59:02'!
        defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Colour r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Colour r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Colour r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Colour r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Colour r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:59:12'!
                    doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Colour colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:10:01'!
         exactColorNamed: aColorName

	"Answer color matching name or nil 
	from my ColorName->Color Dictionary"
	
	^ self colorNamesDict at: (aColorName asSymbol) ifAbsent: [nil]! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:59:55'!
   setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Colour defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 21:01:08'!
            traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Colour r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Colour r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Colour r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Colour r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Colour r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Colour r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Colour r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Colour r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Colour r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Colour r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Colour r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Colour r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Colour r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Colour r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Colour r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Colour r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Colour r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Colour r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Colour r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Colour r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Colour r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Colour r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Colour r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Colour r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Colour r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColour r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 21:01:38'!
                 xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Colour fromString: '#ffd1df') ;
	at: #mustard put: (Colour fromString: '#ceb301') ;
	at: #indigo put: (Colour fromString: '#380282') ;
	at: #lime put: (Colour fromString: '#aaff32') ;
	at: #seaGreen put: (Colour fromString: '#53fca1') ;
	at: #periwinkle put: (Colour fromString: '#8e82fe') ;
	at: #darkPink put: (Colour fromString: '#cb416b') ;
	at: #oliveGreen put: (Colour fromString: '#677a04') ;
	at: #peach put: (Colour fromString: '#ffb07c') ;
	at: #paleGreen put: (Colour fromString: '#c7fdb5') ;
	at: #lightBrown put: (Colour fromString: '#ad8150') ;
	at: #hotPink put: (Colour fromString: '#ff028d') ;
	at: #black put: (Colour fromString: '#000000') ;
	at: #lilac put: (Colour fromString: '#cea2fd') ;
	at: #navyBlue put: (Colour fromString: '#001146') ;
	at: #royalBlue put: (Colour fromString: '#0504aa') ;
	at: #beige put: (Colour fromString: '#e6daa6') ;
	at: #salmon put: (Colour fromString: '#ff796c') ;
	at: #olive put: (Colour fromString: '#6e750e') ;
	at: #maroon put: (Colour fromString: '#650021') ;
	at: #brightGreen put: (Colour fromString: '#01ff07') ;
	at: #darkPurple put: (Colour fromString: '#35063e') ;
	at: #mauve put: (Colour fromString: '#ae7181') ;
	at: #forestGreen put: (Colour fromString: '#06470c') ;
	at: #aqua put: (Colour fromString: '#13eac9') ;
	at: #cyan put: (Colour fromString: '#00ffff') ;
	at: #tan put: (Colour fromString: '#d1b26f') ;
	at: #darkBlue put: (Colour fromString: '#00035b') ;
	at: #lavender put: (Colour fromString: '#c79fef') ;
	at: #turquoise put: (Colour fromString: '#06c2ac') ;
	at: #darkGreen put: (Colour fromString: '#033500') ;
	at: #violet put: (Colour fromString: '#9a0eea') ;
	at: #lightPurple put: (Colour fromString: '#bf77f6') ;
	at: #limeGreen put: (Colour fromString: '#89fe05') ;
	at: #grey put: (Colour fromString: '#929591') ;
	at: #skyBlue put: (Colour fromString: '#75bbfd') ;
	at: #yellow put: (Colour fromString: '#ffff14') ;
	at: #magenta put: (Colour fromString: '#c20078') ;
	at: #lightGreen put: (Colour fromString: '#96f97b') ;
	at: #orange put: (Colour fromString: '#f97306') ;
	at: #teal put: (Colour fromString: '#029386') ;
	at: #lightBlue put: (Colour fromString: '#95d0fc') ;
	at: #red put: (Colour fromString: '#e50000') ;
	at: #brown put: (Colour fromString: '#653700') ;
	at: #pink put: (Colour fromString: '#ff81c0') ;
	at: #blue put: (Colour fromString: '#0343df') ;
	at: #green put: (Colour fromString: '#15b01a') ;
	at: #purple put: (Colour fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                   blueColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueColorDict explore.
"
	^self blueColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  blueColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlue)
				or: [assoc key asString asLowercase includesSubString: 'blue'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                blueGreenColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueGreenColorDict explore.
"
	^self blueGreenColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                   blueGreenColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlueGreen)
				or: [assoc key asString asLowercase includesSubString: 'bluegreen'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
 brightColorDict
	"Answer a dictionary of named colors considered Bright"
"
	Color brightColorDict explore.
"
	^self brightColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          brightColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isBright) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                  brownColorDict
	"Answer a dictionary of named colors considered Brown"
"
	Color brownColorDict explore.
"
	^self brownColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              brownColorDict: aColorDict
	"Answer a dictionary of named colors considered Brown"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBrown)
				or: [assoc key asString asLowercase includesSubString: 'brown'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
            darkColorDict
	"Answer a dictionary of named colors considered Dark"
"
	Color darkColorDict explore.
"
	^self darkColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  darkColorDict: aColorDict
	"Answer a dictionary of named colors considered Dark"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isDark) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                        grayColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                greenColorDict
	"Answer a dictionary of named colors considered Green"
"
	Color greenColorDict explore.
"
	^self greenColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              greenColorDict: aColorDict
	"Answer a dictionary of named colors considered Green"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGreen)
				or: [assoc key asString asLowercase includesSubString: 'green'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
            greyColorDict
	"Answer a dictionary of named colors considered Grey"
"
	Color greyColorDict explore.
"
	^self greyColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  greyColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                lightColorDict
	"Answer a dictionary of named colors considered light"
"
	Color lightColorDict explore.
"
	^self lightColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              lightColorDict: aColorDict
	"Answer a dictionary of named colors considered Liight"

	^self brightColorDict: aColorDict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              orangeColorDict
	"Answer a dictionary of named colors considered Orange"
"
	Color orangeColorDict explore.
"
	^self orangeColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          orangeColorDict: aColorDict
	"Answer a dictionary of named colors considered Orange"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isOrange)
				or: [assoc key asString asLowercase includesSubString: 'orange'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
        pastelColorDict
	"Answer a dictionary of named colors considered Pastel"
"
	Color pastelColorDict explore.
"
	^self pastelColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          pastelColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isPastel) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                  pinkColorDict
	"Answer a dictionary of named colors considered Pink"
"
	Color pinkColorDict explore.
"
	^self pinkColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  pinkColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isPink)
				or: [assoc key asString asLowercase includesSubString: 'pink'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                purpleColorDict
	"Answer a dictionary of named colors considered Purple"
"
	Color purpleColorDict explore.
"
	^self purpleColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          purpleColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc key asString asLowercase includesSubString: 'purple')
				or: [assoc key asString asLowercase includesSubString: 'violet'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
    redColorDict
	"Answer a dictionary of named colors considered Red"
"
	Color redColorDict explore.
"
	^self redColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
      redColorDict: aColorDict
	"Answer a dictionary of named colors considered Red"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isRed)
				or: [assoc key asString asLowercase includesSubString: 'red'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                    saturatedColorDict
	"Answer a dictionary of named colors considered Saturated"
"
	Color saturatedColorDict explore.
"
	^self saturatedColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
              saturatedColorDict: aColorDict
	"Answer a dictionary of named colors considered Saturated"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isSaturated) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
         yellowColorDict
	"Answer a dictionary of named colors considered Yellow"
"
	Color yellowColorDict explore.
"
	^self yellowColorDict: (self colorNamesDict)! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                           yellowColorDict: aColorDict
	"Answer a dictionary of named colors considered Yellow"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isYellow)
				or: [assoc key asString asLowercase includesSubString: 'yellow'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'color space conversions' stamp: 'jmv 6/18/2017 20:10:01'!
                          applySimpleGamma: gamma to: value
	"Encode / decode Gamma. Typical gamma are 0.4545 ( = 1.0 / 2.2, for encoding) and 2.2 (for decoding)
	In a non gamma encoded image, the pixel values are proportional to luminance, i.e. the actual light intensity, the photon count.
	In an gamma encoded image, the pixel value is close to the average perceived brightness, or 'lightness'. This optimizes the use of available bits in digital images, and dynamic range in analog images and film. This is like the 'luma' signal in video.

	Usually:
		- Images stored in file formats such as jpg, png, tiff and bmp are gamma encoded
				(unless they are actually raw images).
		- Images sent to a framebuffer (video memory) should be gamma encoded.
		- Raw images from sensors are not gamma encoded.

		- Image processing algorithms that simulate the real world, or are applied to real world data should work on unencoded (linear) images.
				This includes filtering, resizing, blending, and most operations done on images.
				This means that if the images come from jpg photos from a camera, they should be gamma decoded.
		- Image processing algorithms that works on human perception should work on gamma encoded images.
				This includes histograms, histogram equalization, bit allocation (i.e. quantization), compression, etc.
				This also includes detecting objects like a human would do
				

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html

	Mostly for documentation.
	value must be in [0.0 .. 1.0].
	Note that the sRGB standard specifies a function that is close to this, but slightly different.
	See #linearTosRGBGamma: and #sRGBGammaToLinear:"

	^ value raisedTo: gamma! !
!Colour class methodsFor: 'color space conversions' stamp: 'jmv 6/18/2017 20:10:01'!
        linearTosRGBGamma: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from linearSpace to gammaSpace, i.e. it 'encodes' with gamma.
	This is the operation done when producing an 8bit Form for displaying, or for saving on a JPG, PNG, etc; if source data is in linear space (for example, from raw data a sensor image, or data that was converted previously to linear space for proper image processing).
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	
	| r v |
	r _ Random new.
	1000 timesRepeat: [
		v _ r next.
		self assert: ((Color sRGBGammaToLinear: (Color linearTosRGBGamma: v)) closeTo: v) ]

	| r |
	r _ 10@10 extent: 600@400.
	Display fill: r fillColor: Color white.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color linearTosRGBGamma: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 1/2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color sRGBGammaToLinear: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	"

	^ value <= 0.00313066844250063
		ifTrue: [ value * 12.92 ]
		ifFalse: [ (value raisedTo: 1.0/2.4) * 1.055 - 0.055 ]! !
!Colour class methodsFor: 'color space conversions' stamp: 'jmv 6/18/2017 20:10:01'!
            sRGBGammaToLinear: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from gammaSpace to linearSpace, i.e. it 'decodes'.
	This is the operation done by display screens. It is also needed to convert 8bit Forms (from a frameBuffer, or from PNG, JPG, etc.) to linear space for proper image processing.
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	"

	^ value <= 0.0404482362771082
		ifTrue: [ value / 12.92 ]
		ifFalse: [ value + 0.055 / 1.055 raisedTo: 2.4 ]! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
                        colorNamesDict
	"Answer the current dictionary of  name->color associations."
"
	Color colorNamesDict explore.
"
	ColorNamesDict ifNil: [
		self setColorNamesDict: self defaultColorNamesDictionary ].
	^ColorNamesDict! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
                   grayToIndexMap
	"
	Color grayToIndexMap explore.
	"
	GrayToIndexMap ifNil: [
		self initializeGrayToIndexMap ].
	^GrayToIndexMap! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
           indexedColors
	"
	Color indexedColors explore.
	"
	IndexedColors ifNil: [
		self initializeIndexedColors ].
	^IndexedColors! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
                releaseClassCachedState
	"
	Color releaseClassCachedState
	"
	CachedColormaps _ nil. 		"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	ColorNamesDict _ nil.
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !
!TranslucentColour methodsFor: 'accessing' stamp: 'jmv 6/18/2017 20:41:17'!
                        alpha
	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."

	^ self at: 4! !
!TranslucentColour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:08'!
    storeArrayValuesOn: aStream

	self isTransparent ifTrue: [
		^ aStream space].
	super storeArrayValuesOn: aStream.
	aStream space.
	self alpha printOn: aStream fractionDigits: 3! !
!TranslucentColour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:08'!
storeOn: aStream

	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].
	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' alpha: '.
	self alpha printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ')'! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:55:03'!
                    alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifTrue: [
		^ Colour new
			setRed: self red
			green: self green
			blue: self blue].
	^ super alpha: alphaValue! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:08'!
            asNontranslucentColor
	^ self alpha: 1.0! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:08'!
      bitPatternForDepth: depth
	"Return an appropriate bit pattern. This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."

	self isTransparent ifTrue: [
		^ Bitmap with: 0].
	^ super bitPatternForDepth: depth! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:47'!
              pixelValueForDepth: d
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."
	| basicPixelWord |
	"In 32bpp, if alpha = 0, ignore any color components, and answer R=0, G=0, B=0, Alpha=0.
	In depths > 8 and < 32, pixelValue zero is the special value used by BitBlt to denote transparent."
	self isTransparent ifTrue: [
		^ 0].
	basicPixelWord _ super pixelValueForDepth: d.
	^d < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:50'!
                           pixelWordForDepth: depth
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."

	| basicPixelWord |
	self isTransparent ifTrue: [^ 0].
	basicPixelWord _ super pixelWordForDepth: depth.
	^depth < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:42:05'!
                      setRed: r green: g blue: b alpha: alphaValue

	self basicSetRed: r green: g blue: b.
	self at: 4 put: alphaValue! !
!TranslucentColour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:26'!
  isOpaque

	^self alpha = 1.0! !
!TranslucentColour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:54'!
                      isTransparent
	^ self alpha = 0.0! !
!TranslucentColour methodsFor: 'please remove' stamp: 'jmv 6/18/2017 21:27:51'!
           setRed: r green: g blue: b alpha: alphaValue colorSpace: aSymbol
	^ self setRed: r green: g blue: b alpha: alphaValue! !
!TranslucentColour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:35'!
             new
	^ self new: 4! !
!TranslucentColour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:57:08'!
                r: r g: g b: b alpha: alphaValue
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b
		alpha: alphaValue! !
!FloatArray methodsFor: 'comparing' stamp: 'jmv 6/18/2017 20:25:14' prior: 16846542!
                    = another 
	self == another ifTrue: [ ^ true ].
	self class == another class ifFalse: [ ^ false ].
	^self primitiveEqual: another! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3105-FloatArrayColour-JuanVuletich-2017Jun19-09h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:11:02 am'!
!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04' prior: 16859466!
   asColorOfDepth: d
	"Return a color value representing the receiver as color of the given depth"
	^Colour colorFromPixelValue: self depth: d! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 9/2/2016 11:08:09' prior: 16856307!
                             kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char _ nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char _ self keyboard.
		Display fill: (5@5 extent: 400@20) fillColor: Colour white.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char numericValue;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])
		displayAt: 10 @ 10 ].! !
!String methodsFor: 'displaying' stamp: 'jmv 5/12/2015 15:52' prior: 16917036!
                             displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: Colour black
	"
	'Display' displayOn: Display at: 10@10
	"! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/25/2016 15:31' prior: 16922270!
                  reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Colour shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 7/28/2015 08:26' prior: 16938828!
                       endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			0@0 + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (4@4 + frame topLeft extent: Display extent)
		color: Colour black
		selectionColor: Colour blue.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 16938904!
           black
	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].
	^ Colour black! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 16938910!
 white
	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].
	^ Colour white! !
!DataStream class methodsFor: 'as yet unclassified' stamp: '' prior: 16827931!
           example
    "An example and test of DataStream/ReferenceStream.
     11/19/92 jhm: Use self testWith:."
    "DataStream example"
    "ReferenceStream example"
    | input sharedPoint |

    "Construct the test data."
    input _ Array new: 9.
    input at: 1 put: nil.
    input at: 2 put: true.
    input at: 3 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 3) fillWithColor: Colour lightBlue.
    input at: 4 put: #(3 3.0 'three').
    input at: 5 put: false.
    input at: 6 put: 1024 @ -2048.
    input at: 7 put: #x.
    input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
    input at: 9 put: sharedPoint.

    "Write it out, read it back, and return it for inspection."
    ^ self testWith: input! !
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: '' prior: 16900040!
                              example2
"Here is the way to use DataStream and ReferenceStream:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	rr nextPut: <your object>.
	rr close.

To get it back:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	<your object> _ rr next.
	rr close.
"
"An example and test of DataStream/ReferenceStream.
	 11/19/92 jhm: Use self testWith:."
	"ReferenceStream example2"
	| input sharedPoint |

	"Construct the test data."
	input _ Array new: 9.
	input at: 1 put: nil.
	input at: 2 put: true.
	input at: 3 put: false.
	input at: 4 put: #(-4 -4.0 'four' four).
	input at: 5 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 5) fillWithColor: Colour lightOrange.
	input at: 6 put: 1024 @ -2048.
	input at: 7 put: input. "a cycle"
	input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
	input at: 9 put: sharedPoint.

	"Write it out, read it back, and return it for inspection."
	^ self testWith: input
! !
!TextEditor methodsFor: 'attributes' stamp: 'jmv 6/18/2017 21:32:55' prior: 16931569!
                            offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel _ self selection.
	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index _ (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array with: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute _ TextColor color: (Colour perform: (colors at: index)) ]
		ifFalse: [
			index _ index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute _ self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	^ true.! !
!TextAction class methodsFor: 'as yet unclassified' stamp: 'jmv 4/19/2015 09:38' prior: 16930008!
                               textActionColor
	^Colour r: 0.4 g: 0 b: 1.0! !
!TextColor methodsFor: 'testing' stamp: 'jmv 1/21/2011 11:33' prior: 16930362!
  isSet
	"Do not include Colour black, as it is the default color."
	^color ~= Colour black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930372!
                               black
	^ self new color: Colour black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930375!
                   blue
	^ self new color: Colour blue! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930378!
                     cyan
	^ self new color: Colour cyan! !
!TextColor class methodsFor: 'constants' stamp: 'ajh 9/10/2002 02:26' prior: 16930382!
  gray
	^ self new color: Colour gray! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930385!
                     green
	^ self new color: Colour green! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930388!
                   magenta
	^ self new color: Colour magenta! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930391!
               red
	^ self new color: Colour red! !
!TextColor class methodsFor: 'constants' stamp: 'sma 3/24/2000 10:50' prior: 16930395!
    white 
	^ self new color: Colour white! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930398!
                  yellow
	^ self new color: Colour yellow! !
!Preferences class methodsFor: 'halos' stamp: 'jmv 6/18/2017 21:33:44' prior: 16893209!
                             installHaloSpecsFromArray: anArray

	| aColour |
	^ self parameters at: #HaloSpecs put: (anArray collect: [ :each |
				aColour _ Colour.
				each fourth do: [ :sel | aColour _ aColour perform: sel].
				HaloSpec new 
					horizontalPlacement: each second
					verticalPlacement: each third 
					color: aColour
					iconSymbol: each fifth
					addHandleSelector: each first
					hoverHelp: each sixth])! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:45:55' prior: 16938476!
             displayOn: aForm in: aRectangle
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f canvas innerR |
	aForm fill: aRectangle fillColor: Colour white.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	fh _ font height.
	count _ innerR height // fh-1.
	x _ innerR left.
	y _ innerR top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	[
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: Colour veryDarkGray.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: Colour veryDarkGray! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:53:35' prior: 16938512!
                    displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas r innerR |
	innerR _ bounds insetBy: self padding.
	lastDisplayPosition < innerR right ifTrue: [
		font _ AbstractFont default.
		fh _ font height.
		count _ innerR height // fh-1.
		x _ innerR left.
		string _ unfinishedEntry contents.
		y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerR top.
		canvas _ aForm getCanvas.
		r _ innerR left: lastDisplayPosition.
		canvas newClipRect: r.
		(canvas drawString: string at: x@y font: font color: Colour veryDarkGray) ifNotNil: [ :lastPoint |
			lastDisplayPosition _ lastPoint x.
			^r ]].
	^nil! !
!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40' prior: 16846838!
        dominantColor
	| tally max maxi |
	self depth > 16 ifTrue:
		[^(self asFormOfDepth: 16) dominantColor].
	tally _ self tallyPixelValues.
	max _ maxi _ 0.
	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].
	^ Colour colorFromPixelValue: maxi - 1 depth: self depth! !
!Form methodsFor: 'bordering' stamp: 'jmv 1/22/2015 10:22' prior: 16847019!
                           border: aRectangle width: borderWidth 
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses black for 
	drawing the border."

	self border: aRectangle width: borderWidth fillColor: Colour black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847087!
       fillBlack
	"Set all bits in the receiver to black (ones)."

	self fill: self boundingBox fillColor: Colour black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847093!
 fillBlack: aRectangle 
	"Set all bits in the receiver's area defined by aRectangle to black (ones)."

	self fill: aRectangle rule: Form over fillColor: Colour black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847109!
             fillGray
	"Set all bits in the receiver to gray."

	self fill: self boundingBox fillColor: Colour gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847115!
           fillGray: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to the gray mask."

	self fill: aRectangle rule: Form over fillColor: Colour gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847146!
               fillWhite
	"Set all bits in the form to white."

	self fill: self boundingBox fillColor: Colour white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847152!
            fillWhite: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to white."

	self fill: aRectangle rule: Form over fillColor: Colour white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847165!
                     reverse
	"Change all the bits in the receiver that are white to black, and the ones 
	that are black to white.
	Display reverse
	"

	self fill: self boundingBox rule: Form reverse fillColor: Colour white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847174!
      reverse: aRectangle
	"Change all the bits in the receiver's area that intersects with aRectangle 
	that are white to black, and the ones that are black to white."

	self fill: aRectangle rule: Form reverse fillColor: Colour white! !
!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:42' prior: 16847212!
        colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	self depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"
	^ Colour colorMapIfNeededFrom: self depth to: destDepth
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 5/12/2016 13:53' prior: 16847223!
                          colormapIfNeededForGray8bpp
	"Return a colormap for displaying the receiver at the given depth.
	Note: Uses 5 bits per color component. 32bit Forms will lose information!!"

	^ Colour cachedColormapForGrayFrom: self depth! !
!Form methodsFor: 'color mapping' stamp: 'jmv 6/18/2017 21:31:52' prior: 16847240!
            mapColor: oldColour to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Colour cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColour indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: 0@0;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 1/31/2011 09:21' prior: 16847262!
          maskingMap
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Colour maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."
	^Colour maskingMap: self depth! !
!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28' prior: 16847299!
             as8BitColorForm
	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."

	| f map |
	f _ ColorForm extent: self extent depth: 8.
	self displayOn: f at: self offset negated.
	map _ Colour indexedColors copy.
	map at: 1 put: Colour transparent.
	f colors: map.
	f offset: self offset.
	^ f
! !
!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:42' prior: 16848158!
                             colorAt: aPoint
	"Return the color in the pixel at the given point.  "

	^ Colour 
		colorFromPixelValue: (self pixelValueAt: aPoint)
		depth: self depth
! !
!Form methodsFor: 'pixel access' stamp: 'jmv 11/4/2015 12:40' prior: 16848175!
                   colorInterpolatedAt: aPoint
	"Evaluate a bilinear (i.e. cheap) interpolation
	Like OpenCV's CV_INTER_LINEAR
	Answer Colour transparent if outside image bounds.
	Copied almost verbatim from FloatImage.
	Answer Colors with float components. Will be rounded to be stored in, for example, a 32-bit Form."

	| x y w interpolated xWeight1 xWeight0 yWeight1 yWeight0 xIndex0 xIndex1 yIndex0 yIndex1 |
	x _ aPoint x.
	y _ aPoint y.
	x < 0.0 ifTrue: [ ^Colour transparent ].
	xIndex0 _ x truncated. 		"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	xIndex0 > (width-1) ifTrue: [ ^Colour transparent ].
	(xIndex0 = (width-1) and: [ x > (width-1) ]) ifTrue: [ ^Colour transparent ].
	xIndex1 _ xIndex0 = (width-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ xIndex0 + 1 ]
		ifTrue: [ xIndex0 ].

	y < 0.0 ifTrue: [ ^Colour transparent ].
	yIndex0 _ y truncated.			"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	yIndex0 > (height-1) ifTrue: [ ^Colour transparent ].
	(yIndex0 = (height-1) and: [ y > (height-1) ]) ifTrue: [ ^Colour transparent ].
	yIndex1 _ yIndex0 = (height-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ yIndex0 + 1 ]
		ifTrue: [ yIndex0 ].

	xWeight1 _ x - xIndex0.
	xWeight0 _ 1.0 - xWeight1.

	yWeight1 _ y - yIndex0.
	yWeight0 _ 1.0 - yWeight1.

	"/* perform interpolation */"
	w _ ((self colorAt: xIndex0 @ yIndex0) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex0) * xWeight1).
	interpolated _ w * yWeight0.

	w _ ((self colorAt: xIndex0 @ yIndex1) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex1) * xWeight1).
	interpolated _ w * yWeight1 + interpolated.

	^interpolated! !
!Form methodsFor: 'transitions' stamp: 'jmv 7/28/2015 08:32' prior: 16848519!
    pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Colour black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 9/23/2012 21:44' prior: 16848886!
             dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).	
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Colour black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'instance creation' stamp: 'pb 5/4/2016 17:43' prior: 16849005!
                       fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb _ GrafPort toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect _ aPoint extent: diameter.
	bb fillOval: rect.
	p _ (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: (Colour white alpha: 0.3).
		d _ i * diameter // 10.
		rect _ Rectangle
			center: p
			extent: d.
		bb fillOval: rect ].
	DisplayScreen screenUpdateRequired: nil.
"
	Form fakeSphereAt: 50@50 diameter: 30 color:  (Colour red alpha: 0.5)
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 3/20/2013 22:36' prior: 16849178!
                          toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Colour red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: -40@-40].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:37' prior: 16849256!
  bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:47' prior: 16849283!
                               bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:38' prior: 16849314!
             bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomRight corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:41' prior: 16849341!
         bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:34' prior: 16849371!
                       topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:36' prior: 16849397!
                           topRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topRight corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (x @ (w - y - 1)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45' prior: 16818750!
                  colors: colorList
	"Set my color palette to the given collection."

	| colorArray colorCount newColors |
	colorList ifNil: [
		colors _ cachedDepth _ cachedColormap _ nil.
		^ self].

	colorArray _ colorList asArray.
	colorCount _ colorArray size.
	newColors _ Array new: (1 bitShift: self depth).
	1 to: newColors size do: [:i |
		i <= colorCount
			ifTrue: [newColors at: i put: (colorArray at: i)]
			ifFalse: [newColors at: i put: Colour transparent]].

	colors _ newColors.
	cachedDepth _ nil.
	cachedColormap _ nil.
! !
!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20' prior: 16818824!
                        asGrayScale
	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"
	^ self copy colors:
		(colors collect:
			[:c | c isTransparent ifTrue: [c]
						ifFalse: [Colour gray: c luminance]])! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 3/1/2010 09:41' prior: 16818834!
  colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	| newMap |
	colors ifNil: [
		"use the standard colormap"
		^ Colour colorMapIfNeededFrom: self depth to: destDepth].

	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 
		ifTrue: [^ cachedColormap].
	newMap _ Bitmap new: colors size.
	1 to: colors size do: [:i |
		newMap
			at: i
			put: ((colors at: i) pixelValueForDepth: destDepth)].

	cachedDepth _ destDepth.
	^ cachedColormap _ newMap.
! !
!ColorForm methodsFor: 'private' stamp: 'ar 5/17/2001 15:44' prior: 16818940!
           ensureColorArrayExists
	"Return my color palette."

	colors ifNil: [
		self depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].
		self colors: (Colour indexedColors copyFrom: 1 to: (1 bitShift: self depth))].
! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 4/10/2015 23:20' prior: 16819047!
             mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: 0@0
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Colour indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Colour white ifTrue: [Colour transparent] ifFalse: [c]].
	f colors: map.
	^ f
! !
!ColorForm class methodsFor: 'instance creation' stamp: 'jmv 5/4/2016 16:31' prior: 16819074!
                               grayScaleAndTransparentExtent: aPoint
"Native depth"
	"Answer a ColorForm for storing 8bpp gray scale. (do not include any slot for transparent)"

	| grays result |
	result _ self extent: aPoint depth: (Smalltalk isLittleEndian ifTrue: [ -8 ] ifFalse: [ 8 ]).
	grays _ (0 to: 255) collect: [ :brightness | Colour gray: brightness asFloat / 255.0].
	grays at: 1 put: Colour transparent.
	result colors: grays.
	^result! !
!Cursor methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 16825855!
            asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: self fillColor: Colour black at: offset negated.
	^ form offset: offset! !
!CursorWithMask methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 16826695!
           asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: maskForm fillColor: Colour white.
	form fillShape: self fillColor: Colour black at: offset negated.
	^ form offset: offset! !
!GrayForm methodsFor: 'pixel accessing' stamp: 'jmv 5/11/2016 19:57' prior: 16850335!
                         grayAt: aPoint
	"Return the color of the pixel at aPoint."

	^Colour gray: (self pixelValueAt: aPoint) asFloat / 255.0! !
!GrayForm methodsFor: 'color manipulation' stamp: 'jmv 5/12/2016 15:04' prior: 16850359!
             colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	^ Colour cachedColormapFromGrayTo: destDepth! !
!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57' prior: 16781762!
                 readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount := (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ Array with: Colour white with: Colour black].
		"default gray-scale color map"
		maxLevel := (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Colour gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors := Array new: colorCount.
	1 to: colorCount do: [:i |
		b := ccStream next.
		g := ccStream next.
		r := ccStream next.
		ccStream next. "skip reserved"
		colors at: i put: (Colour r: r g: g b: b range: 255)].
	^ colors
! !
!BitBlt methodsFor: 'accessing' stamp: 'jmv 3/20/2013 00:50' prior: 16785567!
           fillColor
	"Return the current fill color as a Color.  
	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."

	halftoneForm ifNil: [^ Colour black].
	^ Colour colorFromPixelValue: halftoneForm first depth: destForm depth! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 7/27/2015 17:07' prior: 16786237!
        alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Colour cachedColormapFrom: Display depth to: 32.
		map32toD _ Colour cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Colour red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.
	DisplayScreen screenUpdateRequired: nil.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Colour red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor isMouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor isMouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				DisplayScreen screenUpdateRequired: updateRect.
				prevP _ p]]]! !
!WarpBlt methodsFor: 'setup' stamp: 'mtf 8/14/2009 18:21' prior: 16942977!
              cellSize: s
	"Set the number of samples used for averaging"
	cellSize := s.
	cellSize = 1 ifTrue: [^ self].
	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the
	destination depth. Note that we need to install the 32->32 color map explicitly because
	the VM will substitute a colorMap derived from sourceForm->destForm mapping which
	is just plain wrong for <32 source and 32bit dest depth"
	(destForm depth = 32 and: [sourceForm notNil] and: [sourceForm depth < 32])
		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]
		ifFalse:[colorMap := Colour colorMapIfNeededFrom: 32 to: destForm depth].
! !
!GrafPort methodsFor: 'text' stamp: 'jmv 6/1/2015 13:28' prior: 16850127!
          displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font color: foregroundColor
	"If required, do a second pass with new rule and colorMap.
	Answer last affected pixel position
	Answer nil if nothing was done
	"

	| answer prevRule secondPassMap sourceDepth destDepth |

	"Slight optimization when there's nothing to do."
	clipHeight = 0 ifTrue: [^nil].
	clipWidth = 0 ifTrue: [^nil].

	self installStrikeFont: font foregroundColor: (foregroundColor alpha: 1).

	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.
	If not, do it simply"
	combinationRule = 37 "rgbMul" ifFalse: [
		^self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font ].
	
	"We need to do a second pass. The colormap set is for use in the second pass."
	secondPassMap _ colorMap.
	sourceDepth _ sourceForm depth.
	destDepth _ destForm depth.
	colorMap _ sourceDepth ~= destDepth
		ifTrue: [ Colour cachedColormapFrom: sourceDepth to: destDepth ].
	answer := self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
	colorMap := secondPassMap.
	secondPassMap ifNotNil: [
		prevRule := combinationRule.
		combinationRule := 20. "rgbAdd"
		self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
		combinationRule := prevRule ].
	^answer! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:52' prior: 16850173!
                             cachedFontColormapFrom1BitTo: destDepth

	| map dstIndex |
	CachedFontColorMaps 
		ifNil: [CachedFontColorMaps _ Array new: 6].

	dstIndex _ destDepth highBit.
	(CachedFontColorMaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ (Colour cachedColormapFrom: 1 to: destDepth) copy.
	CachedFontColorMaps at: dstIndex put: map.
	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:55' prior: 16850186!
     colorConvertingMap: targetColour from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	
	| srcIndex dstIndex map mapsForSource mapsForSourceAndDest |
	ColorConvertingMaps 
		ifNil: [ColorConvertingMaps _ (1 to: 6) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit.
	sourceDepth > 8 ifTrue: [ srcIndex _ keepSubPix ifTrue: [5] ifFalse: [6] ].
	dstIndex _ destDepth highBit.
	
	mapsForSource _ ColorConvertingMaps at: srcIndex.
	(mapsForSourceAndDest _ mapsForSource at: dstIndex) ifNil: [
		mapsForSourceAndDest _ mapsForSource at: dstIndex put: Dictionary new ].
	
	map _ mapsForSourceAndDest at: targetColour ifAbsentPut: [
		Colour 
			computeColorConvertingMap: targetColour 
			from: sourceDepth 
			to: destDepth 
			keepSubPixelAA: keepSubPix ].

	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 4/17/2014 16:57' prior: 16850225!
          setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: Colour transparent).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			Preferences subPixelRenderFonts and: [ foregroundColor = Colour black or: [ 
				Preferences subPixelRenderColorFonts and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= Colour black or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preferences properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = Colour black ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25' prior: 16815566!
                         makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Colour black]
                ifFalse: [Colour white]! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96' prior: 16815760!
                          mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Colour green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Colour r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45' prior: 16815785!
                        wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Colour h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:33' prior: 16815842!
                          closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Colour red lighter lighter) closestColour explore.
"
	^ self closestColorFrom: (Colour colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 16815850!
                 closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Colour blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Colour colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 16815867!
          closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Colour red lighter lighter) closestColour name.
"
	
	^ self closestNameFrom: (Colour colorNamesDict)! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:41' prior: 16815891!
    colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Colour colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:03' prior: 16816085!
             * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Color brown *2) display
	"
	^ Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:06' prior: 16816097!
+ aColor
	"Answer this color mixed with the given color in an additive color space.  "
	"
	(Color blue + Color green) display
	"
	^ Colour new
		setRed: (self red + aColor red min: 1.0 max: 0.0)
		green: (self green + aColor green min: 1.0 max: 0.0)
		blue: (self blue + aColor blue min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:09' prior: 16816110!
- aColor
	"Answer aColor is subtracted from the given color in an additive color space.  "
	"
	(Color white - Color red) display
	"
	^ Colour new
		setRed: (self red - aColor red min: 1.0 max: 0.0)
		green: (self green - aColor green min: 1.0 max: 0.0)
		blue: (self blue - aColor blue min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:10' prior: 16816123!
                             / aNumber
	"Answer this color with its RGB divided by the given number. "
	"
	(Color red / 2) display
	"
	^ Colour new
		setRed: (self red / aNumber min: 1.0 max: 0.0)
		green: (self green / aNumber min: 1.0 max: 0.0)
		blue: (self blue / aNumber min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:18' prior: 16816135!
    adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:22' prior: 16816146!
   adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:28:01' prior: 16816159!
                          alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifFalse: [
		^ TranslucentColour new
			setRed: self red
			green: self green
			blue: self blue
			alpha: alphaValue
			colorSpace: colorSpace ]! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:26' prior: 16816170!
    alphaMixed: proportion with: aColour 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColour red * frac2)
		g: self green * frac1 + (aColour green * frac2)
		b: self blue * frac1 + (aColour blue * frac2)
		alpha: self alpha * frac1 + (aColour alpha * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 16816210!
                               blacker

	^ self alphaMixed: 0.8333 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54' prior: 16816214!
                  dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Colour h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:30' prior: 16816240!
       mixed: proportion with: aColour 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColour alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColour red * frac2)
		g: self green * frac1 + (aColour green * frac2)
		b: self blue * frac1 + (aColour blue * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29' prior: 16816258!
     muchDarker

	^ self alphaMixed: 0.5 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07' prior: 16816262!
                    muchLighter

	^ self alphaMixed: 0.233 with: Colour white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:33' prior: 16816266!
            negated
	"Return an RGB inverted color"
	^Colour
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:41' prior: 16816287!
                          quiteBlacker

	^ self alphaMixed: 0.8 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:44' prior: 16816291!
                quiteWhiter

	^ self alphaMixed: 0.6 with: Colour white! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25' prior: 16816304!
                  slightlyWhiter

	^ self alphaMixed: 0.85 with: Colour white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 8/23/2009 23:24' prior: 16816321!
             veryMuchDarker

	^ self alphaMixed: 0.25 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 7/28/2016 15:43:04' prior: 16816326!
          veryMuchLighter

	^ self alphaMixed: 0.07 with: Colour white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 16816331!
             whiter

	^ self alphaMixed: 0.8333 with: Colour white
! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/2/2016 15:04' prior: 16816547!
            colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Colour transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Colour transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Colour r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Colour r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Colour r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Color class methodsFor: 'class initialization' stamp: '' prior: 16816881!
initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Colour initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Colour r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Colour r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Colour r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Colour r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Colour r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Colour r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Colour r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Colour r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Colour r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Colour r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Colour r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Colour r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Colour r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Colour r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Colour r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Colour r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Colour r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Colour r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48' prior: 16816950!
                 colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Colour colorRampForDepth: Display depth extent: 256@80) display"
	"(Colour colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Colour r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: i g: i b: i range: 255)].
	^ f
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:30:09' prior: 16816978!
        experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Colour random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Colour new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Colour new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Colour new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Colour new setHue: h chroma: selectedChroma luminance: v.
"		color _ Colour new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817055!
                showColorCube
	"Show a 12x12x12 color cube."
	"Colour showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Colour r: r g: g b: b range: 11)]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817075!
        showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Colour h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Colour h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817112!
                         wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Colour wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817120!
                           wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Colour showColors: (Colour wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Colour showColors: (Colour wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Colour h: 0.0 s: s v: v) wheel: thisMany
! !
!Color class methodsFor: 'colormaps' stamp: '' prior: 16817522!
                    colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Colour cachedColormapFrom: sourceDepth to: destDepth
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:56' prior: 16817637!
                  computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Colour gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05' prior: 16817648!
                computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Colour white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 21:34:38' prior: 16817670!
            computeRGBColorConvertingMap: targetColour to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColour values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColour r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColour _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColour _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColour _ bitsPerColour min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColour) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColour)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColour)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColour) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColour
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Colour
							r: 1.0 - (r asFloat/mask) * targetColour red
							g: 1.0 - (g asFloat/mask) * targetColour green
							b: 1.0 - (b asFloat/mask) * targetColour blue
							alpha: f	* targetColour alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColour * f alpha: f * targetColour alpha ]
						ifFalse: [ targetColour alphaMixed: f*1.5 with: Colour white ]]]
			ifNil: [ Colour r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 21:34:42' prior: 16817730!
                      computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Colour maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Colour transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 21:34:46' prior: 16817772!
        computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Colour maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Color class methodsFor: 'color from user' stamp: 'jmv 3/1/2010 15:13' prior: 16817838!
       colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 7/27/2009 11:32' prior: 16817895!
                          colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/28/2013 20:34' prior: 16817983!
                defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Colour r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Colour r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Colour r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Colour r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Colour r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 2/1/2013 14:39' prior: 16818009!
        doesNotUnderstand: aMessage
	"Some code takes
		 Colour colorNames 
	and does
		Colour perform: aColorname.
		
	Make this work."

	^(Colour colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 7/25/2014 21:22' prior: 16818027!
                          setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Colour defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Color class methodsFor: 'color name lookup' stamp: 'sqr 10/21/2016 12:44:48' prior: 16818045!
                            traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Colour r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Colour r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Colour r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Colour r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Colour r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Colour r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Colour r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Colour r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Colour r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Colour r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Colour r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Colour r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Colour r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Colour r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Colour r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Colour r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Colour r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Colour r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Colour r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Colour r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Colour r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Colour r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Colour r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Colour r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Colour r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColour r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Color class methodsFor: 'color name lookup' stamp: 'jmv 6/30/2014 15:22' prior: 16818102!
     xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Colour xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Colour fromString: '#ffd1df') ;
	at: #mustard put: (Colour fromString: '#ceb301') ;
	at: #indigo put: (Colour fromString: '#380282') ;
	at: #lime put: (Colour fromString: '#aaff32') ;
	at: #seaGreen put: (Colour fromString: '#53fca1') ;
	at: #periwinkle put: (Colour fromString: '#8e82fe') ;
	at: #darkPink put: (Colour fromString: '#cb416b') ;
	at: #oliveGreen put: (Colour fromString: '#677a04') ;
	at: #peach put: (Colour fromString: '#ffb07c') ;
	at: #paleGreen put: (Colour fromString: '#c7fdb5') ;
	at: #lightBrown put: (Colour fromString: '#ad8150') ;
	at: #hotPink put: (Colour fromString: '#ff028d') ;
	at: #black put: (Colour fromString: '#000000') ;
	at: #lilac put: (Colour fromString: '#cea2fd') ;
	at: #navyBlue put: (Colour fromString: '#001146') ;
	at: #royalBlue put: (Colour fromString: '#0504aa') ;
	at: #beige put: (Colour fromString: '#e6daa6') ;
	at: #salmon put: (Colour fromString: '#ff796c') ;
	at: #olive put: (Colour fromString: '#6e750e') ;
	at: #maroon put: (Colour fromString: '#650021') ;
	at: #brightGreen put: (Colour fromString: '#01ff07') ;
	at: #darkPurple put: (Colour fromString: '#35063e') ;
	at: #mauve put: (Colour fromString: '#ae7181') ;
	at: #forestGreen put: (Colour fromString: '#06470c') ;
	at: #aqua put: (Colour fromString: '#13eac9') ;
	at: #cyan put: (Colour fromString: '#00ffff') ;
	at: #tan put: (Colour fromString: '#d1b26f') ;
	at: #darkBlue put: (Colour fromString: '#00035b') ;
	at: #lavender put: (Colour fromString: '#c79fef') ;
	at: #turquoise put: (Colour fromString: '#06c2ac') ;
	at: #darkGreen put: (Colour fromString: '#033500') ;
	at: #violet put: (Colour fromString: '#9a0eea') ;
	at: #lightPurple put: (Colour fromString: '#bf77f6') ;
	at: #limeGreen put: (Colour fromString: '#89fe05') ;
	at: #grey put: (Colour fromString: '#929591') ;
	at: #skyBlue put: (Colour fromString: '#75bbfd') ;
	at: #yellow put: (Colour fromString: '#ffff14') ;
	at: #magenta put: (Colour fromString: '#c20078') ;
	at: #lightGreen put: (Colour fromString: '#96f97b') ;
	at: #orange put: (Colour fromString: '#f97306') ;
	at: #teal put: (Colour fromString: '#029386') ;
	at: #lightBlue put: (Colour fromString: '#95d0fc') ;
	at: #red put: (Colour fromString: '#e50000') ;
	at: #brown put: (Colour fromString: '#653700') ;
	at: #pink put: (Colour fromString: '#ff81c0') ;
	at: #blue put: (Colour fromString: '#0343df') ;
	at: #green put: (Colour fromString: '#15b01a') ;
	at: #purple put: (Colour fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 21:28:31' prior: 16939024!
                            alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifTrue: [
		^ Colour new
			setRed: self red
			green: self green
			blue: self blue
			colorSpace: colorSpace].
	^ super alpha: alphaValue! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/24/2013 22:36' prior: 16898974!
            newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor isAnyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Colour gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor isAnyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Colour gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Colour gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Colour gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 4/10/2015 23:21' prior: 16914485!
                       makeBoldGlyphs
	"Make a bold set of glyphs with same widths by ORing 1 bit to the right
		(requires at least 1 pixel of intercharacter space)"
	| g bonkForm |
	g _ glyphs copy.
	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.
	self bonk: g with: bonkForm.
	glyphs depth = 1 ifTrue: [
		g copyBits: g boundingBox from: g at: (1@0)
			clippingBox: g boundingBox rule: Form under ]
		ifFalse: [
			0 to: g width - 2 do: [ :x | 0 to: g height-1 do: [ :y |
				(glyphs colorAt:  x@y) = Colour white ifFalse: [
					g colorAt: x+1@y put: 
						((glyphs colorAt: x+1@y) = Colour white 
							ifTrue: [glyphs colorAt:  x@y]
							ifFalse: [Colour black])]]]].
	glyphs _ g.
	self isSynthetic: true! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:22' prior: 16914725!
                 makeControlCharsVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character space).
	glyph border: glyph boundingBox width: 1 fillColor: Colour blue.
	self glyphAt: (Character numericValue: 134) put: glyph.
	
	"Keep tab(9), lf(10), cr(13) and space(32) transparent or whatever the user chose"
	#(0 1 2 3 4 5 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27)
		do: [ :ascii |
			characterToGlyphMap at: ascii + 1 put: 134 ]! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:27' prior: 16914749!
            makeCrVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 182).
	glyph border: glyph boundingBox width: 1 fillColor: Colour blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 133) put: glyph.
	characterToGlyphMap at: 14 put: 133! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:31' prior: 16914768!
        makeLfVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 163).
	glyph border: glyph boundingBox width: 1 fillColor: Colour blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 132) put: glyph.
	characterToGlyphMap at: 11 put: 132! !
!Morph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:40' prior: 16873946!
            color

	^ Colour blue! !
!Morph methodsFor: 'drawing' stamp: 'jmv 4/14/2015 08:53' prior: 16874298!
                            drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: self morphLocalBounds
		color: Colour blue! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:46' prior: 16899196!
                             defaultColor
	^ Colour orange! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:28' prior: 16790410!
 defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Colour gray! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 6/18/2017 21:33:36' prior: 16887268!
defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Colour
		r: 0.861
		g: 1.0
		b: 0.722! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 6/18/2017 21:33:40' prior: 16887280!
      defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour
		r: 0.8
		g: 1.0
		b: 0.6! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 11/10/2013 19:32' prior: 16887655!
                             findWindow: evt
	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."
	| menu expanded collapsed nakedMorphs |
	menu _ MenuMorph new.
	expanded _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed not ].
	collapsed _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed ].
	nakedMorphs _ self submorphsSatisfying: [ :m |
		(m is: #SystemWindow) not ].
	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) ifTrue: [ ^ Smalltalk beep ].
	(expanded asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #activateAndForceLabelToShow.
		w canDiscardEdits ifFalse: [ menu lastItem color: Colour red ]].
	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) ifFalse: [ menu addLine ].
	(collapsed asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #expand.
		w canDiscardEdits ifFalse: [ menu lastItem color: Colour red ]].
	nakedMorphs isEmpty ifFalse: [ menu addLine ].
	(nakedMorphs asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #comeToFrontAndAddHalo ].
	menu addTitle: 'find window'.
	menu popUpInWorld: self! !
!EllipseMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:14' prior: 16837113!
                       defaultColor
	"Return the default fill style for the receiver"
	^Colour yellow! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 8/6/2014 09:15' prior: 16889451!
                    defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour lightGray! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:50' prior: 16888164!
           drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Colour h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/12/2012 22:37' prior: 16888215!
   iconColor

	^ self isPressed
		ifTrue: [ Colour gray: 0.75 ]
		ifFalse: [
			self mouseIsOver
				ifTrue: [ Colour gray: 0.75 ]
				ifFalse: [ Colour white ]].! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 1/4/2013 13:31' prior: 16888484!
                              example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Colour lightRed.
	b2 color: Colour lightRed.
	b3 color: Colour lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: 120@35.
	^ row
! !
!TextModelMorph methodsFor: 'drawing' stamp: 'cbr 10/10/2012 23:04' prior: 16933987!
                            drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"


	| bw bc |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"


	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Colour tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Colour red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Colour red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Colour white ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'cbr 11/7/2010 18:58' prior: 16926270!
                             defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour white! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/7/2013 23:23' prior: 16926535!
                          setWindowColor: incomingColor
	| existingColor aColor |
	incomingColor ifNil: [^ self].  "it happens"
	aColor _ incomingColor asNontranslucentColor.
	aColor = Colour black ifTrue: [^ self].
	existingColor _ self widgetsColor.
	existingColor ifNil: [^ Smalltalk beep].
	self widgetsColor: aColor.
	self redrawNeeded! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'KenD 8/27/2015 14:39' prior: 16811424!
 buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground textHeigth |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	textHeigth := AbstractFont default height.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: textHeigth;
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: textHeigth;
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: textHeigth;
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: self buildButtonPane proportionalHeight: 0.1;
		addAdjusterAndMorph: summary proportionalHeight: 0.18;
		addAdjusterAndMorph: description proportionalHeight: 0.22;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.2.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'len 5/27/2016 21:51' prior: 16811499!
                 buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	requirements color: Theme current textPane.
		
	deleteReqButton := PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete'.
	deleteReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newColumn.
	buttonLayout addMorph: deleteReqButton 
					layoutSpec: (LayoutSpec 
										proportionalWidth: 1.0 
										proportionalHeight: 1.0
										minorDirectionPadding: #top);
					color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.9 
							proportionalHeight: 1.0 
							minorDirectionPadding: #left);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.1 
							proportionalHeight: 1.0 
							minorDirectionPadding: #right);
		color: Colour transparent;
		yourself
		! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 6/18/2017 21:32:16' prior: 16813173!
      decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColour aButton flags buttonColour |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColour _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColour ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColour ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColour _ {

		"This is NOTan override. There is no super implementation."
		buttonColour.							"no sends to super. there is not override in any subclass"
		Colour tan.							"no sends to super. there is an override in some subclass"
		Colour red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Colour red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Colour red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Colour r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Colour green muchLighter.			"doesn't have sub; has super and callsl it"
		Colour blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: buttonColour! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'DM 8/22/2015 12:34' prior: 16799978!
                buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35' prior: 50336800!
    buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Colour transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!TestRunnerWindow methodsFor: 'constants' stamp: 'jmv 4/16/2011 13:57' prior: 16928704!
                     runButtonColor
	^ Colour green lighter duller! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:52' prior: 16896023!
                  defaultColor
	^Colour white! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:53' prior: 16896027!
    initialize
	super initialize.
	progressColor _ Colour gray.
	value _ 0.0! !
!MenuMorph methodsFor: 'construction' stamp: 'len 11/16/2015 02:52' prior: 16866472!
                               addStayUpIcons
	| closeBox pinBox w |
	Preferences optionalButtons ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon; color: Colour transparent.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon; color: Colour transparent.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: 19);
			color: Colour transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleLikeMorph new color: Colour transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleLikeMorph new color: Colour transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 6/8/2014 20:32' prior: 16867035!
             displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Colour veryDarkGray.
		self addMorphBack: feedbackMorph lock position: (0@ -20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/14/2016 15:10' prior: 16781489!
                           drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (0@0 extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Colour veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:09' prior: 16781571!
                 defaultBorderColor
	^ Colour gray! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:59' prior: 16851609!
             drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: 0@0
		color: Colour black! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 6/18/2017 21:32:59' prior: 16854101!
      color: aColor
        super color: aColor.
        (image depth = 1 and: [aColor is: #Color]) ifTrue: [
                image colors: {Colour transparent. aColor}.
                self redrawNeeded]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/13/2009 10:04' prior: 16865863!
 isEnabled: aBoolean

	isEnabled = aBoolean ifTrue: [^ self].
	isEnabled _ aBoolean.
	self color: (aBoolean ifTrue: [Colour black] ifFalse: [Colour gray]).
! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 16866162!
               offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Colour gray: 0.9) 
			borderWidth: 1 borderColor: Colour black.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 16866174!
          onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Colour gray: 0.8) 
			borderWidth: 1 borderColor: Colour black;
		fillRectangle: (form boundingBox insetBy: 2) color: Colour black.
	^form! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 12/1/2015 09:53' prior: 16863001!
      adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	doAdoptWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: paneColor) ]
		ifFalse: [ self color: Colour transparent ]! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:38' prior: 16863302!
                           defaultColor
	^Colour gray! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:59' prior: 16863603!
  initializedInstance
	"Answer a row by default so the 'new morph' menu doesn't fail..."
	^self newRow color: (Colour red alpha: 0.2)! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:57' prior: 16863624!
  example1
"
	self example1
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/12/2015 16:42' prior: 16863690!
       example10
"
	self example10 openInWorld
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example10.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:55' prior: 16863758!
example11
"
	self example11
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example11.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:08' prior: 16863827!
                     example13
	"
	self example13
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Colour red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Colour red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Colour h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 2/16/2016 13:27' prior: 16863874!
                       example1b
"
Based on #example1, but using some Morph instead of RectangleLikeMorph -> extent is not adjustable
	self example1b
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (Morph new name: #B);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (Morph new name: #G);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (Morph new name: #J);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:25' prior: 16863934!
              example2
	"
	self example2
	"
	| pane row |
	pane _ (LayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Colour red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Colour h: 270 s: 0.2 v: 0.6);
		addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 11/18/2015 09:45' prior: 16863965!
                         example20
"
	self example20
"
| column |

column _ (LayoutMorph newColumn separation: 5) name: #Column.
column
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 30).
column morphPosition: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:13' prior: 16863988!
   example3
	"
	self example3
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Colour red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Colour red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Colour h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/8/2014 20:03' prior: 16864030!
                       example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Colour lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := BorderedRectMorph new color: (Colour cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Colour lightGreen;
	morphPosition: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane _ LayoutMorph newRow separation: 5. "2"
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Colour lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Colour cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane
	color: Colour lightGreen;
	morphPosition: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Colour lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Colour cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane
	color: Colour lightGreen;
	morphPosition: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 1/4/2013 13:42' prior: 16864106!
   launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: Colour lightRed ].
	row _ LayoutMorph newRow
		 color: Colour red;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:55' prior: 16896260!
             defaultColor
	^Colour veryLightGray! !
!HaloHandleMorph class methodsFor: 'accessing' stamp: 'jmv 11/18/2010 09:44' prior: 16850573!
                           circleForm: extent
	"
	CircleForm _ nil
	"
	| r d l bw center |
	(CircleForm isNil or: [ CircleForm extent ~= extent ]) ifTrue: [
		center _ extent -1 * 0.5.
		r _ center r * 0.75.
		bw _ 1.3.
		CircleForm _ Form extent: extent depth: 32.
		0 to: extent y - 1 do: [ :y |
			0 to: extent x - 1 do: [ :x |
				d _ (x@y - center) r.
				l _ (r - d max: 0.0) min: bw.
				CircleForm
					colorAt: x @ y
					put: (Colour white alpha: (l / bw))
					]].
		].
	^CircleForm! !
!HaloMorph methodsFor: 'initialization' stamp: 'jmv 6/18/2017 21:33:32' prior: 16850854!
                 defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour
		r: 0.6
		g: 0.8
		b: 1.0! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 5/27/2015 13:42' prior: 16850874!
    addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Colour colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: 0@0 ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 7/4/2016 22:14' prior: 16850920!
         addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition nameBackground |
	nameBackground _ RectangleLikeMorph new
		color: ((target is: #SystemWindow) ifTrue: [target windowColor] ifFalse: [Colour lightBlue alpha: 0.9]).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Colour black.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	namePosition _ haloBox width - nameMorph morphWidth // 2 @ (haloBox height).
	self addMorph: nameBackground position: namePosition - 2.
	self addMorph: nameMorph position: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18' prior: 16851047!
              doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Colour lightBlue]
		ifFalse: [rotHandle color: Colour blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPositionInWorld: evt eventPosition - (rotHandle morphExtent // 2)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01' prior: 16851135!
                            setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint:  (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [ Colour red muchLighter ]
		ifTrue: [ Colour lightGray ].
	dismissHandle color: colorToUse! !
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 5/27/2013 09:39' prior: 16855063!
         initialize
	super initialize.
	self color: Colour black.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	selectedRows _ Set new.
	highlightedRow _ nil! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 10/16/2013 19:55' prior: 16855561!
                    debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self textComposition lines do: [ :line |
		aCanvas
			frameRectangle: line rectangle
			borderWidth: 1
			color: Colour brown ]
! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:51' prior: 50333232!
                       initialize
	super initialize.
	extent _ 400@300.
	color _ Colour white.
	grid _ 8@6.
	gridLineWidth _ 2.
	gridColor _ Colour black.
	selectionColor _ Colour red! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:18' prior: 50333240!
                               mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Colour black;
		color: Colour transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 9/25/2011 23:12' prior: 16853831!
                    defaultColor

	^Colour r: 1.0 g: 1.0 b: 0.7! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 12/20/2014 15:09' prior: 16853866!
                            drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		textComposition: textComposition
		bounds: (r insetBy: 4)
		color: Colour black
		selectionColor: (Theme current textHighlightFocused: false)! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12' prior: 50339659!
           drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Colour gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Colour random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21' prior: 50339881!
        experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Colour green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Colour gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 12/20/2014 15:35' prior: 16877458!
                            drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > (50@50)
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Colour red
		borderWidth: w
		borderColor: Colour yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Colour yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Colour yellow! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/1/2015 13:30' prior: 16877630!
                             drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Colour black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Colour black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Colour white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Colour white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + (0@2)
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + (0@1)
		font: fontOrNil
		color: aColor! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:01' prior: 16786666!
     fillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	aColor isTransparent ifFalse: [
		self 
			frameAndFillRectangle: aRectangle
			fillColor: aColor
			borderWidth: 0
			borderColor: Colour transparent ]! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:14' prior: 16786789!
                               reverseRectangleBorder: r borderWidth: borderWidth
	"
	Display getCanvas
		reverseRectangleBorder: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	port
		sourceForm: nil;
		fillColor: Colour gray;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 4/9/2015 09:46' prior: 16787146!
                              setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor |
	paintColor _ aColor ifNil: [ Colour transparent ].
	(paintColor is: #Color) ifFalse: [
		^self error: 'Cannot install color' ].

	"Okay, so paintColor really *is* a color"
	port sourceForm: nil.
	(paintColor isOpaque or: [ self depth < 32]) ifTrue: [
		port fillColor: paintColor.
		port combinationRule: Form paint.
		^self ].

	"BitBlt setup for alpha mapped transfer"
	port fillColor: paintColor.
	port combinationRule: Form blend! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 16787260!
                              steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (0@0 extent: extent)
				color: (Colour gray: 0.4)
				radius: 4.
			canvas
				roundRect: (1@1 extent: extent-2)
				color: Colour white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 16787305!
                         verticalGrayGradient: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	^self cachedForms
		at: { #vertical. height. gradientTopFactor . gradientBottomFactor }
		ifAbsentPut: [
			Form
				verticalGradient: height
				topColor: (Colour gray: gradientTopFactor)
				bottomColor: (Colour gray: gradientBottomFactor) ]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/7/2015 08:12' prior: 16787328!
     buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	 (self buildArrowOfDirection: #up size: 120) display
	"

	| resizeFactor resizedForm f e c bottomMargin topMargin |
	resizeFactor _ 4.
	e _ finalSizeInteger@finalSizeInteger*resizeFactor.
	f _ Form extent: e depth: 32.
	c _ Colour gray: 0.5.
	topMargin _ finalSizeInteger * 3//4.
	bottomMargin _ finalSizeInteger * 4//4.
	0 to: e y-1-bottomMargin do: [ :y |
		0 to: e x -1 do: [ :x |
			(e x / 2 - 1 - x) abs * 2 + topMargin < y ifTrue: [
				f colorAt: x@y put: c
			]
		]
	].
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 10/9/2014 23:02' prior: 16787371!
                   buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - (1@2).
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Colour r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Colour transparent ]
				ifFalse: [
					borderSpec = (Colour r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Colour white]
								ifFalse: [Colour black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/19/2010 14:06' prior: 16935417!
           background
	^ Colour r: 0.7 g: 0.72 b: 0.83! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:42' prior: 16935421!
      buttonColorFrom: aColor
	^ Display depth <= 8
			ifTrue: [ Colour transparent ]
			ifFalse: [ aColor paler ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/14/2011 08:50' prior: 16935427!
      buttonLabel
	^Colour gray: 0.18! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 16935430!
                    errorColor
	^ Colour red lighter! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:40' prior: 16935433!
                   failureColor
	^ Colour yellow lighter! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 16935453!
            scrollbarButtonColor
	^Colour gray: 0.95! !
!Theme methodsFor: 'colors' stamp: 'len 11/17/2015 23:55' prior: 16935457!
         scrollbarColor
	^Colour white! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 16935460!
                    scrollbarSliderShadowColor
	^Colour white! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 16935464!
          successColor
	^ Colour green lighter! !
!Theme methodsFor: 'colors' stamp: 'cbr 11/7/2010 18:00' prior: 16935468!
              text
	^ Colour black! !
!Theme methodsFor: 'colors' stamp: 'jmv 10/16/2013 22:08' prior: 16935471!
                             textCursor
	^ Display depth <= 2
		ifTrue: [ Colour black ]
		ifFalse: [ self text ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 5/30/2011 14:31' prior: 16935476!
                              textHighlight
	"A nice light blue."
	"
	^ Colour r: 0.71 g: 0.835 b: 1.0
	^ Colour hue: 214 chroma: 0.29 luminance: 0.816
	"
	^Colour hue: 204 chroma: 0.29 luminance: 0.77! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:58' prior: 16935484!
      textHighlightFocused: focused
	"A nice light blue."
	| textHighlight |
	Display depth = 1 ifTrue: [^ Colour veryLightGray].
	Display depth = 2 ifTrue: [^ Colour gray: 0.87].
	textHighlight _ self textHighlight.
	^focused
		ifTrue: [ textHighlight ]
		ifFalse: [ self unfocusedTextHighlightFrom: textHighlight ]! !
!Theme methodsFor: 'colors' stamp: 'cbr 12/6/2010 20:08' prior: 16935501!
                            windowLabel
	^Colour gray: 0.3! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 5/26/2011 09:07' prior: 16935505!
               menu
	Display depth <= 2 ifTrue: [^ Colour white].
	^Colour r: 0.75 g: 0.75 b: 0.75 alpha: 0.93! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/23/2010 09:45' prior: 16935511!
             menuHighlight
	^ Display depth < 8
		ifTrue: [ Colour veryLightGray ]
		ifFalse: [ self textHighlight ]! !
!Theme methodsFor: 'menu colors' stamp: 'cbr 11/7/2010 18:28' prior: 16935517!
      menuText
	^ Colour black! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/28/2010 08:04' prior: 16935520!
                    menuTitleBar
	Display depth = 1 ifTrue: [^ Colour white].
	Display depth = 2 ifTrue: [^ Colour gray].
	^ self menu darker! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 4/15/2011 14:59' prior: 16935526!
                    browser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.5 g: 0.7 b: 0.4]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 2/14/2013 11:05' prior: 16935539!
                             debugger
	^Colour h: 0.0 s: 0.6 v: 0.7! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:16' prior: 16935543!
      defaultWindowColor
	^ Colour lightGray! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 16935551!
      fileContentsBrowser
	^Colour tan duller! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:44' prior: 16935555!
      fileList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.7 g: 0.55 b: 0.7 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 16935561!
                          messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 16935567!
                  messageSet
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.45 g: 0.6 b: 0.85 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 16935573!
                      object
	^Colour white duller! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/28/2012 09:41' prior: 16935576!
                 packageList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.63 g: 0.47 b: 0.08 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:17' prior: 16935582!
                    testRunner
	^ self useUniformColors
		ifTrue: [ self defaultWindowColour ]
		ifFalse: [ (Colour r: 0.650 g: 0.753 b: 0.976) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:15' prior: 16935589!
         textEditor
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour gray: 0.6 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 16935595!
    transcript
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.8 g: 0.6 b: 0.3 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/18/2010 17:56' prior: 16935601!
                        versionsBrowser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColour ]
		ifFalse: [ (Colour r: 0.869 g: 0.753 b: 1.0) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:13' prior: 16935608!
      workspace
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour h: 60.0 s: 0.73 v: 0.72 ]! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49' prior: 16935614!
                     acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Colour r: 0.2 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 16935621!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Colour r: 0.8 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'cbr 10/10/2012 23:36' prior: 16935647!
                      textPane
	^Colour white! !
!SHTextStylerST80 class methodsFor: 'style table' stamp: 'pb 5/4/2016 17:44' prior: 16903544!
       initialTextAttributes
	| d element color emphasis attrArray |
	d _ IdentityDictionary new.
	self styleTable do: [ :each |
		element _ each first.
		color _ each at: 2 ifAbsent: nil.
		color _ color ifNotNil: [ Colour colorFrom: color ].
		emphasis _ each at: 3 ifAbsent: nil.
		attrArray _ self attributeArrayForColor: color emphasis: emphasis.
		attrArray notEmpty ifTrue: [
			d at: element put: attrArray ]].
	^ d! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3106-ChangeReferencesToColour-JuanVuletich-2017Jun19-11h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3106] on 19 June 2017 at 12:18:58 pm'!
!Colour methodsFor: 'transformations' stamp: 'jmv 6/19/2017 12:18:51' prior: 50345512!
                     * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Colour brown *2) display
	"
	^ (Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0))
			alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/19/2017 12:18:50' prior: 50349789!
 * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Color brown *2) display
	"
	^ (Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0)
		colorSpace: colorSpace)
			alpha: self alpha! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3107-KeepAlphaOnColorMultiply-JuanVuletich-2017Jun19-12h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3106] on 19 June 2017 at 11:52:30 am'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| all |
all := Color allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).
all := TranslucentColor allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3108-MigrateInstancesToColour-JuanVuletich-2017Jun19-11h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:15:55 am'!

TranslucentColour removeSelector: #setRed:green:blue:alpha:colorSpace:!

TranslucentColour removeSelector: #setRed:green:blue:alpha:colorSpace:!

Colour removeSelector: #floatRGB!

Colour removeSelector: #floatRGB!

Colour removeSelector: #setRed:green:blue:colorSpace:!

Colour removeSelector: #setRed:green:blue:colorSpace:!

Smalltalk removeClassNamed: #Color!

Smalltalk removeClassNamed: #Color!

Smalltalk removeClassNamed: #TranslucentColor!

Smalltalk removeClassNamed: #TranslucentColor!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3109-removeColor-JuanVuletich-2017Jun19-11h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3108] on 19 June 2017 at 11:58:54 am'!

FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #Color category: #'Graphics-Primitives'!
FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!Color commentStamp: 'jmv 6/18/2017 20:14:31' prior: 0!
 This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)
	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:
	r	amount of red, a Float between 0.0 and 1.0.
	g	amount of green, a Float between 0.0 and 1.0.
	b	amount of blue, a Float between 0.0 and 1.0.
	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)
	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.
	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.
	Here are some fun things to run in when your screen has color:
		Pen new mandala: 30 diameter: Display height-100.
		Pen new web  "Draw with the mouse, opt-click to end"
		Display fillWhite.  Pen new hilberts: 5.
		Form toothpaste: 30  "Draw with mouse, opt-click to end"

Messages:
	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.

	+ 	add two colors
	- 	subtract two colors
	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.
	/	divide a color by a factor or an array of three factors.

	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.
	saturation	Returns the saturation of the color.  0.0 to 1.0
	brightness	Returns the brightness of the color.  0.0 to 1.0

	name    Look to see if this Color has a name.
	display	Show a swatch of this color tracking the cursor.

	lightShades: thisMany		An array of thisMany colors from white to the receiver. 
	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.
	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.
	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.

	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. 

Messages to Class Color.
	red: r green: g blue: b		Return a color with the given r, g, and b components.
	r: g: b:		Same as above, for fast typing.

 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.

	pink
 	blue
	red ...	Many colors have messages that return an instance of Color.
	canUnderstand: #brown	  Returns true if #brown is a defined color.
	names		An OrderedCollection of the names of the colors.
	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.
	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.

	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.

    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array. 

   colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.

(See also comments in these classes: Form, Bitmap, BitBlt)

Default colorSpace is #sRGB. Subclasses might use other color spaces!

Color variableWordSubclass: #TranslucentColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #TranslucentColor category: #'Graphics-Primitives'!
Color variableWordSubclass: #TranslucentColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!TranslucentColor commentStamp: '<historical>' prior: 0!
         A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the fourth position.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.!
!Color methodsFor: 'access' stamp: 'jmv 1/31/2011 09:25'!
                         alpha
	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TranslucentColors."

	^ 1.0
! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:34'!
     blue
	"Return the blue component of this color, a float in the range [0.0..1.0]."

	^ self at: 3! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:33:10'!
                               brightness
	"Return the brightness of this color, a float in the range [0.0..1.0].
	Color red brightness
	"

	"Do not include alpha if TranslucentColor"
	^ (self red max: self green) max: self blue! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:30'!
                          chroma
	"Return the chroma of this color, a value between 0.0 and 1.0, somewhat related to saturation.
	See http://en.wikipedia.org/wiki/HSL_and_HSV
	Color red chroma
	Color gray chroma
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	^max - min! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:28'!
                              green
	"Return the green component of this color, a float in the range [0.0..1.0]."

	^ self at: 2! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:31:54'!
                             hue
	"Return the hue of this color, an angle in the range [0.0..360.0].
	Color orange hue
	"

	| r g b max min span h |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	span _ (max - min) asFloat.
	span = 0.0 ifTrue: [ ^ 0.0 ].

	r = max ifTrue: [
		h _ ((g - b) asFloat / span) * 60.0.
	] ifFalse: [
		g = max
			ifTrue: [ h _ 120.0 + (((b - r) asFloat / span) * 60.0). ]
			ifFalse: [ h _ 240.0 + (((r - g) asFloat / span) * 60.0). ].
	].

	^h mod: 360.0! !
!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:19'!
    icon
	"Answer a swatch to display in a menu or browser"
	^self swatch! !
!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:17'!
                            iconOrThumbnailOfSize: aNumberOrPoint 
	"Answer an appropiate form to represent the receiver"
	| form |
	form := Form extent: aNumberOrPoint asPoint asPoint depth: 32.
	form fillColor: self.
	^ form! !
!Color methodsFor: 'access' stamp: 'jmv 4/19/2013 16:46'!
                            luminance
	"Return the luminance of this color, a brightness value weighted by the human eye's color sensitivity."

	^ ((299 * self red) +
	   (587 * self green) +
	   (114 * self blue)) / 1000! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:25'!
                              red
	"Return the red component of this color, a float in the range [0.0..1.0]."

	^ self at: 1! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:08'!
 saturation
	"Return the saturation of this color, a value between 0.0 and 1.0.
	Color red saturation
	Color gray saturation
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	max = 0.0 ifTrue: [ ^0.0 ].
	^max - min / max! !
!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:18'!
                           swatch
	"Answer a swatch to display in a menu or browser"
	^self iconOrThumbnailOfSize: 16! !
!Color methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!
   asNontranslucentColor
	^ self! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:20:07'!
                             bitPatternForDepth: depth
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"

	^ Bitmap with: (self pixelWordForDepth: depth)! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/3/2016 17:28'!
                    bitPatternForGrayForm
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"
	"Details: The pattern for the most recently requested depth is cached."

	^Bitmap with: (self pixelWordFor: 8 filledWith: (self luminance * 255) rounded)! !
!Color methodsFor: 'conversions' stamp: 'jmv 4/19/2013 16:17'!
             closestPixelValue1
	"Return the nearest approximation to this color for a monochrome Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 0].  "white"

	self luminance > 0.5
		ifTrue: [^ 0]  "white"
		ifFalse: [^ 1].  "black"! !
!Color methodsFor: 'conversions' stamp: 'jmv 12/13/2014 16:18'!
                   closestPixelValue2
	"Return the nearest approximation to this color for a 2-bit deep Form."

	| lum |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	lum _ self luminance.
	lum < 0.2 ifTrue: [^ 1].  "black"
	lum > 0.6 ifTrue: [^ 2].  "opaque white"
	^ 3  "50% gray"
! !
!Color methodsFor: 'conversions' stamp: 'jmv 12/13/2014 16:17'!
                       closestPixelValue4
	"Return the nearest approximation to this color for a 4-bit deep Form."

	| bIndex |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	self isRed ifTrue: [^ 4].
	self isGreen ifTrue: [^ 5].
	self isBlue ifTrue: [^ 6].
	self isCyan ifTrue: [^ 7].
	self isYellow ifTrue: [^ 8].
	self isMagenta ifTrue: [^ 9].

	bIndex _ (self luminance * 8.0) rounded.  "bIndex in [0..8]"
	^ #(
		1	"black"
		10	"1/8 gray"
		11	"2/8 gray"
		12	"3/8 gray"
		3	"4/8 gray"
		13	"5/8 gray"
		14	"6/8 gray"
		15	"7/8 gray"
		2	"opaque white"
	) at: bIndex + 1.
! !
!Color methodsFor: 'conversions' stamp: 'jmv 4/21/2015 09:57'!
                       closestPixelValue8
	"Return the nearest approximation to this color for an 8-bit deep Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 255].  "white"

	^self saturation < 0.2
		ifTrue: [
			^ self class grayToIndexMap at:(self green * 255) rounded + 1.  "nearest gray"
			]
		ifFalse: [
			"compute nearest entry in the color cube"
			40 + 
				((self red * 5) rounded * 36) +
				((self blue * 5) rounded * 6) +
				(self green * 5) rounded ]! !
!Color methodsFor: 'conversions' stamp: 'di 9/2/97 20:21'!
                          dominantColor
	^ self! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/2/2016 14:48'!
         indexInMap: aColorMap
	"Return the index corresponding to this color in the given color map. RGB colors are truncated to 3-, 4-, or 5-bits per color component when indexing into such a colorMap.  "

	aColorMap size = 2 ifTrue: [^ (self pixelValueForDepth: 1) + 1].
	aColorMap size = 4 ifTrue: [^ (self pixelValueForDepth: 2) + 1].
	aColorMap size = 16 ifTrue: [^ (self pixelValueForDepth: 4) + 1].
	aColorMap size = 256 ifTrue: [^ (self pixelValueForDepth: 8) + 1].
	aColorMap size = 512 ifTrue: [^ (self pixelValueForDepth: 9) + 1].
	aColorMap size = 4096 ifTrue: [^ (self pixelValueForDepth: 12) + 1].
	aColorMap size = 32768 ifTrue: [^ (self pixelValueForDepth: 15) + 1].
	self error: 'unknown pixel depth'.
! !
!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25'!
                       makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Color black]
                ifFalse: [Color white]! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/2/2016 14:50'!
         pixelValueForDepth: d
	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	d = 32 ifTrue: [
		"eight bits per component; top 8 bits set to all ones (opaque alpha)"
		val _ LargePositiveInteger new: 4.
		val at: 3 put: (self red * 255) rounded.
		val at: 2 put: (self green * 255) rounded.
		val at: 1 put: (self blue * 255) rounded.
		val at: 4 put: 16rFF.  "opaque alpha"
		^ val normalize].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val _ ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val _ ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val _ ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString! !
!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!
                             pixelWordFor: depth filledWith: pixelValue
	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."
	| halfword |
	depth = 32 ifTrue: [^ pixelValue].
	depth = 16
		ifTrue: [halfword _ pixelValue]
		ifFalse: [halfword _ pixelValue * 
					(#(16rFFFF				"replicates at every bit"
						16r5555 -			"replicates every 2 bits"
						16r1111 - - -			"replicates every 4 bits"
						16r0101) at: depth)	"replicates every 8 bits"].
	^ halfword bitOr: (halfword bitShift: 16)! !
!Color methodsFor: 'conversions'!
                               pixelWordForDepth: depth
	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."

	| pixelValue |
	pixelValue _ self pixelValueForDepth: depth.
	^ self pixelWordFor: depth filledWith: pixelValue
! !
!Color methodsFor: 'equality' stamp: 'jmv 6/18/2017 20:38:11'!
           diff: theOther
	"Returns a number between 0.0 and 1.0.
	Color gray diff: Color red
	"
	^(self - theOther ) abs sum / self size! !
!Color methodsFor: 'equality' stamp: 'KenD 12/8/2013 08:35'!
 rgbDistance: otherColor
	"Compare two colors in distance"
"
	^ (self hue - otherColor hue) abs +
	  (self saturation - otherColor saturation) abs *10 +
	  (self brightness - otherColor brightness) abs
"
	"See http://www.compuphase.com/cmetric.htm"
	| meanRed deltaRed deltaGreen deltaBlue |
	meanRed := (self red + otherColor red) abs / 2.
	deltaRed := (self red - otherColor red) abs.
	deltaGreen := (self green - otherColor green) abs.
	deltaBlue := (self blue - otherColor blue) abs.
	
	^ ( ((2 + (meanRed / 256)) * (deltaRed * deltaRed)) +
		(4 * deltaGreen) +
		((2 + ((255 - meanRed) / 256)) * deltaBlue)
	  ) sqrt! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
                     darkShades: thisMany
	"An array of thisMany colors from black to the receiver.  Array is of length num. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red darkShades: 12)"

	^ self class black mix: self shades: thisMany
! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
                lightShades: thisMany
	"An array of thisMany colors from white to self. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red lightShades: 12)"

	^ self class white mix: self shades: thisMany
! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
               mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Color r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45'!
          wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Color methodsFor: 'named colors' stamp: 'KenD 12/8/2013 14:59'!
           closestAssocFrom: aColorDict
	"Answer closest associated color in aColorDict"
"
	((Color r: 0.3 g: 0.2 b: 0.8) closestAssocFrom: (Color colorNamesDict)) explore.
"
	"Filter values for those close in hue (cheap test) then use rgbDistance"
	| closeInHue isClose close distance myHue |
	closeInHue := OrderedCollection new.
	myHue := self hue.
	isClose := [ :assoc | | delta |
		delta := ((assoc value hue) - myHue) abs.
		(delta < 20) or: [ delta > 340 ] "hues within 20 degrees"
	].
	aColorDict  associationsDo:  [ :assoc |
		(isClose value: assoc) ifTrue: [ closeInHue add: assoc ]
	].

	close := nil.
	distance := 1000. "big"
	(closeInHue size > 0)
		ifFalse: [ "fallback -- no color really close"
			aColorDict  associationsDo:  [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		]
		ifTrue: [ closeInHue do: [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		].
	
	^ close! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:33'!
                              closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
    closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/25/2013 14:31'!
                            closestColorFrom: aColorDict
	"Answer closest associated color"
"
	((Color lightBlue) closestColorFrom: (Color css2NamedColors)) explore..
"
	^(self closestAssocFrom: aColorDict) value! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
   closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
                closestNameFrom: aColorDict
	"Answer closest associated color name"
"
	((Color lightBlue) closestNameFrom: (Color namedColors)) print.
"
	^(self closestAssocFrom: aColorDict) key! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:41'!
                colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Color colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:46'!
          name
	"Return this color's name, or description if unnamed."

	^ self printString
! !
!Color methodsFor: 'printing' stamp: 'jmv 2/13/2014 13:41'!
              hexStringRGB
	"
	Color fromUser hexStringRGB
	"
	^String streamContents: [ :strm |
		(self red * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self green * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self blue * 255) rounded printOn: strm base: 16 length: 2 padded: true ]! !
!Color methodsFor: 'printing' stamp: 'KenD 7/18/2015 20:42'!
           printOn: aStream
	 self colorName ifNotNil: [ :name |
		^ aStream
			nextPutAll: 'Color ';
			nextPutAll: name].
	self storeOn: aStream.
! !
!Color methodsFor: 'printing' stamp: 'KenD 7/18/2015 20:44'!
                      printString
	"Answer a String whose characters are a description of the receiver."
	
	^ String streamContents: [ :stream | self printOn: stream ]! !
!Color methodsFor: 'printing' stamp: 'mir 7/21/1999 11:41'!
               storeArrayOn: aStream

	aStream nextPutAll: '#('.
	self storeArrayValuesOn: aStream.
	aStream nextPutAll: ') '
! !
!Color methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:04'!
                  storeArrayValuesOn: aStream


	self red printOn: aStream fractionDigits: 3.
	aStream space.
	self green printOn: aStream fractionDigits: 3.
	aStream space.
	self blue printOn: aStream fractionDigits: 3

! !
!Color methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:01'!
                      storeOn: aStream

	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPut: $)! !
!Color methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:55'!
    isBlack
	"Return true if the receiver represents black"
	(self at: 1) = 0.0 ifFalse: [ ^ false ].
	(self at: 2) = 0.0 ifFalse: [ ^ false ].
	(self at: 3) = 0.0 ifFalse: [ ^ false ].
	^ true! !
!Color methodsFor: 'queries' stamp: 'ar 4/20/2001 04:33'!
     isOpaque
	^true! !
!Color methodsFor: 'queries'!
               isTransparent

	^ false
! !
!Color methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:46'!
      isWhite
	"Return true if the receiver represents white"
	(self at: 1) = 1.0 ifFalse: [ ^ false ].
	(self at: 2) = 1.0 ifFalse: [ ^ false ].
	(self at: 3) = 1.0 ifFalse: [ ^ false ].
	^ true! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:35'!
 isBlue
	"Am I considered Blue?"

	^self blue > (self green + 0.3)
		and: [self blue > (self red + 0.3)]
			and: [(self green - self red) abs < 0.4]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:37'!
           isBlueGreen
	"Am I considered BlueGreen ?"

	^self green > self red 
		and: [self red < 0.3]
			and: [(self green - self blue) abs < 0.1]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:50'!
                     isBright
	"Am I considered a Bright color ?"

	^self brightness > 0.6! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:40'!
                         isBrown
	"Am I considered Brown ?"

	^self red >= self green  
		and: [self green > self blue]					
			and: [(self red - self green) < 0.5]	
				and: [(self green - self blue) < 0.3]! !
!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:14'!
         isCyan
	"Am I considered Cyan ?"

	^self red < 0.05 
		and: [(self green min: self blue) > 0.5]					
			and: [(self green - self blue) abs < 0.2]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:50'!
             isDark
	"Am I considered a Dark color ?"

	^self brightness < 0.5! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:42'!
                             isGray
	"Am I considered Gray  ?"

	^(self red closeTo: self green)
		and: [self blue closeTo: self green ]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:38'!
                   isGreen
	"Am I considered Green ?"

	^self green > (self blue + 0.3)
		and: [self blue > (self red + 0.3)]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:40'!
                    isGrey
	"Am I considered Grey  ?"

	^self isGray! !
!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:06'!
               isLight
	"Am I considered a Light color ?"

	^self brightness > 0.6! !
!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:13'!
                            isMagenta
	"Am I considered Magenta ?"

	^self green < 0.05 
		and: [(self red min: self blue) > 0.5]					
			and: [(self red - self blue) abs < 0.2]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:44'!
         isOrange
	"Am I considered Orange ?"

	^self red > ((self green max: self blue) + 0.2)  
		and: [self green > (self blue + 0.2)]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:45'!
                              isPastel
	"Am I considered Pastel ?"

	^self saturation < 0.4! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:46'!
 isPink
	"Am I considered Pink ?"

	^self red > ((self green max: self blue) + 0.3)  
		and: [self blue > (self green + 0.2)]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:47'!
  isRed
	"Am I considered Red ?"

	^self red > (self green + 0.4)
		and: [self red > (self blue + 0.6)]
			and: [(self green - self blue) abs < 0.4]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:55'!
            isSaturated
	"Am I considered to be a Saturated color ?"

	^self saturation > 0.6! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:49'!
             isYellow
	"Am I considered Yellow ?"

	^self blue < 0.05 
		and: [(self red min: self green) > 0.5]					
			and: [(self red - self green) abs < 0.2]! !
!Color methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!
             is: aSymbol
	^ aSymbol == #Color or: [ super is: aSymbol ]! !
!Color methodsFor: 'testing' stamp: 'jmv 2/10/2011 21:46'!
       mightBeTranslucent
	"For Colors, answer if actually translucent or not."
	^self isOpaque not! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:14'!
                          * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Color brown *2) display
	"
	^ (Color new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0))
			alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:18'!
                   + aColor
	"Answer this color mixed with the given color in an additive color space.  "
	"
	(Color blue + Color green) display
	"
	^ Color new
		setRed: (self red + aColor red min: 1.0 max: 0.0)
		green: (self green + aColor green min: 1.0 max: 0.0)
		blue: (self blue + aColor blue min: 1.0 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:22'!
          - aColor
	"Answer aColor is subtracted from the given color in an additive color space.  "
	"
	(Color white - Color red) display
	"
	^ Color new
		setRed: (self red - aColor red min: 1.0 max: 0.0)
		green: (self green - aColor green min: 1.0 max: 0.0)
		blue: (self blue - aColor blue min: 1.0 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:26'!
       / aNumber
	"Answer this color with its RGB divided by the given number. "
	"
	(Color red / 2) display
	"
	^ Color new
		setRed: (self red / aNumber min: 1.0 max: 0.0)
		green: (self green / aNumber min: 1.0 max: 0.0)
		blue: (self blue / aNumber min: 1.0 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:50'!
                 adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:51'!
                       adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:10:41'!
           alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifFalse: [
		^ TranslucentColor new
			setRed: self red
			green: self green
			blue: self blue
			alpha: alphaValue ]! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 11:55'!
                    alphaMixed: proportion with: aColor 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)
		alpha: self alpha * frac1 + (aColor alpha * frac2)! !
!Color methodsFor: 'transformations' stamp: 'RAA 6/2/2000 08:47'!
                      atLeastAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance < aFloat] whileTrue: [revisedColor _ revisedColor slightlyLighter].
	^revisedColor
! !
!Color methodsFor: 'transformations' stamp: 'nk 3/8/2004 09:43'!
          atMostAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance > aFloat] whileTrue: [revisedColor _ revisedColor slightlyDarker].
	^revisedColor
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!
          blacker

	^ self alphaMixed: 0.8333 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54'!
   dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Color h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:40'!
                            darker
	"Answer a darker shade of this color."

	^ self adjustBrightness: -0.08! !
!Color methodsFor: 'transformations' stamp: 'dew 3/8/2002 00:13'!
           duller

	^ self adjustSaturation: -0.03 brightness: -0.2! !
!Color methodsFor: 'transformations' stamp: 'dew 1/23/2002 20:19'!
 lighter
	"Answer a lighter shade of this color."

	^ self adjustSaturation: -0.03 brightness: 0.08! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:00'!
                         mixed: proportion with: aColor 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColor alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29'!
                           muchDarker

	^ self alphaMixed: 0.5 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07'!
     muchLighter

	^ self alphaMixed: 0.233 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36'!
 negated
	"Return an RGB inverted color"
	^Color
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:37:53'!
        orColorUnlike: theOther
	"If this color is a lot like theOther, then return its complement, otherwide, return self"

	^ (self diff: theOther) < 0.3
		ifTrue: [theOther negated]
		ifFalse: [self]! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:42'!
                        paler
	"Answer a paler shade of this color."

	^ self adjustSaturation: -0.09 brightness: 0.09
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:41'!
                          quiteBlacker

	^ self alphaMixed: 0.8 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:44'!
 quiteWhiter

	^ self alphaMixed: 0.6 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!
    slightlyDarker

	^ self adjustBrightness: -0.03
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!
          slightlyLighter

	^ self adjustSaturation: -0.01 brightness: 0.03! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25'!
                        slightlyWhiter

	^ self alphaMixed: 0.85 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 5/7/2012 15:05'!
                               twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:45'!
      twiceLighter
	"Answer a significantly lighter shade of this color."

	^ self adjustSaturation: -0.06 brightness: 0.15! !
!Color methodsFor: 'transformations' stamp: 'jmv 8/23/2009 23:24'!
    veryMuchDarker

	^ self alphaMixed: 0.25 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 7/28/2016 15:43:04'!
                           veryMuchLighter

	^ self alphaMixed: 0.07 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!
                              whiter

	^ self alphaMixed: 0.8333 with: Color white
! !
!Color methodsFor: 'private'!
         attemptToMutateError
	"A color is immutable. Once a color's red, green, and blue have been initialized, you cannot change them. Instead, create a new Color and use it."

	self error: 'Color objects are immutable once created'
! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:32'!
                            basicSetRed: r green: g blue: b
	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0]."

	self
		at: 1 put: r;
		at: 2 put: g;
		at: 3 put: b! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:44'!
          setHue: hue chroma: chroma brightness: brightness
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 
	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ brightness - ((r1 max: g1) max: b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:49'!
                              setHue: hue chroma: chroma luminance: luma
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 

	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ luma - (0.299*r1) - (0.587*g1) - (0.114*b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0 
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:16:07'!
                           setHue: hue saturation: saturation brightness: brightness
	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."

	| s v hf i f p q t | 
	s _ saturation asFloat min: 1.0 max: 0.0.
	v _ brightness asFloat min: 1.0 max: 0.0.
	hf _ hue \\ 360.
	i _ hf // 60.  			"integer part of hue"
	f _ (hf \\ 60) / 60.0.         	"fractional part of hue"

	p _ (1.0 - s) * v.
	q _ (1.0 - (s * f)) * v.
	t _ (1.0 - (s * (1.0 - f))) * v.

	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].
	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].
	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].
	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].
	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].
	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].

	self error: 'implementation error'! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:13:04'!
   setRed: r green: g blue: b

	self basicSetRed: r green: g blue: b! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:48'!
                             setRed: r green: g blue: b range: range
	"Initialize this color's r, g, and b components to the given values in the range [0..r]."

	self basicSetRed: r green: g blue: b.
	self /= range! !
!Color methodsFor: 'as yet unclassified' stamp: 'jmv 8/15/2015 18:23'!
                            color
	^ self! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 9/17/2015 15:22'!
    clipR: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0].
	Clip if necessary"

	^ self 
		r: (r min: 1.0 max: 0.0)
		g: (g min: 1.0 max: 0.0)
		b: (b min: 1.0 max: 0.0)! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 4/2/2016 23:05'!
 colorFrom: parm
	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"

	| aColor firstParm |
	(parm is: #Color) ifTrue: [ ^ parm ].
	parm isSymbol ifTrue: [ ^ self perform: parm ].
	(parm isSequenceableCollection and: [ parm size > 0 ])
		ifTrue: [
			firstParm _ parm first.
			firstParm isNumber ifTrue: [
				^ self fromRgbTriplet: parm].
			aColor _ self colorFrom: firstParm.
			parm withIndexDo: [ :sym :ind |
				ind > 1 ifTrue: [
					aColor _ aColor perform: sym ]].
			^ aColor].
	^ parm

"
Color colorFrom: #(blue darker)
Color colorFrom: Color blue darker
Color colorFrom: #blue
Color colorFrom: #(0.0 0.0 1.0)
"! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/2/2016 15:04'!
                       colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Color transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Color transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Color r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Color r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Color class methodsFor: 'instance creation' stamp: 'sqr 10/15/2016 20:41:04'!
       fromArray: colorDef

	| answer |
	colorDef size = 0 ifTrue: [^self transparent].
	colorDef size between: 3 and: 4 :: ifFalse: [self error: 'Undefined color definition'].
	answer _ self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3).
	^colorDef size = 3
		ifTrue: [answer]
		ifFalse: [answer alpha: (colorDef at: 4)]! !
!Color class methodsFor: 'instance creation' stamp: 'sw 8/8/97 22:03'!
             fromRgbTriplet: list
	^ self r: list first g: list second b: list last! !
!Color class methodsFor: 'instance creation' stamp: 'pb 10/16/2016 18:42:44'!
        fromString: aString
	"For HTML color spec: #FFCCAA. Also support named colors.
	See http://www.w3schools.com/cssref/css_colors_legal.asp"
	"
	Color fromString: '#FFCCAA'.
	Color fromString: 'white'.
	Color fromString: 'orange'
	Color fromString: 'rgb(255,0,98)'
	"
	(aString size = 7 and: [ aString first = $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU _ aString asUppercase.
		red _ ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green _ ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue _ ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].

	(aString beginsWith: 'rgb')
		ifTrue: [|values r g b|
				values := (aString allButFirst: 4) allButLast findTokens: ','.
				r  := (values first includes: $%)
						ifTrue: [(values first asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values first asInteger min: 255 max: 0) / 255.0].
				g := (values second includes: $%)
						ifTrue: [(values second asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values second asInteger min: 255 max: 0) / 255.0].
				b := (values third includes: $%)
						ifTrue: [(values third asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values third asInteger min: 255 max: 0) / 255.0].
				^self r: r g: g b: b].

	^self exactColorNamed: aString! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:29'!
                     gray: brightness
	"Return a gray shade with the given brightness in the range [0.0..1.0]."

	^ self new
		setRed: brightness
		green: brightness
		blue: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:31'!
           h: hue s: saturation v: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'dew 3/19/2002 23:49'!
              h: h s: s v: v alpha: alpha

	^ (self h: h s: s v: v) alpha: alpha! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:34'!
            hue: hue chroma: chroma brightness: brightness
	^self new setHue: hue chroma: chroma brightness: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:37'!
   hue: hue chroma: chroma luminance: luma
	^self new setHue: hue chroma: chroma luminance: luma! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:39'!
                 hue: hue saturation: saturation brightness: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:20'!
                       new
	^ self new: 3! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:41'!
                            r: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b! !
!Color class methodsFor: 'instance creation'!
 r: r g: g b: b alpha: alpha

	^ (self r: r g: g b: b) alpha: alpha! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:43'!
            r: r g: g b: b range: range
	"Return a color with the given r, g, and b components specified as integers in the range [0..r]. This avoids the floating point arithmetic in the red:green:blue: message and is thus a bit faster for certain applications (such as computing a sequence of colors for a palette)."

	^ self new setRed: r green: g blue: b range: range! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 4/4/2015 20:30'!
            random
	"Return a random color that isn't too dark or under-saturated.
		Display fill: (10@10 extent: 200@200) fillColor: Color random
	"

	^ Random withDefaultDo: [ :random |
		self random: random ]! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 4/4/2015 20:30'!
           random2
	"Return a random color with a distribution that spans over all possible colors.
		Display fill: (10@10 extent: 200@200) fillColor: Color random2
	"

	^ Random withDefaultDo: [ :random |
		self random2: random ]! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:46'!
                   random2: aRandom
	"Return a random color with a distribution that spans over all possible colors."

	^ self new
		setRed: aRandom next
		green: aRandom next
		blue: aRandom next! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:48'!
                             random: aRandom
	"Return a random color that isn't too dark or under-saturated."

	^ self new
		setHue: (360.0 * aRandom next)
		saturation: (0.3 + (aRandom next * 0.7))
		brightness: (0.4 + (aRandom next * 0.6))! !
!Color class methodsFor: 'class initialization' stamp: 'jmv 4/17/2015 15:06'!
                          initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollection new.
	grayIndices _ OrderedCollection new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation = 0.0 ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !
!Color class methodsFor: 'class initialization'!
                     initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Color r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Color r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
                    colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: i g: i b: i range: 255)].
	^ f
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:29:30'!
                              experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Color random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Color new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Color new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Color new setHue: h chroma: selectedChroma luminance: v.
"		color _ Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !
!Color class methodsFor: 'examples' stamp: 'tk 6/19/96'!
hotColdShades: thisMany
	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "
	"Color showColors: (Color hotColdShades: 25)"

	| n s1 s2 s3 s4 s5 |
	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].
	n _ thisMany // 5.
	s1 _ self white mix: self yellow shades: (thisMany - (n*4)).
	s2 _ self yellow mix: self red shades: n+1.
	s2 _ s2 copyFrom: 2 to: n+1.
	s3 _ self red mix: self green darker shades: n+1.
	s3 _ s3 copyFrom: 2 to: n+1.
	s4 _ self green darker mix: self blue shades: n+1.
	s4 _ s4 copyFrom: 2 to: n+1.
	s5 _ self blue mix: self black shades: n+1.
	s5 _ s5 copyFrom: 2 to: n+1.
	^ s1, s2, s3, s4, s5
! !
!Color class methodsFor: 'examples'!
                       showColorCube
	"Show a 12x12x12 color cube."
	"Color showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
       showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w _ Display width // colorList size.
	r _ 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		Display fill: r fillColor: c.
		r _ r translatedBy: w@0].
! !
!Color class methodsFor: 'examples'!
             showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Color class methodsFor: 'examples' stamp: 'jmv 1/14/2013 21:12'!
                        showHuesInteractively
	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."
	"Color showHuesInteractively"

	| p s v |
	[Sensor isAnyButtonPressed] whileFalse: [
		p _ Sensor mousePoint.
		s _ p x asFloat / 300.0.
		v _ p y asFloat / 300.0.
		self showColors: (self wheel: 12 saturation: s brightness: v)].
	^ (s min: 1.0) @ (v min: 1.0)! !
!Color class methodsFor: 'examples'!
    wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Color wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Color class methodsFor: 'examples'!
                      wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Color h: 0.0 s: s v: v) wheel: thisMany
! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
                   aqua

	^ self colorNamesDict at: #aqua! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
                beige

	^ self colorNamesDict at: #beige! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
              black

	^ self colorNamesDict at: #black! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
              blue

	^ self colorNamesDict at: #blue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
                brightGreen

	^ self colorNamesDict at: #brightGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
  brown

	^ self colorNamesDict at: #brown! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
              cyan

	^ self colorNamesDict at: #cyan! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
                darkBlue

	^ self colorNamesDict at: #darkBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        darkGray

	^ self colorNamesDict at: #darkGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        darkGreen

	^ self colorNamesDict at: #darkGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      darkPink

	^ self colorNamesDict at: #darkPink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        darkPurple

	^ self colorNamesDict at: #darkPurple! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
    forestGreen

	^ self colorNamesDict at: #forestGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
  gray

	^ self colorNamesDict at: #gray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
                green

	^ self colorNamesDict at: #green! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
              grey

	^ self colorNamesDict at: #grey! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
                hotPink

	^ self colorNamesDict at: #hotPink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
          indigo

	^ self colorNamesDict at: #indigo! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
            lavender

	^ self colorNamesDict at: #lavender! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        lightBlue

	^ self colorNamesDict at: #lightBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      lightBrown

	^ self colorNamesDict at: #lightBrown! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
    lightCyan

	^ self colorNamesDict at: #lightCyan! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      lightGray

	^ self colorNamesDict at: #lightGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      lightGreen

	^ self colorNamesDict at: #lightGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
    lightMagenta

	^ self colorNamesDict at: #lightMagenta! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
lightOrange

	^ self colorNamesDict at: #lightOrange! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
  lightPink

	^ self colorNamesDict at: #lightPink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
      lightPurple

	^ self colorNamesDict at: #lightPurple! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
  lightRed

	^ self colorNamesDict at: #lightRed! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
        lightYellow

	^ self colorNamesDict at: #lightYellow! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
  lilac

	^ self colorNamesDict at: #lilac! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              lime

	^ self colorNamesDict at: #lime! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
                limeGreen

	^ self colorNamesDict at: #limeGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
      magenta

	^ self colorNamesDict at: #magenta! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
          maroon

	^ self colorNamesDict at: #maroon! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
            mauve

	^ self colorNamesDict at: #mauve! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              mustard

	^ self colorNamesDict at: #mustard! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
          navyBlue

	^ self colorNamesDict at: #navyBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
        olive

	^ self colorNamesDict at: #olive! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              oliveGreen

	^ self colorNamesDict at: #oliveGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
    orange

	^ self colorNamesDict at: #orange! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
            paleGreen

	^ self colorNamesDict at: #paleGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
      peach

	^ self colorNamesDict at: #peach! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              periwinkle

	^ self colorNamesDict at: #periwinkle! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
    pink

	^ self colorNamesDict at: #pink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
                purple

	^ self colorNamesDict at: #purple! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
            red

	^ self colorNamesDict at: #red! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                  royalBlue

	^ self colorNamesDict at: #royalBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
      salmon

	^ self colorNamesDict at: #salmon! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
            seaGreen

	^ self colorNamesDict at: #seaGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
        skyBlue

	^ self colorNamesDict at: #skyBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
          tan

	^ self colorNamesDict at: #tan! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                  teal

	^ self colorNamesDict at: #teal! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                transparent

	^ self colorNamesDict at: #transparent! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
  turquoise

	^ self colorNamesDict at: #turquoise! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
      veryDarkGray

	^ self colorNamesDict at: #veryDarkGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
veryLightGray

	^ self colorNamesDict at: #veryLightGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                              veryVeryDarkGray

	^ self colorNamesDict at: #veryVeryDarkGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                        veryVeryLightGray

	^ self colorNamesDict at: #veryVeryLightGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                      violet

	^ self colorNamesDict at: #violet! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
            white

	^ self colorNamesDict at: #white! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
              yellow

	^ self colorNamesDict at: #yellow! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:49'!
               cachedColormapForGrayFrom: sourceDepth
	"Return a cached colormap for mapping from the given depth to the 8bpp grays. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex map |
	ToGrayColormaps ifNil: [
		ToGrayColormaps _ Array new: 5].
	
	srcIndex _ sourceDepth highBit min: 5.

	(ToGrayColormaps at: srcIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapForGray8bppFrom: sourceDepth.
	ToGrayColormaps at: srcIndex put: map.
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 14:50'!
                               cachedColormapFrom: sourceDepth to: destDepth
	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex dstIndex map |
	CachedColormaps
		ifNil: [CachedColormaps _ (1 to: 5) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit min: 5.
	dstIndex _ destDepth highBit.

	((CachedColormaps at: srcIndex) at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFrom: sourceDepth to: destDepth.
	(CachedColormaps at: srcIndex) at: dstIndex put: map.
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:49'!
     cachedColormapFromGrayTo: destDepth
	"Return a cached colormap for mapping from 8bpp grays to the given depth. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| dstIndex map |
	FromGrayColormaps
		ifNil: [FromGrayColormaps _ Array new: 6 ].

	dstIndex _ destDepth highBit.

	(FromGrayColormaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFromGray8bppForDepth: destDepth.
	FromGrayColormaps at: dstIndex put: map.
	^ map! !
!Color class methodsFor: 'colormaps'!
  colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Color cachedColormapFrom: sourceDepth to: destDepth
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 8/27/2009 08:47'!
   computeColorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color.
		Assumed not to include subpixelAA"
		^ self computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	] ifFalse: [
		"source is 16-bit or 32-bit RGB.
		Might include subpixelAA"
		^ self computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	]! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:55'!
          computeColormapForGray8bppFrom: sourceDepth
	"Compute a colorMap for translatingfrom the given depth to the 8bpp grays"
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [ :c | (c luminance * 255) rounded].
		map _ map as: Bitmap.
		^ map
		]
	ifFalse: [
		^ self computeRGBColormapForGray8 ]! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05'!
                              computeColormapFrom: sourceDepth to: destDepth
	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map bitsPerColor |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [:c | c pixelValueForDepth: destDepth].
		map _ map as: Bitmap.
	] ifFalse: [
		"source is 16-bit or 32-bit RGB"
		destDepth > 8
			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
			ifFalse: [bitsPerColor _ 4].
		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].

	"Note: zero is transparent except when source depth is one-bit deep"
	sourceDepth > 1 ifTrue: [map at: 1 put: 0].
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:56'!
                               computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Color gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05'!
 computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 12/26/2011 13:49'!
                               computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:10'!
                               computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:57'!
                              computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Color class methodsFor: 'other' stamp: 'jmv 1/31/2011 09:30'!
  maskingMap: depth
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."
	"Warning: The behavior is incorrect if depth = 32.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| sizeNeeded |
	depth <= 8
		ifTrue: [sizeNeeded _ 1 bitShift: depth]
		ifFalse: [sizeNeeded _ 4096].

	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:
		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.
		MaskingMap at: 1 put: 0.  "transparent"].

	^ MaskingMap
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 3/1/2010 15:13'!
                         colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 7/27/2009 11:32'!
               colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/26/2013 20:13'!
     colorNames
	"Answer the current dictionary of  name->color associations."

	^self colorNamesDict keys! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/28/2013 20:34'!
           defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Color r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Color r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Color r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Color r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Color r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 2/1/2013 14:39'!
                             doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Color colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/26/2013 20:51'!
             exactColorNamed: aColorName

	"Answer color matching name or nil 
	from my ColorName->Color Dictionary"
	
	^ self colorNamesDict at: (aColorName asSymbol) ifAbsent: [nil]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 7/25/2014 21:22'!
      setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Color defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Color class methodsFor: 'color name lookup' stamp: 'sqr 10/21/2016 12:44:48'!
             traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Color r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Color r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Color r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Color r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Color r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Color r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Color r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Color r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Color r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Color r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Color class methodsFor: 'color name lookup' stamp: 'jmv 6/30/2014 15:22'!
               xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Color fromString: '#ffd1df') ;
	at: #mustard put: (Color fromString: '#ceb301') ;
	at: #indigo put: (Color fromString: '#380282') ;
	at: #lime put: (Color fromString: '#aaff32') ;
	at: #seaGreen put: (Color fromString: '#53fca1') ;
	at: #periwinkle put: (Color fromString: '#8e82fe') ;
	at: #darkPink put: (Color fromString: '#cb416b') ;
	at: #oliveGreen put: (Color fromString: '#677a04') ;
	at: #peach put: (Color fromString: '#ffb07c') ;
	at: #paleGreen put: (Color fromString: '#c7fdb5') ;
	at: #lightBrown put: (Color fromString: '#ad8150') ;
	at: #hotPink put: (Color fromString: '#ff028d') ;
	at: #black put: (Color fromString: '#000000') ;
	at: #lilac put: (Color fromString: '#cea2fd') ;
	at: #navyBlue put: (Color fromString: '#001146') ;
	at: #royalBlue put: (Color fromString: '#0504aa') ;
	at: #beige put: (Color fromString: '#e6daa6') ;
	at: #salmon put: (Color fromString: '#ff796c') ;
	at: #olive put: (Color fromString: '#6e750e') ;
	at: #maroon put: (Color fromString: '#650021') ;
	at: #brightGreen put: (Color fromString: '#01ff07') ;
	at: #darkPurple put: (Color fromString: '#35063e') ;
	at: #mauve put: (Color fromString: '#ae7181') ;
	at: #forestGreen put: (Color fromString: '#06470c') ;
	at: #aqua put: (Color fromString: '#13eac9') ;
	at: #cyan put: (Color fromString: '#00ffff') ;
	at: #tan put: (Color fromString: '#d1b26f') ;
	at: #darkBlue put: (Color fromString: '#00035b') ;
	at: #lavender put: (Color fromString: '#c79fef') ;
	at: #turquoise put: (Color fromString: '#06c2ac') ;
	at: #darkGreen put: (Color fromString: '#033500') ;
	at: #violet put: (Color fromString: '#9a0eea') ;
	at: #lightPurple put: (Color fromString: '#bf77f6') ;
	at: #limeGreen put: (Color fromString: '#89fe05') ;
	at: #grey put: (Color fromString: '#929591') ;
	at: #skyBlue put: (Color fromString: '#75bbfd') ;
	at: #yellow put: (Color fromString: '#ffff14') ;
	at: #magenta put: (Color fromString: '#c20078') ;
	at: #lightGreen put: (Color fromString: '#96f97b') ;
	at: #orange put: (Color fromString: '#f97306') ;
	at: #teal put: (Color fromString: '#029386') ;
	at: #lightBlue put: (Color fromString: '#95d0fc') ;
	at: #red put: (Color fromString: '#e50000') ;
	at: #brown put: (Color fromString: '#653700') ;
	at: #pink put: (Color fromString: '#ff81c0') ;
	at: #blue put: (Color fromString: '#0343df') ;
	at: #green put: (Color fromString: '#15b01a') ;
	at: #purple put: (Color fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:26'!
      blueColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueColorDict explore.
"
	^self blueColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:24'!
     blueColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlue)
				or: [assoc key asString asLowercase includesSubString: 'blue'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:28'!
                   blueGreenColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueGreenColorDict explore.
"
	^self blueGreenColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:29'!
                      blueGreenColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlueGreen)
				or: [assoc key asString asLowercase includesSubString: 'bluegreen'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:31'!
    brightColorDict
	"Answer a dictionary of named colors considered Bright"
"
	Color brightColorDict explore.
"
	^self brightColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:31'!
                             brightColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isBright) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:34'!
                     brownColorDict
	"Answer a dictionary of named colors considered Brown"
"
	Color brownColorDict explore.
"
	^self brownColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:33'!
 brownColorDict: aColorDict
	"Answer a dictionary of named colors considered Brown"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBrown)
				or: [assoc key asString asLowercase includesSubString: 'brown'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:36'!
               darkColorDict
	"Answer a dictionary of named colors considered Dark"
"
	Color darkColorDict explore.
"
	^self darkColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:37'!
     darkColorDict: aColorDict
	"Answer a dictionary of named colors considered Dark"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isDark) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:41'!
                           grayColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:38'!
                   greenColorDict
	"Answer a dictionary of named colors considered Green"
"
	Color greenColorDict explore.
"
	^self greenColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:38'!
 greenColorDict: aColorDict
	"Answer a dictionary of named colors considered Green"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGreen)
				or: [assoc key asString asLowercase includesSubString: 'green'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:41'!
               greyColorDict
	"Answer a dictionary of named colors considered Grey"
"
	Color greyColorDict explore.
"
	^self greyColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:40'!
     greyColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:44'!
                   lightColorDict
	"Answer a dictionary of named colors considered light"
"
	Color lightColorDict explore.
"
	^self lightColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:43'!
 lightColorDict: aColorDict
	"Answer a dictionary of named colors considered Liight"

	^self brightColorDict: aColorDict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:46'!
 orangeColorDict
	"Answer a dictionary of named colors considered Orange"
"
	Color orangeColorDict explore.
"
	^self orangeColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:46'!
                             orangeColorDict: aColorDict
	"Answer a dictionary of named colors considered Orange"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isOrange)
				or: [assoc key asString asLowercase includesSubString: 'orange'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:48'!
           pastelColorDict
	"Answer a dictionary of named colors considered Pastel"
"
	Color pastelColorDict explore.
"
	^self pastelColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:48'!
                             pastelColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isPastel) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:50'!
                     pinkColorDict
	"Answer a dictionary of named colors considered Pink"
"
	Color pinkColorDict explore.
"
	^self pinkColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:50'!
     pinkColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isPink)
				or: [assoc key asString asLowercase includesSubString: 'pink'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:52'!
                   purpleColorDict
	"Answer a dictionary of named colors considered Purple"
"
	Color purpleColorDict explore.
"
	^self purpleColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:52'!
                             purpleColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc key asString asLowercase includesSubString: 'purple')
				or: [assoc key asString asLowercase includesSubString: 'violet'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:54'!
       redColorDict
	"Answer a dictionary of named colors considered Red"
"
	Color redColorDict explore.
"
	^self redColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:53'!
         redColorDict: aColorDict
	"Answer a dictionary of named colors considered Red"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isRed)
				or: [assoc key asString asLowercase includesSubString: 'red'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:56'!
                       saturatedColorDict
	"Answer a dictionary of named colors considered Saturated"
"
	Color saturatedColorDict explore.
"
	^self saturatedColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:55'!
                 saturatedColorDict: aColorDict
	"Answer a dictionary of named colors considered Saturated"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isSaturated) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:26'!
            yellowColorDict
	"Answer a dictionary of named colors considered Yellow"
"
	Color yellowColorDict explore.
"
	^self yellowColorDict: (self colorNamesDict)! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:19'!
                              yellowColorDict: aColorDict
	"Answer a dictionary of named colors considered Yellow"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isYellow)
				or: [assoc key asString asLowercase includesSubString: 'yellow'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:55'!
                              applySimpleGamma: gamma to: value
	"Encode / decode Gamma. Typical gamma are 0.4545 ( = 1.0 / 2.2, for encoding) and 2.2 (for decoding)
	In a non gamma encoded image, the pixel values are proportional to luminance, i.e. the actual light intensity, the photon count.
	In an gamma encoded image, the pixel value is close to the average perceived brightness, or 'lightness'. This optimizes the use of available bits in digital images, and dynamic range in analog images and film. This is like the 'luma' signal in video.

	Usually:
		- Images stored in file formats such as jpg, png, tiff and bmp are gamma encoded
				(unless they are actually raw images).
		- Images sent to a framebuffer (video memory) should be gamma encoded.
		- Raw images from sensors are not gamma encoded.

		- Image processing algorithms that simulate the real world, or are applied to real world data should work on unencoded (linear) images.
				This includes filtering, resizing, blending, and most operations done on images.
				This means that if the images come from jpg photos from a camera, they should be gamma decoded.
		- Image processing algorithms that works on human perception should work on gamma encoded images.
				This includes histograms, histogram equalization, bit allocation (i.e. quantization), compression, etc.
				This also includes detecting objects like a human would do
				

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html

	Mostly for documentation.
	value must be in [0.0 .. 1.0].
	Note that the sRGB standard specifies a function that is close to this, but slightly different.
	See #linearTosRGBGamma: and #sRGBGammaToLinear:"

	^ value raisedTo: gamma! !
!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:49'!
            linearTosRGBGamma: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from linearSpace to gammaSpace, i.e. it 'encodes' with gamma.
	This is the operation done when producing an 8bit Form for displaying, or for saving on a JPG, PNG, etc; if source data is in linear space (for example, from raw data a sensor image, or data that was converted previously to linear space for proper image processing).
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	
	| r v |
	r _ Random new.
	1000 timesRepeat: [
		v _ r next.
		self assert: ((Color sRGBGammaToLinear: (Color linearTosRGBGamma: v)) closeTo: v) ]

	| r |
	r _ 10@10 extent: 600@400.
	Display fill: r fillColor: Color white.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color linearTosRGBGamma: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 1/2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color sRGBGammaToLinear: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	"

	^ value <= 0.00313066844250063
		ifTrue: [ value * 12.92 ]
		ifFalse: [ (value raisedTo: 1.0/2.4) * 1.055 - 0.055 ]! !
!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:50'!
                sRGBGammaToLinear: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from gammaSpace to linearSpace, i.e. it 'decodes'.
	This is the operation done by display screens. It is also needed to convert 8bit Forms (from a frameBuffer, or from PNG, JPG, etc.) to linear space for proper image processing.
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	"

	^ value <= 0.0404482362771082
		ifTrue: [ value / 12.92 ]
		ifFalse: [ value + 0.055 / 1.055 raisedTo: 2.4 ]! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 14:58'!
                            colorNamesDict
	"Answer the current dictionary of  name->color associations."
"
	Color colorNamesDict explore.
"
	ColorNamesDict ifNil: [
		self setColorNamesDict: self defaultColorNamesDictionary ].
	^ColorNamesDict! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 15:08'!
                       grayToIndexMap
	"
	Color grayToIndexMap explore.
	"
	GrayToIndexMap ifNil: [
		self initializeGrayToIndexMap ].
	^GrayToIndexMap! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 15:04'!
               indexedColors
	"
	Color indexedColors explore.
	"
	IndexedColors ifNil: [
		self initializeIndexedColors ].
	^IndexedColors! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 5/12/2016 14:58'!
                    releaseClassCachedState
	"
	Color releaseClassCachedState
	"
	CachedColormaps _ nil. 		"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	ColorNamesDict _ nil.
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !
!TranslucentColor methodsFor: 'accessing' stamp: 'jmv 6/18/2017 20:41:17'!
                         alpha
	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."

	^ self at: 4! !
!TranslucentColor methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:06'!
         storeArrayValuesOn: aStream

	self isTransparent ifTrue: [
		^ aStream space].
	super storeArrayValuesOn: aStream.
	aStream space.
	self alpha printOn: aStream fractionDigits: 3! !
!TranslucentColor methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:20'!
     storeOn: aStream

	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].
	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' alpha: '.
	self alpha printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ')'! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:55:03'!
                     alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifTrue: [
		^ Color new
			setRed: self red
			green: self green
			blue: self blue].
	^ super alpha: alphaValue! !
!TranslucentColor methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!
                 asNontranslucentColor
	^ self alpha: 1.0! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 4/19/2013 16:10'!
          bitPatternForDepth: depth
	"Return an appropriate bit pattern. This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."

	self isTransparent ifTrue: [
		^ Bitmap with: 0].
	^ super bitPatternForDepth: depth! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:47'!
               pixelValueForDepth: d
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."
	| basicPixelWord |
	"In 32bpp, if alpha = 0, ignore any color components, and answer R=0, G=0, B=0, Alpha=0.
	In depths > 8 and < 32, pixelValue zero is the special value used by BitBlt to denote transparent."
	self isTransparent ifTrue: [
		^ 0].
	basicPixelWord _ super pixelValueForDepth: d.
	^d < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:50'!
                            pixelWordForDepth: depth
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."

	| basicPixelWord |
	self isTransparent ifTrue: [^ 0].
	basicPixelWord _ super pixelWordForDepth: depth.
	^depth < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColor methodsFor: 'private' stamp: 'jmv 6/18/2017 20:42:05'!
                       setRed: r green: g blue: b alpha: alphaValue

	self basicSetRed: r green: g blue: b.
	self at: 4 put: alphaValue! !
!TranslucentColor methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:26'!
   isOpaque

	^self alpha = 1.0! !
!TranslucentColor methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:54'!
                       isTransparent
	^ self alpha = 0.0! !
!TranslucentColor class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:35'!
  new
	^ self new: 4! !
!TranslucentColor class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:57:08'!
                 r: r g: g b: b alpha: alphaValue
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b
		alpha: alphaValue! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3110-CallItColorAgain-JuanVuletich-2017Jun19-11h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3109] on 19 June 2017 at 12:07:06 pm'!
!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04' prior: 50348249!
                 asColorOfDepth: d
	"Return a color value representing the receiver as color of the given depth"
	^Color colorFromPixelValue: self depth: d! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 9/2/2016 11:08:09' prior: 50348257!
                              kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char _ nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char _ self keyboard.
		Display fill: (5@5 extent: 400@20) fillColor: Color white.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char numericValue;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])
		displayAt: 10 @ 10 ].! !
!String methodsFor: 'displaying' stamp: 'jmv 5/12/2015 15:52' prior: 50348295!
                              displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: Color black
	"
	'Display' displayOn: Display at: 10@10
	"! !
!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25' prior: 50353443!
                             makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Color black]
                ifFalse: [Color white]! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96' prior: 50353623!
                            mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Color r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45' prior: 50353648!
                          wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:33' prior: 50353705!
                           closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 50353713!
                    closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 50353730!
            closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Color colorNamesDict)! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:41' prior: 50353747!
       colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Color colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:50' prior: 50353994!
                 adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:51' prior: 50354005!
       adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 11:55' prior: 50354028!
alphaMixed: proportion with: aColor 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)
		alpha: self alpha * frac1 + (aColor alpha * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 50354068!
     blacker

	^ self alphaMixed: 0.8333 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54' prior: 50354072!
                   dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Color h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:00' prior: 50354098!
             mixed: proportion with: aColor 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColor alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29' prior: 50354116!
           muchDarker

	^ self alphaMixed: 0.5 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07' prior: 50354120!
                     muchLighter

	^ self alphaMixed: 0.233 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36' prior: 50354124!
                 negated
	"Return an RGB inverted color"
	^Color
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:41' prior: 50354145!
                           quiteBlacker

	^ self alphaMixed: 0.8 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:44' prior: 50354149!
                 quiteWhiter

	^ self alphaMixed: 0.6 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25' prior: 50354162!
                   slightlyWhiter

	^ self alphaMixed: 0.85 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 8/23/2009 23:24' prior: 50354179!
              veryMuchDarker

	^ self alphaMixed: 0.25 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 7/28/2016 15:43:04' prior: 50354184!
           veryMuchLighter

	^ self alphaMixed: 0.07 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 50354189!
              whiter

	^ self alphaMixed: 0.8333 with: Color white
! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/2/2016 15:04' prior: 50354382!
             colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Color transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Color transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Color r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Color r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Color class methodsFor: 'class initialization' stamp: '' prior: 50354713!
           initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Color r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Color r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48' prior: 50354782!
    colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: i g: i b: i range: 255)].
	^ f
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354886!
    showColorCube
	"Show a 12x12x12 color cube."
	"Color showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354906!
          showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354943!
                           wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Color wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354951!
                            wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Color h: 0.0 s: s v: v) wheel: thisMany
! !
!Color class methodsFor: 'colormaps' stamp: '' prior: 50355351!
                         colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Color cachedColormapFrom: sourceDepth to: destDepth
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:56' prior: 50355466!
                   computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Color gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05' prior: 50355477!
                 computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 12/26/2011 13:49' prior: 50355499!
               computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:10' prior: 50355559!
               computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:57' prior: 50355601!
              computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Color class methodsFor: 'color from user' stamp: 'jmv 3/1/2010 15:13' prior: 50355667!
         colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 7/27/2009 11:32' prior: 50355724!
                               colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/28/2013 20:34' prior: 50355812!
                     defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Color r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Color r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Color r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Color r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Color r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 2/1/2013 14:39' prior: 50355838!
             doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Color colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 7/25/2014 21:22' prior: 50355856!
                             setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Color defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Color class methodsFor: 'color name lookup' stamp: 'sqr 10/21/2016 12:44:48' prior: 50355874!
                             traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Color r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Color r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Color r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Color r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Color r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Color r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Color r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Color r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Color r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Color r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Color class methodsFor: 'color name lookup' stamp: 'jmv 6/30/2014 15:22' prior: 50355931!
                               xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Color fromString: '#ffd1df') ;
	at: #mustard put: (Color fromString: '#ceb301') ;
	at: #indigo put: (Color fromString: '#380282') ;
	at: #lime put: (Color fromString: '#aaff32') ;
	at: #seaGreen put: (Color fromString: '#53fca1') ;
	at: #periwinkle put: (Color fromString: '#8e82fe') ;
	at: #darkPink put: (Color fromString: '#cb416b') ;
	at: #oliveGreen put: (Color fromString: '#677a04') ;
	at: #peach put: (Color fromString: '#ffb07c') ;
	at: #paleGreen put: (Color fromString: '#c7fdb5') ;
	at: #lightBrown put: (Color fromString: '#ad8150') ;
	at: #hotPink put: (Color fromString: '#ff028d') ;
	at: #black put: (Color fromString: '#000000') ;
	at: #lilac put: (Color fromString: '#cea2fd') ;
	at: #navyBlue put: (Color fromString: '#001146') ;
	at: #royalBlue put: (Color fromString: '#0504aa') ;
	at: #beige put: (Color fromString: '#e6daa6') ;
	at: #salmon put: (Color fromString: '#ff796c') ;
	at: #olive put: (Color fromString: '#6e750e') ;
	at: #maroon put: (Color fromString: '#650021') ;
	at: #brightGreen put: (Color fromString: '#01ff07') ;
	at: #darkPurple put: (Color fromString: '#35063e') ;
	at: #mauve put: (Color fromString: '#ae7181') ;
	at: #forestGreen put: (Color fromString: '#06470c') ;
	at: #aqua put: (Color fromString: '#13eac9') ;
	at: #cyan put: (Color fromString: '#00ffff') ;
	at: #tan put: (Color fromString: '#d1b26f') ;
	at: #darkBlue put: (Color fromString: '#00035b') ;
	at: #lavender put: (Color fromString: '#c79fef') ;
	at: #turquoise put: (Color fromString: '#06c2ac') ;
	at: #darkGreen put: (Color fromString: '#033500') ;
	at: #violet put: (Color fromString: '#9a0eea') ;
	at: #lightPurple put: (Color fromString: '#bf77f6') ;
	at: #limeGreen put: (Color fromString: '#89fe05') ;
	at: #grey put: (Color fromString: '#929591') ;
	at: #skyBlue put: (Color fromString: '#75bbfd') ;
	at: #yellow put: (Color fromString: '#ffff14') ;
	at: #magenta put: (Color fromString: '#c20078') ;
	at: #lightGreen put: (Color fromString: '#96f97b') ;
	at: #orange put: (Color fromString: '#f97306') ;
	at: #teal put: (Color fromString: '#029386') ;
	at: #lightBlue put: (Color fromString: '#95d0fc') ;
	at: #red put: (Color fromString: '#e50000') ;
	at: #brown put: (Color fromString: '#653700') ;
	at: #pink put: (Color fromString: '#ff81c0') ;
	at: #blue put: (Color fromString: '#0343df') ;
	at: #green put: (Color fromString: '#15b01a') ;
	at: #purple put: (Color fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/25/2016 15:31' prior: 50348307!
                  reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 7/28/2015 08:26' prior: 50348378!
                        endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			0@0 + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (4@4 + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 50348412!
             black
	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].
	^ Color black! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 50348418!
  white
	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].
	^ Color white! !
!DataStream class methodsFor: 'as yet unclassified' stamp: '' prior: 50348424!
            example
    "An example and test of DataStream/ReferenceStream.
     11/19/92 jhm: Use self testWith:."
    "DataStream example"
    "ReferenceStream example"
    | input sharedPoint |

    "Construct the test data."
    input _ Array new: 9.
    input at: 1 put: nil.
    input at: 2 put: true.
    input at: 3 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 3) fillWithColor: Color lightBlue.
    input at: 4 put: #(3 3.0 'three').
    input at: 5 put: false.
    input at: 6 put: 1024 @ -2048.
    input at: 7 put: #x.
    input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
    input at: 9 put: sharedPoint.

    "Write it out, read it back, and return it for inspection."
    ^ self testWith: input! !
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: '' prior: 50348450!
                               example2
"Here is the way to use DataStream and ReferenceStream:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	rr nextPut: <your object>.
	rr close.

To get it back:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	<your object> _ rr next.
	rr close.
"
"An example and test of DataStream/ReferenceStream.
	 11/19/92 jhm: Use self testWith:."
	"ReferenceStream example2"
	| input sharedPoint |

	"Construct the test data."
	input _ Array new: 9.
	input at: 1 put: nil.
	input at: 2 put: true.
	input at: 3 put: false.
	input at: 4 put: #(-4 -4.0 'four' four).
	input at: 5 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 5) fillWithColor: Color lightOrange.
	input at: 6 put: 1024 @ -2048.
	input at: 7 put: input. "a cycle"
	input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
	input at: 9 put: sharedPoint.

	"Write it out, read it back, and return it for inspection."
	^ self testWith: input
! !
!TextEditor methodsFor: 'attributes' stamp: 'jmv 12/12/2014 15:53' prior: 50348482!
                               offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel _ self selection.
	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index _ (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array with: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute _ TextColor color: (Color perform: (colors at: index)) ]
		ifFalse: [
			index _ index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute _ self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	^ true.! !
!TextAction class methodsFor: 'as yet unclassified' stamp: 'jmv 4/19/2015 09:38' prior: 50348510!
textActionColor
	^Color r: 0.4 g: 0 b: 1.0! !
!TextColor methodsFor: 'testing' stamp: 'jmv 1/21/2011 11:33' prior: 50348514!
   isSet
	"Do not include Color black, as it is the default color."
	^color ~= Color black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348520!
 black
	^ self new color: Color black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348524!
                    blue
	^ self new color: Color blue! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348528!
                      cyan
	^ self new color: Color cyan! !
!TextColor class methodsFor: 'constants' stamp: 'ajh 9/10/2002 02:26' prior: 50348532!
   gray
	^ self new color: Color gray! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348536!
                      green
	^ self new color: Color green! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348540!
                    magenta
	^ self new color: Color magenta! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348544!
                red
	^ self new color: Color red! !
!TextColor class methodsFor: 'constants' stamp: 'sma 3/24/2000 10:50' prior: 50348548!
     white 
	^ self new color: Color white! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348552!
                   yellow
	^ self new color: Color yellow! !
!Preferences class methodsFor: 'halos' stamp: 'jmv 4/20/2015 16:17' prior: 50348557!
 installHaloSpecsFromArray: anArray

	| aColor |
	^ self parameters at: #HaloSpecs put: (anArray collect: [ :each |
				aColor _ Color.
				each fourth do: [ :sel | aColor _ aColor perform: sel].
				HaloSpec new 
					horizontalPlacement: each second
					verticalPlacement: each third 
					color: aColor
					iconSymbol: each fifth
					addHandleSelector: each first
					hoverHelp: each sixth])! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:45:55' prior: 50348573!
                   displayOn: aForm in: aRectangle
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f canvas innerR |
	aForm fill: aRectangle fillColor: Color white.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	fh _ font height.
	count _ innerR height // fh-1.
	x _ innerR left.
	y _ innerR top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	[
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: Color veryDarkGray.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: Color veryDarkGray! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:53:35' prior: 50348602!
                       displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas r innerR |
	innerR _ bounds insetBy: self padding.
	lastDisplayPosition < innerR right ifTrue: [
		font _ AbstractFont default.
		fh _ font height.
		count _ innerR height // fh-1.
		x _ innerR left.
		string _ unfinishedEntry contents.
		y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerR top.
		canvas _ aForm getCanvas.
		r _ innerR left: lastDisplayPosition.
		canvas newClipRect: r.
		(canvas drawString: string at: x@y font: font color: Color veryDarkGray) ifNotNil: [ :lastPoint |
			lastDisplayPosition _ lastPoint x.
			^r ]].
	^nil! !
!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40' prior: 50348625!
         dominantColor
	| tally max maxi |
	self depth > 16 ifTrue:
		[^(self asFormOfDepth: 16) dominantColor].
	tally _ self tallyPixelValues.
	max _ maxi _ 0.
	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].
	^ Color colorFromPixelValue: maxi - 1 depth: self depth! !
!Form methodsFor: 'bordering' stamp: 'jmv 1/22/2015 10:22' prior: 50348637!
                            border: aRectangle width: borderWidth 
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses black for 
	drawing the border."

	self border: aRectangle width: borderWidth fillColor: Color black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348648!
        fillBlack
	"Set all bits in the receiver to black (ones)."

	self fill: self boundingBox fillColor: Color black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348654!
  fillBlack: aRectangle 
	"Set all bits in the receiver's area defined by aRectangle to black (ones)."

	self fill: aRectangle rule: Form over fillColor: Color black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348662!
              fillGray
	"Set all bits in the receiver to gray."

	self fill: self boundingBox fillColor: Color gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348668!
            fillGray: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to the gray mask."

	self fill: aRectangle rule: Form over fillColor: Color gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348676!
                fillWhite
	"Set all bits in the form to white."

	self fill: self boundingBox fillColor: Color white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348682!
             fillWhite: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to white."

	self fill: aRectangle rule: Form over fillColor: Color white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348690!
                      reverse
	"Change all the bits in the receiver that are white to black, and the ones 
	that are black to white.
	Display reverse
	"

	self fill: self boundingBox rule: Form reverse fillColor: Color white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348699!
       reverse: aRectangle
	"Change all the bits in the receiver's area that intersects with aRectangle 
	that are white to black, and the ones that are black to white."

	self fill: aRectangle rule: Form reverse fillColor: Color white! !
!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:42' prior: 50348709!
         colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	self depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"
	^ Color colorMapIfNeededFrom: self depth to: destDepth
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 5/12/2016 13:53' prior: 50348721!
                           colormapIfNeededForGray8bpp
	"Return a colormap for displaying the receiver at the given depth.
	Note: Uses 5 bits per color component. 32bit Forms will lose information!!"

	^ Color cachedColormapForGrayFrom: self depth! !
!Form methodsFor: 'color mapping' stamp: 'jmv 9/23/2012 21:42' prior: 50348731!
                mapColor: oldColor to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Color cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: 0@0;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 1/31/2011 09:21' prior: 50348753!
             maskingMap
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."
	^Color maskingMap: self depth! !
!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28' prior: 50348776!
               as8BitColorForm
	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."

	| f map |
	f _ ColorForm extent: self extent depth: 8.
	self displayOn: f at: self offset negated.
	map _ Color indexedColors copy.
	map at: 1 put: Color transparent.
	f colors: map.
	f offset: self offset.
	^ f
! !
!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:42' prior: 50348789!
                               colorAt: aPoint
	"Return the color in the pixel at the given point.  "

	^ Color 
		colorFromPixelValue: (self pixelValueAt: aPoint)
		depth: self depth
! !
!Form methodsFor: 'pixel access' stamp: 'jmv 11/4/2015 12:40' prior: 50348797!
                    colorInterpolatedAt: aPoint
	"Evaluate a bilinear (i.e. cheap) interpolation
	Like OpenCV's CV_INTER_LINEAR
	Answer Color transparent if outside image bounds.
	Copied almost verbatim from FloatImage.
	Answer Colors with float components. Will be rounded to be stored in, for example, a 32-bit Form."

	| x y w interpolated xWeight1 xWeight0 yWeight1 yWeight0 xIndex0 xIndex1 yIndex0 yIndex1 |
	x _ aPoint x.
	y _ aPoint y.
	x < 0.0 ifTrue: [ ^Color transparent ].
	xIndex0 _ x truncated. 		"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	xIndex0 > (width-1) ifTrue: [ ^Color transparent ].
	(xIndex0 = (width-1) and: [ x > (width-1) ]) ifTrue: [ ^Color transparent ].
	xIndex1 _ xIndex0 = (width-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ xIndex0 + 1 ]
		ifTrue: [ xIndex0 ].

	y < 0.0 ifTrue: [ ^Color transparent ].
	yIndex0 _ y truncated.			"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	yIndex0 > (height-1) ifTrue: [ ^Color transparent ].
	(yIndex0 = (height-1) and: [ y > (height-1) ]) ifTrue: [ ^Color transparent ].
	yIndex1 _ yIndex0 = (height-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ yIndex0 + 1 ]
		ifTrue: [ yIndex0 ].

	xWeight1 _ x - xIndex0.
	xWeight0 _ 1.0 - xWeight1.

	yWeight1 _ y - yIndex0.
	yWeight0 _ 1.0 - yWeight1.

	"/* perform interpolation */"
	w _ ((self colorAt: xIndex0 @ yIndex0) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex0) * xWeight1).
	interpolated _ w * yWeight0.

	w _ ((self colorAt: xIndex0 @ yIndex1) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex1) * xWeight1).
	interpolated _ w * yWeight1 + interpolated.

	^interpolated! !
!Form methodsFor: 'transitions' stamp: 'jmv 7/28/2015 08:32' prior: 50348856!
           pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 9/23/2012 21:44' prior: 50348927!
              dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).	
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Color black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'instance creation' stamp: 'pb 5/4/2016 17:43' prior: 50348966!
                        fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb _ GrafPort toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect _ aPoint extent: diameter.
	bb fillOval: rect.
	p _ (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: (Color white alpha: 0.3).
		d _ i * diameter // 10.
		rect _ Rectangle
			center: p
			extent: d.
		bb fillOval: rect ].
	DisplayScreen screenUpdateRequired: nil.
"
	Form fakeSphereAt: 50@50 diameter: 30 color:  (Color red alpha: 0.5)
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 3/20/2013 22:36' prior: 50348989!
                            toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Color red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: -40@-40].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:37' prior: 50349026!
   bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:47' prior: 50349054!
 bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:38' prior: 50349085!
               bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomRight corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:41' prior: 50349112!
           bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:34' prior: 50349143!
                         topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:36' prior: 50349170!
                             topRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topRight corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (x @ (w - y - 1)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45' prior: 50349196!
                    colors: colorList
	"Set my color palette to the given collection."

	| colorArray colorCount newColors |
	colorList ifNil: [
		colors _ cachedDepth _ cachedColormap _ nil.
		^ self].

	colorArray _ colorList asArray.
	colorCount _ colorArray size.
	newColors _ Array new: (1 bitShift: self depth).
	1 to: newColors size do: [:i |
		i <= colorCount
			ifTrue: [newColors at: i put: (colorArray at: i)]
			ifFalse: [newColors at: i put: Color transparent]].

	colors _ newColors.
	cachedDepth _ nil.
	cachedColormap _ nil.
! !
!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20' prior: 50349216!
                         asGrayScale
	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"
	^ self copy colors:
		(colors collect:
			[:c | c isTransparent ifTrue: [c]
						ifFalse: [Color gray: c luminance]])! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 3/1/2010 09:41' prior: 50349226!
   colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	| newMap |
	colors ifNil: [
		"use the standard colormap"
		^ Color colorMapIfNeededFrom: self depth to: destDepth].

	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 
		ifTrue: [^ cachedColormap].
	newMap _ Bitmap new: colors size.
	1 to: colors size do: [:i |
		newMap
			at: i
			put: ((colors at: i) pixelValueForDepth: destDepth)].

	cachedDepth _ destDepth.
	^ cachedColormap _ newMap.
! !
!ColorForm methodsFor: 'private' stamp: 'ar 5/17/2001 15:44' prior: 50349246!
            ensureColorArrayExists
	"Return my color palette."

	colors ifNil: [
		self depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].
		self colors: (Color indexedColors copyFrom: 1 to: (1 bitShift: self depth))].
! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 4/10/2015 23:20' prior: 50349257!
              mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: 0@0
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Color white ifTrue: [Color transparent] ifFalse: [c]].
	f colors: map.
	^ f
! !
!ColorForm class methodsFor: 'instance creation' stamp: 'jmv 5/4/2016 16:31' prior: 50349285!
  grayScaleAndTransparentExtent: aPoint
"Native depth"
	"Answer a ColorForm for storing 8bpp gray scale. (do not include any slot for transparent)"

	| grays result |
	result _ self extent: aPoint depth: (Smalltalk isLittleEndian ifTrue: [ -8 ] ifFalse: [ 8 ]).
	grays _ (0 to: 255) collect: [ :brightness | Color gray: brightness asFloat / 255.0].
	grays at: 1 put: Color transparent.
	result colors: grays.
	^result! !
!Cursor methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 50349301!
              asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: self fillColor: Color black at: offset negated.
	^ form offset: offset! !
!CursorWithMask methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 50349309!
            asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: maskForm fillColor: Color white.
	form fillShape: self fillColor: Color black at: offset negated.
	^ form offset: offset! !
!GrayForm methodsFor: 'pixel accessing' stamp: 'jmv 5/11/2016 19:57' prior: 50349319!
                           grayAt: aPoint
	"Return the color of the pixel at aPoint."

	^Color gray: (self pixelValueAt: aPoint) asFloat / 255.0! !
!GrayForm methodsFor: 'color manipulation' stamp: 'jmv 5/12/2016 15:04' prior: 50349326!
              colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	^ Color cachedColormapFromGrayTo: destDepth! !
!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57' prior: 50349335!
                  readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount := (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ Array with: Color white with: Color black].
		"default gray-scale color map"
		maxLevel := (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors := Array new: colorCount.
	1 to: colorCount do: [:i |
		b := ccStream next.
		g := ccStream next.
		r := ccStream next.
		ccStream next. "skip reserved"
		colors at: i put: (Color r: r g: g b: b range: 255)].
	^ colors
! !
!BitBlt methodsFor: 'accessing' stamp: 'jmv 3/20/2013 00:50' prior: 50349370!
               fillColor
	"Return the current fill color as a Color.  
	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."

	halftoneForm ifNil: [^ Color black].
	^ Color colorFromPixelValue: halftoneForm first depth: destForm depth! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 7/27/2015 17:07' prior: 50349381!
          alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.
	DisplayScreen screenUpdateRequired: nil.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor isMouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor isMouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				DisplayScreen screenUpdateRequired: updateRect.
				prevP _ p]]]! !
!WarpBlt methodsFor: 'setup' stamp: 'mtf 8/14/2009 18:21' prior: 50349504!
                  cellSize: s
	"Set the number of samples used for averaging"
	cellSize := s.
	cellSize = 1 ifTrue: [^ self].
	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the
	destination depth. Note that we need to install the 32->32 color map explicitly because
	the VM will substitute a colorMap derived from sourceForm->destForm mapping which
	is just plain wrong for <32 source and 32bit dest depth"
	(destForm depth = 32 and: [sourceForm notNil] and: [sourceForm depth < 32])
		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]
		ifFalse:[colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth].
! !
!GrafPort methodsFor: 'text' stamp: 'jmv 6/1/2015 13:28' prior: 50349528!
           displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font color: foregroundColor
	"If required, do a second pass with new rule and colorMap.
	Answer last affected pixel position
	Answer nil if nothing was done
	"

	| answer prevRule secondPassMap sourceDepth destDepth |

	"Slight optimization when there's nothing to do."
	clipHeight = 0 ifTrue: [^nil].
	clipWidth = 0 ifTrue: [^nil].

	self installStrikeFont: font foregroundColor: (foregroundColor alpha: 1).

	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.
	If not, do it simply"
	combinationRule = 37 "rgbMul" ifFalse: [
		^self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font ].
	
	"We need to do a second pass. The colormap set is for use in the second pass."
	secondPassMap _ colorMap.
	sourceDepth _ sourceForm depth.
	destDepth _ destForm depth.
	colorMap _ sourceDepth ~= destDepth
		ifTrue: [ Color cachedColormapFrom: sourceDepth to: destDepth ].
	answer := self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
	colorMap := secondPassMap.
	secondPassMap ifNotNil: [
		prevRule := combinationRule.
		combinationRule := 20. "rgbAdd"
		self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
		combinationRule := prevRule ].
	^answer! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:52' prior: 50349575!
                              cachedFontColormapFrom1BitTo: destDepth

	| map dstIndex |
	CachedFontColorMaps 
		ifNil: [CachedFontColorMaps _ Array new: 6].

	dstIndex _ destDepth highBit.
	(CachedFontColorMaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ (Color cachedColormapFrom: 1 to: destDepth) copy.
	CachedFontColorMaps at: dstIndex put: map.
	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:55' prior: 50349588!
      colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	
	| srcIndex dstIndex map mapsForSource mapsForSourceAndDest |
	ColorConvertingMaps 
		ifNil: [ColorConvertingMaps _ (1 to: 6) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit.
	sourceDepth > 8 ifTrue: [ srcIndex _ keepSubPix ifTrue: [5] ifFalse: [6] ].
	dstIndex _ destDepth highBit.
	
	mapsForSource _ ColorConvertingMaps at: srcIndex.
	(mapsForSourceAndDest _ mapsForSource at: dstIndex) ifNil: [
		mapsForSourceAndDest _ mapsForSource at: dstIndex put: Dictionary new ].
	
	map _ mapsForSourceAndDest at: targetColor ifAbsentPut: [
		Color 
			computeColorConvertingMap: targetColor 
			from: sourceDepth 
			to: destDepth 
			keepSubPixelAA: keepSubPix ].

	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 4/17/2014 16:57' prior: 50349618!
              setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: Color transparent).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ 
				Preferences subPixelRenderColorFonts and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= Color black or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preferences properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = Color black ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/24/2013 22:36' prior: 50350831!
                       newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor isAnyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor isAnyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 4/10/2015 23:21' prior: 50350867!
                           makeBoldGlyphs
	"Make a bold set of glyphs with same widths by ORing 1 bit to the right
		(requires at least 1 pixel of intercharacter space)"
	| g bonkForm |
	g _ glyphs copy.
	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.
	self bonk: g with: bonkForm.
	glyphs depth = 1 ifTrue: [
		g copyBits: g boundingBox from: g at: (1@0)
			clippingBox: g boundingBox rule: Form under ]
		ifFalse: [
			0 to: g width - 2 do: [ :x | 0 to: g height-1 do: [ :y |
				(glyphs colorAt:  x@y) = Color white ifFalse: [
					g colorAt: x+1@y put: 
						((glyphs colorAt: x+1@y) = Color white 
							ifTrue: [glyphs colorAt:  x@y]
							ifFalse: [Color black])]]]].
	glyphs _ g.
	self isSynthetic: true! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:22' prior: 50350892!
                    makeControlCharsVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character space).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
	self glyphAt: (Character numericValue: 134) put: glyph.
	
	"Keep tab(9), lf(10), cr(13) and space(32) transparent or whatever the user chose"
	#(0 1 2 3 4 5 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27)
		do: [ :ascii |
			characterToGlyphMap at: ascii + 1 put: 134 ]! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:27' prior: 50350909!
             makeCrVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 182).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 133) put: glyph.
	characterToGlyphMap at: 14 put: 133! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:31' prior: 50350921!
         makeLfVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 163).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 132) put: glyph.
	characterToGlyphMap at: 11 put: 132! !
!Morph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:40' prior: 50350933!
             color

	^ Color blue! !
!Morph methodsFor: 'drawing' stamp: 'jmv 4/14/2015 08:53' prior: 50350937!
                             drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: self morphLocalBounds
		color: Color blue! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:46' prior: 50350947!
                              defaultColor
	^ Color orange! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:28' prior: 50350951!
  defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Color gray! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35' prior: 50350957!
    defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Color
		r: 0.861
		g: 1.0
		b: 0.722! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29' prior: 50350964!
          defaultColor
	"answer the default color/fill style for the receiver"
	^ Color
		r: 0.8
		g: 1.0
		b: 0.6! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 11/10/2013 19:32' prior: 50350971!
                              findWindow: evt
	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."
	| menu expanded collapsed nakedMorphs |
	menu _ MenuMorph new.
	expanded _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed not ].
	collapsed _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed ].
	nakedMorphs _ self submorphsSatisfying: [ :m |
		(m is: #SystemWindow) not ].
	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) ifTrue: [ ^ Smalltalk beep ].
	(expanded asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #activateAndForceLabelToShow.
		w canDiscardEdits ifFalse: [ menu lastItem color: Color red ]].
	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) ifFalse: [ menu addLine ].
	(collapsed asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #expand.
		w canDiscardEdits ifFalse: [ menu lastItem color: Color red ]].
	nakedMorphs isEmpty ifFalse: [ menu addLine ].
	(nakedMorphs asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #comeToFrontAndAddHalo ].
	menu addTitle: 'find window'.
	menu popUpInWorld: self! !
!EllipseMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:14' prior: 50351025!
                         defaultColor
	"Return the default fill style for the receiver"
	^Color yellow! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 8/6/2014 09:15' prior: 50351031!
                     defaultColor
	"answer the default color/fill style for the receiver"
	^ Color lightGray! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:50' prior: 50351037!
            drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/12/2012 22:37' prior: 50351078!
    iconColor

	^ self isPressed
		ifTrue: [ Color gray: 0.75 ]
		ifFalse: [
			self mouseIsOver
				ifTrue: [ Color gray: 0.75 ]
				ifFalse: [ Color white ]].! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 1/4/2013 13:31' prior: 50351087!
 example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: 120@35.
	^ row
! !
!TextModelMorph methodsFor: 'drawing' stamp: 'cbr 10/10/2012 23:04' prior: 50351111!
                               drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"


	| bw bc |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"


	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Color red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Color white ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'cbr 11/7/2010 18:58' prior: 50351148!
 defaultColor
	"answer the default color/fill style for the receiver"
	^ Color white! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/7/2013 23:23' prior: 50351154!
                           setWindowColor: incomingColor
	| existingColor aColor |
	incomingColor ifNil: [^ self].  "it happens"
	aColor _ incomingColor asNontranslucentColor.
	aColor = Color black ifTrue: [^ self].
	existingColor _ self widgetsColor.
	existingColor ifNil: [^ Smalltalk beep].
	self widgetsColor: aColor.
	self redrawNeeded! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'KenD 8/27/2015 14:39' prior: 50351167!
  buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground textHeigth |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	textHeigth := AbstractFont default height.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: textHeigth;
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: textHeigth;
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: textHeigth;
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: self buildButtonPane proportionalHeight: 0.1;
		addAdjusterAndMorph: summary proportionalHeight: 0.18;
		addAdjusterAndMorph: description proportionalHeight: 0.22;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.2.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'len 5/27/2016 21:51' prior: 50351243!
                    buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	requirements color: Theme current textPane.
		
	deleteReqButton := PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete'.
	deleteReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newColumn.
	buttonLayout addMorph: deleteReqButton 
					layoutSpec: (LayoutSpec 
										proportionalWidth: 1.0 
										proportionalHeight: 1.0
										minorDirectionPadding: #top);
					color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.9 
							proportionalHeight: 1.0 
							minorDirectionPadding: #left);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.1 
							proportionalHeight: 1.0 
							minorDirectionPadding: #right);
		color: Color transparent;
		yourself
		! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 9/2/2013 10:25' prior: 50351294!
           decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'DM 8/22/2015 12:34' prior: 50351348!
    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35' prior: 50351446!
        buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!TestRunnerWindow methodsFor: 'constants' stamp: 'jmv 4/16/2011 13:57' prior: 50351469!
                      runButtonColor
	^ Color green lighter duller! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:52' prior: 50351474!
                   defaultColor
	^Color white! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:53' prior: 50351478!
     initialize
	super initialize.
	progressColor _ Color gray.
	value _ 0.0! !
!MenuMorph methodsFor: 'construction' stamp: 'len 11/16/2015 02:52' prior: 50351484!
addStayUpIcons
	| closeBox pinBox w |
	Preferences optionalButtons ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon; color: Color transparent.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon; color: Color transparent.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: 19);
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 6/8/2014 20:32' prior: 50351527!
                  displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock position: (0@ -20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/14/2016 15:10' prior: 50351557!
                            drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (0@0 extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:09' prior: 50351608!
                  defaultBorderColor
	^ Color gray! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:59' prior: 50351612!
              drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: 0@0
		color: Color black! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:15' prior: 50351621!
          color: aColor
        super color: aColor.
        (image depth = 1 and: [aColor is: #Color]) ifTrue: [
                image colors: {Color transparent. aColor}.
                self redrawNeeded]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/13/2009 10:04' prior: 50351630!
  isEnabled: aBoolean

	isEnabled = aBoolean ifTrue: [^ self].
	isEnabled _ aBoolean.
	self color: (aBoolean ifTrue: [Color black] ifFalse: [Color gray]).
! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 50351638!
                 offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) 
			borderWidth: 1 borderColor: Color black.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 50351650!
            onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 
			borderWidth: 1 borderColor: Color black;
		fillRectangle: (form boundingBox insetBy: 2) color: Color black.
	^form! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 12/1/2015 09:53' prior: 50351664!
         adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	doAdoptWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: paneColor) ]
		ifFalse: [ self color: Color transparent ]! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:38' prior: 50351674!
                            defaultColor
	^Color gray! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:59' prior: 50351678!
   initializedInstance
	"Answer a row by default so the 'new morph' menu doesn't fail..."
	^self newRow color: (Color red alpha: 0.2)! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:57' prior: 50351685!
   example1
"
	self example1
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/12/2015 16:42' prior: 50351752!
                      example10
"
	self example10 openInWorld
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:55' prior: 50351820!
               example11
"
	self example11
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:08' prior: 50351890!
    example13
	"
	self example13
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 2/16/2016 13:27' prior: 50351938!
                            example1b
"
Based on #example1, but using some Morph instead of RectangleLikeMorph -> extent is not adjustable
	self example1b
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (Morph new name: #B);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (Morph new name: #G);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (Morph new name: #J);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:25' prior: 50351999!
                          example2
	"
	self example2
	"
	| pane row |
	pane _ (LayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 11/18/2015 09:45' prior: 50352031!
                              example20
"
	self example20
"
| column |

column _ (LayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 30).
column morphPosition: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:13' prior: 50352054!
       example3
	"
	self example3
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/8/2014 20:03' prior: 50352097!
                            example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := BorderedRectMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	morphPosition: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane _ LayoutMorph newRow separation: 5. "2"
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane
	color: Color lightGreen;
	morphPosition: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	morphPosition: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 1/4/2013 13:42' prior: 50352150!
            launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: Color lightRed ].
	row _ LayoutMorph newRow
		 color: Color red;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:55' prior: 50352174!
               defaultColor
	^Color veryLightGray! !
!HaloHandleMorph class methodsFor: 'accessing' stamp: 'jmv 11/18/2010 09:44' prior: 50352179!
                            circleForm: extent
	"
	CircleForm _ nil
	"
	| r d l bw center |
	(CircleForm isNil or: [ CircleForm extent ~= extent ]) ifTrue: [
		center _ extent -1 * 0.5.
		r _ center r * 0.75.
		bw _ 1.3.
		CircleForm _ Form extent: extent depth: 32.
		0 to: extent y - 1 do: [ :y |
			0 to: extent x - 1 do: [ :x |
				d _ (x@y - center) r.
				l _ (r - d max: 0.0) min: bw.
				CircleForm
					colorAt: x @ y
					put: (Color white alpha: (l / bw))
					]].
		].
	^CircleForm! !
!HaloMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:28' prior: 50352197!
                      defaultColor
	"answer the default color/fill style for the receiver"
	^ Color
		r: 0.6
		g: 0.8
		b: 1.0! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 5/27/2015 13:42' prior: 50352203!
     addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: 0@0 ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 7/4/2016 22:14' prior: 50352237!
          addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition nameBackground |
	nameBackground _ RectangleLikeMorph new
		color: ((target is: #SystemWindow) ifTrue: [target windowColor] ifFalse: [Color lightBlue alpha: 0.9]).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color black.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	namePosition _ haloBox width - nameMorph morphWidth // 2 @ (haloBox height).
	self addMorph: nameBackground position: namePosition - 2.
	self addMorph: nameMorph position: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18' prior: 50352260!
                doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPositionInWorld: evt eventPosition - (rotHandle morphExtent // 2)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01' prior: 50352286!
                              setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint:  (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 5/27/2013 09:39' prior: 50352301!
           initialize
	super initialize.
	self color: Color black.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	selectedRows _ Set new.
	highlightedRow _ nil! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 10/16/2013 19:55' prior: 50352310!
                     debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self textComposition lines do: [ :line |
		aCanvas
			frameRectangle: line rectangle
			borderWidth: 1
			color: Color brown ]
! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:51' prior: 50352320!
                        initialize
	super initialize.
	extent _ 400@300.
	color _ Color white.
	grid _ 8@6.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:18' prior: 50352329!
  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Color black;
		color: Color transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 9/25/2011 23:12' prior: 50352341!
                      defaultColor

	^Color r: 1.0 g: 1.0 b: 0.7! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 12/20/2014 15:09' prior: 50352346!
                             drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		textComposition: textComposition
		bounds: (r insetBy: 4)
		color: Color black
		selectionColor: (Theme current textHighlightFocused: false)! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12' prior: 50352357!
            drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Color gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Color random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21' prior: 50352483!
          experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Color green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Color gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 12/20/2014 15:35' prior: 50352512!
                              drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > (50@50)
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Color yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Color yellow! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/1/2015 13:30' prior: 50352530!
 drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Color black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Color black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Color white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + (0@2)
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + (0@1)
		font: fontOrNil
		color: aColor! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:01' prior: 50352557!
         fillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	aColor isTransparent ifFalse: [
		self 
			frameAndFillRectangle: aRectangle
			fillColor: aColor
			borderWidth: 0
			borderColor: Color transparent ]! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:14' prior: 50352568!
reverseRectangleBorder: r borderWidth: borderWidth
	"
	Display getCanvas
		reverseRectangleBorder: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	port
		sourceForm: nil;
		fillColor: Color gray;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 4/9/2015 09:46' prior: 50352583!
                               setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor |
	paintColor _ aColor ifNil: [ Color transparent ].
	(paintColor is: #Color) ifFalse: [
		^self error: 'Cannot install color' ].

	"Okay, so paintColor really *is* a color"
	port sourceForm: nil.
	(paintColor isOpaque or: [ self depth < 32]) ifTrue: [
		port fillColor: paintColor.
		port combinationRule: Form paint.
		^self ].

	"BitBlt setup for alpha mapped transfer"
	port fillColor: paintColor.
	port combinationRule: Form blend! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 50352603!
                               steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (0@0 extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				roundRect: (1@1 extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 50352622!
                           verticalGrayGradient: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	^self cachedForms
		at: { #vertical. height. gradientTopFactor . gradientBottomFactor }
		ifAbsentPut: [
			Form
				verticalGradient: height
				topColor: (Color gray: gradientTopFactor)
				bottomColor: (Color gray: gradientBottomFactor) ]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/7/2015 08:12' prior: 50352636!
       buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	 (self buildArrowOfDirection: #up size: 120) display
	"

	| resizeFactor resizedForm f e c bottomMargin topMargin |
	resizeFactor _ 4.
	e _ finalSizeInteger@finalSizeInteger*resizeFactor.
	f _ Form extent: e depth: 32.
	c _ Color gray: 0.5.
	topMargin _ finalSizeInteger * 3//4.
	bottomMargin _ finalSizeInteger * 4//4.
	0 to: e y-1-bottomMargin do: [ :y |
		0 to: e x -1 do: [ :x |
			(e x / 2 - 1 - x) abs * 2 + topMargin < y ifTrue: [
				f colorAt: x@y put: c
			]
		]
	].
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 10/9/2014 23:02' prior: 50352680!
                    buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - (1@2).
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Color r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Color transparent ]
				ifFalse: [
					borderSpec = (Color r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Color white]
								ifFalse: [Color black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/19/2010 14:06' prior: 50352721!
                background
	^ Color r: 0.7 g: 0.72 b: 0.83! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:42' prior: 50352725!
       buttonColorFrom: aColor
	^ Display depth <= 8
			ifTrue: [ Color transparent ]
			ifFalse: [ aColor paler ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/14/2011 08:50' prior: 50352731!
       buttonLabel
	^Color gray: 0.18! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 50352735!
                     errorColor
	^ Color red lighter! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:40' prior: 50352739!
                    failureColor
	^ Color yellow lighter! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 50352743!
             scrollbarButtonColor
	^Color gray: 0.95! !
!Theme methodsFor: 'colors' stamp: 'len 11/17/2015 23:55' prior: 50352747!
          scrollbarColor
	^Color white! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 50352751!
                     scrollbarSliderShadowColor
	^Color white! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 50352755!
           successColor
	^ Color green lighter! !
!Theme methodsFor: 'colors' stamp: 'cbr 11/7/2010 18:00' prior: 50352759!
               text
	^ Color black! !
!Theme methodsFor: 'colors' stamp: 'jmv 10/16/2013 22:08' prior: 50352763!
                              textCursor
	^ Display depth <= 2
		ifTrue: [ Color black ]
		ifFalse: [ self text ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 5/30/2011 14:31' prior: 50352769!
                               textHighlight
	"A nice light blue."
	"
	^ Color r: 0.71 g: 0.835 b: 1.0
	^ Color hue: 214 chroma: 0.29 luminance: 0.816
	"
	^Color hue: 204 chroma: 0.29 luminance: 0.77! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:58' prior: 50352777!
         textHighlightFocused: focused
	"A nice light blue."
	| textHighlight |
	Display depth = 1 ifTrue: [^ Color veryLightGray].
	Display depth = 2 ifTrue: [^ Color gray: 0.87].
	textHighlight _ self textHighlight.
	^focused
		ifTrue: [ textHighlight ]
		ifFalse: [ self unfocusedTextHighlightFrom: textHighlight ]! !
!Theme methodsFor: 'colors' stamp: 'cbr 12/6/2010 20:08' prior: 50352790!
                              windowLabel
	^Color gray: 0.3! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 5/26/2011 09:07' prior: 50352794!
                menu
	Display depth <= 2 ifTrue: [^ Color white].
	^Color r: 0.75 g: 0.75 b: 0.75 alpha: 0.93! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/23/2010 09:45' prior: 50352800!
               menuHighlight
	^ Display depth < 8
		ifTrue: [ Color veryLightGray ]
		ifFalse: [ self textHighlight ]! !
!Theme methodsFor: 'menu colors' stamp: 'cbr 11/7/2010 18:28' prior: 50352806!
       menuText
	^ Color black! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/28/2010 08:04' prior: 50352810!
                     menuTitleBar
	Display depth = 1 ifTrue: [^ Color white].
	Display depth = 2 ifTrue: [^ Color gray].
	^ self menu darker! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 4/15/2011 14:59' prior: 50352817!
                      browser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.5 g: 0.7 b: 0.4]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 2/14/2013 11:05' prior: 50352824!
                              debugger
	^Color h: 0.0 s: 0.6 v: 0.7! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:16' prior: 50352828!
       defaultWindowColor
	^ Color lightGray! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 50352832!
       fileContentsBrowser
	^Color tan duller! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:44' prior: 50352836!
       fileList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.7 g: 0.55 b: 0.7 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 50352843!
                           messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 50352850!
                   messageSet
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.45 g: 0.6 b: 0.85 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 50352857!
                       object
	^Color white duller! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/28/2012 09:41' prior: 50352861!
                  packageList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.63 g: 0.47 b: 0.08 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:17' prior: 50352868!
                     testRunner
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ (Color r: 0.650 g: 0.753 b: 0.976) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:15' prior: 50352875!
           textEditor
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color gray: 0.6 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 50352881!
     transcript
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.8 g: 0.6 b: 0.3 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/18/2010 17:56' prior: 50352888!
                         versionsBrowser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ (Color r: 0.869 g: 0.753 b: 1.0) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:13' prior: 50352895!
        workspace
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color h: 60.0 s: 0.73 v: 0.72 ]! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49' prior: 50352902!
                      acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.2 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 50352910!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'cbr 10/10/2012 23:36' prior: 50352918!
                       textPane
	^Color white! !
!SHTextStylerST80 class methodsFor: 'style table' stamp: 'pb 5/4/2016 17:44' prior: 50352922!
        initialTextAttributes
	| d element color emphasis attrArray |
	d _ IdentityDictionary new.
	self styleTable do: [ :each |
		element _ each first.
		color _ each at: 2 ifAbsent: nil.
		color _ color ifNotNil: [ Color colorFrom: color ].
		emphasis _ each at: 3 ifAbsent: nil.
		attrArray _ self attributeArrayForColor: color emphasis: emphasis.
		attrArray notEmpty ifTrue: [
			d at: element put: attrArray ]].
	^ d! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3111-ChangeReferencesBackToColor-JuanVuletich-2017Jun19-12h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3106] on 19 June 2017 at 11:52:30 am'!
!Colour methodsFor: 'transformations' stamp: 'jmv 6/19/2017 12:10:13' prior: 50352946!
                   * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Colour brown *2) display
	"
	^ (Color new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0))
			alpha: self alpha! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| all |
all := Colour allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).
all := TranslucentColour allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3112-MigrateInstancesToColor-JuanVuletich-2017Jun19-11h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3111] on 19 June 2017 at 12:11:51 pm'!

Smalltalk removeClassNamed: #Colour!

Smalltalk removeClassNamed: #Colour!

Smalltalk removeClassNamed: #TranslucentColour!

Smalltalk removeClassNamed: #TranslucentColour!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3113-RemoveColour-JuanVuletich-2017Jun19-12h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3113] on 19 June 2017 at 3:22:14 pm'!

InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow selectedRows highlightedRow '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #InnerListMorph category: #'Morphic-Views'!
InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow selectedRows highlightedRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:21:44' prior: 50360534!
       initialize
	super initialize.
	self color: Color black.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 6/19/2017 15:21:40' prior: 16855089!
    listChanged
	"set newList to be the list of strings to display"
	listItems _ Array new: self getListSize withAll: nil.
	selectedRow _ nil.
	self adjustExtent! !
!InnerListMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:21:48' prior: 16855308!
        noSelection
	selectedRow _ nil.
	highlightedRow _ nil! !

InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow highlightedRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #InnerListMorph category: #'Morphic-Views'!
InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow highlightedRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3114-removeAnUnusedIvar-JuanVuletich-2017Jun19-15h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3113] on 19 June 2017 at 4:40:20 pm'!
!Object methodsFor: 'private' stamp: 'jmv 6/19/2017 16:14:39' prior: 16882717!
                       primitiveError: aString 
	"This method is called when the error handling results in a recursion in 
	calling on error: or halt or halt:."

	| context emergencyEvaluator lines r |
	r _ `10@10` extent: (Display extent -20 min: `700@1000`).
	lines _ r height // AbstractFont default height.
	emergencyEvaluator _ Transcripter newInFrame: r.
	emergencyEvaluator
		nextPutAll: '***System error handling failed***'; newLine;
		nextPutAll: aString; newLine;
		nextPutAll: '-------------------------------'; newLine.
	context _ thisContext sender sender.
	(30 min: lines - 10) timesRepeat: [context ifNotNil: [emergencyEvaluator print: (context _ context sender); newLine]].
	emergencyEvaluator
		nextPutAll: '-------------------------------'; newLine;
		nextPutAll: 'Type ''revert'' to revert your last method change.'; newLine;
		nextPutAll: 'Type ''exit'' to exit the emergency evaluator.'; newLine.
	emergencyEvaluator readEvalPrint! !
!InputSensor methodsFor: 'private' stamp: 'jmv 6/19/2017 15:53:29' prior: 16856661!
        primMousePt
	"Primitive. Poll the mouse to find out its position. Return a Point. Fail if
	event-driven tracking is used instead of polling. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 90>
	^ `0@0`! !
!EventSensor methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:48:40' prior: 16839804!
   initialize
	"Run the I/O process"
	mouseButtons _ 0.
	mousePosition _ `0@0`.
	self setInterruptKey: (interruptKey ifNil: [$. numericValue bitOr: 16r0800 ]). 	"cmd-."
	interruptSemaphore _ (Smalltalk specialObjectsArray at: 31) ifNil: [Semaphore new].
	self flushAllButDandDEvents.
	inputSemaphore _ Semaphore new.
	hasInputSemaphore _ false.

	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	self installInterruptWatcher.
	self installEventTickler.
	self flushAllButDandDEvents.

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore _ false.
	inputSemaphore initSignals! !
!String methodsFor: 'displaying' stamp: 'jmv 6/19/2017 16:12:23' prior: 16917029!
   displayOn: aDisplayMedium
	"Display the receiver on the given DisplayMedium.  5/16/96 sw"

	self displayOn: aDisplayMedium at: `0 @ 0`! !
!Bitmap methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 15:45:57' prior: 16787594!
                           asByteArray
	"Faster way to make a byte array from me.
	copyFromByteArray:, if receiver is BigEndian makes equal Bitmap.
	Assume receiver bytes-in-word mapping is BigEndian:
		Most significant bye of first word in self goes to first position in result.
	This means that for a BigEndian 8bpp Form, pixels are in the right order in the ByteArray
	
	Form lena asGrayForm bits asByteArray copyFrom: 1 to: 4.
	(Form lena asGrayForm asFormOfDepth: 8) bits asByteArray copyFrom: 1 to: 4.
	(0 to: 3) collect: [ :x | ((Form lena asGrayForm colorAt: x@0) luminance * 255) rounded ].
	"
	| f bytes hack |
	f _ Form extent: 4@self size depth: 8 bits: self.
	bytes _ ByteArray new: self size * 4.
	hack _ Form new hackBits: bytes.
	Smalltalk isLittleEndian ifTrue: [hack swapEndianness].
	hack copyBits: f boundingBox
		from: f
		at: `0@0`
		clippingBox: hack boundingBox
		rule: Form over.

	"f displayOn: hack."
	^ bytes! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 6/19/2017 16:12:37' prior: 50335412!
            snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ ProjectX ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ ProjectX ui ]."
	ProjectX stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	ProjectX spawnNewMorphicProcessFor: (world ifNil: [ PasteUpMorph newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:13:36' prior: 50357756!
                  endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			`0@0` + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (`4@4` + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter class methodsFor: 'utilities' stamp: 'jmv 6/19/2017 15:58:42' prior: 16938949!
                           emergencyEvaluator
	(Transcripter newInFrame: `0@0 corner: 320@200`)
		show: 'Type ''exit'' to exit the emergency evaluator.';
		readEvalPrint! !
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:15:27' prior: 50342770!
                              defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame oldFilledWidth oldFilledWidth2 prevContents |
	f _ AbstractFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.

	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ `0@0` extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	prevContents _ Form fromDisplay: outerFrame.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	oldFilledWidth _ 0.
	oldFilledWidth2 _ 0.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		filledWidth _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		filledWidth  > oldFilledWidth ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + `2@2` extent: filledWidth@17).
			filledWidth -200 > oldFilledWidth2
				ifFalse: [
					"Usually just request an update, to be done asynchronously."
					DisplayScreen screenUpdateRequired: outerFrame ]
				ifTrue: [
					"Once in a while, force a real screen update (warning: really slow on MacOS if done too often)"
					Display forceToScreen: outerFrame. oldFilledWidth2 _ filledWidth ].
			oldFilledWidth _ filledWidth ]].
	prevContents displayAt: outerFrame topLeft.
	self resume: result! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:37' prior: 16898287!
           staggerOffset
	^`6 @ 20`! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:46' prior: 16898320!
                          standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| effectiveExtent width strips height grid allowedArea maxLevel |
	effectiveExtent _ self maximumUsableArea extent
					- (self scrollBarSetback @ self screenTopSetback).
	Preferences reverseWindowStagger ifTrue:
		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"
		allowedArea _ self maximumUsableArea insetBy: (
			self scrollBarSetback @ self screenTopSetback extent: `0@0`
		).
		"Number to be staggered at each corner (less on small screens)"
		maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
		"Amount by which to stagger (less on small screens)"
		grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: `52@40` * Preferences standardCodeFont height ].
	width _ (strips _ self windowColumnsDesired) > 1
		ifTrue:
			[effectiveExtent x // strips]
		ifFalse:
			[(3 * effectiveExtent x) // 4].
	height _ (strips _ self windowRowsDesired) > 1
		ifTrue:
			[effectiveExtent y // strips]
		ifFalse:
			[(3 * effectiveExtent y) //4].
	^ width @ height

"RealEstateAgent standardWindowExtent"! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:58' prior: 16898360!
                            strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 
	"This method implements a staggered window placement policy that I (di) like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible."

	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |
	allowedArea := (self maximumUsableAreaInWorld: aWorld) 
				insetBy: (self scrollBarSetback @ self screenTopSetback extent: `0 @ 0`).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame := `0 @ 0` extent: initialExtent.
	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400"
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [ :w | w visible and: [w isCollapsed not]]) 
						collect: [:w | w morphBoundsInWorld].
	otherFrames _ otherFrames reject: [ :f | f isNil ].
	0 to: maxLevel do: [ :level | 
			1 to: 4 do: [:ci | 
					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.
					corner := allowedArea perform: cornerSel.
					"The extra grid//2 in delta helps to keep title tabs distinct"
					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).
					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"
					putativeCorner := corner + delta.
					free := true.
					otherFrames do: [ :w |
						free := free & ((w perform: cornerSel) ~= putativeCorner)].
					free 
						ifTrue: [
							^(initialFrame aligned: (initialFrame perform: cornerSel)
								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].
	"If all else fails..."
	^(self scrollBarSetback @ self screenTopSetback 
		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !
!Form methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:50:37' prior: 16846782!
           offset
	^offset ifNil:[`0@0`]! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:14' prior: 16846919!
                primCountBits
	"Count the non-zero pixels of this form."
	self depth > 8 ifTrue:
		[^(self asFormOfDepth: 8) primCountBits].
	^ (BitBlt toForm: self)
		fillColor: (Bitmap with: 0);
		destRect: (`0@0` extent: width@height);
		combinationRule: 32;
		copyBits! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:36' prior: 16846929!
             tallyPixelValuesInRect: destRect into: valueTable
	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."

	(BitBlt toForm: self)
		sourceForm: self;  "src must be given for color map ops"
		sourceOrigin: `0@0`;
		colorMap: valueTable;
		combinationRule: 33;
		destRect: destRect;
		copyBits.
	^ valueTable

"
Move a little rectangle around the screen and print its tallies...
 | r tallies nonZero |
Cursor blank showWhile: [
[Sensor isAnyButtonPressed] whileFalse:
	[r _ Sensor mousePoint extent: 10@10.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.
	tallies _ (Display copy: r) tallyPixelValues.
	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]
			thenCollect: [:i | (tallies at: i) -> (i-1)].
	Display fill: (0@0 extent: Display width@20) fillColor: Color white.
	nonZero printString , '          ' displayAt: 0@0.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]
"! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:54' prior: 16846963!
                   xTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by x-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice countBlt copyBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: 1@height.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: 1 @ slice height
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: width-1) collect:
		[:x |
		copyBlt sourceOrigin: x@0; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:52:04' prior: 16846991!
                     yTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: slice width @ 1
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: height-1) collect:
		[:y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'coloring' stamp: 'jmv 6/19/2017 15:50:16' prior: 16847123!
                       fillShape: aShapeForm fillColor: aColor
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	^ self fillShape: aShapeForm fillColor: aColor at: `0@0`! !
!Form methodsFor: 'coloring' stamp: 'jmv 6/19/2017 15:50:23' prior: 16847131!
         fillShape: aShapeForm fillColor: aColor at: location
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	((BitBlt destForm: self sourceForm: aShapeForm fillColor: aColor
		combinationRule: Form paint
		destOrigin: location + aShapeForm offset sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits! !
!Form methodsFor: 'color mapping' stamp: 'jmv 6/19/2017 15:50:33' prior: 50358106!
     mapColor: oldColor to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Color cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: `0@0`;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:08' prior: 16847321!
           asFormOfDepth: d
	| newForm source |
	d = depth ifTrue: [ ^self ].
	source _ (self depth = 32 and: [ d abs < 32 ])
		ifTrue: [ self copy convertAlphaToZeroValueTransparency ]
		ifFalse: [ self ].
	newForm _ Form extent: source extent depth: d.
	(BitBlt toForm: newForm)
		colorMap: (source colormapIfNeededFor: newForm);
		copy: source boundingBox
		from: `0@0` in: source
		fillColor: nil rule: Form over.
	"If we build a 32bpp from one of smaller depth,
	it will have zero in the alpha channel (until BitBlt is fixed!!)"
	(newForm depth = 32 and: [self depth < 32]) ifTrue: [
		newForm fixAlpha ].
	^newForm! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:12' prior: 16847342!
           asGrayForm
	| answer map |

	"For lower bit depths, the 15 bit ColorMap loses no information,
	and answers the real #luminance of each pixel."
	self depth < 32 ifTrue: [
		answer _ GrayForm extent: width@height.
		map _ self colormapIfNeededForGray8bpp.
		(BitBlt toForm: answer)
			colorMap: map;
			copy: self boundingBox
			from: `0@0` in: self
			fillColor: nil rule: Form over.
		answer offset: self offset.
		^ answer ].

	"For 32bpp, the approach below would use just 5bits per component.
	Generally it is best to extract a component in full 8bpp and keep full dynamic range.
	Green usually is a good choice."
	^ self asGrayForm: 3! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:19' prior: 16847364!
              asGrayForm: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a GrayForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit GrayForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayForm: componentIndex ].
	
	result _ GrayForm extent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.
	^ result! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:38' prior: 16847425!
                       asGrayScaleAndTransparent: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayScaleAndTransparent: componentIndex ].

	result _ ColorForm grayScaleAndTransparentExtent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.

	"final BitBlt to zero-out pixels that were truely transparent in the original"
	map _ Bitmap new: 512.
	map at: 1 put: 16rFF.
	(BitBlt toForm: result)
		sourceForm: self;
		sourceRect: self boundingBox;
		destOrigin: `0@0`;
		combinationRule: Form erase;
		colorMap: map;
		copyBits.
	^ result! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 16:04:17' prior: 16847525!
                        icon
	"Answer a 16 x 16 icon of myself"
	
	^self magnifyTo: `16 @ 16`! !
!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:49:47' prior: 16847584!
          contentsOfArea: aRect into: newForm
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !
!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:49:55' prior: 16847594!
          copy: aRect
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !
!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:50:02' prior: 16847621!
                            copyBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt 
		destForm: self
		sourceForm: sourceForm
		combinationRule: 30
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 copyBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'display box access' stamp: 'jmv 6/19/2017 16:04:01' prior: 16847674!
boundingBox
	^ Rectangle
		origin: `0 @ 0`
		corner: width @ height! !
!Form methodsFor: 'displaying' stamp: 'jmv 6/19/2017 15:51:05' prior: 16847690!
         paintBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt destForm: self
		sourceForm: sourceForm
		combinationRule: 31
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f replaceColor: f dominantColor withColor: Color transparent.
f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 paintBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'displaying-generic' stamp: 'jmv 6/19/2017 16:04:09' prior: 16847730!
   displayOn: aDisplayMedium
	"Simple default display in order to see the receiver in the upper left 
	corner of screen."

	self displayOn: aDisplayMedium at: `0 @ 0`! !
!Form methodsFor: 'filling' stamp: 'jmv 6/19/2017 15:50:07' prior: 16847937!
            eraseShape: bwForm
	"use bwForm as a mask to clear all pixels where bwForm has 1's"
	((BitBlt destForm: self sourceForm: bwForm
		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"
		destOrigin: bwForm offset 
		sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits.
! !
!Form methodsFor: 'filling' stamp: 'jmv 6/19/2017 15:50:12' prior: 16847951!
                              fill: aRectangle rule: anInteger fillColor: aForm 
	"Replace a rectangular area of the receiver with the pattern described by aForm 
	according to the rule anInteger."
	(BitBlt toForm: self)
		copy: aRectangle
		from: `0@0` in: nil
		fillColor: aForm rule: anInteger! !
!Form methodsFor: 'image manipulation' stamp: 'jmv 6/19/2017 15:51:26' prior: 16848014!
                          smear: dir distance: dist
	"Smear any black pixels in this form in the direction dir in Log N steps"
	| skew bb |
	bb _ BitBlt destForm: self sourceForm: self
		combinationRule: Form under destOrigin: `0@0` sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox.
	skew _ 1.
	[skew < dist] whileTrue:
		[bb destOrigin: dir*skew; copyBits.
		skew _ skew+skew]! !
!Form methodsFor: 'transitions' stamp: 'jmv 6/19/2017 15:50:50' prior: 50358231!
                        pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!Form methodsFor: 'private' stamp: 'jmv 6/19/2017 16:04:06' prior: 16848740!
                     copyFromByteArray: bigEndianByteArray
	"This method should work with either byte orderings.
	See comment at Bitmap>>#asByteArray
	Also see #copyFromByteArray2:to:"

	| myHack byteHack |
	myHack := Form new hackBits: bits.
	byteHack := Form new hackBits: bigEndianByteArray.
	"We are passing a ByteArray instead of a Words object. Will be accessed according to native endianness."
	Smalltalk isLittleEndian = self isLittleEndian ifFalse: [byteHack swapEndianness].
	byteHack displayOn: myHack at: `0 @ 0` rule: Form over! !
!Form methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:04:13' prior: 16848849!
 fromDisplay: aRectangle 
	"Create a virtual bit map from a user specified rectangular area on the 
	display screen. Reallocates bitmap only if aRectangle ~= the receiver's 
	extent."

	(width = aRectangle width and: [height = aRectangle height])
		ifFalse: [self setExtent: aRectangle extent depth: depth].
	self
		copyBits: (aRectangle origin extent: self extent)
		from: Display
		at: `0 @ 0`
		clippingBox: self boundingBox
		rule: Form over! !
!Form methodsFor: 'encoding' stamp: 'jmv 6/19/2017 15:49:02' prior: 16848870!
                  addDeltasFrom: previousForm

	(BitBlt 
		destForm: self 
		sourceForm: previousForm 
		fillColor: nil 
		combinationRule: Form reverse
		destOrigin: `0@0`
		sourceOrigin: `0@0`
		extent: self extent 
		clipRect: self boundingBox) copyBits.
	^self! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 16:37:08' prior: 50358302!
         dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: `0@0` - radius.
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Color black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 6/19/2017 16:04:23' prior: 50358364!
      toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Color red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: `-40@-40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 6/19/2017 15:47:08' prior: 16818811!
    asGrayForm
	"Build an optimal GrayForm,
	for any color palette in the receiver."
	| answer map |
	answer _ GrayForm extent: width@height.
	map _ self colormapIfNeededForGray8bpp.
	(BitBlt toForm: answer)
		colorMap: map;
		copy: self boundingBox
		from: `0@0` in: self
		fillColor: nil rule: Form over.
	^ answer! !
!ColorForm methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:47:12' prior: 16818912!
                  copy: aRect
 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	colors ifNotNil: [newForm colors: colors copy].
	^ newForm
! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 15:47:16' prior: 50358631!
mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: `0@0`
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Color white ifTrue: [Color transparent] ifFalse: [c]].
	f colors: map.
	^ f
! !
!Cursor methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:47:21' prior: 16825862!
            enlargedBy: scale
	"Big cursors are 32 bits deep (ARGB premultiplied)"
	| big |
	scale = 1 ifTrue: [^self].
	big := CursorWithAlpha extent: self extent * scale depth: 32.
	(self asCursorForm magnifyBy: scale) displayOn: big.
	big offset: (self offset - 0.5 * scale min: `0@0` max: big extent negated) asIntegerPoint.
	big fallback: self.
	^big! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/19/2017 16:02:49' prior: 16835519!
       actualScreenSize
	<primitive: 106>
	^ `640@480`! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/19/2017 16:02:57' prior: 16835523!
               shutDown 
	"Minimize Display memory saved in image"
	Display setExtent: `240@120` depth: Display nativeDepth.
	ScreenUpdaterProcess ifNotNil: [
		ScreenUpdaterProcess terminate.
		ScreenUpdaterProcess _ nil ]! !
!GrayForm methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:52:16' prior: 16850389!
                           copy: aRect
 	"Return a new instance containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	^ newForm! !
!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:45:22' prior: 16786163!
                        bitPeekerFromForm: sourceForm
	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."
	| pixPerWord answer |
	pixPerWord _ sourceForm pixelsPerWord.
	answer _ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)
	 	sourceForm: nil 			"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: (pixPerWord - 1)@0
		sourceOrigin: `0@0`
		extent: `1@1`
		clipRect: (`0@0` extent: pixPerWord@1).
	"To ensure no colormap set"
	answer sourceForm: sourceForm.
	^ answer! !
!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:45:33' prior: 16786184!
              bitPokerToForm: destForm
	"Answer an instance to be used for valueAt: aPoint put: pixValue.
	The source for a 1x1 copyBits will be the low order of (bits at: 1)"
	| pixPerWord answer |
	pixPerWord _ 32//destForm depth.
	answer _ self destForm: destForm
	 	sourceForm: nil 		"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: (pixPerWord-1)@0
		extent: `1@1`
		clipRect: (`0@0` extent: destForm extent).
	"To ensure no colormap set"
	answer sourceForm: (Form extent: pixPerWord@1 depth: destForm depth).
	^ answer! !
!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 6/19/2017 15:43:10' prior: 16778110!
      internalizeDelta: aPoint
	"Internalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x.
	y _ aPoint y.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 6/19/2017 15:43:16' prior: 16778149!
                             inverseTransform: aPoint
	"Apply the inverse transformation to aPoint, i.e. multiply our inverse by aPoint.
	Use Smalltalk code, and not Matrix2x3Plugin, because we want Float conversion."
	| x y det a11 a12 a21 a22 detX detY |

	x _ aPoint x - self a13.
	y _ aPoint y - self a23.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!AffineTransformation methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:43:25' prior: 16778231!
            inverseTransformation
	"Return the inverse transformation of the receiver.
	The inverse transformation is computed by first calculating
	the inverse offset and then computing transformations
	for the two identity vectors (1@0) and (0@1)"
	| r1 r2 r3 m |
	r3 _ self inverseTransform: `0@0`.
	r1 _ (self inverseTransform: `1@0`) - r3.
	r2 _ (self inverseTransform: `0@1`) - r3.
	m _ self species new.
	m
		a11: r1 x; a12: r2 x; a13: r3 x;
		a21: r1 y; a22: r2 y; a23: r3 y.
	^m! !
!AffineTransformation methodsFor: 'transforming rects' stamp: 'jmv 6/19/2017 15:43:02' prior: 16778783!
                         displayBoundsOfTransformOf: aRectangle
	"Externalize aRectangle, and find a bounding rectangle with horizontal 
		and vertical bounds and integer coordinates (i.e. adisplayBounds).
	Primitive rounds and answers integers.
	Warning: if answer from primitive is not strictly positive, it is off by one. Fix it here."

	| dstRect |
	dstRect _ Rectangle new.
	(self primDisplayBoundsOfTransformOf: aRectangle into: dstRect) ifNotNil: [
		dstRect topLeft > `0@0` ifTrue: [ ^dstRect  ]].
	^Rectangle encompassing: (aRectangle corners collect: [ :pt |
		(self transform: pt) rounded ])! !
!Point methodsFor: 'point functions' stamp: 'jmv 6/19/2017 16:10:05' prior: 16890518!
     eightNeighbors
	^ (Array with: self + `1@0`
		with: self + `1@1`
		with: self + `0@1`
		with: self + `-1@1`) ,
	(Array with: self + `-1@0`
		with: self + `-1@-1`
		with: self + `0@-1`
		with: self + `1@-1`)
! !
!Point methodsFor: 'point functions' stamp: 'jmv 6/19/2017 16:10:18' prior: 16890538!
                       fourNeighbors
	^ Array with: self + `1@0`
		with: self + `0@1`
		with: self + `-1@0`
		with: self + `0@-1`
! !
!Rectangle methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:11:04' prior: 16898560!
                             innerCorners
	"Return an array of inner corner points,
	ie, the most extreme pixels included,
	in the order of a quadrilateral spec for WarpBlt"
	| r1 |
	r1 _ self topLeft corner: self bottomRight - `1@1`.
	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 6/19/2017 15:54:30' prior: 16875129!
  processUnknownEvent: aMorphicEvent localPosition: localEventPosition
	"An event of an unknown type was sent to the receiver. What shall we do?!!"

	Smalltalk beep. 
	aMorphicEvent printString displayAt: `0@0`.
	aMorphicEvent wasHandled: true! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:08:34' prior: 16875336!
                            minimumExtent
	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least"

	self flag: #jmvVer2.	"in owner's coordinates?"
	^self valueOfProperty: #minimumExtent ifAbsent: [`1@1`]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:08:41' prior: 16875397!
                          morphExtent
	"In our own coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^`50 @ 40`! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:54:22' prior: 16875457!
   morphPositionInWorld

	self flag: #jmvVer2.
	"Most likely we don't want to use global coordinates...
	In fact, we could be in many frames of reference at the same time...
	This method makes no sense at all!!"

	^self externalizeToWorld: `0@0`! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:54:26' prior: 16875515!
                           morphTopLeft
	"By default, morphs occupy a rectangle specified by #morphTopLef and #morphExtent"
	^`0@0`! !
!Morph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:08:46' prior: 16875946!
                               openInWorld: aWorld
	"Add this morph to the requested World."
	(location = MorphicTranslation new)
		ifTrue: [ aWorld addMorph: self position: `50@50` ]
		ifFalse: [ aWorld addMorph: self ]! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:11:08' prior: 16899200!
                             initialize
	super initialize.
	extent _ `50@40`.
	color _ self defaultColor! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 6/19/2017 15:55:13' prior: 16887050!
                   invalidateDisplayRect: damageRect from: aMorph
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self world 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: ( `0@0` extent: extent) ) ]
                ifFalse: [ super invalidateDisplayRect: damageRect from: aMorph ]
! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:00' prior: 16887077!
           drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			aCanvas image: backgroundImage at: `0@0` ]
		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [ aCanvas drawsOnDisplay ] and: [ color mightBeTranslucent ])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Cuis Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: `0@0` in: nil
						fillColor: color rule: Form over.
					Display forceToScreen]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:55:18' prior: 16887238!
            morphPositionInWorld

	self flag: #jmvVer2. "Solo para evitar los warning por falta de owner... pensar despues este caso"
	self isWorldMorph ifTrue: [ ^ `0@0` ].
	^super morphPositionInWorld! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 6/19/2017 15:55:22' prior: 50337471!
   viewBox

	^ worldState
		ifNotNil: [
			 `0@0` extent: extent ]
		ifNil: [
			self world viewBox ]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 6/19/2017 15:55:05' prior: 16887770!
 fillRects: rectangleList color: aColor
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."


	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		fillColor: aColor;
		combinationRule: Form over.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 150) wait! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 6/19/2017 15:55:09' prior: 16887789!
                             flashRects: rectangleList color: aColor
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."
	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."

	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		fillColor: aColor;
		combinationRule: Form reverse.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 250) wait.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ]! !
!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:55:26' prior: 50337487!
              newWorld
	"
[
	ProjectX stopUIProcess.
	ProjectX spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: `0@0` extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 6/19/2017 16:03:06' prior: 16837091!
                            morphContainsPoint: aLocalPoint

	| radius other delta xOverY |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [^ false].  "quick elimination"
	extent > `1@1`
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ extent y asFloat / 2.
	other _ extent x asFloat / 2.
	delta _ aLocalPoint - (other@radius).
	xOverY _ extent x asFloat / extent y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!HandleMorph methodsFor: 'events' stamp: 'jmv 6/19/2017 16:05:03' prior: 16852419!
                       keyStroke: aKeyboardEvent
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ aKeyboardEvent keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - `1@0` ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + `1@0` ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - `0@1` ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + `0@1` ].
	"Special case for return"
	aKeyboardEvent isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:04:48' prior: 16852446!
                              initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ `12@12`! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:25' prior: 16889457!
       initialize
	super initialize.
	extent _ `200@100`! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:30' prior: 16888083!
              draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:46' prior: 50359275!
               drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:15' prior: 16888316!
                  initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  `20 @ 15`! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 6/19/2017 15:55:52' prior: 16888418!
     morphContainsPoint: aLocalPoint

	| iconOrigin |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ extent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: (aLocalPoint - iconOrigin) rounded) not ]]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 6/19/2017 16:09:19' prior: 50359324!
                           example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: `120@35`.
	^ row
! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 6/19/2017 15:56:26' prior: 16889497!
                       addToScroller: aMorph

	scroller
		addMorph: aMorph position: `0@0`;
		morphExtent: aMorph morphExtent! !
!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:31' prior: 16889865!
                   initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ false.

	"initialize the receiver's scrollBars"
	scrollBar _ self scrollBarClass new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ self scrollBarClass new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ true.

	scroller _ self innerMorphClass new.
	self addMorph: scroller.
	self scrollerOffset: `0@ 0`.
	self addMorph: scrollBar.
	self addMorph: hScrollBar.! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 6/19/2017 15:56:31' prior: 16889992!
              scrollToShow: aRectangle
	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.
	This means that 0@0 is scrolling all the way top and all the way left"
	| delta |
	(aRectangle top >= 0 and: [
		aRectangle bottom <= self viewableHeight ])
		ifTrue: [
			"already visible"
			^self ].

	"Scroll end of selection into view if necessary"
	delta _ aRectangle amountToTranslateWithin: (`0@0` extent: self viewableExtent).
	delta y ~= 0 ifTrue: [
		self scrollBy: 0@delta y ]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 6/19/2017 15:55:58' prior: 16889279!
                     mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 6/19/2017 15:58:02' prior: 16926004!
                     invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(Different themes use various looks, this covers them all)"
	self invalidateLocalRect: (`0@0` extent: extent x @ (self labelHeight + borderWidth))! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:54' prior: 16926054!
                 drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: (`0@0` extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	"A border was drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	aCanvas fillRectangle: (borderWidth@borderWidth extent: extent x - (2*borderWidth)@ self labelHeight) color: titleColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:58' prior: 16926109!
drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: (`0@0` extent: extent)
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 16:37:43' prior: 16926132!
          makeMeFullyVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self morphExtent)]) ifTrue: [
		^ self "OK -- visible"].

	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: self morphExtentInWorld world: self world) topLeft! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 16:37:53' prior: 16926145!
                     makeMeVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:12:56' prior: 16926196!
                 minimumExtent

	^`160@80`! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:13:07' prior: 16926199!
             rescaleButtons
	"boxExtent changed.  Update my buttons."
	| buttonExtent buttonPos buttonDelta |
	buttonExtent := self boxExtent.
	buttonPos := `2@2`.
	buttonDelta := self boxExtent x + 2.
	self submorphsReverseDo: [ :aMorph |
		(aMorph is: #PluggableButtonMorph) 
		  ifTrue: [ 
				aMorph morphExtent: buttonExtent. 
				aMorph morphPosition: buttonPos.
				buttonPos := (buttonPos x  + buttonDelta) @ 2.
		].
	].
! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:57:49' prior: 16926215!
boxExtent
	"answer the extent to use in all the buttons. 
	 
	the label height is used to be proportional to the fonts preferences"
	| e |
	Theme current minimalWindows ifTrue: [^`0@0`].
	e _ Preferences windowTitleFont height.
	^e@e! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:12:42' prior: 16926276!
                       initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	
	self initializeLabelArea.
	extent _ `300 @ 200`.

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorphFront: m ].

	"by default"
	self beColumn! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:12:52' prior: 16926307!
                         initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing |
	spacing _ self boxExtent x + 2.
	self addMorph: self createCloseBox position: `2@2`.
	self addMorph: self createCollapseBox position: spacing+2@2.
	self addMorph: self createExpandBox position: spacing*2+2@2.
	self addMorph: self createMenuBox position: spacing*3+2@2! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 6/19/2017 15:58:05' prior: 16926374!
  layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww pos |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) morphPosition: cornerExtent@0 extent: w@thickness.
	(adjusters at: #bottomAdjuster) morphPosition: cornerExtent@(wh-thickness) extent: w@thickness.
	(adjusters at: #leftAdjuster) morphPosition: 0@cornerExtent extent: thickness@h.
	(adjusters at: #rightAdjuster) morphPosition: ww-thickness@cornerExtent extent: thickness@h.
	(adjusters at: #topLeftAdjuster) morphPosition: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) morphPosition: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) morphPosition: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) morphPosition: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos _ borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			morphPosition: pos
			extent: extent - pos - borderWidth ].
	
	layoutNeeded _ false! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 6/19/2017 16:13:13' prior: 50333187!
                            resize
	| resizeMorph |
	resizeMorph _ ResizeMorph new morphExtent: `200@150`.
	resizeMorph action: [self resize: (resizeMorph selectionRectangle: Display extent)].
	resizeMorph morphPosition: self world activeHand morphPosition.
	resizeMorph openInWorld
	! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:26' prior: 16811550!
                         initialExtent

	^`540@400`! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:18' prior: 16800076!
  initialExtent
	^`540@300`! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:38' prior: 16892600!
       initialExtent
	^ `640 @ 320`! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:32' prior: 50336305!
   initialExtent

	^`600@325`! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:35' prior: 16883318!
initialExtent

	^`300@500`! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:13:18' prior: 16928555!
    buildMorphicWindow

	self layoutMorph
		addMorph: self buildUpperControls proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.
	self setLabel: 'SUnit Test Runner'.
	self refreshWindow.
	self morphExtent: `460 @ 400`! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:09' prior: 16904515!
        drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: (color alphaMixed: 0.3 with: Theme current scrollbarColor)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/19/2017 16:07:49' prior: 16866514!
      addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleLikeMorph new.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 16) @ (pp y).
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:37:20' prior: 50341054!
       popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = `0@0` ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:08:25' prior: 50339204!
         popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:08:29' prior: 50339229!
      popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:08:18' prior: 50341130!
            initialize
	super initialize.
	extent _ `40@10`.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 6/19/2017 16:08:04' prior: 50359761!
   displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock position: `0@ -20`.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:07:56' prior: 16867223!
  adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p h |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: each minItemWidth].

	w _ w + 1.
	p _ `5 @ 5`.
	submorphs do: [ :m |
		h _ m morphHeight.
		m morphPosition: p extent: w@h.
		p _ p + (0@(h + 1)) ].

	self morphExtent: w+4 @ p y + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:08:14' prior: 16867241!
                         fitInWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| delta |
	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self morphPosition: ((self morphPosition x + 10 - extent x) @ self morphPosition y) ].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight:
			((owner world morphExtentInWorld y) max: (self morphPosition y) + 1)).
	delta = `0 @ 0` ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:43:48' prior: 16781484!
                              downButtonPosition
	^`0@0` + (extent - ScrollBar scrollbarThickness)! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:43:54' prior: 50359791!
                             drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (`0@0` extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 16:00:57' prior: 16781686!
    initializedInstance
	| completer m |
	completer _ SmalltalkCompleter withModel: (TextModel withText: 'Small').
	completer
		instVarNamed: 'position'
		put: 5.
	completer computeEntries.
	m _ AutoCompleterMorph
		completer: completer
		position: `200 @ 200`.
	completer instVarNamed: 'menuMorph' put: m.
	^m! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:36' prior: 50359846!
                        drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: `0@0`
		color: Color black! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:45' prior: 16851711!
        savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| fullBounds |
	fullBounds _ self morphFullBoundsInWorld.
	fullBounds ifNil: [ ^self ].

	fullBounds _ fullBounds intersect: (`0@0` extent: aCanvas extent).
	(savedPatch isNil or: [savedPatch extent ~= fullBounds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBounds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: fullBounds
		into: savedPatch.
	savedPatch offset: fullBounds topLeft.
	prevFullBounds
		ifNil: [ aStream nextPut: fullBounds ]
		ifNotNil: [ aStream nextPut: (fullBounds merge: prevFullBounds)].
	prevFullBounds _ fullBounds! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:52:41' prior: 16852160!
          initForEvents
	mouseOverHandler _ nil.
	lastMouseEvent _ MouseEvent new setType: #mouseMove position: `0@0` buttons: 0 hand: self.
	lastMouseEventTime _ Time localMillisecondClock.
	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.
	self dontWaitForMoreClicks! !
!ImageMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:49' prior: 16854128!
        drawOn: aCanvas

	aCanvas image: image at: `0@0`! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:40' prior: 50343917!
                        drawOn: aCanvas
	aCanvas
		drawString: (contents ifNil: [ '' ])
		at: `0@0`
		font: self fontToUse
		color: color
		! !
!StringMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:57:44' prior: 16918155!
                   fitContents
	"Measures contents later at #minimumExtent"
	self morphExtent: `0@0`! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:00' prior: 16854676!
            drawOn: aCanvas

	| tRect colorToUse sLeft aForm centeringOffset |
	isHighlighted ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) duller ].
	isSelected ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].
			
	tRect _ self toggleRectangle.
	aForm _ isExpanded 
		ifTrue: [ container expandedForm ]
		ifFalse: [ container notExpandedForm ].
	centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.

	complexContents hasContents ifTrue: [
		aCanvas 
			image: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	icon isNil
	ifFalse: [
		 aCanvas 
			image: icon
			at:  (tRect topLeft translatedBy:  icon width  @ centeringOffset).
		sLeft _ indentLevel * 12 + 16 + (icon width + 2).
	]
	ifTrue: [
		sLeft _ indentLevel * 12 + 16.
	].
	colorToUse _ complexContents preferredColor ifNil: [ color ].

	aCanvas
		drawString: contents asString
		at: sLeft@0
		font: self fontToUse
		color: colorToUse! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:06:04' prior: 16865800!
                contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:42' prior: 16865892!
                          drawOn: aCanvas 
	| stringColor leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: (`0@0` extent: extent) color: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScaleAndTransparent ].
			aCanvas image: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
			leftEdge _ leftEdge + iconForm width + self iconSeparation].

	aCanvas
		drawString: contents
		at: leftEdge @ 1
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			image: self class subMenuMarker
			at: extent x - 8 @ (extent y - self class subMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:06:09' prior: 16866103!
                            initialize
	"initialize the state of the receiver"
	super initialize.
	""
	extent _ `10@10`.
	contents _ ''.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ Preferences standardMenuFont! !
!MenuItemMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:06:26' prior: 16866117!
            measureContents
	| e |
	e _ super measureContents.
	^e y > 12
		ifTrue: [e+`2@2`]
		ifFalse: [e+`2@1`]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 6/19/2017 15:53:59' prior: 50341145!
                              select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + `10@0`
											with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !
!MenuItemMorph class methodsFor: 'cached state access' stamp: 'jmv 6/19/2017 16:06:33' prior: 16866204!
                              subMenuMarker

	| f |
	SubMenuMarker ifNotNil: [ ^SubMenuMarker ].
	f _ Form
		extent: `5@9`
		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)
		offset: `0@0`.
	SubMenuMarker _ ColorForm mappingWhiteToTransparentFrom: f.
	^SubMenuMarker! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:34' prior: 16862884!
                  drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: color! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 15:53:38' prior: 16863315!
                         layoutBounds
	"Return the bounds for laying out children of the receiver"

	^`0@0` extent: extent! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:05:36' prior: 16863335!
        layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth 
		fractionalWidths integerWidths theLeft usableHeight boundsTop boundsRight theTop minWidth submorphsToLayout 
			nextMorph ht wd ls theRight boundsBottom theBottom alternativeWidths count diff i |
	
	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableWidth := boundsForLayout width - ((submorphsToLayout size + 1) * xSep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth := usableWidth - sumOfFixed max: 0.
	normalizationFactor := self proportionalWidthNormalizationFactor.
	availableForPropWidth := availableForPropWidth * normalizationFactor.
	
	fractionalWidths := submorphsToLayout collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerWidths _ fractionalWidths collect: [ :w | w rounded ].
	diff _ integerWidths sum - fractionalWidths sum rounded.
	alternativeWidths _ diff > 0 ifTrue: [ fractionalWidths collect: [ :w | w floor ]] ifFalse: [ fractionalWidths collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerWidths at: i) = (alternativeWidths at: i) ifFalse: [
			integerWidths at: i put: (alternativeWidths at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minWidth := integerWidths sum.
	theLeft := ((usableWidth - minWidth) * (padding ifNil: [0]) max: 0) + boundsForLayout left + xSep.
	usableHeight := boundsForLayout height - (ySep * 2) max: 0.
	boundsTop    := boundsForLayout top + ySep.
	boundsRight  := boundsForLayout right - xSep.
	boundsBottom := boundsForLayout bottom - ySep.

	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		wd := integerWidths at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		ht := (ls heightFor: usableHeight) min: usableHeight.
		theTop := ((usableHeight - ht) * ls minorDirectionPadding) floor + boundsTop.
		theBottom := (theTop + ht) ceiling min: boundsBottom.
		theRight := (theLeft + (wd min: minWidth)) "ceiling "min: boundsRight.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theLeft := theRight + xSep
	]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:05:46' prior: 16863426!
  layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight 
		fractionalHeights integerHeights theTop usableWidth boundsLeft boundsBottom theLeft minHeight submorphsToLayout 
			nextMorph ht wd ls theBottom boundsRight theRight alternativeHeights count diff i |

	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableHeight := boundsForLayout height - ((submorphsToLayout size + 1) * ySep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight := usableHeight - sumOfFixed max: 0.
	normalizationFactor := self proportionalHeightNormalizationFactor.
	availableForPropHeight := availableForPropHeight * normalizationFactor.
	
	fractionalHeights := submorphsToLayout collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerHeights _ fractionalHeights collect: [ :w | w rounded ].
	diff _ integerHeights sum - fractionalHeights sum rounded.
	alternativeHeights _ diff > 0 ifTrue: [ fractionalHeights collect: [ :w | w floor ]] ifFalse: [ fractionalHeights collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerHeights at: i) = (alternativeHeights at: i) ifFalse: [
			integerHeights at: i put: (alternativeHeights at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minHeight := integerHeights sum.
	theTop := ((usableHeight - minHeight) * (padding ifNil: [0]) max: 0) + boundsForLayout top + ySep.
	usableWidth     := boundsForLayout width - (xSep * 2) max: 0.
	boundsLeft      := boundsForLayout left + xSep.
	boundsBottom := boundsForLayout bottom - ySep.
	boundsRight := boundsForLayout right - xSep.
	
	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		ht := integerHeights at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		wd := (ls widthFor: usableWidth) min: usableWidth.
		theLeft := ((usableWidth - wd) * ls minorDirectionPadding) floor + boundsLeft.
		theRight := (theLeft + wd) ceiling min: boundsRight.
		theBottom := (theTop + (ht min: minHeight)) "ceiling" min: boundsBottom.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theTop := theBottom + ySep
	]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:10:33' prior: 16896264!
                       initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress _ ProgressBarMorph new.
	progress morphExtent: `200 @ 15`.
	self addMorphFront: labelMorph.
	self addMorphFront: subLabelMorph.
	self addMorph: progress fixedHeight: 15.! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:21' prior: 16850527!
                     drawOn: aCanvas

	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: color
		at: `0@0`! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:52:25' prior: 50360436!
      addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:04:44' prior: 16850943!
    basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self class handleSize.
	anExtent _ ((extent x + self class handleSize + 8) max: minSide) @
				((extent y + self class handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld center extent: anExtent.
	w _ self world ifNil: [ target world ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: `8@8`) ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:52:32' prior: 16851149!
                    startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self removeAllHandlesBut: growHandle.  "remove all other handles"
	botRt _ target morphPositionInWorld + target morphExtentInWorld.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [`0@0`]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:36:31' prior: 16854885!
     itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	self hasSubmorphs ifFalse: [ ^nil ].
	(aPoint > `0@0` and: [ aPoint < extent ]) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	self firstSubmorph morphPosition y > ptY ifTrue: [ ^nil ].
	last _ self lastSubmorph.
	last morphPosition y + last morphHeight < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^self 
		findSubmorphBinary: [ :m |
			(m morphPosition y <= ptY and: [ m morphPosition y + m morphHeight >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPosition y + (m morphHeight // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:10' prior: 16855151!
                      drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds color: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:15' prior: 16855170!
        drawHighlightOn: aCanvas
"Ademas, poner el mouse pointer de relojito si tarda... Detectarlo automaticamente, etc. Aunque no estoy seguro de como hacerlo... quizas colgar un cachito de codigo en un proceso de mayor prioridad, onda 'si pasa 1 segundo, y todavia no te resetee este flag, entonces pone el relojito'"
	| selectionDrawBounds |
	highlightedRow  ifNil: [ ^self ].
	highlightedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: highlightedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus) duller! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:20' prior: 16855209!
   drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:24' prior: 16855570!
                    drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		textComposition: self textComposition
		bounds: (`0@0` extent: extent)
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:15:44' prior: 50360553!
   initialize
	super initialize.
	extent _ `400@300`.
	color _ Color white.
	grid _ `8@6`.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:19' prior: 16844103!
                        createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `2@7.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:31' prior: 16844116!
createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `12@7.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:37' prior: 16844129!
                               createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	result morphExtent: `24@2` * self sizeUnit.
	self addMorph: result position: `2@0.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:44' prior: 16844140!
                         createTextPaneAcceptOnCR: acceptBoolean
	"create the textPane"
	| result |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"

	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	result morphExtent: `18@5` * self sizeUnit.
	self addMorph: result position: `1@2` * self sizeUnit.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:48' prior: 16844169!
   initialize

	super initialize.
	extent _ `20@10` * self sizeUnit.
	responseUponCancel _ ''! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:48:53' prior: 16844226!
      drawOn: aCanvas

	Theme current roundWindowCorners
		ifTrue: [
			aCanvas
				roundRect: (`0@0` extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ]! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:58:30' prior: 16938600!
               drawOn: aCanvas
	Transcript
		showOnDisplay: true;
		displayOn: form in: (`0@0` extent: extent).
	aCanvas image: form at: `0@0`.
	Transcript
		bounds: self morphBoundsInWorld;
		showOnDisplay: doImmediateUpdates.
	self updateWorkspace! !
!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:54:11' prior: 16866232!
                            drawOn: aCanvas 
	| baseColor |
	baseColor _ owner color.
	aCanvas
		fillRectangle: (`0@0` corner: extent x @ (extent y / 2))
		color: baseColor twiceDarker.
			
	aCanvas
		fillRectangle: (0 @ (extent y / 2) corner: extent)
		color: baseColor twiceLighter! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:06:38' prior: 16866243!
initialize
	super initialize.
	extent _ `50 @ 2`! !
!MenuLineMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:07:43' prior: 16866250!
                     minimumExtent

	^`10@2`! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 6/19/2017 15:59:45' prior: 50339585!
             tryDeferredUpdatingAndSetCanvas
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		world morphPosition: `0@0` extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 6/19/2017 15:54:47' prior: 16877833!
                   startDispatchFrom: aHand
	"double dispatch the event dispatch"
	"An event of an unknown type was sent. What shall we do?!!"

	Smalltalk beep. 
	self printString displayAt: `0@0`.
	self wasHandled: true! !
!MorphicCanvas methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:54:34' prior: 16877393!
                           newClipRect: aRectangleOrNil
	"aRectangle is in world coordinates.
	But ivar clipRect is relative to the form,
	For example, if we had previously been built like
		aCanvas on: someForm over: (100@100 extent 200@100)
	then our origin would be -100 @ -100.
	Then, a clipRect argument like (120@120 extent: 40@30) would mean affecting
	only (20@20 extent: 40@30) in our form"

	self setClipRect: (aRectangleOrNil
		ifNil: [ `0@0` corner: form extent ]
		ifNotNil: [ aRectangleOrNil translatedBy: self canvasOrigin ])! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 6/19/2017 16:08:51' prior: 50360744!
     drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > `50@50`
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Color yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Color yellow! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/19/2017 16:09:00' prior: 50360761!
                             drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Color black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Color black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Color white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + `0@2`
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + `0@1`
		font: fontOrNil
		color: aColor! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/19/2017 15:54:38' prior: 16877657!
            textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc
	| displayScanner leftInRun line boundsInWorld tl |

	tl _ boundsRect topLeft.
	boundsInWorld _ currentTransformation displayBoundsOfTransformOf: boundsRect.

	displayScanner _ MorphicScanner new
		defaultFont: aTextComposition defaultFont;
		text: aTextComposition textComposed
		foreground: c.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aTextComposition lineIndexForPoint: (`0@0` max: (clipLeft@clipTop)- boundsInWorld origin))
		to: (aTextComposition lineIndexForPoint: (boundsInWorld extent min: (clipRight@clipBottom+1) - boundsInWorld origin))
		do: [ :i |
			line _ aTextComposition lines at: i.
			aTextComposition
				displaySelectionInLine: line
				on: self
				textTopLeft: tl
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line textTopLeft: tl leftInRun: leftInRun  ]! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:54:43' prior: 16877740!
                              onForm: aForm

	^ self basicNew
		initializeWith: aForm origin: `0@0`! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 6/19/2017 15:45:38' prior: 16787053!
  fillRectangle: aRectangle tilingWith: aForm sourceRect: patternBox rule: aCombinationRule
	"aRectangle is in form coordinates, no transformation is done."
	| displayRectangle  additionalOffset clippedPort targetTopLeft clipOffset ex 
	targetBox savedMap top left |
	
	ex _ patternBox extent.
	ex x = 0 ifTrue: [ ^self ].
	ex y = 0 ifTrue: [ ^self ].
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.

	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.
	something better is needed, but not now"

	additionalOffset _ `0@0`.
	clippedPort _ port clippedBy: displayRectangle.
	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.
	clipOffset _ displayRectangle topLeft - targetTopLeft.
	additionalOffset _ (clipOffset \\ ex) - ex.

	"do it iteratively"
	targetBox _ clippedPort clipRect.
	savedMap _ clippedPort colorMap.
	clippedPort sourceForm: aForm;
		fillColor: nil;
		combinationRule: aCombinationRule;
		sourceRect: patternBox;
		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).
	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.
	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.

	left to: (targetBox right - 1) by: patternBox width do: [:x |
		top to: (targetBox bottom - 1) by: patternBox height do: [:y |
			clippedPort destOrigin: x@y; copyBits]].
	clippedPort colorMap: savedMap! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 6/19/2017 15:45:51' prior: 50360833!
          steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (`0@0` extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				roundRect: (`1@1` extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 6/19/2017 16:01:13' prior: 50360910!
              buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - `1@2`.
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Color r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Color transparent ]
				ifFalse: [
					borderSpec = (Color r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Color white]
								ifFalse: [Color black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!TextComposition methodsFor: 'selection' stamp: 'jmv 6/19/2017 16:13:22' prior: 16931067!
 defaultCharacterBlock
	^ CharacterBlock
		stringIndex: 1
		text: model actualContents
		topLeft: lines first topLeft
		extent: `0 @ 0`
		textLine: lines first! !
!DifferenceFinder methodsFor: 'private' stamp: 'jmv 6/19/2017 16:02:44' prior: 16834082!
     maxLengthPoints
	| max points |
	max := self maxLength.
	max = 0 ifTrue: [^Array with: `0 @ 0`].
	points := OrderedCollection new.
	tally withIndexesDo: [:i :j :t | t = max ifTrue: [points add: i @ j]].
	^points! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3115-UseLiteralPoints-JuanVuletich-2017Jun19-16h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3115] on 20 June 2017 at 5:50:34 pm'!
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:47:09' prior: 16919543!
    browseObsoleteMethodReferences
	"Open a browser on all referenced behaviors that are obsolete
		Smalltalk browseObsoleteMethodReferences
	Remember that if no methods reference obsoletes, but
		Smalltalk obsoleteBehaviors inspect
	still finds them, maybe they are referenced by ChangeSets!!
	"
	| list |
	list _ self obsoleteMethodReferences.
	self browseMessageList: list name:'Method referencing obsoletes' autoSelect: nil! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:46:17' prior: 16919851!
                       obsoleteBehaviors
	"
	Smalltalk obsoleteBehaviors inspect
	Find all obsolete behaviors including meta classes
	"
	| obs |
	obs _ OrderedCollection new.
	Smalltalk garbageCollect.
	self allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [obs add: cl]].
	^ obs asArray! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:46:10' prior: 16919891!
  obsoleteMethodReferences
	"
	Smalltalk obsoleteMethodReferences
	Smalltalk browseObsoleteMethodReferences
	Open a browser on all referenced behaviors that are obsolete"
	| obsClasses obsRefs references |
	references _ WriteStream on: Array new.
	obsClasses _ self obsoleteBehaviors.
	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor mousePoint
		from: 1 to: obsClasses size during: [ :bar |
	obsClasses keysAndValuesDo: [ :index :each |
		bar value: index.
		obsRefs _ self pointersTo: each except: obsClasses.
		obsRefs do: [ :ref |
			"Figure out if it may be a global"
			(ref isVariableBinding and: [ ref key isString "or Symbol" ]) ifTrue: [
				(self pointersTo: ref) do: [ :meth |
					(meth is: #CompiledMethod) ifTrue: [
						meth methodReference ifNotNil: [ :mref |
							(mref isValid and: [ mref compiledMethod == meth]) ifTrue: [
								references nextPut: mref ]]]]]]].
	].
	^references contents! !
!MethodReference methodsFor: 'queries' stamp: 'jmv 6/20/2017 13:30:02' prior: 16873082!
                       printOn: aStream
	"Print the receiver on a stream"

	super printOn: aStream.
	aStream
		space;
		nextPutAll: classSymbol.
	classIsMeta ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: ' >> ';
		nextPutAll: methodSymbol! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3116-obsoleteMethodRefs-fix-JuanVuletich-2017Jun20-17h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3115] on 20 June 2017 at 5:51:43 pm'!
!Color methodsFor: 'conversions' stamp: 'jmv 6/20/2017 17:46:14' prior: 50353451!
                   pixelValueForDepth: d
	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	"Most common case"
	"eight bits per component; top 8 bits set to all ones (opaque alpha)"
	d = 32 ifTrue: [
		^ 16rFF000000 bitOr:
			((((self at: 1) * 255.999) truncated bitShift: 16) bitOr:
			((((self at: 2) * 255.999) truncated bitShift: 8) bitOr: 
			(((self at: 3) * 255.999) truncated))) ].

"Faster in 32 bit systems, but slower in 64 bits"
"	d = 32 ifTrue: [
		val _ LargePositiveInteger new: 4.
		val at: 3 put: ((self at: 1) * 255.999) truncated.
		val at: 2 put: ((self at: 2)  * 255.999) truncated.
		val at: 1 put: ((self at: 3)  * 255.999) truncated.
		val at: 4 put: 16rFF.
		^ val normalize]."

	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val _ ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val _ ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val _ ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3117-pixelValueForDepth-speedup-JuanVuletich-2017Jun20-17h50m-jmv.1.cs.st----!

----SNAPSHOT----#(20 June 2017 5:57:31.430286 pm) Cuis5.0-3117-v3.image priorSource: 400355!

----QUIT----#(20 June 2017 5:57:49.378972 pm) Cuis5.0-3117-v3.image priorSource: 1058207!

----STARTUP----#(27 June 2017 7:12:15.894997 am) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3117-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3117] on 20 June 2017 at 11:19:24 pm'!
!WorldState methodsFor: 'initialization' stamp: 'jmv 6/20/2014 20:24:55' prior: 16945777!
                            clearWaitDelay
	waitDelay ifNotNil: [
		waitDelay unschedule.
		waitDelay _ nil ].
	"Needed if for some reason Cuis is started with an earlier DateTime than the image was saved.
	Might happen, especially on RasPi or other systems without an RTC"
	lastCycleTime _ Time localMillisecondClock.
	lastAlarmTime _ 0.! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3118-FixHangWhenStartupInThePast-JuanVuletich-2017Jun20-23h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 18 June 2017 at 5:34:41 am'!
!Browser methodsFor: 'class comment pane' stamp: 'pb 6/18/2017 05:34:23' prior: 16791499!
                          newClassComment: aText
	"The user has just entered aText.
	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."
	| theClass |
	theClass _ self selectedClassOrMetaClass theNonMetaClass.
	theClass ifNotNil: [
		theClass classComment: aText asString ].
	self changed: #classCommentText.
	^ true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3119-Class-comment-editor-fix-PhilBellalouna-2017Jun18-05h34m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3119] on 22 June 2017 at 12:54:43 pm'!
!Color methodsFor: 'as yet unclassified' stamp: 'jmv 6/22/2017 12:54:10'!
                convertToCurrentVersion: varDict refStream: smartRefStrm

	"subclasses should implement if they wish to convert old instances to modern ones"
	self size = 0 ifTrue: [
		^ Color new copyFrom: (varDict at: 'floatRGB') ].
	^ self! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3120-MigrateColorInstancesInSmartRefStream-JuanVuletich-2017Jun22-12h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3120] on 26 June 2017 at 8:03:37 pm'!
!ReadStream methodsFor: 'accessing' stamp: 'jmv 6/26/2017 19:34:17'!
                         readInto: byteArray startingAt: startIndex count: count
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| max |
	max _ (readLimit - position) min: count.
	byteArray 
		replaceFrom: startIndex 
		to: startIndex+max-1
		with: collection
		startingAt: position+1.
	position _ position + max.
	^max! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3121-ReadStream-readInto-JuanVuletich-2017Jun26-19h32m-jmv.1.cs.st----!

----SNAPSHOT----#(27 June 2017 7:12:23.031476 am) Cuis5.0-3121-v3.image priorSource: 1058301!

----QUIT----#(27 June 2017 7:12:36.833399 am) Cuis5.0-3121-v3.image priorSource: 1061159!

----STARTUP----#(2 August 2017 3:58:12.972093 pm) as C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\Cuis5.0-3121-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 6 July 2017 at 3:13:37 am'!
!ScrollBar methodsFor: 'access' stamp: 'pb 7/6/2017 02:44:45'!
                          scrollValue
	^ value! !
!ScrollBar methodsFor: 'model access' stamp: 'pb 7/6/2017 02:53:19'!
   internalScrollValue: newValue
	"Called internally for propagation to model"
	self scrollValue: newValue.
	setValueSelector ifNotNil: [
		model perform: setValueSelector with: value ]! !
!ScrollBar methodsFor: 'model access' stamp: 'pb 7/6/2017 02:45:15'!
 scrollValue: newValue
	"Drive the slider position externally..."
	value _ newValue min: 1.0 max: 0.0.
	self computeSlider! !
!ProgressBarMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:42:04'!
                          progressValue
	^value! !
!ProgressBarMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:42:12'!
                              progressValue: aValue
	value _ aValue.
	self redrawNeeded! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 10/10/2015 23:26' prior: 16891768!
       fileInAnnouncing: announcement
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :bar | 
			[ self atEnd ] whileFalse: [
					bar value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, 
									because next line is a doit that does the stuff
									(or because it is handled elsewhere)"
									(chunk beginsWith: 'description:  ')
									| (chunk beginsWith: 'provides: ')
									| (chunk beginsWith: 'requires: ')
									| (chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Compiler evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Compiler evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex pass ]
										]] 
							on: InMidstOfFileinNotification
							do: [ :ex | ex resume: true ] ].
			].
	"Note:  The main purpose of this banner is to flush the changes file."
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !
!PositionableStream methodsFor: 'gui' stamp: 'pb 7/6/2017 02:51:46' prior: 16892012!
           untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :bar |
			[ self atEnd ] whileFalse: [
				bar scrollValue: self position.
				aBlock value ]]! !
!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'pb 7/6/2017 02:52:33' prior: 16896176!
          testInnermost

	"test the progress code WITHOUT special handling"

	^'Now here''s some Real Progress'
		displayProgressAt: Sensor mousePoint
		from: 0 
		to: 10
		during: [ :bar |
			1 to: 10 do: [ :x | 
				bar scrollValue: x.
				(Delay forMilliseconds: 500) wait.
				x = 5 ifTrue: [1/0].	"just to make life interesting"
			].
			'done'
		].

! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'pb 7/6/2017 02:46:41' prior: 16889660!
       hSetScrollDelta
	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."
	| range delta w |
	
	delta _ self scrollDeltaWidth * 1.0.		"avoid Fraction arithmetic"
	range _ self hLeftoverScrollRange.
	range = 0 ifTrue: [
		^hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; internalScrollValue: 0 ].

	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."
	w _ self viewableWidth * 1.0.		"avoid Fraction arithmetic"
	hScrollBar scrollDelta: delta / range pageDelta: w - delta / range.
	hScrollBar interval: w / self hTotalScrollRange.
	hScrollBar internalScrollValue: hScrollBar scrollValue! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'pb 7/6/2017 02:48:25' prior: 16889801!
                         vSetScrollDelta
	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."
	| range delta h |
	
	delta _ self scrollDeltaHeight * 1.0.	"avoid Fraction arithmetic"
	range _ self vLeftoverScrollRange.
	range = 0 ifTrue: [
		^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; internalScrollValue: 0 ].

	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."
	h _ self viewableHeight * 1.0. 		"avoid Fraction arithmetic"
	scrollBar scrollDelta: delta / range pageDelta: h - delta / range.
	scrollBar interval: h / self vTotalScrollRange.
	scrollBar internalScrollValue: scrollBar scrollValue! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:00' prior: 16889930!
                          hideOrShowScrollBars

	"Assume for a moment we don't need an horizontal scrollbar"
	self hHideScrollBar.

	"Add or remove vertical scrollbar, asuming for a monent there's no horizontal scrollbar,
	to determine need of horizontal scrollbar..."
	self vIsScrollbarNeeded
		ifTrue: [ self vShowScrollBar ]
		ifFalse: [ self vHideScrollBar ].

	"If we need an horizontal scrollbar, add it."
	self hIsScrollbarNeeded ifTrue: [
		self hShowScrollBar.

		"If horizontal scrollbar is needed, maybe vertical scrollbar will be needed too (even if we previously thoutht it wouldn't be needed)."	
		"Note that there is no chance of modifying the need of horizontal scrollbar: it was already needed. Therefore, there is no circularity here."
		self vIsScrollbarNeeded  ifTrue: [
			self vShowScrollBar ]].

	"Ensure that if no scrollbars are needed, whole contents are visible"
	self vIsScrollbarShowing ifFalse: [
		scrollBar internalScrollValue: 0 ].
	self hIsScrollbarShowing ifFalse: [
		hScrollBar internalScrollValue: 0 ].

	self updateScrollBarsBounds! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:51:24' prior: 16889965!
            scrollBy: delta
	"Move the contents in the direction delta."

	| newYoffset r newXoffset |
	
	"Set the offset on the scroller"
	newYoffset _ self scrollerOffset y - delta y max: 0.
	newXoffset _ self scrollerOffset x - delta x max: 0.
	
	self scrollerOffset: newXoffset@ newYoffset.

	"Update the scrollBars"
	(r _ self vLeftoverScrollRange) = 0
		ifTrue: [ scrollBar scrollValue: 0.0 ]
		ifFalse: [ scrollBar scrollValue: newYoffset asFloat / r ].
	(r _ self hLeftoverScrollRange) = 0
		ifTrue: [ hScrollBar scrollValue: 0.0 ]
		ifFalse: [ hScrollBar scrollValue: newXoffset asFloat / r ]! !
!PluggableListMorph methodsFor: 'selection' stamp: 'pb 7/6/2017 02:47:04' prior: 16889020!
                    scrollSelectionIntoView
	"make sure that the current selection is visible"
	| row r |
	row _ self getCurrentSelectionIndex.
	row = 0 
		ifTrue: [
			"Value is 0, but we need to propagate it to model"
			scrollBar internalScrollValue: scrollBar scrollValue ]
		ifFalse: [
			self flag: #jmvVer2.
			r _ self listMorph drawBoundsForRow: row.
			r _ ((self listMorph externalize: r origin) extent: r extent).
			self scrollToShow: r ]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'pb 7/6/2017 02:56:44' prior: 50362986!
               mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar scrollValue < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:48' prior: 16904721!
                     scrollByPage
	"Scroll automatically while mouse is down"
	nextPageDirection
		ifTrue: [self internalScrollValue: (value + pageDelta min: 1.0)]
		ifFalse: [self internalScrollValue: (value - pageDelta max: 0.0)]
! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:59' prior: 16904734!
                       scrollDown: count
	self internalScrollValue: (value + (scrollDelta * count) + 0.000001 min: 1.0)! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:49:09' prior: 16904739!
          scrollTo: handPositionRelativeToSlider
	| v handPositionRelativeToUs |
	grabPosition ifNotNil: [
		handPositionRelativeToUs _ slider externalize: handPositionRelativeToSlider.
		v _ (self isHorizontal
			ifTrue: [ handPositionRelativeToUs x - grabPosition x ]
			ifFalse: [ handPositionRelativeToUs y - grabPosition y ])
				- borderWidth - self buttonExtent * 1.0
					/ self freeSliderRoom.
		self internalScrollValue: v ]! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:49:21' prior: 16904758!
  scrollUp: count
	self internalScrollValue: (value - (scrollDelta * count) - 0.000001 max: 0.0)! !
!ProgressBarMorph methodsFor: 'menu' stamp: 'pb 7/6/2017 02:57:29' prior: 16896049!
          changeProgressValue: evt
	| answer |
	answer _ FillInTheBlankMorph
		request: 'Enter new value (0 - 1.0)'
		initialAnswer: self progressValue contents asString.
	answer isEmptyOrNil ifTrue: [^ self].
	self progressValue: answer asNumber! !
!ProgressMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:57:41' prior: 16896233!
                          done
	^progress progressValue! !
!ProgressMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:52:47' prior: 16896236!
         done: amountDone
	progress progressValue: ((amountDone min: 1.0) max: 0.0)! !
!InnerTextMorph methodsFor: 'editing' stamp: 'pb 7/6/2017 02:47:26' prior: 50336490!
                             acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar scrollValue.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar internalScrollValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

ProgressBarMorph removeSelector: #value!

ProgressBarMorph removeSelector: #value!

ProgressBarMorph removeSelector: #value:!

ProgressBarMorph removeSelector: #value:!

ScrollBar removeSelector: #setValue:!

ScrollBar removeSelector: #setValue:!

ScrollBar removeSelector: #value!

ScrollBar removeSelector: #value!

ScrollBar removeSelector: #value:!

ScrollBar removeSelector: #value:!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3122-Morphs-Distinct-value-Methods-PhilBellalouna-2017Jul06-02h42m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 15 July 2017 at 10:07:51 pm'!
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'pb 7/15/2017 22:07:40' prior: 50337148!
                        stepAt: millisecondSinceLast

	self contents: (target perform: getSelector) asString! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3123-UpdatingStringMorph-Squeak-compatibility-PhilBellalouna-2017Jul15-22h07m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 15 July 2017 at 11:19:17 pm'!
!PluggableButtonMorph methodsFor: 'as yet unclassified' stamp: 'pb 7/15/2017 23:15:35'!
                          morphExtent
	"Use extent if it has already been manually set, otherwise try to set it by computing from the label text and font, otherwise try using the icon extent, or finally fall back to the default value."
	^ extent ifNil: [
		extent := (self fontToUse notNil and: [ label notNil ])
			ifTrue: [ "Add a bit of padding"
				(self fontToUse widthOfString: label) + 10 @ (self fontToUse height + 10) ]
			ifFalse: [
				icon
					ifNil: [ `20@15` ]
					ifNotNil: [ icon extent ]]].! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'pb 7/15/2017 22:34:12' prior: 16899252!
                              morphHeight

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ self morphExtent y! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'pb 7/15/2017 22:34:52' prior: 16899265!
                              morphPosition: newPos extent: newExtent
	"Change the position of this morph. Argument is in owner's coordinates."

	| oldBoundsInWorld someChange |

	"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
	oldBoundsInWorld _ self morphBoundsInWorld.
	someChange _ false.
	(location isTranslation: newPos) ifFalse: [
		location _ location withTranslation: newPos.
		someChange _ true ].

	self morphExtent = newExtent ifFalse: [
		(self privateExtent: newExtent) ifTrue: [
			someChange _ true ]].

	someChange ifTrue: [
		"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
		oldBoundsInWorld ifNotNil: [
			self invalidateDisplayRect: oldBoundsInWorld from: nil ].
		self someSubmorphPositionOrExtentChanged.
		owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
		self redrawNeeded ]! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'pb 7/15/2017 22:34:20' prior: 16899296!
              morphWidth

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ self morphExtent x! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:40:30' prior: 50362831!
                              draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (`0@0` extent: self morphExtent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:40:17' prior: 16888097!
      drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ self morphExtent // 2.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ self morphExtent x - labelMargin - labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: colorForLabel
			embossed: true ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:39:57' prior: 16888142!
                       drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ self morphExtent // 2.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ self morphExtent x - labelMargin - labelMargin - 1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:39:34' prior: 50362846!
                   drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (`0@0` extent: self morphExtent) insetBy: `1@3`.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (`0@0` extent: self morphExtent) insetBy: `1@3`.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'pb 7/15/2017 22:36:46' prior: 50362888!
                               initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle := nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model := nil.
	getStateSelector := nil.
	actionSelector := nil.
	isPressed := false.
	mouseIsOver := false.
	actWhen := #buttonUp.
	"We are overriding any value populated in extent by our superclass with nil so we know to perform the inital morph extent calculation"
	extent := nil! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'pb 7/15/2017 22:36:28' prior: 50337959!
      magnifiedIcon
	| factor magnifiedExtent w h |

	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon := icon.
		w := icon width.
		h := icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * self morphExtent x / w min: 1.0 * self morphExtent y / h.
			(factor < 1 or: [ factor > 1.7 and: [self isRoundButton]]) ifTrue: [
				magnifiedExtent := (icon extent * factor) rounded.
				magnifiedIcon := icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'pb 7/15/2017 22:38:44' prior: 50362902!
                morphContainsPoint: aLocalPoint

	| iconOrigin |
	((`0@0` extent: self morphExtent) containsPoint: aLocalPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin := self morphExtent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: (aLocalPoint - iconOrigin) rounded) not ]]! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3124-PluggableButtonMorph-initial-extent-PhilBellalouna-2017Jul15-22h29m-pb.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 16 July 2017 at 3:33:18 pm'!
!Morph methodsFor: 'events' stamp: 'pb 7/16/2017 15:06:53'!
                             mouseHover: aMouseMoveEvent localPosition: localEventPosition
	"Handle a mouse move event.
	This message will only be sent to Morphs that answer true to #handlesMouseHover for events that have not been previously handled.
	We can query aMouseMoveEvent to know about pressed mouse buttons."
	"Allow instances to dynamically use properties for handling common events."
	self
		valueOfProperty: #mouseHover:localPosition:
		ifPresentDo: [ :handler |
			handler
				value: aMouseMoveEvent
				value: localEventPosition ].! !
!Morph methodsFor: 'event handling testing' stamp: 'pb 7/16/2017 15:00:51'!
           handlesMouseHover
	"Do I want to receive unhandled mouseMove events when the button is up and the hand is empty?  The default response is false."
	"Use a property test to allow individual instances to specify this."
	^ self hasProperty: #handlesMouseHover.! !
!Morph methodsFor: 'events-processing' stamp: 'pb 7/16/2017 15:31:38' prior: 16875080!
     processMouseOver: aMouseEvent localPosition: localEventPosition
	"System level event handling."
	 self hasMouseFocus ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: localEventPosition event: aMouseEvent) ifFalse: [
			^self ]].
	aMouseEvent hand noticeMouseOver: self event: aMouseEvent.
	"Open question: should any unhandled mouse move events be filtered out? (i.e. should mouseHover:localPosition: be called when a mouse button is pressed but the morph doesn't have mouse button handlers?  Essentially, what are the limits of what is considered 'hovering'?"
	(self handlesMouseHover and: [aMouseEvent wasHandled not]) ifTrue: [
		self
			mouseHover: aMouseEvent
			localPosition: localEventPosition ].! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3125-Morph-hovering-PhilBellalouna-2017Jul16-15h00m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3122] on 17 July 2017 at 3:52:45 pm'!
!ChangeList methodsFor: 'scanning' stamp: 'jmv 7/17/2017 15:44:04' prior: 16795940!
                        scanFile: aFile from: startPosition to: stopPosition

	file _ aFile.
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	file position: startPosition.
	'Scanning ', aFile localName, '...'
		displayProgressAt: Sensor mousePoint
		from: startPosition to: stopPosition
		during: [ :barBlock |
			[file position < stopPosition] whileTrue: [ | prevChar |
				barBlock value: file position.
				[file atEnd not and: [file peek isSeparator]]
					whileTrue: [prevChar _ file next].
				(file peekFor: $!!)
					ifTrue: [
						"A line starting with $!! means a specific ChangeRecord type"
						(prevChar notNil and: [ prevChar isLineSeparator ])
							ifTrue: [self scanSpecificChangeRecordType]]
					ifFalse: [
						"Otherwise, interpret it with #doIt:"
						| itemPosition item |
						itemPosition _ file position.
						item _ file nextChunk.
						item size > 0 ifTrue: [
							self
								addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)
								text: 'do it: ' , (item contractTo: 160)]]]].
	self clearSelections! !
!ClassBuilder methodsFor: 'private' stamp: 'jmv 7/17/2017 15:48:14' prior: 16803943!
                  informUserDuring: aBlock
	self class isSilent ifTrue:[^aBlock value].
	Utilities informUserDuring:[:barBlock|
		progress _ barBlock.
		aBlock value].
	progress _ nil.! !
!Integer class methodsFor: 'prime numbers' stamp: 'jmv 7/17/2017 15:44:55' prior: 16861068!
                          verbosePrimesUpTo: max do: aBlock
	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"
	"Compute primes up to max, but be verbose about it"
	| lastTime |
	lastTime := Time localMillisecondClock.
	Utilities informUserDuring: [ :barBlock|
		barBlock value:'Computing primes...'.
		self primesUpTo: max do: [ :prime| | nowTime |
			aBlock value: prime.
			nowTime := Time localMillisecondClock.
			(nowTime - lastTime > 1000) ifTrue:[
				lastTime := nowTime.
				barBlock value: 'Last prime found: ', prime printString]]].! !
!LookupKey methodsFor: 'bindings' stamp: 'jmv 7/17/2017 15:45:04' prior: 16865388!
                      recompileBindingsAnnouncing: aBool
	"Make the receiver (a global read-write binding) be a read-only binding"
	aBool ifTrue:[
		Utilities informUserDuring: [ :barBlock |
			(Smalltalk allCallsOn: self) do: [ :mref | 
				barBlock value: 'Recompiling ', mref stringVersion.
				mref actualClass recompile: mref methodSymbol ].
		].
	] ifFalse:[
		(Smalltalk allCallsOn: self) do: [ :mref |
			mref actualClass recompile: mref methodSymbol ]
	]! !
!SequenceableCollection methodsFor: 'gui' stamp: 'jmv 7/17/2017 15:45:17' prior: 16906997!
        do: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			self withIndexDo: [ :each :i |
				barBlock value: i.
				aBlock value: each]]! !
!String methodsFor: 'displaying' stamp: 'jmv 7/17/2017 15:41:46' prior: 16917058!
                  displayProgressAt: aPoint from: minVal to: maxVal during: workBlock
	"Display this string as a caption over a progress bar while workBlock is evaluated.

EXAMPLE (Select next 6 lines and Do It)

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
		1 to: 100 do: [:x | 
			(Delay forMilliseconds: 10) wait.
			barBlock value: x.]].

['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
	1 to: 100 do: [:x | barBlock value: x.
			(Delay forMilliseconds: 100) wait]].] fork
	
['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: x \\ 11.
			(Delay forMilliseconds: 100) wait]]] fork

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: nil.
			(Delay forMilliseconds: 200) wait]].

HOW IT WORKS (Try this in any other language :-)
Since your code (the last 2 lines in the above example) is in a block,
this method gets control to display its heading before, and clean up 
the screen after, its execution.
The key, though, is that the block is supplied with an argument,
named 'bar' in the example, which will update the bar image every 
it is sent the message value: x, where x is in the from:to: range.

The use of ProgressInitiationException allows for avoiding actual
progress display, by catching the exception.
"
	^ProgressInitiationException 
		display: self
		at: aPoint 
		from: minVal 
		to: maxVal 
		during: workBlock! !
!Set class methodsFor: 'initialization' stamp: 'jmv 7/17/2017 15:40:16' prior: 16907390!
       quickRehashAllSets  "Set rehashAllSets"
	| insts |
	self withAllSubclassesDo:
		[:c |
			insts _ c allInstances.
			(insts isEmpty or: [c = MethodDictionary]) ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock | 1 to: insts size do: [:x | barBlock value: x. (insts at: x) rehash]]
			]
		]! !
!Set class methodsFor: 'initialization' stamp: 'jmv 7/17/2017 15:40:27' prior: 16907404!
         rehashAllSets  "Set rehashAllSets"
	| insts |
	self withAllSubclassesDo:
		[:c | insts _ c allInstances.
		insts isEmpty ifFalse:
		['Rehashing instances of ' , c name
			displayProgressAt: Sensor mousePoint
			from: 1 to: insts size
			during: [ :barBlock |
			1 to: insts size do:
				[ :x | barBlock value: x.
				(insts at: x) rehash]]]]! !
!Dictionary methodsFor: 'removing' stamp: 'jmv 7/17/2017 15:44:29' prior: 16833635!
                   unreferencedKeys
	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"

	^'Scanning for references . . .' 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size * 2
		during: 
			[:barBlock | | currentClass n associations referencedAssociations |
			currentClass := nil.
			n := 0.
			associations := self associations asIdentitySet.
			referencedAssociations := IdentitySet new: associations size.
			Smalltalk allSelect:
				[:m|
				m methodClass ~~ currentClass ifTrue:
					[currentClass := m methodClass.
					 barBlock value: (n := n + 1)].
				m literalsDo:
					[:l|
					(l isVariableBinding and: [associations includes: l]) ifTrue:
						[referencedAssociations add: l]].
				false].
			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:10' prior: 16919601!
condenseChanges
	"Move all the changes onto a compacted sources file."
	"
	Smalltalk condenseChanges
	"

	| oldChanges classCount oldChangesLocalName oldChangesPathName |
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' forceWriteStreamDo: [ :f |
		f timeStamp.
		'Condensing Changes File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: Smalltalk classNames size
			during: [ :barBlock |
				classCount _ 0.
				Smalltalk allClassesDo: [ :class | 
					barBlock value: (classCount _ classCount + 1).
					class moveChangesTo: f.
					class putClassCommentToCondensedChangesFile: f.
					class class moveChangesTo: f ]].
		LastQuitLogPosition _ f position ].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	oldChanges _ SourceFiles at: 2.
	oldChangesPathName _ oldChanges name.
	oldChangesLocalName _ oldChanges localName.
	oldChanges close.
	(oldChangesPathName, '.old') asFileEntry delete.
	oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old'.
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' rename: oldChangesLocalName.
	
	SourceFiles
			at: 2 put: oldChangesPathName asFileEntry appendStream.

	self inform: 'Changes file has been rewritten!!

Check that all is well, and then save/quit.
 
Otherwise, remove new changes,
replace it with the former one, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:14' prior: 16919647!
                        condenseSources	
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"

	| classCount newVersionString oldChanges oldChangesLocalName oldChangesPathName newChangesPathName newSourcesName |
	newVersionString _ FillInTheBlankMorph request: 'Please name the new sources file' initialAnswer: SourceFileVersionString.
	newVersionString ifNil: [^ self].
	newVersionString = SourceFileVersionString ifTrue: [
		^ self error: 'The new source file must not be the same as the old.'].
	SourceFileVersionString _ newVersionString.

	"Write all sources with fileIndex 1"
	newSourcesName _ self defaultSourcesName.
	newSourcesName asFileEntry writeStreamDo: [ :f |
		f timeStamp.
		'Condensing Sources File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: Smalltalk classNames size
			during: [ :barBlock |
				classCount _ 0.
				Smalltalk allClassesDo: [ :class |
					barBlock value: (classCount _ classCount + 1).
					class fileOutOn: f moveSource: true toFile: 1]]].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	"Make a new empty changes file"
	oldChanges _ SourceFiles at: 2.
	oldChangesPathName _ oldChanges name.
	oldChangesLocalName _ oldChanges localName.
	self closeSourceFiles.
	oldChangesPathName ifNotNil: [
		(oldChangesPathName, '.old') asFileEntry delete.
		oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old' ].
	newChangesPathName _ self defaultChangesName.
	newChangesPathName asFileEntry writeStreamDo: [ :stream |
		stream timeStamp ].
	LastQuitLogPosition _ 0.

	self openSourceFiles.
	self inform: 'Source files have been rewritten!!
 
Check that all is well, and then save/quit.
 
Otherwise, remove new sources/changes,
replace them with the former ones, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:41:56' prior: 16919755!
         macroBenchmark1    "Smalltalk macroBenchmark1"
	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."
	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |
	classes _ Smalltalk allClasses select: [:c | c name < 'B3'].
	badOnes _ OrderedCollection new.
'Decompiling and recompiling...'
displayProgressAt: Sensor mousePoint
from: 0 to: (classes detectSum: [:c | c selectors size])
during: [:barBlock | n _ 0.
	classes do:
		[:cls | 
		"Transcript cr; show: cls name."
		cls selectors do:
			[:selector | barBlock value: (n _ n+1).
			oldMethod _ cls compiledMethodAt: selector.
			oldCodeString _ (cls decompilerClass new
								decompile: selector in: cls method: oldMethod)
							decompileString.
			methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls notifying: nil ifFail: nil.
			newMethod _ methodNode generate: #(0 0 0 0).
			oldCodeString = (cls decompilerClass new
								decompile: selector in: cls method: newMethod)
							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].
].
	^ badOnes size! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:19' prior: 16919804!
   macroBenchmark3   "Smalltalk macroBenchmark3"
	| testBlock tallies prev receiver |
	"Runs the stepping simulator with the messageTally tree (like tallySends)."
	testBlock _
		['Running the context step simulator'
			displayProgressAt: Sensor mousePoint
			from: 0 to: 200
			during:
				[:barBlock |
				1 to: 200 do:
				[:x | barBlock value: x.
				Float pi printString.
				15 factorial printString]]].
	tallies _ MessageTally new class: testBlock receiver class
							method: testBlock method.
	receiver _ nil.
	prev _ testBlock.
	thisContext sender
		runSimulated: testBlock
		contextAtEachStep:
			[:current |
			current == prev ifFalse: [
				"call or return"
				prev sender ifNotNil: [
					"call only"
					(receiver == nil or: [current receiver == receiver])
						ifTrue: [tallies tally: current by: 1]].
				prev _ current]].
! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:24' prior: 50364568!
                      obsoleteMethodReferences
	"
	Smalltalk obsoleteMethodReferences
	Smalltalk browseObsoleteMethodReferences
	Open a browser on all referenced behaviors that are obsolete"
	| obsClasses obsRefs references |
	references _ WriteStream on: Array new.
	obsClasses _ self obsoleteBehaviors.
	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor mousePoint
		from: 1 to: obsClasses size during: [ :barBlock |
	obsClasses keysAndValuesDo: [ :index :each |
		barBlock value: index.
		obsRefs _ self pointersTo: each except: obsClasses.
		obsRefs do: [ :ref |
			"Figure out if it may be a global"
			(ref isVariableBinding and: [ ref key isString "or Symbol" ]) ifTrue: [
				(self pointersTo: ref) do: [ :meth |
					(meth is: #CompiledMethod) ifTrue: [
						meth methodReference ifNotNil: [ :mref |
							(mref isValid and: [ mref compiledMethod == meth]) ifTrue: [
								references nextPut: mref ]]]]]]].
	].
	^references contents! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:30' prior: 16919989!
       testDecompiler
	"
	Smalltalk testDecompiler
	"
	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."
	| methodNode oldMethod newMethod badOnes oldCodeString n |
	badOnes _ OrderedCollection new.
	'Decompiling all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldMethod _ cls compiledMethodAt: selector.
					oldCodeString _ (cls decompilerClass new
						decompile: selector
						in: cls
						method: oldMethod) decompileString.
					methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldCodeString =
						(cls decompilerClass new
							decompile: selector
							in: cls
							method: newMethod) decompileString ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: (MethodReference class: cls selector: selector) ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Decompiler Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:37' prior: 16920039!
                       testFormatter
	"Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.
	The formatting used will be classic monochrome."
	| newCodeString methodNode oldMethod newMethod badOnes n |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					newCodeString _ cls compilerClass new
						format: (cls sourceCodeAt: selector)
						in: cls
						notifying: nil.
					methodNode _ cls compilerClass new
						compile: newCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldMethod _ cls compiledMethodAt: selector.
					oldMethod = newMethod ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:43' prior: 16920080!
        testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString _ (cls sourceCodeAt: selector) asString.
					newCodeString _ cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens _ oldCodeString findTokens: Character separators.
					newTokens _ newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/17/2017 15:45:58' prior: 16921677!
   allMethodsSourceStringMatching: aString
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring. 
	Search the class comments also.
	Argument might include $*, that matches any subsequence.
	For example, try:
		ensure:*[*close*]
	"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
	list add:
		(MethodReference new
			setStandardClass: mrClass
			methodSymbol: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						(aString match: (cl sourceCodeAt: sel)) ifTrue: [
							adder
								value: cl
								value: sel ]].
					
					(aString match: cl organization classComment asString) ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/17/2017 15:46:02' prior: 16921712!
             allMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
	list add:
		(MethodReference new
			setStandardClass: mrClass
			methodSymbol: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						((cl sourceCodeAt: sel)
							findString: aString
							startingAt: 1
							caseSensitive: caseSensitive) > 0 ifTrue: [
							adder
								value: cl
								value: sel ]].
					(cl organization classComment asString
						findString: aString
						startingAt: 1
						caseSensitive: caseSensitive) > 0 ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 7/17/2017 15:45:48' prior: 16922180!
                     abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal _ 0.  bCount _ 0.
	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		Smalltalk allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount _ bCount + 1).
			cl selectors do: [:selector |
				m _ cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	Smalltalk allBehaviorsDo: [:b | b zapOrganization].
	Smalltalk closeSourceFiles.
	Preferences disable: #warnIfNoChangesFile.
	Preferences disable: #warnIfNoSourcesFile! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 7/17/2017 15:42:02' prior: 16922340!
                      removeAllUnSentMessages
	"Smalltalk removeAllUnSentMessages"
	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 
	Smalltalk removeAllUnSentMessages > 0] whileTrue."
	"Remove all implementations of unsent messages."
	| sels n |
	sels _ self allUnSentMessages.
	self presumedSentMessages
		do: [:sel | sels
				remove: sel
				ifAbsent: nil].
	sels size = 0
		ifTrue: [^ 0].
	n _ 0.
	Smalltalk
		allBehaviorsDo: [:x | n _ n + 1].
	'Removing ' , sels size printString , ' messages . . .'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: n
		during: [:barBlock | 
			n _ 0.
			self
				allBehaviorsDo: [:class | 
					barBlock value: (n _ n + 1).
					sels
						do: [:sel | class removeSelector: sel]]].
	^ sels size! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 7/17/2017 15:45:10' prior: 50364852!
                        fileInAnnouncing: announcement
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :barBlock | 
			[ self atEnd ] whileFalse: [
					barBlock value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, 
									because next line is a doit that does the stuff
									(or because it is handled elsewhere)"
									(chunk beginsWith: 'description:  ')
									| (chunk beginsWith: 'provides: ')
									| (chunk beginsWith: 'requires: ')
									| (chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Compiler evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Compiler evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex pass ]
										]] 
							on: InMidstOfFileinNotification
							do: [ :ex | ex resume: true ] ].
			].
	"Note:  The main purpose of this banner is to flush the changes file."
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !
!PositionableStream methodsFor: 'gui' stamp: 'jmv 7/17/2017 15:38:57' prior: 50364910!
                               untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			[ self atEnd ] whileFalse: [
				barBlock value: self position.
				aBlock value ]]! !
!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 7/17/2017 15:40:06' prior: 16899982!
                              statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences _ self references.	"Exclude unrealized weaks"
	parents _ IdentityDictionary new: normalReferences size * 2.
	n _ 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n _ n+1).
		kids _ parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [Array new]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags _ Dictionary new.
	tallies _ Bag new.
	n _ 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n _ n+1).
		nm _ obj class name.
		tallies add: nm.
		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n _ assn key.  nm _ assn value.
			owners _ ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 7/17/2017 15:40:37' prior: 16911182!
                             nextPut: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.
	You can see an analysis of which objects are written out by doing: 
	(SmartRefStream statsOfSubObjects: anObject)
	(SmartRefStream tallyOfSubObjects: anObject)
	(SmartRefStream subObjects: anObject ofClass: aClass)"

| info |
topCall
	ifNil: [
		topCall _ anObject.
		'Please wait while objects are counted' 
			displayProgressAt: Sensor mousePoint
			from: 0 to: 10
			during: [ :barBlock | info _ self instVarInfo: anObject].
		byteStream binary.
		'Writing an object file' displayProgressAt: Sensor mousePoint
			from: 0 to: objCount*4	"estimate"
			during: [ :barBlock |
				objCount _ 0.
				progressBar _ barBlock.
				self setStream: byteStream reading: false.
					"set basePos, but keep any class renames"
				super nextPut: ReferenceStream versionCode.
				super nextPut: info.
				super nextPut: anObject.		"<- the real writing"
				].
					"Note: the terminator, $!!, is not doubled inside object data"
		"references is an IDict of every object that got written"
		byteStream ascii.
		byteStream nextPutAll: '!!'; newLine; newLine.
		byteStream padToEndWith: $ .	"really want to truncate file, but can't"
		topCall _ progressBar _ nil]	"reset it"
	ifNotNil: [
		super nextPut: anObject.
		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].
! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 7/17/2017 15:40:57' prior: 16911232!
                            nextPutObjOnly: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"

	| info |
	topCall
		ifNil: [
			topCall _ anObject.
			super nextPut: ReferenceStream versionCode.
			'Please wait while objects are counted' displayProgressAt: Sensor mousePoint
				from: 0 to: 10
				during: [ :barBlock |
					info _ self instVarInfo: anObject].
			'Writing an object file' displayProgressAt: Sensor mousePoint
				from: 0 to: objCount*4	"estimate"
				during: [ :barBlock |
					objCount _ 0.
					progressBar _ barBlock.
					super nextPut: info.
					super nextPut: anObject.	"<- the real writing"
					"Class inst vars not written here!!"].
			"references is an IDict of every object that got written
			(in case you want to take statistics)"
			"Transcript cr; show: structures keys printString."		"debug"
			topCall _ progressBar _ nil]	"reset it"
		ifNotNil: [
			super nextPut: anObject.
			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !
!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'jmv 7/17/2017 15:39:39' prior: 50364921!
testInnermost

	"
	test the progress code WITHOUT special handling
	
	ProgressInitiationException  testInnermost
	"

	^'Now here''s some Real Progress'
		displayProgressAt: Sensor mousePoint
		from: 0 
		to: 10
		during: [ :barBlock |
			1 to: 10 do: [ :x | 
				barBlock value: x.
				(Delay forMilliseconds: 500) wait.
				x = 5 ifTrue: [1/0].	"just to make life interesting"
			].
			'done'
		].

! !
!Utilities class methodsFor: 'user interface' stamp: 'jmv 7/17/2017 15:48:35' prior: 16941514!
             informUserDuring: barBlock 
	"Display a message above (or below if insufficient room) the cursor during execution of the given block."

	"Utilities informUserDuring:[:barBlock|
		#(one two three) do:[:info|
			barBlock value: info.
			(Delay forSeconds: 1) wait]]"

	(MVCMenuMorph from: (SelectionMenu labels: '') title: '						') 
				informUserAt: Sensor mousePoint
				during: barBlock! !
!CodeFile methodsFor: 'reading' stamp: 'jmv 7/17/2017 15:44:20' prior: 16808992!
       buildFrom: aStream
	| chgRec changes |
	changes _ (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.
	('Processing ', self name) 
		displayProgressAt: Sensor mousePoint
		from: 1
		to: changes size
		during: [ :barBlock |
			1 to: changes size do:[:i|
				barBlock value: i.
				chgRec := changes at: i.
				chgRec class == MethodDeletionChangeRecord
					ifTrue: [ self removedMethod: chgRec command with: chgRec ]
					ifFalse: [ self perform: (chgRec changeType copyWith: $:) asSymbol with: chgRec ].
			].
		]! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 7/17/2017 15:45:36' prior: 16912516!
                   printSpaceAnalysis: threshold on: aStream
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.
	results _ OrderedCollection new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace _ cl spaceUsed.
				barBlock value: (n _ n+1).
				Smalltalk garbageCollectMost.
				instCount _ cl instanceCount.
				instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8]) * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace _ instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace _ instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace _ totalCodeSpace + codeSpace.
				totalInstCount _ totalInstCount + instCount.
				totalInstSpace _ totalInstSpace + instSpace]].
	totalPercent _ 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results _ (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent _ s spaceForInstances*100.0/totalInstSpace.
		totalPercent _ totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3126-ProgressArgumentIsABlock-JuanVuletich-2017Jul17-15h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 12 July 2017 at 1:50:53 pm'!
!Float64Array methodsFor: 'testing' stamp: 'jmv 7/11/2017 14:04:20'!
isLiteral
	"so that 
	#(1 #[1.0 2 3] 5)
	prints itself"
	^self class == Float64Array! !
!Float64Array methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:10:44'!
  printOn: aStream

	self storeOn: aStream! !
!Float64Array methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:10:41'!
              storeOn: aStream

	aStream nextPutAll: '#['.
	self
		do: [ :each | each storeOn: aStream ]
		separatedBy: [ aStream nextPut: $ ].
	aStream nextPut: $]! !
!ByteArray methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:09:10' prior: 16793833!
                   printOn: aStream
	self storeOn: aStream! !
!Scanner methodsFor: 'expression types' stamp: 'jmv 7/12/2017 13:50:30' prior: 16903764!
                            scanLitByteVec
	"Also accept Floats besides bytes!!
	#[1 2 3 255]
	#[1.0 0.2 1.0]
	#[1.0 -0.2e-23 1.0e4]
	"
	| stream |
	stream _ nil.
	[ tokenType == #rightBracket or: [ tokenType == #doIt ] ] whileFalse: [
		(token == #- and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: [
			self scanToken.
			token _ token negated ].
		((token isInteger and: [ token between: 0 and: 255 ]) or: [token isFloat])
			ifFalse: [ ^ self offEnd: '8-bit integer, floating point number, or right bracket expected' ].
		stream ifNil: [
			stream _ ((token isFloat ifTrue: [Float64Array] ifFalse: [ByteArray]) new: 16) writeStream ].
		stream nextPut: token.
		self scanToken ].
	token _ stream contents! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3127-LiteralFloatArrays-JuanVuletich-2017Jul12-13h50m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3127] on 17 July 2017 at 5:00:00 pm'!
!Collection methodsFor: 'converting' stamp: 'jmv 7/17/2017 16:59:02'!
         asFloat64Array
	"Answer a Float64Array whose elements are the elements of the receiver"

	^self as: Float64Array! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3128-asFloat64Array-JuanVuletich-2017Jul17-16h59m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3128] on 18 July 2017 at 10:23:11 am'!
!PluggableButtonMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/18/2017 10:22:53' prior: 50365258!
        morphExtent
	"Use extent if it has already been manually set, otherwise try to set it by computing from the label text and font, otherwise try using the icon extent, or finally fall back to the default value."
	^ extent ifNil: [
		extent := (self fontToUse notNil and: [ label notNil ])
			ifTrue: [ "Add a bit of padding"
				(self fontToUse widthOfString: label) + 10 @ (self fontToUse height + 10) ]
			ifFalse: [
				`20@15`
				"Usually button extent should not depend on icon extent. Icons are many times very big.
				For example, the icons in buttons in Taskbar are full size captures of the windows"
				"icon
					ifNil: [ `20@15` ]
					ifNotNil: [ icon extent ]"
				]].! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3129-AvoidHugeButtons-JuanVuletich-2017Jul18-10h22m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3128] on 19 July 2017 at 2:45:06 am'!
!AutoCompleterMorph methodsFor: 'actions' stamp: 'pb 7/19/2017 02:42:16'!
            moveEnd
	self gotoPage: self pageCount.
	self selected: completer entryCount.
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'pb 7/19/2017 02:42:22'!
                 moveHome
	self gotoPage: 1.
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'pb 7/19/2017 02:43:17' prior: 16781410!
                   moveDown
	self selected = completer entryCount
		ifTrue: [ self moveHome ]
		ifFalse: [
			self selected: self selected + 1.
			(self selected > self lastVisible and: [ self selected <= completer entryCount ]) ifTrue: [ firstVisible _ firstVisible + 1 ]].
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'pb 7/19/2017 02:42:32' prior: 16781419!
               moveUp
	(self selected = 0 and: [ self firstVisible = 1 ]) ifTrue: [ ^ self ].
	self selected = 1
		ifTrue: [ 
			self moveEnd ]
		ifFalse: [
			self selected: self selected - 1.
			self selected < self firstVisible ifTrue: [ firstVisible _ firstVisible - 1 ]].
	self redrawNeeded.! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'pb 7/19/2017 02:42:44' prior: 16781174!
             handleKeystrokeBefore: kbEvent
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	| currentPos currentCharIsAlphaNumeric keyValue ctrl cmd tab colon alphanum backspace esc space return keyChar  |
	currentPos _ textMorph editor startIndex-1.
	currentCharIsAlphaNumeric _ currentPos > 0 and: [ model textSize >= currentPos and: [
			(model actualContents at: currentPos) isAlphaNumeric ]].
	keyValue _ kbEvent keyValue.
	keyChar _ kbEvent keyCharacter.
	ctrl _ kbEvent controlKeyPressed.
	cmd _ kbEvent commandAltKeyPressed.
	tab _ keyChar = Character tab.
	colon _ keyChar = $:.
	alphanum _ kbEvent keyCharacter isAlphaNumeric.
	backspace _ keyValue = 8.
	esc _ keyValue = 27.
	space _ #(0 32 160) includes: keyValue.
	return _ kbEvent isReturnKey.

	"Stuff to do if the menu is not open"
	menuMorph ifNil: [
		"Ctrl-Space or Tab for open"
		"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
		(space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [
			(self opensWithTab and: [tab]) and: [ currentCharIsAlphaNumeric ]])
				ifTrue: [ self openCompletionMenu. ^ true].
		"Auto-open - currently deactivated"
"		(ctrl not & cmd not & alphanum) 
			ifTrue: [ self openCompletionMenu ]."
		^ false].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	"Escape"
	esc ifTrue: [ self closeMenu. ^ true].
	"Backspace"
	backspace ifTrue: [
		currentCharIsAlphaNumeric ifFalse: [ self closeMenu ].
		^ false].
	"Home"
	keyValue = 1 ifTrue: [ menuMorph moveHome. ^ true ].
	"End"
	keyValue = 4 ifTrue: [ menuMorph moveEnd. ^ true].
	"?"
	keyChar = $? ifTrue: [ menuMorph help. ^true].
	"Arrow up"
	keyValue = 30 ifTrue: [ menuMorph moveUp. ^ true].
	"Arrow down"
	keyValue = 31 ifTrue: [ menuMorph moveDown. ^ true].
	"Page up"
	keyValue = 11 ifTrue: [ menuMorph pageUp. ^ true].
	"Page down"
	keyValue = 12 ifTrue: [ menuMorph pageDown. ^ true].
	"Return, Tab or Ctrl-Space"
	(return or: [ space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [ tab]]) ifTrue: [
		self insertSelected
			ifTrue: [^ true]].
	"All keys but the alphanumeric chars (without command and control ) 
	and the backspace key do close the menu"
	(ctrl not & cmd not and: [ alphanum | colon])
		ifFalse: [ self closeMenu ].
	^false! !

AutoCompleterMorph removeSelector: #end!

AutoCompleterMorph removeSelector: #end!

AutoCompleterMorph removeSelector: #ensureVisible!

AutoCompleterMorph removeSelector: #home!

AutoCompleterMorph removeSelector: #home!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3130-AutoCompleterMorph-wrapping-PhilBellalouna-2017Jul19-02h20m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3130] on 2 August 2017 at 12:48:23 pm'!
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:12'!
    goDown
	self selected: self selected + 1.
	(self selected > self lastVisible
			and: [self selected <= completer entryCount])
		ifTrue: [firstVisible := firstVisible + 1].
	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:38'!
                    goHome
	firstVisible := 1.
	self selected: firstVisible. 
	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:47:05'!
      goPageDown
	(self gotoPage: self currentPage + 1)
		ifFalse: [ self goToEnd ].
	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:54'!
                 goPageUp
	self gotoPage: self currentPage - 1.
	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:32'!
                 goToEnd
	self selected: completer entryCount.
	firstVisible := selected - self class itemsPerPage + 1 max: 1.
	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2017 12:45:45'!
                  goUp
	(self selected = 0
			and: [self firstVisible = 1])
		ifTrue: [^ self].
	self selected: self selected - 1.
	self selected < self firstVisible
		ifTrue: [firstVisible := firstVisible - 1].
	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 8/2/2017 12:46:45' prior: 16781544!
               mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	(self morphContainsPoint: localEventPosition)
		ifTrue: [
			((self upButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goUp ].
			((self downButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goDown ].
			self selected: (localEventPosition y // self class itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!AutoCompleterMorph methodsFor: 'paging' stamp: 'jmv 8/2/2017 12:38:44' prior: 16781597!
gotoPage: anInteger
	| item |
	item := ((anInteger - 1) * self class itemsPerPage) + 1. 
	item >= completer entryCount ifTrue: [^false].
	item < 1 ifTrue: [item := 1].
	firstVisible := item.
	self selected: firstVisible. 
	^ true! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 8/2/2017 12:47:30' prior: 50366775!
 handleKeystrokeBefore: kbEvent
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	| currentPos currentCharIsAlphaNumeric keyValue ctrl cmd tab colon alphanum backspace esc space return keyChar  |
	currentPos _ textMorph editor startIndex-1.
	currentCharIsAlphaNumeric _ currentPos > 0 and: [ model textSize >= currentPos and: [
			(model actualContents at: currentPos) isAlphaNumeric ]].
	keyValue _ kbEvent keyValue.
	keyChar _ kbEvent keyCharacter.
	ctrl _ kbEvent controlKeyPressed.
	cmd _ kbEvent commandAltKeyPressed.
	tab _ keyChar = Character tab.
	colon _ keyChar = $:.
	alphanum _ kbEvent keyCharacter isAlphaNumeric.
	backspace _ keyValue = 8.
	esc _ keyValue = 27.
	space _ #(0 32 160) includes: keyValue.
	return _ kbEvent isReturnKey.

	"Stuff to do if the menu is not open"
	menuMorph ifNil: [
		"Ctrl-Space or Tab for open"
		"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
		(space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [
			(self opensWithTab and: [tab]) and: [ currentCharIsAlphaNumeric ]])
				ifTrue: [ self openCompletionMenu. ^ true].
		"Auto-open - currently deactivated"
"		(ctrl not & cmd not & alphanum) 
			ifTrue: [ self openCompletionMenu ]."
		^ false].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	"Escape"
	esc ifTrue: [ self closeMenu. ^ true].
	"Backspace"
	backspace ifTrue: [
		currentCharIsAlphaNumeric ifFalse: [ self closeMenu ].
		^ false].
	"Home"
	keyValue = 1 ifTrue: [ menuMorph goHome. ^ true ].
	"End"
	keyValue = 4 ifTrue: [ menuMorph goToEnd. ^ true].
	"?"
	keyChar = $? ifTrue: [ menuMorph help. ^true].
	"Arrow up"
	keyValue = 30 ifTrue: [ menuMorph goUp. ^ true].
	"Arrow down"
	keyValue = 31 ifTrue: [ menuMorph goDown. ^ true].
	"Page up"
	keyValue = 11 ifTrue: [ menuMorph goPageUp. ^ true].
	"Page down"
	keyValue = 12 ifTrue: [ menuMorph goPageDown. ^ true].
	"Return, Tab or Ctrl-Space"
	(return or: [ space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [ tab]]) ifTrue: [
		self insertSelected
			ifTrue: [^ true]].
	"All keys but the alphanumeric chars (without command and control ) 
	and the backspace key do close the menu"
	(ctrl not & cmd not and: [ alphanum | colon])
		ifFalse: [ self closeMenu ].
	^false! !

AutoCompleterMorph removeSelector: #moveDown!

AutoCompleterMorph removeSelector: #moveDown!

AutoCompleterMorph removeSelector: #moveEnd!

AutoCompleterMorph removeSelector: #moveEnd!

AutoCompleterMorph removeSelector: #moveHome!

AutoCompleterMorph removeSelector: #moveHome!

AutoCompleterMorph removeSelector: #moveUp!

AutoCompleterMorph removeSelector: #moveUp!

AutoCompleterMorph removeSelector: #pageDown!

AutoCompleterMorph removeSelector: #pageDown!

AutoCompleterMorph removeSelector: #pageUp!

AutoCompleterMorph removeSelector: #pageUp!

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3131-AutoCompletterMorph-removeWrapping-JuanVuletich-2017Aug02-12h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3131] on 2 August 2017 at 12:59:24 pm'!
!Scanner methodsFor: 'expression types' stamp: 'jmv 8/2/2017 12:59:08' prior: 50366661!
      scanLitByteVec
	"Also accept Floats besides bytes!!
	#[1 2 3 255]
	#[1.0 0.2 1.0]
	#[1.0 -0.2e-23 1.0e4]
	"
	| stream |
	stream _ nil.
	[ tokenType == #rightBracket or: [ tokenType == #doIt ] ] whileFalse: [
		(token == #- and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: [
			self scanToken.
			token _ token negated ].
		((token isInteger and: [ token between: 0 and: 255 ]) or: [token isFloat])
			ifFalse: [ ^ self offEnd: '8-bit integer, floating point number, or right bracket expected' ].
		stream ifNil: [
			stream _ ((token isFloat ifTrue: [Float64Array] ifFalse: [ByteArray]) new: 16) writeStream ].
		stream nextPut: token.
		self scanToken ].
	token _ stream
		ifNotNil: [ stream contents ]
		ifNil: [
			"For back compatibility, if empty, assume ByteArray"
			ByteArray new ]! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3132-EmptyLiteralByteArrayFix-JuanVuletich-2017Aug02-12h59m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3094] on 29 July 2017 at 9:36:44 pm'!
!Exception methodsFor: 'debug support' stamp: 'HAW 7/29/2017 15:47:08'!
                    canSearchForSignalerContext
	"This method is /only/ to support the debugger's catching of exceptions in stepIntoBlock."
	^signalContext isContext! !
!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/29/2017 20:49:55' prior: 16829808!
               doStep
	"Send the selected message in the accessed method, and regain control 
	after the invoked method returns."
	
	| currentContext newContext |

	currentContext := self selectedContext.
	newContext := self handleLabelUpdatesIn: [interruptedProcess completeStep: currentContext]
						whenExecuting: currentContext.
	newContext == currentContext ifTrue:
		[newContext := interruptedProcess stepToSendOrReturn].
	self contextStackIndex > 1
		ifTrue: [self resetContext: newContext]
		ifFalse:
			[newContext == currentContext
				ifTrue: [self changed: #contentsSelection.
						self updateInspectors]
				ifFalse: [self resetContext: newContext]].
! !
!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/29/2017 20:50:01'!
     handleLabelUpdatesIn: aBlock whenExecuting: aContext
	"Send the selected message in the accessed method, and regain control 
	after the invoked method returns."
	
	^aBlock
		on: Notification
		do: [:ex|
			(ex tag isArray
			 and: [ex tag size = 2
			 and: [(ex tag first == aContext or: [ex tag first hasSender: aContext])]])
				ifTrue:
					[self labelString: ex tag second description.
					 ex resume]
				ifFalse:
					[ex pass]]! !
!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/29/2017 20:50:15' prior: 16829946!
             stepIntoBlock
	"Send messages until you return to the present method context.
	 Used to step into a block in the method."

	self 
		handleLabelUpdatesIn: [interruptedProcess stepToHome: self selectedContext]
		whenExecuting: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn! !
!Inspector methodsFor: 'initialization' stamp: 'HAW 7/29/2017 15:28:27' prior: 16857112!
                   inspect: anObject 
	"Initialize the receiver so that it is inspecting anObject. There is no current selection.
	
	Normally the receiver will be of the correct class (as defined by anObject inspectorClass),
	because it will have just been created by sedning inspect to anObject.   However, the
	debugger uses two embedded inspectors, which are re-targetted on the current receiver
	each time the stack frame changes.  The left-hand inspector in the debugger has its
	class changed by the code here.  Care should be taken if this method is overridden to
	ensure that the overriding code calls 'super inspect: anObject', or otherwise ensures that 
	the class of these embedded inspectors are changed back."

	| c |
	c := anObject inspectorClass.
	self class ~= c ifTrue: [
		self class format = c format
			ifTrue: [self primitiveChangeClassTo: c basicNew]
			ifFalse: [self becomeForward: (c basicNew copyFrom: self)]].
	
	"Set 'object' before sending the initialize message, because some implementations
	of initialize (e.g., in DictionaryInspector) require 'object' to be non-nil."
	
	object := anObject. 
	self initialize! !
!OrderedCollectionInspector methodsFor: 'as yet unclassified' stamp: 'HAW 7/29/2017 15:13:36' prior: 16884334!
           fieldList

	| fieldsHere |
	object isNil ifTrue: [^OrderedCollection new].
	fieldsHere _
		[
			(object size <= (self i1 + self i2)
				ifTrue: [(1 to: object size) collect: [:i | i printString]]
				ifFalse: [(1 to: self i1) , (object size-(self i2-1) to: object size) collect: [:i | i printString]])
		] on: Error do: [:ex | ex return: OrderedCollection new].	
	^self baseFieldList , fieldsHere
"
OrderedCollection new inspect
(OrderedCollection newFrom: #(3 5 7 123)) inspect
(OrderedCollection newFrom: (1 to: 1000)) inspect
"! !
!Process methodsFor: 'changing suspended state' stamp: 'HAW 7/29/2017 16:00:49' prior: 16894360!
         stepToHome: aContext 
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| home anError |
	
	home := aContext home.
	[suspendedContext := suspendedContext step.
	home == suspendedContext home or: [home isDead]] whileFalse:
		[(suspendedContext selector == #signalForException:
			and: [(suspendedContext receiver isBehavior 
			and: [suspendedContext receiver includesBehavior: UnhandledError])
			and: [anError := suspendedContext tempAt: 1.
				((suspendedContext objectClass: anError) includesBehavior: Exception)
			and: [anError canSearchForSignalerContext]]]) ifTrue:
				[anError signalerContext ifNotNil: [:unhandledErrorSignalerContext|
					[unhandledErrorSignalerContext == suspendedContext] whileFalse:
						[self completeStep: suspendedContext].
					"Give a debugger a chance to update its title to reflect the new exception"
					 Notification new
						tag: {unhandledErrorSignalerContext. anError};
						signal.
					^unhandledErrorSignalerContext]]].
		
	^suspendedContext! !

----End fileIn of C:\Users\Admin\Cuis-Smalltalk-Organization\Cuis-Smalltalk-Dev\CoreUpdates\3133-DebuggerFixes-HernanWilkinson-2017Jun03-20h55m-HAW.1.cs.st----!

----SNAPSHOT----#(2 August 2017 3:58:25.351093 pm) Cuis5.0-3133-v3.image priorSource: 1061254!

----QUIT----#(2 August 2017 3:58:48.807093 pm) Cuis5.0-3133-v3.image priorSource: 1139044!

----STARTUP----#(17 August 2017 10:42:52.713116 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3133-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3133] on 3 August 2017 at 12:49:11 pm'!
!Number methodsFor: 'intervals' stamp: 'jmv 8/3/2017 11:57:08'!
                to: stop do: elementBlock separatedBy: separatorBlock
	"
	String streamContents: [ :strm |
		1 to: 10 do: [ :i | i printOn: strm ] separatedBy: [ strm nextPutAll: ' -- ' ]]
	"
	| beforeFirst | 
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	beforeFirst _ true.
	self to: stop do: [ :element |
		beforeFirst
			ifTrue: [beforeFirst _ false]
			ifFalse: [separatorBlock value].
		elementBlock value: element]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3134-to_do_separatedBy-JuanVuletich-2017Aug03-11h50m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3129] on 24 July 2017 at 4:30:44 pm'!
!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 7/24/2017 09:10:47' prior: 16932568!
       forwardDelete: aKeyboardEvent
	"Delete forward over the next character."
	"This is a user command, and generates undo"

	| startIndex stopIndex |

	"If there was a selection"
	self hasSelection ifTrue: [
		self replaceSelectionWith: self nullText.
		^ false].

	"Exit if at end"
	startIndex _ self markIndex.
	startIndex > model textSize ifTrue: [
		^ false].

	"Null selection - do the delete forward"
	stopIndex _ startIndex.
	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])
		ifTrue: [stopIndex := (self nextWordStart: stopIndex) - 1].
	self selectFrom: startIndex to: stopIndex.
	self replaceSelectionWith: self nullText.
	self deselectAndPlaceCursorAt: startIndex.
	^false! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3135-DeleteSelectionAtEndOfText-fix-JuanVuletich-2017Jul24-16h25m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3134] on 9 August 2017 at 11:37:48 am'!
!BitBltCanvas methodsFor: 'drawing-images' stamp: 'jmv 8/9/2017 11:37:34' prior: 16786577!
                      image: aForm at: aPoint sourceRect: sourceRect
	"Draw a translucent image using the best available way of representing translucency.
	Note: This will be fixed in the future."
	| r p |
	p _ (currentTransformation transform: aPoint) rounded.
	r _ (self depth < 32 or: [ aForm mightBeTranslucent not ]) 
		ifTrue: [
			"Rule Form paint treats pixels with a value of zero as transparent"
			Form paint ]
		ifFalse: [ Form blend ].
	port colorMap: (aForm colormapIfNeededFor: form); fillColor: nil.
	port image: aForm at: p sourceRect: sourceRect rule: r.
	(self depth = 32 and: [ aForm depth < 32 ]) ifTrue: [
		"If we blit to 32bpp from one of smaller depth,
		it will have zero in the alpha channel (until BitBlt is fixed!!)
		This is the same workaround as in #asFormOfDepth:"
		port sourceForm: nil.
		port combinationRule: 40. "fixAlpha:with:"
		port copyBits ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3136-BitBltCanvas-fix-JuanVuletich-2017Aug08-16h59m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3134] on 17 August 2017 at 1:06:03 pm'!
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 8/17/2017 13:05:27' prior: 16888588!
 doubleClick: aMouseButtonEvent localPosition: localEventPosition
	| index |
	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index _ self rowAtLocation: localEventPosition.
	index = 0 ifTrue: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index == self selectionIndex
		ifFalse: [ self changeModelSelection: index ].
	^ self model perform: doubleClickSelector! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3137-DoubleClickOnSelection-Inspector-Fix-JuanVuletich-2017Aug17-12h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3137] on 17 August 2017 at 5:00:13 pm'!
!Inspector methodsFor: 'user interface support' stamp: 'jmv 8/17/2017 16:28:29'!
                     textStylerClassFor: textGetter

	^SHTextStylerST80! !
!Inspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:51:54'!
  bindingNamesDo: aBlock
	object class allInstVarNames do: aBlock! !
!Inspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:52:08'!
                     hasBindingOf: aString
	^ object class allInstVarNames includes: aString! !
!Inspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:48:11'!
             shoutAboutToStyle: aSHTextStyler
	"This is a notification that aSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in aSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"

	aSHTextStyler 
"No. Impica que es un metodo!!
		classOrMetaClass: self selectedClassOrMetaClass."

		workspace: self.
	^true! !
!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:58:45'!
                     bindingNamesDo: aBlock
	fieldList do: aBlock! !
!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:58:56'!
                        hasBindingOf: aString
	^ fieldList includes: aString! !
!ObjectExplorer methodsFor: 'user interface support' stamp: 'jmv 8/17/2017 16:28:32'!
                  textStylerClassFor: textGetter

	^SHTextStylerST80! !
!ObjectExplorer methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:54:38'!
                             bindingNamesDo: aBlock
	self doItReceiver class allInstVarNames do: aBlock! !
!ObjectExplorer methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:54:33'!
     hasBindingOf: aString
	^ self doItReceiver class allInstVarNames includes: aString! !
!ObjectExplorer methodsFor: 'shout styling' stamp: 'jmv 8/17/2017 16:48:02'!
                             shoutAboutToStyle: aSHTextStyler
	"This is a notification that aSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in aSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"

	aSHTextStyler 
"No. Impica que es un metodo!!
		classOrMetaClass: self selectedClassOrMetaClass."

		workspace: self.
	^true! !
!Inspector methodsFor: 'accessing' stamp: 'jmv 8/17/2017 16:47:26' prior: 16856921!
                         selectedClassOrMetaClass
"NOOOOOO"
	^ self selectedClass	"I don't know any better"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3138-ShoutInInspectorsAndExplorers-JuanVuletich-2017Aug17-16h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3137] on 17 August 2017 at 5:07:41 pm'!
!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 8/17/2017 17:06:33' prior: 16909227!
                               computeEntries

	| allSource contextClass id specificModel last3Ranges range prevRange receiverClass prevPrevRange |
	allSource _ model actualContents string.
	specificModel _ (model is: #hasTextProvider)
		ifTrue: [ model textProvider ]
		ifFalse: [ model ].
	contextClass _ (specificModel is: #CodeProvider) ifTrue: [
		specificModel selectedClassOrMetaClass ].

	"Instead of creating a new string, maybe we could pass the last position to parse to Shout..."
	parser _ SHParserST80 new.
	parser
		workspace: specificModel;
		classOrMetaClass: contextClass;
		source: (allSource copyFrom: 1 to: position).
	parser parse.
	last3Ranges _ parser last3Ranges.
	range _ last3Ranges third.
	range ifNil: [ ^entries _ #() ].

	"If parsing breaks before position, then we don't know what to suggest, therefore don't open Completion"
	range end = position ifFalse: [ ^entries _ #() ].

	prefix _ allSource copyFrom: range start to: range end.
	
	(parser isMessage: range rangeType) ifTrue: [
		"If previous range is a constant or a well known identifier, we might filter messages"
		prevRange _ last3Ranges second.
		prevPrevRange _ last3Ranges first.
		receiverClass _ nil.
		"3 if -> ifNil: but not ifTrue:
		3=4 -> ifNil: or ifTrue:"
		(prevRange notNil and: [ prevPrevRange isNil or: [ (#(binary keyword) includes: prevPrevRange rangeType) not]]) ifTrue: [
			id _ (allSource copyFrom: prevRange start to: prevRange end).
			receiverClass _ prevRange rangeType caseOf: {
				[ #globalVar ] -> [ (Smalltalk at: id asSymbol) class ].
				[ #self ] -> [ contextClass ].
				[ #super ] -> [ contextClass superclass ].
				[ #true ] -> [ True ].
				[ #false ] -> [ False ].
				[ #nil ] -> [ UndefinedObject ].
				[ #character ] -> [ id first class ].
				[ #number ] -> [ (Compiler evaluate: id) class ].
				[ #string ] -> [ (Compiler evaluate: id) class ].
				[ #symbol ] -> [ (Compiler evaluate: id) class ].
				[ #stringSymbol ] -> [ (Compiler evaluate: id) class ].
				"thisContext could mean ContextPart or BlockClosure..."
				"[ #thisContext ] -> [ ContextPart ]"
			} otherwise: [ nil ]
		].
		^self computeMessageEntries: receiverClass ].

	(parser isPartialOrFullIdentifier: range rangeType) ifTrue: [
		^self computeIdentifierEntries ].
	
	"If we don't know what to do, do nothing"
	entries _ #()! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3139-AutocompleterInInspectorsAndExplorers-JuanVuletich-2017Aug17-17h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3139] on 17 August 2017 at 9:26:32 pm'!
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:56' prior: 50365277!
          morphHeight

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ extent y! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 2/16/2016 12:58' prior: 50365284!
          morphPosition: newPos extent: newExtent
	"Change the position of this morph. Argument is in owner's coordinates."

	| oldBoundsInWorld someChange |

	"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
	oldBoundsInWorld _ self morphBoundsInWorld.
	someChange _ false.
	(location isTranslation: newPos) ifFalse: [
		location _ location withTranslation: newPos.
		someChange _ true ].

	extent = newExtent ifFalse: [
		(self privateExtent: newExtent) ifTrue: [
			someChange _ true ]].

	someChange ifTrue: [
		"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
		oldBoundsInWorld ifNotNil: [
			self invalidateDisplayRect: oldBoundsInWorld from: nil ].
		self someSubmorphPositionOrExtentChanged.
		owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
		self redrawNeeded ]! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'jmv 9/22/2012 14:57' prior: 50365316!
                          morphWidth

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ extent x! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:30' prior: 50365323!
       draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/1/2015 16:20' prior: 50365338!
                   drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ extent // 2.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: colorForLabel
			embossed: true ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 7/10/2014 22:43' prior: 50365374!
             drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ extent // 2.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ extent x - labelMargin - labelMargin - 1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:46' prior: 50365397!
      drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:15' prior: 50365440!
                  initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  `20 @ 15`! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 2/17/2017 15:10:48' prior: 50365458!
              magnifiedIcon
	| factor magnifiedExtent w h |

	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		w _ icon width.
		h _ icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * extent x / w min: 1.0 * extent y / h.
			(factor < 1 or: [ factor > 1.7 and: [self isRoundButton]]) ifTrue: [
				magnifiedExtent _ (icon extent * factor) rounded.
				magnifiedIcon _ icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 6/19/2017 15:55:52' prior: 50365476!
        morphContainsPoint: aLocalPoint

	| iconOrigin |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ extent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: (aLocalPoint - iconOrigin) rounded) not ]]! !

PluggableButtonMorph removeSelector: #morphExtent!

PluggableButtonMorph removeSelector: #morphExtent!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3140-Revert-3124-BreaksExistingPackages-JuanVuletich-2017Aug17-21h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3140] on 17 August 2017 at 9:45:47 pm'!
!Number methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:37:11'!
                   raisedToFraction: aFraction
	self isZero ifTrue: [
		aFraction negative ifTrue: [
			^ (ZeroDivide dividend: 1) signal ].
		^ self ].
	self negative ifFalse: [
		^ (self ln * aFraction) exp ].
	aFraction denominator even ifTrue: [
		^ ArithmeticError signal: 'nth root only defined for positive Integer n.' ].
	^ (self negated ln * aFraction) exp negated! !
!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:37:35'!
          raisedToFraction: aFraction
	| root |
	root _ (self numerator nthRootTruncated: aFraction denominator) /
			(self denominator nthRootTruncated: aFraction denominator).
	(root raisedToInteger: aFraction denominator) = self ifTrue: [
		^ root raisedToInteger: aFraction numerator ].
	^ super raisedToFraction: aFraction! !
!Integer methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:37:42'!
                raisedToFraction: aFraction
	| root |
	root _ self nthRootTruncated: aFraction denominator.
	(root raisedToInteger: aFraction denominator) = self ifTrue: [
		^ root raisedToInteger: aFraction numerator ].
	^ super raisedToFraction: aFraction! !
!Number methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:44:25' prior: 16880173!
             raisedTo: aNumber 
	"Answer the receiver raised to aNumber."

	aNumber isInteger ifTrue: [
		"Do the special case of integer power"
		^ self raisedToInteger: aNumber].
	aNumber isFraction ifTrue: [
		"Special case for fraction power by Nicolas Cellier:
		If aNumber is a fraction, but result must be a Float, learn it as quickly as possible, and give quick Float answer
		Allows evaluating:
		(2009/2000) raisedTo: (3958333/100000)
		"
		^ self raisedToFraction: aNumber].
	self < 0 ifTrue: [
		^ ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].
	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"
	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"
	0 = self ifTrue: [				"Special case of self = 0"
		aNumber < 0
			ifTrue: [^ (ZeroDivide dividend: self) signal]
			ifFalse: [^ self]].
	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !
!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 8/17/2017 21:38:55' prior: 16849696!
                          nthRoot: aPositiveInteger
	"Answer the nth root of the receiver."
	| guess |
	guess _ (numerator nthRootTruncated: aPositiveInteger) /
				(denominator nthRootTruncated: aPositiveInteger).
	(guess raisedTo: aPositiveInteger) = self ifTrue: [
		^ guess ].
	"There is no exact nth root, so answer a Float approximation"
	^ (self abs ln / aPositiveInteger) exp * self sign! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3141-raisedTo-fix-NicolasCellier-2017Aug17-21h28m-jmv.1.cs.st----!

----SNAPSHOT----#(17 August 2017 10:43:00.134843 pm) Cuis5.0-3141-v3.image priorSource: 1139140!

----QUIT----#(17 August 2017 10:43:11.415409 pm) Cuis5.0-3141-v3.image priorSource: 1158329!

----STARTUP----#(18 August 2017 6:06:27.201531 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3141-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3138] on 18 August 2017 at 3:36:55 pm'!
!Debugger methodsFor: 'code pane' stamp: 'jmv 8/18/2017 15:36:20' prior: 16829971!
     contentsSelection

	"If we are just creating the method in the debugger, help the user by selecting the method body."
	currentCompiledMethod ifNotNil: [
		((currentCompiledMethod hasLiteral: #shouldBeImplemented) and: [
			(self selectedContext debuggerMap method abstractPCForConcretePC: self selectedContext pc) = 1]) ifTrue: [
				^currentCompiledMethod selector size + 3  to: currentCompiledMethod getSource size ]].

	^self pcRange! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3142-autoSelectBodyIfCreateInDebugger-JuanVuletich-2017Aug18-15h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3141] on 18 August 2017 at 5:43:59 pm'!
!Workspace methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:42:35'!
                   is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !
!Debugger methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:41:49'!
                      is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !
!Inspector methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:42:07'!
                     is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !
!ObjectExplorer methodsFor: 'testing' stamp: 'jmv 8/18/2017 17:42:19'!
                is: aSymbol
	^ aSymbol == #providesBindings or: [ super is: aSymbol ]! !
!Inspector methodsFor: 'accessing' stamp: 'jmv 9/21/2009 15:16' prior: 50367450!
      selectedClassOrMetaClass

	^ self selectedClass	"I don't know any better"! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 8/18/2017 17:43:14' prior: 50367464!
                        computeEntries

	| allSource contextClass id specificModel last3Ranges range prevRange receiverClass prevPrevRange |
	allSource _ model actualContents string.
	specificModel _ (model is: #hasTextProvider)
		ifTrue: [ model textProvider ]
		ifFalse: [ model ].
	contextClass _ (specificModel is: #CodeProvider) ifTrue: [
		specificModel selectedClassOrMetaClass ].

	"Instead of creating a new string, maybe we could pass the last position to parse to Shout..."
	parser _ SHParserST80 new.
	parser
		workspace: ((specificModel is: #providesBindings) ifTrue: [specificModel]);
		classOrMetaClass: contextClass;
		source: (allSource copyFrom: 1 to: position).
	parser parse.
	last3Ranges _ parser last3Ranges.
	range _ last3Ranges third.
	range ifNil: [ ^entries _ #() ].

	"If parsing breaks before position, then we don't know what to suggest, therefore don't open Completion"
	range end = position ifFalse: [ ^entries _ #() ].

	prefix _ allSource copyFrom: range start to: range end.
	
	(parser isMessage: range rangeType) ifTrue: [
		"If previous range is a constant or a well known identifier, we might filter messages"
		prevRange _ last3Ranges second.
		prevPrevRange _ last3Ranges first.
		receiverClass _ nil.
		"3 if -> ifNil: but not ifTrue:
		3=4 -> ifNil: or ifTrue:"
		(prevRange notNil and: [ prevPrevRange isNil or: [ (#(binary keyword) includes: prevPrevRange rangeType) not]]) ifTrue: [
			id _ (allSource copyFrom: prevRange start to: prevRange end).
			receiverClass _ prevRange rangeType caseOf: {
				[ #globalVar ] -> [ (Smalltalk at: id asSymbol) class ].
				[ #self ] -> [ contextClass ].
				[ #super ] -> [ contextClass superclass ].
				[ #true ] -> [ True ].
				[ #false ] -> [ False ].
				[ #nil ] -> [ UndefinedObject ].
				[ #character ] -> [ id first class ].
				[ #number ] -> [ (Compiler evaluate: id) class ].
				[ #string ] -> [ (Compiler evaluate: id) class ].
				[ #symbol ] -> [ (Compiler evaluate: id) class ].
				[ #stringSymbol ] -> [ (Compiler evaluate: id) class ].
				"thisContext could mean ContextPart or BlockClosure..."
				"[ #thisContext ] -> [ ContextPart ]"
			} otherwise: [ nil ]
		].
		^self computeMessageEntries: receiverClass ].

	(parser isPartialOrFullIdentifier: range rangeType) ifTrue: [
		^self computeIdentifierEntries ].
	
	"If we don't know what to do, do nothing"
	entries _ #()! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3143-fixRecentAutocompleteBug-JuanVuletich-2017Aug18-17h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3129] on 18 August 2017 at 9:07:32 am'!
!Message methodsFor: 'stub creation' stamp: 'HAW 8/18/2017 09:04:10'!
                        addGetterCodeOn: stream

	stream
		newLine; tab;
		nextPut: $^;
		nextPutAll: selector ! !
!Message methodsFor: 'stub creation' stamp: 'HAW 8/18/2017 09:04:52'!
                               addSetterCodeOn: stream with: argumentName
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ' := ';
		nextPutAll: argumentName ! !
!Message methodsFor: 'stub creation' stamp: 'HAW 8/18/2017 07:43:09'!
                        writeShouldBeImplementedOn: stream.
		
	stream				
		nextPutAll: 'self ';
		nextPutAll: #shouldBeImplemented;
		nextPut: $.! !
!Message methodsFor: 'testing' stamp: 'HAW 8/18/2017 07:40:37'!
 isGetter

	^selector isUnary and: [ lookupClass instVarNames includes: selector  ]! !
!Message methodsFor: 'testing' stamp: 'HAW 8/18/2017 07:44:22'!
          isSetter

	^selector isKeyword and: [ self numArgs = 1 and: [ lookupClass instVarNames includes: selector allButLast ]]! !
!Message methodsFor: 'stub creation' stamp: 'HAW 8/18/2017 09:03:49' prior: 16867424!
               createStubMethod
	| argNames aOrAn argName arg argClassName |
			
	argNames _ Set new.
	^ String streamContents: [ :s |
		self selector keywords withIndexDo: [ :key :i |
			s nextPutAll: key.
			((key last = $:) or: [self selector isInfix]) ifTrue: [
				arg _ self arguments at: i.
				argClassName _ (arg class isMeta) ifTrue: ['Class'] ifFalse: [arg class name].
				aOrAn _ argClassName first isVowel ifTrue: ['an'] ifFalse: ['a'].
				argName _ aOrAn, argClassName.
				[argNames includes: argName] whileTrue: [argName _ argName, i asString].
				argNames add: argName.
				s nextPutAll: ' '; nextPutAll: argName; space
			].
		].
		s newLine; tab.
		self writeShouldBeImplementedOn: s.
		self isGetter ifTrue: [ self addGetterCodeOn: s ].
		self isSetter ifTrue: [ self addSetterCodeOn: s with: argName ].
	]! !

Message removeSelector: #createGetterStub!

Message removeSelector: #createSetterStub!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3144-CreateAccessorsInDebugger-HernanWilkinson-2017Aug17-20h05m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3144] on 18 August 2017 at 6:03:22 pm'!
!Debugger methodsFor: 'code pane' stamp: 'jmv 8/18/2017 18:02:55' prior: 50367861!
                    contentsSelection

	"If we are just creating the method in the debugger, help the user by selecting the method body."
	| sendInterval |
	currentCompiledMethod ifNotNil: [
		((currentCompiledMethod hasLiteral: #shouldBeImplemented) and: [
			(currentCompiledMethod abstractPCForConcretePC: self selectedContext pc) = 1]) ifTrue: [
				sendInterval _ (self selectedContext debuggerMap abstractSourceMap at: 2 ifAbsent: [nil]).
				sendInterval ifNotNil: [ ^ sendInterval first - 5 to: sendInterval last + 1 ]]].

	^self pcRange! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3145-autoSelectOnCreateInDebugger-update-JuanVuletich-2017Aug18-17h52m-jmv.1.cs.st----!

----SNAPSHOT----#(18 August 2017 6:06:32.360998 pm) Cuis5.0-3145-v3.image priorSource: 1158427!

----QUIT----#(18 August 2017 6:06:44.135902 pm) Cuis5.0-3145-v3.image priorSource: 1166058!

----STARTUP----#(28 August 2017 9:44:54.537559 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3145-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3145] on 22 August 2017 at 11:23:45 am'!
!Object methodsFor: 'message handling' stamp: 'HAW 8/22/2017 10:17:59'!
argumentName

	^self argumentNameSufix prefixedWithAOrAn ! !
!Object methodsFor: 'message handling' stamp: 'HAW 8/22/2017 10:16:01'!
                           argumentNameSufix

	^self class isMeta ifTrue: ['Class'] ifFalse: [self class name]! !
!String methodsFor: 'converting' stamp: 'HAW 8/22/2017 10:14:02'!
       aOrAnPrefix

	^self isEmpty 
		ifTrue: [ self ]
		ifFalse: [ self first isVowel ifTrue: ['an'] ifFalse: ['a'] ]
! !
!String methodsFor: 'converting' stamp: 'HAW 8/22/2017 10:14:46'!
          prefixedWithAOrAn

	^self aOrAnPrefix, self! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 8/22/2017 11:22:30' prior: 50336724!
                        implement: aMessage inClass: aClass context: aContext 
	
	aClass
		compile: (aMessage createStubMethodFor: aClass)
		classified: (self askForCategoryIn: aClass default: 'as yet unclassified').
		
	aContext privRefreshWith: (aClass lookupSelector: aMessage selector).
	aMessage arguments withIndexDo: [ :arg :index | aContext tempAt: index put: arg ].
	self resetContext: aContext! !
!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:23:03' prior: 50367995!
           addGetterCodeOn: stream

	stream
		newLine; tab;
		nextPut: $^;
		nextPutAll: selector ! !
!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:23:07' prior: 50368001!
               addSetterCodeOn: stream with: argumentName
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ' := ';
		nextPutAll: argumentName ! !
!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:22:53'!
                        createStubMethodFor: aClass

	| argNames argName arg  |

	argNames _ Set new.
	^ String streamContents: [ :s |
		self selector keywords withIndexDo: [ :key :i |
			s nextPutAll: key.
			((key last = $:) or: [self selector isInfix]) ifTrue: [
				arg _ self arguments at: i.
				argName _ arg argumentName.
				[argNames includes: argName] whileTrue: [argName _ argName, i asString].
				argNames add: argName.
				s nextPutAll: ' '; nextPutAll: argName; space
			].
		].
	
		s newLine; tab.
		self writeShouldBeImplementedOn: s.
		(self isGetterFor: aClass) ifTrue: [ self addGetterCodeOn: s ].
		(self isSetterFor: aClass) ifTrue: [ self addSetterCodeOn: s with: argName ].
	]! !
!Message methodsFor: 'stub creation' stamp: 'HAW 8/22/2017 11:23:11' prior: 50368009!
 writeShouldBeImplementedOn: stream.

	stream				
		nextPutAll: 'self ';
		nextPutAll: #shouldBeImplemented;
		nextPut: $.! !
!Message methodsFor: 'testing' stamp: 'HAW 8/22/2017 11:22:40'!
   isGetterFor: aClass

	^selector isUnary and: [ aClass instVarNames includes: selector  ]! !
!Message methodsFor: 'testing' stamp: 'HAW 8/22/2017 11:22:43'!
    isSetterFor: aClass

	^selector isKeyword and: [ self numArgs = 1 and: [ aClass instVarNames includes: selector allButLast ]]! !

Message removeSelector: #createStubMethod!

Message removeSelector: #createStubMethod!

Message removeSelector: #isGetter!

Message removeSelector: #isGetter!

Message removeSelector: #isSetter!

Message removeSelector: #isSetter!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3146-CreateAccessorsInDebuggerFix-HernanWilkinson-2017Aug19-20h52m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3145] on 23 August 2017 at 2:35:44 pm'!
!TextModelMorph methodsFor: 'accessing' stamp: 'HAW 8/23/2017 14:22:17'!
                            enableEdition

	self textMorph enableEdition! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'HAW 8/23/2017 14:23:36'!
       enableEdition
	
	self removeProperty: #disablesEdition! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3147-textMorph-enableEdition-HernanWilkinson-2017Aug23-12h52m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3147] on 25 August 2017 at 10:56:35 am'!
!Object methodsFor: 'printing' stamp: 'jmv 8/25/2017 10:55:31' prior: 16882206!
        printOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver."

	| title |
	title _ self class name.
	aStream
		nextPutAll: title aOrAnPrefix;
		space;
		nextPutAll: title! !
!Object methodsFor: 'printing' stamp: 'jmv 8/25/2017 10:55:49' prior: 16882255!
                 printWithClosureAnalysisOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver."

	| title |
	title _ self class name.
	aStream
		nextPutAll: title aOrAnPrefix;
		space;
		nextPutAll: title! !
!ContextPart methodsFor: 'debugger access' stamp: 'jmv 8/25/2017 10:55:54' prior: 16824084!
                  print: anObject on: aStream
	"Safely print anObject in the face of direct ProtoObject subclasses."
	| objClass title |
	objClass _ self objectClass: anObject.
	(objClass canUnderstand: #printOn:) ifTrue: [
		^anObject printOn: aStream].
	title _ objClass name.
	aStream
		nextPutAll: title aOrAnPrefix;
		space;
		nextPutAll: title! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3148-Use-aOrAnPrefix-JuanVuletich-2017Aug25-10h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3128] on 23 July 2017 at 1:07:52 am'!
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'pb 7/23/2017 00:53:45' prior: 50359403!
               buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground textHeigth |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	textHeigth := AbstractFont default height.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: textHeigth;
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: textHeigth;
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: textHeigth;
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: self buildButtonPane fixedHeight: Theme current buttonPaneHeight;
		addAdjusterAndMorph: summary fixedHeight: 60;
		addAdjusterAndMorph: description proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.15.
	self setLabel: 'Installed Packages'! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3149-CodePackageWindow-layout-tweak-PhilBellalouna-2017Jul23-00h53m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3128] on 23 July 2017 at 1:47:54 pm'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3150-category-cleanup-PhilBellalouna-2017Jul23-13h39m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3131] on 27 July 2017 at 3:27:46 am'!
!Debugger class methodsFor: 'opening' stamp: 'pb 7/27/2017 03:27:10' prior: 16830456!
openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug.log' ].
	w := ProjectX newProcessIfUIX: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	WorldState addDeferredUIMessage: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3151-Debugger-ensure-focus-released-fix-PhilBellalouna-2017Jul27-03h27m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3130] on 27 July 2017 at 2:24:40 pm'!
!HierarchicalListMorph methodsFor: 'commands' stamp: 'pb 7/27/2017 14:24:23' prior: 16852992!
                       toggleExpandedState: aMorph event: event

	"self setSelectedMorph: aMorph."
	((self autoExpand or: [event shiftPressed]) and: [aMorph isExpanded not])
		ifTrue: [aMorph beFullyExpanded]
		ifFalse: [aMorph toggleExpandedState].
	scroller adjustExtent.
	self setScrollDeltas! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3152-HierarchicalListMorph-shift-key-fully-expands-PhilBellalouna-2017Jul27-14h17m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3130] on 27 July 2017 at 6:26:56 am'!

TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected '
	classVariableNames: 'FileReaderRegistry '
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #FileList category: #'Tools-FileList'!
TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected'
	classVariableNames: 'FileReaderRegistry'
	poolDictionaries: ''
	category: 'Tools-FileList'!
!FileList class methodsFor: 'file reader registration' stamp: 'pb 7/27/2017 06:05:51' prior: 16843241!
                         itemsForFile: filename
	"Answer a list of services appropriate for a file of the given name"
	| services suffix classList |
	suffix _ (FileIOAccessor default extensionFor: filename) asLowercase.
	services _ OrderedCollection new.
	"Build the list dynamically for all implementers of the appropriate class method... registration no longer required"
	classList _ (Smalltalk allClassesImplementing: #fileReaderServicesForFile:suffix:)
		collect: [ :item |
			item class == Metaclass ifTrue: [ item soleInstance ]]
		thenSelect: [ :item |
			item notNil ].
	classList do: [ :reader |
		reader ifNotNil: [
			services addAll:
				(reader
					fileReaderServicesForFile: filename
					suffix: suffix) ]].
	^ services.! !
!FileList class methodsFor: 'file reader registration' stamp: 'pb 7/27/2017 06:02:20' prior: 16843256!
              registerFileReader: aProviderClass
	"For compatibility... no longer necessary"! !
!FileList class methodsFor: 'file reader registration' stamp: 'pb 7/27/2017 06:02:32' prior: 16843266!
       unregisterFileReader: aProviderClass
	"For compatibility... no longer necessary"! !

Morph class removeSelector: #unload!

Morph class removeSelector: #unload!

Form class removeSelector: #unload!

Form class removeSelector: #unload!

FileList class removeSelector: #initialize!

FileList class removeSelector: #initialize!

ChangeSorter class removeSelector: #unload!

ChangeSorter class removeSelector: #unload!

ChangeList class removeSelector: #unload!

ChangeList class removeSelector: #unload!

CodeFileBrowser class removeSelector: #unload!

CodeFileBrowser class removeSelector: #unload!

MessageNames class removeSelector: #unload!

MessageNames class removeSelector: #unload!

TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #FileList category: #'Tools-FileList'!
TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

FileList initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3153-FileList-dynamic-registration-PhilBellalouna-2017Jul27-05h59m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3153] on 25 August 2017 at 1:01:32 pm'!
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/25/2017 13:00:40' prior: 50366866!
         goDown
	self selected = completer entryCount ifTrue: [
		"Wrap around"
		^ self goHome ].
	self selected: self selected + 1.
	(self selected > self lastVisible
			and: [self selected <= completer entryCount])
		ifTrue: [firstVisible := firstVisible + 1].
	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/25/2017 13:00:48' prior: 50366898!
                goUp
	(self selected = 0
			and: [self firstVisible = 1])
		ifTrue: [^ self].
	self selected = 1 ifTrue: [
		"Wrap around"
		^self goToEnd ].
	self selected: self selected - 1.
	self selected < self firstVisible
		ifTrue: [firstVisible := firstVisible - 1].
	self redrawNeeded! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3154-WraparoundAutoComplete-JuanVuletich-2017Aug25-12h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3145] on 28 August 2017 at 1:59:42 pm'!
!CompiledMethod class methodsFor: 'method encoding' stamp: 'HAW 8/28/2017 13:59:31' prior: 16821632!
                          headerFlagForEncoder: anEncoder
	
	(anEncoder class includesBehavior: PrimaryBytecodeSetEncoderClass) ifTrue: [^0].
	(anEncoder class includesBehavior: SecondaryBytecodeSetEncoderClass) ifTrue: [^SmallInteger minVal].
	
	self error: 'The encoder is not one of the two installed bytecode sets'! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3155-AllowOtherMethodEncoders-HernanWilkinson-2017Aug28-13h56m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3145] on 28 August 2017 at 1:50:13 pm'!

CodeWindow subclass: #BrowserWindow
	instanceVariableNames: 'codePane '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!classDefinition: #BrowserWindow category: #'Morphic-Tools'!
CodeWindow subclass: #BrowserWindow
	instanceVariableNames: 'codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!
!BrowserWindow methodsFor: 'updating' stamp: 'HAW 8/28/2017 13:44:30'!
 disableCodePaneEdition

	codePane ifNotNil: [ codePane disableEdition ]! !
!BrowserWindow methodsFor: 'updating' stamp: 'HAW 8/28/2017 13:41:24'!
              editSelectionChanged
	
	self isEditSelectionNone
		ifTrue: [ self disableCodePaneEdition ]
		ifFalse: [ self enableCodePaneEdition]! !
!BrowserWindow methodsFor: 'updating' stamp: 'HAW 8/28/2017 13:43:20'!
                  enableCodePaneEdition

	codePane ifNotNil: [ codePane enableEdition ]! !
!BrowserWindow methodsFor: 'updating' stamp: 'HAW 8/28/2017 13:43:44'!
                isEditSelectionNone
		
	^ model editSelection = #none! !
!BrowserWindow methodsFor: 'updating' stamp: 'HAW 8/28/2017 13:41:51'!
update: anEvent
	super update: anEvent.
	anEvent = #editSelection ifTrue: [self editSelectionChanged ] ! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 8/28/2017 13:39:41'!
          buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."

	codePane _ super buildMorphicCodePane.
	^codePane! !

CodeWindow subclass: #BrowserWindow
	instanceVariableNames: 'codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!classDefinition: #BrowserWindow category: #'Morphic-Tools'!
CodeWindow subclass: #BrowserWindow
	instanceVariableNames: 'codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3156-DisableEditionIfNoSysCatSelected-HernanWilkinson-2017Aug23-14h35m-HAW.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3156] on 28 August 2017 at 5:05:29 pm'!
!MessageSet methodsFor: 'private' stamp: 'jmv 8/28/2017 17:05:18' prior: 16870086!
                 initializeMessageList: anArray

	messageList _ anArray.
	messageList isEmpty
		ifTrue: [ selectedMessage _ nil ]
		ifFalse: [
			selectedMessage _ messageList first.
			self editSelection: #editMessage ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3157-MessageSetFix-JuanVuletich-2017Aug28-16h59m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3157] on 28 August 2017 at 5:16:24 pm'!
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 8/28/2017 17:06:34'!
                              reservedNames

	^Theme current pseudoVariables! !
!ClassBuilder methodsFor: 'private' stamp: 'jmv 8/28/2017 16:58:40' prior: 16804009!
                         reservedNames
	"Return a list of names that must not be used for variables"
	^#(#self #super #true #false #nil #thisContext)! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 8/28/2017 16:51:25' prior: 16902210!
isIncompleteReservedName: aString 
	"Answer true if aString is the start of a reserved name, false otherwise"

	self reservedNames do: [ :arg | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 8/28/2017 16:53:14' prior: 16902288!
                       resolve: aString

	self reservedNames do: [ :symbol | aString = symbol ifTrue: [^symbol]].
	(self isBlockTempName: aString) ifTrue: [^#blockTempVar].
	(self isBlockArgName: aString) ifTrue: [^#blockArg].
	(self isMethodTempName: aString) ifTrue: [^#tempVar].
	(self isMethodArgName: aString) ifTrue: [^#methodArg].
	(self isInstVarName: aString) ifTrue: [^#instVar].
	(self isWorkspaceVarName: aString) ifTrue: [^#workspaceVar].
	Symbol hasInterned: aString ifTrue: [ :symbol |
		(self isClassVarName: symbol) ifTrue: [ ^#classVar ].
		(self isPoolConstantName: symbol) ifTrue: [ ^#poolConstant].
		(self isGlobal: symbol) ifTrue: [^#globalVar]].
	^self resolvePartial: aString! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 8/28/2017 16:52:46' prior: 16902979!
                    nonGlobalNamesDo: aBlock
	"Evaluate aBlock over all available names, except for globals"

	self
		blockArgNamesDo: aBlock;
		blockTempNamesDo: aBlock;
		methodArgNamesDo: aBlock;
		methodTempNamesDo: aBlock;
		instVarNamesDo: aBlock;
		classVarNamesDo: aBlock;
		poolConstantNamesDo: aBlock;
		workspaceNamesDo: aBlock.
	self
		reservedNames do: aBlock! !
!SHParserST80 methodsFor: 'testing' stamp: 'jmv 8/28/2017 17:14:20' prior: 16903020!
       isPartialOrFullIdentifier: aSymbol

	(#(#incompleteIdentifier
		#blockTempVar #blockArg #tempVar #methodArg
		#instVar #classVar 
		#workspaceVar #poolConstant #globalVar ) 
			statePointsTo:aSymbol) ifTrue: [ ^ true ].
	(self reservedNames statePointsTo: aSymbol) ifTrue: [ ^ true ].
	^ false! !

SHParserST80 removeSelector: #isReservedName:!

SHParserST80 removeSelector: #isReservedName:!

SHParserST80 removeSelector: #reservedNamesDo:!

SHParserST80 removeSelector: #reservedNamesDo:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3158-AllowNewReservedNamesInSHParserST80-JuanVuletich-2017Aug28-17h12m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3158] on 28 August 2017 at 5:26:35 pm'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 8/25/2017 15:05:56' prior: 16888064!
label: aStringOrNil font: aFontOrNil
	"Label this button with the given string."
	label _ aStringOrNil.
	font _ aFontOrNil.
	(self fontToUse notNil and: [ label notNil ])
		ifTrue: [ "Add a bit of padding"
			extent := (self fontToUse widthOfString: label) + 10 @ (self fontToUse height + 10) ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3159-SetAppropriateButtonExtent-JuanVuletich-2017Aug28-17h25m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3154] on 26 August 2017 at 7:48:09 pm'!
!TextModel methodsFor: 'user interface support' stamp: 'jmv 8/26/2017 19:19:29'!
                        formatAndStyleIfNeededWith: anSHTextStyler
	anSHTextStyler ifNotNil: [
		(self shouldStyle: self actualContents with: anSHTextStyler) ifTrue: [
			anSHTextStyler formatAndStyle: self actualContents allowBackgroundStyleProcess: true.
			self basicActualContents: anSHTextStyler formattedText ]]! !
!PluggableTextModel methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:51'!
      shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	^textProvider shouldStyle: text with: anSHTextStyler! !
!Workspace methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:53'!
      shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text."

	self shouldStyle ifFalse: [ ^false ].
	anSHTextStyler 
		classOrMetaClass: nil;
		workspace: self.
	^true! !
!CodeProvider methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:32'!
                  shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer false if showing difs, to veto the styling."
	
	^self showingAnyKindOfDiffs not! !
!Browser methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:20'!
            shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	| type |
	
	self isModeStyleable ifFalse: [^false].
	type _ self editSelection.
	(#(newMessage editMessage editClass newClass) includes: type) ifFalse:[^false].
	anSHTextStyler classOrMetaClass: (type = #editClass ifFalse:[self selectedClassOrMetaClass]).
	^true! !
!MessageSet methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:44'!
                   shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [^false].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !
!CodeFileBrowser methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:30'!
   shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"

	self isModeStyleable ifFalse: [^false].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !
!ChangeList methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:23'!
         shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [^false].
	listIndex = 0 ifFalse: [
		(changeList at: listIndex) changeType = #method ifTrue: [
			self selectedClassOrMetaClass ifNotNil: [ :cl |
				anSHTextStyler classOrMetaClass: cl.
				^true ]]].
	^false! !
!ChangeSorter methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:27'!
     shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"

	self isModeStyleable ifFalse: [^false].
	self currentSelector ifNil: [^false].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !
!Debugger methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:21:36'!
    shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [^false].
	anSHTextStyler 
		classOrMetaClass: self selectedClassOrMetaClass;
		disableFormatAndConvert;
		workspace: self.
	^true! !
!Inspector methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:42:36'!
                        shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer true to allow styling to proceed, or false to veto the styling"

	anSHTextStyler workspace: self.
	^(text = self acceptedContents) not! !
!ObjectExplorer methodsFor: 'shout styling' stamp: 'jmv 8/26/2017 19:27:12'!
              shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Answer true to allow styling to proceed, or false to veto the styling"

	anSHTextStyler workspace: self.
	^true! !
!Inspector methodsFor: 'contents' stamp: 'jmv 8/26/2017 19:40:39' prior: 16857103!
      acceptedStringOrText
	"We need our cache not to be modified by user editions"
	^acceptedContentsCache copy! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 8/26/2017 19:07:20' prior: 16855670!
                           hasUnacceptedEdits: aBoolean
	"Set the hasUnacceptedEdits flag to the given value. "
	aBoolean == hasUnacceptedEdits ifFalse: [
		hasUnacceptedEdits _ aBoolean.
		owner redrawNeeded].
	aBoolean ifFalse: [ hasEditingConflicts _ false].

	"shout:  re-style the text iff aBoolean is true
	Do not apply any formatting (i.e. changes to the characters in the text),
	just styling (i.e. TextAttributes)"
	aBoolean ifTrue: [
		self formatAndStyleIfNeeded ]! !
!InnerTextMorph methodsFor: 'shout' stamp: 'jmv 8/26/2017 19:14:13' prior: 16856199!
       formatAndStyleIfNeeded
	"Apply both formatting (changes to the characters in the text, such as
	preferred assignment operators), and styling (TextAttributes to make
	Smalltalk code easier to understand)"

	model formatAndStyleIfNeededWith: styler! !

InnerTextMorph removeSelector: #okToStyle!

InnerTextMorph removeSelector: #okToStyle!

ObjectExplorer removeSelector: #shoutAboutToStyle:!

ObjectExplorer removeSelector: #shoutAboutToStyle:!

Inspector removeSelector: #shoutAboutToStyle:!

Inspector removeSelector: #shoutAboutToStyle:!

Debugger removeSelector: #shoutAboutToStyle:!

Debugger removeSelector: #shoutAboutToStyle:!

ChangeSorter removeSelector: #shoutAboutToStyle:!

ChangeSorter removeSelector: #shoutAboutToStyle:!

ChangeList removeSelector: #shoutAboutToStyle:!

ChangeList removeSelector: #shoutAboutToStyle:!

CodeFileBrowser removeSelector: #shoutAboutToStyle:!

CodeFileBrowser removeSelector: #shoutAboutToStyle:!

MessageSet removeSelector: #shoutAboutToStyle:!

MessageSet removeSelector: #shoutAboutToStyle:!

Browser removeSelector: #shoutAboutToStyle:!

Browser removeSelector: #shoutAboutToStyle:!

CodeProvider removeSelector: #shoutAboutToStyle:!

CodeProvider removeSelector: #shoutAboutToStyle:!

Workspace removeSelector: #shoutAboutToStyle:!

Workspace removeSelector: #shoutAboutToStyle:!

PluggableTextModel removeSelector: #shoutAboutToStyle:!

PluggableTextModel removeSelector: #shoutAboutToStyle:!

TextModel removeSelector: #formatAndStyleWith:!

TextModel removeSelector: #formatAndStyleWith:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3160-AvoidStylingInIspectorUntilEdit-JuanVuletich-2017Aug26-19h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3160] on 28 August 2017 at 9:40:53 pm'!

ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #SimpleServiceEntry category: #'Tools-FileList'!
ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!
!SimpleServiceEntry methodsFor: 'accessing' stamp: 'jmv 8/28/2017 21:35:11'!
                               sortOrder
	^sortOrder! !
!SimpleServiceEntry methodsFor: 'accessing' stamp: 'jmv 8/28/2017 21:28:07'!
                          sortOrder: aNumber
	sortOrder _ aNumber! !
!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 8/28/2017 21:40:08' prior: 16809512!
             serviceBrowseCode
	"Answer the service of opening a file-contents browser"

	^ (SimpleServiceEntry
		provider: self 
		label: 'code file browser'
		selector: #browseCode:
		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'code')
			sortOrder: 10;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'jmv 8/28/2017 21:40:05' prior: 16809527!
                  serviceBrowsePackage
	"Answer the service of opening a file-contents browser"

	^ (SimpleServiceEntry
		provider: self 
		label: 'package file browser'
		selector: #browsePackage:
		description: 'open a "package file browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'package browser')
			sortOrder: 10;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 8/28/2017 21:39:59' prior: 16796992!
           serviceContents
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'code file contents'
		selector: #browseContents:
		description: 'open a code file contents tool on this file'
		buttonLabel: 'contents')
			sortOrder: 20;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 8/28/2017 21:39:55' prior: 16797005!
    servicePackageContents
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'package file contents'
		selector: #browsePackageContents:
		description: 'open a code file contents tool on this package file'
		buttonLabel: 'pck contents')
			sortOrder: 20;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!FileList class methodsFor: 'file reader registration' stamp: 'jmv 8/28/2017 21:39:36' prior: 50368456!
                           itemsForFile: filename
	"Answer a list of services appropriate for a file of the given name"
	| services suffix classList |
	suffix _ (FileIOAccessor default extensionFor: filename) asLowercase.
	"Build the list dynamically for all implementers of the appropriate class method... registration no longer required"
	classList _ (Smalltalk allClassesImplementing: #fileReaderServicesForFile:suffix:)
		collect: [ :item |
			item class == Metaclass ifTrue: [ item soleInstance ]]
		thenSelect: [ :item |
			item notNil ].
	services _ OrderedCollection new.
	classList do: [ :reader |
		services addAll:
			(reader
				fileReaderServicesForFile: filename
				suffix: suffix) ].
	services sort: [ :a :b | a sortOrder < b sortOrder ].
	^ services.! !
!ChangeSet class methodsFor: 'file list services' stamp: 'jmv 8/28/2017 21:28:59' prior: 16799248!
                     serviceFileIn
	"Answer a service for filing in an entire file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'fileIn entire file'
		selector: #fileIn:
		description: 'file in the entire contents of the file, which is expected to contain Smalltalk code in fileout ("chunk") format'
		buttonLabel: 'filein')
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!ChangeSet class methodsFor: 'file list services' stamp: 'jmv 8/28/2017 21:29:05' prior: 16799263!
                 serviceInstall
	"Answer a service for filing in an entire file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'install code'
		selector: #install:
		description: 'install change set'
		buttonLabel: 'install')
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!CodePackageFile class methodsFor: 'file list services' stamp: 'jmv 8/28/2017 21:29:39' prior: 16811207!
            serviceInstallPackage
	"Answer the service of installing a CodePackageFile (a chunk format file for a CodePackage)"

	^ (SimpleServiceEntry
		provider: self 
		label: 'install package'
		selector: #installPackageStream:
		description: 'install the package, replacing all existing code in the package (if any); create a new change set just for the installation'
		buttonLabel: 'install package')
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !

ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #SimpleServiceEntry category: #'Tools-FileList'!
ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3161-RestoreFileListButtonsOrder-JuanVuletich-2017Aug28-21h38m-jmv.1.cs.st----!

----SNAPSHOT----#(28 August 2017 9:45:04.328394 pm) Cuis5.0-3161-v3.image priorSource: 1166155!

----QUIT----#(28 August 2017 9:45:16.349516 pm) Cuis5.0-3161-v3.image priorSource: 1202187!

----STARTUP----#(10 September 2017 6:05:31.684746 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3161-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3161] on 29 August 2017 at 3:54:37 pm'!
!Theme methodsFor: 'keyboard shortcuts' stamp: 'jmv 8/29/2017 15:53:47' prior: 16936827!
            keyStroke: aKeyboardEvent morph: aMorph
	aKeyboardEvent controlKeyPressed ifTrue: [^false].
	aKeyboardEvent commandAltKeyPressed ifFalse: [^false].

	aKeyboardEvent keyValue = $w numericValue ifTrue: [
		aMorph owningWindow ifNotNil: [ :w |
			(w morphContainsPoint: (w internalizeFromWorld: aKeyboardEvent eventPosition)) ifTrue: [
				w delete. 
				^true ]	]].
"	aKeyboardEvent keyValue = $f numericValue
		ifTrue: [aMorph owningWindow ifNotNil: [ :w | w fullScreen. ^true ]].
"
	^ false! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3162-OnlyCloseWindowIfContainsMousePointer-JuanVuletich-2017Aug29-15h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 9 July 2017 at 7:49:17 pm'!
!Interval class methodsFor: 'instance creation' stamp: 'jmv 7/9/2017 16:59:23' prior: 16861363!
                             newFrom: aCollection 
	"Answer an instance of me containing the same elements as aCollection."

    | newInterval n |

    (n := aCollection size) <= 1 ifTrue: [
		n = 0 ifTrue: [^self from: 1 to: 0].
		^self from: aCollection first to: aCollection last].
    	newInterval := self from: aCollection first to: aCollection last by: (aCollection last - aCollection first) // (n - 1).
	(newInterval hasEqualElements: aCollection)
		ifFalse: [ self error: 'The argument is not an arithmetic progression' ].
	^newInterval

"
	Interval newFrom: {1. 2. 3}
	{33. 5. -23} as: Interval
	{33. 5. -22} as: Interval.   ' (an error)'
	(-4 to: -12 by: -1) as: Interval
"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3163-IntervalFix-JuanVuletich-2017Jul09-16h58m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3163] on 31 August 2017 at 10:20:55 am'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3164-CategorizePinningProtocol-JuanVuletich-2017Aug31-10h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3164] on 6 September 2017 at 9:59:44 am'!
!SimpleServiceEntry methodsFor: 'initialization' stamp: 'jmv 9/6/2017 09:56:01' prior: 16908010!
initialize
	triggerFileListChanged _ false.
	sortOrder _ 1! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3165-FileListFix-JuanVuletich-2017Sep06-09h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3165] on 6 September 2017 at 10:08:50 am'!
!ReparseAfterSourceEditing commentStamp: 'jmv 9/6/2017 10:05:54' prior: 16900979!
               A ReparseAfterSourceEditing is a Notification used to restart the syntax parsing phase of a compilation after a change in source code.!
!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:01:18'!
                disableEditing
	self textMorph disableEditing! !
!TextModelMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:03:26'!
       enableEditing

	self textMorph enableEditing! !
!BrowserWindow methodsFor: 'updating' stamp: 'jmv 9/6/2017 10:04:36'!
          disableCodePaneEditing

	codePane ifNotNil: [ codePane disableEditing ]! !
!BrowserWindow methodsFor: 'updating' stamp: 'jmv 9/6/2017 10:04:48'!
               enableCodePaneEditing

	codePane ifNotNil: [ codePane enableEditing ]! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:01:59'!
               disableEditing
	self setProperty: #disablesEditing toValue: true.
	self stopBlinking! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:03:03'!
enableEditing
	
	self removeProperty: #disablesEditing! !
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 9/6/2017 10:02:01'!
                 disablesEditing

	^self hasProperty: #disablesEditing! !
!Inspector methodsFor: 'contents' stamp: 'jmv 9/6/2017 10:05:31' prior: 50368947!
                     acceptedStringOrText
	"We need our cache not to be modified by user changes"
	^acceptedContentsCache copy! !
!TextEditor methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:02:22' prior: 16931330!
                               replaceSelectionWith: aTextOrString
	"Deselect, and replace the selection text by aText."
	"This is a user command, and generates undo"

	| start stop replacement |

	morph disablesEditing ifTrue: [
		^ self ].

	start _ self startIndex.
	stop _ self stopIndex.
	(aTextOrString isEmpty and: [stop > start]) ifTrue: [
		"If deleting, then set emphasisHere from 1st character of the deletion"
		emphasisHere _ (model actualContents attributesAt: start) select: [:att |
			att mayBeExtended]].

	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [
		replacement _ self addAttributesForPasting: aTextOrString.
		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.
		textComposition
			recomposeFrom: start
			to:  start + replacement size - 1
			delta: replacement size - (stop-start).
		self deselectAndPlaceCursorAt: start + replacement size.
		selectionStartBlocks _ #().
		selectionStopBlocks _ #().
		self userHasEdited  " -- note text now dirty" ].

	morph possiblyChanged! !
!TextEditor methodsFor: 'private' stamp: 'jmv 9/6/2017 10:02:19' prior: 16932614!
        applyAttribute: aTextAttribute
	"The user selected aTextAttribute via shortcut, menu or other means.
	If there is a selection, apply the attribute to the selection.
	In any case use the attribute for the user input (emphasisHere)"
	"This generates undo"
	| anythingDone |

	morph disablesEditing ifTrue: [
		^ self ].

	anythingDone _ false.
	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.
	self selectionIntervalsDo: [ :interval |
		(interval notEmpty or: [ aTextAttribute isParagraphAttribute ])
			ifTrue: [
				anythingDone _ true.
				model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.
				textComposition recomposeFrom: interval first to: interval last delta: 0 ]].
	anythingDone ifTrue: [
		self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
		self userHasEdited ].

	"Even if nothing done, emphasisHere might have changed"
	morph possiblyChanged! !
!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 9/6/2017 10:02:20' prior: 16933011!
                             redo

	morph disablesEditing ifTrue: [
		^ self ].

	model redoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.			"this could be made more specific..."
			morph possiblyChanged ]]! !
!TextEditor methodsFor: 'undo & redo' stamp: 'jmv 9/6/2017 10:02:24' prior: 16933031!
           undo

	morph disablesEditing ifTrue: [
		^ self ].

	model undoAndEvaluate: [ :modelUpdated :newCursorPos |
		newCursorPos
			ifNil: [ self recomputeSelection ]
			ifNotNil: [ self markIndex: newCursorPos pointIndex: newCursorPos ].
		modelUpdated ifTrue: [
			self userHasEdited.
			textComposition composeAll.				"this could be made more specific..."
			morph possiblyChanged ]]! !
!BrowserWindow methodsFor: 'updating' stamp: 'jmv 9/6/2017 10:04:55' prior: 50368607!
          editSelectionChanged
	
	self isEditSelectionNone
		ifTrue: [ self disableCodePaneEditing ]
		ifFalse: [ self enableCodePaneEditing]! !
!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/6/2017 10:02:07' prior: 16856157!
                           showsBlinkingCursor

	^self handlesKeyboard and: [ self disablesEditing not ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3166-ItIsEditingNotEdition-JuanVuletich-2017Sep06-10h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3165] on 6 September 2017 at 10:09:36 am'!

InnerTextMorph removeSelector: #disableEdition!

InnerTextMorph removeSelector: #disableEdition!

InnerTextMorph removeSelector: #disablesEdition!

InnerTextMorph removeSelector: #disablesEdition!

InnerTextMorph removeSelector: #enableEdition!

InnerTextMorph removeSelector: #enableEdition!

BrowserWindow removeSelector: #disableCodePaneEdition!

BrowserWindow removeSelector: #disableCodePaneEdition!

BrowserWindow removeSelector: #enableCodePaneEdition!

BrowserWindow removeSelector: #enableCodePaneEdition!

TextModelMorph removeSelector: #disableEdition!

TextModelMorph removeSelector: #disableEdition!

TextModelMorph removeSelector: #enableEdition!

TextModelMorph removeSelector: #enableEdition!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3167-EditionMisnomerCleanup-JuanVuletich-2017Sep06-10h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3162] on 4 September 2017 at 5:01:33 pm'!

ChangeList subclass: #ChangeListWithFileInErrors
	instanceVariableNames: 'errors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #ChangeListWithFileInErrors category: #'Tools-Changes'!
ChangeList subclass: #ChangeListWithFileInErrors
	instanceVariableNames: 'errors'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeListWithFileInErrors commentStamp: 'HAW 9/4/2017 10:23:05' prior: 0!
   This class is used to keep errors when filing in changes.
I could have use ChangeList directly, selecting changes with errors, then removing them, etc., but it had some problems and that solution is more a hack.
So, instances of this class will keep errors when filing in a change, and it allows the posibility to show the change with the error in a change list window.

A doit change that signaled a MessageNotUnderstood is assume to not be an error becuase those kinds of things are evaluations in specific contexts that will obiously generate errors.
All doits with errors could be assume not to be errors, but I limited to MNU type of errors to avoid filtering errors that should be shown.!
!ChangeListWithFileInErrors methodsFor: 'filing in' stamp: 'HAW 9/4/2017 09:34:35'!
                     fileInAllKeepingErrors

	errors := Dictionary new.
	changeList do: [ :change | self fileInKeepingError: change ].
! !
!ChangeListWithFileInErrors methodsFor: 'filing in' stamp: 'HAW 9/4/2017 16:36:13'!
                      fileInKeepingError: change
	
	[ change fileIn ]
		on: Error 
		do: [ :anError | (self hasToKeep: anError for: change) ifTrue: [ errors at: change put: anError ]]! !
!ChangeListWithFileInErrors methodsFor: 'initialization-release' stamp: 'HAW 9/4/2017 09:34:20'!
                          initialize

	super initialize.
	errors := Dictionary new.! !
!ChangeListWithFileInErrors methodsFor: 'testing' stamp: 'HAW 9/4/2017 09:37:00'!
                 hasFileInErrors

	^errors notEmpty! !
!ChangeListWithFileInErrors methodsFor: 'testing' stamp: 'HAW 9/4/2017 16:37:07'!
        hasToKeep: anError for: change

	^(change isDoIt and: [ anError isKindOf: MessageNotUnderstood ]) not! !
!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:01:06'!
                       failedFileInChangesLabel

	^'Changes that failed to file in'! !
!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:45:43'!
ifFiledInWithErrorAdd: aChange at: anIndex to: newChangeList and: newList 
	
	(self wasFiledInWithError: aChange) ifTrue: [ 
		newChangeList add: aChange.
		newList add: ((list at: anIndex) contractTo: 40), ' | ', (errors at: aChange) printString ]! !
!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:04:47'!
    removeSucessfullyFiledInChanges

	| newChangeList newList |

	newChangeList := OrderedCollection new.
	newList := OrderedCollection new.

	changeList withIndexDo: [ :aChange :anIndex | self ifFiledInWithErrorAdd: aChange at: anIndex to: newChangeList and: newList ].
			
	changeList _ newChangeList.
	list _ newList.
	listIndex _ 0.
	self clearSelections.
	self changed: #list.! !
!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:02:20'!
   showChangesWithFileInErrors

	self removeSucessfullyFiledInChanges.
	ChangeListWindow open: self label: self failedFileInChangesLabel

! !
!ChangeListWithFileInErrors methodsFor: 'showing filein errors' stamp: 'HAW 9/4/2017 10:46:01'!
                     wasFiledInWithError: aChange
	
	^errors includesKey: aChange! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:48:40'!
              logSnapshot: save andQuit: quit
	"Log quitting to changes file"
	| msg |
	(SourceFiles at: 2) ifNotNil: [
		msg _ self snapshotMessageFor: save andQuit: quit.
		self assureStartupStampLogged.
		save ifTrue: [
			LastQuitLogPosition _ (SourceFiles at: 2)
				 setToEnd;
				 position ].
		self logChange: msg.
		Transcript
			 newLine;
			 show: msg;
			 newLine ]! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:42:57'!
                               nopTag

	^ 'NOP'! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:42:27'!
                          quitNoSaveTag

	^ 'QUIT/NOSAVE' ! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:40:45'!
          quitTag
		
	^'QUIT'! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:51:51'!
                       snapshotMessageFor: save andQuit: quit
		
	^String streamContents: [ :stream |
		stream 
			nextPutAll: self tagHeader;
			nextPutAll: (self snapshotTagFor: save andQuit: quit);
			nextPutAll: self tagTail;
			print: Date dateAndTimeNow;
			space;
			nextPutAll: self imageName asFileEntry name;
			nextPutAll: ' priorSource: ';
			print: LastQuitLogPosition ].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:41:19'!
 snapshotTag
		
	^'SNAPSHOT'! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:51:20'!
               snapshotTagFor: save andQuit: quit
		
	^save
		ifTrue: [ quit
			ifTrue: [ self quitTag ]
			ifFalse: [ self snapshotTag ]]
		ifFalse: [ quit
			ifTrue: [ self quitNoSaveTag ]
			ifFalse: [ self nopTag ]]! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:45:54'!
                              tagHeader

	^ '----'! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:46:02'!
                      tagTail

	^ self tagHeader! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:11:51'!
   hasToRestoreChanges

	^self withChangesFileDo: [ :changesFile |
		changesFile position: self lastQuitLogPosition.
		self hasToRestoreChangesFrom: changesFile ].
	! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 16:41:24'!
                           hasToRestoreChangesFrom: changesFile

	| chunk  |
	
	[ changesFile atEnd ] whileFalse: [ chunk := changesFile nextChunk ].
	
	^(self isSnapshotQuitOrQuitNoSaveRecord: chunk) not
! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 08:56:02'!
           isQuitNoSaveRecord: chunk

	^chunk beginsWith: self tagHeader, self quitNoSaveTag
	! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 08:55:51'!
          isQuitRecord: chunk

	^chunk beginsWith: self tagHeader, self quitTag ! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 16:34:34'!
                       isSnapshotQuitOrQuitNoSaveRecord: chunk

	^(self isSnapshotRecord: chunk) 
		or: [ (self isQuitRecord: chunk) 
		or: [ self isQuitNoSaveRecord: chunk ]]! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 08:57:09'!
     isSnapshotRecord: chunk

	^chunk beginsWith: self tagHeader, self snapshotTag 
	! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 09:07:35'!
             lostChangesDetectedCaption
	
	^
'Last changes may have been lost
(maybe the VM crashed or you had to kill it)
What do you want to do?'! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:25:45'!
                       restoreLostChanges

 	| decision |
	
	decision := PopUpMenu withCaption: self lostChangesDetectedCaption chooseFrom: self restoreLostChangesOptions.

	decision = 1 ifTrue: [ ^self restoreLostChangesAutomatically ].
	decision = 2 ifTrue: [ ^self restoreLostChangesManually ]! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:13:01'!
            restoreLostChangesAutomatically
	
	self withChangesFileDo: [ :aChangesFile | self restoreLostChangesAutomaticallyFrom: aChangesFile ]! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 10:15:16'!
                        restoreLostChangesAutomaticallyFrom: aChangesFile

	| changeList |

	changeList := ChangeListWithFileInErrors new.
	changeList scanFile: aChangesFile from: LastQuitLogPosition to: aChangesFile size.
	changeList fileInAllKeepingErrors.
	(changeList hasFileInErrors and: [ self shouldShowFileInErrors ]) ifTrue: [ changeList showChangesWithFileInErrors ]
! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:09:39'!
                            restoreLostChangesIfNecessary

	"
	Smalltalk restoreLostChangesIfNecessary
	"
	
	self hasToRestoreChanges ifTrue: [ WorldState addDeferredUIMessage: [self restoreLostChanges ]].
! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/1/2017 17:28:22'!
           restoreLostChangesManually

	ChangeList browseRecentLog! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:25:55'!
      restoreLostChangesOptions
	
	^{'Restore lost changes automatically'. 'Restore lost changes manually'. 'Nothing'}.! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:29:46'!
            restoringChangesHasErrorsCaption
	
	^'There were errors filing in the lost changes. Do you want to see them?'! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 09:37:34'!
                shouldShowFileInErrors
	
 	^self confirm: self restoringChangesHasErrorsCaption
	! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/4/2017 06:11:39'!
            withChangesFileDo: aBlock

	^self currentChangesName asFileEntry readStreamDo: aBlock! !
!ChangeRecord methodsFor: 'testing' stamp: 'HAW 9/4/2017 06:32:29'!
   isDoIt

	^type = #doIt! !
!ChangeList methodsFor: 'menu actions' stamp: 'HAW 9/4/2017 10:26:32' prior: 16796254!
               removeDoIts
	"Remove doits from the receiver, other than initializes. 1/26/96 sw"

	| newChangeList newList |
	newChangeList _ OrderedCollection new.
	newList _ OrderedCollection new.

	changeList with: list do: [ :chRec :str |
		(chRec isDoIt not or: [str endsWith: 'initialize'])
			ifTrue: [
				newChangeList add: chRec.
				newList add: str]].
	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list.

	! !
!ChangeList methodsFor: 'menu actions' stamp: 'HAW 9/4/2017 10:26:50' prior: 16796515!
                               selectRemovalsOfSent
	"Selects all method removal for sent methods"

	1 to: changeList size do: [ :i | | change |
		change _ changeList at: i.
		listSelections at: i put:
			(change isDoIt and: [
				change string includesSubString: 'removeSelector: #' ] and: [
					Smalltalk isThereAReferenceTo: (change string copyAfterLast: $#) asSymbol ]) ].
	self changed: #allSelections.
	self changed: #annotation! !
!ChangeList class methodsFor: 'public access' stamp: 'HAW 9/4/2017 10:32:00' prior: 16796892!
          browseRecentLogOn: origChangesFileName 
	"figure out where the last snapshot or quit was, then browse the recent entries."

	| end done block positions prevBlock |
	origChangesFileName asFileEntry readStreamDo: [ :changesFile |
		positions _ SortedCollection new.
		end _ changesFile size.
		prevBlock _ end.
		block _ end - 1024 max: 0.
		done _ false.
		[ done or: [ positions size > 0 ]]
			whileFalse: [
				changesFile position: block.
				"ignore first fragment"
				changesFile nextChunk.
				[ changesFile position < prevBlock ]
					whileTrue: [
						| pos chunk |
						pos _ changesFile position.
						chunk _ changesFile nextChunk.
						((Smalltalk isQuitRecord: chunk) or: [ Smalltalk isSnapshotRecord: chunk ])
							ifTrue: [ positions add: pos ]].
				block = 0
					ifTrue: [done _ true]
					ifFalse: [
						prevBlock _ block.
						block _ block - 1024 max: 0]].
	].
	positions isEmpty
		ifTrue: [self inform: 'File ' , origChangesFileName , ' does not appear to be a changes file']
		ifFalse: [self browseRecentLogOn: origChangesFileName startingFrom: positions last]! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 9/4/2017 08:46:37' prior: 50361385!
                      snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ ProjectX ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ ProjectX ui ]."
	ProjectX stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	ProjectX spawnNewMorphicProcessFor: (world ifNil: [ PasteUpMorph newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!SystemDictionary methodsFor: 'startup' stamp: 'HAW 9/4/2017 06:14:44' prior: 50335324!
                doStartUp: isARealStartup
	"
	isARealStartup
		true: system is coming up (VM and image just started)
		false: we have just saved an image snapshot, but didn't quit.
	"

	"Here, startup begins!!"
	Cursor normal activateCursor.
	self setGCParameters.
	isARealStartup ifTrue: [
		self clearExternalObjects ].
	self readCommandLineArguments.
	self processStartUpList: isARealStartup.
	isARealStartup ifTrue: [
		self setPlatformPreferences.
		self setStartupStamp.
		self restoreLostChangesIfNecessary ]! !
!ChangeRecord methodsFor: 'initialization' stamp: 'HAW 9/4/2017 10:27:15' prior: 16797438!
              fileIn
	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."
	| s |
	type == #method ifTrue: [
		self changeClass ifNotNil: [ :methodClass |
			methodClass
				compile: self text
				classified: category
				withStamp: stamp
				notifying: nil ]].
	self isDoIt ifTrue: [
		((s _ self string) beginsWith: '----') ifFalse: [ Compiler evaluate: s ]].
	type == #classDefinition ifTrue: [ Compiler evaluate: self string ].
	type == #classComment ifTrue: [
		(Smalltalk at: class asSymbol)
			comment: self text
			stamp: stamp ]! !

SystemDictionary removeSelector: #logSapshot:andQuit:!

SystemDictionary removeSelector: #logSapshot:andQuit:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3168-AidInRecoveringChanges-HernanWilkinson-2017Sep01-13h49m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3168] on 10 September 2017 at 4:47:52 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 9/10/2017 16:44:03'!
                           withNextDo: twoArgBlock
	"Evaluate the block with each element and the one following it.
	For the last element, next is nil
	(1 to: 10) asArray withNextDo: [ :each :next | {each. next} print ]
	#() withNextDo: [ :a :b | {a. b} print ]
	"
	| first previous |
	first _ true.
	self do: [ :each |
		first ifTrue: [
			first _ false ]
		ifFalse: [
			twoArgBlock value: previous value: each ].
		previous _ each ].
	first ifFalse: [
		twoArgBlock value: previous value: nil ]! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 9/10/2017 16:44:25'!
                   withPreviousDo: twoArgBlock
	"Evaluate the block with each element and the one before it.
	For the first element, previous is nil
	(1 to: 10) asArray withPreviousDo: [ :each :previous | {previous. each} print ]
	#() withPreviousDo: [ :a :b | {a. b} print ]
	"
	| previous |
	previous _ nil.
	self do: [ :each |
		twoArgBlock value: each value: previous.
		previous _ each ].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3169-withNextDo-withPreviousDo-JuanVuletich-2017Sep10-16h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3168] on 10 September 2017 at 4:29:09 pm'!

TextAttribute subclass: #TextBackgroundColor
	instanceVariableNames: 'color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!

!classDefinition: #TextBackgroundColor category: #'System-TextAttributes'!
TextAttribute subclass: #TextBackgroundColor
	instanceVariableNames: 'color'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!
!TextBackgroundColor commentStamp: '<historical>' prior: 0!
                A TextBackgroundColor encodes a highlight (background) color change applicable over a given range of text.!

TextBackgroundColor subclass: #ShoutTextBackgroundColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!

!classDefinition: #ShoutTextBackgroundColor category: #'System-TextAttributes'!
TextBackgroundColor subclass: #ShoutTextBackgroundColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-TextAttributes'!
!ShoutTextBackgroundColor commentStamp: '<historical>' prior: 0!
                       Just for code styler (Shout)!

CharacterScanner subclass: #MorphicScanner
	instanceVariableNames: 'canvas lineY foregroundColor defaultColor topLeft ignoreColorChanges backgroundColor '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Text'!

!classDefinition: #MorphicScanner category: #'Graphics-Text'!
CharacterScanner subclass: #MorphicScanner
	instanceVariableNames: 'canvas lineY foregroundColor defaultColor topLeft ignoreColorChanges backgroundColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Text'!
!TextAttribute methodsFor: 'iterating' stamp: 'jmv 9/7/2017 16:45:20'!
                  forTextBackgroundColorDo: aBlock
	"No action is the default"! !
!TextBackgroundColor methodsFor: 'accessing' stamp: 'jmv 9/7/2017 16:41:55'!
                   color
	^ color! !
!TextBackgroundColor methodsFor: 'accessing' stamp: 'jmv 9/7/2017 16:41:55'!
 color: aColor
	color _ aColor! !
!TextBackgroundColor methodsFor: 'comparing' stamp: 'jmv 9/7/2017 16:41:55'!
                  = other
 	self == other ifTrue: [ ^ true ].
	^ (other class == self class) 
		and: [other color = color]! !
!TextBackgroundColor methodsFor: 'comparing' stamp: 'jmv 9/7/2017 16:41:55'!
       hash
	^ color hash! !
!TextBackgroundColor methodsFor: 'printing' stamp: 'jmv 9/7/2017 16:41:55'!
                              printOn: strm
	super printOn: strm.
	strm nextPutAll: ' code: '; print: color! !
!TextBackgroundColor methodsFor: 'scanning' stamp: 'jmv 9/7/2017 16:41:55'!
   dominates: other
	^ other class == self class! !
!TextBackgroundColor methodsFor: 'iterating' stamp: 'jmv 9/7/2017 16:45:12'!
  forTextBackgroundColorDo: aBlock
	aBlock value: color! !
!TextBackgroundColor methodsFor: 'testing' stamp: 'jmv 9/7/2017 16:44:40'!
                            isSet
	"Do not include Color black, as it is the default color."
	^color isTransparent not! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
               black
	^ self new color: Color black! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
     blue
	^ self new color: Color blue! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
       cyan
	^ self new color: Color cyan! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
       gray
	^ self new color: Color gray! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
       green
	^ self new color: Color green! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
     magenta
	^ self new color: Color magenta! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
 red
	^ self new color: Color red! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
         white 
	^ self new color: Color white! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 9/7/2017 16:41:55'!
    yellow
	^ self new color: Color yellow! !
!TextBackgroundColor class methodsFor: 'instance creation' stamp: 'jmv 9/7/2017 16:41:55'!
                           color: aColor
	^ self new color: aColor! !
!ShoutTextBackgroundColor methodsFor: 'testing' stamp: 'jmv 9/7/2017 16:42:03'!
     isForShout
	"True if to be removed from code before styling"
	^true! !
!CharacterScanner methodsFor: 'private' stamp: 'jmv 9/7/2017 17:00:23'!
                 backgroundColor: ignored
	"Overridden in MorphicScanner"! !
!MorphicScanner methodsFor: 'private' stamp: 'jmv 9/7/2017 16:56:38'!
                              backgroundColor: aColor
	backgroundColor _ aColor! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:28:51' prior: 16929486!
                             withAttributeValues: attributes do: aBlock
	"Evaluate aBlock with the values of various attributes that affect text formatting, applied in the correct order
	The order is (each overwriting the previous one)
	1) basic defaults
	2) ParagraphStyleReferene
	3) CharacterStyleReference
	4) TextFontReference
	5) TextEmphasis"

	| paragraphStyle characterStyle familyName pointSize emphasis alignment color backgroundColor |
	paragraphStyle _ nil.
	characterStyle _ nil.
	familyName _ nil.
	pointSize _ nil.
	emphasis _ 0.
	alignment _ 0.
	color _ nil.
	backgroundColor _ nil.
	
	"ParagraphStyle is the first to set several values"
	attributes do: [ :attribute |
		attribute forParagraphStyleReferenceDo: [ :s |
			paragraphStyle _ s.
			familyName _ s familyName.
			pointSize _ s pointSize.
			emphasis _ s emphasis.
			alignment _ s alignment.
			s color ifNotNil: [ :c | color _ c ]]].

	"CharacterStyle, if present, can override font and color"
	attributes do: [ :attribute |
		attribute forCharacterStyleReferenceDo: [ :s |
			characterStyle _ s.
			familyName _ s familyName.
			pointSize _ s pointSize.
			emphasis _ s emphasis.
			s color ifNotNil: [ :c | color _ c ]]].

	"These will not interfere with each other, and all of them take precedence over previous values"
	attributes do: [ :attribute |
		attribute forFontFamilyAndSizeDo: [ :fn :ps | familyName _ fn. pointSize _ ps ].
		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].
		attribute forTextColorDo: [ :c | color _ c ].
		attribute forTextBackgroundColorDo: [ :c | backgroundColor _ c ].
		attribute forTextAlignmentDo: [ :a | alignment _ a ].
	].
	
	"Done. Now evaluate the block."
"change all senders!!!!!!!!!!!!"
	aBlock numArgs = 8 ifTrue: [
		^aBlock valueWithArguments: { familyName. pointSize. emphasis. color. alignment. characterStyle. paragraphStyle. backgroundColor }
		].
	^aBlock valueWithArguments: { familyName. pointSize. emphasis. color. alignment. characterStyle. paragraphStyle }! !
!BitBlt methodsFor: 'accessing' stamp: 'jmv 9/6/2017 20:40:02' prior: 16785548!
             destX: x destY: y width: w height: h
	destX _ x.
	destY _ y.
	width _ w.
	height _ h.! !
!CharacterScanner methodsFor: 'private' stamp: 'jmv 9/7/2017 17:19:12' prior: 16801954!
               setFont
	| attributes |
	"Set the font and other emphasis.
	In fact set actual ParagraphStyle (or nil), alignment, font and emphasis"

	self setActualFont: (text fontAt: lastIndex default: defaultFont).
	attributes _ text attributesAt: lastIndex.
	text
		withAttributeValues: attributes
		do: [ :familyNameInText :pointSizeInText :emphasisInText :colorInText :alignmentInText :characterStyleInText :paragraphStyleInText :backgroundColorInText |
			colorInText ifNotNil: [ self textColor: colorInText ].
			self backgroundColor: backgroundColorInText.
			alignment _ alignmentInText.
			paragraphStyle _ paragraphStyleInText ].
	
	"Hardcoded color for TextAction"
	attributes do: [ :attribute |
		attribute forTextActionInfoDo: [ :info |
			self textColor: TextAction textActionColor ]].

	"Install various parameters from the font."
	spaceWidth _ font widthOf: Character space.
	tabWidth _ (font widthOf: $a) * 3.
	xTable _ font xTable.
	map _ font characterToGlyphMap! !
!CharacterScanner methodsFor: 'private' stamp: 'jmv 9/6/2017 20:40:09' prior: 16801989!
                            textColor: ignored
	"Overridden in MorphicScanner"! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/10/2017 16:28:26' prior: 16877966!
                  displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				tabWidth _ (font widthOf: $a) * 3.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: font baseKern.
		backgroundColor ifNotNil: [
			canvas
				fillRectangle: (lastPos corner: destX @ (line bottom +  textTopLeft y))
				color: backgroundColor ].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !

CharacterScanner subclass: #MorphicScanner
	instanceVariableNames: 'canvas lineY foregroundColor defaultColor topLeft backgroundColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Text'!

!classDefinition: #MorphicScanner category: #'Graphics-Text'!
CharacterScanner subclass: #MorphicScanner
	instanceVariableNames: 'canvas lineY foregroundColor defaultColor topLeft backgroundColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Text'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3170-TextBackgroundColor-JuanVuletich-2017Sep10-16h23m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3168] on 10 September 2017 at 4:36:05 pm'!
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:32:21' prior: 16929265!
 alignmentAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ alignment ]! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:17' prior: 16929295!
                  characterStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ characterStyle ]! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:23' prior: 16929304!
   characterStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		^characterStyle ]! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:30' prior: 16929363!
           emphasisAt: characterIndex
	"Answer the emphasis for characters in the run beginning at characterIndex."

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ emphasis ]! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:36' prior: 16929398!
      fontIfApplying: textAttributes default: defaultFont
	"Answer the font for characters as specified by the argument."

	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		^((AbstractFont familyName: familyName pointSize: pointSize) ifNil: [ defaultFont baseFont ])
			emphasized: emphasis ]! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:42' prior: 16929443!
          paragraphStyleOrNilAt: characterIndex

	self
		withAttributeValues: (self attributesAt: characterIndex)
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^ paragraphStyle ]! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:33:48' prior: 16929452!
   paragraphStyleOrNilIfApplying: textAttributes
	"Answer the ParagraphStyle for characters as specified by the argument."
	
	self
		withAttributeValues: textAttributes
		do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
			^paragraphStyle ]! !
!Text methodsFor: 'emphasis' stamp: 'jmv 9/10/2017 16:34:25' prior: 50370242!
      withAttributeValues: attributes do: aBlock
	"Evaluate aBlock with the values of various attributes that affect text formatting, applied in the correct order
	The order is (each overwriting the previous one)
	1) basic defaults
	2) ParagraphStyleReferene
	3) CharacterStyleReference
	4) TextFontReference
	5) TextEmphasis"

	| paragraphStyle characterStyle familyName pointSize emphasis alignment color backgroundColor |
	paragraphStyle _ nil.
	characterStyle _ nil.
	familyName _ nil.
	pointSize _ nil.
	emphasis _ 0.
	alignment _ 0.
	color _ nil.
	backgroundColor _ nil.
	
	"ParagraphStyle is the first to set several values"
	attributes do: [ :attribute |
		attribute forParagraphStyleReferenceDo: [ :s |
			paragraphStyle _ s.
			familyName _ s familyName.
			pointSize _ s pointSize.
			emphasis _ s emphasis.
			alignment _ s alignment.
			s color ifNotNil: [ :c | color _ c ]]].

	"CharacterStyle, if present, can override font and color"
	attributes do: [ :attribute |
		attribute forCharacterStyleReferenceDo: [ :s |
			characterStyle _ s.
			familyName _ s familyName.
			pointSize _ s pointSize.
			emphasis _ s emphasis.
			s color ifNotNil: [ :c | color _ c ]]].

	"These will not interfere with each other, and all of them take precedence over previous values"
	attributes do: [ :attribute |
		attribute forFontFamilyAndSizeDo: [ :fn :ps | familyName _ fn. pointSize _ ps ].
		attribute forTextEmphasisDo: [ :e | emphasis _ emphasis bitOr: e ].
		attribute forTextColorDo: [ :c | color _ c ].
		attribute forTextBackgroundColorDo: [ :c | backgroundColor _ c ].
		attribute forTextAlignmentDo: [ :a | alignment _ a ].
	].
	
	"Done. Now evaluate the block."
	^aBlock valueWithArguments: { familyName. pointSize. emphasis. color. alignment. characterStyle. paragraphStyle. backgroundColor }! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3171-Cleanup-JuanVuletich-2017Sep10-16h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3168] on 10 September 2017 at 4:45:51 pm'!

Object subclass: #SHRange
	instanceVariableNames: 'start end type blockDepth '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHRange category: #'Tools-Syntax Highlighting'!
Object subclass: #SHRange
	instanceVariableNames: 'start end type blockDepth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!
!Preferences class methodsFor: 'shout' stamp: 'jmv 9/10/2017 16:40:28'!
  highlightBlockNesting
	^ self
		valueOfFlag: #highlightBlockNesting
		ifAbsent: [true]! !
!SHRange methodsFor: 'accessing' stamp: 'jmv 9/6/2017 20:25:10'!
     blockDepth
	^blockDepth! !
!SHRange methodsFor: 'accessing' stamp: 'jmv 9/6/2017 20:22:45'!
    blockDepth: anInteger
	blockDepth := anInteger! !
!SHParserST80 methodsFor: 'recording ranges' stamp: 'jmv 9/9/2017 15:21:28' prior: 16902916!
                 rangeType: aSymbol start: s end: e 
	^ranges add: ((SHRange start: s end: e type: aSymbol) blockDepth: blockDepth)! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/10/2017 16:41:27' prior: 50335086!
                 setAttributesFromRanges: ranges

	| alpha start end |
	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges withNextDo: [ :range :nextRangeOrNil |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		Preferences highlightBlockNesting ifTrue: [
			alpha _ range blockDepth / 16.0 min: 0.5.
			start _ range start.
			end _ nextRangeOrNil ifNotNil: [ nextRangeOrNil start - 1 ] ifNil: [ range end ].
			formattedText 
				addAttribute: (ShoutTextBackgroundColor 
				color: (Theme current text alpha: alpha) ) from: start to: end ].

		"Show as subscripts if appropriate."
		classOrMetaClass ifNotNil: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]].
				]! !

Object subclass: #SHRange
	instanceVariableNames: 'start end type blockDepth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHRange category: #'Tools-Syntax Highlighting'!
Object subclass: #SHRange
	instanceVariableNames: 'start end type blockDepth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3172-ShoutShowBlockDepth-JuanVuletich-2017Sep10-16h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3168] on 9 September 2017 at 12:15:04 pm'!
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/9/2017 12:09:32' prior: 50369680!
   hasToRestoreChanges

	^Preferences checkLostChangesOnStartUp and: [ 
		self withChangesFileDo: [ :changesFile | self hasToRestoreChangesFrom: changesFile ]].
	! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/9/2017 12:09:46' prior: 50369689!
              hasToRestoreChangesFrom: changesFile

	| chunk  |
	
	changesFile position: self lastQuitLogPosition.
	[ changesFile atEnd ] whileFalse: [ chunk := changesFile nextChunk ].
	
	^(self isSnapshotQuitOrQuitNoSaveRecord: chunk) not
! !
!Preferences class methodsFor: 'start up' stamp: 'HAW 9/9/2017 12:07:37'!
               checkLostChangesOnStartUp
	^ self
		valueOfFlag: #checkLostChangesOnStartUp
		ifAbsent: [ true ].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3173-RestoreLostChangesPreference-HernanWilkinson-2017Sep09-12h03m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3161] on 6 September 2017 at 8:02:36 pm'!
!ChangeList class methodsFor: 'public access' stamp: 'HAW 9/6/2017 19:58:01'!
                         browseFrom: startPosition on: aChangesFileName labeled: aLabel
	
	"
	ChangeList browseFrom: Smalltalk lastQuitLogPosition on: Smalltalk currentChangesName labeled: 'Lost changes'
	"
	
	| changeList end |

	aChangesFileName asFileEntry readStreamDo: [ :changesFile |
		end _ changesFile size.
		changeList _ self new
			scanFile: changesFile
			from: startPosition 
			to: end.
	].

	ChangeListWindow open: changeList label: aLabel! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'HAW 9/6/2017 19:59:40' prior: 50369776!
                               restoreLostChangesManually

	ChangeList browseFrom: LastQuitLogPosition on: self currentChangesName labeled: 'Lost changes'
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3174-RestoreChangesOnlySinceLastSnapshot-HernanWilkinson-2017Sep04-16h55m-HAW.1.cs.st----!

----SNAPSHOT----#(10 September 2017 6:05:40.130169 pm) Cuis5.0-3174-v3.image priorSource: 1202284!

----QUIT----#(10 September 2017 6:06:01.832791 pm) Cuis5.0-3174-v3.image priorSource: 1252284!

----STARTUP----#(18 September 2017 11:06:38.653242 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3174-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3138] on 29 July 2017 at 10:49:50 pm'!
!Dictionary class methodsFor: 'instance creation' stamp: 'pb 7/29/2017 22:47:17' prior: 16833878!
            newFrom: aDict 
	"Answer an instance of me containing the same associations as aDict.
	 Error if any key appears twice."
	| newDictionary |
	newDictionary _ self new: aDict size.
	aDict associationsDo:
		[:x |
		(newDictionary includesKey: x key)
			ifTrue: [self error: 'Duplicate key: ', x key printString]
			ifFalse: [newDictionary add: x copy]].
	^ newDictionary

"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}
	{1->#a. 2->#b. 3->#c} as: NewDictionary
	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}
	{1->#a. 2->#b. 1->#c} as: NewDictionary
"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3175-Dictionary-newFrom-compatibility-with-Squeak-PhilBellalouna-2017Jul29-22h47m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3163] on 31 August 2017 at 5:46:33 am'!
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'pb 8/31/2017 05:46:22' prior: 16853225!
                  arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self getSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection - 1 max: 1 ]].
		^ true ].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		WorldState addDeferredUIMessage: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3176-HierarchicalListMorph-keyboard-navigation-wrapping-PhilBellalouna-2017Aug31-05h46m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3168] on 9 September 2017 at 3:07:54 am'!
!BraceNode methodsFor: 'as yet unclassified' stamp: 'pb 9/9/2017 03:05:08'!
                   isComplex
	^ true.! !
!BraceNode methodsFor: 'printing' stamp: 'pb 9/9/2017 03:05:21' prior: 16791076!
                         printOn: aStream indent: level
	| isComplex useLevel |
	useLevel := level.
	isComplex := elements anySatisfy: [ :ea |
		ea isComplex ].
	isComplex ifTrue: [ useLevel := useLevel + 1 ].
	aStream nextPut: ${.
	1
		to: elements size
		do: [ :i |
			isComplex ifTrue: [ aStream newLineTab: (1 max: useLevel) ].
			(elements at: i)
				printOn: aStream
				indent: useLevel.
			i < elements size ifTrue: [ aStream nextPutAll: '. ' ]].
	isComplex ifTrue: [ aStream newLineTab: (1 max: level) ].
	aStream nextPut: $}.! !
!LiteralNode methodsFor: 'printing' stamp: 'pb 9/9/2017 03:06:57' prior: 50334837!
           printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea storeOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key storeOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3177-PrettyPrint-complex-arrays-PhilBellalouna-2017Sep09-03h05m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3168] on 9 September 2017 at 12:50:57 am'!
!FileList commentStamp: '<historical>' prior: 16842300!
                           I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.

The FileList provides a dynamic extension mechanism.  To extend FileList functionality, tools should implement the following class-side method (look for implementors in the image):

#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)

This method returns a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.

The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3178-FileList-class-comment-PhilBellalouna-2017Sep09-00h27m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3174] on 13 September 2017 at 3:48:54 pm'!
!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'HAW 9/13/2017 15:16:19'!
           classImplementingSelector

	^class ! !
!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'HAW 9/13/2017 15:15:44'!
     selector

	^selector ! !
!UndeclaredVariableWarning methodsFor: 'accessing' stamp: 'HAW 9/13/2017 15:15:34'!
                   variableName

	^name ! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3179-UndeclaredVariableWarning-accessors-HernanWilkinson-2017Sep11-18h54m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3179] on 15 September 2017 at 3:38:52 pm'!

Object subclass: #SHRange
	instanceVariableNames: 'start end type blockDepth '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHRange category: #'Tools-Syntax Highlighting'!
Object subclass: #SHRange
	instanceVariableNames: 'start end type blockDepth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!
!SHParserST80 methodsFor: 'recording ranges' stamp: 'tween 4/28/2004 10:20' prior: 50370633!
rangeType: aSymbol start: s end: e 
	^ranges add: (SHRange start: s end: e type: aSymbol)! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 12/30/2016 11:44:19' prior: 50370640!
         setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		classOrMetaClass ifNotNil: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]]! !

SHRange removeSelector: #blockDepth!

SHRange removeSelector: #blockDepth!

SHRange removeSelector: #blockDepth:!

SHRange removeSelector: #blockDepth:!

Object subclass: #SHRange
	instanceVariableNames: 'start end type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHRange category: #'Tools-Syntax Highlighting'!
Object subclass: #SHRange
	instanceVariableNames: 'start end type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3180-goBackWith-3172-JuanVuletich-2017Sep15-15h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3180] on 17 September 2017 at 9:22:40 pm'!

Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepthsStartIndexes blockDepths '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHParserST80 category: #'Tools-Syntax Highlighting'!
Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepthsStartIndexes blockDepths'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!
!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 9/13/2017 22:00:57'!
 blockDepths
	^blockDepths! !
!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 9/13/2017 22:01:05'!
                            blockDepthsStartIndexes
	^blockDepthsStartIndexes! !
!SHParserST80 methodsFor: 'accessing' stamp: 'jmv 9/13/2017 20:51:24'!
    ranges
	^ ranges! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/17/2017 18:29:22'!
   parseSetWorkspace: aBoolean
	"Answer a collection of SHRanges by parsing aText.
	When formatting it is not necessary to set the workspace, and this can make the parse take less time, so aBoolean specifies whether the parser should be given the workspace"

	parser ifNil: [parser _ SHParserST80 new].
	parser 
		workspace: (aBoolean ifTrue: [workspace]);
		classOrMetaClass: classOrMetaClass;
		source: formattedText asString.
	parser parse! !
!SHParserST80 methodsFor: 'parse support' stamp: 'jmv 9/17/2017 19:04:26' prior: 16901977!
          enterBlock
	blockDepth _ blockDepth + 1.
	bracketDepth _ bracketDepth + 1.
	blockDepths add: blockDepth.
	blockDepthsStartIndexes add: sourcePosition-1! !
!SHParserST80 methodsFor: 'parse support' stamp: 'jmv 9/17/2017 19:02:56' prior: 16901989!
          leaveBlock
	arguments removeKey: blockDepth ifAbsent: nil.
	temporaries removeKey: blockDepth ifAbsent: nil.
	blockDepth _ blockDepth - 1.
	bracketDepth _ bracketDepth - 1.
	blockDepths add: blockDepth.
	blockDepthsStartIndexes add: sourcePosition! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/17/2017 19:03:23' prior: 16902395!
                  parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth := 0.
	blockDepths _ OrderedCollection with: blockDepth.
	blockDepthsStartIndexes _ OrderedCollection with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollection new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		self parseStatementList.
		currentToken ifNotNil: [self error]
	] ensure: [errorBlock _ nil].
	^true! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/17/2017 19:05:25' prior: 50335035!
                       parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self leaveBlock.
	self scanPast: #backtick! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/17/2017 18:40:55' prior: 16902449!
                               parseBlock
	self enterBlock.
	self scanPast: #blockStart level: bracketDepth.
	currentTokenFirst == $: ifTrue: [self parseBlockArguments].
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $].
	self leaveBlock.
	self scanPast: #blockEnd level: bracketDepth.! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/17/2017 21:20:07' prior: 16903299!
                    privateStyle

	| alpha end start count startIndexes |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	Preferences highlightBlockNesting ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 16.0 min: 0.5.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor 
				color: (Theme current text alpha: alpha) ) from: start to: end ]]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/17/2017 18:30:50' prior: 16903322!
                replaceStringForRangesWithType: aSymbol with: aString
	"Answer aText if no replacements, or a copy of aText with 
	each range with a type of aSymbol replaced by aString"
	| toReplace increaseInLength |

	"We don't handle format and conversion for debuggers"
	disableFormatAndConvert ifTrue: [ ^self ].

	self parseSetWorkspace: false.
	toReplace _ parser ranges select: [ :each |
		each rangeType = aSymbol ].
	toReplace isEmpty ifTrue: [ ^self ].
	increaseInLength := 0.

	(toReplace asArray sort: [ :a :b | a start <= b start ]) 
		do: [ :each | | end start thisIncrease | 
			start := each start + increaseInLength.
			end := each end + increaseInLength.
			formattedText replaceFrom: start to: end with: aString.
			thisIncrease := aString size - each length.
			increaseInLength := increaseInLength + thisIncrease ]! !

SHTextStylerST80 removeSelector: #rangesSetWorkspace:!

SHTextStylerST80 removeSelector: #rangesSetWorkspace:!

SHParserST80 removeSelector: #rangesIn:classOrMetaClass:workspace:!

SHParserST80 removeSelector: #rangesIn:classOrMetaClass:workspace:!

Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepths blockDepthsStartIndexes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHParserST80 category: #'Tools-Syntax Highlighting'!
Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepths blockDepthsStartIndexes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3181-ShoutShowsBlockDepth-Take2-JuanVuletich-2017Sep17-21h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3180] on 17 September 2017 at 9:29:15 pm'!
!Preferences class methodsFor: 'shout' stamp: 'jmv 9/17/2017 21:27:39'!
            backgroundColorFillsAllBackground
	"I.e. do fill all whitespace (tabs and space at right of end of text) with backgroundColor"
	^ self
		valueOfFlag: #backgroundColorFillsAllBackground
		ifAbsent: [true]! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/17/2017 21:27:43' prior: 50370352!
                         displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos x1 |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				tabWidth _ (font widthOf: $a) * 3.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: font baseKern.
		backgroundColor ifNotNil: [
			x1 _ destX.
			(Preferences backgroundColorFillsAllBackground and: [startIndex > line last]) ifTrue: [
				x1 _ rightMargin ].
			canvas
				fillRectangle: (lastPos corner: x1 @ (line bottom + textTopLeft y))
				color: backgroundColor.
			(Preferences backgroundColorFillsAllBackground and: [stopCondition = #tab]) ifTrue: [
				canvas
					fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
					color: backgroundColor ]].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3182-BlockHighlightFillAllBackground-JuanVuletich-2017Sep17-21h22m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3174] on 13 September 2017 at 6:23:32 am'!
!DateAndTime methodsFor: 'private' stamp: 'pb 9/13/2017 06:17:35'!
 subtractDateAndtime: operand
	"operand is a DateAndTime or a Duration"

	| lvalue rvalue |
	offset = operand offset
		ifTrue: [
			lvalue _ self.
			rvalue _ operand ]
		ifFalse: [
			lvalue _ self asUTC.
			rvalue _ operand asUTC ].
	^ Duration
		seconds: (Time secondsInDay *(lvalue julianDayNumber - rvalue julianDayNumber)) + 
					(lvalue secondsSinceMidnight - rvalue secondsSinceMidnight)
		nanoSeconds: lvalue nanoSecond - rvalue nanoSecond! !
!DateAndTime methodsFor: 'private' stamp: 'pb 9/13/2017 06:17:41'!
                         subtractDuration: operand
	"operand is a DateAndTime or a Duration"

	^self + operand negated! !
!DateAndTime methodsFor: 'double dispatching' stamp: 'pb 9/13/2017 06:20:33'!
                 subtractFrom: aDateAndTime

	^ aDateAndTime subtractDateAndtime: self! !
!Duration methodsFor: 'double dispatching' stamp: 'pb 9/13/2017 06:21:11'!
            subtractFrom: aDateAndTimeOrDate

	^aDateAndTimeOrDate subtractDuration: self! !
!Timespan methodsFor: 'private' stamp: 'pb 9/13/2017 06:18:08'!
               subtractDuration: aDuration

	^self class classDefinesDuration
		ifTrue: [ self class including: start - aDuration ]
		ifFalse: [ self class starting: start - aDuration duration: duration ]! !
!Timespan methodsFor: 'private' stamp: 'pb 9/13/2017 06:19:33'!
                               subtractTimespan: aTimespan
	^self start subtractDateAndtime: aTimespan start! !
!Timespan methodsFor: 'double dispatching' stamp: 'pb 9/13/2017 06:21:26'!
    subtractFrom: aTimespan

	^ aTimespan subtractTimespan: self! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'pb 9/13/2017 06:20:43' prior: 50342669!
       - operand
	"operand is a DateAndTime or a Duration.
	Double dispatch"

	^ operand subtractFrom: self! !
!Timespan methodsFor: 'ansi protocol' stamp: 'pb 9/13/2017 06:20:49' prior: 50342675!
  - aDurationOrTimespan

	^ aDurationOrTimespan subtractFrom: self! !
!ScrollBar methodsFor: 'geometry' stamp: 'pb 9/13/2017 06:22:10' prior: 16904581!
          freeSliderRoom
	"Answer the length or height of the free slider area, i.e. subtract the slider itself.
	If we are really too short of room, lie a little bit. Answering at least 4, even when the
	free space might be actually negative, makes the scrollbar somewhat usable."

	| buttonsRoom |
	buttonsRoom _ Theme current minimalWindows ifTrue: [0] ifFalse: [self buttonExtent * 2].
	^ ((self isHorizontal
		ifTrue: [ extent x - slider morphWidth]
		ifFalse: [ extent y - slider morphHeight])
			- (borderWidth * 2) - buttonsRoom) max: 4! !

Timespan removeSelector: #substractDuration:!

Timespan removeSelector: #substractDuration:!

Timespan removeSelector: #substractFrom:!

Timespan removeSelector: #substractFrom:!

Timespan removeSelector: #substractTimespan:!

Timespan removeSelector: #substractTimespan:!

Duration removeSelector: #substractFrom:!

Duration removeSelector: #substractFrom:!

DateAndTime removeSelector: #substractDateAndtime:!

DateAndTime removeSelector: #substractDateAndtime:!

DateAndTime removeSelector: #substractDuration:!

DateAndTime removeSelector: #substractDuration:!

DateAndTime removeSelector: #substractFrom:!

DateAndTime removeSelector: #substractFrom:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3183-fix-typos-and-remove-Timespan-error-message-PhilBellalouna-2017Sep13-06h16m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3183] on 18 September 2017 at 6:29:35 pm'!
!Timespan methodsFor: 'private' stamp: 'jmv 9/18/2017 18:27:11'!
                 subtractMonth: aYear

	^ self subtractTimespan: aYear! !
!Timespan methodsFor: 'private' stamp: 'jmv 9/18/2017 17:22:56'!
      subtractYear: aYear

	^ self subtractTimespan: aYear! !
!Month methodsFor: 'double dispatching' stamp: 'jmv 9/18/2017 18:26:57'!
                               subtractFrom: aTimespan

	^ aTimespan subtractMonth: self! !
!Month methodsFor: 'double dispatching' stamp: 'jmv 9/18/2017 18:26:44'!
                          subtractMonth: aMonth
	"Months can be subtracted even they have different length."

	^self start subtractDateAndtime: aMonth start! !
!Year methodsFor: 'double displatching' stamp: 'jmv 9/18/2017 17:23:04'!
                 subtractFrom: aTimespan

	^ aTimespan subtractYear: self! !
!Year methodsFor: 'double displatching' stamp: 'jmv 9/18/2017 17:24:41'!
                           subtractYear: aYear
	"Years can be subtracted even if one of them is leap and the other isn't."

	^self start subtractDateAndtime: aYear start! !
!Timespan methodsFor: 'private' stamp: 'jmv 9/18/2017 18:29:20' prior: 50371487!
                             subtractTimespan: aTimespan
	"
	(Month month: 'March' year: 2017) - (Month month: 'January' year: 2017)
	(Month month: 'February' year: 2017) - (Month month: 'January' year: 2017)

	(Year yearNumber: 2016) - (Year yearNumber: 2015).
	(Year yearNumber: 2017) - (Year yearNumber: 2016).
	(Year yearNumber: 2017) - (Year yearNumber: 2015).

	(Year yearNumber: 2018) - (Date today). 					'Error'.
	"
	aTimespan duration = self duration ifFalse: [
		self error: 'Can not subtract Timespans of different duration' ].
	
	^self start subtractDateAndtime: aTimespan start! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3184-AddTimespanErrorMessageBack-JuanVuletich-2017Sep18-18h25m-jmv.1.cs.st----!

----SNAPSHOT----#(18 September 2017 11:06:50.303544 pm) Cuis5.0-3184-v3.image priorSource: 1252384!

----QUIT----#(18 September 2017 11:07:10.670677 pm) Cuis5.0-3184-v3.image priorSource: 1278855!

----STARTUP----#(24 September 2017 10:19:14.559677 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3184-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3184] on 19 September 2017 at 10:18:24 pm'!
!Number methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:48:57'!
                            withBinaryUnitPrefixAndValue: aBlock
	"
	As in https://en.wikipedia.org/wiki/Binary_prefix
	{ 0.123456. 1.23456. 12.3456. 123.456. 1234.56. 12345.6. 123456. 1234560. 12345600 } do: [ :n | n withBinaryUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName | {value printString, ' ', unitPrefixSymbol. unitPrefixName} print]]
	"
	| prefixIndex factor nameAndSymbol |
	prefixIndex _ self log floor // 3.
	prefixIndex _ prefixIndex min: 8 max: 0.
	factor _ 1024 raisedToInteger: prefixIndex.
	nameAndSymbol _ {
		{''. ''}.
		{'kibi'.		'Ki'}.
		{'mebi'.	'Mi'}.
		{'gibi'.		'Gi'}.
		{'tebi'.		'Ti'}.
		{'pebi'.	'Pi'}.
		{'exbi'.	'Ei'}.
		{'zebi'.	'Zi'}.
		{'yobi'.	'Yi'}
	} at: prefixIndex+1.
	aBlock value: (self / factor) asIntegerOrFloat value: nameAndSymbol second value: nameAndSymbol first! !
!Number methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:48:12'!
                              withDecimalUnitPrefixAndValue: aBlock
	"
	As in https://en.wikipedia.org/wiki/Metric_prefix
	{ 0.00000123456. 0.0000123456. 0.000123456. 0.00123456. 0.0123456. 0.123456. 1.23456. 12.3456. 123.456. 1234.56. 12345.6. 123456. 1234560. 12345600 } do: [ :n | n withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName | {value printString, ' ', unitPrefixSymbol. unitPrefixName} print]]
	"
	| prefixIndex factor nameAndSymbol |
	prefixIndex _ self log floor // 3.
	prefixIndex _ prefixIndex min: 6 max: -6.
	factor _ 1000 raisedToInteger: prefixIndex.
	nameAndSymbol _ {
		{'atto'.	'a'}.
		{'femto'.	'f'}.
		{'pico'.	'p'}.
		{'nano'.	'n'}.
		{'micro'.	''}.
		{'milli'.		'm'}.
		{''. ''}.
		{'kilo'.		'k'}.
		{'mega'.	'M'}.
		{'giga'.	'G'}.
		{'tera'.	'T'}.
		{'peta'.	'P'}.
		{'exa'.		'E'}
	} at: prefixIndex+7.
	aBlock value: self asFloat / factor value: nameAndSymbol second value: nameAndSymbol first! !
!Integer methodsFor: 'benchmarks' stamp: 'jmv 9/19/2017 21:59:09' prior: 50343298!
                    tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		RasPi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec
		
		RasPi3B - StackSpur 								44,107,512 bytecodes/sec; 			2,767,863 sends/sec
		RasPi3B - CogSpur 							    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		2.70GHz Core i5-6400 -CogSpur64 		3,162,934,362 bytecodes/sec; 		243,321,293 sends/sec
	
		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue: [n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue: [n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^String streamContents: [ :strm |
		(n1 * 500000 * 1000) // t1 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Bytecodes/second; ' ].
		(r * 1000) // t2 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Sends/second' ]]! !
!Integer methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:42:27' prior: 16860030!
       printStringAsBytes
	"Answer a terse, easily-readable representation of this Integer reprsenting a number of bytes.  Useful for file-browsers.
	123 printStringAsBytes
	1024 printStringAsBytes
	(12*1024) printStringAsBytes
	(1024*1024) printStringAsBytes
	(1024*1024*1024) printStringAsBytes
	(1024*1024*1024*1024) printStringAsBytes
	(30 factorial) printStringAsBytes
	
	See https://en.wikipedia.org/wiki/Kibibyte
	See #printStringAsBytesDecimal
	"
	self withBinaryUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
		^String streamContents: [ :strm |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixSymbol;
				nextPut: $B]]! !
!Integer methodsFor: 'printing' stamp: 'jmv 9/19/2017 21:48:23' prior: 16860061!
     printStringAsBytesDecimal
	"Answer a terse, easily-readable representation of this Integer reprsenting a number of bytes.  Useful for file-browsers.
	123 printStringAsBytesDecimal
	(12*1000) printStringAsBytesDecimal
	(1000*1000) printStringAsBytesDecimal
	
	1024 printStringAsBytesDecimal
	(12*1024) printStringAsBytesDecimal
	(1024*1024) printStringAsBytesDecimal
	(1024*1024*1024) printStringAsBytesDecimal
	(1024*1024*1024*1024) printStringAsBytesDecimal
	(30 factorial) printStringAsBytesDecimal
	
	See https://en.wikipedia.org/wiki/Kibibyte
	See #printStringAsBytes
	"
	self withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
		^String streamContents: [ :strm |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixSymbol;
				nextPut: $B]]! !
!BlockClosure methodsFor: 'evaluating' stamp: 'jmv 9/19/2017 22:16:51' prior: 16787838!
                              bench
	"See how many times I can value in 5 seconds.  I'll answer a meaningful description.
	[ Float pi printString ] bench print.
	[ 80000 factorial printString ] bench print.
	"

	| startTime endTime count run |
	count _ 0.
	run _ true.
	[ (Delay forSeconds: 5) wait. run _ false ] forkAt: Processor timingPriority - 1.
	startTime _ Time localMillisecondClock.
	[ run ] whileTrue: [ self value. count _ count + 1 ].
	endTime _ Time localMillisecondClock.
	count = 1
		ifTrue: [
			(endTime - startTime) / 1000 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' seconds per run']]
			]
		ifFalse: [
			(count * 1000) / (endTime - startTime) withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
				^String streamContents: [ :strm |
					value printOn: strm fractionDigits: 2.
					strm
						space;
						nextPutAll: unitPrefixSymbol;
						nextPutAll: ' runs per second' ]]
			]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3185-benchImprovements-NumberUnitprefixPrint-JuanVuletich-2017Sep19-20h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3185] on 19 September 2017 at 10:42:44 pm'!
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 9/19/2017 22:40:08' prior: 50371238!
  privateStyle

	| alpha end start count startIndexes c hue |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	Preferences highlightBlockNesting ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 10.0 min: 1.0.
			hue _ depth * 60.
			c _ Color h: hue s: 0.2 v: 0.5 alpha: alpha.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor 
				color: c ) from: start to: end ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3186-BlockNestingHighlightWithColor-JuanVuletich-2017Sep19-22h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3186] on 24 September 2017 at 10:13:16 pm'!
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 9/24/2017 20:34:05'!
         shortUnderscore
	"Answer the Character representing very short (or invisible) underscore.
	Used to optionally mark subscript in code."

	^ Character numericValue: 127! !
!Character class methodsFor: 'accessing mathematical symbols' stamp: 'jmv 9/24/2017 20:13:24' prior: 16801432!
       infinity
	"
	Character infinity
	"
	^ $! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:08:45' prior: 16914742!
  makeCrInvisible
	| glyph |
	glyph _ self glyphAt: Character cr.
	glyph fillWhite.
	self glyphAt: Character cr put: glyph! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:07:50' prior: 50359147!
                  makeCrVisible
	| glyph |
	glyph _ self glyphAt: (Character numericValue: 182).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: Character cr put: glyph! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:09:18' prior: 16914761!
                          makeLfInvisible
	| glyph |
	glyph _ self glyphAt: Character lf.
	glyph fillWhite.
	self glyphAt: Character lf put: glyph! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 22:07:44' prior: 50359159!
                  makeLfVisible
	| glyph |
	glyph _ self glyphAt: (Character numericValue: 163).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: Character lf put: glyph! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/24/2017 20:24:03' prior: 16914780!
                          makeTabInvisible
	self characterToGlyphMap.
	characterToGlyphMap at: 10 put: (10 < minAscii ifFalse: [10] ifTrue: [maxAscii+1])! !
!StrikeFont methodsFor: 'building' stamp: 'jmv 9/24/2017 20:49:47' prior: 16914852!
         buildFromForm: allGlyphs data: data name: aString

	| x shortUnderscore firstGlyphInFiles |
	pointSize _ data first asNumber.
	ascent _ data second asNumber.
	descent _ data third asNumber.

	firstGlyphInFiles _ 257-(data size-3).
	minAscii _ 1.
	maxAscii _ 255.
	name _ aString.
	type _ 0.  "ignored for now"
	superscript _ ascent - descent // 3.	
	subscript _ descent - ascent // 3.	
	emphasis _ 0.

	xTable _ (Array new: 258) atAllPut: 0.
	maxWidth _ 0.
	glyphs _ allGlyphs depth > 16 ifTrue: [ allGlyphs asFormOfDepth: 16 ] ifFalse: [ allGlyphs ].
	x _ 0.
	4 to: data size do: [ :i |
		x _ (data at: i) asNumber.
		xTable at: i+firstGlyphInFiles+1-4 put: x].
	xTable at: 258 put: x.
	self reset.
	derivativeFonts _ nil.

	self makeCrVisible.

	"Replace glyph for 127 (a box) with a short version of the underscore (used to optionally mark subscript in code)"
	shortUnderscore _ self glyphAt: $_.
	shortUnderscore _ shortUnderscore copy: (0@0 extent: 1@shortUnderscore height).
	self glyphAt: (Character numericValue: 127) put: shortUnderscore! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 9/24/2017 20:08:30' prior: 16915044!
   create: fontName size: pointSize bold: includeBold italic: includeItalic boldItalic: includeBoldItalic
	"
	self create: 'DejaVu Sans Mono' size: 12 bold: true italic: true boldItalic: true
	"
	| folder basename base bold oblique boldOblique point |
	folder _ DirectoryEntry smalltalkImageDirectory / 'AdditionalFontData'.
	basename _ fontName = 'DejaVu' ifTrue: ['DejaVu Sans'] ifFalse: [fontName].
	point _ pointSize asString.
	base _ [ (StrikeFont new
		buildFromForm: ((Form fromFileEntry: folder // (basename, '-0-', point, '.bmp')) asFormOfDepth: 16)
		data: (folder // (basename, '-0-', point, '.txt')) fileContents substrings
		name: fontName, ' ', point)
			pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ].
	includeBold ifTrue: [
		bold _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (basename, '-1-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (basename, '-1-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'B')
				emphasis: 1;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	includeItalic ifTrue: [
		oblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (basename, '-2-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (basename, '-2-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'I')
				emphasis: 2;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	includeBoldItalic ifTrue: [
		boldOblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (basename, '-3-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (basename, '-3-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'BI')
				emphasis: 3;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	"We have a regular, base font. Make others derivatives of it"
	base ifNotNil: [
		bold ifNotNil: [
			base derivativeFont: bold at: 1 ].
		oblique ifNotNil: [
			base derivativeFont: oblique at: 2].
		boldOblique ifNotNil: [
			base derivativeFont: boldOblique at: 3 ].
		^base ].
	"We don't have a base, regular font."
	oblique ifNotNil: [
		oblique emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		bold ifNotNil: [
			oblique derivativeFont: bold at: 1 ].
		boldOblique ifNotNil: [
			oblique derivativeFont: boldOblique at: 3 ].
		^oblique ].
	bold ifNotNil: [
		bold emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		boldOblique ifNotNil: [
			bold derivativeFont: boldOblique at: 3 ].
		^bold ].
	boldOblique ifNotNil: [
		^boldOblique ].
	^nil! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 9/24/2017 20:15:42' prior: 16915129!
  install: aString
"
StrikeFont install: 'DejaVu'.
StrikeFont buildLargerPunctuation: 'DejaVu'.
Character initialize

StrikeFont install: 'DejaVu Sans Mono'.
StrikeFont buildLargerPunctuation: 'DejaVu Sans Mono'.
Character initialize
"
"
StrikeFont install: 'Inconsolata'
StrikeFont install: '#PilGi'
StrikeFont install: 'Optima'
StrikeFont install: 'Herculanum'
StrikeFont install: 'Papyrus'
StrikeFont install: 'Handwriting - Dakota'
StrikeFont install: 'Times New Roman'
StrikeFont install: 'Apple Chancery'
StrikeFont install: 'Cochin'
StrikeFont install: 'Cracked'
StrikeFont install: 'Zapfino'
StrikeFont install: 'Brush Script MT'
StrikeFont install: 'Chalkboard'
"
	| fontDict |
	fontDict _ Dictionary new.
	#(5 6 7 8 9 10 11 12 14 17 22) do: [ :s |
		(self create: aString size: s bold: true italic: true boldItalic: false) ifNotNil: [ :font |
			fontDict
				at: s
				put: font ]].
	fontDict notEmpty ifTrue: [
		AvailableFonts at: aString put: fontDict ].
	Preferences restoreDefaultFonts! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3187-FontsFixes-JuanVuletich-2017Sep24-22h12m-jmv.1.cs.st----!

StrikeFont install: 'DejaVu'.
StrikeFont buildLargerPunctuation: 'DejaVu'.
Character initialize!

----SNAPSHOT----#(24 September 2017 10:19:32.375884 pm) Cuis5.0-3187-v3.image priorSource: 1278956!

----QUIT----#(24 September 2017 10:19:46.345396 pm) Cuis5.0-3187-v3.image priorSource: 1295660!

----STARTUP----#(24 September 2017 10:28:07.581656 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3187-v3.image!


actualContents edit!

----QUIT----#(24 September 2017 10:28:53.042172 pm) Cuis5.0-3187-v3.image priorSource: 1295761!

----STARTUP----#(1 October 2017 4:33:15.04294 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3187-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3187] on 25 September 2017 at 10:56:05 pm'!
!Preferences class methodsFor: 'fonts' stamp: 'jmv 9/25/2017 20:23:26'!
       defaultFontFamily
	"Answer the default font family name"

	^self parameters at: #defaultFontFamily ifAbsentPut: [ AbstractFont familyNames first ]! !
!Preferences class methodsFor: 'fonts' stamp: 'jmv 9/25/2017 20:33:41'!
  setDefaultFont: fontFamilyName spec: defaultFontsSpec
		
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ AbstractFont familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ AbstractFont default ]. 
		triplet size > 2 ifTrue: [
			font _ font emphasized: triplet third ].
		self
			perform: triplet first
			with: font]! !
!Preferences class methodsFor: 'fonts' stamp: 'jmv 9/25/2017 20:22:40'!
                          setDefaultFontFamilyTo: aString

	self parameters at: #defaultFontFamily put: aString! !
!Preferences class methodsFor: 'fonts' stamp: 'jmv 9/25/2017 20:40:23' prior: 16892936!
               restoreDefaultFonts
	"Since this is called from menus, we can take the opportunity to prompt for missing font styles.
	Preferences restoreDefaultFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9))! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:14' prior: 16893908!
                               bigFonts
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences bigFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 11)
			(setListFontTo: 11)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 11)
			(setButtonFontTo: 11)).
	Preferences enable: #biggerCursors! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:20' prior: 16893923!
                        hugeFonts
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences hugeFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 17)
			(setListFontTo: 17)
			(setMenuFontTo: 17)
			(setWindowTitleFontTo: 22)
			(setCodeFontTo: 17)
			(setButtonFontTo: 17)).
	Preferences enable: #biggerCursors! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:26' prior: 16893939!
            smallFonts
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences smallFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 8)
			(setMenuFontTo: 8)
			(setWindowTitleFontTo: 11)
			(setCodeFontTo: 8)
			(setButtonFontTo: 8)).
	Preferences disable: #biggerCursors! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:30' prior: 16893954!
                         standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9)).
	Preferences disable: #biggerCursors! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:32' prior: 16893970!
              tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 7)
			(setListFontTo: 5)
			(setMenuFontTo: 5)
			(setWindowTitleFontTo: 7)
			(setCodeFontTo: 5)
			(setButtonFontTo: 5)).
	Preferences disable: #biggerCursors! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:36' prior: 16893986!
                  veryBigFonts
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences veryBigFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 14)
			(setListFontTo: 14)
			(setMenuFontTo: 14)
			(setWindowTitleFontTo: 17)
			(setCodeFontTo: 14)
			(setButtonFontTo: 14)).
	Preferences enable: #biggerCursors! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 9/25/2017 20:40:39' prior: 16894002!
      verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences verySmallFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 7)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7)).
	Preferences disable: #biggerCursors! !
!AbstractFont methodsFor: 'displaying' stamp: 'jmv 9/25/2017 20:24:32' prior: 16777361!
   on: aGrafPort displayString: aString from: firstIndex to: lastIndex at: p color: color
	"Answer last affected pixel position
	Answer nil if nothing was done"

	| char fallbackFont x y answer |
	fallbackFont _ (AbstractFont
		familyName: Preferences defaultFontFamily
		aroundPointSize: self pointSize*0.9)
			emphasized: self emphasis.
	x _ p x.
	y _ p y.
	firstIndex to: lastIndex do: [ :i |
		char _ aString at: i.
		answer _ aGrafPort displayString: char asString from: 1 to: 1 at: x@y strikeFont: fallbackFont color: color.
		x _ x + (self widthOf: char) ].
	^answer! !
!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 9/25/2017 20:25:27' prior: 16777395!
                            familyName: aString aroundPointSize: aNumber
	"
	AbstractFont familyName: Preferences defaultFontFamily aroundPointSize: 120
	"
	| familyDictionary found |
	familyDictionary _ AvailableFonts at: aString ifAbsent: [^nil].
	^familyDictionary at: aNumber ifAbsent: [
		familyDictionary do: [ :font |
			(found isNil or: [ (found pointSize - aNumber) abs > (font pointSize - aNumber) abs ])
				ifTrue: [ found _ font ]].
			found
		]! !
!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 9/25/2017 20:25:34' prior: 16777411!
        familyName: aString pointSize: aNumber
	"
	AbstractFont familyName: Preferences defaultFontFamily pointSize: 12
	"
	| familyDictionary |
	familyDictionary _ AvailableFonts at: aString ifAbsent: [^nil].
	^familyDictionary at: aNumber ifAbsent: nil! !
!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 9/25/2017 20:25:58' prior: 16777469!
pointSizesFor: aString
	"
	AbstractFont pointSizesFor: Preferences defaultFontFamily
	"
	| familyDictionary |
	familyDictionary _ AvailableFonts at: aString ifAbsent: [^#()].
	^familyDictionary keys sort! !
!AbstractFont class methodsFor: 'class initialization' stamp: 'jmv 9/25/2017 20:25:47' prior: 16777478!
         initialize
	"AvailableFonts is a dictionary whose keys are family names, such as 'DejaVu Sans' and values are family dictionaries
	family dictionaries have keys that are integers (point sizes such as 10 or 12) and values instances of the Font hierarcy
	
	Fonts with emphasis (such as bold or italic) are derivative fonts of the one found in the family dictionary"
	
	AvailableFonts _ Dictionary new! !
!StrikeFont methodsFor: 'accessing' stamp: 'jmv 9/25/2017 20:45:55' prior: 16914200!
                         baseKern
	"Return the base kern value to be used for all characters.
	What follows is some 'random' text used to visually adjust this method.
	HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH
	HAHBHCHDHEHFHGHHHIHJHKHLHMHNHOHPHQHRHSHTHUHVHWHXHYHXZH
	wok yuyo	wuwu	vuvu	rucu	tucu	WUWU	VUVU	huevo	HUEVO	to
											k y mate	runico ridiculo	ARABICO	AAAAA	TOMATE
	TUTU
	tatadalajafua
	abacadafagahaqawaearatayauaiaoapasadafagahajakalazaxacavabanama
	kUxUxa
	q?d?h?l?t?f?j?"
	
	| italic baseKern |
	italic _ self isItalic.
	
	"Assume synthetic will not affect kerning (i.e. synthetic italics are not used)"
	"After all, DejaVu Sans are the only StrikeFonts used in Cuis..."
"	self familyName = 'DejaVu Sans'
		ifTrue: ["
			baseKern _ (italic or: [ pointSize < 9 ])
				ifTrue: [ -1 ]
				ifFalse: [ 0 ].
			pointSize >= 13 ifTrue: [
				baseKern _ baseKern +1 ].
			pointSize >= 20 ifTrue: [
				baseKern _ baseKern +1 ]"]
		ifFalse: [
			baseKern _ pointSize < 12
				ifTrue: [ -1 ]
				ifFalse: [ 0 ].
			italic ifTrue: [
				baseKern _ baseKern - 1]]".
	
	"If synthetic italic"
	"See makeItalicGlyphs"
	(self isSynthetic and: [ italic and: [ self isBold ]]) ifTrue: [
		baseKern _ baseKern - ((self height-1-self ascent+4)//4 max: 0)  
		- (((self ascent-5+4)//4 max: 0)) ].
	^baseKern! !
!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 9/25/2017 20:44:21' prior: 16914975!
                 syntheticSubscript
	"Build and answer a derivative that is Subscript."

	| derivative |
	derivative _ ((AbstractFont familyName: Preferences defaultFontFamily aroundPointSize: pointSize * 0.58)
		emphasized: emphasis)
			copy.
	derivative useShortUnderscore.
	^ derivative

"
StrikeFont allInstances do: [ :a | a reset ].
('Hi ', (Text string: 'there' attribute: TextEmphasis superscript), ' how ', (Text string: 'are' attribute: TextEmphasis subscript), ' you?') edit.

que todos, menos estos, tengan superscript y subscript en cero. Y en estos, apropiado. y en 'aca' usarlo. y listo
"! !
!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 9/25/2017 20:44:26' prior: 16914996!
                 syntheticSuperscript
	"Build and answer a derivative that is Superscript."

	| derivative |
	derivative _ ((AbstractFont familyName: Preferences defaultFontFamily aroundPointSize: pointSize * 0.58)
		emphasized: emphasis)
			copy.
	derivative name: self name , 'Sup'.
	^ derivative

"
StrikeFont allInstances do: [ :a | a reset ].
('Hi ', (Text string: 'there' attribute: TextEmphasis superscript), ' how ', (Text string: 'are' attribute: TextEmphasis subscript), ' you?') edit.
"! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 9/25/2017 20:17:15' prior: 50372011!
                         create: fontName size: pointSize bold: includeBold italic: includeItalic boldItalic: includeBoldItalic
	"
	self create: 'DejaVu Sans Mono' size: 12 bold: true italic: true boldItalic: true
	"
	| folder base bold oblique boldOblique point |
	folder _ DirectoryEntry smalltalkImageDirectory / 'AdditionalFontData'.
	point _ pointSize asString.
	base _ [ (StrikeFont new
		buildFromForm: ((Form fromFileEntry: folder // (fontName, '-0-', point, '.bmp')) asFormOfDepth: 16)
		data: (folder // (fontName, '-0-', point, '.txt')) fileContents substrings
		name: fontName, ' ', point)
			pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ].
	includeBold ifTrue: [
		bold _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-1-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-1-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'B')
				emphasis: 1;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	includeItalic ifTrue: [
		oblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-2-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-2-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'I')
				emphasis: 2;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	includeBoldItalic ifTrue: [
		boldOblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-3-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-3-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'BI')
				emphasis: 3;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | ex print. nil ]].
	"We have a regular, base font. Make others derivatives of it"
	base ifNotNil: [
		bold ifNotNil: [
			base derivativeFont: bold at: 1 ].
		oblique ifNotNil: [
			base derivativeFont: oblique at: 2].
		boldOblique ifNotNil: [
			base derivativeFont: boldOblique at: 3 ].
		^base ].
	"We don't have a base, regular font."
	oblique ifNotNil: [
		oblique emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		bold ifNotNil: [
			oblique derivativeFont: bold at: 1 ].
		boldOblique ifNotNil: [
			oblique derivativeFont: boldOblique at: 3 ].
		^oblique ].
	bold ifNotNil: [
		bold emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		boldOblique ifNotNil: [
			bold derivativeFont: boldOblique at: 3 ].
		^bold ].
	boldOblique ifNotNil: [
		^boldOblique ].
	^nil! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 9/25/2017 20:48:55' prior: 50372099!
                        install: aString
"
StrikeFont install: 'DejaVu Sans'.
StrikeFont buildLargerPunctuation: 'DejaVu Sans'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans'.
Preferences standardFonts.
Character initialize.
"
"
StrikeFont install: 'DejaVu Sans Mono'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans Mono'.
Preferences bigFonts.
Character initialize.
"
"
StrikeFont install: 'Inconsolata'
StrikeFont install: '#PilGi'
StrikeFont install: 'Optima'
StrikeFont install: 'Herculanum'
StrikeFont install: 'Papyrus'
StrikeFont install: 'Handwriting - Dakota'
StrikeFont install: 'Times New Roman'
StrikeFont install: 'Apple Chancery'
StrikeFont install: 'Cochin'
StrikeFont install: 'Cracked'
StrikeFont install: 'Zapfino'
StrikeFont install: 'Brush Script MT'
StrikeFont install: 'Chalkboard'
"
	| fontDict |
	fontDict _ Dictionary new.
	#(5 6 7 8 9 10 11 12 14 17 22) do: [ :s |
		(self create: aString size: s bold: true italic: true boldItalic: false) ifNotNil: [ :font |
			fontDict
				at: s
				put: font ]].
	fontDict notEmpty ifTrue: [
		AvailableFonts at: aString put: fontDict ].
	Preferences restoreDefaultFonts! !
!StrikeFont class methodsFor: 'removing' stamp: 'jmv 9/25/2017 20:41:27' prior: 16915172!
        removeForPDA
"
StrikeFont removeForPDA
"
	| familyDict |
	familyDict _ AvailableFonts at: Preferences defaultFontFamily.
	familyDict keys do: [ :k |
		(#(5 6 7 8 9) includes: k) 
			ifTrue: [
				(familyDict at: k) derivativeFont: nil at: 0 ]
			ifFalse: [
				familyDict removeKey: k ]].
	
	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 6)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7))! !
!StrikeFont class methodsFor: 'removing' stamp: 'jmv 9/25/2017 20:42:25' prior: 16915190!
        removeMostFonts
"
StrikeFont removeMostFonts
"
	| familyDict |
	Preferences disable: #italicsInShout.
	SHTextStylerST80 initialize.
	familyDict _ AvailableFonts at: Preferences defaultFontFamily.
	familyDict keys do: [ :k |
		(#(8 10 12) includes: k) 
			ifTrue: [
				(familyDict at: k) derivativeFont: nil at: 0 ]
			ifFalse: [
				familyDict removeKey: k ]].

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 10)
			(setListFontTo: 10)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 10)
			(setButtonFontTo: 10))! !
!StrikeFont class methodsFor: 'removing' stamp: 'jmv 9/25/2017 20:42:49' prior: 16915211!
                          removeSomeFonts
"
StrikeFont removeSomeFonts
"
	| familyDict |
	familyDict _ AvailableFonts at: Preferences defaultFontFamily.
	familyDict keys do: [ :k |
		"No boldItalic for the followint"
		(#(5 6 7 8 9 10 11 12 14 17 22) includes: k)
			ifTrue: [ (familyDict at: k) derivativeFont: nil at: 3 ].
		"No derivatives at all for the following"
		(#() includes: k)
			ifTrue: [ (familyDict at: k) derivativeFont: nil at: 0 ].
		"Sizes to keep"
		(#(5 6 7 8 9 10 11 12 14 17 22) includes: k) 
			ifFalse: [ familyDict removeKey: k ]].

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9))! !
!StrikeFont class methodsFor: 'character shapes' stamp: 'jmv 9/25/2017 20:45:01' prior: 16915250!
            buildLargerPunctuation: familyName
	"
	StrikeFont buildLargerPunctuation: 'DejaVu Sans'
	"
	| form form2 f10 f11 f12 f9 |

	f9 _ AbstractFont familyName: familyName pointSize: 9.
	f10 _ AbstractFont familyName: familyName pointSize: 10.
	f11 _ AbstractFont familyName: familyName pointSize: 11.
	f12 _ AbstractFont familyName: familyName pointSize: 12.


	f9 takeGlyphFor: $. from: $. in: f12.
	f9 takeGlyphFor: $, from: $, in: f12.
	
	form _ f9 glyphAt: $..
	form copy: (0@9 extent: 3@14) from: form to: 0@4 rule: Form and.
	f9 glyphAt: $: put: form.

	form _ f9 glyphAt: $,.
	form2 _ f9 glyphAt: $..
	form copy: (0@9 extent: 3@14) from: form2 to: 1@4 rule: Form and.
	f9 glyphAt: $; put: form.



	f10 takeGlyphFor: $. from: $. in: f12.
	f10 takeGlyphFor: $, from: $, in: f12.

	form _ f10 glyphAt: $. .
	form copy: (0@9 extent: 3@14) from: form to: 0@4 rule: Form and.
	f10 glyphAt: $: put: form.

	form _ f10 glyphAt: $,.
	form2 _ f10 glyphAt: $..
	form copy: (0@9 extent: 3@14) from: form2 to: 1@4 rule: Form and.
	f10 glyphAt: $; put: form.



	f11 takeGlyphFor: $. from: $. in: f12.
	f11 takeGlyphFor: $, from: $, in: f12.
	f11 takeGlyphFor: $: from: $: in: f12.
	f11 takeGlyphFor: $; from: $; in: f12! !
!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'jmv 9/25/2017 20:44:33' prior: 50337167!
                  initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (AbstractFont familyName: Preferences defaultFontFamily pointSize: 22) 
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3188-FontInstallEnhancements-JuanVuletich-2017Sep25-20h30m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3188] on 29 September 2017 at 5:43:16 pm'!
!Form methodsFor: 'bordering' stamp: 'jmv 9/29/2017 16:59:58'!
                              border: aRectangle width: borderWidth borderHeight: borderHeight fillColor: aColor
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth@borderHeight. Uses aHalfTone for 
	drawing the border."

	self border: aRectangle
		widthRectangle: 
			(Rectangle
				left: borderWidth
				right: borderWidth
				top: borderHeight
				bottom: borderHeight)
		rule: Form over
		fillColor: aColor! !
!Form methodsFor: 'bordering' stamp: 'jmv 9/29/2017 16:59:43'!
                             borderWidth: borderWidth borderHeight: borderHeight fillColor: aColor
	self border: self boundingBox width: borderWidth borderHeight: borderHeight fillColor: aColor! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3189-Form-2borderMethods-JuanVuletich-2017Sep29-12h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3187] on 28 September 2017 at 1:44:54 pm'!
!Float64Array methodsFor: 'interpolating' stamp: 'jmv 9/28/2017 13:39:15'!
    interpolateValues: valuesArray at: x
	"Interpret self as a domain and valuesArray as a function samples."
	
	^self
		findBinaryIndex: [ :arg | x - arg ]
		do: [ :i | valuesArray at: i ]
		ifNone: [ :i :j  |
			((valuesArray at: i) interpolateTo: (valuesArray at: j) at: (x - (self at: i)) / ((self at: j) - (self at: i)))]! !
!Float64Array methodsFor: 'interpolating' stamp: 'jmv 9/28/2017 13:39:12'!
               interpolatedValueAt: floatIndex
	"Do a linear interpolation.
	Gives usual error if argument outside bounds:
	#[ 4 5 ] asFloatArray interpolatedValueAt: 0.999
	#[ 4 5 ] asFloatArray interpolatedValueAt: 1.0
	#[ 4 5 ] asFloatArray interpolatedValueAt: 1.5
	#[ 4 5 ] asFloatArray interpolatedValueAt: 2.0
	#[ 4 5 ] asFloatArray interpolatedValueAt: 2.000001
	#[ 4 5 ] asFloatArray interpolatedValueAt: 3
	"
	| size index0 index1 weight0 weight1 |

	size _ self size.
	index0 _ floatIndex truncated. 		"Could be #floor. But as we only care for values >=1, it is the same. But faster."

	weight1 _ floatIndex - index0.
	weight0 _ 1.0 - weight1.

	index1 _ (index0 = size and: [ weight1 = 0.0 ]) 			"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ index0 + 1 ]
		ifTrue: [ index0 ].

	"/* perform interpolation */"
	^ (weight0 * (self at: index0)) + (weight1 * (self at: index1))! !
!FloatArray methodsFor: 'interpolating' stamp: 'jmv 9/28/2017 13:36:31'!
         interpolateValues: valuesArray at: x
	"Interpret self as a domain and valuesArray as a function samples."
	
	^self
		findBinaryIndex: [ :arg | x - arg ]
		do: [ :i | valuesArray at: i ]
		ifNone: [ :i :j  |
			((valuesArray at: i) interpolateTo: (valuesArray at: j) at: (x - (self at: i)) / ((self at: j) - (self at: i)))]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3190-interpolation-enh-JuanVuletich-2017Sep28-13h36m-jmv.1.cs.st----!

----SNAPSHOT----#(1 October 2017 4:33:22.632616 pm) Cuis5.0-3190-v3.image priorSource: 1295998!

----QUIT----#(1 October 2017 4:33:41.266095 pm) Cuis5.0-3190-v3.image priorSource: 1317581!

----STARTUP----#(1 October 2017 4:45:40.238381 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3190-v3.image!


----QUIT----#(1 October 2017 4:54:50.115556 pm) Cuis5.0-3190-v3.image priorSource: 1317678!

----STARTUP----#(22 October 2017 9:25:43.58221 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3190-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3190] on 1 October 2017 at 5:11:37 pm'!
!Preferences class methodsFor: 'fonts' stamp: 'jmv 10/1/2017 17:11:24' prior: 50372160!
                               defaultFontFamily
	"Answer the default font family name"

	^self parameters at: #defaultFontFamily ifAbsentPut: [ AbstractFont familyNames first ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3191-JustInCase-JuanVuletich-2017Oct01-17h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3186] on 30 September 2017 at 3:32:06 pm'!
!SHTextStylerST80 methodsFor: 'private' stamp: 'pb 9/30/2017 15:31:56' prior: 50371148!
                  parseSetWorkspace: aBoolean
	"Answer a collection of SHRanges by parsing aText.
	When formatting it is not necessary to set the workspace, and this can make the parse take less time, so aBoolean specifies whether the parser should be given the workspace"
	parser ifNil: [ parser := SHParserST80 new ].
	parser
		workspace:
			(aBoolean ifTrue: [ workspace ]);
		classOrMetaClass: classOrMetaClass;
		source: formattedText asString.
	parser parse.
	^ parser ranges.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3192-SHTextStylerST80-parseSetWorkspace-PhilBellalouna-2017Sep30-15h31m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3192] on 7 October 2017 at 4:29:18 pm'!
!Float commentStamp: 'jmv 10/7/2017 16:27:55' prior: 16844366!
                       A note About Floating Point numbers and Floating Point Arithmetic.

The following is not specific to Cuis or Smalltalk at all. This is about the properties of Float numbers in any computer implementation.

If you haven't done so already, read https://en.wikipedia.org/wiki/Floating-point_arithmetic

But if you find the Wikipedia article too detailed, or hard to read, then try http://fabiensanglard.net/floating_point_visually_explained/ (get past "How Floating Point are usually explained" and read "A different way to explain...").

Other great reads are:
	"Why don't my numbers add up?":
		http://floating-point-gui.de/
and
	"What Every Computer Scientist Should Know About Floating-Point Arithmetic":
		http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
and also maybe
	"Comparing floating point numbers"
		https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

Now that you read them, and we are on the same boat, some further comments (from jmv):

Floats are (conceptually) approximate real numbers. That's why trig and other trascendental functions always answer Floats. That's why it is ok to round the result of operations. That's why Float is considered more general than Fraction in ST-80 and most Smalltalks. So, when we have a Float value, we must not think about it as a Rational but as a Real (actually as some unknown Real that could hopefully be close to the Rational we can actually represent). Keep this in mind when dealing with Floats, and especially avoid comparing them for equality.

(If you want exact arithmetic, can live in the limited world of Rational numbers, and can afford a slight performance penalty, use Fraction instead.)

There are some things that can be done to increase the confidence you can have on Float results. One is to do an error propagation analysis on the code you are running. This is not easy, but it is done for any widely used numerical method. Then, you can know real bounds and/or estimates of the errors made.

Perhaps you have heard about "interval arithmetic". It is a bit better than simple Float, but doesn't really fix the problems.

The ultimate solution is to do Monte Carlo analysis, with random contamination of inputs. After the Monte Carlo run, it is needed to do statistical analysis of possible correlations between the distributions of the random noise added to imputs and the result of the algorithm.

Additional food for thought: http://www.cs.berkeley.edu/~wkahan/Mindless.pdf . According to this, doing Monte Carlo as described above attacks a slightly different problem. This might be yet another reason (besides performance) to try something like the next paragraph. I (jmv) came up with it, and I don't really know if it has been described and or tried before or not. Mhhh. Maybe a defensive publication is in order.

A possibility that could be a practical solution, being much cheaper than Monte Carlo, but better than interval arithmetic, is to represent each value by 2 Floats: an estimation of the real value (i.e. an estimation of the mean value of the distribution of the corresponding Monte Carlo result), and an estimation of the error (i.e. an estimation of the standard deviation of the corresponding Monte Carlo result). Or perhaps even 3 of them. In addition to the estimation of the real value and an estimation of the error, we could add a hard bound on the error. In many cases it will be useless, because the error can not really be bound. But in those cases where it is possible to bound it, applications could really know about the quality of computed values.

=======================================================================

My instances represent IEEE-754 floating-point double-precision numbers. They have about 16 digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:
	
	8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12

Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:

	3r20.2 --> 6.66666666666667
	8r20.2 --> 16.25

If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...
	sign		1 bit
	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent
						in the range -1023 .. +1024
				- 16r000:
					significand = 0: Float zero
					significand ~= 0: Denormalized number (exp = -1024, no hidden '1' bit)
				- 16r7FF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.

The single-precision format is...
	sign		1 bit
	exponent	8 bits, with bias of 127, to represent -126 to +127
                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)
                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)
	mantissa	24 bits, but only 23 are stored
This format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.

You might also check https://en.wikipedia.org/wiki/IEEE_754_revision

Other great reads (covering broader but interesting issues):
https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
http://www.ima.umn.edu/2010-2011/W1.10-14.11/activities/Leeser-Miriam/Leeser-GPU-IMA-Jan2011.pdf!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3193-FloatClassCommentTweaks-JuanVuletich-2017Oct07-16h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3193] on 8 October 2017 at 6:43:01 pm'!
!WriteStream methodsFor: 'services' stamp: 'jmv 10/8/2017 17:58:45'!
                    padToEndIfCantTruncate
	"Only makes sense for file streams with existing content.
	See inheritance"! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 10/8/2017 17:58:13'!
padToEndIfCantTruncate
	"Only makes sense for file streams with existing content.
	On file systems that don't support truncating this is needed.
	If truncating is supported, try that first"

	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."

	| pad |
	self atEnd ifTrue: [^ self].
	self truncate.
	self atEnd ifTrue: [^ self].
	pad := self isBinary 
		ifTrue: [Character space numericValue]
		ifFalse: [Character space ].
	self nextPutAll: (self collectionSpecies new: ((self size - self position) min: 20000) 
							withAll: pad)! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 10/8/2017 17:02:10' prior: 50332189!
                       basicNext
	"Answer the next byte or character (depending on mode) from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 10/8/2017 17:02:58' prior: 16913325!
                              nextPut: char
	"Write the given byte or character (depending on mode) to this file."

	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].
	collection ifNotNil: [ 
		position < readLimit ifTrue: [ self flushReadBuffer ] ].
	buffer1 at: 1 put: char.
	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.
	^ char
! !
!StandardFileStream methodsFor: 'private' stamp: 'jmv 10/8/2017 17:04:44' prior: 16913668!
                     collectionSpecies
	"Answer the species of collection into which the receiver can stream.
	This is ByteArray or String, depending on the mode."
	
	^buffer1 species! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 10/8/2017 17:59:09' prior: 50366383!
nextPut: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.
	You can see an analysis of which objects are written out by doing: 
	(SmartRefStream statsOfSubObjects: anObject)
	(SmartRefStream tallyOfSubObjects: anObject)
	(SmartRefStream subObjects: anObject ofClass: aClass)"

| info |
topCall
	ifNil: [
		topCall _ anObject.
		'Please wait while objects are counted' 
			displayProgressAt: Sensor mousePoint
			from: 0 to: 10
			during: [ :barBlock | info _ self instVarInfo: anObject].
		byteStream binary.
		'Writing an object file' displayProgressAt: Sensor mousePoint
			from: 0 to: objCount*4	"estimate"
			during: [ :barBlock |
				objCount _ 0.
				progressBar _ barBlock.
				self setStream: byteStream reading: false.
					"set basePos, but keep any class renames"
				super nextPut: ReferenceStream versionCode.
				super nextPut: info.
				super nextPut: anObject.		"<- the real writing"
				].
					"Note: the terminator, $!!, is not doubled inside object data"
		"references is an IDict of every object that got written"
		byteStream ascii.
		byteStream nextPutAll: '!!'; newLine; newLine.
		byteStream padToEndIfCantTruncate.
		topCall _ progressBar _ nil]	"reset it"
	ifNotNil: [
		super nextPut: anObject.
		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].
! !

DummyStream removeSelector: #padToEndWith:!

DummyStream removeSelector: #padToEndWith:!

StandardFileStream removeSelector: #padToEndWith:!

StandardFileStream removeSelector: #padToEndWith:!

FileStream removeSelector: #text!

FileStream removeSelector: #text!

RWBinaryOrTextStream removeSelector: #padToEndWith:!

RWBinaryOrTextStream removeSelector: #padToEndWith:!

RWBinaryOrTextStream removeSelector: #text!

RWBinaryOrTextStream removeSelector: #text!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3194-FileStream-cleanup-JuanVuletich-2017Oct08-18h39m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3194] on 11 October 2017 at 12:29:51 pm'!
!SHParserST80 methodsFor: 'parse support' stamp: 'tween 4/28/2004 09:48' prior: 50371165!
           enterBlock
	blockDepth := blockDepth + 1.
	bracketDepth := bracketDepth + 1! !
!SHParserST80 methodsFor: 'parse support' stamp: 'jmv 3/2/2010 10:06' prior: 50371173!
                          leaveBlock
	arguments removeKey: blockDepth ifAbsent: nil.
	temporaries removeKey: blockDepth ifAbsent: nil.
	blockDepth := blockDepth - 1.
	bracketDepth := bracketDepth - 1! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:03' prior: 50371213!
                           parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 10/11/2017 12:27:51' prior: 50371224!
                              parseBlock

	"Just read $["
	blockDepths add: blockDepth+1.
	blockDepthsStartIndexes add: sourcePosition-1.

	self enterBlock.
	self scanPast: #blockStart level: bracketDepth.
	currentTokenFirst == $: ifTrue: [self parseBlockArguments].
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $].

	"Just read $]"
	blockDepths add: blockDepth-1.
	blockDepthsStartIndexes add: sourcePosition.

	self scanPast: #blockEnd level: bracketDepth.
	self leaveBlock! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3195-FixShoutBracketColoring-JuanVuletich-2017Oct11-12h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3195] on 21 October 2017 at 10:12:27 pm'!
!ContextPart methodsFor: 'debugger access' stamp: 'jmv 10/21/2017 22:04:04'!
                   shortErrorReportOn: strm
	"Write a short error report on the stack (above me) on a stream.  For both the error file, and emailing a bug report. "

	| cnt aContext |
 	strm print: Date today; space; print: Time now; newLine.
	aContext _ self.
	cnt _ 0.
	[aContext notNil and: [(cnt _ cnt + 1) < 20]] whileTrue: [
		strm print: aContext; newLine.  "just class>>selector"	
		aContext _ aContext sender]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 10/19/2017 23:20:22'!
                             isHeadless
	"Answer true if any of this VM options was specified in the commandline:
		-nodisplay
		-vm-display-null

	Smalltalk isHeadless
	"
	self vmOptionsDo: [ :vmOption :i |
		vmOption = '-vm-display-null' ifTrue: [ ^ true ].
		vmOption = '-nodisplay' ifTrue: [ ^ true ] ].
	^ false! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 10/19/2017 23:14:08'!
             vmOptionsDo: aBlock
	"Repeatedly evaluate aBlock for each vm option specified by the commandline that started Cuis.
	aBlock has two arguments: the vm option itself and the index (position)
	
	Smalltalk vmOptionsDo: [ :option :i | {i. option} print ]
	"
	| i vmOption |
	i _ -1.
	[vmOption _ Smalltalk getSystemAttribute: i.
	vmOption notNil ] whileTrue: [
		aBlock value: vmOption value: i.
		i _ i-1 ]! !
!UnhandledError methodsFor: 'priv handling' stamp: 'jmv 10/21/2017 22:07:43'!
                            standaloneAppDefaultAction
	"Dump the stack trace to a log file, then exit the program (image)."
	
	Smalltalk logError: self description inContext: self signalerContext to: 'CuisDebug'.
	Smalltalk quitPrimitive: 1! !
!Debugger class methodsFor: 'class initialization' stamp: 'jmv 10/21/2017 21:54:51' prior: 16830340!
  openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	<primitive: 19> "Simulation guard"
	self errorRecursion not & Preferences logDebuggerStackToFile ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	ErrorRecursion ifTrue: [
		ErrorRecursion _ false.
		contentsStringOrNil
			ifNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString]
			ifNotNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString, String newLineString, contentsStringOrNil ]].
	ErrorRecursion _ true.
	self informExistingDebugger: aContext label: aString.
	(Debugger context: aContext)
		openNotifierContents: contentsStringOrNil
		label: aString.
	ErrorRecursion _ false.
	Processor activeProcess suspend.
! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 10/21/2017 21:54:56' prior: 16830430!
     openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	debugger
		process: interruptedProcess
		context: interruptedProcess suspendedContext.
	debugger externalInterrupt: true.

Preferences logDebuggerStackToFile ifTrue:
	[(aString includesSubString: 'Space') & 
		(aString includesSubString: 'low') ifTrue: [
			Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug']].

	^ debugger
		openNotifierContents: nil
		label: aString
! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 10/21/2017 21:55:00' prior: 50368357!
                          openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := ProjectX newProcessIfUIX: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	WorldState addDeferredUIMessage: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 10/21/2017 22:12:20' prior: 16921052!
             logError: errMsg inContext: aContext to: baseFilename
	"Log the error message and a stack trace to the given file.
	Smalltalk logError: 'test error message' inContext: thisContext to: 'testErr.txt'
	"

	| localFilename file |
	localFilename _ Preferences debugLogTimestamp
		ifTrue: [ baseFilename, '-', Utilities dateTimeSuffix, '.log' ]
		ifFalse: [ baseFilename, '.log' ].
	file _ DirectoryEntry smalltalkImageDirectory // localFilename.
	[
		file forceWriteStreamDo: [ :stream |
	 	 	stream nextPutAll: errMsg; newLine.
			aContext errorReportOn: stream ]
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"
	[
 	 	StdIOWriteStream stdout newLine; nextPutAll: errMsg.
		StdIOWriteStream stdout newLine; nextPutAll: 'See '; nextPutAll: file pathName.
		StdIOWriteStream stdout newLine.
		aContext shortErrorReportOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout flush
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"! !
!UnhandledError methodsFor: 'priv handling' stamp: 'jmv 10/21/2017 21:17:43' prior: 16940304!
                        defaultAction
	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."

	self isDevelopmentEnvironmentPresent
		ifTrue: [ self devDefaultAction ]
		ifFalse: [ self standaloneAppDefaultAction ]! !
!UnhandledError methodsFor: 'priv handling' stamp: 'jmv 10/19/2017 23:20:13' prior: 16940324!
        isDevelopmentEnvironmentPresent

	^ Smalltalk isHeadless not and: [Smalltalk includesKey: #Debugger]! !
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 10/19/2017 23:30:02' prior: 16893585!
                    debugLogTimestamp
	^ self
		valueOfFlag: #debugLogTimestamp
		ifAbsent: [true]! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 10/21/2017 21:52:54' prior: 16940682!
              dateTimeSuffix
	"Answer a string which indicates the date and time, intended for use in building fileout filenames, etc.

	Utilities dateTimeSuffix
	"
	| n |
	n _ DateAndTime now.
	^ String streamContents: [ :strm |
		n printYMDOn: strm withLeadingSpace: false.
		strm nextPut: $_.
		n printHMSOn: strm separator: $. ]! !
!DisplayScreen methodsFor: 'private' stamp: 'jmv 10/21/2017 21:55:10' prior: 16835312!
       findAnyDisplayDepth
	"Return any display depth that is supported on this system."
	^self findAnyDisplayDepthIfNone: [
		"Ugh .... now this is a biggie - a system that does not support
		any of the Squeak display depths at all."
		Smalltalk
			logError: 'Fatal error: This system has no support for any display depth at all.'
			inContext: thisContext
			to: 'CuisDebug'.
		Smalltalk quitPrimitive. "There is no way to continue from here"
	]! !

Utilities class removeSelector: #monthDayTime24StringFrom:!

Utilities class removeSelector: #monthDayTime24StringFrom:!

Utilities class removeSelector: #monthDayTimeStringFrom:!

Utilities class removeSelector: #monthDayTimeStringFrom:!

Preferences class removeSelector: #twentyFourHourFileStamps!

Preferences class removeSelector: #twentyFourHourFileStamps!

Debugger removeSelector: #storeLog!

Debugger removeSelector: #storeLog!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3196-StandaloneApps-ExitOnError-JuanVuletich-2017Oct21-22h09m-jmv.1.cs.st----!

----SNAPSHOT----#(22 October 2017 9:25:52.288228 pm) Cuis5.0-3196-v3.image priorSource: 1317885!

----QUIT----#(22 October 2017 9:26:08.261184 pm) Cuis5.0-3196-v3.image priorSource: 1340930!

----STARTUP----#(3 November 2017 11:15:47.773216 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3196-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3196] on 26 October 2017 at 12:41:44 pm'!

UnhandledError removeSelector: #runtimeDefaultAction!

UnhandledError removeSelector: #runtimeDefaultAction!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3197-remove-runtimeDefaultAction-JuanVuletich-2017Oct26-12h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3197] on 26 October 2017 at 4:59:57 pm'!
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'dhn 10/25/2017 16:48:11' prior: 16909778!
               browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry browser |
	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	(aSymbol _ self selectedSymbol) ifNil: [^ morph flash].

	aSymbol first isUppercase
		ifTrue: [
			anEntry _ (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse:	[anEntry _ anEntry class].
			browser _ Browser new.
			browser setClass: anEntry selector: nil.
			BrowserWindow open: browser label:'System Browser: ',  aSymbol]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3198-BrowseIt-includeClassName-DanNorton-2017Oct26-16h59m-dhn.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3198] on 27 October 2017 at 9:25:00 am'!
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 10/27/2017 09:24:28' prior: 0!
                              logDebuggerStackToFile
	^ self
		valueOfFlag: #logDebuggerStackToFile
		ifAbsent: [ false ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3199-DontLogWalkbacksToDiskByDefault-JuanVuletich-2017Oct27-09h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3195] on 22 October 2017 at 4:02:34 pm'!

MouseEvent subclass: #MouseScrollEvent
	instanceVariableNames: 'direction eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseScrollEvent category: #'Morphic-Events'!
MouseEvent subclass: #MouseScrollEvent
	instanceVariableNames: 'direction eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!MouseScrollEvent commentStamp: '<historical>' prior: 0!
            A MouseScrollEvent can be any type of secondary pointer movement (typically via a scroll wheel on a traditional mouse or a gesture on a trackpad).  Currently, events are extracted from KeyboardEvents (which is how the VM currently communicates things like scroll wheel events via ctl+arrow up/down)!
!Morph methodsFor: 'events' stamp: 'pb 10/22/2017 02:55:55'!
                       mouseScroll: aMouseScrollEvent localPosition: localEventPosition
	"Handle a mouse scroll event.
	This message will only be sent to Morphs that answer true to #handlesMouseScroll:
	We can query aMouseScrollEvent to know about pressed mouse buttons."
	
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseScroll:localPosition: 
		ifPresentDo: [ :handler | handler value: aMouseScrollEvent value: localEventPosition ]! !
!Morph methodsFor: 'event handling testing' stamp: 'pb 10/22/2017 02:53:48'!
                        handlesMouseScroll: aMouseScrollEvent
	^ self hasProperty: #'handlesMouseScroll:'! !
!Morph methodsFor: 'events-processing' stamp: 'pb 10/22/2017 15:49:56'!
   processMouseScroll: aMouseEvent localPosition: localEventPosition
	((self handlesMouseScroll: aMouseEvent) and: [ aMouseEvent wasHandled not ]) ifTrue: [
		self
			mouseScroll: aMouseEvent
			localPosition: localEventPosition.
		aMouseEvent wasHandled: true ].! !
!Morph methodsFor: 'private' stamp: 'pb 10/22/2017 05:19:27'!
                          privateAnyOwnerHandlesMouseScroll: aMouseScrollEvent
	| foundHandler |
	foundHandler _ false.
	(self ownerChain allButFirst anySatisfy: [ :anOwner |
		anOwner isWorldMorph not and: [ anOwner handlesMouseScroll: aMouseScrollEvent ]]) ifTrue: [ foundHandler _ true ].
	^ foundHandler.! !
!PluggableScrollPane methodsFor: 'events' stamp: 'pb 10/22/2017 15:52:25'!
                       mouseScroll: aMouseEvent localPosition: localEventPosition
	aMouseEvent direction = #up
		ifTrue: [ scrollBar scrollUp: 1 ]
		ifFalse: [ scrollBar scrollDown: 1 ].! !
!PluggableScrollPane methodsFor: 'event handling testing' stamp: 'pb 10/22/2017 16:00:50'!
                              handlesMouseScroll: aMouseScrollEvent
	"Only accept if we can actually do something useful with the event (i.e. not scrolling up when already at the top or down when already at the bottom) or if my owner chain doesn't want it"
	| canUse |
	canUse _ (aMouseScrollEvent direction = #up and: [ scrollBar scrollValue > 0 ]) or: [
		aMouseScrollEvent direction = #down and: [ scrollBar scrollValue < 1 ]].
	"Even if I don't want it, one of my owners might. (i.e. nested scroll panes)  If my owners don't want it, accept the event to make sure that morphs behind me doesn't get the event."
	canUse ifFalse: [
		(self privateAnyOwnerHandlesMouseScroll: aMouseScrollEvent) ifFalse: [ canUse _ true ]].
	^ canUse.! !
!MouseEvent methodsFor: 'testing' stamp: 'pb 10/22/2017 02:19:31'!
                         isMouseScroll
	^ type == #mouseScroll! !
!MouseScrollEvent methodsFor: 'private' stamp: 'pb 10/22/2017 02:17:18'!
              setType: evtType position: evtPos direction: evtDir buttons: evtButtons hand: evtHand stamp: stamp
	type _ evtType.
	position _ evtPos.
	buttons _ evtButtons.
	source _ evtHand.
	wasHandled _ false.
	direction _ evtDir.
	timeStamp _ stamp.! !
!MouseScrollEvent methodsFor: 'comparing' stamp: 'pb 10/22/2017 02:18:29'!
  hash
	^ position hash + buttons hash + direction hash! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'pb 10/22/2017 15:51:28'!
                          dispatchWith: aMorph localPosition: positionInAMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	"Try to get out quickly"
	| aMorphHandlesIt handledByInner eventPositionInChild focus|
	focus := self hand keyboardFocus.
	"FIXME - this works in all tested cases but one: when the window directly under the mouse doesn't have keyboard focus (i.e. a Transcript window)"
	((aMorph fullContainsPoint: positionInAMorph) and: [(aMorph = focus) or: [focus notNil and: [aMorph notNil and: [focus hasOwner: aMorph]]]]) ifFalse: [ ^ #rejected ].
	"Install the prospective handler for the receiver"
	aMorphHandlesIt _ false.
	(aMorph handlesMouseScroll: self) ifTrue: [
		eventHandler _ aMorph.
		aMorphHandlesIt _ true ].
	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			eventPositionInChild _ eachChild internalize: positionInAMorph.
			(eachChild
				dispatchEvent: self
				localPosition: eventPositionInChild) == #rejected ifFalse: [ "Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].
	(handledByInner or: [
		aMorph
			containsPoint: positionInAMorph
			event: self ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt ifTrue: [ ^ self
				sentTo: aMorph
				localPosition: positionInAMorph ]].
	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected.! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'pb 10/22/2017 03:04:54'!
   sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"
	^ aMorph
		processMouseScroll: self
		localPosition: positionInAMorph.! !
!MouseScrollEvent methodsFor: 'accessing' stamp: 'pb 10/22/2017 03:15:50'!
                    direction
	^ direction ! !
!HandMorph methodsFor: 'events-processing' stamp: 'pb 10/22/2017 14:44:34' prior: 16851817!
         startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		^self mouseFocus
			ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
			ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]].

	"any mouse event but mouseOver"
	lastMouseEvent _ aMouseEvent.	
	lastMouseEventTime _ Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	aMouseEvent isMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
				ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]
		] ifFalse: [
		aMouseEvent isMouseScroll ifTrue: [
			owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setType: #mouseMove
					position: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [
					"Not if we are grabbing them"
					mouseClickState ifNil: [self dropMorphs: aMouseEvent ]]
				ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
						ifNil: [ owner dispatchEvent: aMouseEvent localPosition: aMouseEvent eventPosition ]]]].
		self mouseOverHandler processMouseOver: self lastMouseEvent! !
!HandMorph methodsFor: 'private events' stamp: 'pb 10/22/2017 14:48:02' prior: 16852220!
          generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time localMillisecondClock ].
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [ type _ #keyUp ].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [
			"Control key pressed"
			keyValue < 27 ifTrue: [
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [
					"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [
						"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96
								"shift not pressed: conver to lowercase letter" ]]]].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]]].
	buttons _ modifiers bitShift: 3.
	(modifiers = 2 and: [
		keyValue = 30 or: [ keyValue = 31 ]])
		ifTrue: [ "We're hijacking ctl-up/down arrow since that is what the VM sends us for scroll events.  We're going to convert these to MouseScrollEvent and throw away the keyboard event"
			^ MouseScrollEvent new
				setType: #mouseScroll
				position: self morphPosition
				direction:
					(keyValue caseOf: {
						[ "Implementing as a caseof to allow for easy adding of left/right/other events should they become available"
						30 ] -> [ #up ].
						[ 31 ] -> [ #down ]})
				buttons: buttons
				hand: self
				stamp: stamp ]
		ifFalse: [ ^ KeyboardEvent new
				setType: type
				buttons: buttons
				position: self morphPosition
				keyValue: keyValue
				hand: self
				stamp: stamp ].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3200-Morph-Scroll-Events-PhilBellalouna-2017Oct22-02h07m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3200] on 27 October 2017 at 9:38:49 am'!
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 10/27/2017 09:38:25' prior: 16889541!
                        keyStroke: aKeyboardEvent

	(Theme current keyStroke: aKeyboardEvent morph: self)
		ifTrue: [^ self].
	( self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	super keyStroke: aKeyboardEvent.
	scroller keyStroke: aKeyboardEvent! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 10/27/2017 09:38:10' prior: 16853054!
                   keyStroke: aKeyboardEvent 
	"Process potential command keys"

	| args aCharacter |
	(Theme current keyStroke: aKeyboardEvent morph: self)
		ifTrue: [^ self].
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	aCharacter _ aKeyboardEvent keyCharacter.
	(self arrowKey: aCharacter)
		ifTrue: [ ^self ].
	keystrokeActionSelector ifNil: [^self].
	(args _ keystrokeActionSelector numArgs) = 1 
		ifTrue: [^mainView perform: keystrokeActionSelector with: aCharacter].
	args = 2 
		ifTrue: [
			^mainView 
				perform: keystrokeActionSelector
				with: aCharacter
				with: self].
	^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 10/27/2017 09:38:21' prior: 16888604!
          keyStroke: aKeyboardEvent 
	"Process keys"
	
	| aCharacter |
	(Theme current keyStroke: aKeyboardEvent morph: self)
		ifTrue: [^ self].
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	aCharacter _ aKeyboardEvent keyCharacter.
	(self arrowKey: aCharacter)
		ifTrue: [ ^self ].
	aCharacter numericValue = 27 ifTrue: [	" escape key"
		^ self mouseButton2Activity].
	aKeyboardEvent anyModifierKeyPressed
		ifTrue: [
			(self keystrokeAction: aCharacter)
				ifTrue: [ ^self ]].
	^ self keyboardSearch: aCharacter! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 10/27/2017 09:36:10' prior: 50373894!
                      generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time localMillisecondClock ].
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [ type _ #keyUp ].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [
			"Control key pressed"
			keyValue < 27 ifTrue: [
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [
					"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [
						"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96
								"shift not pressed: conver to lowercase letter" ]]]].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]]].
	buttons _ modifiers bitShift: 3.
	(modifiers = 2 and: [
		keyValue = 30 or: [ keyValue = 31 ]])
		ifTrue: [ "We're hijacking ctl-up/down arrow since that is what the VM sends us for scroll events.  We're going to convert these to MouseScrollEvent and throw away the keyboard event"
			"ThisPrecludes the use of up and down arrows with control, that are standard keystrokes in Windows to control the cursor.
			But as Linux, Mac and Windows VMs generate ctrl-up and ctrl-down for mouse wheel events, we must honor them.
			Some day, it would be good for the VMs to report mouse wheel events differently fom ctrl-up & ctrl-down..."
			^ MouseScrollEvent new
				setType: #mouseScroll
				position: self morphPosition
				direction:
					(keyValue caseOf: {
						[ "Implementing as a caseof to allow for easy adding of left/right/other events should they become available"
						30 ] -> [ #up ].
						[ 31 ] -> [ #down ]})
				buttons: buttons
				hand: self
				stamp: stamp ]
		ifFalse: [ ^ KeyboardEvent new
				setType: type
				buttons: buttons
				position: self morphPosition
				keyValue: keyValue
				hand: self
				stamp: stamp ].! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 10/27/2017 09:38:16' prior: 16855703!
         keyStroke: aKeyboardEvent

	(Theme current keyStroke: aKeyboardEvent morph: self)
		ifTrue: [^ self].
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].

	autoCompleter 
		ifNil: [ self processKeyStroke: aKeyboardEvent ]
		ifNotNil: [
			autoCompleter
				autoCompletionAround: [ self processKeyStroke: aKeyboardEvent ]
				keyStroke: aKeyboardEvent ]! !

PluggableScrollPane removeSelector: #scrollByKeyboard:!

PluggableScrollPane removeSelector: #scrollByKeyboard:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3201-Cleanup-JuanVuletich-2017Oct27-09h31m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3201] on 27 October 2017 at 9:58:10 am'!
!MouseScrollEvent commentStamp: '<historical>' prior: 50373638!
    A MouseScrollEvent can be any type of secondary pointer movement (typically via a scroll wheel on a traditional mouse or a gesture on a trackpad).  Currently, events are extracted from KeyboardEvents (which is how the VM currently communicates things like scroll wheel events via ctl+arrow up/down).

It is also possible to generate these events with a keyboard, pressing ctrl-down or ctrl-up. Given this, we also added ctrl-left and ctrl-right, that can only be generated with a keyboard, to control horizontal scroll.!
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 10/27/2017 09:56:48' prior: 50373696!
                           mouseScroll: aMouseEvent localPosition: localEventPosition
	aMouseEvent direction
		caseOf: {
			[ #up ] 		-> 		[  scrollBar scrollUp: 1 ].
			[ #down ] 	-> 		[ scrollBar scrollDown: 1 ].
			[ #left ] 		-> 		[  hScrollBar scrollUp: 1 ].
			[ #right ] 	-> 		[  hScrollBar scrollDown: 1 ] }! !
!PluggableScrollPane methodsFor: 'event handling testing' stamp: 'jmv 10/27/2017 09:47:51' prior: 50373705!
                handlesMouseScroll: aMouseScrollEvent
	"Only accept if we can actually do something useful with the event (i.e. not scrolling up when already at the top or down when already at the bottom) or if my owner chain doesn't want it"

	(aMouseScrollEvent direction = #up and: [ scrollBar scrollValue > 0 ])
		ifTrue: [ ^ true ].
	(aMouseScrollEvent direction = #down and: [ scrollBar scrollValue < 1 ])
		ifTrue: [ ^ true ].
	(aMouseScrollEvent direction = #left and: [ hScrollBar scrollValue > 0 ])
		ifTrue: [ ^ true ].
	(aMouseScrollEvent direction = #right and: [ hScrollBar scrollValue < 1 ])
		ifTrue: [ ^ true ].
	"Even if I don't want it, one of my owners might. (i.e. nested scroll panes)  If my owners don't want it, accept the event to make sure that morphs behind me doesn't get the event."
	(self privateAnyOwnerHandlesMouseScroll: aMouseScrollEvent)
		ifFalse: [ ^ true ].
	^ false! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 10/27/2017 09:57:46' prior: 50374061!
          generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time localMillisecondClock ].
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [ type _ #keyUp ].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [
			"Control key pressed"
			keyValue < 27 ifTrue: [
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [
					"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [
						"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96
								"shift not pressed: conver to lowercase letter" ]]]].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]]].
	buttons _ modifiers bitShift: 3.
	(modifiers = 2 and: [
		keyValue between: 28 and: 31])
		ifTrue: [ "We're hijacking ctl-up/down arrow since that is what the VM sends us for scroll events.  We're going to convert these to MouseScrollEvent and throw away the keyboard event"
			"ThisPrecludes the use of up and down arrows with control, that are standard keystrokes in Windows to control the cursor.
			But as Linux, Mac and Windows VMs generate ctrl-up and ctrl-down for mouse wheel events, we must honor them.
			Some day, it would be good for the VMs to report mouse wheel events differently fom ctrl-up & ctrl-down..."
			"Also do ctrl-left and ctrl-right for horizontal scroll."
			^ MouseScrollEvent new
				setType: #mouseScroll
				position: self morphPosition
				direction:
					(keyValue caseOf: {
						"Implementing as a caseof to allow for easy adding of left/right/other events should they become available"
						[ 30 ] -> [ #up ].
						[ 31 ] -> [ #down ].
						[ 28 ] -> [ #left ].
						[ 29 ] -> [ #right ].
						})
				buttons: buttons
				hand: self
				stamp: stamp ]
		ifFalse: [ ^ KeyboardEvent new
				setType: type
				buttons: buttons
				position: self morphPosition
				keyValue: keyValue
				hand: self
				stamp: stamp ].! !
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 10/27/2017 09:42:20' prior: 16879126!
                     hash
	^ type hash bitXor: (position hash bitXor: buttons hash)! !
!MouseMoveEvent methodsFor: 'comparing' stamp: 'jmv 10/27/2017 09:42:03' prior: 16879243!
    hash
	^ position hash bitXor: buttons hash! !
!MouseScrollEvent methodsFor: 'comparing' stamp: 'jmv 10/27/2017 09:41:31' prior: 50373744!
                      hash
	^ position hash bitXor: (buttons hash bitXor: direction hash)! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3202-HorizontalScrollEvents-JuanVuletich-2017Oct27-09h52m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3202] on 30 October 2017 at 10:28:09 am'!
!Timespan methodsFor: 'smalltalk-80' stamp: 'jmv 10/30/2017 10:26:58' prior: 16938162!
                       previous
	"
	(Month month: 10 year: 2017) previous
	(Year yearNumber: 2016) previous
	"
	^self class classDefinesDuration
		ifTrue: [ self class including: self end - duration ]
		ifFalse: [ self class starting: start - duration duration: duration ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3203-Month-Year-previous-fix-JuanVuletich-2017Oct30-10h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3202] on 30 October 2017 at 10:37:01 am'!
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 10/30/2017 10:36:16'!
   ctrlArrowsScrollHorizontally
	^ self
		valueOfFlag: #ctrlArrowsScrollHorizontally
		ifAbsent: [ false ]! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 10/30/2017 10:35:34' prior: 50374264!
                           generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time localMillisecondClock ].
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [ type _ #keyUp ].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [
			"Control key pressed"
			keyValue < 27 ifTrue: [
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [
					"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [
						"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96
								"shift not pressed: conver to lowercase letter" ]]]].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]]].
	buttons _ modifiers bitShift: 3.
	(modifiers = 2 and: [
		keyValue
			between: (Preferences ctrlArrowsScrollHorizontally ifTrue: [28] ifFalse: [30])
			and: 31])
		ifTrue: [ "We're hijacking ctl-up/down arrow since that is what the VM sends us for scroll events.  We're going to convert these to MouseScrollEvent and throw away the keyboard event"
			"ThisPrecludes the use of up and down arrows with control, that are standard keystrokes in Windows to control the cursor.
			But as Linux, Mac and Windows VMs generate ctrl-up and ctrl-down for mouse wheel events, we must honor them.
			Some day, it would be good for the VMs to report mouse wheel events differently fom ctrl-up & ctrl-down..."
			"Also do ctrl-left and ctrl-right for horizontal scroll."
			^ MouseScrollEvent new
				setType: #mouseScroll
				position: self morphPosition
				direction:
					(keyValue caseOf: {
						"Implementing as a caseof to allow for easy adding of left/right/other events should they become available"
						[ 30 ] -> [ #up ].
						[ 31 ] -> [ #down ].
						[ 28 ] -> [ #left ].
						[ 29 ] -> [ #right ].
						})
				buttons: buttons
				hand: self
				stamp: stamp ]
		ifFalse: [ ^ KeyboardEvent new
				setType: type
				buttons: buttons
				position: self morphPosition
				keyValue: keyValue
				hand: self
				stamp: stamp ].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3204-ByDefault-ctrlLeftRight-jumpsWords-JuanVuletich-2017Oct30-10h28m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3204] on 1 November 2017 at 3:31:08 pm'!
!Character methodsFor: 'accessing' stamp: 'jmv 8/11/2016 09:46:09' prior: 16800406!
                        nonImmediateNumericValue
	"Answer the numeric value of the receiver, if instances happen to be regular (i.e. not in Spur)"

	^self instVarAt: 1! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3205-Dummy-JuanVuletich-2017Nov01-15h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3205] on 1 November 2017 at 4:07:42 pm'!

MessageSet subclass: #ProtocolBrowser
	instanceVariableNames: 'selectiveClassListIndex selectiveClassList baseClass selectedName exclude '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #ProtocolBrowser category: #'Tools-Browser'!
MessageSet subclass: #ProtocolBrowser
	instanceVariableNames: 'selectiveClassListIndex selectiveClassList baseClass selectedName exclude'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

MessageSetWindow subclass: #ProtocolBrowserWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!classDefinition: #ProtocolBrowserWindow category: #'Morphic-Tools'!
MessageSetWindow subclass: #ProtocolBrowserWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!
!ProtocolBrowserWindow commentStamp: '<historical>' prior: 0!
                       A view of the messages available to a class from itself upward through the class hierarchy. The viewed protocol can be pruned by selecting a superclass in the class hierchy pane.!
!ProtocolBrowser methodsFor: 'accessing' stamp: 'dhn 10/31/2017 17:06:51'!
 labelString
	"Answer the string for the window title"
	
	^ 'Protocol for: ', baseClass name, ' up to: ', selectedName! !
!ProtocolBrowser methodsFor: 'private' stamp: 'dhn 10/31/2017 17:38:39'!
                              hierarchyForClass: aClass
	"Set the class hierarchy for the list pane"
	| tab |

	selectiveClassList _ OrderedCollection new.
	tab _ ''.
	aClass withAllSuperclasses reverse do: [:ea | 
		selectiveClassList add: tab , ea name.
		tab _ tab , '  '].
	self classListIndex: 0! !
!ProtocolBrowser methodsFor: 'private' stamp: 'dhn 10/31/2017 16:56:42'!
     protocolFor: anIndex
	"Change the listed protocol"

	exclude _ OrderedCollection new.
	anIndex > 0
		ifTrue: [
			selectedName _ (selectiveClassList at: anIndex) withBlanksTrimmed.
			(1 to: anIndex - 1) do: [:ix |
				exclude addLast: (selectiveClassList at: ix) withBlanksTrimmed]]
		ifFalse: [
			selectedName _ nil.
			].
	self on: baseClass.
	self changed: #relabel! !
!ProtocolBrowser methodsFor: 'private' stamp: 'dhn 10/30/2017 15:40:07'!
 selectiveClassList
	"Answer the value of selectiveClassList"

	^ selectiveClassList! !
!ProtocolBrowser methodsFor: 'private' stamp: 'dhn 10/30/2017 17:02:13'!
selectiveClassListIndex
	"Answer the value of selectiveClassListIndex"

	selectiveClassListIndex ifNil: [selectiveClassListIndex _ 0].
	^ selectiveClassListIndex! !
!ProtocolBrowser methodsFor: 'private' stamp: 'dhn 10/30/2017 17:02:28'!
                  selectiveClassListIndex: anObject
	"Set the value of selectiveClassListIndex"

	selectiveClassListIndex _ anObject.
	self protocolFor: selectiveClassListIndex
! !
!ProtocolBrowser methodsFor: 'initialization' stamp: 'dhn 10/31/2017 15:03:26'!
             initialize

	exclude _ OrderedCollection new! !
!ProtocolBrowserWindow methodsFor: 'GUI building' stamp: 'dhn 10/30/2017 17:28:22'!
                            buildMorphicWindow
	"Answer a morphic window that can display the receiver with a class hierarchy"
	| topRow |

	topRow _ LayoutMorph newRow.
	topRow 
		addMorph: self buildSelectiveClassList proportionalWidth: 0.3;
		addAdjusterMorph;
		addMorph: self buildMorphicMessageList proportionalWidth: 0.7.
	self layoutMorph
		addMorph: topRow proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.8.
	model changed: #editSelection! !
!ProtocolBrowserWindow methodsFor: 'GUI building' stamp: 'dhn 10/30/2017 16:56:49'!
                          buildSelectiveClassList
	"Define the class hierarchy list pane"

	^PluggableListMorph
		model: model
		listGetter: #selectiveClassList
		indexGetter: #selectiveClassListIndex
		indexSetter: #selectiveClassListIndex:! !
!ProtocolBrowserWindow methodsFor: 'updating' stamp: 'dhn 10/30/2017 19:23:00'!
                     update: aSymbol
	"Respond to events of the Dependency Mechanism"
	
	super update: aSymbol.
	aSymbol == #relabel
		ifTrue: [self setLabel: model labelString]! !
!ProtocolBrowser methodsFor: 'private' stamp: 'dhn 10/31/2017 16:33:52' prior: 16896671!
       initListFrom: selectorCollection highlighting: aClass 
	"Make up the messageList with items from aClass in boldface."
	| defClass item |

	messageList _ OrderedCollection new.
	selectorCollection do: [ :selector |  
		defClass _ aClass whichClassIncludesSelector: selector.
		item _ selector, '     (' , defClass name , ')'.
		defClass == aClass ifTrue: [item _ item asText allBold].
		messageList add: (
			MethodReference new
				setClass: defClass 
				methodSymbol: selector 
				stringVersion: item)].
	self hierarchyForClass: (baseClass _ aClass)! !
!ProtocolBrowser methodsFor: 'private' stamp: 'dhn 10/31/2017 18:08:50' prior: 16896690!
                           on: aClass
	"Initialize the protocol for the class, aClass."
	"Optionally, the upper part of the protocol is excluded."
	| selectors |
	
	selectors _ Set new.
	aClass withAllSuperclasses do: [ :each |
		(exclude includes: each name) ifFalse: [selectors addAll: each selectors]].
	self
		initListFrom: selectors asArray sort
		highlighting: aClass! !
!CodeWindow methodsFor: 'menu commands' stamp: 'dhn 10/30/2017 16:28:04' prior: 16813280!
        browseFullProtocol
	"Create and schedule a new protocol browser on the currently selected class or meta."

	| aPBrowser label |
	model selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |
		aPBrowser _ ProtocolBrowser new on: classOrMetaclass.
		label _ 'Entire protocol of: ', classOrMetaclass name.
		ProtocolBrowserWindow open: aPBrowser label: label ]! !

MessageSet subclass: #ProtocolBrowser
	instanceVariableNames: 'baseClass selectiveClassList selectiveClassListIndex selectedName exclude'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #ProtocolBrowser category: #'Tools-Browser'!
MessageSet subclass: #ProtocolBrowser
	instanceVariableNames: 'baseClass selectiveClassList selectiveClassListIndex selectedName exclude'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3206-EnhancedProtocolBrowser-DanNorton-2017Nov01-16h05m-dhn.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3206] on 3 November 2017 at 10:42:58 am'!
!Object methodsFor: 'system primitives' stamp: 'jmv 12/31/1969 21:14:14'!
                         instVarAtPrim73: index
	"Primitive. Answer a fixed variable in an object. The numbering of the 
	variables corresponds to the named instance variables. Fail if the index 
	is not an Integer or is not the index of a fixed variable. Essential. See 
	Object documentation whatIsAPrimitive."

	<primitive: 73>
	"Access beyond fixed variables."
	^self basicAt: index - self class instSize! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/31/1969 21:15:46'!
                   instVarAtPrim74: anInteger put: anObject
	"Primitive. Store a value into a fixed variable in the receiver. The 
	numbering of the variables corresponds to the named instance variables. 
	Fail if the index is not an Integer or is not the index of a fixed variable. 
	Answer the value stored as the result. Using this message violates the 
	principle that each object has sovereign control over the storing of 
	values into its instance variables. Essential. See Object documentation 
	whatIsAPrimitive."

	<primitive: 74>
	"Access beyond fixed fields"
	^self basicAt: anInteger - self class instSize put: anObject! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/31/1969 21:17:57' prior: 16882332!
                              instVarAt: index
	"Primitive. Answer a fixed variable in an object. The numbering of the variables
	 corresponds to the named instance variables, followed by the indexed instance
	 variables. Fail if the index is not an Integer or is not the index of a fixed variable.
	 Essential. See Object documentation whatIsAPrimitive."

	<primitive: 173 error: ec>
	"The classic InterpreterVMs don't support primitives 173 and 174.
	See http://forum.world.st/Some-test-where-Spur-more-slow-than-Cog-td4867810.html#a4867888
	Use primitives 73 and 74 in such case."
	Smalltalk isRunningCog ifFalse: [
		^ self instVarAtPrim73: index ].
	self primitiveFailed! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/31/1969 21:17:51' prior: 16882347!
                             instVarAt: index put: anObject
	"Primitive. Store a value into a fixed variable in an object. The numbering of the
	 variables corresponds to the named instance variables, followed by the indexed
	 instance variables. Fail if the index is not an Integer or is not the index of a fixed
	 variable. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 174 error: ec>
	"The classic InterpreterVMs don't support primitives 173 and 174.
	See http://forum.world.st/Some-test-where-Spur-more-slow-than-Cog-td4867810.html#a4867888
	Use primitives 73 and 74 in such case."
	Smalltalk isRunningCog ifFalse: [
		^ self instVarAtPrim74: index put: anObject ].
	self primitiveFailed! !
!Character methodsFor: 'accessing' stamp: 'jmv 8/11/2016 09:46:09' prior: 50374560!
                           nonImmediateNumericValue
	"Answer the numeric value of the receiver, if instances happen to be regular (i.e. not in Spur)"

	^self instVarAt: 1! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/31/1969 21:13:09' prior: 16920989!
             interpreterClass
	"Interpreter class (Cog VM only)
	nil for classic Interpreter VM
	"
	^self getSystemAttribute: 1007! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3207-MakeCuisWorkOnInterpreterVM-JuanVuletich-2017Nov03-10h42m-jmv.1.cs.st----!

----SNAPSHOT----#(3 November 2017 11:15:54.791933 am) Cuis5.0-3207-v3.image priorSource: 1341028!

----QUIT----#(3 November 2017 11:16:05.949731 am) Cuis5.0-3207-v3.image priorSource: 1383370!

----STARTUP----#(28 November 2017 3:35:55.816335 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3207-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3207] on 10 November 2017 at 11:08:35 am'!
!HandMorph methodsFor: 'private events' stamp: 'jmv 11/10/2017 11:07:46' prior: 50374431!
      generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time localMillisecondClock ].
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [ type _ #keyUp ].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [
			"Control key pressed"
			keyValue < 27 ifTrue: [
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [
					"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [
						"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96
								"shift not pressed: conver to lowercase letter" ]]]].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]]].
	buttons _ modifiers bitShift: 3.
	((modifiers anyMask: 2) and: [
		keyValue
			between: (Preferences ctrlArrowsScrollHorizontally ifTrue: [28] ifFalse: [30])
			and: 31])
		ifTrue: [ "We're hijacking ctl-up/down arrow since that is what the VM sends us for scroll events.  We're going to convert these to MouseScrollEvent and throw away the keyboard event"
			"ThisPrecludes the use of up and down arrows with control, that are standard keystrokes in Windows to control the cursor.
			But as Linux, Mac and Windows VMs generate ctrl-up and ctrl-down for mouse wheel events, we must honor them.
			Some day, it would be good for the VMs to report mouse wheel events differently fom ctrl-up & ctrl-down..."
			"Also do ctrl-left and ctrl-right for horizontal scroll."
			^ MouseScrollEvent new
				setType: #mouseScroll
				position: self morphPosition
				direction:
					(keyValue caseOf: {
						"Implementing as a caseof to allow for easy adding of left/right/other events should they become available"
						[ 30 ] -> [ #up ].
						[ 31 ] -> [ #down ].
						[ 28 ] -> [ #left ].
						[ 29 ] -> [ #right ].
						})
				buttons: buttons
				hand: self
				stamp: stamp ]
		ifFalse: [ ^ KeyboardEvent new
				setType: type
				buttons: buttons
				position: self morphPosition
				keyValue: keyValue
				hand: self
				stamp: stamp ].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3208-MouseScrollOnMacFix-JuanVuletich-2017Nov10-11h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3207] on 10 November 2017 at 11:19:54 am'!

SystemWindow subclass: #WorkspaceWindow
	instanceVariableNames: 'acceptDroppedMorphs '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!classDefinition: #WorkspaceWindow category: #'Morphic-Tools'!
SystemWindow subclass: #WorkspaceWindow
	instanceVariableNames: 'acceptDroppedMorphs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!
!Morph methodsFor: 'accessing - properties' stamp: 'jmv 11/10/2017 11:14:34'!
objectForWorkspace
	^self! !
!InspectorWindow methodsFor: 'accessing' stamp: 'jmv 11/10/2017 11:15:23'!
                        objectForWorkspace
	^model object! !
!ObjectExplorerWindow methodsFor: 'accessing' stamp: 'jmv 11/10/2017 11:19:10'!
           objectForWorkspace
	^model rootObject! !
!Morph methodsFor: 'accessing - properties' stamp: 'jmv 11/10/2017 11:16:44' prior: 16874017!
                         nameForWorkspace
	"Answer a name suitable for a Workspace variable"
	| displayName object |
	object _ self objectForWorkspace.
	displayName := object name.
	^ displayName 
		ifNotNil: [ | name |
			name := displayName asIdentifier: false.
			(name size < 1)
			ifTrue: [ object class name asLowercase , object identityHash asString ]
			ifFalse: [ name at: 1 put:  (name at: 1) asLowercase. name ]
		] 
		ifNil: [ object class name asLowercase , object identityHash asString ]! !
!WorkspaceWindow methodsFor: 'menu' stamp: 'jmv 11/10/2017 11:10:18' prior: 16945502!
          addCustomMenuItems: aCustomMenu hand: aHandMorph
	super addCustomMenuItems: aCustomMenu hand: aHandMorph.
	aCustomMenu addLine.
	aCustomMenu
		add: 'reset variables'
		target: model
		action: #initializeBindings.
	aCustomMenu
		addUpdating: #mustDeclareVariableWording
		target: model
		action: #toggleVariableDeclarationMode.
	aCustomMenu
		addUpdating: #toggleStylingLabel
		target: model
		action: #toggleStyling! !
!WorkspaceWindow methodsFor: 'menu' stamp: 'jmv 11/10/2017 11:10:38' prior: 16945530!
       offerWindowMenu
	| aMenu |
	aMenu _ self buildWindowMenu.
	aMenu addLine.
	aMenu
		add: 'reset variables'
		target: model
		action: #initializeBindings.
	aMenu
		addUpdating: #mustDeclareVariableWording
		target: model
		action: #toggleVariableDeclarationMode.
	aMenu
		addUpdating: #toggleStylingLabel
		target: model
		action: #toggleStyling.
	aMenu popUpInWorld: self world! !
!WorkspaceWindow methodsFor: 'drag n drop' stamp: 'jmv 11/10/2017 11:09:41' prior: 16945548!
       allowsMorphDrop
	"Answer whether we accept dropping morphs. By default answer false."

	^ true! !
!WorkspaceWindow methodsFor: 'drag n drop' stamp: 'jmv 11/10/2017 11:17:29' prior: 16945554!
 wantsDroppedMorph: aMorph event: evt
	"Dropping a morph on my window means:
  	    display exteral name for aMorph in Workspace
	    add a binding from name to aMorph
	    and rejecting the drop."
	
	| objectName textModelMorph object |
	objectName := aMorph nameForWorkspace.
	object _ aMorph objectForWorkspace.
	textModelMorph := self layoutMorph submorphs at: 1.
	
	(self model  bindingOf: objectName) value: object.
	textModelMorph editor afterSelectionInsertAndSelect: objectName , ' '.
	"send aMorph back to original position"
	evt isNil ifFalse: [ evt wasHandled: true ]. 
	"Short circuit"
	aMorph rejectDropMorphEvent: evt.
	
	^ false ! !

WorkspaceWindow removeSelector: #allowsMorphDropWording!

WorkspaceWindow removeSelector: #allowsMorphDropWording!

WorkspaceWindow removeSelector: #initialize!

WorkspaceWindow removeSelector: #initialize!

WorkspaceWindow removeSelector: #toggleAcceptDroppedMorphs!

WorkspaceWindow removeSelector: #toggleAcceptDroppedMorphs!

SystemWindow subclass: #WorkspaceWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!classDefinition: #WorkspaceWindow category: #'Morphic-Tools'!
SystemWindow subclass: #WorkspaceWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3209-InspectorExplorerDnDOnWorkspace-JuanVuletich-2017Nov10-11h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3209] on 12 November 2017 at 9:07:35 pm'!
!Morph methodsFor: 'accessing - properties' stamp: 'jmv 11/12/2017 20:56:19'!
                 objectsForWorkspace
	^{self}! !
!InspectorWindow methodsFor: 'accessing' stamp: 'jmv 11/12/2017 21:00:55'!
                     objectsForWorkspace
	^{self. model object. model selection}! !
!ObjectExplorerWindow methodsFor: 'accessing' stamp: 'jmv 11/12/2017 21:00:29'!
                 objectsForWorkspace
	^{self. model rootObject. model object}! !
!WorkspaceWindow methodsFor: 'drag n drop' stamp: 'jmv 11/12/2017 20:57:38'!
                   nameForObject: object
	"Answer a name suitable for a Workspace variable"
	object name ifNotNil: [ :displayName |
		^displayName asIdentifier: false ].
	^ object class name asLowercase , object identityHash asString! !
!WorkspaceWindow methodsFor: 'drag n drop' stamp: 'jmv 11/12/2017 20:44:49' prior: 50375096!
         allowsMorphDrop
	"Answer whether we accept dropping morphs. Workspaces always accept drops.
	Regular morphs are inserted in the text.
	Inspectors and Explorers generate workspace variables referencing the inspected object(s.)"

	^ true! !
!WorkspaceWindow methodsFor: 'drag n drop' stamp: 'jmv 11/12/2017 21:05:37' prior: 50375102!
                    wantsDroppedMorph: aMorph event: evt
	"Dropping a morph on my window means:
  	    display exteral name for aMorph in Workspace
	    add a binding from name to aMorph
	    and rejecting the drop."
	
	| textModelMorph |
	textModelMorph := self layoutMorph submorphs at: 1.
	aMorph objectsForWorkspace do: [ :object | | objectName |
		objectName _ self nameForObject: object.
		(self model bindingOf: objectName) value: object.
		textModelMorph editor afterSelectionInsertAndSelect: String newLineString, objectName , '. ' ].
	"send aMorph back to original position"
	evt isNil ifFalse: [ evt wasHandled: true ]. 
	"Short circuit"
	aMorph rejectDropMorphEvent: evt.
	
	^ false ! !

ObjectExplorerWindow removeSelector: #objectForWorkspace!

ObjectExplorerWindow removeSelector: #objectForWorkspace!

InspectorWindow removeSelector: #objectForWorkspace!

InspectorWindow removeSelector: #objectForWorkspace!

Morph removeSelector: #nameForWorkspace!

Morph removeSelector: #nameForWorkspace!

Morph removeSelector: #objectForWorkspace!

Morph removeSelector: #objectForWorkspace!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3210-DnDOnWorkspaceEnhancements-JuanVuletich-2017Nov12-20h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3210] on 12 November 2017 at 10:28:26 pm'!
!BlockClosure methodsFor: 'lambda calculus' stamp: 'jmv 11/12/2017 22:27:40'!
             curried
	"
	https://en.wikipedia.org/wiki/Currying
	[ :a :b | a + b ] value: 1 value: 2
	[ :a :b | a + b ] curried value: 1 :: value: 2
	"
	^self argumentCount caseOf: {
		[ 1] -> [[ :arg1 | [ self value: arg1 ]]].
		[ 2] -> [[ :arg1 | [ :arg2 | self value: arg1 value: arg2 ]]].
		[ 3] -> [[ :arg1 | [ :arg2 :arg3 | self value: arg1 value: arg2 value: arg3 ]]].
		[ 4] -> [[ :arg1 | [ :arg2 :arg3 :arg4 | self value: arg1 value: arg2 value: arg3 value: arg4 ]]] }
	otherwise: [ self halt ]! !
!BlockClosure methodsFor: 'lambda calculus' stamp: 'jmv 11/12/2017 22:27:57'!
    withFirstArg: arg1
	"
	https://en.wikipedia.org/wiki/Partial_application

	[ :a :b | a + b ] value: 1 value: 2
	[ :a :b | a + b ] withFirstArg: 1
	([ :a :b | a + b ] withFirstArg: 1) value: 2
	([ :a :b | a + b ] withFirstArg: 1) withFirstArg: 2
	(([ :a :b | a + b ] withFirstArg: 1) withFirstArg: 2) value

	([ :a :b | a - b ] withFirstArg: 1) value: 2
	"
	^self argumentCount caseOf: {
		[ 1] -> [[ self value: arg1 ]].
		[ 2] -> [[ :arg2 | self value: arg1 value: arg2 ]].
		[ 3] -> [[ :arg2 :arg3 | self value: arg1 value: arg2 value: arg3 ]].
		[ 4] -> [[ :arg2 :arg3 :arg4 | self value: arg1 value: arg2 value: arg3 value: arg4 ]] }
	otherwise: [ self halt ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3211-lambdaCalculusToys-JuanVuletich-2017Nov12-22h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3211] on 14 November 2017 at 2:06:38 pm'!
!DisplayScreen methodsFor: 'other' stamp: 'jmv 11/14/2017 14:04:10' prior: 16835265!
         restoreAfter: aBlock
	"
	- Evaluate the block
	- Update host OS Display
	- Wait for a mouse click
	- And then restore the Morphic World"

	aBlock value.
	self forceToScreen.
	Sensor waitButton.
	self runningWorld ifNotNil: [ :w | w fullRepaintNeeded ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3212-restoreAfter-fix-JuanVuletich-2017Nov14-14h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3212] on 19 November 2017 at 11:38:44 am'!
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 11/19/2017 11:33:31' prior: 50363260!
                       initialExtent

	^`540@400` * Preferences standardCodeFont height // 14! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 11/19/2017 11:34:12' prior: 50363264!
                     initialExtent
	^`540@300` * Preferences standardCodeFont height // 14! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 11/19/2017 11:36:45' prior: 50363268!
                          initialExtent
	^ `640 @ 320` * Preferences standardCodeFont height // 14! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 11/19/2017 11:36:58' prior: 50363272!
                      initialExtent

	^`600@325` * Preferences standardCodeFont height // 14! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 11/19/2017 11:37:06' prior: 50363276!
                   initialExtent

	^`300@500` * Preferences standardCodeFont height // 14! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 11/19/2017 11:25:32' prior: 16863061!
  adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint
	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth |
	i _ submorphs indexOf: aLayoutAdjustMorph.
	l _ self submorphs at: i +1.
	ls _ l layoutSpec.
	lCurrentWidth _ l morphWidth max: 1.	"avoid division by zero"
	r _ self submorphs at: i - 1.
	rs _ r layoutSpec.
	rCurrentWidth _ r morphWidth max: 1.	"avoid division by zero"
	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.
	delta _ delta max: l minPaneWidthForReframe - lCurrentWidth.
	delta _ delta min: rCurrentWidth - r minPaneWidthForReframe.
	delta = 0 ifTrue: [ ^self ].
	rNewWidth _ rCurrentWidth - delta.
	lNewWidth _ lCurrentWidth + delta.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [	"If both proportional, update them"
			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).
			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 11/19/2017 11:27:34' prior: 16863565!
                           minPaneWidthForReframe

	^(self submorphs collect: [ :m | m minimumExtent x ]) max! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3213-FixColumnarResize-JuanVuletich-2017Nov19-11h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3213] on 19 November 2017 at 11:43:25 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 11/19/2017 11:43:05' prior: 50335858!
    knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 					'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('BenComan' 			'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 					'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 					'Doug Way')
	#('dgd' 					'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhn'	 				'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DM' 					'Duncan Mak')
	#('DSM' 					'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 					'Hari Balaraman')
	#('hjh' 					'Hannes Hirzel')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 					'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 					'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 					'Mike Rutenberg')
	#('mga' 					'Markus Galli')
	#('mha' 					'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 					'Peter Keeler')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 					'Paul McDonough')
	#('r++' 					'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 					'Ron Teitelbaum')
	#('rr' 						'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 					'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 					'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 					'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sqr' 					'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 					'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 					'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 					'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3214-AddJavierAsKnownAuthor-JuanVuletich-2017Nov19-11h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3207] on 18 November 2017 at 2:30:36 pm'!
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'JO 11/18/2017 14:28:55' prior: 50368267!
                   buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Package Name');
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' File Name');
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: self buildButtonPane fixedHeight: Theme current buttonPaneHeight;
		addAdjusterAndMorph: summary fixedHeight: 60;
		addAdjusterAndMorph: description proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.15.
	self setLabel: 'Installed Packages'! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3215-CodePackageListWindow-cleanup-JavierOlaechea-2017Nov18-14h22m-JO.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3208] on 19 November 2017 at 12:34:29 am'!
!ChangeSorterWindow class methodsFor: 'instance creation' stamp: 'JO 11/18/2017 23:13:44' prior: 16800331!
                           openChangeSorter
	self
		open: ChangeSorter new
		label: nil.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'JO 11/18/2017 22:23:10' prior: 16934823!
     changesMenu
        "Build the changes menu for the world."

	| menu |
	menu _ self menu: 'Changes...'.
	self fillIn: menu from: {
		{ 'Change Sorter' . {ChangeSorterWindow. #openChangeSorter}.  'Open a 3-paned changed-set viewing tool'}.
		nil.

		{ 'Install New Updates' . { ChangeSet. #installNewUpdates }.
'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'}.
		nil.

		{ 'Browse my Changes' . { Smalltalk . #browseMyChanges }.
				'Browse all of my changes since the last time #condenseSources was run.'}.
		{ 'Recently logged Changes...' . { ChangeList . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.

		nil.
		{ 'Save World as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.
	}.
	^ menu! !

TheWorldMenu removeSelector: #openChangeSorter1!

TheWorldMenu removeSelector: #openChangeSorter1!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3216-WorldMenu-cleanup-JavierOlaechea-2017Nov18-22h23m-JO.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3212] on 21 November 2017 at 3:19:55 am'!

Object immediateSubclass: #Character
	instanceVariableNames: 'value '
	classVariableNames: 'CharacterTable ClassificationTable LetterBits LowercaseBit UnaccentedTable UnicodeCodePoints UppercaseBit LetterTruthTable UppercaseTruthTable LowercaseTruthTable LowercaseMappingTable UppercaseMappingTable '
	poolDictionaries: ''
	category: 'Kernel-Text'!
!Character class methodsFor: 'class initialization' stamp: 'pb 11/21/2017 02:38:24'!
                            initializeLookupTables
	LowercaseMappingTable _ Array new: 256.
	LowercaseTruthTable _ Array new: 256.
	UppercaseMappingTable _ Array new: 256.
	UppercaseTruthTable _ Array new: 256.
	LetterTruthTable _ Array new: 256.
	UnaccentedTable _ ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char _ self numericValue: idx.
			LowercaseMappingTable
				at: idx + 1
				put: char.
			LowercaseTruthTable
				at: idx + 1
				put: false.
			UppercaseMappingTable
				at: idx + 1
				put: char.
			UppercaseTruthTable
				at: idx + 1
				put: false.
			LetterTruthTable
				at: idx + 1
				put: false.
			UnaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		group size > 1
			ifTrue: [ | lowercaseChar uppercaseChar |
				uppercase _ group first numericValue.
				lowercase _ group second numericValue.
				lowercaseChar _ self numericValue: lowercase.
				uppercaseChar _ self numericValue: uppercase.
				LowercaseMappingTable
					at: lowercase + 1
					put: lowercaseChar.
				LowercaseMappingTable
					at: uppercase + 1
					put: lowercaseChar.
				LowercaseTruthTable
					at: lowercase + 1
					put: true.
				LetterTruthTable
					at: lowercase + 1
					put: true.
				UppercaseMappingTable
					at: lowercase + 1
					put: uppercaseChar.
				UppercaseMappingTable
					at: uppercase + 1
					put: uppercaseChar.
				UppercaseTruthTable
					at: uppercase + 1
					put: true.
				LetterTruthTable
					at: uppercase + 1
					put: true.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase _ group third numericValue.
						unaccentedLowercase _ group fourth numericValue.
						UnaccentedTable at: uppercase+1 put: unaccentedUppercase.
						UnaccentedTable at: lowercase+1 put: unaccentedLowercase]]
			ifFalse: [ | lowercaseChar |
				lowercase _ group first numericValue.
				lowercaseChar _ self numericValue: lowercase.
				LowercaseMappingTable
					at: lowercase + 1
					put: lowercaseChar.
				UppercaseMappingTable
					at: lowercase + 1
					put: lowercaseChar.
				LowercaseTruthTable
					at: lowercase + 1
					put: true.
				UppercaseTruthTable
					at: lowercase + 1
					put: false.
				LetterTruthTable
					at: lowercase + 1
					put: true ]].! !
!Character class methodsFor: 'class initialization' stamp: 'pb 11/21/2017 02:24:51' prior: 16800735!
     initClassCachedState
	"Create the table of unique Characters.
	Character initialize
	"
	self initializeClassificationTable.
	self initializeLookupTables .
	self initializeUnicodeCodePoints.! !
!Character class methodsFor: 'fileIn/Out' stamp: 'pb 11/21/2017 02:26:23' prior: 16801502!
    definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Object immediateSubclass: #Character
	instanceVariableNames: ''value''
	classVariableNames: ''CharacterTable ClassificationTable LetterBits LowercaseBit UnaccentedTable UnicodeCodePoints UppercaseBit LowercaseMappingTable LowercaseTruthTable UppercaseMappingTable UppercaseTruthTable LetterTruthTable''
	poolDictionaries: ''''
	category: ''Kernel-Text'''! !

Object immediateSubclass: #Character
	instanceVariableNames: 'value'
	classVariableNames: 'CharacterTable ClassificationTable LetterBits LowercaseBit UnaccentedTable UnicodeCodePoints UppercaseBit LowercaseMappingTable LowercaseTruthTable UppercaseMappingTable UppercaseTruthTable LetterTruthTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3217-Character-lookup-tables-stage1-PhilBellalouna-2017Nov21-00h32m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3212] on 21 November 2017 at 3:19:55 am'!
!Character methodsFor: 'testing' stamp: 'pb 11/21/2017 02:29:43' prior: 16800489!
        isLetter
	"Answer whether the receiver is a letter."
	^ LetterTruthTable at: self numericValue + 1! !
!Character methodsFor: 'testing' stamp: 'pb 11/21/2017 02:24:10' prior: 16800504!
        isLowercase
	"Answer whether the receiver is a lowercase letter."
	^ LowercaseTruthTable at: self numericValue + 1.! !
!Character methodsFor: 'testing' stamp: 'pb 11/21/2017 02:24:25' prior: 16800531!
                       isUppercase
	"Answer whether the receiver is an uppercase letter."
	^ UppercaseTruthTable at: self numericValue + 1.! !
!Character methodsFor: 'converting' stamp: 'pb 11/21/2017 02:22:41' prior: 16800596!
                   asLowercase
	^ LowercaseMappingTable at: self numericValue + 1.! !
!Character methodsFor: 'converting' stamp: 'pb 11/21/2017 02:23:38' prior: 16800628!
        asUppercase
	"If the receiver is lowercase, answer its matching uppercase Character."
	^ UppercaseMappingTable at: self numericValue + 1.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3218-Character-lookup-tables-stage2-PhilBellalouna-2017Nov21-00h32m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3214] on 21 November 2017 at 3:34:57 am'!
!Character class methodsFor: 'class initialization' stamp: 'pb 11/21/2017 03:33:45' prior: 50375805!
                          initClassCachedState
	"Create the table of unique Characters.
	Character initialize
	"
	self initializeLookupTables .
	self initializeUnicodeCodePoints.! !

Character class removeSelector: #initializeClassificationTable!

Character class removeSelector: #initializeClassificationTable!
!Character class methodsFor: 'fileIn/Out' stamp: 'pb 11/21/2017 03:34:29' prior: 50375814!
       definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Object immediateSubclass: #Character
	instanceVariableNames: ''value''
	classVariableNames: ''CharacterTable UnaccentedTable UnicodeCodePoints LowercaseMappingTable LowercaseTruthTable UppercaseMappingTable UppercaseTruthTable LetterTruthTable''
	poolDictionaries: ''''
	category: ''Kernel-Text'''! !

Object immediateSubclass: #Character
	instanceVariableNames: 'value'
	classVariableNames: 'CharacterTable UnaccentedTable UnicodeCodePoints LowercaseMappingTable LowercaseTruthTable UppercaseMappingTable UppercaseTruthTable LetterTruthTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character initialize!

Smalltalk recreateSpecialObjectsArray!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3219-Character-lookup-tables-stage3-PhilBellalouna-2017Nov21-03h32m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3207] on 19 November 2017 at 12:42:52 pm'!
!Float commentStamp: 'jmv 11/19/2017 12:42:42' prior: 50372885!
   A note About Floating Point numbers and Floating Point Arithmetic.

The following is not specific to Cuis or Smalltalk at all. This is about the properties of Float numbers in any computer implementation.

If you haven't done so already, read https://en.wikipedia.org/wiki/Floating-point_arithmetic

But if you find the Wikipedia article too detailed, or hard to read, then try http://fabiensanglard.net/floating_point_visually_explained/ (get past "How Floating Point are usually explained" and read "A different way to explain...").

Other great reads are:
	"Why don't my numbers add up?":
		http://floating-point-gui.de/
and
	"What Every Computer Scientist Should Know About Floating-Point Arithmetic":
		http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
and also maybe
	"Comparing floating point numbers"
		https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

Now that you read them, and we are on the same boat, some further comments (from jmv):

Floats are (conceptually) approximate real numbers. That's why trig and other trascendental functions always answer Floats. That's why it is ok to round the result of operations. That's why Float is considered more general than Fraction in ST-80 and most Smalltalks. So, when we have a Float value, we must not think about it as a Rational but as a Real (actually as some unknown Real that could hopefully be close to the Rational we can actually represent). Keep this in mind when dealing with Floats, and especially avoid comparing them for equality.

When doing mixed operations with Floats and Fractions, Cuis, as most other Smalltalks, converts all values to Floats. Some other systems, including Pharo Smalltalk, Scheme and Lisp have two rules: when the answer is a Number, they convert to Float. But when the answer is a boolean (#<, #=, #<=, etc.) they convert to Fraction. We think this is a mistake. There should never be implicit conversions from Float to Fraction. Fractions are to hold exact values, and people expect Fractions to be exact. On the other hand, Floats are to hold approximations (and people should be aware of that!!). But an implicit conversion from Float to Fraction would give a Fraction that should not be considered an exact value (the value comes from an inexact Float), but that knowledge is lost, as it is an instance of Fraction.

If you want exact arithmetic, usual mathematical properties (like transitivity of equality), can live in the limited world of Rational numbers, and can afford a slight performance penalty, use Fraction instead. Avoid trascendental functions and never convert to Float.

In any case, most numeric computation is done on Float numbers. There are good reasons for that. One is that in most cases we don't need an exact answer. And in many cases we can't really have it: the inputs to algorithms already have a limited precision, or they use trascendental functions. And even when exact arithmetic possible, if we are doing sound synthesis, 24 bits of resolution is enough. For image processing and graphics, the result is never more than 16 bits per channel. So, these fields don't really need 64 bit Doubles. 32 bit Floats are enough. Other fields do need 64 bit Doubles, like physics simulations and geometry. Games usually prefer special, faster 32 bit Float operations in GPUs that have greater errors but are faster.

There are some things that can be done to increase the confidence you can have on Float results. One is to do an error propagation analysis on the code you are running. This is not easy, but it is done for any widely used numerical method. Then, you can know real bounds and/or estimates of the errors made. So, understanding your inputs and your algorithms (for example error propagation, condition number, numeric stability), and using Float number if appropriate, is the usual advice.

Perhaps you have heard about "interval arithmetic". It is a bit better than simple Float, but doesn't really fix the problems.

The ultimate solution is to do Monte Carlo analysis, with random perturbation of inputs. After the Monte Carlo run, it is needed to do statistical analysis of possible correlations between the distributions of the random noise added to imputs and the result of the algorithm.

Additional food for thought: http://www.cs.berkeley.edu/~wkahan/Mindless.pdf . According to this, doing Monte Carlo as described above attacks a slightly different problem. This might be yet another reason (besides performance) to try something like the next paragraph. I (jmv) came up with it, and I don't really know if it has been described and or tried before or not. Mhhh. Maybe a defensive publication is in order.

A possibility that could be a practical solution, being much cheaper than Monte Carlo, but better than interval arithmetic, is to represent each value by 2 Floats: an estimation of the real value (i.e. an estimation of the mean value of the distribution of the corresponding Monte Carlo result), and an estimation of the error (i.e. an estimation of the standard deviation of the corresponding Monte Carlo result). Or perhaps even 3 of them. In addition to the estimation of the real value and an estimation of the error, we could add a hard bound on the error. In many cases it will be useless, because the error can not really be bound. But in those cases where it is possible to bound it, applications could really know about the quality of computed values.

=======================================================================

My instances represent IEEE-754 floating-point double-precision numbers. They have about 16 decimal digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:
	
	8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12

Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:

	3r20.2 --> 6.66666666666667
	8r20.2 --> 16.25

If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...
	sign		1 bit
	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent
						in the range -1023 .. +1024
				- 16r000:
					significand = 0: Float zero
					significand ~= 0: Denormalized number (exp = -1024, no hidden '1' bit)
				- 16r7FF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.

The single-precision format is...
	sign		1 bit
	exponent	8 bits, with bias of 127, to represent -126 to +127
                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)
                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)
	mantissa	24 bits, but only 23 are stored
This format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.

You might also check https://en.wikipedia.org/wiki/IEEE_754_revision

Other great reads (covering broader but interesting issues):
https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
http://www.ima.umn.edu/2010-2011/W1.10-14.11/activities/Leeser-Miriam/Leeser-GPU-IMA-Jan2011.pdf!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3220-FloatCommentTweaks-JuanVuletich-2017Nov19-12h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3220] on 24 November 2017 at 12:18:25 pm'!
!SystemWindow methodsFor: 'accessing' stamp: 'jmv 11/24/2017 12:06:15'!
     objectsForWorkspace
	^{}! !
!InspectorWindow methodsFor: 'accessing' stamp: 'jmv 11/24/2017 12:16:02' prior: 50375158!
         objectsForWorkspace
	| root sel |
	root _ model object.
	sel _ model selection.
	(root == sel or: [ model contentsIsString ]) ifTrue: [
		^{root} ].
	^{root. sel }! !
!ObjectExplorerWindow methodsFor: 'accessing' stamp: 'jmv 11/24/2017 12:17:16' prior: 50375163!
                         objectsForWorkspace
	| root sel |
	root _ model rootObject.
	sel _ model object.
	(root == sel or: [ sel isNil ]) ifTrue: [
		^{root} ].
	^{root. sel }! !
!WorkspaceWindow methodsFor: 'drag n drop' stamp: 'jmv 11/24/2017 12:08:35' prior: 50375189!
        wantsDroppedMorph: aMorph event: evt
	"Dropping a morph on my window means:
  	    display exteral name for aMorph in Workspace
	    add a binding from name to aMorph
	    and rejecting the drop."
	
	| textModelMorph addedBindings |
	textModelMorph := self layoutMorph submorphs at: 1.
	addedBindings _ false.
	aMorph objectsForWorkspace do: [ :object | | objectName |
		addedBindings _ true.
		objectName _ self nameForObject: object.
		(self model bindingOf: objectName) value: object.
		textModelMorph editor afterSelectionInsertAndSelect: String newLineString, objectName , '. ' ].
	addedBindings ifTrue: [
		"send aMorph back to original position"
		evt isNil ifFalse: [ evt wasHandled: true ]. 
		"Short circuit"
		aMorph rejectDropMorphEvent: evt ].
	
	^ false ! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3221-DropOnWorkspaceEnh-JuanVuletich-2017Nov24-12h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3221] on 26 November 2017 at 5:12:13 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 11/26/2017 17:11:34'!
                     minPaneWidthForReframe
	^ self minimumExtent x! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3222-FixDNUOnColumnResize-JuanVuletich-2017Nov26-17h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3222] on 28 November 2017 at 3:11:44 pm'!
!Object methodsFor: 'inspecting' stamp: 'jmv 11/28/2017 15:08:54'!
  copyToClipboard
	"Create and schedule an Inspector in which the user can examine the receiver's variables."

	Clipboard storeObject:  self! !
!TextModel methodsFor: 'testing' stamp: 'jmv 11/28/2017 14:52:16'!
               canBindVariables
	^ false! !
!Workspace methodsFor: 'variable declarations' stamp: 'jmv 11/28/2017 14:56:27'!
                  nameForObject: object
	"Answer a name suitable for a Workspace variable"
	object name ifNotNil: [ :displayName |
		^displayName asIdentifier: false ].
	^ object class name asLowercase , object identityHash asString! !
!Workspace methodsFor: 'testing' stamp: 'jmv 11/28/2017 14:52:28'!
   canBindVariables
	^ true! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/28/2017 14:57:38'!
                     paste
	| object objectName |
	model canBindVariables ifTrue: [
		object _ Clipboard retrieveObject.
		objectName _ model nameForObject: object.
		(model bindingOf: objectName) value: object.
		self replaceSelectionWith: objectName.
		^ self ].
	^ super paste! !
!InspectorWindow methodsFor: 'menu commands' stamp: 'jmv 11/28/2017 14:47:12'!
           copySelectionToClipboard
	"For example, for pasting a reference in a Workspace"

	Clipboard storeObject: model selection! !
!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 11/28/2017 14:47:30'!
                copySelectionToClipboard
	"For example, for pasting a reference in a Workspace"

	Clipboard storeObject: model object! !
!Editor methodsFor: 'menu messages' stamp: 'jmv 12/19/2011 12:24' prior: 16836376!
                    paste
	"Paste the text from the shared buffer over the current selection and 
	redisplay if necessary."

	self replaceSelectionWith: self clipboardStringOrText! !
!Morph methodsFor: 'debug and other' stamp: 'jmv 11/28/2017 15:07:24' prior: 16874207!
      buildDebugMenu: aHand 
	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"

	| aMenu |
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addStayUpIcons.
	self isKnownFailing
		ifTrue: [
			aMenu add: 'start drawing again' action: #resumeAfterDrawError.
			aMenu addLine].
	(self hasProperty: #errorOnStep) 
		ifTrue: [
			aMenu add: 'start stepping again' action: #resumeAfterStepError.
			aMenu addLine].
	aMenu add: 'inspect morph' action: #inspect.
	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.
	self hasModel 
		ifTrue: [
			aMenu 
				add: 'inspect model'
				target: self model
				action: #inspect].
	aMenu 
		add: 'explore morph'
		target: self
		selector: #explore.
	aMenu 
		add: 'copy to clipboard (c)'
		target: self
		selector: #copyToClipboard.
	aMenu addLine.
	aMenu 
		add: 'browse morph class'
		target: self
		selector: #browseClassHierarchy.
	self hasModel 
		ifTrue: [
			aMenu 
				add: 'browse model class'
				target: self model
				selector: #browseClassHierarchy].
	aMenu addLine.
	aMenu
		add: 'edit balloon help' action: #editBalloonHelpText.
	^aMenu! !
!InspectorWindow methodsFor: 'menu building' stamp: 'jmv 11/28/2017 14:44:33' prior: 16857251!
                      fieldListMenu
	"Arm the supplied menu with items for the field-list of the receiver"

	| aMenu object |
	aMenu _ MenuMorph new defaultTarget: self.

	aMenu addList: #(
		('inspect (i)'							inspectSelection)
		('explore (I)'							exploreSelection)
		('copy to clipboard (c)'				copySelectionToClipboard)
		('basic inspect'						inspectBasic)
		('references finder'					openReferencesFinder)
		('weight explorer'					openWeightExplorer)).

	object _ model object.
	(object is: #Dictionary) ifTrue: [ aMenu addList: #(
		-
		('senders of this key'				sendersOfSelectedKey)
		('add key'								addEntry)
		('rename key'							renameEntry)
		('remove'								removeSelection			''		model)) ]
	
	ifFalse: [ (object is: #Set) ifTrue: [ aMenu addList: #(
		-
		('remove'								removeSelection			''		model))]].

	aMenu addList: #(
		-
		('browse full (b)'						browseMethodFull)
		('browse hierarchy (h)'				browseHierarchy)
		('browse protocol (p)'				browseFullProtocol)).
	^ aMenu! !
!ObjectExplorerWindow methodsFor: 'building menus' stamp: 'jmv 11/28/2017 14:45:17' prior: 16883322!
      genericMenu
	"Borrow a menu from my inspector"
	
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	model getCurrentSelection
		ifNil: [
			aMenu
				add: '*nothing selected*'
				target: self
				selector: #yourself]
		ifNotNil: [
			aMenu addList: #(
				('inspect (i)'							inspectSelection)
				('explore (I)'							exploreSelection)
				('copy to clipboard (c)'				copySelectionToClipboard)
				('basic inspect'						inspectBasic)
				('references finder'					openReferencesFinder)
				('weight explorer'					openWeightExplorer)
				-
				('browse full (b)'						browseMethodFull)
				('browse hierarchy (h)'				browseHierarchy)
				('browse protocol (p)'				browseFullProtocol)).
			aMenu addLine;
				add: 'monitor changes'
				target: self
				selector: #monitor:
				argument: model getCurrentSelection.
			model class == ReferencesExplorer ifTrue: [
				aMenu addLine;
					add: 'rescan'
					target: self
					selector: #rescan ]].
	model basicMonitorList isEmptyOrNil
		ifFalse: [
			aMenu addLine;
				add: 'stop monitoring all'
				target: self
				selector: #stopMonitoring ].
	^ aMenu! !
!Theme methodsFor: 'menus' stamp: 'jmv 11/28/2017 14:43:40' prior: 50344057!
                             basicIcons

	"Minimal menu scheme.
	Theme current class beCurrent
	"

	^ { 
		#('open...') -> #openIcon.
		#('windows...' 'find window' 'Focus follows mouse' 'Click to focus') -> #windowIcon.
		#('help...' 'explain' 'about this system...' 'Terse Guide to Cuis' 'Class Comment Browser' 'Code management in Cuis' 'Using GitHub to host Cuis packages' ) -> #helpIcon.
		#('themes...') -> #appearanceIcon.
		#('do it (d)') -> #doItIcon.
		#('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon.
		#('save' ) -> #saveIcon.
		#('Save options...' 'save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon.
		#('save as new version') -> #saveAsNewVersionIcon.
		#('quit') -> #quitIcon.
		#('save and quit' ) -> #saveAndQuitIcon.
		#('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher' 'stop CPUWatcher')
			-> #inspectIcon.
		#('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'references finder' 'weight explorer' 'explore CompiledMethod') -> #exploreIcon.
		#('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon.
		#('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon.
		#('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript') -> #deleteIcon.
		#('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete') -> #warningIcon.
		#('do again (j)' 'Redo - multiple (Z)') -> #redoIcon.
		#('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon.
		#('copy to clipboard (c)' 'copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon.
		#('paste (v)' 'Paste without Format') -> #pasteIcon.
		#('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon.
		#('paste...' 'icons...') -> #worldIcon.
}! !

WorkspaceWindow removeSelector: #allowsMorphDrop!

WorkspaceWindow removeSelector: #allowsMorphDrop!

WorkspaceWindow removeSelector: #nameForObject:!

WorkspaceWindow removeSelector: #nameForObject:!

WorkspaceWindow removeSelector: #wantsDroppedMorph:event:!

WorkspaceWindow removeSelector: #wantsDroppedMorph:event:!

ObjectExplorerWindow removeSelector: #objectsForWorkspace!

ObjectExplorerWindow removeSelector: #objectsForWorkspace!

InspectorWindow removeSelector: #objectsForWorkspace!

InspectorWindow removeSelector: #objectsForWorkspace!

SystemWindow removeSelector: #objectsForWorkspace!

SystemWindow removeSelector: #objectsForWorkspace!

Morph removeSelector: #objectsForWorkspace!

Morph removeSelector: #objectsForWorkspace!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current class beCurrent!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3223-UseClipboardToAddObjectsToWorkspaces-JuanVuletich-2017Nov28-14h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3223] on 28 November 2017 at 3:28:20 pm'!
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 11/28/2017 15:27:34' prior: 16840895!
                       inPackagesSubtreeOf: aDirectoryEntry do: aBlock

	| pckDir morphicExamplesPckDir compatPckDir |

	"Look in the requested directory"
	aBlock value: aDirectoryEntry.

	"Look in the usual Packages subfolders"
	pckDir _ aDirectoryEntry / 'Packages'.
	pckDir exists ifTrue: [
		aBlock value: pckDir ].
	morphicExamplesPckDir _ pckDir / 'MorphicExamples'.
	morphicExamplesPckDir exists ifTrue: [
		aBlock value: morphicExamplesPckDir ].
	compatPckDir _ aDirectoryEntry / 'CompatibilityPackages'.
	compatPckDir exists ifTrue: [
		aBlock value: compatPckDir ].

	"Finally look in folders that follow the convention of naming package repositories
	with the 'Cuis-Smalltalk' prefix, and their possible 'Packages' subdir."
	aDirectoryEntry children do: [ :entry |
		(entry isDirectory and: [ entry name beginsWith: 'Cuis-Smalltalk' ]) ifTrue: [
			aBlock value: entry.
			pckDir _ entry / 'Packages'.
			pckDir exists ifTrue: [
				aBlock value: pckDir ].
			morphicExamplesPckDir _ pckDir / 'MorphicExamples'.
			morphicExamplesPckDir exists ifTrue: [
				aBlock value: morphicExamplesPckDir ].
			compatPckDir _ entry / 'CompatibilityPackages'.
			compatPckDir exists ifTrue: [
				aBlock value: compatPckDir ]]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3224-AutoFindMorphicExamples-JuanVuletich-2017Nov28-15h27m-jmv.1.cs.st----!

----SNAPSHOT----#(28 November 2017 3:36:05.602441 pm) Cuis5.0-3224-v3.image priorSource: 1383469!

----QUIT----#(28 November 2017 3:36:18.803729 pm) Cuis5.0-3224-v3.image priorSource: 1438500!

----STARTUP----#(29 November 2017 12:06:29.460129 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3224-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3224] on 29 November 2017 at 11:59:54 am'!

Object subclass: #Clipboard
	instanceVariableNames: 'contents recent contentsOriginalObjectWeakly '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #Clipboard category: #'System-Support'!
Object subclass: #Clipboard
	instanceVariableNames: 'contents recent contentsOriginalObjectWeakly'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Support'!
!Clipboard methodsFor: 'accessing' stamp: 'jmv 11/29/2017 11:42:16'!
                        contentsOriginalObject
	"If not nil, the original object (not a copy!!) of what was stored in the clipboard. See #storeObject: Use with care"

	^ contentsOriginalObjectWeakly at: 1! !
!Clipboard class methodsFor: 'default clipboard' stamp: 'jmv 11/29/2017 11:42:25'!
                     contentsOriginalObject
	"If not nil, the original object (not a copy!!) of what was stored in the clipboard. See #storeObject: Use with care"

	^ self default contentsOriginalObject! !
!Object methodsFor: 'inspecting' stamp: 'jmv 11/29/2017 11:49:58' prior: 50376261!
                    copyToClipboard

	Clipboard storeObject: self! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/29/2017 11:55:10' prior: 50376285!
                paste
	| objectName |
	
	model canBindVariables ifTrue: [
		"Not a copy!!!!!!"
		Clipboard contentsOriginalObject ifNotNil: [ :object |
			objectName _ model nameForObject: object.
			(model bindingOf: objectName) value: object.
			self replaceSelectionWith: objectName.
			^ self ]].
	^ super paste! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 11/29/2017 11:36:45' prior: 16807752!
                            storeObject: anObject
	"Set new contents on the clipboard.  Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isString or: [ anObject is: #Text])
		ifTrue: [
			contents _ anObject withCuisLineEndings.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id _ self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat _ (self stringOrIdFor: contents) asUtf8: true.
	self primitiveClipboardString: primitiveFormat! !
!Clipboard methodsFor: 'initialization' stamp: 'jmv 11/29/2017 11:34:38' prior: 16807881!
                  initialize
	contents _ nil.
	contentsOriginalObjectWeakly _ WeakArray new: 1.
	recent _ OrderedCollection new.! !
!Morph methodsFor: 'copying' stamp: 'jmv 11/29/2017 11:51:04' prior: 16874187!
                               copyForClipboard
	"Some subclasses might need specific behavior..."

	self okayToDuplicate ifFalse: [ ^ nil ].
	^self copy! !
!Morph methodsFor: 'menus' stamp: 'jmv 11/29/2017 11:52:10' prior: 16876121!
                     addCopyItemsTo: aMenu 
	"Add copy-like items to the halo menu"

	| subMenu |
	subMenu := MenuMorph new defaultTarget: self.
	subMenu add: 'copy to clipboard (c)' action: #copyToClipboard:.
	aMenu add: 'copy & print...' subMenu: subMenu! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 11/29/2017 11:46:23' prior: 16876400!
                             copyToClipboard: evt
	self copyToClipboard! !

Object subclass: #Clipboard
	instanceVariableNames: 'contents recent contentsOriginalObjectWeakly'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #Clipboard category: #'System-Support'!
Object subclass: #Clipboard
	instanceVariableNames: 'contents recent contentsOriginalObjectWeakly'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Support'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Clipboard releaseClassCachedState!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3225-PasteOnWorkspaceFixes-JuanVuletich-2017Nov29-11h56m-jmv.1.cs.st----!

----SNAPSHOT----#(29 November 2017 12:06:36.507159 pm) Cuis5.0-3225-v3.image priorSource: 1438599!

----QUIT----#(29 November 2017 12:06:50.214237 pm) Cuis5.0-3225-v3.image priorSource: 1444121!

----STARTUP----#(15 December 2017 12:46:46.501118 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3225-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3225] on 30 November 2017 at 11:45:29 am'!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 11/30/2017 11:44:27'!
                              isDevelopmentEnvironmentPresent
	"Or we can't open a Smalltalk debugger"

	^ Smalltalk isHeadless not and: [Smalltalk includesKey: #Debugger]! !
!UnhandledError methodsFor: 'priv handling' stamp: 'jmv 11/30/2017 11:44:53' prior: 50373479!
                 defaultAction
	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."

	Smalltalk isDevelopmentEnvironmentPresent
		ifTrue: [ self devDefaultAction ]
		ifFalse: [ self standaloneAppDefaultAction ]! !

UnhandledError removeSelector: #isDevelopmentEnvironmentPresent!

UnhandledError removeSelector: #isDevelopmentEnvironmentPresent!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3226-isDevelopmentEnvironmentPresent-to-Smalltalk-JuanVuletich-2017Nov30-11h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3226] on 4 December 2017 at 10:51:49 am'!
!Form methodsFor: 'private' stamp: 'jmv 12/4/2017 10:09:15'!
                               hackBits64: bitThing
	"This method provides an initialization so that BitBlt may be used, eg, to 
	copy ByteArrays and other non-pointer objects efficiently.
	The resulting form looks 8 wide, 8 deep, and bitThing-size-in-words high."
	width _ 8.
	depth _ 8.
	bitThing class isBits ifFalse: [self error: 'bitThing must be a non-pointer object'].
	bitThing class isBytes
		ifTrue: [height _ bitThing basicSize // 8]
		ifFalse: [height _ bitThing basicSize // 2].
	bits _ bitThing! !
!BitBlt class methodsFor: 'byte and word utilities' stamp: 'jmv 12/4/2017 10:14:38'!
          swapBytesIn64BitWords: aNonPointerThing
	"Perform a bigEndian/littleEndian byte reversal of my 64 bit words.
	We only intend this for non-pointer arrays.  Do nothing if I contain pointers.

	| ba |
	ba := #[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] copy.
	BitBlt swapBytesIn64BitWords: ba.
	ba
	"

	self swapBytesIn64BitWords: aNonPointerThing from: 1 to: aNonPointerThing basicSize! !
!BitBlt class methodsFor: 'byte and word utilities' stamp: 'jmv 12/4/2017 10:13:45'!
           swapBytesIn64BitWords: aNonPointerThing from: start to: stop
	"Perform a bigEndian/littleEndian byte reversal of my 64 bit words.
	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."

	| hack blt |
	"The implementation is a hack, but fast for large ranges"
	hack _ Form new hackBits64: aNonPointerThing.
	blt _ (BitBlt toForm: hack) sourceForm: hack.
	blt combinationRule: Form reverse.  "XOR"
	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.

	"Exchange bytes 0 and 7"
	blt sourceX: 0; destX: 7; copyBits.
	blt sourceX: 7; destX: 0; copyBits.
	blt sourceX: 0; destX: 7; copyBits.

	"Exchange bytes 1 and 6"
	blt sourceX: 1; destX: 6; copyBits.
	blt sourceX: 6; destX: 1; copyBits.
	blt sourceX: 1; destX: 6; copyBits.

	"Exchange bytes 2 and 5"
	blt sourceX: 2; destX: 5; copyBits.
	blt sourceX: 5; destX: 2; copyBits.
	blt sourceX: 2; destX: 5; copyBits.

	"Exchange bytes 3 and 4"
	blt sourceX: 3; destX: 4; copyBits.
	blt sourceX: 4; destX: 3; copyBits.
	blt sourceX: 3; destX: 4; copyBits.! !
!BitBlt class methodsFor: 'byte and word utilities' stamp: 'jmv 12/4/2017 10:15:23'!
                   swapHalvesIn64BitWords: aNonPointerThing
	"Swap 32 bit halves in each 64 bit word.
	We only intend this for non-pointer arrays.  Do nothing if I contain pointers.

	| ba |
	ba := #[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16] copy.
	BitBlt swapHalvesIn64BitWords: ba.
	ba
	"

	self swapHalvesIn64BitWords: aNonPointerThing from: 1 to: aNonPointerThing basicSize! !
!BitBlt class methodsFor: 'byte and word utilities' stamp: 'jmv 12/4/2017 10:16:27'!
   swapHalvesIn64BitWords: aNonPointerThing from: start to: stop
	"Swap 32 bit halves in each 64 bit word.
	We only intend this for non-pointer arrays.  Do nothing if I contain pointers."

	| hack blt |
	"The implementation is a hack, but fast for large ranges"
	hack _ Form new hackBits64: aNonPointerThing.
	blt _ (BitBlt toForm: hack) sourceForm: hack.
	blt combinationRule: Form reverse.  "XOR"
	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 8.

	"Exchange bytes 0123 with 4567"
	blt sourceX: 0; destX: 4; copyBits.
	blt sourceX: 4; destX: 0; copyBits.
	blt sourceX: 0; destX: 4; copyBits! !
!Float64Array methodsFor: 'private' stamp: 'jmv 12/4/2017 10:51:19' prior: 16846148!
     swapWords
	"This could call #swapHalvesIn64BitWords:"
	| tmp |
	1 to: self size do: [ :i |
		tmp _ self rawBasicAt: i*2.
		self rawBasicAt: i*2 put: (self rawBasicAt: i*2-1).
		self rawBasicAt: i*2-1 put: tmp ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3227-byte-word-utilities-JuanVuletich-2017Dec04-10h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3227] on 4 December 2017 at 3:17:12 pm'!
!Float64Array commentStamp: '<historical>' prior: 16846050!
       FloatArrays store 64bit IEEE floating point numbers, i.e. instances of the Float class.
Some support is included for subclasses in the style of Balloon3D-Math.

Uses the same internal representation as Float. I.e. a Float and a Float64Array of size 1 hold the same bits. See #floatAt: and #floatAt:put:!
!Workspace methodsFor: 'variable declarations' stamp: 'jmv 12/4/2017 15:15:31' prior: 50376272!
                nameForObject: object
	"Answer a name suitable for a Workspace variable"
	^ object class name asLowercase , object identityHash asString! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3228-nameForObject-tweak-JuanVuletich-2017Dec04-15h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3228] on 6 December 2017 at 3:56:49 pm'!
!BitBltCanvas methodsFor: 'drawing-roundedRectangles' stamp: 'jmv 12/6/2017 15:41:29' prior: 16786942!
      windowFrame: aRectangle color: aColor radius: r border: bw labelHeight: lh gradientTop: topFactor gradientBottom: bottomFactor insideColor: insideColor
	"
	BitBltCanvas releaseClassCachedState.
	Display getCanvas windowFrame: (10@10 extent: 200@100) color: Color red radius: 10  border: 5 labelHeight: 25 gradientTop: 1.0 gradientBottom: 0.5 insideColor: Color green.
	Display forceToScreen
	"
	"top stripe"
	| bottomColor he tl tr |
	self
		image: (self class topLeftCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topLeft.
	self
		image: (self class topRightCorner: r height: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor
		at: aRectangle topRight - (r@0).
	self
		fillRectangle: ((aRectangle withHeight: lh) insetBy: r@0)
		tilingWith: (self class verticalGrayGradient: lh gradientTop: topFactor gradientBottom: bottomFactor)
		multipliedBy: aColor.

	bottomColor _ aColor * bottomFactor.

	"left and right borders"
	tl _ aRectangle topLeft + (0@lh).
	tr _ aRectangle topRight + (bw negated@lh).
	he _ bw@(aRectangle height - lh - r).
	self fillRectangle: (tl extent: he) color: bottomColor.
	self fillRectangle: (tr extent: he) color: bottomColor.
	
	"bottom stripe"
	self
		image: (self class bottomLeftCorner: r height: r gradientTop: 1 gradientBottom: 1 borderWidth: bw)
		multipliedBy: bottomColor
		at: aRectangle bottomLeft - (0@r).
	self
		image: (self class bottomRightCorner: r height: r gradientTop: 1 gradientBottom: 1 borderWidth: bw)
		multipliedBy: bottomColor
		at: aRectangle bottomRight - (r@r) .
	self fillRectangle: ((aRectangle bottomLeft + (r@bw negated)) extent: (aRectangle width - r - r@bw)) color: bottomColor.

	"inside"
	self fillRectangle: (aRectangle insetBy: (bw@lh corner: bw@bw)) color: insideColor! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3229-CommentTweak-JuanVuletich-2017Dec06-15h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3229] on 11 December 2017 at 11:54:23 am'!
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 11/2/2017 15:56:23' prior: 50370827!
       arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self getSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [
					oldSelection > self minimumSelection ifTrue: [
						nextSelection _ (oldSelection-1 to: 1 by: -1) detect: [ :i | ( scroller submorphs at: i) indentLevel < selectedMorph indentLevel ]].
					]]].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		WorldState addDeferredUIMessage: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3230-TreeView-keyboardNavigationEng-JuanVuletich-2017Dec11-11h51m-jmv.1.cs.st----!

----SNAPSHOT----#(15 December 2017 12:46:55.680103 pm) Cuis5.0-3230-v3.image priorSource: 1444221!

----QUIT----#(15 December 2017 12:47:13.212637 pm) Cuis5.0-3230-v3.image priorSource: 1454915!

----STARTUP----#(4 January 2018 5:56:24.197624 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3230-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3230] on 16 December 2017 at 6:16:14 pm'!
!MorphicCanvas commentStamp: 'jmv 12/16/2017 18:15:31' prior: 16877314!
A MorphicCanvas offers 2D drawing services. It works on a 'form', usually the Display. These services are used, for example, in #drawOn: methods.

Subclasses are specific implementations. BitBltCanvas is based on BitBlt, the raster operation invented by Dan Ingalls for Smalltalk, and included in Smalltalk-80 and Squeak. VectorCanvas is based on its VectorEngine, using a novel technique for the rasterization (sampling) of vector graphics, invented by Juan Vuletich.!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3231-MorphicCanvasComment-JuanVuletich-2017Dec16-18h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3231] on 26 December 2017 at 9:21:34 am'!
!CodePackage methodsFor: 'enumerating' stamp: 'jmv 12/26/2017 08:36:49'!
                        coreMethodsOf: aClass do: aBlock
	"Evaluate aBlock with the actual method objects in this package."

	aClass organization categories do: [ :cat |
		(self isForeignClassExtension: cat) ifFalse: [
			(aClass organization listAtCategoryNamed: cat) do: [ :s |
				aBlock value: (self referenceForMethod: s ofClass: aClass) ]]]! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 12/26/2017 08:39:58'!
                      writeCoreMethodsOf: aClass on: aStream

	self coreMethodsOf: aClass do: [ :methodReference |
		methodReference isValid
			ifTrue: [
				self writeMethod: methodReference on: aStream ]]! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 12/26/2017 08:52:22' prior: 16810579!
                write: classes methodsOn: aStream

	classes
		do: [ :class |
			self writeCoreMethodsOf: class on: aStream.
			self writeCoreMethodsOf: class class on: aStream ]
		displayingProgress: 'Saving methods...'! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 12/26/2017 09:07:44' prior: 16810632!
                             writeOnStream: aStream

	| sortedClasses |
	aStream
		nextChunkPut: ('Description ', description) printString;
		newLine.
	self writeFeatureSpecOn: aStream.
	self writeSystemCategoriesOn: aStream.
	sortedClasses _ Array streamContents: [ :strm |
		self classesInSafeOrderDo: [ :cls |
			strm nextPut: cls ]].
	self
		write: sortedClasses classDefinitionsOn: aStream;
		write: sortedClasses classCommentsOn: aStream;
		write: sortedClasses methodsOn: aStream.
	self
		sortedExtensionMethodsDo:  [ :methodReference |
			methodReference isValid ifTrue: [
				self writeMethod: methodReference on: aStream ]]
		displayingProgress: 'Saving extension methods...'.
	self
		write: sortedClasses initializersOn: aStream! !

CodePackage removeSelector: #actualMethodsDo:!

CodePackage removeSelector: #actualMethodsDo:!

CodePackage removeSelector: #addCoreMethod:!

CodePackage removeSelector: #addCoreMethod:!

CodePackage removeSelector: #addExtensionMethod:!

CodePackage removeSelector: #addExtensionMethod:!

CodePackage removeSelector: #addMethod:!

CodePackage removeSelector: #addMethod:!

CodePackage removeSelector: #allOverriddenMethods!

CodePackage removeSelector: #allOverriddenMethods!

CodePackage removeSelector: #allOverriddenMethodsDo:!

CodePackage removeSelector: #allOverriddenMethodsDo:!

CodePackage removeSelector: #baseCategoryOfMethod:!

CodePackage removeSelector: #baseCategoryOfMethod:!

CodePackage removeSelector: #changeRecordForOverriddenMethod:!

CodePackage removeSelector: #changeRecordForOverriddenMethod:!

CodePackage removeSelector: #coreCategoriesForClass:!

CodePackage removeSelector: #coreCategoriesForClass:!

CodePackage removeSelector: #extensionClasses!

CodePackage removeSelector: #extensionClasses!

CodePackage removeSelector: #externalCallers!

CodePackage removeSelector: #externalCallers!

CodePackage removeSelector: #externalRefsSelect:thenCollect:!

CodePackage removeSelector: #externalRefsSelect:thenCollect:!

CodePackage removeSelector: #externalSubclasses!

CodePackage removeSelector: #externalSubclasses!

CodePackage removeSelector: #externalUsers!

CodePackage removeSelector: #externalUsers!

CodePackage removeSelector: #foreignClasses!

CodePackage removeSelector: #foreignClasses!

CodePackage removeSelector: #foreignSystemCategories!

CodePackage removeSelector: #foreignSystemCategories!

CodePackage removeSelector: #includesChangeRecord:!

CodePackage removeSelector: #includesChangeRecord:!

CodePackage removeSelector: #includesClassNamed:!

CodePackage removeSelector: #includesClassNamed:!

CodePackage removeSelector: #includesMethodCategory:ofClassNamed:!

CodePackage removeSelector: #includesMethodCategory:ofClassNamed:!

CodePackage removeSelector: #isOverrideCategory:!

CodePackage removeSelector: #isOverrideCategory:!

CodePackage removeSelector: #isOverrideMethod:!

CodePackage removeSelector: #isOverrideMethod:!

CodePackage removeSelector: #isOverrideOfYourMethod:!

CodePackage removeSelector: #isOverrideOfYourMethod:!

CodePackage removeSelector: #overriddenMethods!

CodePackage removeSelector: #overriddenMethods!

CodePackage removeSelector: #overriddenMethodsDo:!

CodePackage removeSelector: #overriddenMethodsDo:!

CodePackage removeSelector: #overriddenMethodsInClass:!

CodePackage removeSelector: #overriddenMethodsInClass:!

CodePackage removeSelector: #overriddenMethodsInClass:do:!

CodePackage removeSelector: #overriddenMethodsInClass:do:!

CodePackage removeSelector: #overrideCategoriesForClass:!

CodePackage removeSelector: #overrideCategoriesForClass:!

CodePackage removeSelector: #overrideCategoriesForClass:do:!

CodePackage removeSelector: #overrideCategoriesForClass:do:!

CodePackage removeSelector: #overrideMethods!

CodePackage removeSelector: #overrideMethods!

CodePackage removeSelector: #writeMethodsOf:on:!

CodePackage removeSelector: #writeMethodsOf:on:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3232-CodePackage-cleanupAndEnhancements-JuanVuletich-2017Dec26-09h12m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3232] on 27 December 2017 at 12:03:07 pm'!
!Theme class methodsFor: 'class initialization' stamp: 'jmv 12/27/2017 11:14:22' prior: 50341495!
                              currentTheme: aTheme

	CurrentTheme := aTheme new.
	SHTextStylerST80 releaseClassCachedState.
	self runningWorld ifNotNil: [ :w |
		w backgroundImage ifNil: [
			w color: CurrentTheme background ]].
	SystemWindow initialize.
	BitBltCanvas releaseClassCachedState.
	self runningWorld ifNotNil: [ :w |
		CurrentTheme useTaskbar
			ifTrue: [w showTaskbar]
			ifFalse: [w hideTaskbar].
		w restoreMorphicDisplay ].
	
	^ CurrentTheme! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3233-DoNotResetShoutPreferencesOnthemeChange-JuanVuletich-2017Dec27-12h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3226] on 11 December 2017 at 2:44:07 pm'!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'pb 12/11/2017 14:37:42'!
     privateMorphicTopLevelRendererClass
	"The class controlling the outermost rendering process for Morphic and other critical methods for handling interrupts.  Dangerous to change as any bugs will effectively crash the UI for the entire image.
	
	Using 'private' prefix to reflect the danger even though it will likely be called externally."
	^ ProjectX! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'pb 12/11/2017 14:37:54'!
               privateMorphicWorldClass
	"The class to be used for Morphic Worlds.  Dangerous to change as any bugs will effectively crash the UI for the entire image.
	
	Using 'private' prefix to reflect the danger even though it will likely be called externally."
	^ PasteUpMorph ! !
!Debugger methodsFor: 'initialization' stamp: 'pb 12/11/2017 14:41:18' prior: 16830276!
                         openFullNoSuspendLabel: aString
	"Create and schedule a full debugger with the given label. Do not terminate the current active process."

	self openFullMorphicLabel: aString.
	interruptedProcessUI _ Smalltalk privateMorphicTopLevelRendererClass newProcessIfUIX: interruptedProcess! !
!Debugger methodsFor: 'initialization' stamp: 'pb 12/11/2017 14:41:28' prior: 16830286!
           openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor normal activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self lowSpaceChoices, (msgString ifNil: ['']) ]
		ifFalse: [ msgString ].

	interruptedProcessUI _ Smalltalk privateMorphicTopLevelRendererClass newProcessIfUIX: interruptedProcess.
	WorldState addDeferredUIMessage: [
		PreDebugWindow open: self label: label message: msg ].
	^self! !
!Debugger class methodsFor: 'opening' stamp: 'pb 12/11/2017 14:41:38' prior: 50373395!
  openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := Smalltalk privateMorphicTopLevelRendererClass newProcessIfUIX: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	WorldState addDeferredUIMessage: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!SystemDictionary methodsFor: 'memory space' stamp: 'pb 12/11/2017 14:42:30' prior: 16920405!
          lowSpaceWatcher
	"Wait until the low space semaphore is signalled, then take appropriate actions."

	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [
		self garbageCollect <= self lowSpaceThreshold ifTrue: [
			"free space must be above threshold before starting low space watcher"
			^ Smalltalk primitiveBeep ]].

	LowSpaceSemaphore _ Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"

	LowSpaceSemaphore wait.  "wait for a low space condition..."

	self primSignalAtBytesLeft: 0.  "disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess _ nil.
	"Note: user now unprotected until the low space watcher is re-installed"

	self privateMorphicTopLevelRendererClass currentInterruptNameX: 'Space is low'! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'pb 12/11/2017 14:42:18' prior: 16920982!
                          handleUserInterrupt
	Preferences cmdDotEnabled ifTrue: [
		[self privateMorphicTopLevelRendererClass currentInterruptNameX: 'User Interrupt'] fork]! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'pb 12/11/2017 14:39:37' prior: 50357685!
              reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	self privateMorphicWorldClass allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'pb 12/11/2017 14:43:32' prior: 50369884!
                        snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ self privateMorphicTopLevelRendererClass ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ self privateMorphicTopLevelRendererClass ui ]."
	self privateMorphicTopLevelRendererClass stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	self privateMorphicTopLevelRendererClass spawnNewMorphicProcessFor: (world ifNil: [ self privateMorphicWorldClass newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'pb 12/11/2017 14:42:05' prior: 16896342!
                    interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess  label |
	preemptedProcess _ Processor preemptedProcess.

	"Only debug preempted process if its priority is >= UIProcess' priority"
	preemptedProcess priority < UIProcess priority ifTrue: [
		preemptedProcess _ UIProcess ].

	label _ labelString,
					' - Process: ', preemptedProcess name,
					' - Priority: ', preemptedProcess priority printString.
	preemptedProcess isTerminated
		ifTrue: [
			self newProcessIfUIX: preemptedProcess.
			self notify: 'Can not debug a terminated process: ', label ]
		ifFalse: [
			preemptedProcess suspend.
			Debugger
				openInterrupt: label 
				onProcess: preemptedProcess ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3234-Morphic-globals-PhilBellalouna-2017Dec11-14h37m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3227] on 11 December 2017 at 5:30:58 pm'!
!PasteUpMorph methodsFor: 'world state' stamp: 'pb 12/11/2017 15:25:45'!
           addDeferredUIMessage: valuableObject
	"This will be safe to call directly in a multi-world environment (as opposed to the WorldState class-side method)"
	WorldState addDeferredUIMessage: valuableObject ! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'pb 12/11/2017 17:07:49' prior: 50377573!
               snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ self privateMorphicTopLevelRendererClass ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ self privateMorphicTopLevelRendererClass ui ]."
	self privateMorphicTopLevelRendererClass stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	self privateMorphicTopLevelRendererClass spawnNewMorphicProcessFor: (world ifNil: [ world:=self privateMorphicWorldClass newWorld ]).

	reopenTranscript ifTrue: [
		world addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	world  addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		world  addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!Morph methodsFor: 'halos and balloon help' stamp: 'pb 12/11/2017 15:29:32' prior: 16875813!
showBalloon: msgString hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	(w _ self world) ifNil: [^ self].
	h _ aHand.
	h ifNil:[
		h _ w activeHand].
	balloon _ HoverHelpMorph contents: msgString.
	
	"Do it in a while. In some cases, processing the event that might have triggered us might also remove any Help Balloon"
	self world addDeferredUIMessage: [
		balloon popUpForHand: h ]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'pb 12/11/2017 15:30:12' prior: 50337477!
            restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	self addDeferredUIMessage: [ Cursor normal activateCursor ]! !
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'pb 12/11/2017 15:26:29' prior: 50377045!
         arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self getSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection - 1 max: 1 ]].
		^ true ].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		self world addDeferredUIMessage: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'pb 12/11/2017 15:30:36' prior: 16888803!
arrowKey: aChar
	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."
	| keyEvent oldSelection nextSelection max min howMany answer w |
	answer _ false.
	keyEvent _ aChar numericValue.
	oldSelection _ self getCurrentSelectionIndex.
	nextSelection _ oldSelection.
	max _ self maximumSelection.
	min _ self minimumSelection.
	howMany _ self numSelectionsInView.	"get this exactly??"

	keyEvent = 31 ifTrue: [
		"down-arrow; move down one, wrapping to top if needed"
		nextSelection _ oldSelection + 1.
		nextSelection > max ifTrue: [ nextSelection _ 1 ]].

	keyEvent = 30 ifTrue: [
		"up arrow; move up one, wrapping to bottom if needed"
		nextSelection _ oldSelection - 1.
		nextSelection < 1 ifTrue: [ nextSelection _ max ]].

	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"
	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"
	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"
	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"
	nextSelection = oldSelection ifFalse: [
		w _ self owningWindow.
		(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

			"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
			self listMorph highlightedRow: nextSelection.

			"Update the model in next world cycle, so user gets the immediate feedback."
			self world addDeferredUIMessage: [
				self changeModelSelection: nextSelection ].
			answer _ true ]].
	^answer! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'pb 12/11/2017 15:30:48' prior: 16889213!
              mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	row _ self rowAtLocation: localEventPosition.

	row = 0 ifTrue: [
		^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
	self listMorph highlightedRow: row.

	w _ self owningWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Different from PluggableListMorph. There, we highlight on mouse down, and act on mouse up.
		Here, we act on mouse down, because we support dragging of selection, so mouse up will
		only happen after user is finished dragging. In order to get the highlight visible for the user,
		update the model on next world cycle."
		self world addDeferredUIMessage: [
			"Set or clear new primary selection (listIndex)"
			dragOnOrOff
				ifTrue: [self changeModelSelection: row]
				ifFalse: [self changeModelSelection: 0].
			"Need to restore the old one, due to how model works, and set new one."
			oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
			self listSelectionAt: row put: dragOnOrOff ].
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!SystemWindow methodsFor: 'open/close' stamp: 'pb 12/11/2017 15:31:54' prior: 50335160!
           openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect _ self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse) "
	aWorld addDeferredUIMessage: [ self activate ]! !
!TaskbarMorph methodsFor: 'events' stamp: 'pb 12/11/2017 15:32:05' prior: 50337199!
                              screenSizeChanged
	"Respond to change in screen size by repositioning self to bottom of screen"
	
"	Transcript newLine; print: 'Taskbar screenSizeChanged'.
"
	| y e |
	self world addDeferredUIMessage: [
		self world ifNotNil: [ :w |
			y _ w morphExtent y - self defaultHeight.
			e _ self internalizeDistance: w morphExtent x @ self defaultHeight.
			self morphPosition: 0@y extent: e ]]! !
!InnerTextMorph methodsFor: 'editing' stamp: 'pb 12/11/2017 15:29:07' prior: 50365178!
 acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar scrollValue.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			"FIXME - is there actually a case where world will be nil here?"
			self world addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar internalScrollValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !
!WorldState class methodsFor: 'class initialization' stamp: 'pb 12/11/2017 15:33:57' prior: 16946300!
                           addDeferredUIMessage: valuableObject
	"Objects should not be calling directly as this will disappear from this location!!  From the sender, instead to schedule on the currently running world use:
	self runningWorld addDeferredUIMessage: ...
	And to schedule on the world a given Morph exists in use:
	self world addDeferredUIMessage: ..."
	self deferredUIMessages nextPut: valuableObject! !
!AndreasSystemProfiler methodsFor: 'reporting' stamp: 'pb 12/11/2017 15:33:07' prior: 16779085!
                         doReport
	"Report the results of this profiler run"
	self runningWorld addDeferredUIMessage: [
		SystemWindow
			editText: (Workspace withText: self report)
			label: 'Spy Results'
			wrap: false ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3235-Morphic-addDeferredUIMessage-PhilBellalouna-2017Dec11-14h52m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3232] on 15 December 2017 at 9:24:34 pm'!
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'pb 12/15/2017 21:24:22' prior: 50377883!
                           arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self getSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [
					oldSelection > self minimumSelection ifTrue: [
						nextSelection _ (oldSelection-1 to: 1 by: -1) detect: [ :i | ( scroller submorphs at: i) indentLevel < selectedMorph indentLevel ]].
					]]].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		self world addDeferredUIMessage: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3236-reapply-HierarchicalListMorph-change-PhilBellalouna-2017Dec15-21h23m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3236] on 28 December 2017 at 10:50:51 am'!

Object subclass: #AndreasSystemProfiler
	instanceVariableNames: 'semaphore ticks profilerProcess tallyRoot vmStats totalTally totalTime startTime ticksPerMSec totalTicks observedProcess '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

!classDefinition: #AndreasSystemProfiler category: #'Tools-Profiling'!
Object subclass: #AndreasSystemProfiler
	instanceVariableNames: 'semaphore ticks profilerProcess tallyRoot vmStats totalTally totalTime startTime ticksPerMSec totalTicks observedProcess'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!
!Time class methodsFor: 'general inquiries' stamp: 'jmv 12/28/2017 09:52:08'!
                highResTimerTicksPerMillisecond
	"
	Time highResTimerTicksPerMillisecond
	"
	| t0 ticks0 ticks1 ticksPerMSec |
	t0 _ Time millisecondClockValue + 2.
	[Time millisecondClockValue >= t0] whileFalse.
	ticks0 := Time primHighResClock.
	[Time millisecondClockValue >= (t0 + 100)] whileFalse.
	ticks1 := Time primHighResClock.
	ticksPerMSec := (ticks1 - ticks0) 
			// (Time millisecondClockValue - t0).
	"Retry if rollover!!"
	^ ticksPerMSec < 0
		ifTrue: [ self highResTimerTicksPerMillisecond ]
		ifFalse: [ ticksPerMSec ]! !
!AndreasSystemProfiler methodsFor: 'testing' stamp: 'jmv 12/28/2017 07:45:21'!
      isProfiling
	^ profilerProcess notNil! !
!Time class methodsFor: 'primitives' stamp: 'jmv 12/28/2017 09:53:17' prior: 16937554!
primHighResClock	
	"Primitive. Answer the value of the high resolution clock if this computer has one.
	Usually, this should be the highest resolution value available, for example on Intel
	it will be the value of the time stamp counter register.
	Answer is (at least usually) a LargePositiveInteger.
	Implemented on Cog, but not in standard interpreter VMs."
	"
	Time primHighResClock
	On Cog on Linux, OS-X and Windows, this gives sub nano second ticks!!

	Time highResTimerTicksPerMillisecond
	"
	"Not really a clock, but a timer or ticker"

	<primitive: 'primitiveHighResClock'>
	^0! !
!SystemDictionary methodsFor: 'AndreasProfiler-profiling' stamp: 'jmv 12/28/2017 09:45:25' prior: 16925386!
      profileStart: counter
	"Primitive. Begin profiling execution every by using the interrupt check-counter instead of a time-based process (which is limited to timing resolution and triggers off the same signal that many of the processes being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let go by before taking a sample. The sample is being stored in the profileSample iVar which can be retrieved by executing primitiveProfileSample. When a sample is taken, it signals the semaphore specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling."
	"Not an interrupt check-counter, but #primHighResClock"
	<primitive: 'primitiveProfileStart'>
	^self primitiveFailed! !
!QSystemTally methodsFor: 'report' stamp: 'jmv 12/28/2017 10:04:11' prior: 16897464!
             printOn: textStream linesOn: linesStream talliesOn: talliesStreams tabs: tabsAndTreeLines total: total totalTime: totalTime parent: parentTally

	| aSelector aClass percentage line |
	line _ String streamContents: [ :lineStream |
		tabsAndTreeLines do: [ :tabOrLineChar | lineStream nextPutAll: tabOrLineChar ].
		percentage _ tally asFloat / total * 100.0.
		percentage printOn: lineStream fractionDigits: 2.
		lineStream nextPutAll: '% ('.
		percentage * totalTime printOn: lineStream fractionDigits: 1.
		lineStream nextPutAll: ' ms) '.
		aSelector _ class selectorAtMethod: method setClass: [ :c | aClass _ c].
			blockNesting > 0 ifTrue: [
				lineStream
					next: blockNesting put: $[;
					next: blockNesting put: $];
					space ].
		lineStream
			nextPutAll: class name;
			nextPutAll: (aClass == class 
					ifTrue: ['>>']
					ifFalse: ['(' , aClass name , ')>>']);
			nextPutAll: aSelector.
		wasInPrimitive ifTrue: [
			self flag: #profilerFriendlyCall:.
			parentTally methodSymbol == #profilerFriendlyCall:
				ifTrue: [
					lineStream nextPutAll: '   -- primitive (reported properly)' ]
				ifFalse: [
					lineStream nextPutAll: '   -- primitive (real sender possibly omitted, see #profilerFriendlyCall:)' ]
			].
		].
	textStream nextPutAll: line; newLine.
	linesStream nextPut: line.
	talliesStreams nextPut: self! !
!AndreasSystemProfiler methodsFor: 'reporting' stamp: 'jmv 12/28/2017 07:52:24' prior: 50378150!
      doReport
	"Report the results of this profiler run"
	| report |
	report _ self report.
	WorldState addDeferredUIMessage: [
		SystemWindow
			editText: (Workspace withText: report)
			label: 'Spy Results'
			wrap: false ]! !
!AndreasSystemProfiler methodsFor: 'profiling' stamp: 'jmv 12/28/2017 10:45:37' prior: 16779284!
                               runProfilerProcess
	"Run the profiler process"

	| process tallyStart tallyTicks methodForPrimitiveWhileTakingSample parentNode contextToTally |
	totalTally _ 0.
	Smalltalk profileSemaphore: semaphore.
	totalTicks _ 0.
	[ true ]
		whileTrue: [
			tallyStart _ Time primHighResClock.
			Smalltalk profileStart: ticks.	"run for n ticks"
			semaphore wait.
			tallyTicks _ Time primHighResClock - tallyStart.
			"In the extremely unlikely event of high res clock rollover, just ignore this tally"
			tallyTicks > 0 ifTrue: [
				totalTicks _ totalTicks + tallyTicks.
				process _ Smalltalk profileSample.
				methodForPrimitiveWhileTakingSample _ Smalltalk profilePrimitive.
				totalTally _ totalTally + 1.
				process
					ifNotNil: [
						methodForPrimitiveWhileTakingSample
							ifNil: [
								tallyRoot
									tally: (process suspendedContext ifNil: [ thisContext ])
									inProcess: process
									by: tallyTicks.
								]
							ifNotNil: [
								"The intention of this code is record which primitive was running when the VM took the sample."
								"In Eliot Miranda's words: 
									AndreasSystemProfiler is more accurate because it uses VM support to tell it which primitive was running when it took a sample. 
									MessageTally simply ascribes a primitive's cost to the method at the next suspension point, which, in some contexts, 
									can yield wildly misleading results."
								"The problem is that knowing just the primitive and the process doesn't give us the complete call stack.
								So, this is, in a sense, approximate."
								"
									AndreasSystemProfiler spyOn: [
								 	       [ #((1 2 3)) do: [ :each |
 									               each findLast: [ :ea |
									                        ea squared = ea ] ] ] bench ].
								Without asking #sender to the context, for this example
									AndreasSystemProfiler spyOn:[10000 timesRepeat: [3.14159 printString]]
								gave:
									  |  2.9% (7 ms) (Number>>#raisedToInteger:)
									  |    2.2% (5 ms) (Float>>#timesTwoPower: )
								but #raisedToInteger: does NOT send #timesTwoPower:
								Approach taken: Add to parent node, but print with a note that specifies this is primitives, and maybe parent node is missing.
								Additionally, add a note, suggesting #profilerFriendlyCall:

								For example
									AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 timesTwoPower: 10000]].
										Here, the real parent node is missing.

									AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 profilerFriendlyTimesTwoPower: 1000]].
										Here, the proper tree is shown.

								See profilerFriendlyCall:
								"
								contextToTally _ process suspendedContext ifNil: [ thisContext ].
								contextToTally method selector == #profilerFriendlyCall: ifFalse: [
									contextToTally _ contextToTally sender ].
								parentNode _ tallyRoot
									tally: contextToTally
									inProcess: process
									by: tallyTicks.
								parentNode
									tallyPrimInMethod: methodForPrimitiveWhileTakingSample by: tallyTicks
								]]]]! !
!AndreasSystemProfiler methodsFor: 'profiling' stamp: 'jmv 12/28/2017 10:23:54' prior: 16779396!
          startProfiling
	"Start the profiler process taking samplesPerMsec samples per *milli* second"
	semaphore _ Semaphore new.
	"Try to get 10 samples per msec... Not really sure how this parameter is used, nor the meaning and relevance of #interruptChecksPerMSec"
	"ticks _ Time highResTimerTicksPerMillisecond // Smalltalk interruptChecksPerMSec."
	ticks _ Time highResTimerTicksPerMillisecond // 10.
	vmStats _ Smalltalk getVMParameters.
	startTime _ Time localMillisecondClock.
	profilerProcess := [self runProfilerProcess] newProcess.
	tallyRoot process: nil.
	profilerProcess priority: Processor timingPriority-1.
	profilerProcess name: 'AndreasSystemProfiler'.
	profilerProcess resume! !
!AndreasSystemProfiler methodsFor: 'profiling' stamp: 'jmv 12/28/2017 07:47:24' prior: 16779425!
             stopProfiling
	"Stop the profiler process"
	Smalltalk profileSemaphore: nil.
	Smalltalk profileStart: 0. "<- profile stops now"
	totalTime _ Time localMillisecondClock - startTime.
	Smalltalk getVMParameters keysAndValuesDo: [ :idx :value | 
		value isNumber ifTrue: [
			vmStats at: idx put: (value - (vmStats at: idx)) ]].
	profilerProcess ifNotNil: [
		profilerProcess terminate.
		profilerProcess _ nil ]! !
!AndreasSystemProfiler class methodsFor: 'spying' stamp: 'jmv 12/28/2017 07:51:36' prior: 16779565!
spyOn: aBlock includeAllProcesses: aBoolean
	"
	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.
	[1000 timesRepeat: [
		100 timesRepeat: [120 factorial].
		(Delay forMilliseconds: 10) wait
		]] forkAt: 45 named: '45'.
	AndreasSystemProfiler spyOn: [10000 timesRepeat: [1.23 printString]] includeAllProcesses: true
	"
	| profiler |
	self allInstancesDo: [ :p |
		p isProfiling ifTrue: [
			^ self inform: 'Must first wait for running profiler, or kill it in Process Browser' ]].
	profiler _ self new.
	profiler observedProcess: (aBoolean ifFalse: [Processor activeProcess]).
	[ ^ profiler spyOn: aBlock]  ensure: [ profiler doReport ].
! !

Object subclass: #AndreasSystemProfiler
	instanceVariableNames: 'semaphore ticks profilerProcess tallyRoot vmStats totalTally totalTime startTime totalTicks observedProcess'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

!classDefinition: #AndreasSystemProfiler category: #'Tools-Profiling'!
Object subclass: #AndreasSystemProfiler
	instanceVariableNames: 'semaphore ticks profilerProcess tallyRoot vmStats totalTally totalTime startTime totalTicks observedProcess'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3237-ProfilerFixes-JuanVuletich-2017Dec28-10h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3237] on 28 December 2017 at 12:21:11 pm'!
!AndreasSystemProfiler methodsFor: 'reporting' stamp: 'jmv 12/28/2017 12:20:41' prior: 50378380!
         doReport
	"Report the results of this profiler run"
	| report |
	report _ self report.
	self runningWorld addDeferredUIMessage: [
		SystemWindow
			editText: (Workspace withText: report)
			label: 'Spy Results'
			wrap: false ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3238-MergeWith3235-JuanVuletich-2017Dec28-12h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3237] on 28 December 2017 at 2:26:10 pm'!

Smalltalk renameClassNamed: #ProjectX as: #UISupervisor!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/28/2017 14:25:52' prior: 50377343!
                             privateMorphicTopLevelRendererClass
	"The class controlling the outermost rendering process for Morphic and other critical methods for handling interrupts.  Dangerous to change as any bugs will effectively crash the UI for the entire image.
	
	Using 'private' prefix to reflect the danger even though it will likely be called externally."
	^ UISupervisor! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3239-UISupervisor-JuanVuletich-2017Dec28-14h25m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3239] on 28 December 2017 at 3:15:30 pm'!
!UISupervisor commentStamp: '<historical>' prior: 0!
    UISupervisor is an interface to User Interface services not tied to any specific GUI. There could even be no GUI.
All state and behavior is on the class side!
!Debugger class methodsFor: 'opening' stamp: 'jmv 12/28/2017 15:02:53'!
                         interruptProcess: aProcess label: labelString
	"Create a Notifier on aProcess with the given label."
	|  label |

	label _ labelString,
					' - Process: ', aProcess name,
					' - Priority: ', aProcess priority printString.
	aProcess isTerminated
		ifTrue: [
			UISupervisor newProcessIfUI: aProcess.
			self notify: 'Can not debug a terminated process: ', label ]
		ifFalse: [
			aProcess suspend.
			self
				openInterrupt: label 
				onProcess: aProcess ]! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 14:50:40'!
 newProcessIfUI: suspendedProcess
	"Answer the UI we created a new process for"

	suspendedProcess animatedUI ifNotNil: [ :guiRootObject |
		self spawnNewMorphicProcessFor: guiRootObject.
		^guiRootObject ].
	^nil! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 15:04:16'!
                        userInterrupt
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess  |
	preemptedProcess _ Processor preemptedProcess.

	"Only debug preempted process if its priority is >= UIProcess' priority"
	preemptedProcess priority < UIProcess priority ifTrue: [
		preemptedProcess _ UIProcess ].

	Debugger interruptProcess: preemptedProcess label: 'User Interrupt'! !
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 12/28/2017 14:38:23'!
mainLoop

	
	self clearWaitDelay.
	self clearCanvas.
	[
		self doOneCycle.
		Processor yield.
		true ]
			whileTrue: []! !
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 12/28/2017 14:40:22'!
                      runProcess
	| process |
	process _ [ self mainLoop ]
		newProcess.
	process
		priority: Processor userSchedulingPriority;
		name: 'Morphic UI';
		animatedUI: self.
	^ process! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 12/28/2017 14:43:57' prior: 50377369!
                     openFullNoSuspendLabel: aString
	"Create and schedule a full debugger with the given label. Do not terminate the current active process."

	self openFullMorphicLabel: aString.
	interruptedProcessUI _ UISupervisor newProcessIfUI: interruptedProcess! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 12/28/2017 14:44:04' prior: 50377381!
            openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor normal activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self lowSpaceChoices, (msgString ifNil: ['']) ]
		ifFalse: [ msgString ].

	interruptedProcessUI _ UISupervisor newProcessIfUI: interruptedProcess.
	WorldState addDeferredUIMessage: [
		PreDebugWindow open: self label: label message: msg ].
	^self! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 12/28/2017 14:44:13' prior: 50377412!
   openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	WorldState addDeferredUIMessage: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 12/28/2017 15:00:19' prior: 50377463!
           lowSpaceWatcher
	"Wait until the low space semaphore is signalled, then take appropriate actions."

	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [
		self garbageCollect <= self lowSpaceThreshold ifTrue: [
			"free space must be above threshold before starting low space watcher"
			^ Smalltalk primitiveBeep ]].

	LowSpaceSemaphore _ Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"

	LowSpaceSemaphore wait.  "wait for a low space condition..."

	self primSignalAtBytesLeft: 0.  "disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess _ nil.
	"Note: user now unprotected until the low space watcher is re-installed"

	Debugger interruptProcess: Processor preemptedProcess label: 'Space is low'! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/28/2017 15:04:08' prior: 50377493!
                            handleUserInterrupt
	Preferences cmdDotEnabled ifTrue: [
		[ UISupervisor userInterrupt ] fork]! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/28/2017 14:48:02' prior: 50377736!
                         snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup guiRootObject reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.

	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ self privateMorphicWorldClass newWorld ]).

	reopenTranscript ifTrue: [
		guiRootObject addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	world  addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		guiRootObject  addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 14:50:33' prior: 16896377!
                       spawnNewMorphicProcessFor: guiRootObject

	UIProcess ifNotNil: [ UIProcess animatedUI: nil ].
	UIProcess _ guiRootObject runProcess.
	UIProcess resume! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 15:10:48' prior: 16896390!
      stopUIProcess
	UIProcess ifNotNil: [
		UIProcess animatedUI: nil.
		UIProcess terminate ].
	UIProcess _ nil! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 15:09:33' prior: 16896397!
                 ui
	^UIProcess animatedUI! !

UISupervisor class removeSelector: #currentInterruptNameX:!

UISupervisor class removeSelector: #currentInterruptNameX:!

UISupervisor class removeSelector: #interruptNameX:!

UISupervisor class removeSelector: #interruptNameX:!

UISupervisor class removeSelector: #newProcessIfUIX:!

UISupervisor class removeSelector: #newProcessIfUIX:!

SystemDictionary removeSelector: #privateMorphicTopLevelRendererClass!

SystemDictionary removeSelector: #privateMorphicTopLevelRendererClass!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3240-UISupervisor-cleanup-JuanVuletich-2017Dec28-15h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3239] on 28 December 2017 at 3:20:41 pm'!
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/25/2016 15:31' prior: 50377501!
                              reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/28/2017 15:19:25' prior: 50378816!
        snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup guiRootObject guiRootObjectClass reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	guiRootObjectClass _ UISupervisor ui class.
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.

	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ guiRootObjectClass newWorld ]).

	reopenTranscript ifTrue: [
		guiRootObject addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	world  addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		guiRootObject  addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 12/28/2017 15:19:42' prior: 50362764!
                            newWorld
	"
[
	UISupervisor stopUIProcess.
	UISupervisor spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: `0@0` extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !

SystemDictionary removeSelector: #privateMorphicWorldClass!

SystemDictionary removeSelector: #privateMorphicWorldClass!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3241-dontAskForWorldClass-JuanVuletich-2017Dec28-15h15m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3239] on 28 December 2017 at 3:45:45 pm'!
!BlockClosure commentStamp: 'jmv 12/28/2017 15:42:10' prior: 16787685!
        I am a block closure for Eliot's closure implementation. Not to be confused with the old BlockClosure (they were never part of Cuis anyway).

This is a closure converted image. With full closure support, you can finally use recursive blocks like here:

| fac |
	fac := [:n| n > 1 ifTrue:[n * (fac value: n-1)] ifFalse:[1]].
	fac value: 5. "120"

and close over temps correctly, such as here:

	(1 to: 10) do:[:i| UISupervisor whenUIinSafeState:[Transcript newLine; show: i]].

Another good example:

| fib |
fib := [:n| n < 2 ifTrue:[1] ifFalse:[(fib value:n-1) + (fib value:n-2)]].
fib value: 10. "89"!
!UISupervisor class methodsFor: 'services' stamp: 'jmv 12/28/2017 15:36:24'!
                       restoreDisplay
	DisplayScreen startUp.
	self ui ifNotNil: [ :guiRootObject |
		guiRootObject restoreDisplay ].
	UISupervisor whenUIinSafeState: [ Cursor normal activateCursor ]! !
!UISupervisor class methodsFor: 'services' stamp: 'jmv 12/28/2017 15:29:34'!
                               whenUIinSafeState: evaluableObject
	"If there is an UI present, evaluate argument when such UI is in a safe state.
	If not, just evaluate the argument right now."
	self ui
		ifNotNil: [ :guiRootObject | guiRootObject whenUIinSafeState: evaluableObject ]
		ifNil: evaluableObject! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/28/2017 15:36:22'!
                            restoreDisplay
	self
		morphExtent: Display extent;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/28/2017 15:30:26'!
      whenUIinSafeState: evaluableObject
	"Please call
	UISupervisor whenUIinSafeState: evaluableObject
	"
	WorldState addDeferredUIMessage: evaluableObject ! !
!Debugger methodsFor: 'initialization' stamp: 'jmv 12/28/2017 15:31:17' prior: 50378699!
            openNotifierContents: msgString label: label
	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."
	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."
	| msg |
	Sensor flushKeyboard.
	savedCursor _ Cursor currentCursor.
	Cursor normal activateCursor.
	msg _ (label beginsWith: 'Space is low')
		ifTrue: [ self lowSpaceChoices, (msgString ifNil: ['']) ]
		ifFalse: [ msgString ].

	interruptedProcessUI _ UISupervisor newProcessIfUI: interruptedProcess.
	UISupervisor whenUIinSafeState: [
		PreDebugWindow open: self label: label message: msg ].
	^self! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 12/28/2017 15:31:22' prior: 50378729!
    openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 12/28/2017 15:41:46' prior: 16928246!
                    runSuite: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	running _ [
            [ result _ suite run ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				UISupervisor whenUIinSafeState: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
"	      priority: Processor userBackgroundPriority;"
	      resume.
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 12/28/2017 15:41:57' prior: 16928270!
                              runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				UISupervisor whenUIinSafeState: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
"	      priority: Processor userBackgroundPriority;"
	      resume.
! !
!TestRunner methodsFor: 'updating' stamp: 'jmv 12/28/2017 15:41:51' prior: 16928371!
  update: aParameter 
	"updates come in from another thread"
	(aParameter is: #TestCase)
		ifTrue: [
			UISupervisor whenUIinSafeState: [
				completedTests _ completedTests + 1.
				progressLabel _ aParameter printString.
				self changed: #progress ]]
		ifFalse: [ super update: aParameter ]! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 12/28/2017 15:31:10' prior: 16795052!
                             openWindowForSuspendedProcess: aProcess 

	UISupervisor whenUIinSafeState: [self openMorphicWindowForSuspendedProcess: aProcess]! !
!ProcessBrowser class methodsFor: 'CPU utilization' stamp: 'jmv 12/28/2017 15:42:34' prior: 16895203!
                      dumpPigStackOn: aStream
	"Must run forked on its own process, so the monitored behavior is not affected too much"

	| promise tally process depth stack suspendedContext |
	promise := Processor tallyCPUUsageFor: 1 every: 10.
	tally := promise value.
	"UISupervisor whenUIinSafeState: [self dumpTallyOnTranscript: tally]."
	aStream nextPutAll: '====Al processes===='; newLine.
	self dumpTally: tally on: aStream.
	aStream newLine; nextPutAll: '====Process using most CPU===='; newLine.
	process _ tally sortedCounts first value.
	(100.0 * (tally occurrencesOf: process) / tally size) rounded printOn: aStream.
	aStream
		nextPutAll: ' % ';
		nextPutAll: (process browserPrintStringFull: false);
		newLine.
	depth _ 20.
	stack _ process == Processor activeProcess
		ifTrue: [thisContext stackOfSize: depth]
		ifFalse: [suspendedContext _ process suspendedContext.
			suspendedContext
				ifNotNil: [suspendedContext stackOfSize: depth]].
	stack 
		ifNil: [ aStream nextPutAll: 'No context'; newLine]
		ifNotNil: [
			stack do: [ :c | 
				c printOn: aStream.
				aStream newLine ]]! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 12/28/2017 15:31:52' prior: 16870883!
           tallySendsTo: receiver inBlock: aBlock
	"
	MessageTally tallySends: [3.14159 printString]
	"
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. If receiver is not nil, then only sends
	to that receiver are tallied.
	Results are presented as leaves, sorted by frequency,
	preceded, optionally, by the whole tree."
	| prev tallies startTime totalTime |
	startTime _ Time localMillisecondClock.
	tallies _ self new class: aBlock receiver class method: aBlock method.
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep: [ :current |
			current == prev ifFalse: [ "call or return"
				prev sender ifNotNil: [ "call only"
					(receiver == nil or: [ current receiver == receiver ])
						ifTrue: [ tallies tally: current by: 1 ]].
				prev _ current]].

	totalTime _ Time localMillisecondClock - startTime / 1000.0.
	UISupervisor whenUIinSafeState: [
		SystemWindow
			editText: (Workspace withText: (String streamContents: [ :s |
				s
					nextPutAll: 'This simulation took ';
					nextPutAll: totalTime printString;
					nextPutAll: ' seconds.';
					newLine.
				tallies fullPrintExactOn: s ]))
			label: 'Spy Results'
			wrap: false ]! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/28/2017 15:42:48' prior: 50379047!
                      snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup guiRootObject guiRootObjectClass reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	guiRootObjectClass _ UISupervisor ui class.
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.

	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ guiRootObjectClass newWorld ]).

	reopenTranscript ifTrue: [
		UISupervisor whenUIinSafeState: [
			TranscriptWindow openTranscript ]].
	"
	UISupervisor whenUIinSafeState: [
		guiRootObject fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'jmv 12/28/2017 15:40:12' prior: 50369767!
                restoreLostChangesIfNecessary

	"
	Smalltalk restoreLostChangesIfNecessary
	"
	
	self hasToRestoreChanges ifTrue: [ UISupervisor whenUIinSafeState: [self restoreLostChanges ]].
! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 15:26:47' prior: 50378949!
           ui
	^UIProcess ifNotNil: [ UIProcess animatedUI ]! !
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 15:27:03' prior: 50378657!
           userInterrupt
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess  |
	preemptedProcess _ Processor preemptedProcess.

	"Only debug preempted process if its priority is >= UIProcess' priority"
	UIProcess ifNotNil: [
		preemptedProcess priority < UIProcess priority ifTrue: [
			preemptedProcess _ UIProcess ]].

	Debugger interruptProcess: preemptedProcess label: 'User Interrupt'! !
!DisplayScreen methodsFor: 'other' stamp: 'jmv 12/28/2017 15:22:40' prior: 16835232!
newDepth: pixelSize
"
	Display newDepth: 8.
	Display newDepth: 1.
"
	(self supportsDisplayDepth: pixelSize)
		ifFalse: [ ^self inform:'Display depth ', pixelSize printString, ' is not supported on this system' ].
	self newDepthNoRestore: pixelSize.
	self runningWorld ifNotNil: [ :w | w  buildMagnifiedBackgroundImage ].
	self restore.! !
!DisplayScreen class methodsFor: 'display box access' stamp: 'jmv 12/28/2017 15:37:02' prior: 16835493!
     checkForNewScreenSize
	"Check whether the screen size has changed and if so take appropriate actions"

	Display extent = DisplayScreen actualScreenSize ifTrue: [^ self].
	UISupervisor restoreDisplay! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/28/2017 15:33:32' prior: 50377855!
                        showBalloon: msgString hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	(w _ self world) ifNil: [^ self].
	h _ aHand.
	h ifNil:[
		h _ w activeHand].
	balloon _ HoverHelpMorph contents: msgString.
	
	"Do it in a while. In some cases, processing the event that might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: h ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/28/2017 15:32:34' prior: 16875939!
                openInWorld

	self runningWorld
		ifNil: [ UISupervisor whenUIinSafeState: [ self openInWorld ]]
		ifNotNil: [ :w | self openInWorld: w ]! !
!PasteUpMorph class methodsFor: 'system startup' stamp: 'jmv 12/28/2017 15:37:37' prior: 16887941!
                initClassCachedState

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each buildMagnifiedBackgroundImage.
		each isWorldMorph ifTrue: [
			each restoreDisplay ]].
	Cursor normal activateCursor! !
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 12/28/2017 15:31:28' prior: 50378168!
                 arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self getSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [
					oldSelection > self minimumSelection ifTrue: [
						nextSelection _ (oldSelection-1 to: 1 by: -1) detect: [ :i | ( scroller submorphs at: i) indentLevel < selectedMorph indentLevel ]].
					]]].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		UISupervisor whenUIinSafeState: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 12/28/2017 15:39:41' prior: 50377944!
          arrowKey: aChar
	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."
	| keyEvent oldSelection nextSelection max min howMany answer w |
	answer _ false.
	keyEvent _ aChar numericValue.
	oldSelection _ self getCurrentSelectionIndex.
	nextSelection _ oldSelection.
	max _ self maximumSelection.
	min _ self minimumSelection.
	howMany _ self numSelectionsInView.	"get this exactly??"

	keyEvent = 31 ifTrue: [
		"down-arrow; move down one, wrapping to top if needed"
		nextSelection _ oldSelection + 1.
		nextSelection > max ifTrue: [ nextSelection _ 1 ]].

	keyEvent = 30 ifTrue: [
		"up arrow; move up one, wrapping to bottom if needed"
		nextSelection _ oldSelection - 1.
		nextSelection < 1 ifTrue: [ nextSelection _ max ]].

	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"
	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"
	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"
	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"
	nextSelection = oldSelection ifFalse: [
		w _ self owningWindow.
		(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

			"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
			self listMorph highlightedRow: nextSelection.

			"Update the model in next world cycle, so user gets the immediate feedback."
			UISupervisor whenUIinSafeState: [
				self changeModelSelection: nextSelection ].
			answer _ true ]].
	^answer! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 12/28/2017 15:39:45' prior: 50377998!
              mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	row _ self rowAtLocation: localEventPosition.

	row = 0 ifTrue: [
		^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
	self listMorph highlightedRow: row.

	w _ self owningWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Different from PluggableListMorph. There, we highlight on mouse down, and act on mouse up.
		Here, we act on mouse down, because we support dragging of selection, so mouse up will
		only happen after user is finished dragging. In order to get the highlight visible for the user,
		update the model on next world cycle."
		UISupervisor whenUIinSafeState: [
			"Set or clear new primary selection (listIndex)"
			dragOnOrOff
				ifTrue: [self changeModelSelection: row]
				ifFalse: [self changeModelSelection: 0].
			"Need to restore the old one, due to how model works, and set new one."
			oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
			self listSelectionAt: row put: dragOnOrOff ].
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/28/2017 15:41:35' prior: 50378056!
           openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect _ self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse) "
	UISupervisor whenUIinSafeState: [ self activate ]! !
!TaskbarMorph methodsFor: 'events' stamp: 'jmv 12/28/2017 15:41:40' prior: 50378072!
                          screenSizeChanged
	"Respond to change in screen size by repositioning self to bottom of screen"
	
"	Transcript newLine; print: 'Taskbar screenSizeChanged'.
"
	| y e |
	UISupervisor whenUIinSafeState: [
		self world ifNotNil: [ :w |
			y _ w morphExtent y - self defaultHeight.
			e _ self internalizeDistance: w morphExtent x @ self defaultHeight.
			self morphPosition: 0@y extent: e ]]! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 12/28/2017 15:31:44' prior: 50378087!
 acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar scrollValue.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			UISupervisor whenUIinSafeState: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar internalScrollValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !
!WorldState class methodsFor: 'class initialization' stamp: 'jmv 12/28/2017 15:26:18' prior: 50378134!
                               addDeferredUIMessage: evaluableObject
	"Objects should not be calling directly as this will disappear from this location!!  From the sender, instead to schedule on the currently running world use:
	self runningWorld addDeferredUIMessage: ...
	And to schedule on the world a given Morph exists in use:
	self world addDeferredUIMessage: ..."
	self deferredUIMessages nextPut: evaluableObject! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 12/28/2017 15:38:38' prior: 16934600!
fullScreenOff

	Display fullScreenMode: false.
	DisplayScreen checkForNewScreenSize.
	myWorld restoreDisplay! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 12/28/2017 15:38:40' prior: 16934606!
                         fullScreenOn

	Display fullScreenMode: true.
	DisplayScreen checkForNewScreenSize.
	myWorld restoreDisplay! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 12/28/2017 15:37:53' prior: 50341417!
                       buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Preferences...'. { self. #preferencesDo}.
					'put up a menu offering many controls over appearance and system preferences.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Restore Display (r)'. { myWorld. #restoreDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name\and save it under that name on disk.\Clear all user preferences and user state (class vars).' withNewLines}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the image and quit out of Cuis.'}.				
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!Theme class methodsFor: 'class initialization' stamp: 'jmv 12/28/2017 15:38:58' prior: 50377319!
                              currentTheme: aTheme

	CurrentTheme := aTheme new.
	SHTextStylerST80 releaseClassCachedState.
	self runningWorld ifNotNil: [ :w |
		w backgroundImage ifNil: [
			w color: CurrentTheme background ]].
	SystemWindow initialize.
	BitBltCanvas releaseClassCachedState.
	self runningWorld ifNotNil: [ :w |
		CurrentTheme useTaskbar
			ifTrue: [w showTaskbar]
			ifFalse: [w hideTaskbar].
		w restoreDisplay ].
	
	^ CurrentTheme! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'jmv 12/28/2017 15:40:01' prior: 50338203!
            runSuiteShowingProgress

	[ self registerTestSuiteAction. 
	progressBar openInWorld.
	self runSuite ] ensure: [
		self unregisterTestSuiteAction.
		UISupervisor whenUIinSafeState: [progressBar dismissMorph] ].
	! !
!AndreasSystemProfiler methodsFor: 'reporting' stamp: 'jmv 12/28/2017 15:31:01' prior: 50378582!
        doReport
	"Report the results of this profiler run"
	| report |
	report _ self report.
	UISupervisor whenUIinSafeState: [
		SystemWindow
			editText: (Workspace withText: report)
			label: 'Spy Results'
			wrap: false ]! !
!SHTextStyler methodsFor: 'styling' stamp: 'jmv 12/28/2017 15:40:06' prior: 16903157!
           styleInBackgroundProcess
	"Do the styling on a copy of the provided text (and in a separate process).
	After finishing, send it to the model, by triggering #shoutStyled
	The the model should grab the TextAttributes we added to the copy, as appropriate."
	self terminateBackgroundStylingProcess.

	self mutex critical: [
		"This part runs at low priority, and signals sem when finished"
		backgroundProcess _  [
			self privateStyle.
			UISupervisor whenUIinSafeState: [
				textModel changed: #shoutStyled ].
			] newProcess.
		backgroundProcess
			priority: Processor userBackgroundPriority;
			name: 'Shout format';
			resume
	]! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'jmv 12/28/2017 15:39:54' prior: 16891167!
             inform: aString
	"PopUpMenu inform: 'I like Cuis'"

	UISupervisor whenUIinSafeState: [ (PopUpMenu labels: ' OK ') startUpWithCaption: aString ]! !

PasteUpMorph removeSelector: #addDeferredUIMessage:!

PasteUpMorph removeSelector: #addDeferredUIMessage:!

PasteUpMorph removeSelector: #restoreMorphicDisplay!

PasteUpMorph removeSelector: #restoreMorphicDisplay!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3242-UISupervisor-whenUIinSafeState-JuanVuletich-2017Dec28-15h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3242] on 28 December 2017 at 3:56:57 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 12/28/2017 15:54:48' prior: 50379607!
  ui
	^UIProcess ifNotNil: [
		UIProcess isSuspended ifFalse: [
			UIProcess animatedUI ]]! !
!UISupervisor class methodsFor: 'services' stamp: 'jmv 12/28/2017 15:56:12' prior: 50379213!
       restoreDisplay
	DisplayScreen startUp.
	self ui ifNotNil: [ :guiRootObject |
		guiRootObject restoreDisplay ].
	self whenUIinSafeState: [ Cursor normal activateCursor ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3243-answerUIonlyIfActive-JuanVuletich-2017Dec28-15h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3243] on 29 December 2017 at 10:30:48 am'!
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 10:29:16'!
                         privateVisualSelection: item
	"Called internally to set a new selection.
	Does not update model"

	self privateVisualSelectionIndex: (self indexForItem: item)! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 10:19:02'!
             privateVisualSelectionIndex: idx
	"Called internally to select the index-th item.
	Does not update model"
	self selectedMorph: (self listMorphAt: idx).
	self scrollSelectionIntoView! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 09:42:44'!
                      visualSelectionIndex
	^scroller submorphs indexOf: selectedMorph! !
!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 12/29/2017 10:28:53'!
             indexForItem: item
	| i |
	item ifNil: [
		^ 0 ].
	i _ scroller submorphs findFirst: [ :m | m complexContents == item ].
	i > 0 ifTrue: [
		^ i ].
	i _ scroller submorphs findFirst: [ :m | m withoutListWrapper = item withoutListWrapper ].
	^ i! !
!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 12/29/2017 09:32:10'!
                        setSelectionIndex: anInteger
	"Change the model's selected item index to be anInteger."

	setIndexSelector ifNotNil: [
		model perform: setIndexSelector with: anInteger.
		self update: getIndexSelector.
		^ true ].
	^ false! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 09:05:26'!
               privateVisualSelection: item
	"Called internally to set a new selection.
	Does not update model"

	self privateVisualSelectionIndex: (list indexOf: item)! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 08:57:30'!
                     privateVisualSelectionIndex: index
	"Called internally to select the index-th item.
	Does not update model"
	| row |
	row _ index ifNil: [ 0 ].
	row _ row min: self getListSize.  "make sure we don't select past the end"
	self listMorph selectedRow: row.
	self scrollSelectionIntoView! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 08:59:40'!
                   visualSelection 
	self visualSelectionIndex = 0 ifTrue: [ ^nil ].
	list ifNotNil: [ ^list at: self visualSelectionIndex ].
	^ self getListItem: self visualSelectionIndex! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 08:54:40'!
     visualSelectionIndex
	"return the index we have currently selected, or 0 if none"
	^self listMorph selectedRow ifNil: [ 0 ]! !
!PluggableListMorphByItem methodsFor: 'model access' stamp: 'jmv 12/29/2017 09:32:13'!
          setSelectionIndex: anInteger
	"Change the model's selected item to be the one at the given index."

	| item |
	setIndexSelector ifNotNil: [
		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).
		model perform: setIndexSelector with: item.
		self update: getIndexSelector.
		^ true ].
	^false
	! !
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 12/29/2017 09:18:40' prior: 50379690!
                       arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self visualSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [
					oldSelection > self minimumSelection ifTrue: [
						nextSelection _ (oldSelection-1 to: 1 by: -1) detect: [ :i | ( scroller submorphs at: i) indentLevel < selectedMorph indentLevel ]].
					]]].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		UISupervisor whenUIinSafeState: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 12/29/2017 10:15:47' prior: 16853285!
    setSelectionIndex: idx
	"Change the model's selected item index to be anInteger."

	^self setSelectedMorph: (self listMorphAt: idx)! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 10:30:10' prior: 16853374!
                        selection: item
	"Called to set a new selection.
	Updates both model and view."
	"Assumes scroller submorphs is exactly our list.
	Note: MAY NOT work right if list includes repeated items"

	self selectionIndex: (self indexForItem: item)! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 10:23:15' prior: 16853391!
              selectionIndex: anInteger
	"Public. Call to set selection.
	Usually, view is updated from model updates.
	If model updating fails (no model index setter defined) then just update visuals."

	(self setSelectionIndex: anInteger) ifFalse: [
		self privateVisualSelectionIndex: anInteger ]! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 10:16:19' prior: 16853399!
                              setSelectedMorph: aMorph
	setSelectionSelector ifNil: [ ^ false ].
	model 
		perform: setSelectionSelector
		with: aMorph complexContents	."leave last wrapper in place"
	^ true

 ! !
!HierarchicalListMorph methodsFor: 'updating' stamp: 'jmv 12/29/2017 10:20:49' prior: 16853407!
         update: aSymbol
	super update: aSymbol.
	aSymbol == getSelectionSelector 
		ifTrue: [
			self privateVisualSelection: self getCurrentSelectionItem.
			^self ].
	aSymbol == getListSelector 
		ifTrue: [
			self list: self getList.
			^self ].

	"Indeed not pretty"
	( aSymbol notEmpty and: [aSymbol first == #openPath]) 
		ifTrue: [
			^(scroller submorphs at: 1 ifAbsent: [^self]) 
				openPath: aSymbol allButFirst adaptor: #asString compare: #=]! !
!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 12/29/2017 10:20:41' prior: 16853481!
                               insertNewMorphs: morphList

	scroller addAllMorphs: morphList.
	scroller adjustExtent.
	self setScrollDeltas.
	self privateVisualSelection: self getCurrentSelectionItem! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/29/2017 09:43:57' prior: 50367353!
                         doubleClick: aMouseButtonEvent localPosition: localEventPosition
	| index |
	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index _ self rowAtLocation: localEventPosition.
	index = 0 ifTrue: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	index == self visualSelectionIndex
		ifFalse: [ self setSelectionIndex: index ].
	^ self model perform: doubleClickSelector! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/29/2017 09:44:01' prior: 16888657!
                               mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: localEventPosition.
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [ ^ self ]].
	(autoDeselect == false and:  [row = 0 ]) ifTrue: [ ^ self ].  "work-around the no-mans-land bug"
	"No change if model is locked"
	(autoDeselect and: [ row == self visualSelectionIndex ])
		ifTrue: [
			aMouseButtonEvent mouseButton1Changed ifTrue: [
				self setSelectionIndex: 0 ]]
		ifFalse: [ self setSelectionIndex: row ]! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 12/29/2017 09:38:13' prior: 50379758!
          arrowKey: aChar
	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."
	| keyEvent oldSelection nextSelection max min howMany answer w |
	answer _ false.
	keyEvent _ aChar numericValue.
	oldSelection _ self getCurrentSelectionIndex.
	nextSelection _ oldSelection.
	max _ self maximumSelection.
	min _ self minimumSelection.
	howMany _ self numSelectionsInView.	"get this exactly??"

	keyEvent = 31 ifTrue: [
		"down-arrow; move down one, wrapping to top if needed"
		nextSelection _ oldSelection + 1.
		nextSelection > max ifTrue: [ nextSelection _ 1 ]].

	keyEvent = 30 ifTrue: [
		"up arrow; move up one, wrapping to bottom if needed"
		nextSelection _ oldSelection - 1.
		nextSelection < 1 ifTrue: [ nextSelection _ max ]].

	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"
	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"
	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"
	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"
	nextSelection = oldSelection ifFalse: [
		w _ self owningWindow.
		(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

			"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
			self listMorph highlightedRow: nextSelection.

			"Update the model in next world cycle, so user gets the immediate feedback."
			UISupervisor whenUIinSafeState: [
				self setSelectionIndex: nextSelection ].
			answer _ true ]].
	^answer! !
!PluggableListMorph methodsFor: 'menus' stamp: 'jmv 12/29/2017 09:50:46' prior: 16888894!
                        copySelectionToClipboard
	"Copy my selected item to the clipboard as a string"

	self visualSelection 
		ifNotNil: [ :sel |
			Clipboard storeObject: sel asString ]
		ifNil: [
			self flash ]! !
!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 12/29/2017 09:38:18' prior: 16888950!
                            keyboardSearch: aChar 
	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |
	nextSelection _ oldSelection _ self getCurrentSelectionIndex.
	max _ self maximumSelection.
	milliSeconds _ Time localMillisecondClock.
	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"
		lastKeystrokes _ ''].
	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.
	lastKeystrokeTime _ milliSeconds.
	nextSelectionList _ OrderedCollection newFrom: (list copyFrom: oldSelection + 1 to: max).
	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).
	"Get rid of blanks and style used in some lists"
	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]
				ifNone: [^ self flash"match not found"].
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	nextSelection _ list findFirst: [:a | a == nextSelectionText].
	"No change if model is locked"
	oldSelection == nextSelection ifTrue: [^ self flash].
	^ self setSelectionIndex: nextSelection! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 10:05:11' prior: 16889043!
                 selection: item
	"Public. Call to set selection.
	Usually, view is updated from model updates.
	If model updating fails (no model index setter defined) then just update visuals."

	self selectionIndex: (list indexOf: item)! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 12/29/2017 09:32:29' prior: 16889057!
selectionIndex: anInteger
	"Public. Call to set selection.
	Usually, view is updated from model updates.
	If model updating fails (no model index setter defined) then just update visuals."

	(self setSelectionIndex: anInteger) ifFalse: [
		self privateVisualSelectionIndex: anInteger ]! !
!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 12/29/2017 09:46:24' prior: 16889068!
  update: aSymbol 
	"Refer to the comment in View|update:."

	super update: aSymbol.
	aSymbol == getListSelector ifTrue: [
		self updateList.
		^ self].
	aSymbol == getIndexSelector ifTrue: [
		self privateVisualSelectionIndex: self getCurrentSelectionIndex ]! !
!PluggableListMorph methodsFor: 'updating' stamp: 'jmv 12/29/2017 09:46:28' prior: 16889079!
                              updateList
	| index |
	"the list has changed -- update from the model"
	self getList.
	self listMorph listChanged.
	self setScrollDeltas.
	index _ self getCurrentSelectionIndex.
	self privateVisualSelectionIndex: index! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 12/29/2017 09:38:30' prior: 50379812!
 mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	row _ self rowAtLocation: localEventPosition.

	row = 0 ifTrue: [
		^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
	self listMorph highlightedRow: row.

	w _ self owningWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Different from PluggableListMorph. There, we highlight on mouse down, and act on mouse up.
		Here, we act on mouse down, because we support dragging of selection, so mouse up will
		only happen after user is finished dragging. In order to get the highlight visible for the user,
		update the model on next world cycle."
		UISupervisor whenUIinSafeState: [
			"Set or clear new primary selection (listIndex)"
			dragOnOrOff
				ifTrue: [self setSelectionIndex: row]
				ifFalse: [self setSelectionIndex: 0].
			"Need to restore the old one, due to how model works, and set new one."
			oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
			self listSelectionAt: row put: dragOnOrOff ].
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 12/29/2017 09:38:32' prior: 50365060!
         mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar scrollValue < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self setSelectionIndex: row ]
		ifFalse: [ self setSelectionIndex: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PluggableListMorphOfMany methodsFor: 'updating' stamp: 'jmv 12/29/2017 09:46:31' prior: 16889359!
          update: aSymbol 
	super update: aSymbol.
	aSymbol == #allSelections ifTrue: [
		self privateVisualSelectionIndex: self getCurrentSelectionIndex.
		self redrawNeeded]! !

PluggableListMorphByItem removeSelector: #changeModelSelection:!

PluggableListMorphByItem removeSelector: #changeModelSelection:!

PluggableListMorph removeSelector: #changeModelSelection:!

PluggableListMorph removeSelector: #changeModelSelection:!

PluggableListMorph removeSelector: #getListSelector!

PluggableListMorph removeSelector: #getListSelector!

PluggableListMorph removeSelector: #selection!

PluggableListMorph removeSelector: #selection!

PluggableListMorph removeSelector: #selectionIndex!

PluggableListMorph removeSelector: #selectionIndex!

HierarchicalListMorph removeSelector: #getSelectionIndex!

HierarchicalListMorph removeSelector: #getSelectionIndex!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3244-PluggableLists-protocolCleanup-JuanVuletich-2017Dec29-10h09m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3244] on 4 January 2018 at 3:38:22 pm'!
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 1/4/2018 15:37:17'!
         incrementFraction
	"
	#(10 12.5 15 20) incrementFraction
	"
	| displaced answer |
	displaced _ self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first.
	answer _ self copy.
	answer -= displaced.
	^answer / displaced! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3245-IncrementFraction-JuanVuletich-2018Jan04-13h50m-jmv.1.cs.st----!

----SNAPSHOT----#(4 January 2018 5:56:30.980531 pm) Cuis5.0-3245-v3.image priorSource: 1455015!

----QUIT----#(4 January 2018 5:56:41.426633 pm) Cuis5.0-3245-v3.image priorSource: 1570120!

----STARTUP----#(19 January 2018 10:34:48.803022 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3245-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3245] on 11 January 2018 at 11:01:17 am'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/11/2018 00:15:12' prior: 50379478!
    snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup guiRootObject guiRootObjectClass reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	guiRootObjectClass _ UISupervisor ui class.
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.

	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ guiRootObjectClass newWorld ]).
	Display triggerEvent: #screenSizeChanged.

	reopenTranscript ifTrue: [
		UISupervisor whenUIinSafeState: [
			TranscriptWindow openTranscript ]].
	"
	UISupervisor whenUIinSafeState: [
		guiRootObject fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3246-FixTaskbarBugOnImageSave-JuanVuletich-2018Jan11-11h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3246] on 12 January 2018 at 9:18:55 am'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/12/2018 09:16:22' prior: 50380730!
       snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup guiRootObject guiRootObjectClass reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	guiRootObjectClass _ UISupervisor ui class.
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.

	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ guiRootObjectClass newWorld ]).

	Display triggerEvent: #screenSizeChanged.

	UISupervisor whenUIinSafeState: [
		"guiRootObject fullRepaintNeeded."
		reopenTranscript ifTrue: [
			TranscriptWindow openTranscript ]].

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!PasteUpMorph class methodsFor: 'system startup' stamp: 'jmv 1/12/2018 09:17:41' prior: 50379678!
                            initClassCachedState

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each buildMagnifiedBackgroundImage.
		each isWorldMorph ifTrue: [
			each redrawNeeded ]].
	Cursor normal activateCursor! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3247-AvoidWindowRepositionOnImageSave-JuanVuletich-2018Jan12-09h13m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3247] on 12 January 2018 at 9:26:33 am'!
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 1/12/2018 09:24:56' prior: 16813375!
                 browseProtocol
	"Create and schedule a new protocol browser on the currently selected class or meta."
	| aPBrowser label |
	model selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |
		aPBrowser _ ProtocolBrowser new onSubProtocolOf: classOrMetaclass.
		label _'Sub-protocol of: ', classOrMetaclass name.
		ProtocolBrowserWindow open: aPBrowser label: label ]! !
!DebuggerWindow methodsFor: 'keyboard shortcuts' stamp: 'jmv 1/12/2018 09:25:29' prior: 16831235!
               browseFullProtocolIn: anInspector
	"Spawn a window showing full protocol for the receiver's selection"

	ProtocolBrowserWindow
		openFullProtocolForClass: anInspector selectedClassOrMetaClass! !
!InspectorWindow methodsFor: 'menu commands' stamp: 'jmv 1/12/2018 09:23:23' prior: 16857301!
                               browseFullProtocol
	"Spawn a window showing full protocol for the receiver's selection"

	ProtocolBrowserWindow openFullProtocolForClass: model selectedClassOrMetaClass! !
!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 1/12/2018 09:23:27' prior: 16883379!
                 browseFullProtocol
	"Spawn a window showing full protocol for the receiver's selection"

	ProtocolBrowserWindow openFullProtocolForClass: model selectedClass! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3248-UseProtocolBrowserWindow-JuanVuletich-2018Jan12-09h23m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3248] on 13 January 2018 at 3:55:27 pm'!
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/13/2018 15:49:22'!
          fillRects: rectangleList
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."


	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		combinationRule: Form over.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt fillColor: Color random.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 50) wait! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 1/13/2018 15:47:59' prior: 50360589!
        drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world fillRects: xrects ].
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !

PasteUpMorph removeSelector: #fillRects:color:!

PasteUpMorph removeSelector: #fillRects:color:!

PasteUpMorph removeSelector: #flashRects:color:!

PasteUpMorph removeSelector: #flashRects:color:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3249-MorphicInvalidationAidsEnh-JuanVuletich-2018Jan13-15h40m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3249] on 13 January 2018 at 5:18:44 pm'!
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 1/13/2018 17:03:34'!
              setCanvas: aCanvas

	^ worldState ifNotNil: [ worldState setCanvas: aCanvas ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3250-setCanvas-JuanVuletich-2018Jan13-17h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3250] on 14 January 2018 at 11:26:34 am'!
!WorldState methodsFor: 'stepping' stamp: 'jmv 1/14/2018 11:26:09' prior: 50340235!
                             runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue readyToProcess |

	queue _ self class deferredUIMessages.
	"Processing the queue until empty is wrong if a block in it calls #addDeferredUIMessage: itself, because this loop will never end.
	Instead, process no more than entries already in queue befor we start iterating!!"
	readyToProcess _ queue size.
	readyToProcess timesRepeat: [
		queue nextOrNil ifNotNil: [ :block |
			block value
		]
	].
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3251-DeferredMorphicProcessingFix-JuanVuletich-2018Jan14-11h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3251] on 14 January 2018 at 7:37:37 pm'!
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 1/14/2018 19:19:58' prior: 16855794!
                 keyboardFocusChange: aBoolean
	
	"The message is sent to a morph when its keyboard focus changes.
	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.
	In this case, all we need to do is to redraw border feedback"
	aBoolean
		ifTrue: [
			"A hand is wanting to send us characters..."
			editor ifNil: [ self editor storeSelectionInComposition ].	"Forces install"
			self showsBlinkingCursor ifTrue: [
				editor hasSelection ifFalse: [
					self startBlinking ]]]
		ifFalse: [ self stopBlinking ].
	"Selection might be shown differently when focused"
	owner
		ifNotNil: [ owner redrawNeeded ]
		ifNil: [ self redrawNeeded ]		"Or at least redraw us"! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 1/14/2018 19:14:30' prior: 16856065!
                   selectionChanged

	self textComposition selectionRects do: [ :r | self invalidateLocalRect: r ].
	editor hasSelection
		ifTrue: [ self stopBlinking ]
		ifFalse: [ self startBlinking ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3252-InnerTextMorph-avoidUnnededStepping-JuanVuletich-2018Jan14-19h37m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3251] on 14 January 2018 at 7:38:44 pm'!
!WorldState methodsFor: 'update cycle' stamp: 'jmv 1/14/2018 19:31:36' prior: 50340754!
                      doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent | self class deferredUIMessages isEmpty not
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3253-MorphicMaxFPSifDeferredBlocks-JuanVuletich-2018Jan14-19h37m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3253] on 15 January 2018 at 4:47:07 pm'!
!DisplayScreen methodsFor: 'initialization' stamp: 'jmv 1/15/2018 15:51:20'!
      initialize
	self
		setExtent: self class actualScreenSize
		depth: (self class actualScreenDepth ifNil: [ 32 ])! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 1/15/2018 16:08:16' prior: 16820423!
       getPreambleFrom: aFileStream at: position
	|  writeStream c p |
	writeStream _ String new writeStream.
	p _ position.
	c _ nil.
	[ p >= 0 and: [ c ~~ $!! ]] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		p _ p - 1 ].
	[ p >= 0] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		c == $!!
			ifTrue: [^ writeStream contents reverse ]
			ifFalse: [ writeStream nextPut: c ].
		p _ p - 1 ].
	^ nil! !
!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 1/15/2018 16:08:53' prior: 16821137!
            timeStamp
	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."

	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"

	| file preamble stamp tokens tokenCount |
	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"
	file _ SourceFiles at: self fileIndex.
	file ifNil: [^ String new].  "sources file not available"
	"file does not exist happens in secure mode"
	file _ [file name asFileEntry readStream] on: FileDoesNotExistException do: [ :ex| nil ].
	file ifNil: [^ String new].
	preamble _ self getPreambleFrom: file at: (0 max: self filePosition).
	preamble ifNil: [ ^ '' ].
	stamp _ String new.
	tokens _ (preamble findString: 'methodsFor:' startingAt: 1) > 0
		ifTrue: [Scanner new scanTokens: preamble]
		ifFalse: [Array new  "ie cant be back ref"].
	(((tokenCount _ tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])
		ifTrue:
			[(tokens at: tokenCount - 3) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp _ tokens at: tokenCount - 2]].
	((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])
		ifTrue:
			[(tokens at: tokenCount  - 1) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
					stamp _ tokens at: tokenCount]].
	file close.
	^ stamp! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/15/2018 16:45:44' prior: 50380858!
        snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup guiRootObject guiRootObjectClass reopenTranscript |
	self logSnapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	guiRootObjectClass _ UISupervisor ui class.
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: DisplayScreen new.
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.

	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ guiRootObjectClass newWorld ]).
	Display triggerEvent: #screenSizeChanged.
	
	self restoreLostChangesIfNecessary.

	UISupervisor whenUIinSafeState: [
		"guiRootObject fullRepaintNeeded."
		reopenTranscript ifTrue: [
			TranscriptWindow openTranscript ]].

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 1/6/2017 09:59:32' prior: 50369999!
                           doStartUp: isARealStartup
	"
	isARealStartup
		true: system is coming up (VM and image just started)
		false: we have just saved an image snapshot, but didn't quit.
	"

	"Here, startup begins!!"
	Cursor normal activateCursor.
	self setGCParameters.
	isARealStartup ifTrue: [
		self clearExternalObjects ].
	self readCommandLineArguments.
	self processStartUpList: isARealStartup.
	isARealStartup ifTrue: [
		self setPlatformPreferences.
		self setStartupStamp ]! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'jmv 1/15/2018 16:17:47' prior: 50370731!
                               hasToRestoreChangesFrom: changesFile

	| chunk  |
	
	changesFile position: self lastQuitLogPosition.
	[ changesFile atEnd ] whileFalse: [ chunk := changesFile nextChunk ].
	
	^chunk notNil and: [(self isSnapshotQuitOrQuitNoSaveRecord: chunk) not]
! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 1/15/2018 15:51:11' prior: 16835515!
       actualScreenDepth
	<primitive: 'primitiveScreenDepth'>
	^ Display ifNotNil: [ Display depth ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3254-fixStartupFreezeWhenBrokenChanges-JuanVuletich-2018Jan15-16h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3254] on 19 January 2018 at 10:28:10 am'!
!Collection methodsFor: 'enumerating' stamp: 'jmv 1/19/2018 08:57:00'!
  select: selectBlock thenDo: doBlock
	"Equivalent to 
		(self select: selectBlock) do: doBlock
	but avoid creating an extra collection."

	self do: [ :each | (selectBlock value: each) ifTrue: [ doBlock value ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3255-selectthenDo-JuanVuletich-2018Jan19-10h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3254] on 19 January 2018 at 10:28:40 am'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/19/2018 10:12:45'!
                       snapshot: save andQuit: quit

	self snapshot: save andQuit: quit embedded: false clearAllClassState: false! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/19/2018 08:53:57'!
                               snapshot: save andQuit: quit embedded: embeddedFlag

	self snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: false! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3256-quitProtocol-JuanVuletich-2018Jan19-10h28m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3254] on 19 January 2018 at 10:28:58 am'!
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 1/19/2018 10:25:24' prior: 50343078!
                  copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak and Cuis projects. 1997-2018.'! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3257-updateCopyrightNotice-JuanVuletich-2018Jan19-10h28m-jmv.1.cs.st----!

----SNAPSHOT----#(19 January 2018 10:34:56.475259 am) Cuis5.0-3257-v3.image priorSource: 1570217!

----QUIT----#(19 January 2018 10:35:24.515101 am) Cuis5.0-3257-v3.image priorSource: 1599859!

----STARTUP----#(26 February 2018 3:44:01.300155 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3257-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3257] on 22 January 2018 at 5:54:08 pm'!
!Transcript class methodsFor: 'displaying' stamp: 'jmv 1/22/2018 17:53:13' prior: 50357948!
                             displayOn: aForm in: aRectangle
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f canvas innerR |
	aForm fill: aRectangle fillColor: Color white.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	fh _ font height.
	count _ innerR height // fh.
	x _ innerR left.
	y _ innerR top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	[ i <= lastIndex ] whileTrue: [
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: Color veryDarkGray.
		y _ y + fh.
		i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: Color veryDarkGray! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3258-FixTranscriptResizeOnHugeFonts-JuanVuletich-2018Jan22-17h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3257] on 6 February 2018 at 11:27:37 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 2/6/2018 11:27:31' prior: 16902489!
                 parseByteArray
	"Literal ByteArray or literal FloatArray"
	[currentTokenFirst == $]] whileFalse: [
		currentTokenFirst isDigit | (currentTokenFirst = $-)
			ifTrue: [
				"do not parse the number, can be time consuming"
				self scanPast: #number]
			ifFalse: [
				self failWhen: currentTokenFirst == $. .
				self error]].
	self scanPast: #arrayEnd! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3259-ShoutLiteralFloatArrays-JuanVuletich-2018Feb06-11h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3259] on 11 February 2018 at 6:51:44 pm'!
!Color methodsFor: 'testing' stamp: 'jmv 2/11/2018 18:50:54'!
                    isCollection
	^ false! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3260-Color-is-not-collection-JuanVuletich-2018Feb11-18h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3260] on 23 February 2018 at 3:19:20 pm'!
!TextModelMorph methodsFor: 'events' stamp: 'jmv 2/23/2018 14:55:30'!
                     clickAndHalf: aMouseButtonEvent localPosition: localEventPosition

	self textMorph clickAndHalf: aMouseButtonEvent localPosition: localEventPosition! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 2/23/2018 14:56:20'!
  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	scroller mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3261-ClickNHalf-SelectAll-OnEmptyTextArea-JuanVuletich-2018Feb23-15h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3260] on 23 February 2018 at 3:00:53 pm'!
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 2/23/2018 15:00:36' prior: 16836736!
                               selectAll: aKeyboardEvent 
	"select everything, invoked by cmd-a.  1/17/96 sw"

	self selectAll.
	^ true! !

TextEditor removeSelector: #selectAll:!

TextEditor removeSelector: #selectAll:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3262-SelectAll-cleanup-JuanVuletich-2018Feb23-14h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3262] on 23 February 2018 at 3:46:21 pm'!
!HandMorph methodsFor: 'private events' stamp: 'jmv 2/23/2018 15:43:19' prior: 16852387!
   shouldControlEmulateAltFor: keyValue
	"At least on Linux Windows, command key is usually ctrl, not alt."

	^ true! !
!Theme methodsFor: 'keyboard shortcuts' stamp: 'jmv 2/23/2018 15:42:17' prior: 50369232!
                  keyStroke: aKeyboardEvent morph: aMorph

	aKeyboardEvent commandAltKeyPressed | aKeyboardEvent controlKeyPressed
		ifFalse: [ ^ false ].

	aKeyboardEvent keyValue = $w numericValue ifTrue: [
		aMorph owningWindow ifNotNil: [ :w |
			(w morphContainsPoint: (w internalizeFromWorld: aKeyboardEvent eventPosition)) ifTrue: [
				w delete. 
				^true ]	]].
"	aKeyboardEvent keyValue = $f numericValue
		ifTrue: [aMorph owningWindow ifNotNil: [ :w | w fullScreen. ^true ]].
"
	^ false! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3263-Ctrl-means-Command-JuanVuletich-2018Feb23-15h41m-jmv.1.cs.st----!

----SNAPSHOT----#(26 February 2018 3:44:31.144618 pm) Cuis5.0-3263-v3.image priorSource: 1599958!

----QUIT----#(26 February 2018 3:44:41.305869 pm) Cuis5.0-3263-v3.image priorSource: 1604939!

----STARTUP----#(9 March 2018 11:47:50.795017 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3263-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3263] on 1 March 2018 at 4:59:38 pm'!
!HandMorph methodsFor: 'private events' stamp: 'jmv 3/1/2018 16:59:14' prior: 50381776!
               shouldControlEmulateAltFor: keyValue
	"At least on Linux Windows, command key is usually ctrl, not alt.
	But not for arrow keys!! ctrl-left ~~ alt-left"
	^ keyValue > 32! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3264-Fix-ctrl-ArrowKeys-JuanVuletich-2018Mar01-16h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3264] on 4 March 2018 at 12:09:15 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 3/4/2018 12:06:08' prior: 50371688!
                             tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results


	Performance of early 80's experimental Smalltalk systems.
	Estimations from http://wiki.c2.com/?GreenBook and http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive

		DEC PDP-11/23 											  5,000 bytecodes/sec (Green Book, p.128)
		Apple 5MHz 68000 							   9,000 to 11,000 bytecodes/sec (Green Book, p.187, 1982-qtr4-magnolia-perf-graph.pdf)
		VAX-11/780 C HP Smalltalk 				  5,000 to 25,000 bytecodes/sec (Green Book, p.235)
		VAX-11/780 C Berkeley Smalltalk 			 12,000 to 23000 bytecodes/sec (Green Book, p.203, 1982-qtr4-magnolia-perf-graph.pdf)
		DEC VAX-11/780 assembly 				20,000 to 25,000 bytecodes/sec (Green Book, p.149, 1982-qtr4-magnolia-perf-graph.pdf)
		Xerox Dolphin  code 					 	20,000 to 40,000 bytecodes/sec (Green Book, p.44, p.203, 1982-qtr4-magnolia-perf-graph.pdf)
		TEK Magnolia 10MHz 68000 						      50,000 bytecodes/sec (1983-Magnolia-st-perf.pdf)
		Xerox Dorado 14MHz code			 400,000 to 500,000 bytecodes/sec (Green book, p.44, p.203, 1982-qtr4-magnolia-perf-graph.pdf)


	0 tinyBenchmarks
		
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		RasPi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec
		
		RasPi3B - StackSpur 								44,107,512 bytecodes/sec; 			2,767,863 sends/sec
		RasPi3B - CogSpur 							    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		2.70GHz Core i5-6400 -CogSpur64 		3,162,934,362 bytecodes/sec; 		243,321,293 sends/sec
	
		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue: [n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue: [n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^String streamContents: [ :strm |
		(n1 * 500000 * 1000) // t1 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Bytecodes/second; ' ].
		(r * 1000) // t2 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Sends/second' ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3265-EarlySmalltalkPerformanceNumbers-JuanVuletich-2018Mar04-12h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3265] on 4 March 2018 at 12:46:18 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 3/4/2018 12:44:36' prior: 50381834!
                       tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results


	Performance of early 80's experimental Smalltalk systems.
	Estimations from
		http://wiki.c2.com/?GreenBook
		http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1982-qtr4-magnolia-perf-graph.pdf
		http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1983-Magnolia-st-perf.pdf

		DEC PDP-11/23 											  5,000 bytecodes/sec (Green Book, p.128)
		Apple 5MHz 68000 							   9,000 to 11,000 bytecodes/sec (Green Book, p.187, awb) 							5000 clocks/bytecode
		VAX-11/780 5MHz C HP Smalltalk 		  5,000 to 25,000 bytecodes/sec (Green Book, p.235) 								  330 clocks/bytecode
		VAX-11/780 5MHz C Berkeley Smalltalk 	 12,000 to 23000 bytecodes/sec (Green Book, p.203, awb) 							  300 clocks/bytecode
		DEC VAX-11/780 5MHz assembly 			20,000 to 25,000 bytecodes/sec (Green Book, p.149, awb) 				 			  200 clocks/bytecode
		Xerox Dolphin  code 					 	20,000 to 40,000 bytecodes/sec (Green Book, p.44, p.203, awb)
		TEK Magnolia 10MHz 68000 						      50,000 bytecodes/sec (awb) 												  200 clocks/bytecode
		Xerox Dorado 14MHz code			 400,000 to 500,000 bytecodes/sec (Green book, p.44, p.203, awb) 					    28 clocks/bytecode


	0 tinyBenchmarks
		
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec 					12.8 clocks/bytecode
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec 					22.2 clocks/bytecode

		900MHz RasPi2 - StackVM: 						 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec 					16.2 clocks/bytecode
		900MHz RasPi2- CogSSpur: 				     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec 					   5.7 clocks/bytecode
		
		1GHz C.H.I.P. (*1) - StackVM: 					55,315,471 bytecodes/sec;  			3,348,667 sends/sec  					18.1 clocks/bytecode
		1GHz C.H.I.P. (*1) - CogSpur: 			 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec 					   3.9 clocks/bytecode
		
		1.2GHz RasPi3B - StackSpur 					44,107,512 bytecodes/sec; 			2,767,863 sends/sec 					27.2 clocks/bytecode
		1.2GHz RasPi3B - CogSpur 					    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec 					   6.6 clocks/bytecode

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec 					   6.8 clocks/bytecode
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec 					   3.5 clocks/bytecode
 
		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec 					   4.1 clocks/bytecode
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec 					   2.1 clocks/bytecode

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec 					   3.8 clocks/bytecode
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec 					   2.2 clocks/bytecode
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec 					   2.2 clocks/bytecode

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec					   8.9 clocks/bytecode
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec 					   2.1 clocks/bytecode

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec 					   2.6 clocks/bytecode
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec 					   1.5 clocks/bytecode

		2.70GHz Core i5-6400 -CogSpur64 		3,162,934,362 bytecodes/sec; 		243,321,293 sends/sec 					   0.85 clocks/bytecode
	
		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue: [n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue: [n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^String streamContents: [ :strm |
		(n1 * 500000 * 1000) // t1 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Bytecodes/second; ' ].
		(r * 1000) // t2 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Sends/second' ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3266-ClocksPerBytecodeEstimation-JuanVuletich-2018Mar04-12h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3266] on 6 March 2018 at 5:42:11 pm'!
!String methodsFor: 'converting' stamp: 'jmv 3/6/2018 17:40:38'!
  asValidInstanceVariableName
	| answer |
	answer _ self asIdentifier: false.
	(Scanner pseudoVariableNames includes: answer)
		ifTrue: [ answer _ answer , 'x' ].
	^ answer

"
'234znak 43 ) 2' asValidInstanceVariableName
'234 xx\ Uml /ler42342380-4' asValidInstanceVariableName
"! !
!String methodsFor: 'converting' stamp: 'jmv 3/6/2018 17:32:02'!
      asValidSelector
	^ self asIdentifier: false

"
'234znak 43 ) 2' asValidSelector
"! !
!String methodsFor: 'converting' stamp: 'jmv 3/6/2018 17:15:13'!
          uncapitalized
	"Answer an object like the receiver but with first character downshifted if necesary"
	"'MElViN' uncapitalized"
	"#Will uncapitalized"
	| answer |
	self isEmpty ifTrue: [^ self].
	answer _ self isString
				ifTrue: ["don't modify receiver"
					self copy]
				ifFalse: [self asString].
	answer at: 1 put: (answer at: 1) asLowercase.
	^ self isString
		ifTrue: [answer]
		ifFalse: [answer as: self class]! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 3/6/2018 17:38:01'!
                     isValidInstanceVariableName: aString
	"Answer whether aString is a legal instance variable name."

	^ ((self isLiteralSymbol: aString) and: [(aString includes: $:) not]) and:
		[(self pseudoVariableNames includes:  aString) not]! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 3/6/2018 17:36:55'!
                   pseudoVariableNames
	"Answer a list of Smalltalk pseudo-varialbes"
	^ #('nil' 'true' 'false' 'self' 'super' 'thisContext')! !
!Workspace methodsFor: 'variable declarations' stamp: 'jmv 3/6/2018 17:28:10' prior: 50376962!
   nameForObject: object
	"Answer a name suitable for a Workspace variable"
	^ (object class name, object identityHash asString) asIdentifier: false! !
!String methodsFor: 'converting' stamp: 'jmv 3/6/2018 17:19:56' prior: 16916313!
                          asIdentifier: shouldBeCapitalized
	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"

	| aString |
	aString _ self select: [ :el | el isValidInIdentifiers ].
	(aString size = 0 or: [aString first isValidStartOfIdentifiers not])
		ifTrue:	 [aString _ 'a', aString].
	^ shouldBeCapitalized ifTrue: [ aString capitalized ] ifFalse: [ aString uncapitalized ]

"
'234Fred987' asIdentifier: false
'235Fred987' asIdentifier: true
'' asIdentifier: true
'()87234' asIdentifier: false
'())z>=PPve889  U >' asIdentifier: false
"! !
!Symbol class methodsFor: 'access' stamp: 'jmv 3/6/2018 17:15:26' prior: 16918609!
                               selectorsContaining: aString
	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."

	| size selectorList ascii |

	selectorList _ OrderedCollection new.
	(size _ aString size) = 0 ifTrue: [^selectorList].

	aString size = 1 ifTrue:
		[
			ascii _ aString first numericValue.
			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]
		].

	aString first isValidInIdentifiers ifFalse:
		[
			aString size = 2 ifTrue: 
				[Symbol hasInterned: aString ifTrue:
					[:s | selectorList add: s]].
			^selectorList
		].

	selectorList _ selectorList copyFrom: 2 to: selectorList size.

	self allSymbolTablesDo: [:each |
		each size >= size ifTrue:
			[(each findSubstring: aString in: each startingAt: 1 
				matchTable: CaseInsensitiveOrder) > 0
						ifTrue: [selectorList add: each]]].

	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"
		each numArgs < 0 and: [each asString uncapitalized numArgs < 0]].

"Symbol selectorsContaining: 'scon'"! !
!Symbol class methodsFor: 'access' stamp: 'jmv 3/6/2018 17:15:29' prior: 16918646!
       selectorsMatching: aStringPattern
	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.
	 Does return symbols that begin with a capital letter."

	| selectorList |

	selectorList := OrderedCollection new.

	aStringPattern isEmpty ifTrue: [^selectorList].

	self allSymbolTablesDo:
		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].

	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"
		[:each | each numArgs < 0 and: [each asString uncapitalized numArgs < 0]]

	"Symbol selectorsMatching: 'parse:*'"! !
!Morph methodsFor: 'menus' stamp: 'jmv 3/6/2018 16:58:49' prior: 50376737!
                               addCopyItemsTo: aMenu 
	"Add copy-like items to the halo menu"

	aMenu add: 'copy to clipboard (c)' action: #copyToClipboard:! !

Utilities class removeSelector: #inviolateInstanceVariableNames!

Utilities class removeSelector: #inviolateInstanceVariableNames!

Utilities class removeSelector: #isLegalInstVarName:!

Utilities class removeSelector: #isLegalInstVarName:!

Utilities class removeSelector: #wellFormedInstanceVariableNameFrom:!

Utilities class removeSelector: #wellFormedInstanceVariableNameFrom:!

Scanner class removeSelector: #inviolateInstanceVariableNames!

Scanner class removeSelector: #inviolateInstanceVariableNames!

Scanner class removeSelector: #isLegalInstVarName:!

Scanner class removeSelector: #isLegalInstVarName:!

Scanner class removeSelector: #wellFormedInstanceVariableNameFrom:!

Scanner class removeSelector: #wellFormedInstanceVariableNameFrom:!

String removeSelector: #asLegalSelector!

String removeSelector: #asLegalSelector!

String removeSelector: #withFirstCharacterDownshifted!

String removeSelector: #withFirstCharacterDownshifted!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3267-Cleanup-JuanVuletich-2018Mar06-17h39m-jmv.1.cs.st----!

----SNAPSHOT----#(9 March 2018 11:47:57.609542 am) Cuis5.0-3267-v3.image priorSource: 1605038!

----QUIT----#(9 March 2018 11:48:17.309766 am) Cuis5.0-3267-v3.image priorSource: 1621558!

----STARTUP----#(13 March 2018 3:20:50.719361 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3267-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3267] on 11 March 2018 at 9:05:37 am'!
!Feature methodsFor: 'testing' stamp: 'jmv 3/11/2018 09:03:09' prior: 16840526!
                 satisfies: featureRequirement
	"Does this provided Feature satisfy the FeatureRequirement?"
	
	"Must match name."
	^ (name sameAs: featureRequirement name) and: [

		"If no specific version req, we are done. Ok."
		featureRequirement minVersion isNil or: [

		"If our version is exactly the min req version, we must also satisfy minRevision"
		version = featureRequirement minVersion and: [
			featureRequirement minRevision isNil or: [ revision >= featureRequirement minRevision ]]] or: [
		
		"If we are past min req version, ignore minRevision, but check we are not beyond max req version"
		version > featureRequirement minVersion and: [
			featureRequirement maxVersion isNil or: [ version <= featureRequirement maxVersion ]]]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3268-CaseInsensitiveFeatureMatching-JuanVuletich-2018Mar11-09h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3268] on 12 March 2018 at 12:16:15 pm'!
!CodeProvider methodsFor: 'message list' stamp: 'jmv 3/11/2018 15:52:08' prior: 16812753!
                     sourceStringPrettifiedAndDiffed
	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"
	| class selector sourceString |
	class _ self selectedClassOrMetaClass.
	selector _ self selectedMessageName.
	(class isNil or: [ selector isNil ]) ifTrue: [ ^ 'missing' ].
	sourceString _ class
		ultimateSourceCodeAt: selector
		ifAbsent: [ ^ 'error' ].
	(self showingPrettyPrint or: [ self showingAnyKindOfPrettyDiffs ]) ifTrue: [
		sourceString _ class compilerClass new
			format: sourceString
			in: class
			notifying: nil ].
	self showingAnyKindOfDiffs ifTrue: [
		sourceString _ self diffFromPriorSourceFor: sourceString ].
	^ sourceString! !
!Browser methodsFor: 'message functions' stamp: 'jmv 3/12/2018 12:15:33' prior: 16792281!
          defineMessageFrom: aString notifying: aRequestor
	"Compile the expressions in aString. Notify aRequestor if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."
	| selectedMessageName selector category oldMessageList |
	selectedMessageName _ self selectedMessageName.
	oldMessageList _ self messageList.
	 self metaClassIndicated ifTrue: [
		selector _ self selectedClassOrMetaClass parserClass selectorFrom: aString.
		((self selectedClassOrMetaClass includesSelector: selector) not
			and: [Metaclass isScarySelector: selector])
			ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"
					(self confirm: (selector bold, ' is used in the existing class system.
Overriding it could cause serious problems.
Is this really what you want to do?'))
					ifFalse: [^nil]]].
	selector _ self selectedClassOrMetaClass
				compile: aString
				classified: (category _ self selectedMessageCategoryName)
				notifying: aRequestor.
	selector
		ifNil: [^ nil].
	selector ~~ selectedMessageName
		ifTrue: [
			category = ClassOrganizer nullCategory
				ifTrue: [self changed: #classSelectionChanged.
						self changed: #classList.
						self messageCategoryListIndex: 1].
			self setClassOrganizer.  "In case organization not cached"
			(oldMessageList includes: selector)
				ifFalse: [self changed: #messageList].
			self messageListIndex: (self messageList indexOf: selector)].
	^ selector! !
!Compiler methodsFor: 'public access' stamp: 'jmv 3/12/2018 09:04:09' prior: 16821855!
                   compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 
	"Answer a MethodNode for the argument, textOrStream. If the 
	MethodNode can not be created, notify the argument, aRequestor; if 
	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 
	of a parse tree. It can be told to generate a CompiledMethod to be 
	installed in the method dictionary of the argument, aClass."
	
	| methodNode |
	self from: textOrStream
		class: aClass
		context: nil
		notifying: aRequestor.
	category _ aCategory.
	methodNode _ self translate: sourceStream noPattern: false ifFail: failBlock.
	methodNode encoder requestor: requestor.
	^methodNode! !
!Compiler methodsFor: 'public access' stamp: 'jmv 3/12/2018 09:08:56' prior: 16821922!
                    evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: doLog profiled: doProfile
	"Compiles the sourceStream into a parse tree, then generates code into
	 a method. If aContext is not nil, the text can refer to temporaries in that
	 context (the Debugger uses this). If aRequestor is not nil, then it will receive
	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 
	 compiled method is invoked from here via withArgs:executeMethod:, hence
	 the system no longer creates Doit method litter on errors."

	| methodNode method value toLog itsSelection itsSelectionString |
	class _ (aContext ifNil: [ receiver ] ifNotNil: [ aContext receiver ]) class.
	methodNode _ self compileNoPattern: textOrStream in: class context: aContext notifying: aRequestor ifFail: [^failBlock value].
	method _ methodNode generate.

	"(jmv) Log before evaluating. This way, if the evaluation is halted by whatever reason, it is logged anyway"
	doLog ifTrue: [
		toLog _ ((requestor respondsTo: #selection)  
			and: [ (itsSelection _ requestor selection) notNil
			and: [ (itsSelectionString _ itsSelection asString) isEmptyOrNil not ]])
				ifTrue: [ itsSelectionString ]
				ifFalse: [ sourceStream contents ].
		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext].

	"Evaluate now."
	doProfile
		ifTrue: [
			AndreasSystemProfiler spyOn: [
				value _ receiver
					withArgs: (context ifNil: [#()] ifNotNil: [{context}])
					executeMethod: method ]]
		ifFalse: [
			value _ receiver
				withArgs: (context ifNil: [#()] ifNotNil: [{context}])
				executeMethod: method ].

	^ value! !

Compiler removeSelector: #from:class:classified:context:notifying:!

Compiler removeSelector: #from:class:classified:context:notifying:!

CodeProvider removeSelector: #validateMessageSource:forSelector:inClass:!

CodeProvider removeSelector: #validateMessageSource:forSelector:inClass:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3269-CompilationCleanup-JuanVuletich-2018Mar12-12h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3269] on 12 March 2018 at 3:44:27 pm'!

Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals '
	classVariableNames: 'TypeTable '
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Scanner category: #'Compiler-Kernel'!
Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals'
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 3/12/2018 15:37:29' prior: 50334867!
                         xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	[ | compiler method methodNode |
		compiler _ Compiler new.
		methodNode _ compiler compileNoPattern: buffer contents in: UndefinedObject context: nil notifying: nil ifFail: [].
		method _ methodNode generate.
		"Grab all messages sent while evaluating literal, so the main method will be shown as senders of them"
		sentInLiterals addAll: method messages.
		"Evaluate now."
		token _ nil withArgs: #() executeMethod: method.
	] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !
!Scanner methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:05:15' prior: 16904195!
                      initScanner

	buffer := WriteStream on: (String new: 40).
	typeTable := Scanner typeTable.
	isForTokenization := false.
	sentInLiterals := Set new! !
!Parser methodsFor: 'public access' stamp: 'jmv 3/12/2018 15:39:43' prior: 16886804!
                     parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock
	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	| methNode repeatNeeded myStream s p |
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		p _ myStream position.
		s _ myStream upToEnd.
		myStream position: p.
		self encoder init: class context: ctxt notifying: self.
		self init: myStream notifying: req failBlock: [
			^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern context: ctxt ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ sourceStreamGetter notNil 	"Cuis specific. Do not remove!!"
					ifTrue: [ requestor perform: sourceStreamGetter ]
					ifFalse: [ ReadStream on: requestor text string ]].
		repeatNeeded
	] whileTrue: [
		encoder _ self encoder class new ].
	methNode sourceText: s.
	"See #xBacktick"
	sentInLiterals do: [ :sym | encoder noteOptimizedSelector: sym ].
	^ methNode! !

Parser removeSelector: #method:context:encoder:!

Parser removeSelector: #method:context:encoder:!

Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals'
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Scanner category: #'Compiler-Kernel'!
Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals'
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3270-FixSendersInsideBackticks-JuanVuletich-2018Mar12-15h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3269] on 12 March 2018 at 3:58:27 pm'!
!Object methodsFor: 'private' stamp: 'jmv 3/12/2018 15:54:19' prior: 50361280!
              primitiveError: aString 
	"This method is called when the error handling results in a recursion in 
	calling on error: or halt or halt:."

	| context emergencyEvaluator lines r |
	r _ `10@10` extent: (Display extent -20 min: `700@1000`).
	lines _ r height // AbstractFont default height.
	emergencyEvaluator _ Transcripter newInFrame: r.
	emergencyEvaluator
		nextPutAll: '***System error handling failed***'; newLine;
		nextPutAll: aString; newLine;
		nextPutAll: '-------------------------------'; newLine.
	context _ thisContext sender sender.
	(30 min: lines - 10) timesRepeat: [context ifNotNil: [emergencyEvaluator print: (context _ context sender); newLine]].
	emergencyEvaluator
		nextPutAll: '-------------------------------'; newLine;
		nextPutAll: 'Type ''revert'' to revert your last method change.'; newLine;
		nextPutAll: 'Type ''exit'' to exit the emergency evaluator.'; newLine.
	emergencyEvaluator readEvalPrint! !
!Character methodsFor: 'converting' stamp: 'jmv 3/12/2018 15:47:49' prior: 16800645!
       withDiacriticalMark: anUnicodeCodePoint
	"Answer the character resulting from adding a diacritical mark (accent) to a letter.
	If the result is unsupported in ISO 8859-15, answer the receiver.
	Supported diacritical marks are:
		U+0300 	COMBINING GRAVE ACCENT
		U+0301 	COMBINING ACUTE ACCENT
		U+0302 	COMBINING CIRCUMFLEX ACCENT
		U+0303 	COMBINING TILDE
		U+0308 	COMBINING DIAERESIS
		U+030A 	COMBINING RING ABOVE
		U+030C 	COMBINING CARON
		$a withDiacriticalMark: 16r301
		$N withDiacriticalMark: $~
		$Z withDiacriticalMark: $v
		
		invalid:
		$9 withDiacriticalMark:$v
		$A withDiacriticalMark: $v
		$ withDiacriticalMark: $v
		$A withDiacriticalMark: 1244
		"
	| answer i |
	i _ ((anUnicodeCodePoint isNumber
			ifTrue: [#(16r300 16r301 16r302 16r303 16r308 16r30A 16r30C)]
			ifFalse: [#($` $' $^ $~ $" $ $v)]) indexOf: anUnicodeCodePoint
				) + 1.
	answer _ (Character accentedLetters detect: [ :group | group first = self ] ifNone: [ ^self ]) at: i.
	^answer = $- ifFalse: [answer] ifTrue: [self]! !
!InputSensor methodsFor: 'private' stamp: 'jmv 3/12/2018 15:52:20' prior: 50361312!
                     primMousePt
	"Primitive. Poll the mouse to find out its position. Return a Point. Fail if
	event-driven tracking is used instead of polling. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 90>
	^ `0@0`! !
!EventSensor methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:48:41' prior: 50361322!
   initialize
	"Run the I/O process"
	mouseButtons _ 0.
	mousePosition _ `0@0`.
	self setInterruptKey: (interruptKey ifNil: [$. numericValue bitOr: 16r0800 ]). 	"cmd-."
	interruptSemaphore _ (Smalltalk specialObjectsArray at: 31) ifNil: [Semaphore new].
	self flushAllButDandDEvents.
	inputSemaphore _ Semaphore new.
	hasInputSemaphore _ false.

	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	self installInterruptWatcher.
	self installEventTickler.
	self flushAllButDandDEvents.

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore _ false.
	inputSemaphore initSignals! !
!String methodsFor: 'displaying' stamp: 'jmv 3/12/2018 15:56:28' prior: 50361345!
   displayOn: aDisplayMedium
	"Display the receiver on the given DisplayMedium.  5/16/96 sw"

	self displayOn: aDisplayMedium at: `0 @ 0`! !
!Bitmap methodsFor: 'as yet unclassified' stamp: 'jmv 3/12/2018 15:47:42' prior: 50361353!
                           asByteArray
	"Faster way to make a byte array from me.
	copyFromByteArray:, if receiver is BigEndian makes equal Bitmap.
	Assume receiver bytes-in-word mapping is BigEndian:
		Most significant bye of first word in self goes to first position in result.
	This means that for a BigEndian 8bpp Form, pixels are in the right order in the ByteArray
	
	Form lena asGrayForm bits asByteArray copyFrom: 1 to: 4.
	(Form lena asGrayForm asFormOfDepth: 8) bits asByteArray copyFrom: 1 to: 4.
	(0 to: 3) collect: [ :x | ((Form lena asGrayForm colorAt: x@0) luminance * 255) rounded ].
	"
	| f bytes hack |
	f _ Form extent: 4@self size depth: 8 bits: self.
	bytes _ ByteArray new: self size * 4.
	hack _ Form new hackBits: bytes.
	Smalltalk isLittleEndian ifTrue: [hack swapEndianness].
	hack copyBits: f boundingBox
		from: f
		at: `0@0`
		clippingBox: hack boundingBox
		rule: Form over.

	"f displayOn: hack."
	^ bytes! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 3/12/2018 15:57:40' prior: 50361500!
                        endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			`0@0` + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (`4@4` + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter class methodsFor: 'utilities' stamp: 'jmv 3/12/2018 15:57:42' prior: 50361535!
                           emergencyEvaluator
	(Transcripter newInFrame: `0@0 corner: 320@200`)
		show: 'Type ''exit'' to exit the emergency evaluator.';
		readEvalPrint! !
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 3/12/2018 15:55:35' prior: 50361544!
                              defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame oldFilledWidth oldFilledWidth2 prevContents |
	f _ AbstractFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.

	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ `0@0` extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	prevContents _ Form fromDisplay: outerFrame.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	oldFilledWidth _ 0.
	oldFilledWidth2 _ 0.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		filledWidth _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		filledWidth  > oldFilledWidth ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + `2@2` extent: filledWidth@17).
			filledWidth -200 > oldFilledWidth2
				ifFalse: [
					"Usually just request an update, to be done asynchronously."
					DisplayScreen screenUpdateRequired: outerFrame ]
				ifTrue: [
					"Once in a while, force a real screen update (warning: really slow on MacOS if done too often)"
					Display forceToScreen: outerFrame. oldFilledWidth2 _ filledWidth ].
			oldFilledWidth _ filledWidth ]].
	prevContents displayAt: outerFrame topLeft.
	self resume: result! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 3/12/2018 15:56:15' prior: 50382562!
                       xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	[ | compiler method methodNode |
		compiler _ Compiler new.
		methodNode _ compiler compileNoPattern: buffer contents in: UndefinedObject context: nil notifying: nil ifFail: [].
		method _ methodNode generate.
		"Grab all messages sent while evaluating literal, so the main method will be shown as senders of them"
		sentInLiterals addAll: method messages.
		"Evaluate now."
		token _ nil withArgs: #() executeMethod: method.
	] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 3/12/2018 15:56:19' prior: 50334741!
            initTypeTable
	| newTable |
	newTable := Array new: 256 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"

	1 to: 255
		do: [:index |
			(Character numericValue: index) isValidInIdentifiers
				ifTrue: [
					"Digits and $_ are overwritten later"
					newTable at: index put: #xLetter ]].

	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable atAll:  '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.

	newTable at: Scanner doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!LiteralNode methodsFor: 'printing' stamp: 'jmv 3/12/2018 15:52:43' prior: 50370919!
                           printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea storeOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key storeOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]]! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 3/12/2018 15:57:29' prior: 50334912!
             enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (String with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (String with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^ true! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 3/12/2018 15:57:33' prior: 50334948!
        basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< #enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:				'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:		'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R	#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y	#makeUppercase:		'Force selection to uppercase')
		#(		$U	#changeLineEndsToLf:	'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:		'Move cursor to start of text')
		#(		$L	#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z	#redo:						'Redo (multiple levels)')
		#(		$X	#makeLowercase:		'Force selection to lowercase')
		#(		$C	#compareToClipboard:	'Compare argument to clipboard')

		#(		$ 	#selectWord:				'Select the current word as with double clicking')
	)! !
!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 3/12/2018 15:56:25' prior: 50335006!
                      selectWord
	"Select delimited text or word--the result of double-clicking."

	| leftDelimiters rightDelimiters |
	"Warning. Once me (jmv) added Character crCharacter to the delimiters, to make double-click at and of line select whole line.
	This had the bad effect that if a class name is the last word of a line, double-click would correctly select it, but after that,
	doing ctrl-b to browse it would select the whole line..."
	leftDelimiters _ '([{<|''"`'.
	rightDelimiters _ ')]}>|''"`'.
	^self selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 3/12/2018 15:55:41' prior: 50361619!
                      staggerOffset
	^`6 @ 20`! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 3/12/2018 15:55:48' prior: 50361624!
                          standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| effectiveExtent width strips height grid allowedArea maxLevel |
	effectiveExtent _ self maximumUsableArea extent
					- (self scrollBarSetback @ self screenTopSetback).
	Preferences reverseWindowStagger ifTrue:
		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"
		allowedArea _ self maximumUsableArea insetBy: (
			self scrollBarSetback @ self screenTopSetback extent: `0@0`
		).
		"Number to be staggered at each corner (less on small screens)"
		maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
		"Amount by which to stagger (less on small screens)"
		grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: `52@40` * Preferences standardCodeFont height ].
	width _ (strips _ self windowColumnsDesired) > 1
		ifTrue:
			[effectiveExtent x // strips]
		ifFalse:
			[(3 * effectiveExtent x) // 4].
	height _ (strips _ self windowRowsDesired) > 1
		ifTrue:
			[effectiveExtent y // strips]
		ifFalse:
			[(3 * effectiveExtent y) //4].
	^ width @ height

"
RealEstateAgent standardWindowExtent
"! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 3/12/2018 15:55:52' prior: 50361665!
                          strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 
	"This method implements a staggered window placement policy that I (di) like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible."

	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |
	allowedArea := (self maximumUsableAreaInWorld: aWorld) 
				insetBy: (self scrollBarSetback @ self screenTopSetback extent: `0 @ 0`).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame := `0 @ 0` extent: initialExtent.
	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400"
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [ :w | w visible and: [w isCollapsed not]]) 
						collect: [:w | w morphBoundsInWorld].
	otherFrames _ otherFrames reject: [ :f | f isNil ].
	0 to: maxLevel do: [ :level | 
			1 to: 4 do: [:ci | 
					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.
					corner := allowedArea perform: cornerSel.
					"The extra grid//2 in delta helps to keep title tabs distinct"
					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).
					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"
					putativeCorner := corner + delta.
					free := true.
					otherFrames do: [ :w |
						free := free & ((w perform: cornerSel) ~= putativeCorner)].
					free 
						ifTrue: [
							^(initialFrame aligned: (initialFrame perform: cornerSel)
								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].
	"If all else fails..."
	^(self scrollBarSetback @ self screenTopSetback 
		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !
!Form methodsFor: 'accessing' stamp: 'jmv 3/12/2018 15:50:15' prior: 50361731!
           offset
	^offset ifNil: [`0@0`]! !
!Form methodsFor: 'analyzing' stamp: 'jmv 3/12/2018 15:50:32' prior: 50361735!
               primCountBits
	"Count the non-zero pixels of this form."
	self depth > 8 ifTrue: [
		^(self asFormOfDepth: 8) primCountBits].
	^ (BitBlt toForm: self)
		fillColor: (Bitmap with: 0);
		destRect: (`0@0` extent: width@height);
		combinationRule: 32;
		copyBits! !
!Form methodsFor: 'analyzing' stamp: 'jmv 3/12/2018 15:50:49' prior: 50361746!
            tallyPixelValuesInRect: destRect into: valueTable
	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."

	(BitBlt toForm: self)
		sourceForm: self;  "src must be given for color map ops"
		sourceOrigin: `0@0`;
		colorMap: valueTable;
		combinationRule: 33;
		destRect: destRect;
		copyBits.
	^ valueTable

"
Move a little rectangle around the screen and print its tallies...
 | r tallies nonZero |
Cursor blank showWhile: [
[Sensor isAnyButtonPressed] whileFalse:
	[r _ Sensor mousePoint extent: 10@10.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.
	tallies _ (Display copy: r) tallyPixelValues.
	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]
			thenCollect: [:i | (tallies at: i) -> (i-1)].
	Display fill: (0@0 extent: Display width@20) fillColor: Color white.
	nonZero printString , '          ' displayAt: 0@0.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]
"! !
!Form methodsFor: 'analyzing' stamp: 'jmv 3/12/2018 15:50:58' prior: 50361781!
                   xTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by x-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice countBlt copyBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: 1@height.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: 1 @ slice height
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: width-1) collect: [ :x |
		copyBlt sourceOrigin: x@0; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'analyzing' stamp: 'jmv 3/12/2018 15:51:05' prior: 50361810!
                      yTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: slice width @ 1
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: height-1) collect: [ :y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/12/2018 15:49:54' prior: 50361839!
                        fillShape: aShapeForm fillColor: aColor
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	^ self fillShape: aShapeForm fillColor: aColor at: `0@0`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/12/2018 15:49:58' prior: 50361847!
         fillShape: aShapeForm fillColor: aColor at: location
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	((BitBlt destForm: self sourceForm: aShapeForm fillColor: aColor
		combinationRule: Form paint
		destOrigin: location + aShapeForm offset sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits! !
!Form methodsFor: 'color mapping' stamp: 'jmv 3/12/2018 15:50:08' prior: 50361862!
     mapColor: oldColor to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Color cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: `0@0`;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits! !
!Form methodsFor: 'converting' stamp: 'jmv 3/12/2018 15:49:08' prior: 50361884!
             asFormOfDepth: d
	| newForm source |
	d = depth ifTrue: [ ^self ].
	source _ (self depth = 32 and: [ d abs < 32 ])
		ifTrue: [ self copy convertAlphaToZeroValueTransparency ]
		ifFalse: [ self ].
	newForm _ Form extent: source extent depth: d.
	(BitBlt toForm: newForm)
		colorMap: (source colormapIfNeededFor: newForm);
		copy: source boundingBox
		from: `0@0` in: source
		fillColor: nil rule: Form over.
	"If we build a 32bpp from one of smaller depth,
	it will have zero in the alpha channel (until BitBlt is fixed!!)"
	(newForm depth = 32 and: [self depth < 32]) ifTrue: [
		newForm fixAlpha ].
	^ newForm! !
!Form methodsFor: 'converting' stamp: 'jmv 3/12/2018 15:49:11' prior: 50361906!
          asGrayForm
	| answer map |

	"For lower bit depths, the 15 bit ColorMap loses no information,
	and answers the real #luminance of each pixel."
	self depth < 32 ifTrue: [
		answer _ GrayForm extent: width@height.
		map _ self colormapIfNeededForGray8bpp.
		(BitBlt toForm: answer)
			colorMap: map;
			copy: self boundingBox
			from: `0@0` in: self
			fillColor: nil rule: Form over.
		answer offset: self offset.
		^ answer ].

	"For 32bpp, the approach below would use just 5bits per component.
	Generally it is best to extract a component in full 8bpp and keep full dynamic range.
	Green usually is a good choice."
	^ self asGrayForm: 3! !
!Form methodsFor: 'converting' stamp: 'jmv 3/12/2018 15:49:14' prior: 50361929!
              asGrayForm: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a GrayForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit GrayForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayForm: componentIndex ].
	
	result _ GrayForm extent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.
	^ result! !
!Form methodsFor: 'converting' stamp: 'jmv 3/12/2018 15:49:21' prior: 50361968!
                       asGrayScaleAndTransparent: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayScaleAndTransparent: componentIndex ].

	result _ ColorForm grayScaleAndTransparentExtent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.

	"final BitBlt to zero-out pixels that were truely transparent in the original"
	map _ Bitmap new: 512.
	map at: 1 put: 16rFF.
	(BitBlt toForm: result)
		sourceForm: self;
		sourceRect: self boundingBox;
		destOrigin: `0@0`;
		combinationRule: Form erase;
		colorMap: map;
		copyBits.
	^ result! !
!Form methodsFor: 'converting' stamp: 'jmv 3/12/2018 15:50:03' prior: 50362018!
                        icon
	"Answer a 16 x 16 icon of myself"
	
	^self magnifyTo: `16 @ 16`! !
!Form methodsFor: 'copying' stamp: 'jmv 3/12/2018 15:49:28' prior: 50362023!
          contentsOfArea: aRect into: newForm
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !
!Form methodsFor: 'copying' stamp: 'jmv 3/12/2018 15:49:31' prior: 50362033!
          copy: aRect
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !
!Form methodsFor: 'copying' stamp: 'jmv 3/12/2018 15:49:34' prior: 50362045!
                            copyBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt 
		destForm: self
		sourceForm: sourceForm
		combinationRule: 30
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 copyBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'display box access' stamp: 'jmv 3/12/2018 15:49:24' prior: 50362067!
boundingBox
	^ Rectangle
		origin: `0 @ 0`
		corner: width @ height! !
!Form methodsFor: 'displaying' stamp: 'jmv 3/12/2018 15:50:23' prior: 50362072!
         paintBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt destForm: self
		sourceForm: sourceForm
		combinationRule: 31
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f replaceColor: f dominantColor withColor: Color transparent.
f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 paintBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'displaying-generic' stamp: 'jmv 3/12/2018 15:49:40' prior: 50362096!
   displayOn: aDisplayMedium
	"Simple default display in order to see the receiver in the upper left 
	corner of screen."

	self displayOn: aDisplayMedium at: `0 @ 0`! !
!Form methodsFor: 'filling' stamp: 'jmv 3/12/2018 15:49:45' prior: 50362104!
            eraseShape: bwForm
	"use bwForm as a mask to clear all pixels where bwForm has 1's"
	((BitBlt destForm: self sourceForm: bwForm
		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"
		destOrigin: bwForm offset 
		sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits! !
!Form methodsFor: 'filling' stamp: 'jmv 3/12/2018 15:49:51' prior: 50362119!
fill: aRectangle rule: anInteger fillColor: aForm 
	"Replace a rectangular area of the receiver with the pattern described by aForm 
	according to the rule anInteger."
	(BitBlt toForm: self)
		copy: aRectangle
		from: `0@0` in: nil
		fillColor: aForm rule: anInteger! !
!Form methodsFor: 'image manipulation' stamp: 'jmv 3/12/2018 15:50:44' prior: 50362131!
                          smear: dir distance: dist
	"Smear any black pixels in this form in the direction dir in Log N steps"
	| skew bb |
	bb _ BitBlt destForm: self sourceForm: self
		combinationRule: Form under destOrigin: `0@0` sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox.
	skew _ 1.
	[skew < dist] whileTrue: [
		bb destOrigin: dir*skew; copyBits.
		skew _ skew+skew]! !
!Form methodsFor: 'transitions' stamp: 'jmv 3/12/2018 15:50:19' prior: 50362146!
                       pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"! !
!Form methodsFor: 'private' stamp: 'jmv 3/12/2018 15:49:37' prior: 50362217!
                      copyFromByteArray: bigEndianByteArray
	"This method should work with either byte orderings.
	See comment at Bitmap>>#asByteArray
	Also see #copyFromByteArray2:to:"

	| myHack byteHack |
	myHack := Form new hackBits: bits.
	byteHack := Form new hackBits: bigEndianByteArray.
	"We are passing a ByteArray instead of a Words object. Will be accessed according to native endianness."
	Smalltalk isLittleEndian = self isLittleEndian ifFalse: [byteHack swapEndianness].
	byteHack displayOn: myHack at: `0 @ 0` rule: Form over! !
!Form methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:50:00' prior: 50362236!
 fromDisplay: aRectangle 
	"Create a virtual bit map from a user specified rectangular area on the 
	display screen. Reallocates bitmap only if aRectangle ~= the receiver's 
	extent."

	(width = aRectangle width and: [height = aRectangle height])
		ifFalse: [self setExtent: aRectangle extent depth: depth].
	self
		copyBits: (aRectangle origin extent: self extent)
		from: Display
		at: `0 @ 0`
		clippingBox: self boundingBox
		rule: Form over! !
!Form methodsFor: 'encoding' stamp: 'jmv 3/12/2018 15:49:03' prior: 50362253!
                  addDeltasFrom: previousForm

	(BitBlt 
		destForm: self 
		sourceForm: previousForm 
		fillColor: nil 
		combinationRule: Form reverse
		destOrigin: `0@0`
		sourceOrigin: `0@0`
		extent: self extent 
		clipRect: self boundingBox) copyBits.
	^self! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 15:51:12' prior: 50362264!
         dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: `0@0` - radius.
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Color black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do: [ :dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 3/12/2018 15:51:17' prior: 50362302!
       toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Color red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: `-40@-40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 3/12/2018 15:47:55' prior: 50362339!
    asGrayForm
	"Build an optimal GrayForm,
	for any color palette in the receiver."
	| answer map |
	answer _ GrayForm extent: width@height.
	map _ self colormapIfNeededForGray8bpp.
	(BitBlt toForm: answer)
		colorMap: map;
		copy: self boundingBox
		from: `0@0` in: self
		fillColor: nil rule: Form over.
	^ answer! !
!ColorForm methodsFor: 'copying' stamp: 'jmv 3/12/2018 15:47:59' prior: 50362352!
                  copy: aRect
 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	colors ifNotNil: [newForm colors: colors copy].
	^ newForm! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 3/12/2018 15:48:04' prior: 50362369!
 mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: `0@0`
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Color white ifTrue: [Color transparent] ifFalse: [c]].
	f colors: map.
	^ f! !
!Cursor methodsFor: 'converting' stamp: 'jmv 3/12/2018 15:48:08' prior: 50362396!
             enlargedBy: scale
	"Big cursors are 32 bits deep (ARGB premultiplied)"
	| big |
	scale = 1 ifTrue: [^self].
	big := CursorWithAlpha extent: self extent * scale depth: 32.
	(self asCursorForm magnifyBy: scale) displayOn: big.
	big offset: (self offset - 0.5 * scale min: `0@0` max: big extent negated) asIntegerPoint.
	big fallback: self.
	^ big! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 3/12/2018 15:48:15' prior: 50362410!
      actualScreenSize
	<primitive: 106>
	^ `640@480`! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 3/12/2018 15:48:18' prior: 50362415!
               shutDown 
	"Minimize Display memory saved in image"
	Display setExtent: `240@120` depth: Display nativeDepth.
	ScreenUpdaterProcess ifNotNil: [
		ScreenUpdaterProcess terminate.
		ScreenUpdaterProcess _ nil ]! !
!GrayForm methodsFor: 'copying' stamp: 'jmv 3/12/2018 15:51:21' prior: 50362425!
                           copy: aRect
 	"Return a new instance containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	^ newForm! !
!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 15:47:23' prior: 50362441!
                        bitPeekerFromForm: sourceForm
	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."
	| pixPerWord answer |
	pixPerWord _ sourceForm pixelsPerWord.
	answer _ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)
	 	sourceForm: nil 			"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: (pixPerWord - 1)@0
		sourceOrigin: `0@0`
		extent: `1@1`
		clipRect: (`0@0` extent: pixPerWord@1).
	"To ensure no colormap set"
	answer sourceForm: sourceForm.
	^ answer! !
!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 15:47:27' prior: 50362463!
              bitPokerToForm: destForm
	"Answer an instance to be used for valueAt: aPoint put: pixValue.
	The source for a 1x1 copyBits will be the low order of (bits at: 1)"
	| pixPerWord answer |
	pixPerWord _ 32//destForm depth.
	answer _ self destForm: destForm
	 	sourceForm: nil 		"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: (pixPerWord-1)@0
		extent: `1@1`
		clipRect: (`0@0` extent: destForm extent).
	"To ensure no colormap set"
	answer sourceForm: (Form extent: pixPerWord@1 depth: destForm depth).
	^ answer! !
!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 3/12/2018 15:46:56' prior: 50362484!
      internalizeDelta: aPoint
	"Internalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x.
	y _ aPoint y.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^ (detX * det) @ (detY * det)! !
!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 3/12/2018 15:47:00' prior: 50362506!
                            inverseTransform: aPoint
	"Apply the inverse transformation to aPoint, i.e. multiply our inverse by aPoint.
	Use Smalltalk code, and not Matrix2x3Plugin, because we want Float conversion."
	| x y det a11 a12 a21 a22 detX detY |

	x _ aPoint x - self a13.
	y _ aPoint y - self a23.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^ (detX * det) @ (detY * det)! !
!AffineTransformation methodsFor: 'accessing' stamp: 'jmv 3/12/2018 15:47:03' prior: 50362527!
           inverseTransformation
	"Return the inverse transformation of the receiver.
	The inverse transformation is computed by first calculating
	the inverse offset and then computing transformations
	for the two identity vectors (1@0) and (0@1)"
	| r1 r2 r3 m |
	r3 _ self inverseTransform: `0@0`.
	r1 _ (self inverseTransform: `1@0`) - r3.
	r2 _ (self inverseTransform: `0@1`) - r3.
	m _ self species new.
	m
		a11: r1 x; a12: r2 x; a13: r3 x;
		a21: r1 y; a22: r2 y; a23: r3 y.
	^ m! !
!AffineTransformation methodsFor: 'transforming rects' stamp: 'jmv 3/12/2018 15:46:50' prior: 50362546!
                        displayBoundsOfTransformOf: aRectangle
	"Externalize aRectangle, and find a bounding rectangle with horizontal 
		and vertical bounds and integer coordinates (i.e. adisplayBounds).
	Primitive rounds and answers integers.
	Warning: if answer from primitive is not strictly positive, it is off by one. Fix it here."

	| dstRect |
	dstRect _ Rectangle new.
	(self primDisplayBoundsOfTransformOf: aRectangle into: dstRect) ifNotNil: [
		dstRect topLeft > `0@0` ifTrue: [ ^dstRect  ]].
	^Rectangle encompassing: (aRectangle corners collect: [ :pt |
		(self transform: pt) rounded ])! !
!Point methodsFor: 'point functions' stamp: 'jmv 3/12/2018 15:55:24' prior: 50362567!
     eightNeighbors
	^ (Array with: self + `1@0`
		with: self + `1@1`
		with: self + `0@1`
		with: self + `-1@1`) ,
	(Array with: self + `-1@0`
		with: self + `-1@-1`
		with: self + `0@-1`
		with: self + `1@-1`)! !
!Point methodsFor: 'point functions' stamp: 'jmv 3/12/2018 15:55:28' prior: 50362577!
                        fourNeighbors
	^ Array with: self + `1@0`
		with: self + `0@1`
		with: self + `-1@0`
		with: self + `0@-1`! !
!Rectangle methodsFor: 'accessing' stamp: 'jmv 3/12/2018 15:55:55' prior: 50362584!
                              innerCorners
	"Return an array of inner corner points,
	ie, the most extreme pixels included,
	in the order of a quadrilateral spec for WarpBlt"
	| r1 |
	r1 _ self topLeft corner: self bottomRight - `1@1`.
	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 3/12/2018 15:53:54' prior: 50362596!
  processUnknownEvent: aMorphicEvent localPosition: localEventPosition
	"An event of an unknown type was sent to the receiver. What shall we do?!!"

	Smalltalk beep. 
	aMorphicEvent printString displayAt: `0@0`.
	aMorphicEvent wasHandled: true! !
!Morph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:53:40' prior: 50362607!
                            minimumExtent
	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least"

	self flag: #jmvVer2.	"in owner's coordinates?"
	^self valueOfProperty: #minimumExtent ifAbsent: [`1@1`]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:53:42' prior: 50362619!
                          morphExtent
	"In our own coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^`50 @ 40`! !
!Morph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:53:45' prior: 50362626!
   morphPositionInWorld

	self flag: #jmvVer2.
	"Most likely we don't want to use global coordinates...
	In fact, we could be in many frames of reference at the same time...
	This method makes no sense at all!!"

	^self externalizeToWorld: `0@0`! !
!Morph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:53:48' prior: 50362637!
                           morphTopLeft
	"By default, morphs occupy a rectangle specified by #morphTopLef and #morphExtent"
	^`0@0`! !
!Morph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:53:51' prior: 50362644!
                               openInWorld: aWorld
	"Add this morph to the requested World."
	(location = MorphicTranslation new)
		ifTrue: [ aWorld addMorph: self position: `50@50` ]
		ifFalse: [ aWorld addMorph: self ]! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:55:58' prior: 50362654!
                             initialize
	super initialize.
	extent _ `50@40`.
	color _ self defaultColor! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 3/12/2018 15:54:34' prior: 50362660!
                   invalidateDisplayRect: damageRect from: aMorph
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self world 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: ( `0@0` extent: extent) ) ]
                ifFalse: [ super invalidateDisplayRect: damageRect from: aMorph ]! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:54:27' prior: 50362674!
            drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			aCanvas image: backgroundImage at: `0@0` ]
		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [ aCanvas drawsOnDisplay ] and: [ color mightBeTranslucent ])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Cuis Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: `0@0` in: nil
						fillColor: color rule: Form over.
					Display forceToScreen]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:54:38' prior: 50362700!
            morphPositionInWorld

	self flag: #jmvVer2. "Solo para evitar los warning por falta de owner... pensar despues este caso"
	self isWorldMorph ifTrue: [ ^ `0@0` ].
	^ super morphPositionInWorld! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 3/12/2018 15:54:43' prior: 50362709!
  viewBox

	^ worldState
		ifNotNil: [
			 `0@0` extent: extent ]
		ifNil: [
			self world viewBox ]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/12/2018 15:54:30' prior: 50381046!
 fillRects: rectangleList
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."


	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		combinationRule: Form over.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt fillColor: Color random.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 50) wait! !
!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 15:54:48' prior: 50379167!
                      newWorld
	"
[
	UISupervisor stopUIProcess.
	UISupervisor spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: `0@0` extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 3/12/2018 15:48:22' prior: 50362778!
                    morphContainsPoint: aLocalPoint

	| radius other delta xOverY |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [^ false].  "quick elimination"
	extent > `1@1`
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ extent y asFloat / 2.
	other _ extent x asFloat / 2.
	delta _ aLocalPoint - (other@radius).
	xOverY _ extent x asFloat / extent y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!HandleMorph methodsFor: 'events' stamp: 'jmv 3/12/2018 15:51:54' prior: 50362796!
                       keyStroke: aKeyboardEvent
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ aKeyboardEvent keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - `1@0` ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + `1@0` ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - `0@1` ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + `0@1` ].
	"Special case for return"
	aKeyboardEvent isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:51:51' prior: 50362820!
                              initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ `12@12`! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:55:13' prior: 50362826!
       initialize
	super initialize.
	extent _ `200@100`! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:54:51' prior: 50367591!
              draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:54:54' prior: 50367663!
               drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:54:57' prior: 50367705!
                  initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  `20 @ 15`! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 3/12/2018 15:55:00' prior: 50367736!
     morphContainsPoint: aLocalPoint

	| iconOrigin |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ extent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: (aLocalPoint - iconOrigin) rounded) not ]]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 3/12/2018 15:55:05' prior: 50362916!
                           example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: `120@35`.
	^ row! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 3/12/2018 15:55:16' prior: 50362940!
                        addToScroller: aMorph

	scroller
		addMorph: aMorph position: `0@0`;
		morphExtent: aMorph morphExtent! !
!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:55:18' prior: 50362947!
                   initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ false.

	"initialize the receiver's scrollBars"
	scrollBar _ self scrollBarClass new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ self scrollBarClass new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ true.

	scroller _ self innerMorphClass new.
	self addMorph: scroller.
	self scrollerOffset: `0@ 0`.
	self addMorph: scrollBar.
	self addMorph: hScrollBar! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 3/12/2018 15:55:21' prior: 50362966!
               scrollToShow: aRectangle
	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.
	This means that 0@0 is scrolling all the way top and all the way left"
	| delta |
	(aRectangle top >= 0 and: [
		aRectangle bottom <= self viewableHeight ])
		ifTrue: [
			"already visible"
			^self ].

	"Scroll end of selection into view if necessary"
	delta _ aRectangle amountToTranslateWithin: (`0@0` extent: self viewableExtent).
	delta y ~= 0 ifTrue: [
		self scrollBy: 0@delta y ]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 3/12/2018 15:55:10' prior: 50380605!
                     mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar scrollValue < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self setSelectionIndex: row ]
		ifFalse: [ self setSelectionIndex: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 3/12/2018 15:56:57' prior: 50363045!
               invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(Different themes use various looks, this covers them all)"
	self invalidateLocalRect: (`0@0` extent: extent x @ (self labelHeight + borderWidth))! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:56:43' prior: 50363057!
                 drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: (`0@0` extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	"A border was drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	aCanvas fillRectangle: (borderWidth@borderWidth extent: extent x - (2*borderWidth)@ self labelHeight) color: titleColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:56:47' prior: 50363076!
drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: (`0@0` extent: extent)
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:57:04' prior: 50363099!
          makeMeFullyVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self morphExtent)]) ifTrue: [
		^ self "OK -- visible"].

	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: self morphExtentInWorld world: self world) topLeft! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:57:07' prior: 50363113!
                     makeMeVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:57:09' prior: 50363129!
                 minimumExtent

	^`160@80`! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:57:13' prior: 50363133!
             rescaleButtons
	"boxExtent changed.  Update my buttons."
	| buttonExtent buttonPos buttonDelta |
	buttonExtent := self boxExtent.
	buttonPos := `2@2`.
	buttonDelta := self boxExtent x + 2.
	self submorphsReverseDo: [ :aMorph |
		(aMorph is: #PluggableButtonMorph) 
		  ifTrue: [ 
				aMorph morphExtent: buttonExtent. 
				aMorph morphPosition: buttonPos.
				buttonPos := (buttonPos x  + buttonDelta) @ 2.
		].
	]! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:56:39' prior: 50363149!
  boxExtent
	"answer the extent to use in all the buttons. 
	 
	the label height is used to be proportional to the fonts preferences"
	| e |
	Theme current minimalWindows ifTrue: [^`0@0`].
	e _ Preferences windowTitleFont height.
	^e@e! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:56:51' prior: 50363160!
                       initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	
	self initializeLabelArea.
	extent _ `300 @ 200`.

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorphFront: m ].

	"by default"
	self beColumn! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:56:54' prior: 50363192!
                         initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing |
	spacing _ self boxExtent x + 2.
	self addMorph: self createCloseBox position: `2@2`.
	self addMorph: self createCollapseBox position: spacing+2@2.
	self addMorph: self createExpandBox position: spacing*2+2@2.
	self addMorph: self createMenuBox position: spacing*3+2@2! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 3/12/2018 15:57:00' prior: 50363206!
  layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww pos |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) morphPosition: cornerExtent@0 extent: w@thickness.
	(adjusters at: #bottomAdjuster) morphPosition: cornerExtent@(wh-thickness) extent: w@thickness.
	(adjusters at: #leftAdjuster) morphPosition: 0@cornerExtent extent: thickness@h.
	(adjusters at: #rightAdjuster) morphPosition: ww-thickness@cornerExtent extent: thickness@h.
	(adjusters at: #topLeftAdjuster) morphPosition: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) morphPosition: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) morphPosition: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) morphPosition: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos _ borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			morphPosition: pos
			extent: extent - pos - borderWidth ].
	
	layoutNeeded _ false! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 3/12/2018 15:57:17' prior: 50363248!
                            resize
	| resizeMorph |
	resizeMorph _ ResizeMorph new morphExtent: `200@150`.
	resizeMorph action: [self resize: (resizeMorph selectionRectangle: Display extent)].
	resizeMorph morphPosition: self world activeHand morphPosition.
	resizeMorph openInWorld! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 3/12/2018 15:47:52' prior: 50375301!
                           initialExtent

	^`540@400` * Preferences standardCodeFont height // 14! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 3/12/2018 15:47:45' prior: 50375307!
                      initialExtent
	^`540@300` * Preferences standardCodeFont height // 14! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 3/12/2018 15:55:30' prior: 50375313!
                           initialExtent
	^ `640 @ 320` * Preferences standardCodeFont height // 14! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 3/12/2018 15:52:24' prior: 50375319!
                       initialExtent

	^`600@325` * Preferences standardCodeFont height // 14! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 3/12/2018 15:54:22' prior: 50375325!
                    initialExtent

	^`300@500` * Preferences standardCodeFont height // 14! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 3/12/2018 15:57:20' prior: 50363280!
                        buildMorphicWindow

	self layoutMorph
		addMorph: self buildUpperControls proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.
	self setLabel: 'SUnit Test Runner'.
	self refreshWindow.
	self morphExtent: `460 @ 400`! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:56:22' prior: 50363291!
        drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: (color alphaMixed: 0.3 with: Theme current scrollbarColor)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 3/12/2018 15:53:14' prior: 50363301!
      addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleLikeMorph new.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 16) @ (pp y).
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/12/2018 15:53:30' prior: 50363328!
       popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = `0@0` ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/12/2018 15:53:34' prior: 50363357!
         popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/12/2018 15:53:37' prior: 50363382!
      popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:53:27' prior: 50363401!
            initialize
	super initialize.
	extent _ `40@10`.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 3/12/2018 15:53:21' prior: 50363408!
   displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock position: `0@ -20`.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 3/12/2018 15:53:17' prior: 50363437!
  adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p h |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: each minItemWidth].

	w _ w + 1.
	p _ `5 @ 5`.
	submorphs do: [ :m |
		h _ m morphHeight.
		m morphPosition: p extent: w@h.
		p _ p + (0@(h + 1)) ].

	self morphExtent: w+4 @ p y + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 3/12/2018 15:53:24' prior: 50363456!
                         fitInWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| delta |
	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self morphPosition: ((self morphPosition x + 10 - extent x) @ self morphPosition y) ].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight:
			((owner world morphExtentInWorld y) max: (self morphPosition y) + 1)).
	delta = `0 @ 0` ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:47:08' prior: 50363482!
                              downButtonPosition
	^ `0@0` + (extent - ScrollBar scrollbarThickness)! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:47:14' prior: 50363488!
                            drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (`0@0` extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 15:47:19' prior: 50363539!
    initializedInstance
	| completer m |
	completer _ SmalltalkCompleter withModel: (TextModel withText: 'Small').
	completer
		instVarNamed: 'position'
		put: 5.
	completer computeEntries.
	m _ AutoCompleterMorph
		completer: completer
		position: `200 @ 200`.
	completer instVarNamed: 'menuMorph' put: m.
	^m! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:51:41' prior: 50363552!
                        drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: `0@0`
		color: Color black! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:51:48' prior: 50363561!
        savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| fullBounds |
	fullBounds _ self morphFullBoundsInWorld.
	fullBounds ifNil: [ ^self ].

	fullBounds _ fullBounds intersect: (`0@0` extent: aCanvas extent).
	(savedPatch isNil or: [savedPatch extent ~= fullBounds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBounds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: fullBounds
		into: savedPatch.
	savedPatch offset: fullBounds topLeft.
	prevFullBounds
		ifNil: [ aStream nextPut: fullBounds ]
		ifNotNil: [ aStream nextPut: (fullBounds merge: prevFullBounds)].
	prevFullBounds _ fullBounds! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:51:44' prior: 50363591!
          initForEvents
	mouseOverHandler _ nil.
	lastMouseEvent _ MouseEvent new setType: #mouseMove position: `0@0` buttons: 0 hand: self.
	lastMouseEventTime _ Time localMillisecondClock.
	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.
	self dontWaitForMoreClicks! !
!ImageMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:51:57' prior: 50363602!
        drawOn: aCanvas

	aCanvas image: image at: `0@0`! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:56:33' prior: 50363607!
                        drawOn: aCanvas
	aCanvas
		drawString: (contents ifNil: [ '' ])
		at: `0@0`
		font: self fontToUse
		color: color! !
!StringMorph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:56:36' prior: 50363614!
                      fitContents
	"Measures contents later at #minimumExtent"
	self morphExtent: `0@0`! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:52:00' prior: 50363620!
            drawOn: aCanvas

	| tRect colorToUse sLeft aForm centeringOffset |
	isHighlighted ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) duller ].
	isSelected ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].
			
	tRect _ self toggleRectangle.
	aForm _ isExpanded 
		ifTrue: [ container expandedForm ]
		ifFalse: [ container notExpandedForm ].
	centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.

	complexContents hasContents ifTrue: [
		aCanvas 
			image: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	icon isNil
	ifFalse: [
		 aCanvas 
			image: icon
			at:  (tRect topLeft translatedBy:  icon width  @ centeringOffset).
		sLeft _ indentLevel * 12 + 16 + (icon width + 2).
	]
	ifTrue: [
		sLeft _ indentLevel * 12 + 16.
	].
	colorToUse _ complexContents preferredColor ifNil: [ color ].

	aCanvas
		drawString: contents asString
		at: sLeft@0
		font: self fontToUse
		color: colorToUse! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/12/2018 15:52:47' prior: 50363658!
                contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:52:51' prior: 50363694!
                          drawOn: aCanvas 
	| stringColor leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: (`0@0` extent: extent) color: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScaleAndTransparent ].
			aCanvas image: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
			leftEdge _ leftEdge + iconForm width + self iconSeparation].

	aCanvas
		drawString: contents
		at: leftEdge @ 1
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			image: self class subMenuMarker
			at: extent x - 8 @ (extent y - self class subMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:52:54' prior: 50363723!
                            initialize
	"initialize the state of the receiver"
	super initialize.
	""
	extent _ `10@10`.
	contents _ ''.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ Preferences standardMenuFont! !
!MenuItemMorph methodsFor: 'layout' stamp: 'jmv 3/12/2018 15:52:57' prior: 50363734!
            measureContents
	| e |
	e _ super measureContents.
	^e y > 12
		ifTrue: [e+`2@2`]
		ifFalse: [e+`2@1`]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/12/2018 15:52:59' prior: 50363741!
                              select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + `10@0`
											with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !
!MenuItemMorph class methodsFor: 'cached state access' stamp: 'jmv 3/12/2018 15:53:02' prior: 50363754!
                              subMenuMarker

	| f |
	SubMenuMarker ifNotNil: [ ^SubMenuMarker ].
	f _ Form
		extent: `5@9`
		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)
		offset: `0@0`.
	SubMenuMarker _ ColorForm mappingWhiteToTransparentFrom: f.
	^SubMenuMarker! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:52:28' prior: 50363767!
                  drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: color! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 3/12/2018 15:52:31' prior: 50363773!
                         layoutBounds
	"Return the bounds for laying out children of the receiver"

	^`0@0` extent: extent! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 3/12/2018 15:52:35' prior: 50363779!
        layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth 
		fractionalWidths integerWidths theLeft usableHeight boundsTop boundsRight theTop minWidth submorphsToLayout 
			nextMorph ht wd ls theRight boundsBottom theBottom alternativeWidths count diff i |
	
	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableWidth := boundsForLayout width - ((submorphsToLayout size + 1) * xSep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth := usableWidth - sumOfFixed max: 0.
	normalizationFactor := self proportionalWidthNormalizationFactor.
	availableForPropWidth := availableForPropWidth * normalizationFactor.
	
	fractionalWidths := submorphsToLayout collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerWidths _ fractionalWidths collect: [ :w | w rounded ].
	diff _ integerWidths sum - fractionalWidths sum rounded.
	alternativeWidths _ diff > 0 ifTrue: [ fractionalWidths collect: [ :w | w floor ]] ifFalse: [ fractionalWidths collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerWidths at: i) = (alternativeWidths at: i) ifFalse: [
			integerWidths at: i put: (alternativeWidths at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minWidth := integerWidths sum.
	theLeft := ((usableWidth - minWidth) * (padding ifNil: [0]) max: 0) + boundsForLayout left + xSep.
	usableHeight := boundsForLayout height - (ySep * 2) max: 0.
	boundsTop    := boundsForLayout top + ySep.
	boundsRight  := boundsForLayout right - xSep.
	boundsBottom := boundsForLayout bottom - ySep.

	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		wd := integerWidths at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		ht := (ls heightFor: usableHeight) min: usableHeight.
		theTop := ((usableHeight - ht) * ls minorDirectionPadding) floor + boundsTop.
		theBottom := (theTop + ht) ceiling min: boundsBottom.
		theRight := (theLeft + (wd min: minWidth)) "ceiling "min: boundsRight.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theLeft := theRight + xSep
	]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 3/12/2018 15:52:39' prior: 50363870!
  layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight 
		fractionalHeights integerHeights theTop usableWidth boundsLeft boundsBottom theLeft minHeight submorphsToLayout 
			nextMorph ht wd ls theBottom boundsRight theRight alternativeHeights count diff i |

	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableHeight := boundsForLayout height - ((submorphsToLayout size + 1) * ySep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight := usableHeight - sumOfFixed max: 0.
	normalizationFactor := self proportionalHeightNormalizationFactor.
	availableForPropHeight := availableForPropHeight * normalizationFactor.
	
	fractionalHeights := submorphsToLayout collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerHeights _ fractionalHeights collect: [ :w | w rounded ].
	diff _ integerHeights sum - fractionalHeights sum rounded.
	alternativeHeights _ diff > 0 ifTrue: [ fractionalHeights collect: [ :w | w floor ]] ifFalse: [ fractionalHeights collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerHeights at: i) = (alternativeHeights at: i) ifFalse: [
			integerHeights at: i put: (alternativeHeights at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minHeight := integerHeights sum.
	theTop := ((usableHeight - minHeight) * (padding ifNil: [0]) max: 0) + boundsForLayout top + ySep.
	usableWidth     := boundsForLayout width - (xSep * 2) max: 0.
	boundsLeft      := boundsForLayout left + xSep.
	boundsBottom := boundsForLayout bottom - ySep.
	boundsRight := boundsForLayout right - xSep.
	
	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		ht := integerHeights at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		wd := (ls widthFor: usableWidth) min: usableWidth.
		theLeft := ((usableWidth - wd) * ls minorDirectionPadding) floor + boundsLeft.
		theRight := (theLeft + wd) ceiling min: boundsRight.
		theBottom := (theTop + (ht min: minHeight)) "ceiling" min: boundsBottom.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theTop := theBottom + ySep
	]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:55:38' prior: 50363963!
                       initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress _ ProgressBarMorph new.
	progress morphExtent: `200 @ 15`.
	self addMorphFront: labelMorph.
	self addMorphFront: subLabelMorph.
	self addMorph: progress fixedHeight: 15! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:51:24' prior: 50363978!
                      drawOn: aCanvas

	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: color
		at: `0@0`! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 3/12/2018 15:51:29' prior: 50363984!
      addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^ handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 3/12/2018 15:51:35' prior: 50364018!
   basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self class handleSize.
	anExtent _ ((extent x + self class handleSize + 8) max: minSide) @
				((extent y + self class handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld center extent: anExtent.
	w _ self world ifNil: [ target world ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: `8@8`) ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 3/12/2018 15:51:38' prior: 50364034!
                    startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self removeAllHandlesBut: growHandle.  "remove all other handles"
	botRt _ target morphPositionInWorld + target morphExtentInWorld.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [`0@0`]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:52:04' prior: 50364052!
     itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	self hasSubmorphs ifFalse: [ ^nil ].
	(aPoint > `0@0` and: [ aPoint < extent ]) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	self firstSubmorph morphPosition y > ptY ifTrue: [ ^nil ].
	last _ self lastSubmorph.
	last morphPosition y + last morphHeight < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^self 
		findSubmorphBinary: [ :m |
			(m morphPosition y <= ptY and: [ m morphPosition y + m morphHeight >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPosition y + (m morphHeight // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:52:08' prior: 50364078!
                      drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds color: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:52:11' prior: 50364097!
        drawHighlightOn: aCanvas
"Ademas, poner el mouse pointer de relojito si tarda... Detectarlo automaticamente, etc. Aunque no estoy seguro de como hacerlo... quizas colgar un cachito de codigo en un proceso de mayor prioridad, onda 'si pasa 1 segundo, y todavia no te resetee este flag, entonces pone el relojito'"
	| selectionDrawBounds |
	highlightedRow  ifNil: [ ^self ].
	highlightedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: highlightedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus) duller! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:52:14' prior: 50364121!
   drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:52:17' prior: 50364136!
                    drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		textComposition: self textComposition
		bounds: (`0@0` extent: extent)
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!ResizeMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:56:01' prior: 50364149!
        initialize
	super initialize.
	extent _ `400@300`.
	color _ Color white.
	grid _ `8@6`.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:48:45' prior: 50364158!
                        createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `2@7.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:48:48' prior: 50364171!
createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `12@7.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:48:51' prior: 50364185!
                               createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	result morphExtent: `24@2` * self sizeUnit.
	self addMorph: result position: `2@0.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:48:54' prior: 50364197!
                         createTextPaneAcceptOnCR: acceptBoolean
	"create the textPane"
	| result |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"

	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	result morphExtent: `18@5` * self sizeUnit.
	self addMorph: result position: `1@2` * self sizeUnit.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:49:00' prior: 50364215!
   initialize

	super initialize.
	extent _ `20@10` * self sizeUnit.
	responseUponCancel _ ''! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:48:57' prior: 50364221!
      drawOn: aCanvas

	Theme current roundWindowCorners
		ifTrue: [
			aCanvas
				roundRect: (`0@0` extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ]! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:57:36' prior: 50364231!
               drawOn: aCanvas
	Transcript
		showOnDisplay: true;
		displayOn: form in: (`0@0` extent: extent).
	aCanvas image: form at: `0@0`.
	Transcript
		bounds: self morphBoundsInWorld;
		showOnDisplay: doImmediateUpdates.
	self updateWorkspace! !
!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 15:53:05' prior: 50364242!
                            drawOn: aCanvas 
	| baseColor |
	baseColor _ owner color.
	aCanvas
		fillRectangle: (`0@0` corner: extent x @ (extent y / 2))
		color: baseColor twiceDarker.
			
	aCanvas
		fillRectangle: (0 @ (extent y / 2) corner: extent)
		color: baseColor twiceLighter! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:53:08' prior: 50364253!
initialize
	super initialize.
	extent _ `50 @ 2`! !
!MenuLineMorph methodsFor: 'geometry' stamp: 'jmv 3/12/2018 15:53:10' prior: 50364258!
                     minimumExtent

	^`10@2`! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/12/2018 15:57:46' prior: 50364262!
             tryDeferredUpdatingAndSetCanvas
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		world morphPosition: `0@0` extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 3/12/2018 15:54:16' prior: 50364292!
                   startDispatchFrom: aHand
	"double dispatch the event dispatch"
	"An event of an unknown type was sent. What shall we do?!!"

	Smalltalk beep. 
	self printString displayAt: `0@0`.
	self wasHandled: true! !
!MorphicCanvas methodsFor: 'accessing' stamp: 'jmv 3/12/2018 15:54:04' prior: 50364302!
                           newClipRect: aRectangleOrNil
	"aRectangle is in world coordinates.
	But ivar clipRect is relative to the form,
	For example, if we had previously been built like
		aCanvas on: someForm over: (100@100 extent 200@100)
	then our origin would be -100 @ -100.
	Then, a clipRect argument like (120@120 extent: 40@30) would mean affecting
	only (20@20 extent: 40@30) in our form"

	self setClipRect: (aRectangleOrNil
		ifNil: [ `0@0` corner: form extent ]
		ifNotNil: [ aRectangleOrNil translatedBy: self canvasOrigin ])! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 3/12/2018 15:53:57' prior: 50364321!
     drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > `50@50`
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Color yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Color yellow! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/12/2018 15:54:00' prior: 50364339!
                             drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Color black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Color black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Color white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + `0@2`
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + `0@1`
		font: fontOrNil
		color: aColor! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/12/2018 15:54:10' prior: 50364366!
            textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc
	| displayScanner leftInRun line boundsInWorld tl |

	tl _ boundsRect topLeft.
	boundsInWorld _ currentTransformation displayBoundsOfTransformOf: boundsRect.

	displayScanner _ MorphicScanner new
		defaultFont: aTextComposition defaultFont;
		text: aTextComposition textComposed
		foreground: c.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aTextComposition lineIndexForPoint: (`0@0` max: (clipLeft@clipTop)- boundsInWorld origin))
		to: (aTextComposition lineIndexForPoint: (boundsInWorld extent min: (clipRight@clipBottom+1) - boundsInWorld origin))
		do: [ :i |
			line _ aTextComposition lines at: i.
			aTextComposition
				displaySelectionInLine: line
				on: self
				textTopLeft: tl
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line textTopLeft: tl leftInRun: leftInRun ]! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 15:54:13' prior: 50364401!
                               onForm: aForm

	^ self basicNew
		initializeWith: aForm origin: `0@0`! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 3/12/2018 15:47:31' prior: 50364406!
  fillRectangle: aRectangle tilingWith: aForm sourceRect: patternBox rule: aCombinationRule
	"aRectangle is in form coordinates, no transformation is done."
	| displayRectangle  additionalOffset clippedPort targetTopLeft clipOffset ex 
	targetBox savedMap top left |
	
	ex _ patternBox extent.
	ex x = 0 ifTrue: [ ^self ].
	ex y = 0 ifTrue: [ ^self ].
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.

	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.
	something better is needed, but not now"

	additionalOffset _ `0@0`.
	clippedPort _ port clippedBy: displayRectangle.
	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.
	clipOffset _ displayRectangle topLeft - targetTopLeft.
	additionalOffset _ (clipOffset \\ ex) - ex.

	"do it iteratively"
	targetBox _ clippedPort clipRect.
	savedMap _ clippedPort colorMap.
	clippedPort sourceForm: aForm;
		fillColor: nil;
		combinationRule: aCombinationRule;
		sourceRect: patternBox;
		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).
	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.
	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.

	left to: (targetBox right - 1) by: patternBox width do: [:x |
		top to: (targetBox bottom - 1) by: patternBox height do: [:y |
			clippedPort destOrigin: x@y; copyBits]].
	clippedPort colorMap: savedMap! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 3/12/2018 15:47:38' prior: 50364454!
          steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (`0@0` extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				roundRect: (`1@1` extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 3/12/2018 15:47:35' prior: 50364473!
              buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - `1@2`.
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Color r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Color transparent ]
				ifFalse: [
					borderSpec = (Color r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Color white]
								ifFalse: [Color black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!TextComposition methodsFor: 'selection' stamp: 'jmv 3/12/2018 15:57:22' prior: 50364514!
 defaultCharacterBlock
	^ CharacterBlock
		stringIndex: 1
		text: model actualContents
		topLeft: lines first topLeft
		extent: `0 @ 0`
		textLine: lines first! !
!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 3/12/2018 15:56:04' prior: 50334799!
                               isBinarySelectorCharacter: aCharacter

	aCharacter isValidInIdentifiers ifTrue: [^false].
	aCharacter isSeparator ifTrue: [^false].

	('"#$'':().;[]{}_`'  includes: aCharacter) 
		ifTrue:[^false].
	aCharacter numericValue = Scanner doItCharacterValue ifTrue: [^false "the doIt char"].
	aCharacter numericValue = 0 ifTrue: [^false].
	"Any other char is ok as a binary selector char."
	^ true! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 3/12/2018 15:56:08' prior: 50373241!
   parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 3/12/2018 15:56:12' prior: 50335054!
                               parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst == $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst == $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst == $[ ifTrue: [^self parseBlock].
	currentTokenFirst == $` ifTrue: [^self parseBacktick].
	currentTokenFirst == ${ 
		ifTrue: [
			self scanPast: #leftBrace.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !
!DifferenceFinder methodsFor: 'private' stamp: 'jmv 3/12/2018 15:48:12' prior: 50364522!
              maxLengthPoints
	| max points |
	max := self maxLength.
	max = 0 ifTrue: [^Array with: `0 @ 0`].
	points := OrderedCollection new.
	tally withIndexesDo: [:i :j :t | t = max ifTrue: [points add: i @ j]].
	^ points! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3271-RefreshAllMethodsUsingBacktick-JuanVuletich-2018Mar12-15h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3271] on 12 March 2018 at 4:50:33 pm'!
!Color class methodsFor: 'instance creation' stamp: 'jmv 3/7/2018 10:37:22'!
           jet: fraction
	"Answer a suitable color for a HeatMap using the 'jet' color scheme.
	See https://en.wikipedia.org/wiki/Heat_map
	
	Color showColors: ((0.0 to: 1.0 count: 100) collect: [ :f | Color jet: f ])
	"
	
	| hue |
	hue _ Color blue hue interpolateTo: Color red hue at: fraction.
	^ Color h: hue s: 1 v: 1! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3272-jet-heatmap-colors-JuanVuletich-2018Mar12-16h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3272] on 12 March 2018 at 6:02:58 pm'!
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 3/10/2018 22:22:45' prior: 50356632!
            kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char _ nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char _ self keyboard.
		Display fill: `5@5 extent: 400@20` fillColor: `Color white`.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char numericValue;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])
		displayAt: 10 @ 10 ].! !
!String methodsFor: 'displaying' stamp: 'jmv 3/10/2018 21:32:34' prior: 50356670!
                         displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: `Color black`
	"
	'Display' displayOn: Display at: 10@10
	"! !
!Color methodsFor: 'conversions' stamp: 'jmv 3/10/2018 21:25:40' prior: 50356682!
                       makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [`Color black`]
                ifFalse: [`Color white`]! !
!Color methodsFor: 'transformations' stamp: 'jmv 3/10/2018 21:25:46' prior: 50356857!
             muchDarker

	^ self alphaMixed: 0.5 with: `Color black`
! !
!Color methodsFor: 'transformations' stamp: 'jmv 3/10/2018 22:17:55' prior: 50356862!
              muchLighter

	^ self alphaMixed: 0.233 with: `Color white`! !
!Color methodsFor: 'transformations' stamp: 'jmv 3/10/2018 21:25:51' prior: 50356874!
            quiteBlacker

	^ self alphaMixed: 0.8 with: `Color black`
! !
!Color methodsFor: 'transformations' stamp: 'jmv 3/10/2018 22:18:15' prior: 50356879!
            quiteWhiter

	^ self alphaMixed: 0.6 with: `Color white`! !
!Color methodsFor: 'transformations' stamp: 'jmv 3/10/2018 21:26:03' prior: 50356889!
              veryMuchDarker

	^ self alphaMixed: 0.25 with: `Color black`! !
!Color methodsFor: 'transformations' stamp: 'jmv 3/10/2018 22:18:31' prior: 50356894!
          veryMuchLighter

	^ self alphaMixed: 0.07 with: `Color white`! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 3/10/2018 21:27:30' prior: 50356904!
 colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^ `Color transparent` ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^`Color transparent` ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Color r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Color r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^`Color black` ].
		^ Color r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^`Color black` ].
		^ Color r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^`Color black` ].
		^ Color r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 3/10/2018 20:53:35' prior: 50354473!
             fromArray: colorDef

	| answer |
	colorDef size = 0 ifTrue: [^ `Color transparent` ].
	colorDef size between: 3 and: 4 :: ifFalse: [self error: 'Undefined color definition'].
	answer _ self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3).
	^colorDef size = 3
		ifTrue: [answer]
		ifFalse: [answer alpha: (colorDef at: 4)]! !
!Color class methodsFor: 'class initialization' stamp: 'jmv 3/10/2018 20:57:43' prior: 50356995!
              initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: `Color r: 1.0 g: 1.0 b: 1.0`.		"white or transparent"
	a at: 2 put: `Color r: 0.0 g: 0.0 b: 0.0`.	"black"

	"additional colors for 2-bit color"
	a at: 3 put: `Color r: 1.0 g: 1.0 b: 1.0`.	"opaque white"
	a at: 4 put: `Color r: 0.5 g: 0.5 b: 0.5`.	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: `Color r: 1.0 g: 0.0 b: 0.0`.	"red"
	a at:  6 put: `Color r: 0.0 g: 1.0 b: 0.0`.	"green"
	a at:  7 put: `Color r: 0.0 g: 0.0 b: 1.0`.	"blue"
	a at:  8 put: `Color r: 0.0 g: 1.0 b: 1.0`.	"cyan"
	a at:  9 put: `Color r: 1.0 g: 1.0 b: 0.0`.	"yellow"
	a at: 10 put: `Color r: 1.0 g: 0.0 b: 1.0`.	"magenta"

	a at: 11 put: `Color r: 0.125 g: 0.125 b: 0.125`.		"1/8 gray"
	a at: 12 put: `Color r: 0.25 g: 0.25 b: 0.25`.			"2/8 gray"
	a at: 13 put: `Color r: 0.375 g: 0.375 b: 0.375`.		"3/8 gray"
	a at: 14 put: `Color r: 0.625 g: 0.625 b: 0.625`.		"5/8 gray"
	a at: 15 put: `Color r: 0.75 g: 0.75 b: 0.75`.			"6/8 gray"
	a at: 16 put: `Color r: 0.875 g: 0.875 b: 0.875`.		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Color r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Color r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 3/10/2018 22:18:42' prior: 50357180!
                              computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: `Color white` ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 3/10/2018 21:59:30' prior: 50357202!
           computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: `Color white` ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 3/10/2018 22:09:19' prior: 50357262!
          computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (`Color transparent` pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Color class methodsFor: 'color name lookup' stamp: 'jmv 3/10/2018 20:42:11' prior: 50357536!
 traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: `Color r: 0 g: 0 b: 0`.
	nameDict at: #veryVeryDarkGray put: `Color r: 0.125 g: 0.125 b: 0.125`.
	nameDict at: #veryDarkGray put: `Color r: 0.25 g: 0.25 b: 0.25`.
	nameDict at: #darkGray put: `Color r: 0.375 g: 0.375 b: 0.375`.
	nameDict at: #gray put: `Color r: 0.5 g: 0.5 b: 0.5`.
	nameDict at: #lightGray put: `Color r: 0.625 g: 0.625 b: 0.625`.
	nameDict at: #veryLightGray put: `Color r: 0.75 g: 0.75 b: 0.75`.
	nameDict at: #veryVeryLightGray put: `Color r: 0.875 g: 0.875 b: 0.875`.
	nameDict at: #white put: `Color r: 1.0 g: 1.0 b: 1.0`.
	nameDict at: #red put: `Color r: 1.0 g: 0 b: 0`.
	nameDict at: #yellow put: `Color r: 1.0 g: 1.0 b: 0`.
	nameDict at: #green put: `Color r: 0 g: 1.0 b: 0`.
	nameDict at: #cyan put: `Color r: 0 g: 1.0 b: 1.0`.
	nameDict at: #blue put: `Color r: 0 g: 0 b: 1.0`.
	nameDict at: #magenta put: `Color r: 1.0 g: 0 b: 1.0`.
	nameDict at: #brown put: `Color r: 0.6 g: 0.2 b: 0`.
	nameDict at: #orange put: `Color r: 1.0 g: 0.6 b: 0`.
	nameDict at: #lightRed put: `Color r: 1.0 g: 0.8 b: 0.8`.
	nameDict at: #lightYellow put: `Color r: 1.0 g: 1.0 b: 0.8`.
	nameDict at: #lightGreen put: `Color r: 0.8 g: 1.0 b: 0.6`.
	nameDict at: #lightCyan put: `Color r: 0.4 g: 1.0 b: 1.0`.
	nameDict at: #lightBlue put: `Color r: 0.8 g: 1.0 b: 1.0`.
	nameDict at: #lightMagenta put: `Color r: 1.0 g: 0.8 b: 1.0`.
	nameDict at: #lightBrown put: `Color r: 1.0 g: 0.6 b: 0.2`.
	nameDict at: #lightOrange put: `Color r: 1.0 g: 0.8 b: 0.4`.
	nameDict at: #transparent put: `TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0`.
	
	^nameDict
! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 3/12/2018 17:57:31' prior: 50382830!
   endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			`0@0` + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (`4@4` + frame topLeft extent: Display extent)
		color: `Color black`
		selectionColor: `Color blue`.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter methodsFor: 'private' stamp: 'jmv 3/10/2018 21:34:26' prior: 50357790!
                               black
	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].
	^ `Color black`! !
!Transcripter methodsFor: 'private' stamp: 'jmv 3/10/2018 22:23:58' prior: 50357796!
                          white
	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].
	^ `Color white`! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 3/10/2018 21:53:12' prior: 50357802!
                    example
    "An example and test of DataStream/ReferenceStream.
     11/19/92 jhm: Use self testWith:."
    "DataStream example"
    "ReferenceStream example"
    | input sharedPoint |

    "Construct the test data."
    input _ Array new: 9.
    input at: 1 put: nil.
    input at: 2 put: true.
    input at: 3 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 3) fillWithColor: `Color lightBlue`.
    input at: 4 put: #(3 3.0 'three').
    input at: 5 put: false.
    input at: 6 put: 1024 @ -2048.
    input at: 7 put: #x.
    input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
    input at: 9 put: sharedPoint.

    "Write it out, read it back, and return it for inspection."
    ^ self testWith: input! !
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: 'jmv 3/10/2018 21:54:43' prior: 50357828!
       example2
"Here is the way to use DataStream and ReferenceStream:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	rr nextPut: <your object>.
	rr close.

To get it back:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	<your object> _ rr next.
	rr close.
"
"An example and test of DataStream/ReferenceStream.
	 11/19/92 jhm: Use self testWith:."
	"ReferenceStream example2"
	| input sharedPoint |

	"Construct the test data."
	input _ Array new: 9.
	input at: 1 put: nil.
	input at: 2 put: true.
	input at: 3 put: false.
	input at: 4 put: #(-4 -4.0 'four' four).
	input at: 5 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 5) fillWithColor: `Color lightOrange`.
	input at: 6 put: 1024 @ -2048.
	input at: 7 put: input. "a cycle"
	input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
	input at: 9 put: sharedPoint.

	"Write it out, read it back, and return it for inspection."
	^ self testWith: input
! !
!TextAction class methodsFor: 'as yet unclassified' stamp: 'jmv 3/10/2018 20:58:51' prior: 50357887!
            textActionColor
	^ `Color r: 0.4 g: 0 b: 1.0`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:33:13' prior: 50370186!
           black
	^ self new color: `Color black`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:41:12' prior: 50370190!
                  blue
	^ self new color: `Color blue`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:41:25' prior: 50370194!
                    cyan
	^ self new color: `Color cyan`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:41:30' prior: 50370198!
                    gray
	^ self new color: `Color gray`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:41:34' prior: 50370202!
                    green
	^ self new color: `Color green`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:41:39' prior: 50370206!
                  magenta
	^ self new color: `Color magenta`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:42:40' prior: 50370210!
              red
	^ self new color: `Color red`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:42:46' prior: 50370214!
                      white 
	^ self new color: `Color white`! !
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:42:50' prior: 50370218!
                 yellow
	^ self new color: `Color yellow`! !
!TextColor methodsFor: 'testing' stamp: 'jmv 3/10/2018 21:33:19' prior: 50357891!
  isSet
	"Do not include Color black, as it is the default color."
	^color ~= `Color black`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:33:25' prior: 50357896!
         black
	^ self new color: `Color black`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:38:56' prior: 50357900!
                            blue
	^ self new color: `Color blue`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:39:20' prior: 50357904!
                              cyan
	^ self new color: `Color cyan`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:39:25' prior: 50357908!
                              gray
	^ self new color: `Color gray`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:39:29' prior: 50357912!
                              green
	^ self new color: `Color green`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:39:33' prior: 50357916!
                            magenta
	^ self new color: `Color magenta`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:39:38' prior: 50357920!
                        red
	^ self new color: `Color red`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:39:45' prior: 50357924!
white 
	^ self new color: `Color white`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:39:51' prior: 50357928!
                           yellow
	^ self new color: `Color yellow`! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 3/10/2018 22:15:21' prior: 50381660!
                        displayOn: aForm in: aRectangle
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f canvas innerR |
	aForm fill: aRectangle fillColor: `Color white`.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	fh _ font height.
	count _ innerR height // fh.
	x _ innerR left.
	y _ innerR top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	[ i <= lastIndex ] whileTrue: [
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: `Color veryDarkGray`.
		y _ y + fh.
		i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: `Color veryDarkGray`! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 3/10/2018 22:15:54' prior: 50357977!
                    displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas r innerR |
	innerR _ bounds insetBy: self padding.
	lastDisplayPosition < innerR right ifTrue: [
		font _ AbstractFont default.
		fh _ font height.
		count _ innerR height // fh-1.
		x _ innerR left.
		string _ unfinishedEntry contents.
		y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerR top.
		canvas _ aForm getCanvas.
		r _ innerR left: lastDisplayPosition.
		canvas newClipRect: r.
		(canvas drawString: string at: x@y font: font color: `Color veryDarkGray`) ifNotNil: [ :lastPoint |
			lastDisplayPosition _ lastPoint x.
			^r ]].
	^nil! !
!Form methodsFor: 'bordering' stamp: 'jmv 3/10/2018 21:28:34' prior: 50358012!
   border: aRectangle width: borderWidth 
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses black for 
	drawing the border."

	self border: aRectangle width: borderWidth fillColor: `Color black`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 21:28:39' prior: 50358023!
   fillBlack
	"Set all bits in the receiver to black (ones)."

	self fill: self boundingBox fillColor: `Color black`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 21:28:44' prior: 50358029!
                             fillBlack: aRectangle 
	"Set all bits in the receiver's area defined by aRectangle to black (ones)."

	self fill: aRectangle rule: Form over fillColor: `Color black`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 21:45:56' prior: 50358037!
         fillGray
	"Set all bits in the receiver to gray."

	self fill: self boundingBox fillColor: `Color gray`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 21:46:03' prior: 50358043!
       fillGray: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to the gray mask."

	self fill: aRectangle rule: Form over fillColor: `Color gray`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 22:18:53' prior: 50358051!
           fillWhite
	"Set all bits in the form to white."

	self fill: self boundingBox fillColor: `Color white`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 22:19:16' prior: 50358057!
        fillWhite: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to white."

	self fill: aRectangle rule: Form over fillColor: `Color white`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 22:19:25' prior: 50358065!
                 reverse
	"Change all the bits in the receiver that are white to black, and the ones 
	that are black to white.
	Display reverse
	"

	self fill: self boundingBox rule: Form reverse fillColor: `Color white`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/10/2018 22:19:31' prior: 50358074!
  reverse: aRectangle
	"Change all the bits in the receiver's area that intersects with aRectangle 
	that are white to black, and the ones that are black to white."

	self fill: aRectangle rule: Form reverse fillColor: `Color white`! !
!Form methodsFor: 'converting' stamp: 'jmv 3/10/2018 22:10:25' prior: 50358151!
      as8BitColorForm
	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."

	| f map |
	f _ ColorForm extent: self extent depth: 8.
	self displayOn: f at: self offset negated.
	map _ Color indexedColors copy.
	map at: 1 put: `Color transparent`.
	f colors: map.
	f offset: self offset.
	^ f
! !
!Form methodsFor: 'pixel access' stamp: 'jmv 3/10/2018 22:11:31' prior: 50358172!
                         colorInterpolatedAt: aPoint
	"Evaluate a bilinear (i.e. cheap) interpolation
	Like OpenCV's CV_INTER_LINEAR
	Answer Color transparent if outside image bounds.
	Copied almost verbatim from FloatImage.
	Answer Colors with float components. Will be rounded to be stored in, for example, a 32-bit Form."

	| x y w interpolated xWeight1 xWeight0 yWeight1 yWeight0 xIndex0 xIndex1 yIndex0 yIndex1 |
	x _ aPoint x.
	y _ aPoint y.
	x < 0.0 ifTrue: [ ^ `Color transparent` ].
	xIndex0 _ x truncated. 		"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	xIndex0 > (width-1) ifTrue: [ ^ `Color transparent` ].
	(xIndex0 = (width-1) and: [ x > (width-1) ]) ifTrue: [ ^ `Color transparent` ].
	xIndex1 _ xIndex0 = (width-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ xIndex0 + 1 ]
		ifTrue: [ xIndex0 ].

	y < 0.0 ifTrue: [ ^ `Color transparent` ].
	yIndex0 _ y truncated.			"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	yIndex0 > (height-1) ifTrue: [ ^ `Color transparent` ].
	(yIndex0 = (height-1) and: [ y > (height-1) ]) ifTrue: [ ^ `Color transparent` ].
	yIndex1 _ yIndex0 = (height-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ yIndex0 + 1 ]
		ifTrue: [ yIndex0 ].

	xWeight1 _ x - xIndex0.
	xWeight0 _ 1.0 - xWeight1.

	yWeight1 _ y - yIndex0.
	yWeight0 _ 1.0 - yWeight1.

	"/* perform interpolation */"
	w _ ((self colorAt: xIndex0 @ yIndex0) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex0) * xWeight1).
	interpolated _ w * yWeight0.

	w _ ((self colorAt: xIndex0 @ yIndex1) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex1) * xWeight1).
	interpolated _ w * yWeight1 + interpolated.

	^interpolated! !
!Form methodsFor: 'transitions' stamp: 'jmv 3/12/2018 17:58:14' prior: 50383720!
                      pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: `Color black`.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 17:58:22' prior: 50383838!
    dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: `0@0` - radius.
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: `Color black`.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do: [ :dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 3/10/2018 22:20:49' prior: 50358341!
                            fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb _ GrafPort toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect _ aPoint extent: diameter.
	bb fillOval: rect.
	p _ (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: `Color white alpha: 0.3`.
		d _ i * diameter // 10.
		rect _ Rectangle
			center: p
			extent: d.
		bb fillOval: rect ].
	DisplayScreen screenUpdateRequired: nil.
"
	Form fakeSphereAt: 50@50 diameter: 30 color:  (Color red alpha: 0.5)
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 3/12/2018 17:58:38' prior: 50383876!
                         toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ `Color red wheel: 12`.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: `-40@-40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 3/10/2018 22:19:44' prior: 50358401!
                            bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 3/10/2018 22:19:58' prior: 50358428!
                          bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 3/10/2018 22:20:11' prior: 50358459!
        bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomRight corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 3/10/2018 22:20:37' prior: 50358486!
    bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 3/10/2018 22:21:11' prior: 50358517!
                   topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 3/10/2018 22:21:32' prior: 50358544!
                       topRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topRight corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (x @ (w - y - 1)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!ColorForm methodsFor: 'accessing' stamp: 'jmv 3/10/2018 22:09:40' prior: 50358570!
            colors: colorList
	"Set my color palette to the given collection."

	| colorArray colorCount newColors |
	colorList ifNil: [
		colors _ cachedDepth _ cachedColormap _ nil.
		^ self].

	colorArray _ colorList asArray.
	colorCount _ colorArray size.
	newColors _ Array new: (1 bitShift: self depth).
	1 to: newColors size do: [:i |
		i <= colorCount
			ifTrue: [newColors at: i put: (colorArray at: i)]
			ifFalse: [newColors at: i put: `Color transparent` ]].

	colors _ newColors.
	cachedDepth _ nil.
	cachedColormap _ nil.
! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 3/12/2018 17:58:56' prior: 50383943!
            mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: `0@0`
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = `Color white` ifTrue: [`Color transparent`] ifFalse: [c]].
	f colors: map.
	^ f! !
!ColorForm class methodsFor: 'instance creation' stamp: 'jmv 3/10/2018 22:09:53' prior: 50358658!
                         grayScaleAndTransparentExtent: aPoint
"Native depth"
	"Answer a ColorForm for storing 8bpp gray scale. (do not include any slot for transparent)"

	| grays result |
	result _ self extent: aPoint depth: (Smalltalk isLittleEndian ifTrue: [ -8 ] ifFalse: [ 8 ]).
	grays _ (0 to: 255) collect: [ :brightness | Color gray: brightness asFloat / 255.0].
	grays at: 1 put: `Color transparent`.
	result colors: grays.
	^result! !
!Cursor methodsFor: 'converting' stamp: 'jmv 3/10/2018 21:28:10' prior: 50358674!
         asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: self fillColor: `Color black` at: offset negated.
	^ form offset: offset! !
!CursorWithMask methodsFor: 'converting' stamp: 'jmv 3/10/2018 21:28:27' prior: 50358682!
       asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: maskForm fillColor: `Color white`.
	form fillShape: self fillColor: `Color black` at: offset negated.
	^ form offset: offset! !
!BMPReadWriter methodsFor: 'reading' stamp: 'jmv 3/10/2018 22:17:39' prior: 50358708!
                       readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount := (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ `Array with: Color white with: Color black`].
		"default gray-scale color map"
		maxLevel := (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors := Array new: colorCount.
	1 to: colorCount do: [:i |
		b := ccStream next.
		g := ccStream next.
		r := ccStream next.
		ccStream next. "skip reserved"
		colors at: i put: (Color r: r g: g b: b range: 255)].
	^ colors
! !
!BitBlt methodsFor: 'accessing' stamp: 'jmv 3/10/2018 21:25:25' prior: 50358743!
          fillColor
	"Return the current fill color as a Color.  
	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."

	halftoneForm ifNil: [^ `Color black` ].
	^ Color colorFromPixelValue: halftoneForm first depth: destForm depth! !
!GrafPort methodsFor: 'private' stamp: 'jmv 3/10/2018 22:12:11' prior: 50358991!
         setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: `Color transparent`).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			Preferences subPixelRenderFonts and: [ foregroundColor = `Color black` or: [ 
				Preferences subPixelRenderColorFonts and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= `Color black` or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preferences properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = `Color black` ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 3/10/2018 21:46:43' prior: 50359069!
            newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor isAnyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor isAnyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 3/10/2018 21:32:21' prior: 50359105!
                makeBoldGlyphs
	"Make a bold set of glyphs with same widths by ORing 1 bit to the right
		(requires at least 1 pixel of intercharacter space)"
	| g bonkForm |
	g _ glyphs copy.
	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.
	self bonk: g with: bonkForm.
	glyphs depth = 1 ifTrue: [
		g copyBits: g boundingBox from: g at: (1@0)
			clippingBox: g boundingBox rule: Form under ]
		ifFalse: [
			0 to: g width - 2 do: [ :x | 0 to: g height-1 do: [ :y |
				(glyphs colorAt:  x@y) = `Color white` ifFalse: [
					g colorAt: x+1@y put: 
						((glyphs colorAt: x+1@y) = `Color white`
							ifTrue: [glyphs colorAt:  x@y]
							ifFalse: [`Color black`])]]]].
	glyphs _ g.
	self isSynthetic: true! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 3/10/2018 21:40:06' prior: 50359130!
              makeControlCharsVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character space).
	glyph border: glyph boundingBox width: 1 fillColor: `Color blue`.
	self glyphAt: (Character numericValue: 134) put: glyph.
	
	"Keep tab(9), lf(10), cr(13) and space(32) transparent or whatever the user chose"
	#(0 1 2 3 4 5 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27)
		do: [ :ascii |
			characterToGlyphMap at: ascii + 1 put: 134 ]! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 3/10/2018 21:40:54' prior: 50371941!
          makeCrVisible
	| glyph |
	glyph _ self glyphAt: (Character numericValue: 182).
	glyph border: glyph boundingBox width: 1 fillColor: `Color blue`.
"	glyph _ glyph reverse."
	self glyphAt: Character cr put: glyph! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 3/10/2018 21:40:59' prior: 50371958!
                        makeLfVisible
	| glyph |
	glyph _ self glyphAt: (Character numericValue: 163).
	glyph border: glyph boundingBox width: 1 fillColor: `Color blue`.
"	glyph _ glyph reverse."
	self glyphAt: Character lf put: glyph! !
!Morph methodsFor: 'accessing' stamp: 'jmv 3/10/2018 21:38:27' prior: 50359171!
                          color

	^ `Color blue`! !
!Morph methodsFor: 'drawing' stamp: 'jmv 3/10/2018 21:38:33' prior: 50359175!
                        drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: self morphLocalBounds
		color: `Color blue`! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 21:56:39' prior: 50359185!
                         defaultColor
	^ `Color orange`! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 21:45:32' prior: 50359189!
                             defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ `Color gray`! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 20:58:35' prior: 50359195!
                               defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ `Color
		r: 0.861
		g: 1.0
		b: 0.722`! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 20:58:44' prior: 50359202!
     defaultColor
	"answer the default color/fill style for the receiver"
	^ `Color
		r: 0.8
		g: 1.0
		b: 0.6`! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 3/10/2018 22:02:53' prior: 50359209!
                          findWindow: evt
	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."
	| menu expanded collapsed nakedMorphs |
	menu _ MenuMorph new.
	expanded _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed not ].
	collapsed _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed ].
	nakedMorphs _ self submorphsSatisfying: [ :m |
		(m is: #SystemWindow) not ].
	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) ifTrue: [ ^ Smalltalk beep ].
	(expanded asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #activateAndForceLabelToShow.
		w canDiscardEdits ifFalse: [ menu lastItem color: `Color red` ]].
	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) ifFalse: [ menu addLine ].
	(collapsed asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #expand.
		w canDiscardEdits ifFalse: [ menu lastItem color: `Color red` ]].
	nakedMorphs isEmpty ifFalse: [ menu addLine ].
	(nakedMorphs asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #comeToFrontAndAddHalo ].
	menu addTitle: 'find window'.
	menu popUpInWorld: self! !
!EllipseMorph methodsFor: 'visual properties' stamp: 'jmv 3/10/2018 22:24:29' prior: 50359263!
                 defaultColor
	"Return the default fill style for the receiver"
	^ `Color yellow`! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 21:53:56' prior: 50359269!
              defaultColor
	"answer the default color/fill style for the receiver"
	^ `Color lightGray`! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 3/10/2018 21:23:14' prior: 50359316!
      iconColor

	^ self isPressed
		ifTrue: [ `Color gray: 0.75` ]
		ifFalse: [
			self mouseIsOver
				ifTrue: [ `Color gray: 0.75` ]
				ifFalse: [ `Color white` ]].! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 3/12/2018 17:59:10' prior: 50384461!
                       example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: `Color lightRed`.
	b2 color: `Color lightRed`.
	b3 color: `Color lightRed`.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: `120@35`.
	^ row! !
!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 3/10/2018 22:03:53' prior: 50359348!
                      drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"


	| bw bc |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"


	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ `Color tan` ]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ `Color red` ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ `Color red` ]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: `Color white` ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/10/2018 22:23:04' prior: 50359384!
                    defaultColor
	"answer the default color/fill style for the receiver"
	^ `Color white`! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 3/10/2018 21:32:46' prior: 50359390!
                     setWindowColor: incomingColor
	| existingColor aColor |
	incomingColor ifNil: [^ self].  "it happens"
	aColor _ incomingColor asNontranslucentColor.
	aColor = `Color black` ifTrue: [^ self].
	existingColor _ self widgetsColor.
	existingColor ifNil: [^ Smalltalk beep].
	self widgetsColor: aColor.
	self redrawNeeded! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 3/10/2018 22:08:36' prior: 50375583!
                              buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Package Name');
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' File Name');
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: self buildButtonPane fixedHeight: Theme current buttonPaneHeight;
		addAdjusterAndMorph: summary fixedHeight: 60;
		addAdjusterAndMorph: description proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.15.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 3/10/2018 22:09:02' prior: 50359479!
                 buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	requirements color: Theme current textPane.
		
	deleteReqButton := PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete'.
	deleteReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newColumn.
	buttonLayout addMorph: deleteReqButton 
					layoutSpec: (LayoutSpec 
										proportionalWidth: 1.0 
										proportionalHeight: 1.0
										minorDirectionPadding: #top);
					color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.9 
							proportionalHeight: 1.0 
							minorDirectionPadding: #left);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.1 
							proportionalHeight: 1.0 
							minorDirectionPadding: #right);
		color: `Color transparent`;
		yourself
		! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 3/10/2018 20:51:37' prior: 50359530!
     decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		`Color tan`.							"no sends to super. there is an override in some subclass"
		`Color red`.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		`Color red`.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		`Color red muchLighter`.			"doesn't have sub; has super but doesn't call it"
		`Color r: 0.94 g: 0.823 b: 0.673`.		"has sub; has super but doesn't call it"
		`Color green muchLighter`.			"doesn't have sub; has super and callsl it"
		`Color blue muchLighter`.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 3/10/2018 22:07:53' prior: 50359583!
                  buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 3/10/2018 22:13:32' prior: 50359681!
buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: `Color transparent`.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!TestRunnerWindow methodsFor: 'constants' stamp: 'jmv 3/10/2018 21:52:20' prior: 50359704!
                 runButtonColor
	^ `Color green lighter duller`! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 22:22:59' prior: 50359709!
              defaultColor
	^ `Color white`! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 21:46:24' prior: 50359713!
                               initialize
	super initialize.
	progressColor _ `Color gray`.
	value _ 0.0! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 3/10/2018 22:13:23' prior: 50359718!
                            addStayUpIcons
	| closeBox pinBox w |
	Preferences optionalButtons ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon; color: `Color transparent`.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon; color: `Color transparent`.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: 19);
			color: `Color transparent`;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleLikeMorph new color: `Color transparent`) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 3/12/2018 17:59:17' prior: 50384963!
    displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: `Color veryDarkGray`.
		self addMorphBack: feedbackMorph lock position: `0@ -20`.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 17:59:29' prior: 50385043!
                       drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (`0@0` extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: `Color veryLightGray` ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 21:45:20' prior: 50359842!
           defaultBorderColor
	^ `Color gray`! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 3/12/2018 17:59:34' prior: 50385107!
        drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: `0@0`
		color: `Color black`! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/10/2018 22:12:19' prior: 50359855!
   color: aColor
        super color: aColor.
        (image depth = 1 and: [aColor is: #Color]) ifTrue: [
                image colors: {`Color transparent`. aColor}.
                self redrawNeeded]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/10/2018 21:30:52' prior: 50359864!
                             isEnabled: aBoolean

	isEnabled = aBoolean ifTrue: [^ self].
	isEnabled _ aBoolean.
	self color: (aBoolean ifTrue: [`Color black`] ifFalse: [`Color gray`]).
! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 3/10/2018 21:22:24' prior: 50359872!
         offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: `(Color gray: 0.9)`
			borderWidth: 1 borderColor: `Color black`.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 3/10/2018 21:22:55' prior: 50359884!
     onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: `Color gray: 0.8`
			borderWidth: 1 borderColor: `Color black`;
		fillRectangle: (form boundingBox insetBy: 2) color: `Color black`.
	^form! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 3/10/2018 22:12:27' prior: 50359898!
   adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	doAdoptWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: paneColor) ]
		ifFalse: [ self color: `Color transparent` ]! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 21:46:16' prior: 50359908!
                       defaultColor
	^ `Color gray`! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 3/10/2018 22:01:15' prior: 50359912!
                            initializedInstance
	"Answer a row by default so the 'new morph' menu doesn't fail..."
	^self newRow color: `(Color red alpha: 0.2)`! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 3/10/2018 22:01:26' prior: 50360383!
                             launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row _ LayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 22:16:44' prior: 50360407!
        defaultColor
	^ `Color veryLightGray`! !
!HaloHandleMorph class methodsFor: 'accessing' stamp: 'jmv 3/10/2018 22:21:42' prior: 50360412!
                       circleForm: extent
	"
	CircleForm _ nil
	"
	| r d l bw center |
	(CircleForm isNil or: [ CircleForm extent ~= extent ]) ifTrue: [
		center _ extent -1 * 0.5.
		r _ center r * 0.75.
		bw _ 1.3.
		CircleForm _ Form extent: extent depth: 32.
		0 to: extent y - 1 do: [ :y |
			0 to: extent x - 1 do: [ :x |
				d _ (x@y - center) r.
				l _ (r - d max: 0.0) min: bw.
				CircleForm
					colorAt: x @ y
					put: (`Color white` alpha: (l / bw))
					]].
		].
	^CircleForm! !
!HaloMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 20:58:21' prior: 50360430!
                defaultColor
	"answer the default color/fill style for the receiver"
	^ `Color
		r: 0.6
		g: 0.8
		b: 1.0`! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 3/10/2018 21:30:16' prior: 50360470!
addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition nameBackground |
	nameBackground _ RectangleLikeMorph new
		color: ((target is: #SystemWindow) ifTrue: [target windowColor] ifFalse: [`Color lightBlue alpha: 0.9`]).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: `Color black`.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	namePosition _ haloBox width - nameMorph morphWidth // 2 @ (haloBox height).
	self addMorph: nameBackground position: namePosition - 2.
	self addMorph: nameMorph position: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 3/10/2018 21:38:00' prior: 50360493!
         doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: `Color lightBlue`]
		ifFalse: [rotHandle color: `Color blue`].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPositionInWorld: evt eventPosition - (rotHandle morphExtent // 2)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 3/10/2018 21:53:51' prior: 50360519!
                       setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint:  (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [ `Color red muchLighter` ]
		ifTrue: [ `Color lightGray` ].
	dismissHandle color: colorToUse! !
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 21:30:39' prior: 50361238!
    initialize
	super initialize.
	self color: `Color black`.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 3/10/2018 21:44:18' prior: 50360543!
          debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self textComposition lines do: [ :line |
		aCanvas
			frameRectangle: line rectangle
			borderWidth: 1
			color: `Color brown` ]
! !
!ResizeMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 17:59:45' prior: 50385704!
                        initialize
	super initialize.
	extent _ `400@300`.
	color _ `Color white`.
	grid _ `8@6`.
	gridLineWidth _ 2.
	gridColor _ `Color black`.
	selectionColor _ `Color red`! !
!ResizeMorph methodsFor: 'events' stamp: 'jmv 3/10/2018 21:31:55' prior: 50360561!
  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: `Color black`;
		color: `Color transparent`;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 3/10/2018 20:58:28' prior: 50360573!
               defaultColor

	^ `Color r: 1.0 g: 1.0 b: 0.7`! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 3/10/2018 21:30:31' prior: 50360578!
                        drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		textComposition: textComposition
		bounds: (r insetBy: 4)
		color: `Color black`
		selectionColor: (Theme current textHighlightFocused: false)! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/10/2018 21:48:37' prior: 50360715!
                               experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: `Color green`.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: `Color gray`.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 3/12/2018 17:59:57' prior: 50385876!
                        drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > `50@50`
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: `Color red`
		borderWidth: w
		borderColor: `Color yellow`.
	self line: r topLeft to: r bottomRight-w width: w color: `Color yellow`.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: `Color yellow`! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/12/2018 18:00:11' prior: 50385894!
                     drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = `Color black` ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: `Color black`.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = `Color white` ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: `Color white`.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + `0@2`
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + `0@1`
		font: fontOrNil
		color: aColor! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/10/2018 22:06:13' prior: 50360788!
                               fillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	aColor isTransparent ifFalse: [
		self 
			frameAndFillRectangle: aRectangle
			fillColor: aColor
			borderWidth: 0
			borderColor: `Color transparent` ]! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 3/10/2018 21:45:27' prior: 50360798!
                            reverseRectangleBorder: r borderWidth: borderWidth
	"
	Display getCanvas
		reverseRectangleBorder: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	port
		sourceForm: nil;
		fillColor: `Color gray`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 3/10/2018 22:06:54' prior: 50360813!
                         setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor |
	paintColor _ aColor ifNil: [ `Color transparent` ].
	(paintColor is: #Color) ifFalse: [
		^ self error: 'Cannot install color' ].

	"Okay, so paintColor really *is* a color"
	port sourceForm: nil.
	(paintColor isOpaque or: [ self depth < 32]) ifTrue: [
		port fillColor: paintColor.
		port combinationRule: Form paint.
		^ self ].

	"BitBlt setup for alpha mapped transfer"
	port fillColor: paintColor.
	port combinationRule: Form blend! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 3/12/2018 18:00:43' prior: 50386009!
                        steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (`0@0` extent: extent)
				color: `Color gray: 0.4`
				radius: 4.
			canvas
				roundRect: (`1@1` extent: extent-2)
				color: `Color white`
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 3/10/2018 21:21:27' prior: 50360866!
            buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	 (self buildArrowOfDirection: #up size: 120) display
	"

	| resizeFactor resizedForm f e c bottomMargin topMargin |
	resizeFactor _ 4.
	e _ finalSizeInteger@finalSizeInteger*resizeFactor.
	f _ Form extent: e depth: 32.
	c _ `Color gray: 0.5`.
	topMargin _ finalSizeInteger * 3//4.
	bottomMargin _ finalSizeInteger * 4//4.
	0 to: e y-1-bottomMargin do: [ :y |
		0 to: e x -1 do: [ :x |
			(e x / 2 - 1 - x) abs * 2 + topMargin < y ifTrue: [
				f colorAt: x@y put: c
			]
		]
	].
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 3/12/2018 18:01:37' prior: 50386028!
               buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - `1@2`.
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = `Color r: 0.0 g: 0.0 b: 1.0`
				ifTrue: [ color _ `Color transparent` ]
				ifFalse: [
					borderSpec = `Color r: 1.0 g: 0.0 b: 0.0`
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [`Color white`]
								ifFalse: [`Color black`].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 20:59:15' prior: 50360951!
        background
	^ `Color r: 0.7 g: 0.72 b: 0.83`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 22:13:58' prior: 50360955!
   buttonColorFrom: aColor
	^ Display depth <= 8
			ifTrue: [ `Color transparent` ]
			ifFalse: [ aColor paler ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:23:25' prior: 50360961!
  buttonLabel
	^ `Color gray: 0.18`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 22:03:59' prior: 50360965!
              errorColor
	^ `Color red lighter`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 22:24:39' prior: 50360969!
              failureColor
	^ `Color yellow lighter`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:23:34' prior: 50360973!
         scrollbarButtonColor
	^ `Color gray: 0.95`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 22:23:27' prior: 50360977!
     scrollbarColor
	^ `Color white`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 22:23:32' prior: 50360981!
                scrollbarSliderShadowColor
	^ `Color white`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:52:43' prior: 50360985!
    successColor
	^ `Color green lighter`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:34:04' prior: 50360989!
          text
	^ `Color black`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:34:14' prior: 50360993!
                          textCursor
	^ Display depth <= 2
		ifTrue: [ `Color black` ]
		ifFalse: [ self text ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:19:22' prior: 50360999!
                          textHighlight
	"A nice light blue."
	"
	^ Color r: 0.71 g: 0.835 b: 1.0
	^ Color hue: 214 chroma: 0.29 luminance: 0.816
	"
	^ `Color hue: 204 chroma: 0.29 luminance: 0.77`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:24:07' prior: 50361007!
    textHighlightFocused: focused
	"A nice light blue."
	| textHighlight |
	Display depth = 1 ifTrue: [^ `Color veryLightGray` ].
	Display depth = 2 ifTrue: [^ `Color gray: 0.87` ].
	textHighlight _ self textHighlight.
	^focused
		ifTrue: [ textHighlight ]
		ifFalse: [ self unfocusedTextHighlightFrom: textHighlight ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/10/2018 21:24:18' prior: 50361020!
                     windowLabel
	^ `Color gray: 0.3`! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 3/10/2018 20:42:33' prior: 50361024!
          menu
	Display depth <= 2 ifTrue: [^ `Color white` ].
	^ `Color r: 0.75 g: 0.75 b: 0.75 alpha: 0.93`! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 3/10/2018 22:16:53' prior: 50361030!
       menuHighlight
	^ Display depth < 8
		ifTrue: [ `Color veryLightGray` ]
		ifFalse: [ self textHighlight ]! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 3/10/2018 21:33:40' prior: 50361036!
  menuText
	^ `Color black`! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 3/10/2018 21:47:13' prior: 50361040!
                 menuTitleBar
	Display depth = 1 ifTrue: [^ `Color white`].
	Display depth = 2 ifTrue: [^ `Color gray`].
	^ self menu darker! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 20:59:31' prior: 50361047!
               browser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color r: 0.5 g: 0.7 b: 0.4`]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:20:34' prior: 50361054!
                         debugger
	^ `Color h: 0.0 s: 0.6 v: 0.7`! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 20:59:08' prior: 50361058!
  defaultWindowColor
	^ `Color lightGray`! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 22:05:56' prior: 50361062!
   fileContentsBrowser
	^ `Color tan duller`! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 20:59:58' prior: 50361066!
 fileList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color r: 0.7 g: 0.55 b: 0.7` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:00:04' prior: 50361073!
                      messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color r: 0.53 g: 0.77 b: 0.382` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:00:12' prior: 50361080!
              messageSet
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color r: 0.45 g: 0.6 b: 0.85` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 22:23:19' prior: 50361087!
                   object
	^ `Color white duller`! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:00:19' prior: 50361091!
            packageList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color r: 0.63 g: 0.47 b: 0.08` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:00:28' prior: 50361098!
                 testRunner
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `(Color r: 0.650 g: 0.753 b: 0.976) duller` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:23:40' prior: 50361105!
      textEditor
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color gray: 0.6` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:01:02' prior: 50361111!
transcript
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color r: 0.8 g: 0.6 b: 0.3` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:01:08' prior: 50361118!
                     versionsBrowser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `(Color r: 0.869 g: 0.753 b: 1.0) duller` ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/10/2018 21:20:41' prior: 50361125!
   workspace
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color h: 60.0 s: 0.73 v: 0.72` ]! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 3/10/2018 20:59:00' prior: 50361132!
                 acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ `Color r: 0.2 g: 0.6 b: 0.1` ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 3/10/2018 20:59:50' prior: 50361140!
                   cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ `Color r: 0.8 g: 0.2 b: 0.2` ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 3/10/2018 22:23:38' prior: 50361148!
                   textPane
	^ `Color white`! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3273-UseALotOfLiteralColors-JuanVuletich-2018Mar12-17h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3272] on 12 March 2018 at 6:05:59 pm'!
!ChangeListElement methodsFor: 'testing' stamp: 'jmv 3/12/2018 18:05:54'!
                 isDoIt

	^false! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3274-ChangeListElement-isDoit-JuanVuletich-2018Mar12-18h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3274] on 12 March 2018 at 7:21:38 pm'!
!Color methodsFor: 'other' stamp: 'jmv 3/12/2018 19:20:35' prior: 50356766!
                       colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color.
	Return nil if named color support is not present"

	^ ColorNamesDict ifNotNil: [ :dict|
		dict keyAtValue: self ifAbsent: [nil]]! !
!Color methodsFor: 'selection' stamp: 'jmv 3/12/2018 19:15:42' prior: 50353879!
                isGreen
	"Am I considered Green ?"

	^self green > (self blue + 0.3)
		and: [self green > (self red + 0.3)]! !
!Color methodsFor: 'selection' stamp: 'jmv 3/12/2018 19:16:29' prior: 50353894!
 isMagenta
	"Am I considered Magenta ?"

	^self green < 0.05 
		and: [(self red min: self blue) > 0.4]					
			and: [(self red - self blue) abs < 0.3]! !
!Color methodsFor: 'selection' stamp: 'jmv 3/12/2018 19:17:05' prior: 50353930!
                       isYellow
	"Am I considered Yellow ?"

	^self blue < 0.1
		and: [(self red min: self green) > 0.5]					
			and: [(self red - self green) abs < 0.2]! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:48:04' prior: 50354973!
                 black
	^`Color r: 0 g: 0 b: 0`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:01:23' prior: 50354977!
     blue
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.012 g: 0.263 b: 0.875`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:59:10' prior: 50354985!
   brown
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.396 g: 0.216 b: 0.0`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:49:47' prior: 50354989!
    cyan
	^ `Color r: 0 g: 1.0 b: 1.0`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:03:42' prior: 50354997!
 darkGray
	^ `Color r: 0.375 g: 0.375 b: 0.375`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:03:57' prior: 50355017!
                     gray
	^ `Color r: 0.5 g: 0.5 b: 0.5`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:02:25' prior: 50355021!
                               green
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.082 g: 0.690 b: 0.102`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:57:12' prior: 50355041!
  lightBlue
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.584 g: 0.816 b: 0.988`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:47:23' prior: 50355045!
                              lightBrown
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.678 g: 0.506 b: 0.314`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:40:26' prior: 50355049!
                             lightCyan
	"Override traditional names existing in extended XKCD naming"
	^ `Color r: 0.674 g: 1.0 b: 0.988`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:04:01' prior: 50355053!
                       lightGray
	^ `Color r: 0.625 g: 0.625 b: 0.625`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:54:54' prior: 50355057!
                    lightGreen
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.588 g: 0.976 b: 0.482`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:40:33' prior: 50355061!
                             lightMagenta
	"Override traditional names existing in extended XKCD naming"
	^ `Color r: 0.98 g: 0.372 b: 0.969`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:40:22' prior: 50355065!
                   lightOrange
	"Override traditional names existing in extended XKCD naming"
	^ `Color r: 0.992 g: 0.667 b: 0.283`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:40:30' prior: 50355077!
                   lightRed
	"Override traditional names existing in extended XKCD naming"
	^ `Color r: 1.0 g: 0.279 b: 0.298`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:40:18' prior: 50355081!
                        lightYellow
	"Override traditional names existing in extended XKCD naming"
	^ `Color r: 1.0 g: 0.996 b: 0.478`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:53:42' prior: 50355097!
                     magenta
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.760 g: 0.0 b: 0.471`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:55:57' prior: 50355125!
  orange
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.976 g: 0.451 b: 0.024`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:00:11' prior: 50355141!
 pink
	"Override traditional names existing in XKCD naming"
	^ `Color r: 1.0 g: 0.506 b: 0.753`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:03:18' prior: 50355145!
     purple
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.494 g: 0.118 b: 0.612`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:58:04' prior: 50355149!
 red
	"Override traditional names existing in XKCD naming"
	^ `Color r: 0.898 g: 0 b: 0`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:05:22' prior: 50355169!
            tan
	^ `Color r: 0.820 g: 0.698 b: 0.435`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:04:45' prior: 50355177!
                          transparent
	^ `TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:04:05' prior: 50355185!
  veryDarkGray
	^ `Color r: 0.25 g: 0.25 b: 0.25`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:04:10' prior: 50355189!
                    veryLightGray
	^ `Color r: 0.75 g: 0.75 b: 0.75`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:05:08' prior: 50355194!
                   veryVeryDarkGray
	^ `Color r: 0.125 g: 0.125 b: 0.125`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:04:18' prior: 50355199!
             veryVeryLightGray
	^ `Color r: 0.875 g: 0.875 b: 0.875`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:04:24' prior: 50355208!
            white
	^ `Color r: 1.0 g: 1.0 b: 1.0`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 18:52:36' prior: 50355212!
                              yellow
	"Override traditional names existing in XKCD naming"
	^ `Color r: 1.0 g: 1.0 b: 0.078`! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 5/12/2016 14:58' prior: 50356475!
 releaseClassCachedState
	"
	Color releaseClassCachedState
	"
	CachedColormaps _ nil. 		"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	ColorNamesDict _ nil.
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !

Color class removeSelector: #aqua!

Color class removeSelector: #aqua!

Color class removeSelector: #beige!

Color class removeSelector: #beige!

Color class removeSelector: #blueColorDict!

Color class removeSelector: #blueColorDict!

Color class removeSelector: #blueColorDict:!

Color class removeSelector: #blueColorDict:!

Color class removeSelector: #blueGreenColorDict!

Color class removeSelector: #blueGreenColorDict!

Color class removeSelector: #blueGreenColorDict:!

Color class removeSelector: #blueGreenColorDict:!

Color class removeSelector: #brightColorDict!

Color class removeSelector: #brightColorDict!

Color class removeSelector: #brightColorDict:!

Color class removeSelector: #brightColorDict:!

Color class removeSelector: #brightGreen!

Color class removeSelector: #brightGreen!

Color class removeSelector: #brownColorDict!

Color class removeSelector: #brownColorDict!

Color class removeSelector: #brownColorDict:!

Color class removeSelector: #brownColorDict:!

Color class removeSelector: #colorNames!

Color class removeSelector: #colorNames!

Color class removeSelector: #colorNamesDict!

Color class removeSelector: #colorNamesDict!

Color class removeSelector: #darkBlue!

Color class removeSelector: #darkBlue!

Color class removeSelector: #darkColorDict!

Color class removeSelector: #darkColorDict!

Color class removeSelector: #darkColorDict:!

Color class removeSelector: #darkColorDict:!

Color class removeSelector: #darkGreen!

Color class removeSelector: #darkGreen!

Color class removeSelector: #darkPink!

Color class removeSelector: #darkPink!

Color class removeSelector: #darkPurple!

Color class removeSelector: #darkPurple!

Color class removeSelector: #defaultColorNamesDictionary!

Color class removeSelector: #defaultColorNamesDictionary!

Color class removeSelector: #doesNotUnderstand:!

Color class removeSelector: #doesNotUnderstand:!

Color class removeSelector: #exactColorNamed:!

Color class removeSelector: #exactColorNamed:!

Color class removeSelector: #forestGreen!

Color class removeSelector: #forestGreen!

Color class removeSelector: #fromString:!

Color class removeSelector: #fromString:!

Color class removeSelector: #grayColorDict:!

Color class removeSelector: #grayColorDict:!

Color class removeSelector: #greenColorDict!

Color class removeSelector: #greenColorDict!

Color class removeSelector: #greenColorDict:!

Color class removeSelector: #greenColorDict:!

Color class removeSelector: #grey!

Color class removeSelector: #grey!

Color class removeSelector: #greyColorDict!

Color class removeSelector: #greyColorDict!

Color class removeSelector: #greyColorDict:!

Color class removeSelector: #greyColorDict:!

Color class removeSelector: #hotPink!

Color class removeSelector: #hotPink!

Color class removeSelector: #indigo!

Color class removeSelector: #indigo!

Color class removeSelector: #lavender!

Color class removeSelector: #lavender!

Color class removeSelector: #lightColorDict!

Color class removeSelector: #lightColorDict!

Color class removeSelector: #lightColorDict:!

Color class removeSelector: #lightColorDict:!

Color class removeSelector: #lightPink!

Color class removeSelector: #lightPink!

Color class removeSelector: #lightPurple!

Color class removeSelector: #lightPurple!

Color class removeSelector: #lilac!

Color class removeSelector: #lilac!

Color class removeSelector: #lime!

Color class removeSelector: #lime!

Color class removeSelector: #limeGreen!

Color class removeSelector: #limeGreen!

Color class removeSelector: #maroon!

Color class removeSelector: #maroon!

Color class removeSelector: #mauve!

Color class removeSelector: #mauve!

Color class removeSelector: #mustard!

Color class removeSelector: #mustard!

Color class removeSelector: #navyBlue!

Color class removeSelector: #navyBlue!

Color class removeSelector: #olive!

Color class removeSelector: #olive!

Color class removeSelector: #oliveGreen!

Color class removeSelector: #oliveGreen!

Color class removeSelector: #orangeColorDict!

Color class removeSelector: #orangeColorDict!

Color class removeSelector: #orangeColorDict:!

Color class removeSelector: #orangeColorDict:!

Color class removeSelector: #paleGreen!

Color class removeSelector: #paleGreen!

Color class removeSelector: #pastelColorDict!

Color class removeSelector: #pastelColorDict!

Color class removeSelector: #pastelColorDict:!

Color class removeSelector: #pastelColorDict:!

Color class removeSelector: #peach!

Color class removeSelector: #peach!

Color class removeSelector: #periwinkle!

Color class removeSelector: #periwinkle!

Color class removeSelector: #pinkColorDict!

Color class removeSelector: #pinkColorDict!

Color class removeSelector: #pinkColorDict:!

Color class removeSelector: #pinkColorDict:!

Color class removeSelector: #purpleColorDict!

Color class removeSelector: #purpleColorDict!

Color class removeSelector: #purpleColorDict:!

Color class removeSelector: #purpleColorDict:!

Color class removeSelector: #redColorDict!

Color class removeSelector: #redColorDict!

Color class removeSelector: #redColorDict:!

Color class removeSelector: #redColorDict:!

Color class removeSelector: #royalBlue!

Color class removeSelector: #royalBlue!

Color class removeSelector: #salmon!

Color class removeSelector: #salmon!

Color class removeSelector: #saturatedColorDict!

Color class removeSelector: #saturatedColorDict!

Color class removeSelector: #saturatedColorDict:!

Color class removeSelector: #saturatedColorDict:!

Color class removeSelector: #seaGreen!

Color class removeSelector: #seaGreen!

Color class removeSelector: #setColorNamesDict:!

Color class removeSelector: #setColorNamesDict:!

Color class removeSelector: #skyBlue!

Color class removeSelector: #skyBlue!

Color class removeSelector: #teal!

Color class removeSelector: #teal!

Color class removeSelector: #traditionalColorNamesDictionary!

Color class removeSelector: #traditionalColorNamesDictionary!

Color class removeSelector: #turquoise!

Color class removeSelector: #turquoise!

Color class removeSelector: #violet!

Color class removeSelector: #violet!

Color class removeSelector: #xkcdFirst48ColorNamesDictionary!

Color class removeSelector: #xkcdFirst48ColorNamesDictionary!

Color class removeSelector: #yellowColorDict!

Color class removeSelector: #yellowColorDict!

Color class removeSelector: #yellowColorDict:!

Color class removeSelector: #yellowColorDict:!

Color removeSelector: #closestAssocFrom:!

Color removeSelector: #closestAssocFrom:!

Color removeSelector: #closestColor!

Color removeSelector: #closestColor!

Color removeSelector: #closestColorAssociation!

Color removeSelector: #closestColorAssociation!

Color removeSelector: #closestColorFrom:!

Color removeSelector: #closestColorFrom:!

Color removeSelector: #closestColorName!

Color removeSelector: #closestColorName!

Color removeSelector: #closestNameFrom:!

Color removeSelector: #closestNameFrom:!

Color removeSelector: #isBlueGreen!

Color removeSelector: #isBlueGreen!

Color removeSelector: #isBright!

Color removeSelector: #isBright!

Color removeSelector: #isBrown!

Color removeSelector: #isBrown!

Color removeSelector: #isDark!

Color removeSelector: #isDark!

Color removeSelector: #isGray!

Color removeSelector: #isGray!

Color removeSelector: #isGrey!

Color removeSelector: #isGrey!

Color removeSelector: #isLight!

Color removeSelector: #isLight!

Color removeSelector: #isOrange!

Color removeSelector: #isOrange!

Color removeSelector: #isPastel!

Color removeSelector: #isPastel!

Color removeSelector: #isPink!

Color removeSelector: #isPink!

Color removeSelector: #isSaturated!

Color removeSelector: #isSaturated!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3275-MakeNamedColorsOptional-JuanVuletich-2018Mar12-18h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3275] on 12 March 2018 at 8:29:55 pm'!
!Color class methodsFor: 'instance creation' stamp: 'jmv 3/12/2018 19:29:16'!
   fromHexString: aString
	"For HTML color spec: #FFCCAA.
	See http://www.w3schools.com/cssref/css_colors_legal.asp"
	"
	Color fromHexString: '#FFCCAA'.
	"
	(aString size = 7 and: [ aString first = $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU _ aString asUppercase.
		red _ ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green _ ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue _ ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].
	^ nil! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:28:53' prior: 50389025!
      black
	"Override traditional names existing in XKCD naming"
	^`Color fromHexString: '#000000'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:30:14' prior: 50389029!
     blue
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#0343df'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:31:13' prior: 50389035!
     brown
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#653700'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:28:59' prior: 50389041!
    cyan
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#00ffff'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:33:50' prior: 50389055!
     green
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#15b01a'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 19:34:21' prior: 50389061!
    lightBlue
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#95d0fc'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:12:45' prior: 50389068!
lightBrown
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#ad8150'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:13:44' prior: 50389087!
                               lightGreen
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#96f97b'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:14:56' prior: 50389122!
                               magenta
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#c20078'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:15:20' prior: 50389128!
  orange
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#f97306'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:16:35' prior: 50389134!
   pink
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#ff81c0'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:16:53' prior: 50389140!
     purple
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#7e1e9c'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:17:13' prior: 50389146!
   red
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#e50000'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:28:47' prior: 50389152!
      tan
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#d1b26f'`! !
!Color class methodsFor: 'named colors' stamp: 'jmv 3/12/2018 20:18:33' prior: 50389187!
      yellow
	"Override traditional names existing in XKCD naming"
	^ `Color fromHexString: '#ffff14'`! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3276-TweaksToColor-JuanVuletich-2018Mar12-20h27m-jmv.1.cs.st----!

----SNAPSHOT----#(13 March 2018 3:20:58.566479 pm) Cuis5.0-3276-v3.image priorSource: 1621654!

----QUIT----#(13 March 2018 3:21:14.516639 pm) Cuis5.0-3276-v3.image priorSource: 1853479!

----STARTUP----#(13 March 2018 4:40:23.986394 pm) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3276-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3276] on 13 March 2018 at 3:37:57 pm'!
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 3/13/2018 15:37:34'!
 atEnd
	^ false! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3277-StdIOReadStream-atEnd-JuanVuletich-2018Mar13-15h37m-jmv.1.cs.st----!

----SNAPSHOT----#(13 March 2018 4:40:29.44499 pm) Cuis5.0-3277-v3.image priorSource: 1853575!

----QUIT----#(13 March 2018 4:40:52.239446 pm) Cuis5.0-3277-v3.image priorSource: 1854114!

----STARTUP----#(28 March 2018 9:15:50.713275 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3277-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3277] on 19 March 2018 at 3:33:10 pm'!
!Message methodsFor: 'stub creation' stamp: 'HAW 3/19/2018 15:29:03'!
                addSetterCodeOn: stream 
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ' := ';
		nextPutAll: self arguments first argumentName ! !
!Message methodsFor: 'stub creation' stamp: 'HAW 3/19/2018 15:20:08'!
                     argumentNameAt: anIndex havingNamed: alreadyNamedArguments

	| argumentName |
	
	argumentName _ (self arguments at: anIndex) argumentName.
	[alreadyNamedArguments includes: argumentName] whileTrue: [argumentName _ argumentName, anIndex asString].
	alreadyNamedArguments add: argumentName.

	^argumentName! !
!Message methodsFor: 'stub creation' stamp: 'HAW 3/19/2018 15:26:18'!
      writeMessageNameOn: aStream

	| alreadyNamedArguments |

	alreadyNamedArguments _ Set new.
	self selector keywords withIndexDo: [ :keyword :index |
		aStream nextPutAll: keyword.
		self hasArguments ifTrue: [ self writeOn: aStream argumentNameAt: index havingNamed: alreadyNamedArguments ]].
	
	! !
!Message methodsFor: 'stub creation' stamp: 'HAW 3/19/2018 15:27:23'!
               writeOn: aStream argumentNameAt: index havingNamed: alreadyNamedArguments

	| argumentName |
	
	argumentName _ self argumentNameAt: index havingNamed: alreadyNamedArguments.
	
	aStream 
		nextPutAll: ' '; 
		nextPutAll: argumentName; 
		space
	
	! !
!Message methodsFor: 'stub creation' stamp: 'HAW 3/19/2018 15:28:33' prior: 50368152!
                createStubMethodFor: aClass

	^ String streamContents: [ :stream |
		self writeMessageNameOn: stream.
		stream newLine; tab.
		self writeShouldBeImplementedOn: stream.
		(self isGetterFor: aClass) ifTrue: [ self addGetterCodeOn: stream ].
		(self isSetterFor: aClass) ifTrue: [ self addSetterCodeOn: stream ].
	]! !

Message removeSelector: #addSetterCodeOn:with:!

Message removeSelector: #addSetterCodeOn:with:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3278-autoGetterAndSetterTweaks-HernanWilkinson-2018Mar19-15h07m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3277] on 22 March 2018 at 12:42:03 pm'!
!Browser methodsFor: 'class list' stamp: 'HAW 3/22/2018 12:40:03' prior: 16791821!
classListIndex: anInteger 
	"Set anInteger to be the index of the current class selection."

	| className recent canSelectClass |

	canSelectClass _ anInteger between: 1 and: self classList size.
	selectedClassName _ canSelectClass ifTrue: [ self classList at: anInteger ].
	self setClassOrganizer.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	
	self classCommentIndicated ifFalse: [
		self editSelection: (canSelectClass
			ifTrue: [#editClass]
			ifFalse: [ metaClassIndicated | selectedSystemCategory isNil
				ifTrue: [#none]
				ifFalse: [#newClass]])].

	self selectedClass ifNotNil: [
		recent _ self class recentClasses.
		className _ self selectedClass name.
		(recent includes: className) ifTrue: [recent remove: className].
		recent addFirst: className.
		recent size > 16 ifTrue: [recent removeLast]].
	
	"We have to refresh the class list if somebody wants to select a class that does not exist anymore - Hernan"
	anInteger > self classList size ifTrue: [ self changed: #classList ].
	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged! !
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 3/22/2018 12:37:37' prior: 16919340!
                       forgetClass: aClass logged: aBool 
	"Delete the class, aClass, from the system.
	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."

	SystemOrganization removeElement: aClass name.
	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: aClass category].		
	self removeFromStartUpList: aClass.
	self removeFromShutDownList: aClass.
	self removeKey: aClass name ifAbsent: nil.
	self flushClassNameCache! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3279-ClassRemovalFix-HernanWilkinson-2018Mar22-12h07m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3277] on 22 March 2018 at 3:07:52 pm'!
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 3/22/2018 15:07:34' prior: 50389713!
               forgetClass: aClass logged: aBool 
	"Delete the class, aClass, from the system.
	Note that this doesn't do everything required to dispose of a class - to do that use Class>>removeFromSystem."

	| classCategory |
	
	"I have to keep the cateogory becuase it is nil after removing the class -Hernan"
	classCategory _ aClass category.
	
	SystemOrganization removeElement: aClass name.
	aBool ifTrue: [SystemChangeNotifier uniqueInstance classRemoved: aClass fromCategory: classCategory].		
	self removeFromStartUpList: aClass.
	self removeFromShutDownList: aClass.
	self removeKey: aClass name ifAbsent: nil.
	self flushClassNameCache! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3280-ClassRemovalFix-HernanWilkinson-2018Mar22-12h42m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3277] on 27 March 2018 at 10:42:25 am'!
!CodePackage methodsFor: 'saving' stamp: 'jmv 3/27/2018 10:31:21'!
                              writeInitializerExtensionMethods: extensionInitializers on: aStream
	"Write the call to package initialization methods in clases not defined in the
	package (usually, classes in base system that requires specific init 
	of stuff that is package extensions)"

	extensionInitializers do: [ :methodReference |
		aStream nextChunkPut: methodReference classSymbol asString, ' ' , methodReference selector asString; newLine ]! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 3/27/2018 10:20:51' prior: 16810570!
      write: classes initializersOn: aStream
	"Write the call to #initialize method of classes defined in us."

	Smalltalk hierarchySorted: classes do: [ :class |
		(class class includesSelector: #initialize) ifTrue: [
			aStream nextChunkPut: class name, ' initialize'; newLine ]]! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 3/27/2018 10:40:34' prior: 50377186!
                      writeOnStream: aStream

	| sortedClasses initExtensions |
	aStream
		nextChunkPut: ('Description ', description) printString;
		newLine.
	self writeFeatureSpecOn: aStream.
	self writeSystemCategoriesOn: aStream.
	sortedClasses _ Array streamContents: [ :strm |
		self classesInSafeOrderDo: [ :cls |
			strm nextPut: cls ]].
	self
		write: sortedClasses classDefinitionsOn: aStream;
		write: sortedClasses classCommentsOn: aStream;
		write: sortedClasses methodsOn: aStream.
	initExtensions _ OrderedCollection new.
	self
		sortedExtensionMethodsDo:  [ :methodReference |
			methodReference isValid ifTrue: [
				self writeMethod: methodReference on: aStream.
				(methodReference selector beginsWith: 'initialize') 
					ifTrue: [ initExtensions add: methodReference ]]]
		displayingProgress: 'Saving extension methods...'.
	self write: sortedClasses initializersOn: aStream.
	self writeInitializerExtensionMethods: initExtensions on: aStream! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3281-PackageExtensionsInitializers-JuanVuletich-2018Mar27-10h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3281] on 28 March 2018 at 9:05:04 am'!

Object subclass: #StackSizeWatcher
	instanceVariableNames: 'watcher timeBetweenChecks stackSizeThreashold'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

!classDefinition: #StackSizeWatcher category: #'Tools-Profiling'!
Object subclass: #StackSizeWatcher
	instanceVariableNames: 'watcher timeBetweenChecks stackSizeThreashold'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

StackSizeWatcher class
	instanceVariableNames: 'current'!

!classDefinition: 'StackSizeWatcher class' category: #'Tools-Profiling'!
StackSizeWatcher class
	instanceVariableNames: 'current'!
!ProcessBrowser methodsFor: 'initialization' stamp: 'jmv 3/28/2018 08:57:18'!
startStackSizeWatcher

	StackSizeWatcher isWatching ifFalse: [
		StackSizeWatcher startWatchingWithDefaults ]! !
!ProcessBrowser methodsFor: 'initialization' stamp: 'jmv 3/28/2018 08:56:50'!
 stopStackSizeWatcher

	StackSizeWatcher stopWatching.
	self updateProcessList! !
!ContextPart methodsFor: 'accessing' stamp: 'HAW 3/27/2018 14:02:09'!
         depthBelow

	^self depthBelow: nil! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 3/28/2018 08:55:53'!
       startStackSizeWatcher

	model startStackSizeWatcher! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 3/28/2018 08:56:08'!
                      stopStackSizeWatcher
	model stopStackSizeWatcher! !
!StackSizeWatcher methodsFor: 'assertions' stamp: 'HAW 3/27/2018 14:16:52'!
assertIsNotWatching
	
	self isNotWatching ifFalse: [ self error: 'Already watching' ].! !
!StackSizeWatcher methodsFor: 'assertions' stamp: 'HAW 3/27/2018 14:16:43'!
                          assertIsWatching
	
	self isWatching ifFalse: [ self error: 'It is not watching' ]! !
!StackSizeWatcher methodsFor: 'configuration changing' stamp: 'HAW 3/27/2018 14:21:02'!
                   changeStackSizeThresholdTo: aThreshold
	
	stackSizeThreashold _ aThreshold ! !
!StackSizeWatcher methodsFor: 'configuration changing' stamp: 'HAW 3/27/2018 14:21:17'!
                         changeTimeBetweenChecksTo: aTimeBetweenChecks
	
	"time in milliseconds - Hernan"
	
	timeBetweenChecks _ aTimeBetweenChecks ! !
!StackSizeWatcher methodsFor: 'testing' stamp: 'HAW 3/27/2018 14:49:41'!
                        canDebug: aProcess

	^(ProcessBrowser rulesFor: aProcess) second
	
! !
!StackSizeWatcher methodsFor: 'testing' stamp: 'HAW 3/27/2018 13:51:35'!
                isNotWatching

	^self isWatching not! !
!StackSizeWatcher methodsFor: 'testing' stamp: 'HAW 3/27/2018 14:55:20'!
               isStackTooDeepAt: aProcess

	"aProcess suspendedContext should never be nil under this circunstances but checking that just in case - Hernan"
	^aProcess suspendedContext 
		ifNil: [ false ] 
		ifNotNil: [ :topContext | topContext depthBelow > stackSizeThreashold ]
		! !
!StackSizeWatcher methodsFor: 'testing' stamp: 'HAW 3/27/2018 13:51:28'!
        isWatching

	^watcher notNil ! !
!StackSizeWatcher methodsFor: 'testing' stamp: 'HAW 3/27/2018 14:49:21'!
                      shouldStopAndDebug: aProcess

	^(self isStackTooDeepAt: aProcess) and: [self canDebug: aProcess]
	
! !
!StackSizeWatcher methodsFor: 'start/stop' stamp: 'jmv 3/28/2018 08:50:08'!
             startWatching

	self assertIsNotWatching.
	
	watcher _ [ [self watch] repeat ] newProcess.
	watcher priority: Processor lowIOPriority.
	watcher name: 'StackSizeWatcher monitor'.
	watcher resume.
	Processor yield! !
!StackSizeWatcher methodsFor: 'start/stop' stamp: 'HAW 3/27/2018 14:19:22'!
                             startWatchingAt: aTimeBetweenChecks informingWhenStackSizeBiggerThan: aThreshold

	self assertIsNotWatching.
	
	self changeTimeBetweenChecksTo: aTimeBetweenChecks.
	self changeStackSizeThresholdTo: aThreshold.
	self startWatching ! !
!StackSizeWatcher methodsFor: 'start/stop' stamp: 'HAW 3/27/2018 13:50:21'!
          stopWatching

	self assertIsWatching.
	
	watcher terminate.
	watcher _ nil! !
!StackSizeWatcher methodsFor: 'private' stamp: 'HAW 3/27/2018 14:53:56'!
         debug: aProcess

	aProcess debugFullWithTitle: 'Interrupted - Stack too deep'.
! !
!StackSizeWatcher methodsFor: 'private' stamp: 'HAW 3/27/2018 14:47:26'!
    watch

	| processToWatch |
	
	(Delay forMilliseconds: timeBetweenChecks) wait.
	processToWatch := Processor nextReadyProcess.
	(self shouldStopAndDebug: processToWatch) ifTrue: [ self debug: processToWatch ]
! !
!StackSizeWatcher class methodsFor: 'current' stamp: 'HAW 3/27/2018 14:12:49'!
                             current

	current isNil ifTrue: [ current _ self new ].
	^current! !
!StackSizeWatcher class methodsFor: 'current' stamp: 'HAW 3/27/2018 14:15:30'!
            resetCurrent

	current _ nil! !
!StackSizeWatcher class methodsFor: 'defaults' stamp: 'HAW 3/27/2018 14:20:12'!
                defaultStackSizeThreshold

	^2000! !
!StackSizeWatcher class methodsFor: 'defaults' stamp: 'HAW 3/27/2018 14:07:34'!
           defaultTimeBetweenChecks 

	"Time in milliseconds - Hernan"
	^10! !
!StackSizeWatcher class methodsFor: 'start/stop' stamp: 'jmv 3/28/2018 08:54:09'!
          isWatching
	^ current notNil and: [ current isWatching ]! !
!StackSizeWatcher class methodsFor: 'start/stop' stamp: 'HAW 3/27/2018 14:19:58'!
                  startWatchingAt: aTimeBetweenChecks informingWhenStackSizeBiggerThan: aThreshold

	^self current startWatchingAt: aTimeBetweenChecks informingWhenStackSizeBiggerThan: aThreshold
! !
!StackSizeWatcher class methodsFor: 'start/stop' stamp: 'HAW 3/27/2018 14:20:22'!
                        startWatchingWithDefaults

	^self startWatchingAt: self defaultTimeBetweenChecks informingWhenStackSizeBiggerThan: self defaultStackSizeThreshold! !
!StackSizeWatcher class methodsFor: 'start/stop' stamp: 'HAW 3/27/2018 14:15:17'!
                         stopWatching

	self current stopWatching.
	self resetCurrent	! !
!ProcessBrowserWindow methodsFor: 'menu building' stamp: 'jmv 3/28/2018 08:58:40' prior: 16895341!
                            processListMenu
	| menu rules |
	menu _ MenuMorph new defaultTarget: self.

	model selectedProcess
		ifNotNil: [ :selectedProcess |
			rules _ model class rulesFor: model selectedProcess.
			menu addList: #(
				('inspect (i)'					#inspectProcess)
				('explore (I)'				#exploreProcess)
				('references finder'			#openReferencesFinder)).
			rules first
				ifTrue: [
					menu add: 'terminate (t)' target: model action: #terminateProcess.
					selectedProcess isSuspended
						ifTrue: [menu add: 'resume (r)' target: model action: #resumeProcess]
						ifFalse: [menu add: 'suspend (s)' target: model action: #suspendProcess]].
			rules second
				ifTrue: [
					menu addList: #(
						('change priority (p)'		 	#changePriority)
						('debug (d)'						#debugProcess))].
			(selectedProcess suspendingList isKindOf: Semaphore)
				ifTrue: [menu add: 'signal Semaphore (S)' target: model action: #signalSemaphore].
			menu add: 'full stack (k)' target: model action: #moreStack.
			menu addLine].

	menu addList: #(
		('find context... (f)'		#findContext)
		('find again (g)'			#nextContext		''		model)).
	menu addLine.

	menu
		add: (isStepping
				ifTrue: ['turn off auto-update (a)']
				ifFalse: ['turn on auto-update (a)'])
		action: #toggleAutoUpdate.
	menu add: 'update list (u)' target: model action: #updateProcessList.

	menu addLine.
	CPUWatcher isMonitoring
			ifTrue: [ menu add: 'stop CPUWatcher' action: #stopCPUWatcher ]
			ifFalse: [ menu add: 'start CPUWatcher' action: #startCPUWatcher  ].
	StackSizeWatcher isWatching
			ifTrue: [ menu add: 'stop StackSizeWatcher' action: #stopStackSizeWatcher ]
			ifFalse: [ menu add: 'start StackSizeWatcher' action: #startStackSizeWatcher  ].

	^ menu! !
!Theme methodsFor: 'menus' stamp: 'jmv 3/28/2018 09:03:29' prior: 50376430!
  basicIcons

	"Minimal menu scheme.
	Theme current class beCurrent
	"

	^ { 
		#('open...') -> #openIcon.
		#('windows...' 'find window' 'Focus follows mouse' 'Click to focus') -> #windowIcon.
		#('help...' 'explain' 'about this system...' 'Terse Guide to Cuis' 'Class Comment Browser' 'Code management in Cuis' 'Using GitHub to host Cuis packages' ) -> #helpIcon.
		#('themes...') -> #appearanceIcon.
		#('do it (d)') -> #doItIcon.
		#('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon.
		#('save' ) -> #saveIcon.
		#('Save options...' 'save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon.
		#('save as new version') -> #saveAsNewVersionIcon.
		#('quit') -> #quitIcon.
		#('save and quit' ) -> #saveAndQuitIcon.
		#('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher' 'stop CPUWatcher')
			-> #inspectIcon.
		#('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'references finder' 'weight explorer' 'explore CompiledMethod') -> #exploreIcon.
		#('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon.
		#('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon.
		#('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript''stop StackSizeWatcher' ) -> #deleteIcon.
		#('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete' 'start StackSizeWatcher') -> #warningIcon.
		#('do again (j)' 'Redo - multiple (Z)') -> #redoIcon.
		#('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon.
		#('copy to clipboard (c)' 'copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon.
		#('paste (v)' 'Paste without Format') -> #pasteIcon.
		#('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon.
		#('paste...' 'icons...') -> #worldIcon.
}! !
!Theme methodsFor: 'menus' stamp: 'jmv 3/28/2018 09:03:59' prior: 50338800!
               miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)' 'stop StackSizeWatcher') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)' 'Run tests (t)' 'Run tests' 'Run test (t)' 'Accept & Debug Test (r)' 'Debug test (r)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3282-StackGrowthAlert-HernanWilkinson-2018Mar28-08h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3282] on 27 March 2018 at 5:11:12 pm'!
!InspectorWindow methodsFor: 'accessing' stamp: 'HAW 3/27/2018 17:07:55'!
                       classDefinitionChangedFrom: oldClass to: newClass

	model ifNotNil: [ model object class = newClass ifTrue: [ model changed: #fieldList ]]! !
!InspectorWindow methodsFor: 'accessing' stamp: 'HAW 3/27/2018 17:07:24'!
        model: aModel

	super model: aModel.
	model ifNotNil: [ 
		SystemChangeNotifier uniqueInstance
			when: #classDefinitionChanged send: #classDefinitionChangedFrom:to: to: self ]
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3283-UpdateInspectorOnClassShapeChange-HernanWilkinson-2018Mar19-15h33m-HAW.2.cs.st----!

----SNAPSHOT----#(28 March 2018 9:15:59.75432 am) Cuis5.0-3283-v3.image priorSource: 1854209!

----QUIT----#(28 March 2018 9:16:17.83412 am) Cuis5.0-3283-v3.image priorSource: 1879631!

----STARTUP----#(15 April 2018 7:35:02.119502 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3283-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3283] on 31 March 2018 at 11:34:13 pm'!
!SequenceableCollection methodsFor: 'testing' stamp: 'HAW 3/31/2018 23:26:34'!
                          ifInBounds: anIndex ifNot: aValuable

	^(self isInBounds: anIndex) ifTrue: [ anIndex ] ifFalse: aValuable ! !
!SequenceableCollection methodsFor: 'testing' stamp: 'HAW 3/31/2018 23:26:24'!
   isInBounds: anIndex

	^anIndex between: 1 and: self size! !
!SequenceableCollection methodsFor: 'accessing' stamp: 'HAW 3/31/2018 23:26:53' prior: 16905458!
   at: index ifAbsent: exceptionBlock
	"Answer the element at my position index. If I do not contain an element
	at index, answer the result of evaluating the argument, exceptionBlock."

	(self isInBounds: index) ifTrue: [^self at: index].
	^exceptionBlock value! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3284-SequenceableCollection-boundsChecking-HernanWilkinson-2018Mar31-23h26m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3283] on 31 March 2018 at 11:37:37 pm'!
!Browser methodsFor: 'class list' stamp: 'HAW 3/31/2018 23:34:42' prior: 50389670!
           classListIndex: anInteger 
	"Set anInteger to be the index of the current class selection."

	| className recent canSelectClass classList |

	classList _ self classList.
	canSelectClass _ classList isInBounds: anInteger.
	selectedClassName _ canSelectClass ifTrue: [ classList at: anInteger ].
	self setClassOrganizer.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	
	self classCommentIndicated ifFalse: [
		self editSelection: (canSelectClass
			ifTrue: [#editClass]
			ifFalse: [ metaClassIndicated | selectedSystemCategory isNil
				ifTrue: [#none]
				ifFalse: [#newClass]])].

	self selectedClass ifNotNil: [
		recent _ self class recentClasses.
		className _ self selectedClass name.
		(recent includes: className) ifTrue: [recent remove: className].
		recent addFirst: className.
		recent size > 16 ifTrue: [recent removeLast]].
	
	"We have to refresh the class list if somebody wants to select a class that does not exist anymore - Hernan"
	anInteger > classList size ifTrue: [ self changed: #classList ].
	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged! !
!Browser methodsFor: 'message category list' stamp: 'HAW 3/31/2018 23:35:18' prior: 16792196!
       messageCategoryListIndex: anInteger
	"Set the selected message category to be the one indexed by anInteger."

	| index messageCategoryList |
	
	messageCategoryList _ self messageCategoryList.
	index _ messageCategoryList ifInBounds: anInteger ifNot: 0.

	selectedMessageCategory _ index = 0 ifFalse: [messageCategoryList at: index ].
	selectedMessage _ nil.
	self changed: #messageCategorySelectionChanged.
	self changed: #messageCategoryListIndex. "update my selection"
	self changed: #messageList.
	self editSelection: (index > 0
		ifTrue: [#newMessage]
		ifFalse: [self classListIndex > 0
			ifTrue: [#editClass]
			ifFalse: [#newClass]]).
	self acceptedContentsChanged.! !
!Browser methodsFor: 'message list' stamp: 'HAW 3/31/2018 23:35:30' prior: 16792405!
      messageListIndex: anInteger
	"Set the selected message selector to be the one indexed by anInteger."
	
	| index messageList |
	
	messageList _ self messageList.
	index _ messageList ifInBounds: anInteger ifNot: 0.

	selectedMessage _ index = 0 ifFalse: [ messageList at: index ].
	self editSelection: (index > 0
		ifTrue: [#editMessage]
		ifFalse: [self messageCategoryListIndex > 0
			ifTrue: [#newMessage]
			ifFalse: [self classListIndex > 0
				ifTrue: [#editClass]
				ifFalse: [#newClass]]]).
	self changed: #messageListIndex. "update my selection"
	self acceptedContentsChanged! !
!Browser methodsFor: 'system category list' stamp: 'HAW 3/31/2018 23:35:42' prior: 16792786!
                       systemCategoryListIndex: anInteger
	"Set the selected system category index to be anInteger. Update all other 
	selections to be deselected."
	
	| index systemCategoryList |
	
	systemCategoryList _ self systemCategoryList.
	index _ systemCategoryList ifInBounds: anInteger ifNot: 0.
	
	selectedSystemCategory _ index = 0 ifFalse: [ systemCategoryList at: index ].
	selectedClassName _ nil.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	self editSelection: ( index = 0 ifTrue: [#none] ifFalse: [#newClass]).
	metaClassIndicated _ false.
	self setClassOrganizer.
	self changed: #systemCategorySelectionChanged.
	self changed: #systemCategoryListIndex.	"update my selection"
	self changed: #classList.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.
	self acceptedContentsChanged! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'HAW 3/31/2018 23:36:09' prior: 16853533!
    classListIndex: newIndex

	"Cause system organization to reflect appropriate category"

	| newClassName ind i |

	(classList isInBounds: newIndex) ifTrue: [
		newClassName _ (classList at: newIndex) copyWithout: $ .
		i _ systemOrganizer numberOfCategoryOfElement: newClassName.
		selectedSystemCategory _ i = 0 ifFalse: [ self systemCategoryList at: i]].
	ind _ super classListIndex: newIndex.
	self changed: #systemCategorySingleton.
	^ ind! !
!MessageSet methodsFor: 'message list' stamp: 'HAW 3/31/2018 23:36:45' prior: 16869855!
          messageListIndex: anInteger

	"Set the index of the selected item to be anInteger."

	| list |
	
	list _ self messageList.
	selectedMessage _ (list isInBounds: anInteger) ifTrue: [ list at: anInteger ].
	self changed: #messageListIndex.	 "update my selection"
	self editSelection: #editMessage.
	self acceptedContentsChanged! !
!TimeProfileBrowser methodsFor: 'message list' stamp: 'HAW 3/31/2018 23:37:17' prior: 16937837!
                        messageListIndex: anInteger

	"Set the index of the selected item to be anInteger."
	
	selectedMessage _ (talliesList isInBounds: anInteger) ifTrue: [ talliesList at: anInteger ].
	self changed: #messageListIndex.	 "update my selection"
	self editSelection: #editMessage.
	self acceptedContentsChanged! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3285-Browser-SelectionIndexChecks-HernanWilkinson-2018Mar31-23h34m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3285] on 4 April 2018 at 3:16:11 pm'!
!AbstractFont methodsFor: 'measuring' stamp: 'jmv 4/4/2018 14:46:40'!
                         normalizedWidthOf: aCharacter
	"Return the width of the given character, irrespective of point size."
	^ (self widthOf: aCharacter) / self pointSize! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3286-normalizedWidthOf-JuanVuletich-2018Apr04-14h46m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3286] on 4 April 2018 at 4:53:28 pm'!

Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom shadowColor transformations currentTransformation cti currentMorph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #MorphicCanvas category: #'Morphic-Support'!
Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom shadowColor transformations currentTransformation cti currentMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom transformations currentTransformation cti currentMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #MorphicCanvas category: #'Morphic-Support'!
Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom transformations currentTransformation cti currentMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3287-removeUnusedIvar-JuanVuletich-2018Apr04-16h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3285] on 5 April 2018 at 2:33:05 pm'!
!TestCase methodsFor: 'Accessing' stamp: 'HAW 4/5/2018 13:35:59' prior: 50343605!
                        should: aBlock raise: anExceptionHandlingCondition withExceptionDo: assertionsBlock description: aFailDescription

	| result |
	
	[result := aBlock value ] 
		on: anExceptionHandlingCondition
		do: [ :anException |
			assertionsBlock value: anException.
			^result ].
		
	self failWith: aFailDescription! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3288-shouldraise-fix-HernanWilkinson-2018Apr05-14h11m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3283] on 13 April 2018 at 4:53:18 pm'!
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/13/2018 16:51:04' prior: 50386817!
             displayOn: aForm in: aRectangle
	"
	1 to: 2000 do: [ :i | i print ].
	1 to: 750 do: [ :i | i print ].
	Transcript displayOn: Display in: bounds
	"
	| font count string x y fh canvas innerR index |
	aForm fill: aRectangle fillColor: `Color white`.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	x _ innerR left.
	y _ innerR top.
	fh _ font height.
	count _ lastIndex - firstIndex \\ self maxEntries + 1 min: innerR height // fh - 1.
	index _ lastIndex - count \\ self maxEntries + 1.
	count timesRepeat: [
		string _ entries at: index.	
		canvas drawString: string at: x@y font: font color: `Color veryDarkGray`.
		y _ y + fh.
		index _ index \\ self maxEntries + 1 ].
	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: `Color veryDarkGray`! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3289-Transcript-fix-JuanVuletich-2018Apr13-16h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3285] on 12 April 2018 at 1:37:31 pm'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'HAW 4/12/2018 13:36:40' prior: 16806621!
  definition
	"Answer a String that defines the receiver."

	^String streamContents: [ :strm |
		strm
			nextPutAll: (superclass ifNotNil: [ superclass name ] ifNil: [ 'ProtoObject' ]);
			nextPutAll: self kindOfSubclass;
			store: self name.
		strm
			newLine;
			tab;
			nextPutAll: 'instanceVariableNames: ';
			store: self instanceVariablesString.
		strm
			newLine;
			tab;
			nextPutAll: 'classVariableNames: ';
			store: self classVariablesString.
		strm
			newLine;
			tab;
			nextPutAll: 'poolDictionaries: ';
			store: self sharedPoolsString.
		strm
			newLine;
			tab;
			nextPutAll: 'category: ';
			store: self category asString.

		superclass ifNil: [ 
			strm nextPutAll: '.'; newLine.
			strm nextPutAll: self name.
			strm space; nextPutAll: 'superclass: nil' ]]! !
!SmallFloat64 class methodsFor: 'fileIn/Out' stamp: 'HAW 4/12/2018 13:35:41' prior: 16908567!
                     definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Float immediateSubclass: #SmallFloat64
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''', self category, ''''
! !
!SmallInteger class methodsFor: 'fileIn/Out' stamp: 'HAW 4/12/2018 13:35:04' prior: 16909202!
           definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Integer immediateSubclass: #SmallInteger
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''', self category, ''''! !
!Character class methodsFor: 'fileIn/Out' stamp: 'HAW 4/12/2018 13:36:49' prior: 50375906!
             definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Object immediateSubclass: #Character
	instanceVariableNames: ''value''
	classVariableNames: ''CharacterTable UnaccentedTable UnicodeCodePoints LowercaseMappingTable LowercaseTruthTable UppercaseMappingTable UppercaseTruthTable LetterTruthTable''
	poolDictionaries: ''''
	category: ''', self category, ''''
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3290-ImmediateClasses-definition-HernanWilkinson-2018Apr12-13h34m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3285] on 14 April 2018 at 7:50:08 pm'!
!Theme methodsFor: 'menus - private' stamp: 'HAW 4/12/2018 15:53:55'!
                           basicIconsTypeSelector

	^#addBasicIconsTo:! !
!Theme methodsFor: 'menus - private' stamp: 'HAW 4/14/2018 19:47:32'!
           iconDefinersFor: anIconTypeSelector

	^(Smalltalk allClassesImplementing: anIconTypeSelector) 
		select: [ :aClass | aClass isMeta ] 
		thenCollect: [ :aClass | aClass soleInstance ].
	! !
!Theme methodsFor: 'menus - private' stamp: 'HAW 4/14/2018 19:47:39'!
                             iconsDefinitionFor: anIconTypeSelector

	^(self iconDefinersFor: anIconTypeSelector) 
		inject: OrderedCollection new 
		into: [ :definition :iconDefiner | 
			iconDefiner perform: anIconTypeSelector with: definition.
			definition ]! !
!Theme methodsFor: 'menus - private' stamp: 'HAW 4/12/2018 16:00:19'!
             miscellaneousIconsTypeSelector

	^#addMiscellaneousIconsTo:
! !
!Theme class methodsFor: 'icons by menu' stamp: 'HAW 4/14/2018 19:44:24'!
                      addBasicIconsTo: aCollectorCollection

	aCollectorCollection 		
		add: #('open...') -> #openIcon;
		add: #('windows...' 'find window' 'Focus follows mouse' 'Click to focus') -> #windowIcon;
		add: #('help...' 'explain' 'about this system...' 'Terse Guide to Cuis' 'Class Comment Browser' 'Code management in Cuis' 'Using GitHub to host Cuis packages' ) -> #helpIcon;
		add: #('themes...') -> #appearanceIcon;
		add: #('do it (d)') -> #doItIcon;
		add: #('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon;
		add: #('save' ) -> #saveIcon;
		add: #('Save options...' 'save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon;
		add: #('save as new version') -> #saveAsNewVersionIcon;
		add: #('quit') -> #quitIcon;
		add: #('save and quit' ) -> #saveAndQuitIcon;
		add: #('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher' 'stop CPUWatcher')
			-> #inspectIcon;
		add: #('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'references finder' 'weight explorer' 'explore CompiledMethod') -> #exploreIcon;
		add: #('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon;
		add: #('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon;
		add: #('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript''stop StackSizeWatcher' ) -> #deleteIcon;
		add: #('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete' 'start StackSizeWatcher') -> #warningIcon;
		add: #('do again (j)' 'Redo - multiple (Z)') -> #redoIcon;
		add: #('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon;
		add: #('copy to clipboard (c)' 'copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon;
		add: #('paste (v)' 'Paste without Format') -> #pasteIcon;
		add: #('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon;
		add: #('paste...' 'icons...') -> #worldIcon
! !
!Theme class methodsFor: 'icons by menu' stamp: 'HAW 4/14/2018 19:42:09'!
            addMiscellaneousIconsTo: aCollectorCollection

	aCollectorCollection 
		add: #('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon;
		add: #('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon;
		add: #('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon;
		add: #('find again (g)' 'full stack (k)') -> #systemIcon;
		add: #('print it (p)' 'check change set for slips') -> #printIcon;
		add: #('accept (s)' 'make changes go to me (m)') -> #acceptIcon;
		add: #('cancel (l)' 'turn off auto-update (a)' 'stop StackSizeWatcher') -> #cancelIcon;
		add: #('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon;
		add: #('close' 'close all debuggers' 'close top window') -> #closeIcon;
		add: #('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon;
		add: #('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon;
		add: #('menu') -> #windowMenuIcon;
		add: #('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon;
		add: #('workspace' 'workspace with contents') -> #terminalIcon;
		add: #('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon;
		add: #('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon;
		add: #('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon;
		add: #('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon;
		add: #('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon;
		add: #('change sorter') -> #halfRefreshIcon;
		add: #('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)' 'Run tests (t)' 'Run tests' 'Run test (t)' 'Accept & Debug Test (r)' 'Debug test (r)') -> #weatherFewCloudsIcon;
		add: #('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon;
		add: #('full screen on') -> #viewFullscreenIcon;
		add: #('full screen off') -> #exitFullscreenIcon;
		add: #('set desktop color...') -> #wallpaperIcon;
		add: #('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon;
		add: #('Editor keyboard shortcuts') -> #keyboardShortcutsIcon;
		add: #('world menu help') -> #globeIcon;		"currently unused, but a neat icon"
		add: #('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon;
		add: #('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon;
		add: #('space left') -> #removableMediaIcon;
		add: #('start drawing all again' 'window color...') -> #graphicsIcon;
		add: #('start stepping again') -> #mediaPlaybackStartIcon;
		add: #('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon;
		add: #('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon;
		add: #('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon;
		add: #('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon;
		add: #('references to it (N)') -> #addressBookIcon;
		add: #('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon;
		add: #('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon;
		add: #('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon;
		add: #('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon;
		add: #('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon;
		add: #('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon;
		add: #('move up' 'make next-to-topmost') -> #goUpIcon;
		add: #('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon;
		add: #('inheritance (i)' 'move down') -> #goDownIcon;
		add: #('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon;
		add: #('spawn full protocol') -> #speadsheetTemplateIcon;
		add: #('alphabetize') -> #fontXGenericIcon;
		add: #('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon;
		add: #('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon;
		add: #('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon;
		add: #('toggle diffing (D)' 'toggle selections') -> #switchIcon;
		add: #('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon;
		add: #('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon;
		add: #('find changed windows...') -> #newWindowIcon;
		add: #('make undraggable') -> #pushPinIcon;
		add: #('Utilities saveScreenshot.') -> #stillCameraIcon;
		add: #('add new directory') -> #newFolderIcon;
		add: #('select all' 'deselect all') -> #selectAllIcon;
		add: #('sort by date') -> #dateIcon;
		add: #('justified') -> #formatJustifyFillIcon;
		add: #('centered') -> #formatJustifyCenterIcon;
		add: #('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon;
		add: #('rightFlush') -> #formatJustifyRightIcon;
		add: #('signal Semaphore (S)') -> #haloHelpIcon;
		add: #('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon;
		add: #('Clear Font') -> #newIcon;
		add: #('code file browser' 'package file browser') -> #findIcon.
	! !
!Theme methodsFor: 'menus' stamp: 'HAW 4/12/2018 15:56:21' prior: 50390077!
     basicIcons

	"Minimal menu scheme.
	Theme current class beCurrent
	"

	^self iconsDefinitionFor: self basicIconsTypeSelector 
! !
!Theme methodsFor: 'menus' stamp: 'HAW 4/12/2018 16:00:06' prior: 50390166!
                  miscellaneousIcons
	
	^self iconsDefinitionFor: self miscellaneousIconsTypeSelector
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3291-IconSpecEnhancements-HernanWilkinson-2018Apr12-13h37m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3285] on 14 April 2018 at 8:01:56 pm'!
!PluggableListMorphByItem methodsFor: 'model access' stamp: 'HAW 4/14/2018 19:27:47' prior: 50380211!
                         setSelectionIndex: anInteger
	"Change the model's selected item to be the one at the given index."

	| item |
	setIndexSelector ifNotNil: [
		item _ itemList at: anInteger ifAbsent: [ nil ].
		model perform: setIndexSelector with: item.
		self update: getIndexSelector.
		^ true ].
	^false
	! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3292-PluggableListMorphByItem-fix-HernanWilkinson-2018Apr14-19h50m-HAW.1.cs.st----!

----SNAPSHOT----#(15 April 2018 7:35:09.00468 pm) Cuis5.0-3292-v3.image priorSource: 1879726!

----QUIT----#(15 April 2018 7:35:38.974492 pm) Cuis5.0-3292-v3.image priorSource: 1904444!

----STARTUP----#(18 April 2018 5:27:53.308788 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3292-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3292] on 18 April 2018 at 5:21:46 pm'!
!String class methodsFor: 'primitives' stamp: 'jmv 4/18/2018 17:21:32' prior: 16918032!
    indexOfByte: anInteger inString: aString startingAt: start

	| stringSize |
	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>

	self var: #aCharacter declareC: 'int anInteger'.
	self var: #aString declareC: 'unsigned char *aString'.

	start > 0 ifFalse: [ ^ 0 ].
	stringSize _ aString size.
	start to: stringSize do: [:pos |
		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].
	^ 0
! !
!CompiledMethod class methodsFor: 'services' stamp: 'jmv 4/18/2018 17:19:33' prior: 16821574!
                             timeStamp: aStamp partsDo: aBlock
	"
	CompiledMethod>>#timeStampPartsDo: timeStampPartsDo: [ :authorInitials :dateAndTime |
		('*',authorInitials,'*') print. dateAndTime print ]
	"
	| stamp dateIndex aux dateAndTimePart |
	stamp _ aStamp.
	"Account for some unfortunately hacked stamps such as this: 'cwp 10/17/2007 23:29/eem 9/5/2009 11:10 - => :=' "
	aux _ stamp lastIndexOf: $/.
	aux _ stamp indexOf: $: startingAt: (aux max:1) ifAbsent: [ 0 ].
	aux > 0 ifTrue: [
		(aux > 0 and: [ aux + 2 ~= stamp size]) ifTrue: [
			stamp _ stamp copyFrom: 1 to: aux + 2 ]].

	"Find start of date, if not possible, consider the whole stamp the author, and no date"
	aux _ stamp
		lastIndexOf: $/
		startingAt: stamp size
		ifAbsent: [ ^ aBlock value: stamp value: nil ].
	aux _ stamp
		lastIndexOf: $/
		startingAt: aux
		ifAbsent: [ ^ aBlock value: stamp value: nil ].
	dateIndex _ stamp
		lastIndexOf: $ 
		startingAt: aux
		ifAbsent: [ ^ aBlock value: stamp value: nil ].
	"If only date, no time, add midnight time"
	dateAndTimePart _ stamp copyFrom: dateIndex + 1 to: stamp size.
	(dateAndTimePart indexOf: $:) = 0 ifTrue:[
		dateAndTimePart _ dateAndTimePart, ' 00:00' ].
	"Done"
	^aBlock
		value: (stamp copyFrom: 1 to: dateIndex-1)
		value: (DateAndTime fromString: dateAndTimePart)! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3293-PackageLoadHang-fix-JuanVuletich-2018Apr18-17h20m-jmv.1.cs.st----!

----SNAPSHOT----#(18 April 2018 5:27:59.111944 pm) Cuis5.0-3293-v3.image priorSource: 1904539!

----QUIT----#(18 April 2018 5:28:11.893591 pm) Cuis5.0-3293-v3.image priorSource: 1906891!

----STARTUP----#(25 May 2018 2:10:28.044686 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3293-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3293] on 21 April 2018 at 4:54:48 pm'!

CodeWindow subclass: #DebuggerWindow
	instanceVariableNames: 'receiverInspector codePane receiverInspectorText stackList contextVariableInspector contextVariableInspectorText '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!classDefinition: #DebuggerWindow category: #'Morphic-Tools'!
CodeWindow subclass: #DebuggerWindow
	instanceVariableNames: 'receiverInspector codePane receiverInspectorText stackList contextVariableInspector contextVariableInspectorText'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!
!SystemWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 16:46:39'!
             canDiscardEditsOf: aMorphWithChanges 

	| okToLooseChanges |
	
	aMorphWithChanges canDiscardEdits ifTrue: [ ^true ].
	
	okToLooseChanges _ self isItOkToLooseChanges.
	okToLooseChanges ifTrue: [ aMorphWithChanges disregardUnacceptedEdits ].
	
	^okToLooseChanges

		! !
!SystemWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 16:03:28'!
        isItOkToLooseChanges
	
	^ self confirm:
'Changes have not been saved.
Is it OK to cancel those changes?'.! !
!SystemWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 12:09:13'!
       okToChangeDueTo: aMorph
	
	^self okToChange! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 4/21/2018 12:11:38'!
     buildMorphicCodePane
	
	codePane _ super buildMorphicCodePane.
	^codePane! !
!DebuggerWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 16:47:36'!
     okToChangeCodePane

	| okToLooseChanges |
	
	okToLooseChanges _ self canDiscardEditsOf: codePane.
	okToLooseChanges ifTrue: [
		receiverInspectorText disregardUnacceptedEdits.
		contextVariableInspectorText disregardUnacceptedEdits ].
	
	^okToLooseChanges ! !
!DebuggerWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 16:47:50'!
              okToChangeContextVariableInspectorText
	
	^self canDiscardEditsOf: contextVariableInspectorText! !
!DebuggerWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 16:40:50'!
               okToChangeDueTo: aMorph

	aMorph = stackList ifTrue: [ ^self okToChangeCodePane ].
	aMorph = receiverInspector ifTrue: [ ^self okToChangeReceiverInspectorText ].
	aMorph = contextVariableInspector ifTrue: [ ^self okToChangeContextVariableInspectorText ].
	
	^super okToChangeDueTo: aMorph 
	
	
	! !
!DebuggerWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 16:47:56'!
       okToChangeReceiverInspectorText
	
	^self canDiscardEditsOf: receiverInspectorText! !
!PluggableListMorph methodsFor: 'events' stamp: 'HAW 4/21/2018 12:09:58' prior: 50380379!
                 mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: localEventPosition.
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [ ^ self ]].
	(autoDeselect == false and:  [row = 0 ]) ifTrue: [ ^ self ].  "work-around the no-mans-land bug"
	"No change if model is locked"
	(autoDeselect and: [ row == self visualSelectionIndex ])
		ifTrue: [
			aMouseButtonEvent mouseButton1Changed ifTrue: [
				self setSelectionIndex: 0 ]]
		ifFalse: [ self setSelectionIndex: row ]! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'HAW 4/21/2018 12:09:32' prior: 50380401!
                              arrowKey: aChar
	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."
	| keyEvent oldSelection nextSelection max min howMany answer w |
	answer _ false.
	keyEvent _ aChar numericValue.
	oldSelection _ self getCurrentSelectionIndex.
	nextSelection _ oldSelection.
	max _ self maximumSelection.
	min _ self minimumSelection.
	howMany _ self numSelectionsInView.	"get this exactly??"

	keyEvent = 31 ifTrue: [
		"down-arrow; move down one, wrapping to top if needed"
		nextSelection _ oldSelection + 1.
		nextSelection > max ifTrue: [ nextSelection _ 1 ]].

	keyEvent = 30 ifTrue: [
		"up arrow; move up one, wrapping to bottom if needed"
		nextSelection _ oldSelection - 1.
		nextSelection < 1 ifTrue: [ nextSelection _ max ]].

	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"
	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"
	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"
	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"
	nextSelection = oldSelection ifFalse: [
		w _ self owningWindow.
		(w isNil or: [ w okToChangeDueTo: self ]) ifTrue: [ "No change if model is locked"

			"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
			self listMorph highlightedRow: nextSelection.

			"Update the model in next world cycle, so user gets the immediate feedback."
			UISupervisor whenUIinSafeState: [
				self setSelectionIndex: nextSelection ].
			answer _ true ]].
	^answer! !
!PluggableListMorph methodsFor: 'model access' stamp: 'HAW 4/21/2018 12:09:49' prior: 50380465!
       keyboardSearch: aChar 
	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |
	nextSelection _ oldSelection _ self getCurrentSelectionIndex.
	max _ self maximumSelection.
	milliSeconds _ Time localMillisecondClock.
	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"
		lastKeystrokes _ ''].
	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.
	lastKeystrokeTime _ milliSeconds.
	nextSelectionList _ OrderedCollection newFrom: (list copyFrom: oldSelection + 1 to: max).
	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).
	"Get rid of blanks and style used in some lists"
	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]
				ifNone: [^ self flash"match not found"].
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [^ self]].
	nextSelection _ list findFirst: [:a | a == nextSelectionText].
	"No change if model is locked"
	oldSelection == nextSelection ifTrue: [^ self flash].
	^ self setSelectionIndex: nextSelection! !
!SystemWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 16:46:56' prior: 16926859!
      okToChange

	^self canDiscardEditsOf: self! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 4/21/2018 12:08:29' prior: 50334336!
                      buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| bottomMorph |

	stackList _ PluggableListMorph
		model: model 
		listGetter: #contextStackList
		indexGetter: #contextStackIndex
		indexSetter: #toggleContextStackIndex:
		mainView: self
		menuGetter: #contextStackMenu
		keystrokeAction: #contextStackKey:from:.

	receiverInspector _ PluggableListMorph
			model: model receiverInspector
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #receiverFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	receiverInspector doubleClickSelector: #inspectSelection.
	receiverInspectorText _ TextModelMorph
			textProvider: model receiverInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	contextVariableInspector _ PluggableListMorph
			model: model contextVariablesInspector 
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #contextFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	contextVariableInspector doubleClickSelector: #inspectSelection.
	contextVariableInspectorText _ TextModelMorph
			textProvider: model contextVariablesInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.

	bottomMorph _ LayoutMorph newRow.
	bottomMorph
		addMorph: receiverInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: receiverInspectorText proportionalWidth: 0.3;
		addAdjusterAndMorph: contextVariableInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: contextVariableInspectorText proportionalWidth: 0.3.

	self layoutMorph
		addMorph: stackList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2! !

DebuggerWindow removeSelector: #canDiscardEditsFrom:!

DebuggerWindow removeSelector: #canDiscardEditsFrom:disregarding:!

DebuggerWindow removeSelector: #okToChangeStackList!

SystemWindow removeSelector: #askShouldSaveChanges!

CodeWindow subclass: #DebuggerWindow
	instanceVariableNames: 'stackList receiverInspector receiverInspectorText contextVariableInspector contextVariableInspectorText codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

!classDefinition: #DebuggerWindow category: #'Morphic-Tools'!
CodeWindow subclass: #DebuggerWindow
	instanceVariableNames: 'stackList receiverInspector receiverInspectorText contextVariableInspector contextVariableInspectorText codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tools'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3294-DebuggerEnhancements-HernanWilkinson-2018Apr21-12h07m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3293] on 22 April 2018 at 5:32:30 pm'!
!DebuggerWindow methodsFor: 'user interface' stamp: 'HAW 4/21/2018 20:43:49'!
            ifOkToChangeCodePaneDo: aBlock

	^self okToChangeCodePane ifTrue: aBlock 
! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/22/2018 17:30:34'!
createMethod

	^ self ifOkToChangeCodePaneDo: [ model createMethod ]! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/21/2018 20:44:10'!
      doStep

	^ self ifOkToChangeCodePaneDo: [ model doStep ]! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/21/2018 20:45:19'!
                  fullStack

	^ self ifOkToChangeCodePaneDo: [ model fullStack ]! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/21/2018 20:45:26'!
            proceed

	^ self ifOkToChangeCodePaneDo: [ model proceed ]! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/21/2018 20:45:36'!
                restart 
	
	^ self ifOkToChangeCodePaneDo: [ model restart ]! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/22/2018 17:31:44'!
              send

	^ self ifOkToChangeCodePaneDo: [ model send ]! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/21/2018 20:45:56'!
                      stepIntoBlock

	^ self ifOkToChangeCodePaneDo: [ model stepIntoBlock ]! !
!DebuggerWindow methodsFor: 'context stack menu' stamp: 'HAW 4/21/2018 20:46:06'!
    where

	^ self ifOkToChangeCodePaneDo: [ model where ]! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 4/21/2018 20:41:02' prior: 16831080!
          customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollection new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first asString.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!DebuggerWindow methodsFor: 'menu building' stamp: 'HAW 4/21/2018 20:39:59' prior: 16831155!
                         contextStackMenu
	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList: #(
			('fullStack (f)'					fullStack	)
			('restart (r)'					restarl)
			('proceed (p)'					proceed)
			('step (t)'						doStep)
			('step through (T)'				stepIntoBlock)
			('send (e)'						send)
			('where (w)'					where)
			('peel to first like this'			peelToFirst)
			-
			('return entered value'		returnValue)
			('toggle break on entry'		toggleBreakOnEntry 	''		model)
		).
	^aMenu! !
!DebuggerWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 4/21/2018 20:38:49' prior: 16831264!
        contextStackKey: aChar from: view
	"Respond to a keystroke in the context list"

	aChar == $e ifTrue: [^ self send].
	aChar == $t ifTrue: [^ self doStep].
	aChar == $T ifTrue: [^ self stepIntoBlock].
	aChar == $p ifTrue: [^ self proceed].
	aChar == $r ifTrue: [^ self restart].
	aChar == $f ifTrue: [^ self fullStack].
	aChar == $w ifTrue: [^ self where].

	^ self messageListKey: aChar from: view! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3295-DebuggerEnhancements-HernanWilkinson-2018Apr21-16h54m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3295] on 26 April 2018 at 1:38:13 pm'!
!Object methodsFor: 'evaluating' stamp: 'jmv 4/26/2018 13:11:27'!
    valueWithPossibleArgument: anArg

	^self! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 4/26/2018 13:33:07'!
             collect: aBlock andFold: aTwoArgBlock ifEmpty: emptyBlockOrValue
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each  size] andFold: [:a :b | a + b] ifEmpty: nil
	#() collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	"

	| first eachValue answer |
	first _ true.
	self do: [ :each |
		eachValue _  aBlock value: each.
		first
			ifTrue: [
				first _ false.
				answer _ eachValue ]
			ifFalse: [
				answer _ aTwoArgBlock
					value: answer
					value: eachValue ]].
	first ifTrue: [ answer _ emptyBlockOrValue valueWithPossibleArgument: self ].
	^ answer! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 4/26/2018 13:17:08'!
                       fold: aTwoArgBlock ifEmpty: emptyBlockOrValue
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b] ifEmpty: [ :coll | coll errorEmptyCollection ]
	#() fold: [:a :b | a, ' ', b] ifEmpty: [ :coll | coll errorEmptyCollection ]
	#() fold: [:a :b | a, ' ', b] ifEmpty: 7
	"

	^self
		collect: [ :each | each ]
		andFold: aTwoArgBlock
		ifEmpty: emptyBlockOrValue! !
!Collection methodsFor: 'statistics' stamp: 'jmv 4/26/2018 13:30:54'!
         sum: aBlock ifEmpty: emptyBlockOrValue
	"This is implemented using a variant of the normal inject:into: pattern. 
	The reason for this is that it is not known whether we're in the normal 
	number line, i.e. whether 0 is a good initial value for the sum. 
	Consider a collection of measurement objects, 0 would be the unitless 
	value and would not be appropriate to add with the unit-ed objects."
	^self collect: aBlock andFold: [ :a :b | a + b ] ifEmpty: emptyBlockOrValue! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 4/26/2018 13:16:40' prior: 16814204!
            collect: aBlock andFold: aTwoArgBlock
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each ] andFold: [:a :b | a, ' ', b]
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each  size] andFold: [:a :b | a + b]
	"

	^ self
		collect: aBlock
		andFold: aTwoArgBlock
		ifEmpty: [ self errorEmptyCollection ]! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 4/26/2018 13:16:51' prior: 16814381!
                         fold: aTwoArgBlock
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]
	"

	^self
		collect: [ :each | each ]
		andFold: aTwoArgBlock
		ifEmpty: [ self errorEmptyCollection ]! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 4/26/2018 13:22:28' prior: 16814447!
              reduce: aTwoArgBlock
	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.
	For sequenceable collections the elements will be used in order, for unordered
	collections the order is unspecified."

	^self fold: aTwoArgBlock! !
!Collection methodsFor: 'statistics' stamp: 'jmv 4/26/2018 13:27:14' prior: 16815012!
               product
	"Compute the product of all the elements in the receiver"

	^self fold: [ :a :b | a * b] ifEmpty: 1! !
!Collection methodsFor: 'statistics' stamp: 'jmv 4/26/2018 13:30:08' prior: 16815065!
                          sum
	"Compute the sum of all the elements in the receiver"

	^self fold: [ :a :b | a + b]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3296-sum_ifEmpty-foldProtocolTweaks-JuanVuletich-2018Apr26-13h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3296] on 2 May 2018 at 6:33:04 pm'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/2/2018 18:28:52' prior: 50382949!
                         xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	[ | compiler method methodNode |
		compiler _ Compiler new.
		methodNode _ compiler compileNoPattern: buffer contents in: UndefinedObject context: nil notifying: nil ifFail: [].
		method _ methodNode generate.
		"Grab all messages sent while evaluating literal, so the main method will be shown as senders of them"
		sentInLiterals addAll: method messages.
		method literalsDo: [ :literal | literal isSymbol ifTrue: [ sentInLiterals add: literal ]].
		"Evaluate now."
		token _ nil withArgs: #() executeMethod: method.
	] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3297-FixSendersInComplexLiterals-JuanVuletich-2018May02-18h31m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3296] on 30 April 2018 at 8:28:45 pm'!
!Preferences class methodsFor: 'menu icons' stamp: 'jmv 4/30/2018 20:13:31'!
                      useMenuIcons

	self setPreference: #wantsMenuIcons toValue: true! !
!Preferences class methodsFor: 'menu icons' stamp: 'jmv 4/30/2018 20:13:34'!
               useNoMenuIcons

	self setPreference: #wantsMenuIcons toValue: false! !
!Preferences class methodsFor: 'menu icons' stamp: 'jmv 4/30/2018 20:13:53'!
            wantsMenuIcons
	^ self
		valueOfFlag: #wantsMenuIcons
		ifAbsent: [ true ]! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/30/2018 20:26:39' prior: 50378976!
                       reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoMenuIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/30/2018 20:22:36' prior: 16893781!
                           cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe false)
		(syntaxHighlightingAsYouType true)
		(tapAndHoldEmulatesButton2 true)
		(clickGrabsMorphs false)

		(syntaxHighlightingAsYouTypeAnsiAssignment false)
		(syntaxHighlightingAsYouTypeLeftArrowAssignment false)
	).
	self useMenuIcons
	".
	Theme beCurrent.
	Taskbar showTaskbar
	"! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/30/2018 20:24:54' prior: 16893825!
                          slowMachine
	"
	Preferences slowMachine
	"
	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
	).
	self useNoMenuIcons.
	self runningWorld backgroundImageData: nil.
	"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	Taskbar hideTaskbar
	"! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/30/2018 20:24:56' prior: 16893849!
        smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak and Cuis in recent years. Caution: turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more.

	Preferences smalltalk80
	"

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders false)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
	).
	self useNoMenuIcons.
	"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	Taskbar hideTaskbar
	"! !
!Theme methodsFor: 'menus' stamp: 'jmv 4/30/2018 20:06:28' prior: 50391127!
            basicIcons

	"Minimal menu scheme.
	Theme current class beCurrent
	"

	^self iconsDefinitionFor: #addBasicIconsTo:! !
!Theme methodsFor: 'menus' stamp: 'jmv 4/30/2018 20:17:26' prior: 16936052!
                              menuDecorations

	"build a dictionary wordings -> icon to decorate the menus all over the image"

	^Preferences wantsMenuIcons
		ifTrue: [ self allIcons ]
		ifFalse: [#() ]! !
!Theme methodsFor: 'menus' stamp: 'jmv 4/30/2018 20:06:14' prior: 50391134!
    miscellaneousIcons
	
	^self iconsDefinitionFor: #addMiscellaneousIconsTo:! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 4/30/2018 20:22:02' prior: 16936913!
                        changeIcons

	| menu selector |
	
	menu _ SelectionMenu
		fromArray: #(
			#( 'Use icons for menu entries' #useMenuIcons )
			#( 'Don''t use icons for menu entries' #useNoMenuIcons )
		).
			
	selector _ menu startUpWithCaption: 'Menu Icons'.
	
	selector ifNotNil: [
		Preferences perform: selector.
		Theme current class beCurrent ]
! !

Theme removeSelector: #basicIconsTypeSelector!

Theme removeSelector: #basicIconsTypeSelector!

Theme removeSelector: #miscellaneousIconsTypeSelector!

Theme removeSelector: #miscellaneousIconsTypeSelector!

Theme removeSelector: #noIcons!

Theme removeSelector: #noIcons!

Preferences class removeSelector: #menuIcons!

Preferences class removeSelector: #menuIcons!

Preferences class removeSelector: #useAllIcons!

Preferences class removeSelector: #useAllIcons!

Preferences class removeSelector: #useBasicIcons!

Preferences class removeSelector: #useBasicIcons!

Preferences class removeSelector: #useNoIcons!

Preferences class removeSelector: #useNoIcons!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3298-BigMenuRefactor-p1-JuanVuletich-2018Apr30-19h58m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3296] on 1 May 2018 at 1:15:46 am'!

StringMorph subclass: #MenuItemMorph
	instanceVariableNames: 'isEnabled subMenu isSelected target selector arguments icon contentString '
	classVariableNames: 'SubMenuMarker '
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuItemMorph category: #'Morphic-Menus'!
StringMorph subclass: #MenuItemMorph
	instanceVariableNames: 'isEnabled subMenu isSelected target selector arguments icon contentString'
	classVariableNames: 'SubMenuMarker'
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2018 01:15:02' prior: 50385213!
                             contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	contentString _ nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString _ aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 5/1/2018 01:14:28' prior: 16865998!
    mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event. Menu items get activated when the mouse is over them. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."
	owner hasMouseFocus ifFalse: [ ^self ].
	"This will happen if the menu has toggles in it. (for instance, the 'show...' button)
	Update the look, refresh the world and wait a bit,
	to give the user some visual feedback"
	contentString ifNotNil: [
		self contents: contentString withMarkers: true inverse: true.
		self refreshWorld.
		(Delay forMilliseconds: 200) wait].
	self deselect.
	self invokeWithEvent: aMouseButtonEvent! !
!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'jmv 5/1/2018 01:14:34' prior: 16940489!
     updateContents
	"Update the receiver's contents"

	| newString enablement nArgs |
	((wordingProvider isNil) or: [wordingSelector isNil]) ifFalse: [
		nArgs _ wordingSelector numArgs.
		newString _ nArgs = 0
			ifTrue: [
				wordingProvider perform: wordingSelector]
			ifFalse: [
				(nArgs = 1 and: [wordingArgument notNil])
					ifTrue: [
						wordingProvider perform: wordingSelector with: wordingArgument]
					ifFalse: [
						nArgs = arguments size ifTrue: [
							wordingProvider perform: wordingSelector withArguments: arguments]]].
		newString = (contentString ifNil: [ contents ])
			ifFalse: [
				self contents: newString.
				Theme current decorateMenu: owner ]].
	enablementSelector ifNotNil: [
		(enablement _ self enablement) == isEnabled 
			ifFalse:	[self isEnabled: enablement]]! !

MenuItemMorph removeSelector: #contentString!

MenuItemMorph removeSelector: #contentString!

MenuItemMorph removeSelector: #contentString:!

MenuItemMorph removeSelector: #contentString:!

StringMorph subclass: #MenuItemMorph
	instanceVariableNames: 'isEnabled subMenu isSelected target selector arguments icon contentString'
	classVariableNames: 'SubMenuMarker'
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuItemMorph category: #'Morphic-Menus'!
StringMorph subclass: #MenuItemMorph
	instanceVariableNames: 'isEnabled subMenu isSelected target selector arguments icon contentString'
	classVariableNames: 'SubMenuMarker'
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3299-BigMenuRefactor-p2-JuanVuletich-2018May01-01h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3296] on 1 May 2018 at 1:26:50 am'!
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2018 01:22:28'!
                            addBlankIconsIfNecessary
	"If any of my items have an icon, ensure that all do by using anIcon for those that don't"

	| withIcons withoutIcons blankIcon |
	withIcons _ Set new.
	withoutIcons _ Set new.
	self items do: [ :item |
		item hasIcon | item hasMarker
			ifTrue: [ withIcons add: item ]
			ifFalse: [ withoutIcons add: item ].
		item hasSubMenu ifTrue: [ item subMenu addBlankIconsIfNecessary ]].
	(withIcons isEmpty or: [ withoutIcons isEmpty ]) ifTrue: [ ^self ].
	blankIcon _ Theme current blankIcon.
	withoutIcons do: [ :item | item set_icon: blankIcon ].! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2018 01:20:01'!
                             contentsWithMarkers: aString inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	contentString _ nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	icon _ nil.
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString _ aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 4/30/2018 20:54:05'!
 set_icon: aForm 
	"change the the receiver's icon"
	icon := aForm! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 4/30/2018 21:04:03' prior: 16866372!
    add: aString subMenu: aMenuMorph
	"Append the given submenu with the given label."

	| item |
	item _ MenuItemMorph new.
	item
		contents: aString;
		subMenu: aMenuMorph.
	self addMorphBack: item! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 4/30/2018 21:04:08' prior: 16866410!
  add: aString target: target selector: aSymbol argumentList: argList
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  Answer the appended menu item."

	| item |
	item _ MenuItemMorph new
		contents: aString;
		target: target;
		selector: aSymbol;
		arguments: argList asArray.
	self addMorphBack: item.
	^ item! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 4/30/2018 20:51:33' prior: 50384912!
                           popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	self addBlankIconsIfNecessary.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 4/30/2018 20:51:37' prior: 50384937!
      popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	self addBlankIconsIfNecessary.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2018 01:19:11' prior: 16865789!
              contents: aString
	^self contentsWithMarkers: aString inverse: false! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 5/1/2018 01:19:31' prior: 50392158!
    mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event. Menu items get activated when the mouse is over them. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."
	owner hasMouseFocus ifFalse: [ ^self ].
	"This will happen if the menu has toggles in it. (for instance, the 'show...' button)
	Update the look, refresh the world and wait a bit,
	to give the user some visual feedback"
	contentString ifNotNil: [
		self contentsWithMarkers: contentString inverse: true.
		self refreshWorld.
		(Delay forMilliseconds: 200) wait].
	self deselect.
	self invokeWithEvent: aMouseButtonEvent! !
!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'jmv 5/1/2018 01:24:02' prior: 50392183!
            updateContents
	"Update the receiver's contents"

	| newString enablement nArgs |
	((wordingProvider isNil) or: [wordingSelector isNil]) ifFalse: [
		nArgs _ wordingSelector numArgs.
		newString _ nArgs = 0
			ifTrue: [
				wordingProvider perform: wordingSelector]
			ifFalse: [
				(nArgs = 1 and: [wordingArgument notNil])
					ifTrue: [
						wordingProvider perform: wordingSelector with: wordingArgument]
					ifFalse: [
						nArgs = arguments size ifTrue: [
							wordingProvider perform: wordingSelector withArguments: arguments]]].
		newString = (contentString ifNil: [ contents ])
			ifFalse: [
				self contents: newString ]].
	enablementSelector ifNotNil: [
		(enablement _ self enablement) == isEnabled 
			ifFalse:	[self isEnabled: enablement]]! !
!Theme methodsFor: 'accessing' stamp: 'jmv 4/30/2018 20:56:48' prior: 16936767!
                    decorateMenu: aMenu

	"decorate aMenu with icons"

	self flag: #todo. "Do I really belong on Theme, and not some menu class somewhere?"

	menuItemIcons ifEmpty: [
		^ self ].

	aMenu items do: [ :item | 
		| decoration |
		decoration _ menuItemIcons 
			at: item contents asString asLowercase 
			ifAbsent: nil.

		decoration ifNotNil: [
			item set_icon: decoration ]]! !

MenuItemMorph removeSelector: #contents:withMarkers:!

MenuItemMorph removeSelector: #contents:withMarkers:!

MenuItemMorph removeSelector: #contents:withMarkers:inverse:!

MenuItemMorph removeSelector: #contents:withMarkers:inverse:!

MenuItemMorph removeSelector: #icon:!

MenuItemMorph removeSelector: #icon:!

MenuMorph removeSelector: #addBlankIconsIfNecessary:!

MenuMorph removeSelector: #addBlankIconsIfNecessary:!

MenuMorph removeSelector: #addWithLabel:enablement:action:!

MenuMorph removeSelector: #addWithLabel:enablement:action:!

MenuMorph removeSelector: #addWithLabel:enablementSelector:target:selector:argumentList:!

MenuMorph removeSelector: #addWithLabel:enablementSelector:target:selector:argumentList:!

MenuMorph removeSelector: #defaultTarget!

MenuMorph removeSelector: #defaultTarget!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3300-BigMenuRefactor-p3-JuanVuletich-2018May01-01h15m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3296] on 1 May 2018 at 1:29:48 am'!

MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector enablementSelector wordingArgument '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #UpdatingMenuItemMorph category: #'Morphic-Menus'!
MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector enablementSelector wordingArgument'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'jmv 4/30/2018 21:36:20' prior: 50392404!
            updateContents
	"Update the receiver's contents"

	| newString enablement nArgs |
	((wordingProvider isNil) or: [wordingSelector isNil]) ifFalse: [
		nArgs _ wordingSelector numArgs.
		newString _ nArgs = 0
			ifTrue: [
				wordingProvider perform: wordingSelector]
			ifFalse: [
				nArgs = arguments size ifTrue: [
					wordingProvider perform: wordingSelector withArguments: arguments]].
		newString = (contentString ifNil: [ contents ])
			ifFalse: [
				self contents: newString ]].
	enablementSelector ifNotNil: [
		(enablement _ self enablement) == isEnabled 
			ifFalse:	[self isEnabled: enablement]]! !

UpdatingMenuItemMorph removeSelector: #wordingArgument:!

UpdatingMenuItemMorph removeSelector: #wordingArgument:!

MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector enablementSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #UpdatingMenuItemMorph category: #'Morphic-Menus'!
MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector enablementSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3301-BigMenuRefactor-p4-JuanVuletich-2018May01-01h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3300] on 1 May 2018 at 10:29:54 am'!
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 4/30/2018 21:22:56'!
           setBlankIcon
	"change the the receiver's icon"
	icon := Theme current blankIcon! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 4/30/2018 21:26:57'!
     target: anObject selector: aSymbol arguments: aCollection

	target _ anObject.
	selector _ aSymbol.
	arguments _ aCollection! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2018 10:27:02' prior: 50392240!
             addBlankIconsIfNecessary
	"If any of my items have an icon, ensure that all do by using anIcon for those that don't"

	| withIcons withoutIcons |
	withIcons _ Set new.
	withoutIcons _ Set new.
	self items do: [ :item |
		item hasIcon | item hasMarker
			ifTrue: [ withIcons add: item ]
			ifFalse: [ withoutIcons add: item ].
		item hasSubMenu ifTrue: [ item subMenu addBlankIconsIfNecessary ]].
	(withIcons isEmpty or: [ withoutIcons isEmpty ]) ifTrue: [ ^self ].
	withoutIcons do: [ :item | item setBlankIcon ]! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:15:20' prior: 50392307!
      add: aString target: target selector: aSymbol argumentList: argList
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  Answer the appended menu item."

	| item |
	item _ MenuItemMorph new
		contents: aString;
		target: target selector: aSymbol arguments: argList asArray.
	self addMorphBack: item.
	^ item! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:15:48' prior: 16866555!
                             addUpdating: wordingSelector target: target selector: aSymbol argumentList: argList
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  In this variant, the wording of the menu item is obtained by sending the wordingSelector to the target,  Answer the item added."

	| item |
	item _ UpdatingMenuItemMorph new
		target: target selector: aSymbol arguments: argList asArray;
		wordingProvider: target wordingSelector: wordingSelector.
	self addMorphBack: item.
	^ item! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2018 10:23:05' prior: 50392261!
                            contentsWithMarkers: aString inverse: inverse 
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString _ nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	icon _ nil.
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString _ aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 5/1/2018 10:25:29' prior: 50385249!
      drawOn: aCanvas 
	| stringColor leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: (`0@0` extent: extent) color: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	icon ifNotNil: [
		| iconForm | 
		iconForm _ isEnabled ifTrue: [ icon ] ifFalse: [ icon asGrayScaleAndTransparent ].
		aCanvas image: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
		leftEdge _ leftEdge + iconForm width + self iconSeparation].

	aCanvas
		drawString: contents
		at: leftEdge @ 1
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			image: self class subMenuMarker
			at: extent x - 8 @ (extent y - self class subMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'layout' stamp: 'jmv 5/1/2018 10:25:03' prior: 16866123!
                       minItemWidth
	| fontToUse iconWidth subMenuWidth markerWidth |
	fontToUse _ self fontToUse.
	subMenuWidth _ self hasSubMenu
				ifFalse: [0]
				ifTrue: [10].
	iconWidth _ icon
				ifNotNil: [icon width + self iconSeparation]
				ifNil: [0].
	markerWidth _ self hasMarker
		ifTrue: [ submorphs first morphWidth + 8 ]
		ifFalse: [ 0 ].
	^ (fontToUse widthOfString: contents)
		+ subMenuWidth + iconWidth + markerWidth.! !

MenuItemMorph removeSelector: #arguments!

MenuItemMorph removeSelector: #arguments!

MenuItemMorph removeSelector: #arguments:!

MenuItemMorph removeSelector: #arguments:!

MenuItemMorph removeSelector: #icon!

MenuItemMorph removeSelector: #icon!

MenuItemMorph removeSelector: #selector!

MenuItemMorph removeSelector: #selector!

MenuItemMorph removeSelector: #selector:!

MenuItemMorph removeSelector: #selector:!

MenuItemMorph removeSelector: #target!

MenuItemMorph removeSelector: #target!

MenuItemMorph removeSelector: #target:!

MenuItemMorph removeSelector: #target:!

MenuMorph removeSelector: #target:!

MenuMorph removeSelector: #target:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3302-BigMenuRefactor-p5-JuanVuletich-2018May01-10h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3300] on 1 May 2018 at 10:51:01 am'!
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/1/2018 10:35:14' prior: 16800084!
         changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu isForBaseSystem |
	isForBaseSystem _ model changeSet isForBaseSystem.
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	(aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove) 	isEnabled: isForBaseSystem.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	(aMenu add: 'Rename change set (r)' 			action: #rename) 					isEnabled: isForBaseSystem.
	(aMenu add: 'Destroy change set (x)' 			action: #remove) 					isEnabled: isForBaseSystem.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 	action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' target: self action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	(aMenu add: 'trim history' action: #trimHistory) 								isEnabled: isForBaseSystem.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:43:21' prior: 16866322!
                              add: aString action: aSymbol
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."
	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."

	^self add: aString
		target: defaultTarget
		selector: aSymbol
		argumentList: #()! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:44:00' prior: 16866365!
 add: aString selector: aSymbol argument: arg

	^self add: aString
		target: defaultTarget
		selector: aSymbol
		argumentList: (Array with: arg)
! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:44:36' prior: 50392298!
                      add: aString subMenu: aMenuMorph
	"Append the given submenu with the given label."

	| item |
	item _ MenuItemMorph new.
	item
		contents: aString;
		subMenu: aMenuMorph.
	self addMorphBack: item.
	^item! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:44:10' prior: 16866381!
                           add: aString target: aTarget action: aSymbol
	^self add: aString
		target: aTarget
		selector: aSymbol
		argumentList: #()! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:44:15' prior: 16866388!
            add: aString target: anObject selector: aSymbol
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object."

	^self add: aString
		target: anObject
		selector: aSymbol
		argumentList: #()! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:48:29' prior: 16866398!
            add: aString target: target selector: aSymbol argument: arg
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given argument."

	^self add: aString
		target: target
		selector: aSymbol
		argumentList: { arg }! !
!CustomMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:47:21' prior: 16826787!
     addList: listOfTuplesAndDashes
	"Add a menu item to the receiver for each tuple in the given list of the form (<what to show> <selector>). Add a line for each dash (-) in the list."

	listOfTuplesAndDashes do: [:aTuple |
		aTuple == #-
			ifTrue: [self addLine]
			ifFalse: [self add: aTuple first action: aTuple second]]

	"
	CustomMenu new addList: #(
		('apples' buyApples)
		('oranges' buyOranges)
		-
		('milk' buyMilk)); startUpMenu
	"

! !

CustomMenu removeSelector: #add:target:selector:!

CustomMenu removeSelector: #add:target:selector:!

CustomMenu removeSelector: #add:target:selector:argument:!

CustomMenu removeSelector: #add:target:selector:argument:!

CustomMenu removeSelector: #add:target:selector:argumentList:!

CustomMenu removeSelector: #add:target:selector:argumentList:!

CustomMenu removeSelector: #addStayUpIcons!

CustomMenu removeSelector: #addStayUpIcons!

MenuMorph removeSelector: #add:action:enabled:!

MenuMorph removeSelector: #add:action:enabled:!

MenuMorph removeSelector: #add:target:selector:arguments:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3303-BigMenuRefactor-p6-JuanVuletich-2018May01-10h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3300] on 1 May 2018 at 11:01:26 am'!
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:59:27'!
   add: aString target: target action: aSymbol argument: arg
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given argument."

	^self add: aString
		target: target
		action: aSymbol
		argumentList: { arg }! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:58:49'!
                          add: aString target: target action: aSymbol argumentList: argList
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  Answer the appended menu item."

	| item |
	item _ MenuItemMorph new
		contents: aString;
		target: target selector: aSymbol arguments: argList asArray.
	self addMorphBack: item.
	^ item! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:58:11'!
               addUpdating: wordingSelector target: target action: aSymbol argumentList: argList
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  In this variant, the wording of the menu item is obtained by sending the wordingSelector to the target,  Answer the item added."

	| item |
	item _ UpdatingMenuItemMorph new
		target: target selector: aSymbol arguments: argList asArray;
		wordingProvider: target wordingSelector: wordingSelector.
	self addMorphBack: item.
	^ item! !
!SimpleServiceEntry methodsFor: 'services menu' stamp: 'jmv 5/1/2018 10:55:06' prior: 16907962!
                     addServiceFor: served toMenu: aMenu
	argumentProvider _ served.
	aMenu add: self label 
		target: self 
		action: #performService.
	self useLineAfter ifTrue: [ aMenu addLine ].! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 5/1/2018 11:00:03' prior: 16795021!
                  openMorphicWindowForSuspendedProcess: aProcess
	| menu rule |
	menu _ MenuMorph new.
	"nickname  allow-stop  allow-debug"
	rule _ (ProcessBrowser rulesFor: aProcess) second.
	menu add: 'Dismiss this menu' target: menu action: #delete; addLine.
	menu add: 'Open Process Browser' target: ProcessBrowserWindow action: #openProcessBrowser.
	menu add: 'Resume'
		target: self
		action: #resumeProcess:fromMenu:
		argumentList: { aProcess . menu }.
	menu add: 'Terminate'
		target: self
		action: #terminateProcess:fromMenu:
		argumentList: { aProcess . menu }.
	rule ifTrue: [
		menu add: 'Debug at a lower priority'
			target: self
			action: #debugProcess:fromMenu:
			argumentList: { aProcess . menu }.
	].
	menu addTitle: aProcess identityHash asString,
		' ', aProcess name,
		' is taking too much time and has been suspended.
What do you want to do with it?'.
	menu stayUp.
	menu popUpInWorld
! !
!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 5/1/2018 10:56:07' prior: 16777431!
                         fromUser: priorFont
	"
	AbstractFont fromUser
	"
	"Present a menu of available fonts, and if one is chosen, return it.
	Otherwise return nil.
	Show only baseFonts i.e. FamilyName, pointSize (but do not include emphasis, such as italic or bold)"

	| fontList fontMenu active ptMenu label spec |
	fontList := AbstractFont familyNames.
	fontMenu := MenuMorph new defaultTarget: self.
	fontList do: [:fontName | 
			active := priorFont familyName sameAs: fontName.
			ptMenu := MenuMorph new defaultTarget: self.
			(AbstractFont pointSizesFor:fontName ) do: [ :pt | 
					(active and: [pt = priorFont pointSize]) 
						ifTrue: [label := '<on>']
						ifFalse: [label := '<off>'].
					label := label , pt printString , ' pt'.
					ptMenu 
						add: label
						target: fontMenu
						action: #modalSelection:
						argument: { 
								fontName.
								pt}].
			active ifTrue: [label := '<on>'] ifFalse: [label := '<off>'].
			label := label , fontName.
			fontMenu add: label subMenu: ptMenu].
	spec := fontMenu invokeModal.
	spec ifNil: [^nil].
	^AbstractFont familyName: spec first pointSize: spec last! !
!Morph methodsFor: 'debug and other' stamp: 'jmv 5/1/2018 10:55:33' prior: 50376318!
                      buildDebugMenu: aHand 
	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"

	| aMenu |
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addStayUpIcons.
	self isKnownFailing
		ifTrue: [
			aMenu add: 'start drawing again' action: #resumeAfterDrawError.
			aMenu addLine].
	(self hasProperty: #errorOnStep) 
		ifTrue: [
			aMenu add: 'start stepping again' action: #resumeAfterStepError.
			aMenu addLine].
	aMenu add: 'inspect morph' action: #inspect.
	aMenu add: 'inspect owner chain' action: #inspectOwnerChain.
	self hasModel 
		ifTrue: [
			aMenu 
				add: 'inspect model'
				target: self model
				action: #inspect].
	aMenu 
		add: 'explore morph'
		target: self
		action: #explore.
	aMenu 
		add: 'copy to clipboard (c)'
		target: self
		action: #copyToClipboard.
	aMenu addLine.
	aMenu 
		add: 'browse morph class'
		target: self
		action: #browseClassHierarchy.
	self hasModel 
		ifTrue: [
			aMenu 
				add: 'browse model class'
				target: self model
				action: #browseClassHierarchy].
	aMenu addLine.
	aMenu
		add: 'edit balloon help' action: #editBalloonHelpText.
	^aMenu! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 5/1/2018 10:59:32' prior: 16876336!
           addEmbeddingMenuItemsTo: aMenu hand: aHandMorph
	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self potentialEmbeddingTargets reverseDo: [:m | 
		menu 
			add: m class name asString 
			target: m 
			action: #addMorphFrontFromWorldPosition: 
			argumentList: {self}].
	aMenu ifNotNil:[
		menu submorphCount > 0 
			ifTrue:[aMenu add:'embed into' subMenu: menu].
	].
	^menu! !
!ObjectExplorerWindow methodsFor: 'building menus' stamp: 'jmv 5/1/2018 10:56:13' prior: 50376392!
                              genericMenu
	"Borrow a menu from my inspector"
	
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	model getCurrentSelection
		ifNil: [
			aMenu
				add: '*nothing selected*'
				target: self
				action: #yourself]
		ifNotNil: [
			aMenu addList: #(
				('inspect (i)'							inspectSelection)
				('explore (I)'							exploreSelection)
				('copy to clipboard (c)'				copySelectionToClipboard)
				('basic inspect'						inspectBasic)
				('references finder'					openReferencesFinder)
				('weight explorer'					openWeightExplorer)
				-
				('browse full (b)'						browseMethodFull)
				('browse hierarchy (h)'				browseHierarchy)
				('browse protocol (p)'				browseFullProtocol)).
			aMenu addLine;
				add: 'monitor changes'
				target: self
				action: #monitor:
				argument: model getCurrentSelection.
			model class == ReferencesExplorer ifTrue: [
				aMenu addLine;
					add: 'rescan'
					target: self
					action: #rescan ]].
	model basicMonitorList isEmptyOrNil
		ifFalse: [
			aMenu addLine;
				add: 'stop monitoring all'
				target: self
				action: #stopMonitoring ].
	^ aMenu! !
!TestRunnerWindow methodsFor: 'menu building' stamp: 'jmv 5/1/2018 10:56:21' prior: 16928753!
                    listMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu title: 'Test Cases'.
	aMenu add: 'select all' target: model action: #selectAll.
	aMenu add: 'deselect all' target: model action: #deselectAll.
	aMenu add: 'toggle selections' target: model action: #invertSelections.
	aMenu add: 'filter' target: model action: #setFilter.
	model runButtonState ifTrue: [
		aMenu add: 'stop' target: model action: #terminateRun
		].
	model selectedSuite > 0 ifTrue: [ | cls |
		cls _ (model tests at: model selectedSuite ifAbsent: ['']) copyUpTo: Character space.
		cls _ cls asSymbol.
		cls _ (Smalltalk at: cls ifAbsent: nil).
		cls ifNotNil: [
			aMenu addLine.
			aMenu add: 'browse' target: self action: #browse: argument: cls.
		].
	].
	aMenu addLine.
	aMenu add: 'log to Transcript' target: model action: #showResult.
	^aMenu! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:59:08' prior: 50392790!
    add: aString action: aSymbol
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."
	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."

	^self add: aString
		target: defaultTarget
		action: aSymbol
		argumentList: #()! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:59:21' prior: 50392811!
   add: aString selector: aSymbol argument: arg

	^self add: aString
		target: defaultTarget
		action: aSymbol
		argumentList: { arg }! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:59:24' prior: 50392829!
   add: aString target: aTarget action: aSymbol
	^self add: aString
		target: aTarget
		action: aSymbol
		argumentList: #()! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:58:24' prior: 16866541!
              addUpdating: aWordingSelector action: aSymbol

	self addUpdating: aWordingSelector target: defaultTarget action: aSymbol argumentList: #()! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:58:30' prior: 16866548!
                            addUpdating: aWordingSelector target: aTarget action: aSymbol

	self addUpdating: aWordingSelector target: aTarget action: aSymbol argumentList: #()! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:56:28' prior: 50343966!
               alphabeticalMorphMenu
	| list splitLists menu firstChar lastChar subMenu |
	list := Morph withAllSubclasses select: [ :m |
		m includeInNewMorphMenu ].
	list := list asArray sort: [ :c1 :c2 |
		c1 name < c2 name ].
	splitLists := self
		splitNewMorphList: list
		depth: 4.
	menu := MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstChar := i = 1
				ifTrue: [ $A ]
				ifFalse: [ 
					(splitLists at: i) first name first: 3 ].
			lastChar := i = splitLists size
				ifTrue: [ $Z ]
				ifFalse: [ 
					(splitLists at: i) last name first: 3 ].
			subMenu := MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					action: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: firstChar asString , ' - ' , lastChar asString
				subMenu: subMenu ].
	^ menu.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:59:35' prior: 16934888!
                           fillIn: aMenu from: dataForMenu
	"A menu constructor utility by RAA.  dataForMenu is a list of items which mean:
			nil								Indicates to add a line

			first element is symbol		Add updating item with the symbol as the wording selector
			second element is a list		second element has the receiver and selector

			first element is a string		Add menu item with the string as its wording
			second element is a list		second element has the receiver and selector

			a third element exists			Use it as the balloon text
			a fourth element exists		Use it as the enablement selector (updating case only)"

	| item |

	dataForMenu do: [ :itemData |
		itemData ifNil: [aMenu addLine] ifNotNil: [
			item _ itemData first isSymbol
				ifTrue: [
					aMenu 
						addUpdating: itemData first 
						target: self 
						action: #doMenuItem:with: 
						argumentList: {itemData second}]
				 ifFalse: [
					aMenu 
						add: itemData first
						target: self 
						action: #doMenuItem:with: 
						argumentList: {itemData second}].
			itemData size >= 3 ifTrue: [
				aMenu balloonTextForLastItem: itemData third.
			itemData size >= 4 ifTrue: [
				item enablementSelector: itemData fourth ]]]].

	^ aMenu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:59:42' prior: 16934928!
                    fillIn: aMenu fromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text

	note, nil elements will add a line."
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ aMenu addLine ]
			ifNotNil: [
				(dict at: #label) isSymbol
					ifTrue: [
						aMenu
							addUpdating: (dict at: #label)
							target: (dict at: #object)
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						aMenu
							add: (dict at: #label)
							target: (dict at: #object)
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						aMenu balloonTextForLastItem: balloonText ]]].
	^ aMenu.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 10:56:32' prior: 50344234!
            newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu subMenu catDict |
	menu _ self menu: 'Add a new morph'.
	menu
		
			add: 'From Clipboard'
			target: myHand
			action: #pasteMorph;
		
			add: 'From Alphabetical List'
			subMenu: self alphabeticalMorphMenu.
	menu addLine.
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.

	Morph allSubclassesDo: [ :eaSubclass |
		eaSubclass includeInNewMorphMenu ifTrue: [ | category |
			(eaSubclass respondsTo: #categoryInNewMorphMenu)
				ifTrue: [ category _ eaSubclass categoryInNewMorphMenu ]
				ifFalse: [ category _ 'Unknown' ].
			(catDict includesKey: category)
				ifTrue: [ (catDict at: category) add: eaSubclass ]
				ifFalse: [
					catDict
						at: category
						put: (OrderedCollection with: eaSubclass) ]]].
	catDict keys sort do: [ :categ |
		subMenu _ MenuMorph new.
		((catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ]) do: [ :cl |
			subMenu
				add: cl name
				target: self
				action: #newMorphOfClass:event:
				argument: cl ].
		menu
			add: categ
			subMenu: subMenu ].
	self doPopUp: menu.! !

MenuMorph removeSelector: #add:target:selector:!

MenuMorph removeSelector: #add:target:selector:!

MenuMorph removeSelector: #add:target:selector:argument:!

MenuMorph removeSelector: #add:target:selector:argument:!

MenuMorph removeSelector: #add:target:selector:argumentList:!

MenuMorph removeSelector: #add:target:selector:argumentList:!

MenuMorph removeSelector: #addUpdating:target:selector:argumentList:!

MenuMorph removeSelector: #addUpdating:target:selector:argumentList:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3304-BigMenuRefactor-p7-JuanVuletich-2018May01-10h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3303] on 1 May 2018 at 12:46:35 pm'!
!Morph methodsFor: 'menus' stamp: 'jmv 5/1/2018 11:26:39' prior: 16876165!
                               addHaloActionsTo: aMenu 
	"Add items to aMenu representing actions requestable via halo"

	| subMenu |
	subMenu := MenuMorph new defaultTarget: self.
	subMenu addTitle: (self printStringLimitedTo: 40).
	subMenu addStayUpIcons.
	subMenu addLine.
	(subMenu add: 'delete' action: #dismissViaHalo)
		setBalloonText: 'Delete this object -- warning -- can be destructive!!' .
	self maybeAddCollapseItemTo: subMenu.
	(subMenu add: 'grab' action: #openInHand)
		setBalloonText: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' .
	subMenu addLine.
	(subMenu add: 'resize' action: #resizeFromMenu)
		setBalloonText: 'Change the size of this object'.
	(subMenu add: 'duplicate' action: #maybeDuplicateMorph)
		setBalloonText: 'Hand me a copy of this object'.
	(subMenu
		add: 'set color'
		target: self
		action: #changeColor)
			setBalloonText: 'Change the color of this object'.
	(subMenu
		add: 'inspect'
		target: self
		action: #inspect)
			setBalloonText: 'Open an Inspector on this object'.
	aMenu add: 'halo actions...' subMenu: subMenu! !
!Morph methodsFor: 'menus' stamp: 'jmv 5/1/2018 11:26:53' prior: 16876246!
                addToggleItemsToHaloMenu: aMenu
	"Add standard true/false-checkbox items to the memu"

	#(
		(stickinessString toggleStickiness 'whether I should be resistant to a drag done by mousing down on me')
		(lockedString lockUnlockMorph 'when "locked", I am inert to all user interactions')
	) do: [ :trip | 
			(aMenu addUpdating: trip first action: trip second)
				setBalloonText: trip third ]! !
!CodeWindow methodsFor: 'menu building' stamp: 'jmv 5/1/2018 11:24:50' prior: 16813594!
                               addContentsTogglesTo: aMenu
	"Add updating menu toggles governing contents to aMenu."

	model contentsSymbolQuints do: [ :aQuint |
			aQuint == #-
				ifTrue: [
					aMenu addLine]
				ifFalse: [
					(aMenu addUpdating: aQuint third target: model action: aQuint second)
						setBalloonText: aQuint fifth ]]! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/1/2018 11:24:14' prior: 50392723!
        changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu isForBaseSystem |
	isForBaseSystem _ model changeSet isForBaseSystem.
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	(aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove) 	isEnabled: isForBaseSystem.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	(aMenu add: 'Rename change set (r)' 			action: #rename) 					isEnabled: isForBaseSystem.
	(aMenu add: 'Destroy change set (x)' 			action: #remove) 					isEnabled: isForBaseSystem.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 	action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	(aMenu add: 'conflicts with other change sets' target: self action: #browseMethodConflicts)
		setBalloonText: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	(aMenu add: 'trim history' action: #trimHistory)
		isEnabled: isForBaseSystem;
		setBalloonText: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	(aMenu add: 'view affected class categories' action: #viewAffectedClassCategories)
		setBalloonText: ' Show class categories affected by any contained change'.

	^ aMenu! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 11:25:14' prior: 16866439!
         addList: aList
	"Add the given items to this menu, where each item is a pair (<string> <actionSelector>)..  If an element of the list is simply the symobl $-, add a line to the receiver.  The optional third element of each entry, if present, provides balloon help."

	| target item |
	aList do: [:tuple |
		tuple == #-
			ifTrue: [ self addLine ]
			ifFalse: [
				target _ tuple size > 3
					ifTrue: [ defaultTarget perform: tuple fourth ]
					ifFalse: [ defaultTarget ].
				item _ self add: tuple first target: target action: tuple second.
				tuple size > 2 ifTrue: [
					item setBalloonText: tuple third]]]! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 11:24:38' prior: 50393195!
addUpdating: aWordingSelector action: aSymbol

	^self addUpdating: aWordingSelector target: defaultTarget action: aSymbol argumentList: #()! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/1/2018 11:24:33' prior: 50393203!
                           addUpdating: aWordingSelector target: aTarget action: aSymbol

	^self addUpdating: aWordingSelector target: aTarget action: aSymbol argumentList: #()! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 12:45:58' prior: 50393241!
              fillIn: aMenu from: dataForMenu
	"A menu constructor utility by RAA.  dataForMenu is a list of items which mean:
			nil								Indicates to add a line

			first element is symbol		Add updating item with the symbol as the wording selector
			second element is a list		second element has the receiver and selector

			first element is a string		Add menu item with the string as its wording
			second element is a list		second element has the receiver and selector

			a third element exists			Use it as the balloon text
			a fourth element exists		Use it as the enablement selector (updating case only)"

	| item |

	dataForMenu do: [ :itemData |
		itemData ifNil: [aMenu addLine] ifNotNil: [
			item _ aMenu
				add: itemData first
				target: self 
				action: #doMenuItem:with: 
				argumentList: {itemData second}.
			itemData size >= 3 ifTrue: [
				item setBalloonText: itemData third.
			itemData size >= 4 ifTrue: [
				item enablementSelector: itemData fourth ]]]].

	^ aMenu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 11:27:29' prior: 50393282!
             fillIn: aMenu fromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text

	note, nil elements will add a line."
	| item |
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ aMenu addLine ]
			ifNotNil: [
				item _ (dict at: #label) isSymbol
					ifTrue: [
						aMenu
							addUpdating: (dict at: #label)
							target: (dict at: #object)
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						aMenu
							add: (dict at: #label)
							target: (dict at: #object)
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ]]].
	^ aMenu! !

CustomMenu removeSelector: #balloonTextForLastItem:!

CustomMenu removeSelector: #balloonTextForLastItem:!

MenuMorph removeSelector: #balloonTextForLastItem:!

MenuMorph removeSelector: #balloonTextForLastItem:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3305-BigMenuRefactor-p8-JuanVuletich-2018May01-12h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3304] on 1 May 2018 at 9:11:14 pm'!
!Collection methodsFor: 'converting' stamp: 'jmv 5/1/2018 14:28:51'!
  asDictionary
	"Answer a Dictionary. Assume our elements are Associations.
	{
			#itemGroup 	-> 	10.
			#itemOrder 	-> 	30.
			#label 			-> 	'Browser'.
			#object 		-> 	BrowserWindow.
			#selector 		-> 	#openBrowser.
			#icon 			-> #editFindReplaceIcon.
			#balloonText 	-> 	'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary
	"

	^ self as: Dictionary! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2018 14:17:12'!
                     setIcon: symbolOrFormOrNil
	"Argument can be a Form, a Symbol (to be sent to Theme current) or nil."

	icon _ symbolOrFormOrNil isSymbol
		ifTrue: [Theme current perform: symbolOrFormOrNil]
		ifFalse: [ symbolOrFormOrNil ]! !
!Workspace class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:07:43' prior: 16945473!
    worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		20.
			#label 			->		'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary`! !
!Transcripter class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:06:41' prior: 16938956!
                           worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		30.
			#itemOrder 	-> 		20.
			#label 			->		'Emergency Evaluator'.
			#object 			-> 		Transcripter.
			#selector 		-> 		#emergencyEvaluator.
			#icon 			-> 		#emblemImportantIcon.
			#balloonText 	-> 		'When all else fails...'.
		} asDictionary`! !
!TextEditor class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:04:48' prior: 16933249!
                           worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		10.
			#label 			->		'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary`! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 14:38:08' prior: 16811663!
                              worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		20.
			#itemOrder 	-> 		10.
			#label 			->		'Installed Packages'.
			#object 			-> 		CodePackageListWindow.
			#selector 		-> 		#openPackageList.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary`! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 14:36:38' prior: 16793528!
    worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		30.
			#label 			->		'Browser'.
			#object 			-> 		BrowserWindow.
			#selector 		-> 		#openBrowser.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary`! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:01:20' prior: 16867850!
                            worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		40.
			#label 			->		'Message Names'.
			#object 			-> 		MessageNamesWindow.
			#selector 		-> 		#openMessageNames.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary`! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 14:36:47' prior: 16800316!
                              worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		20.
			#itemOrder 	-> 		20.
			#label 			->		'Change Sorter'.
			#object 			-> 		ChangeSorterWindow.
			#selector 		-> 		#openChangeSorter.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:00:10' prior: 16843460!
                     worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		40.
			#itemOrder 	-> 		10.
			#label 			->		'File List'.
			#object 			-> 		FileListWindow.
			#selector 		-> 		#openFileList.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:02:47' prior: 16895580!
                     worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		30.
			#itemOrder 	-> 		10.
			#label 			->		'Process Browser'.
			#object 			-> 		ProcessBrowserWindow.
			#selector 		-> 		#openProcessBrowser.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:03:55' prior: 16928799!
                         worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		40.
			#itemOrder 	-> 		20.
			#label 			->		'SUnit Test Runner'.
			#object 			-> 		TestRunnerWindow.
			#selector 		-> 		#openTestRunner.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'jmv 5/1/2018 21:05:41' prior: 16938780!
              worldMenuForOpenGroup
	^ `{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		50.
			#label 			->		'Transcript'.
			#object 			-> 		TranscriptWindow.
			#selector 		-> 		#openTranscript.
			#icon 			-> 		#printerIcon.
			#balloonText 	-> 		'A window showing contents of the System Transcript'.
		} asDictionary`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 14:18:59' prior: 50393589!
                  fillIn: aMenu fromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item |
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ aMenu addLine ]
			ifNotNil: [
				item _ (dict at: #label) isSymbol
					ifTrue: [
						aMenu
							addUpdating: (dict at: #label)
							target: (dict at: #object)
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						aMenu
							add: (dict at: #label)
							target: (dict at: #object)
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				dict
					at: #icon
					ifPresent: [ :symbolOrFormOrNil |
						item setIcon: symbolOrFormOrNil ].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]].
	^ aMenu! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3306-BigMenuRefactor-p9-JuanVuletich-2018May01-21h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3306] on 2 May 2018 at 2:33:08 pm'!
!TheWorldMenu methodsFor: 'popups' stamp: 'jmv 5/1/2018 21:47:43'!
     openChangesMenu
	"Build the changes menu for the world."

	self doPopUp: self changesMenu! !
!TheWorldMenu methodsFor: 'popups' stamp: 'jmv 5/1/2018 21:48:18'!
openDebugMenu

	self doPopUp: self debugMenu! !
!TheWorldMenu methodsFor: 'popups' stamp: 'jmv 5/1/2018 21:45:28'!
             openHelpMenu
	"Build and show the help menu for the world."

	self doPopUp: self helpMenu! !
!TheWorldMenu methodsFor: 'popups' stamp: 'jmv 5/1/2018 21:30:15'!
openOpenMenu

	self doPopUp: self openMenu! !
!TheWorldMenu methodsFor: 'popups' stamp: 'jmv 5/1/2018 21:43:44'!
               openPreferencesMenu
	"Build and show the preferences menu for the world."

	self doPopUp: self preferencesMenu! !
!TheWorldMenu methodsFor: 'popups' stamp: 'jmv 5/1/2018 21:45:06'!
           openWindowsMenu
	"Build the windows menu for the world."

	self doPopUp: self windowsMenu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/2/2018 14:32:47' prior: 50379975!
          buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	menu addStayUpIcons.
	self
		fillIn: menu
		fromDictionaries: `{
				{
					#label 			-> 		'Open...'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#openOpenMenu.
					#icon 			-> 		#openIcon.
					#balloonText 	-> 		'Submenu to open various system tools'.
				} asDictionary.
				{
					#label 			-> 		'New morph...'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#newMorph.
					#icon 			-> 		#morphsIcon.
					#balloonText 	-> 		'Offers a variety of ways to create new objects'.
				} asDictionary.
				{
					#label 			-> 		'Preferences...'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#openPreferencesMenu.
					#icon 			-> 		#preferencesIcon.
					#balloonText 	-> 		'Opens a menu offering many controls over appearance and system preferences.'.
				} asDictionary.
				{
					#label 			-> 		'Windows...'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#openWindowsMenu.
					#icon 			-> 		#windowIcon.
					#balloonText 	-> 		'Manage open windows'.
				} asDictionary.
				{
					#label 			-> 		'Help...'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#openHelpMenu.
					#icon 			-> 		#helpIcon.
					#balloonText 	-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
				} asDictionary.
				nil.
				{
					#label 			-> 		'Changes...'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#openChangesMenu.
					#icon 			-> 		#changesIcon.
					#balloonText 	-> 		'Opens a menu of useful tools for dealing with changes'.
				} asDictionary.
				{
					#label 			-> 		'Debug...'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#openDebugMenu.
					#icon 			-> 		#debugIcon.
					#balloonText 	-> 		'a menu of debugging items'.
				} asDictionary.
				{
					#label 			-> 		'Restore Display (r)'.
					#object 			-> 		#myWorld.
					#selector 		-> 		#restoreDisplay.
					#icon 			-> 		#displayIcon.
					#balloonText 	-> 		'Repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'.
				} asDictionary.
				nil.
				{
					#label 			-> 		'Save'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveSession.
					#icon 			-> 		#saveIcon.
					#balloonText 	-> 		'Save the current version of the image on disk'.
				} asDictionary.
				{
					#label 			-> 		'Save as...'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveAs.
					#icon 			-> 		#saveAsIcon.
					#balloonText 	-> 		'Save the current version of the image on disk under a new name.'.
				} asDictionary.
				{
					#label 			-> 		'Save as New Version'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveAsNewVersion.
					#icon 			-> 		#saveAsNewVersionIcon.
					#balloonText 	-> 		'Save the current image a new version-stamped name\and save it under that name on disk.\Clear all user preferences and user state (class vars).' withNewLines.
				} asDictionary.
				{
					#label 			-> 		'Save and Quit'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#saveAndQuit.
					#icon 			-> 		#saveAndQuitIcon.
					#balloonText 	-> 		'Save the image and quit out of Cuis.'.
				} asDictionary.
				{
					#label 			-> 		'Quit'.
					#object 			-> 		#theWorldMenu.
					#selector 		-> 		#quitSession.
					#icon 			-> 		#quitIcon.
					#balloonText 	-> 		'Quit out of Cuis.'.
				} asDictionary.
			}`.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/1/2018 21:38:18' prior: 50393815!
                           fillIn: aMenu fromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item |
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ aMenu addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object.
				realTarget == #myWorld ifTrue: [realTarget _ myWorld].
				realTarget == #theWorldMenu ifTrue: [realTarget _ self].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						aMenu
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						aMenu
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				dict
					at: #icon
					ifPresent: [ :symbolOrFormOrNil |
						item setIcon: symbolOrFormOrNil ].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]].
	^ aMenu! !
!TheWorldMenu methodsFor: 'mechanics' stamp: 'jmv 5/1/2018 21:24:40' prior: 16935161!
                         menu: titleString
	"Create a menu with the given title, ready for filling"

	| menu |
	(menu _ MenuMorph entitled: titleString) 
		defaultTarget: self; 
		addStayUpIcons.
	^ menu
! !

TheWorldMenu removeSelector: #changesDo!

TheWorldMenu removeSelector: #changesDo!

TheWorldMenu removeSelector: #colorForDebugging:!

TheWorldMenu removeSelector: #colorForDebugging:!

TheWorldMenu removeSelector: #debugDo!

TheWorldMenu removeSelector: #debugDo!

TheWorldMenu removeSelector: #helpDo!

TheWorldMenu removeSelector: #helpDo!

TheWorldMenu removeSelector: #openWindow!

TheWorldMenu removeSelector: #openWindow!

TheWorldMenu removeSelector: #preferencesDo!

TheWorldMenu removeSelector: #preferencesDo!

TheWorldMenu removeSelector: #windowsDo!

TheWorldMenu removeSelector: #windowsDo!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3307-BigMenuRefactor-p10-JuanVuletich-2018May02-14h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3307] on 2 May 2018 at 5:47:44 pm'!

MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector enablementSelector '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #UpdatingMenuItemMorph category: #'Morphic-Menus'!
MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector enablementSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'jmv 5/2/2018 17:46:11' prior: 50392494!
                          updateContents
	"Update the receiver's contents"

	| newString nArgs |
	((wordingProvider isNil) or: [wordingSelector isNil]) ifFalse: [
		nArgs _ wordingSelector numArgs.
		newString _ nArgs = 0
			ifTrue: [
				wordingProvider perform: wordingSelector]
			ifFalse: [
				nArgs = arguments size ifTrue: [
					wordingProvider perform: wordingSelector withArguments: arguments]].
		newString = (contentString ifNil: [ contents ])
			ifFalse: [
				self contents: newString ]]! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/2/2018 16:57:32' prior: 50375670!
        changesMenu
        "Build the changes menu for the world."

	^ self
		fillIn: (self menu: 'Changes...')
		fromDictionaries: `{
			{
				#label 			-> 		'Change Sorter'.
				#object 			-> 		ChangeSorterWindow.
				#selector 		-> 		#openChangeSorter.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Install New Updates'.
				#object 			-> 		ChangeSet.
				#selector 		-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Browse my Changes'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#label 			-> 		'Recently logged Changes...'.
				#object 			-> 		ChangeList.
				#selector 		-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Save World as morph file'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/2/2018 16:58:03' prior: 16934864!
                      debugMenu

	^ self
		fillIn: (self menu: 'Debug...')
		fromDictionaries: `{
			{
				#label 			-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#inspect.
				#icon 			-> 		#inspectIcon.
			} asDictionary.
			{
				#label 			-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#explore.
				#icon 			-> 		#exploreIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally all Processes'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#startMessageTally.
				#icon 			-> 		#systemMonitorIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally UI and Browse'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#startThenBrowseMessageTally.
				#icon 			-> 		#editFindReplaceIcon.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#removeAllKnownFailing.
				#icon 			-> 		#graphicsIcon.
			} asDictionary.
			{
				#label 			-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#resumeAfterStepError.
				#icon 			-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#label 			-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 		-> 		#closeAllDebuggers.
				#icon 			-> 		#closeIcon.
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/2/2018 17:16:07' prior: 50394008!
fillIn: aMenu fromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item wantsIcons |
	wantsIcons _ Preferences wantsMenuIcons.
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ aMenu addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object.
				realTarget == #myWorld ifTrue: [realTarget _ myWorld].
				realTarget == #theWorldMenu ifTrue: [realTarget _ self].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						aMenu
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						aMenu
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				wantsIcons ifTrue: [
					dict
						at: #icon
						ifPresent: [ :symbolOrFormOrNil |
							item setIcon: symbolOrFormOrNil ]].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]].
	^ aMenu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/2/2018 16:56:08' prior: 16934966!
   helpMenu
	"Build the help menu for the world."

	^ self
		fillIn: (self menu: 'Help...')
		fromDictionaries: `{
			{
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#aboutThisSystem.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'current version information.'
			} asDictionary.
			{
				#label 			-> 		'Terse Guide to Cuis'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#openTerseGuide.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#label 			-> 		'Class Comment Browser'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#openCommentGuide.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCodeManagementInCuis.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCuisAndGitHub.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'GitHub usage pattern.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 	-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 	-> 		'a window full of useful expressions.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'VM Statistics'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 	-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#label 			-> 		'Space Left'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 	-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/2/2018 17:12:47' prior: 16935088!
                          preferencesMenu
	"Build the preferences menu for the world."

	^ self
		fillIn: (self menu: 'Preferences...')
		fromDictionaries: `{
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		Preferences.
				#selector 		-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		Preferences.
				#selector 		-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Font Sizes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set display depth...'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#setDisplayDepth.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'choose how many bits per pixel.'
			} asDictionary.
			{
				#label 			-> 		'Set desktop color...'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#changeBackgroundColor.
				#icon 			-> 		#wallpaperIcon.
				#balloonText 	-> 		'choose a uniform color to use as desktop background.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 		-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 		-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'jmv 5/2/2018 17:42:52' prior: 16935213!
    windowsMenu
        "Build the windows menu for the world."

	^ self
		fillIn: (self menu: 'Windows')
		fromDictionaries: `{
			{
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#label 			-> 		'Delete Both of the Above'.
				#object 			-> 		#theWorldMenu.
				#selector 		-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'
			} asDictionary.
		}`! !

TheWorldMenu removeSelector: #doMenuItem:with:!

TheWorldMenu removeSelector: #doMenuItem:with:!

TheWorldMenu removeSelector: #fillIn:from:!

TheWorldMenu removeSelector: #fillIn:from:!

UpdatingMenuItemMorph removeSelector: #enablement!

UpdatingMenuItemMorph removeSelector: #enablement!

UpdatingMenuItemMorph removeSelector: #enablementSelector:!

UpdatingMenuItemMorph removeSelector: #enablementSelector:!

MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #UpdatingMenuItemMorph category: #'Morphic-Menus'!
MenuItemMorph subclass: #UpdatingMenuItemMorph
	instanceVariableNames: 'wordingProvider wordingSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3308-BigMenuRefactor-p11-JuanVuletich-2018May02-16h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3307] on 2 May 2018 at 5:54:32 pm'!
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 5/2/2018 17:48:28' prior: 16898194!
                initialFrameFor: aView initialExtent: initialExtent world: aWorld 
	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."

	^ self 
		strictlyStaggeredInitialFrameFor: aView
		initialExtent: initialExtent
		world: aWorld! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 5/2/2018 17:49:23' prior: 50383199!
                  standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| grid allowedArea maxLevel |
	"NOTE: following copied from strictlyStaggeredInitialFrameFor:"
	allowedArea _ self maximumUsableArea insetBy: (
		self scrollBarSetback @ self screenTopSetback extent: `0@0`
	).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
	^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: `52@40` * Preferences standardCodeFont height! !

TheWorldMenu removeSelector: #staggerPolicyString!

TheWorldMenu removeSelector: #staggerPolicyString!

TheWorldMenu removeSelector: #toggleWindowPolicy!

TheWorldMenu removeSelector: #toggleWindowPolicy!

RealEstateAgent class removeSelector: #staggerOffset!

RealEstateAgent class removeSelector: #staggerOffset!

RealEstateAgent class removeSelector: #standardPositionsInWorld:!

RealEstateAgent class removeSelector: #standardPositionsInWorld:!

RealEstateAgent class removeSelector: #windowColumnsDesired!

RealEstateAgent class removeSelector: #windowColumnsDesired!

RealEstateAgent class removeSelector: #windowRowsDesired!

RealEstateAgent class removeSelector: #windowRowsDesired!

Preferences class removeSelector: #reverseWindowStagger!

Preferences class removeSelector: #reverseWindowStagger!

Preferences class removeSelector: #staggerPolicyString!

Preferences class removeSelector: #staggerPolicyString!

Preferences class removeSelector: #toggleWindowPolicy!

Preferences class removeSelector: #toggleWindowPolicy!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3309-RealEstateAgent-simplification-JuanVuletich-2018May02-17h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3309] on 5 May 2018 at 5:09:03 pm'!
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/5/2018 16:57:30'!
                          buildFromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object. If nil, use defaultTarget. If a Symbol, send it as message to defaultTarget to get real target.
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item wantsIcons |
	wantsIcons _ Preferences wantsMenuIcons.
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ self addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object ifAbsent: [defaultTarget].
				realTarget isSymbol ifTrue: [ realTarget _ defaultTarget perform: realTarget ].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						self
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						self
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				wantsIcons ifTrue: [
					dict
						at: #icon
						ifPresent: [ :symbolOrFormOrNil |
							item setIcon: symbolOrFormOrNil ]].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]]! !
!TheWorldMenu methodsFor: 'mechanics' stamp: 'jmv 5/5/2018 17:03:51'!
                     myWorld
	^ myWorld! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/5/2018 17:03:26' prior: 50393894!
                 buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	^(MenuMorph new defaultTarget: self)
		addStayUpIcons;
		buildFromDictionaries: `{
				{
					#label 			-> 		'Open...'.
					#selector 		-> 		#openOpenMenu.
					#icon 			-> 		#openIcon.
					#balloonText 	-> 		'Submenu to open various system tools'.
				} asDictionary.
				{
					#label 			-> 		'New morph...'.
					#selector 		-> 		#newMorph.
					#icon 			-> 		#morphsIcon.
					#balloonText 	-> 		'Offers a variety of ways to create new objects'.
				} asDictionary.
				{
					#label 			-> 		'Preferences...'.
					#selector 		-> 		#openPreferencesMenu.
					#icon 			-> 		#preferencesIcon.
					#balloonText 	-> 		'Opens a menu offering many controls over appearance and system preferences.'.
				} asDictionary.
				{
					#label 			-> 		'Windows...'.
					#selector 		-> 		#openWindowsMenu.
					#icon 			-> 		#windowIcon.
					#balloonText 	-> 		'Manage open windows'.
				} asDictionary.
				{
					#label 			-> 		'Help...'.
					#selector 		-> 		#openHelpMenu.
					#icon 			-> 		#helpIcon.
					#balloonText 	-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
				} asDictionary.
				nil.
				{
					#label 			-> 		'Changes...'.
					#selector 		-> 		#openChangesMenu.
					#icon 			-> 		#changesIcon.
					#balloonText 	-> 		'Opens a menu of useful tools for dealing with changes'.
				} asDictionary.
				{
					#label 			-> 		'Debug...'.
					#selector 		-> 		#openDebugMenu.
					#icon 			-> 		#debugIcon.
					#balloonText 	-> 		'a menu of debugging items'.
				} asDictionary.
				{
					#label 			-> 		'Restore Display (r)'.
					#object 			-> 		#myWorld.
					#selector 		-> 		#restoreDisplay.
					#icon 			-> 		#displayIcon.
					#balloonText 	-> 		'Repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'.
				} asDictionary.
				nil.
				{
					#label 			-> 		'Save'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveSession.
					#icon 			-> 		#saveIcon.
					#balloonText 	-> 		'Save the current version of the image on disk'.
				} asDictionary.
				{
					#label 			-> 		'Save as...'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveAs.
					#icon 			-> 		#saveAsIcon.
					#balloonText 	-> 		'Save the current version of the image on disk under a new name.'.
				} asDictionary.
				{
					#label 			-> 		'Save as New Version'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveAsNewVersion.
					#icon 			-> 		#saveAsNewVersionIcon.
					#balloonText 	-> 		('Save the current image a new version-stamped name\and save it under that name on disk.\',
												'Clear all user preferences and user state (class vars).') withNewLines.
				} asDictionary.
				{
					#label 			-> 		'Save and Quit'.
					#selector 		-> 		#saveAndQuit.
					#icon 			-> 		#saveAndQuitIcon.
					#balloonText 	-> 		'Save the image and quit out of Cuis.'.
				} asDictionary.
				{
					#label 			-> 		'Quit'.
					#selector 		-> 		#quitSession.
					#icon 			-> 		#quitIcon.
					#balloonText 	-> 		'Quit out of Cuis.'.
				} asDictionary.
			}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/5/2018 17:01:58' prior: 50394124!
                        changesMenu
        "Build the changes menu for the world."

	^ (self menu: 'Changes...')
		buildFromDictionaries: `{
			{
				#label 			-> 		'Change Sorter'.
				#object 			-> 		ChangeSorterWindow.
				#selector 		-> 		#openChangeSorter.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Install New Updates'.
				#object 			-> 		ChangeSet.
				#selector 		-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Browse my Changes'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#label 			-> 		'Recently logged Changes...'.
				#object 			-> 		ChangeList.
				#selector 		-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Save World as morph file'.
				#selector 		-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/5/2018 17:04:31' prior: 50394180!
   debugMenu

	^ (self menu: 'Debug...')
		buildFromDictionaries: `{
			{
				#label 			-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#inspect.
				#icon 			-> 		#inspectIcon.
			} asDictionary.
			{
				#label 			-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#explore.
				#icon 			-> 		#exploreIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally all Processes'.
				#selector 		-> 		#startMessageTally.
				#icon 			-> 		#systemMonitorIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally UI and Browse'.
				#selector 		-> 		#startThenBrowseMessageTally.
				#icon 			-> 		#editFindReplaceIcon.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#removeAllKnownFailing.
				#icon 			-> 		#graphicsIcon.
			} asDictionary.
			{
				#label 			-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#resumeAfterStepError.
				#icon 			-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#label 			-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 		-> 		#closeAllDebuggers.
				#icon 			-> 		#closeIcon.
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/5/2018 17:05:32' prior: 50394274!
                helpMenu
	"Build the help menu for the world."

	^ (self menu: 'Help...')
		buildFromDictionaries: `{
			{
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#aboutThisSystem.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'current version information.'
			} asDictionary.
			{
				#label 			-> 		'Terse Guide to Cuis'.
				#selector 		-> 		#openTerseGuide.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#label 			-> 		'Class Comment Browser'.
				#selector 		-> 		#openCommentGuide.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCodeManagementInCuis.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCuisAndGitHub.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'GitHub usage pattern.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 	-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 	-> 		'a window full of useful expressions.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'VM Statistics'.
				#selector 		-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 	-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#label 			-> 		'Space Left'.
				#selector 		-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 	-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/5/2018 17:06:38' prior: 16935052!
                openMenu
	"Build the open window menu for the world."
	| menu items groups firstGroup itemsSorted itemsBase |
	menu _ self menu: 'Open...'.
	itemsBase _ (Smalltalk allClassesImplementing: #worldMenuForOpenGroup)
		collect: [ :item |
			item class == Metaclass ifTrue: [
				item soleInstance
					worldMenuForOpenGroup ] ]
		thenSelect: [ :item |
			item notNil ].
	items _ OrderedCollection new.
	"A single class may add more than one item to a menu"
	itemsBase do: [ :item |
		item class == Dictionary
			ifTrue: [ items add: item ]
			ifFalse: [ items addAll: item ]].
	groups _ (items collect: [ :item |
		item at: #itemGroup ]) asSet asSortedCollection.
	itemsSorted _ OrderedCollection new.
	firstGroup _ true.
	groups do: [ :group |
		firstGroup
			ifTrue: [ firstGroup _ false ]
			ifFalse: [ itemsSorted add: nil ].
		((items select: [ :item |
			(item at: #itemGroup) = group ]) sort: [ :item1 :item2 |
			(item1 at: #itemOrder) < (item2 at: #itemOrder) ]) do: [ :item |
			itemsSorted add: item ]].
	menu buildFromDictionaries: itemsSorted.
	^ menu.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/5/2018 17:07:28' prior: 50394349!
                               preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		buildFromDictionaries: `{
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		Preferences.
				#selector 		-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		Preferences.
				#selector 		-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Font Sizes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 		-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 		-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set display depth...'.
				#selector 		-> 		#setDisplayDepth.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'choose how many bits per pixel.'
			} asDictionary.
			{
				#label 			-> 		'Set desktop color...'.
				#selector 		-> 		#changeBackgroundColor.
				#icon 			-> 		#wallpaperIcon.
				#balloonText 	-> 		'choose a uniform color to use as desktop background.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 		-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 		-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'jmv 5/5/2018 17:08:12' prior: 50394454!
                          windowsMenu
        "Build the windows menu for the world."

	^ (self menu: 'Windows')
		buildFromDictionaries: `{
			{
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#label 			-> 		'Delete Both of the Above'.
				#selector 		-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'
			} asDictionary.
		}`! !

TheWorldMenu removeSelector: #fillIn:fromDictionaries:!

TheWorldMenu removeSelector: #fillIn:fromDictionaries:!

TheWorldMenu removeSelector: #world!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3310-BigMenuRefactor-p12-JuanVuletich-2018May05-16h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3309] on 5 May 2018 at 5:51:50 pm'!

TextEditor class
	instanceVariableNames: 'menu '!

!classDefinition: 'TextEditor class' category: #'System-Text'!
TextEditor class
	instanceVariableNames: 'menu'!

SmalltalkEditor class
	instanceVariableNames: 'menu2 '!

!classDefinition: 'SmalltalkEditor class' category: #'System-Text'!
SmalltalkEditor class
	instanceVariableNames: 'menu2'!
!SmalltalkEditor methodsFor: 'menu' stamp: 'jmv 5/5/2018 17:40:51'!
                            getMenu
	
	^(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		buildFromDictionaries: `{
			{
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#label 			-> 		'Debug it (D)'.	
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#label 			-> 		'Profile it'.	
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#label 			-> 		'Cancel (l)'.
				#selector 		-> 		#cancelEdits.
				#icon 			-> 		#cancelIcon
			} asDictionary.
			{
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'jmv 5/5/2018 17:42:25'!
                        openMenu
	
	self getMenu	popUpInWorld: morph world! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'jmv 5/5/2018 17:45:22'!
      openMenu2
	
	(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		buildFromDictionaries: `{
			{
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`;
	popUpInWorld: morph world.! !
!TextEditor methodsFor: 'menu' stamp: 'jmv 5/5/2018 17:40:36' prior: 16933045!
                         getMenu
	
	^(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		buildFromDictionaries: `{
			{
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#label 			-> 		'Set Alignment...'.
				#selector 		-> 		#chooseAlignment.
				#icon 			-> 		#formatJustifyLeftIcon
			} asDictionary.
		}`! !
!TextEditor class methodsFor: 'cached state access' stamp: 'jmv 5/5/2018 17:50:04' prior: 16933239!
                      releaseClassCachedState

	FindText _ nil.
	ChangeText _ nil.
	"We are not calling super to avoid cleansing class vars many times.
	So, repeat inherited class instVars!!"
	shortcuts _ nil.
	cmdShortcuts _ nil! !
!SmalltalkEditor class methodsFor: 'cached state access' stamp: 'jmv 5/5/2018 17:50:09' prior: 16910772!
    releaseClassCachedState

	"We are not calling super to avoid cleansing class vars many times.
	So, repeat inherited class instVars!!"
	shortcuts _ nil.
	cmdShortcuts _ nil! !

SmalltalkEditor class removeSelector: #initializeMenu!

SmalltalkEditor class removeSelector: #initializeMenu!

SmalltalkEditor class removeSelector: #menu2!

SmalltalkEditor class removeSelector: #menu2!

SmalltalkEditor class removeSelector: #paneMenu2:!

SmalltalkEditor class removeSelector: #paneMenu2:!

SmalltalkEditor removeSelector: #getMenu2!

SmalltalkEditor removeSelector: #getMenu2!

TextEditor class removeSelector: #basicInitialize!

TextEditor class removeSelector: #basicInitialize!

TextEditor class removeSelector: #initializeMenu!

TextEditor class removeSelector: #initializeMenu!

TextEditor class removeSelector: #menu!

TextEditor class removeSelector: #menu!

TextEditor class removeSelector: #paneMenu:!

TextEditor class removeSelector: #paneMenu:!

TextEditor class
	instanceVariableNames: ''!

!classDefinition: 'TextEditor class' category: #'System-Text'!
TextEditor class
	instanceVariableNames: ''!

SmalltalkEditor class
	instanceVariableNames: ''!

!classDefinition: 'SmalltalkEditor class' category: #'System-Text'!
SmalltalkEditor class
	instanceVariableNames: ''!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3311-BigMenuRefactor-p13-JuanVuletich-2018May05-17h09m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3311] on 5 May 2018 at 7:22:00 pm'!

SelectionMenu removeSelector: #selections!

SelectionMenu removeSelector: #selections!

MenuMorph removeSelector: #addCustomMenuItems:hand:!

MenuMorph removeSelector: #addCustomMenuItems:hand:!

MenuMorph removeSelector: #addItem!

MenuMorph removeSelector: #addItem!

MenuMorph removeSelector: #addTitle!

MenuMorph removeSelector: #addTitle!

MenuMorph removeSelector: #sightTarget:!

MenuMorph removeSelector: #sightTarget:!

Smalltalk removeClassNamed: #CustomMenu!

Smalltalk removeClassNamed: #CustomMenu!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3312-BigMenuRefactor-p14-JuanVuletich-2018May05-19h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3311] on 5 May 2018 at 7:48:24 pm'!
!MenuMorph methodsFor: 'modal progress dialog' stamp: 'jmv 5/5/2018 19:37:23'!
             displayAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	self runningWorld ifNotNil: [ :w |
		w addMorph: self centeredNear: aPoint.
		self world ifNotNil: [ w displayWorld ].  "show myself"
		].
	aBlock value.
	self delete! !
!MenuMorph methodsFor: 'modal progress dialog' stamp: 'jmv 5/5/2018 19:37:19'!
                     informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ self world ifNil: [ self runningWorld ].
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString morphWidth + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w ifNotNil: [
			w displayWorld	].	 "show myself"
	]. 
	self delete.
	w ifNotNil: [
		w displayWorld ]! !
!Utilities class methodsFor: 'user interface' stamp: 'jmv 5/5/2018 19:31:18' prior: 16941500!
              informUser: aString during: aBlock
	"Display a message above (or below if insufficient room) the cursor during execution of the given block."

	"
	Utilities informUser: 'Just a sec!!' during: [(Delay forSeconds: 1) wait]
	"

	(MenuMorph entitled: aString) 
		displayAt: Sensor mousePoint + 60
		during: aBlock! !
!Utilities class methodsFor: 'user interface' stamp: 'jmv 5/5/2018 19:31:32' prior: 50366490!
         informUserDuring: barBlock 
	"Display a message above (or below if insufficient room) the cursor during execution of the given block."

	"
	Utilities informUserDuring:[:barBlock|
		#(one two three) do:[:info|
			barBlock value: info.
			(Delay forSeconds: 1) wait]]
	"

	(MenuMorph entitled: '						') 
		informUserAt: Sensor mousePoint
		during: barBlock! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 5/5/2018 19:34:12' prior: 16867158!
  invokeModal
	"Invoke this menu and don't return until the user has chosen a value.
	See example below on how to use modal menu morphs."
	^ self invokeModal: Preferences menuKeyboardControl

	"
	| menu sub entry |
	menu _ MenuMorph new.
	1 to: 3 do: [:i |
		entry _ 'Line', i printString.
		sub _ MenuMorph new.
		menu add: entry subMenu: sub.
		#('Item A' 'Item B' 'Item C')  do:[:subEntry|
			sub add: subEntry target: menu 
				action: #modalSelection: argument: {entry. subEntry}]].
	menu invokeModal.
	"! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:29' prior: 50340036!
            invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self
		popUpAt: aPoint
		forHand: actHand
		allowKeyboard: aBoolean.
	done _ false.
	[ self isInWorld & done not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'jmv 5/5/2018 19:38:51' prior: 16891113!
                        confirm: queryString
	"Put up a yes/no menu with caption queryString. Answer true if the 
	response is yes, false if no. This is a modal question--the user must 
	respond yes or no."

	"
	PopUpMenu confirm: 'Are you hungry?'
	"

	^ self confirm: queryString trueChoice: 'Yes' falseChoice: 'No'! !

MVCMenuMorph removeSelector: #displayAt:during:!

MVCMenuMorph removeSelector: #displayAt:during:!

MVCMenuMorph removeSelector: #informUserAt:during:!

MVCMenuMorph removeSelector: #informUserAt:during:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3313-BigMenuRefactor-p15-JuanVuletich-2018May05-19h22m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3311] on 5 May 2018 at 8:47:10 pm'!
!VersionsBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:45:15' prior: 16942771!
    classCommentVersionsMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.				"all commands are implemented by the model, not the view"
	aMenu addTitle: 'versions'.
	aMenu addStayUpIcons.
	aMenu buildFromDictionaries: `{
		{
			#label 			-> 			'compare to current'.
			#selector 		-> 			#compareToCurrentVersion.
			#balloonText 	-> 			'compare selected version to the current version'
		} asDictionary.
		{
			#label 			-> 			'revert to selected version'.
			#selector 		-> 			#fileInSelections.
			#balloonText 	-> 			'resubmit the selected version, so that it becomes the current version'
		} asDictionary.
		nil.
		{
			#label 			-> 			'toggle diffing (D)'.
			#selector 		-> 			#toggleDiffing.
			#balloonText 	-> 			'toggle whether or not diffs should be shown here'
		} asDictionary.
		{
			#label 			-> 			'update list'.
			#selector 		-> 			#reformulateList.
			#balloonText 	-> 			'reformulate the list of versions, in case it somehow got out of synch with reality'
		} asDictionary.
		nil.
		{
			#label 			-> 			'help...'.
			#selector 		-> 			#offerVersionsHelp.
			#balloonText 	-> 			'provide an explanation of the use of this tool'
		} asDictionary.
	}`.
	^aMenu! !
!VersionsBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:45:08' prior: 16942805!
                         methodVersionsMenu
	"Fill aMenu with menu items appropriate to the receiver"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Versions'.
	aMenu addStayUpIcons.
	model listIndex > 0 ifTrue:[
		(model list size > 1 ) ifTrue: [
			aMenu buildFromDictionaries: `{
				{
					#label 			-> 			'compare to current'.
					#object 			-> 			#model.
					#selector 		-> 			#compareToCurrentVersion.
					#balloonText 	-> 			'compare selected version to the current version'
				} asDictionary.
				{
					#label 			-> 			'compare to version...'.
					#object 			-> 			#model.
					#selector 		-> 			#compareToOtherVersion.
					#balloonText 	-> 			'compare selected version to another selected version'
				} asDictionary.
			}` ].
		"Note: Revert to selected should be visible for lists of length one for having the ability to revert to an accidentally deleted method"
		aMenu buildFromDictionaries: `{
			{
				#label 			-> 			'revert to selected version'.
				#object 			-> 			#model.
				#selector 		-> 			#fileInSelections.
				#balloonText 	-> 			'resubmit the selected version, so that it becomes the current version'
			} asDictionary.
		}` ].

	aMenu buildFromDictionaries: `{
		{
			#label 			-> 			'edit current method (O)'.
			#selector 		-> 			#openSingleMessageBrowser.
			#balloonText 	-> 			'open a single-message browser on the current version of this method'
		} asDictionary.
		nil.
		{
			#label 			-> 			'toggle diffing (D)'.
			#object 			-> 			#model.
			#selector 		-> 			#toggleDiffing.
			#balloonText 	-> 			'toggle whether or not diffs should be shown here'
		} asDictionary.
		{
			#label 			-> 			'update list'.
			#object 			-> 			#model.
			#selector 		-> 			#reformulateList.
			#balloonText 	-> 			'reformulate the list of versions, in case it somehow got out of synch with reality'
		} asDictionary.
		nil.
		{
			#label 			-> 			'senders (n)'.
			#selector 		-> 			#browseSenders.
			#balloonText 	-> 			'browse all senders of this selector'
		} asDictionary.
		{
			#label 			-> 			'implementors (m)'.
			#selector 		-> 			#browseImplementors.
			#balloonText 	-> 			'browse all implementors of this selector'
		} asDictionary.
		nil.
		{
			#label 			-> 			'help...'.
			#object 			-> 			#model.
			#selector 		-> 			#offerVersionsHelp.
			#balloonText 	-> 			'provide an explanation of the use of this tool'
		} asDictionary.
	}`.
	^aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:27:50' prior: 50393452!
     changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu isForBaseSystem |
	isForBaseSystem _ model changeSet isForBaseSystem.
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Change Set'.
	aMenu addStayUpIcons.

	(aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove) 	isEnabled: isForBaseSystem.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	(aMenu add: 'Rename change set (r)' 			action: #rename) 					isEnabled: isForBaseSystem.
	(aMenu add: 'Destroy change set (x)' 			action: #remove) 					isEnabled: isForBaseSystem.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 	action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	(aMenu add: 'conflicts with other change sets' target: self action: #browseMethodConflicts)
		setBalloonText: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	(aMenu add: 'trim history' action: #trimHistory)
		isEnabled: isForBaseSystem;
		setBalloonText: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	(aMenu add: 'view affected class categories' action: #viewAffectedClassCategories)
		setBalloonText: ' Show class categories affected by any contained change'.

	^ aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:27:52' prior: 16800150!
                            classListMenu
	"Fill aMenu with items appropriate for the class list"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'class list'.
	aMenu addStayUpIcons.
	aMenu addList: #(
			-
			('delete class from change set (d)'		forgetClass					''		model)
			('remove class from system (x)'		removeClass					''		model)
			-
			('browse full (b)'						browseMethodFull)
			('browse hierarchy (h)'					browseHierarchy)
			('browse protocol (p)'					browseFullProtocol)
			-
			('inst var refs...'							browseInstVarRefs)
			('inst var defs...'						browseInstVarDefs)
			('class var refs...'						browseClassVarRefs)
			('class vars'								browseClassVariables)
			('class refs (N)'							browseClassRefs)).
	^ aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:27:55' prior: 16800176!
 messageMenu
	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'message list'.
	aMenu addStayUpIcons.
	aMenu addList: #(
			('delete method from changeSet (d)'	forget							''		model)
			-
			('remove method from system (x)'		removeMessage				''		model)
				-
			('browse full (b)'						browseMethodFull)
			('browse hierarchy (h)'					browseHierarchy)
			('browse method (O)'					openSingleMessageBrowser)
			('browse protocol (p)'					browseFullProtocol)
			-
			('fileOut'								fileOutMessage				''		model)
			-
			('senders of... (n)'						browseSendersOfMessages)
			('implementors of... (m)'					browseMessages)
			('inheritance (i)'							methodHierarchy)
			('versions (v)'							browseVersions)).
	^ aMenu! !
!TestRunnerWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:27:58' prior: 50393131!
                    listMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Test Cases'.
	aMenu add: 'select all' target: model action: #selectAll.
	aMenu add: 'deselect all' target: model action: #deselectAll.
	aMenu add: 'toggle selections' target: model action: #invertSelections.
	aMenu add: 'filter' target: model action: #setFilter.
	model runButtonState ifTrue: [
		aMenu add: 'stop' target: model action: #terminateRun
		].
	model selectedSuite > 0 ifTrue: [ | cls |
		cls _ (model tests at: model selectedSuite ifAbsent: ['']) copyUpTo: Character space.
		cls _ cls asSymbol.
		cls _ (Smalltalk at: cls ifAbsent: nil).
		cls ifNotNil: [
			aMenu addLine.
			aMenu add: 'browse' target: self action: #browse: argument: cls.
		].
	].
	aMenu addLine.
	aMenu add: 'log to Transcript' target: model action: #showResult.
	^aMenu! !

MenuMorph removeSelector: #title:!

MenuMorph removeSelector: #title:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3314-BigMenuRefactor-p16-JuanVuletich-2018May05-20h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3311] on 5 May 2018 at 8:58:04 pm'!
!CodeWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:54:23'!
     offerClassListMenu
	"Offer the shifted class-list menu."

	^ self classListMenu popUpInWorld! !
!CodeWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:53:04'!
                        offerClassListMenu2
	"Offer the shifted class-list menu."

	^ self classListMenu2 popUpInWorld! !
!CodeWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:50:27'!
                      openMessageListMenu2
	"Offer the additional selector-list menu"

	^ self messageListMenu2 popUpInWorld! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:56:29'!
           addExtraMenu2ItemsTo: aMenu
	"The shifted selector-list menu is being built; some menu items are appropriate only for certain kinds of browsers, and this gives a hook for them to be added as approrpiate.  If any is added here, a line should be added first -- browse reimplementors of this message for examples."! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:55:04'!
                          classListMenu2
	"Set up the menu to apply to the receiver's class list when the shift key is down"

	| aMenu |
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addList: #(
			-
			('unsent methods'					browseUnusedMethods
				'browse all methods defined by this class that have no senders')
			('unreferenced inst vars'			showUnreferencedInstVars
				'show a list of all instance variables that are not referenced in methods')
			('unreferenced class vars'			showUnreferencedClassVars
				'show a list of all class variables that are not referenced in methods')
			('subclass template'				makeNewSubclass
				'put a template into the code pane for defining of a subclass of this class'								model)
			-
			('sample instance'					makeSampleInstance
				'give me a sample instance of this class, if possible')
			('inspect instances'					inspectInstances
				'open an inspector on all the extant instances of this class')
			('inspect subinstances'				inspectSubInstances
				'open an inspector on all the extant instances of this class and of all of its subclasses')
			-
			('create inst var accessors'			createInstVarAccessors
				'compile instance-variable access methods for any instance variables that do not yet have them'		model)
			-
			('more...'							offerClassListMenu
				'return to the standard class-list menu')).
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:56:50'!
                    messageListMenu2
	"Fill aMenu with the items appropriate when the shift key is held down"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addStayUpIcons.
	aMenu addList: #(
		('toggle diffing (D)'						toggleDiffing							''		model)
		('implementors of sent messages'		browseAllMessages)
		-
		('local senders of...'						browseLocalSendersOfMessages)
		('local implementors of...'				browseLocalImplementors)
		-
		('spawn sub-protocol'					browseProtocol)
		('spawn full protocol'					browseFullProtocol)
		-
		('sample instance'						makeSampleInstance)
		('inspect instances'						inspectInstances)
		('inspect subinstances'					inspectSubInstances)).

	self addExtraMenu2ItemsTo: aMenu.
	aMenu addList: #(
		-
		('change category...'					changeCategory							''		model)).

	model canShowMultipleMessageCategories ifTrue: [ aMenu addList: #(
		('show category (C)'					showHomeCategory						''		model))].
	aMenu addList: #(
		-
		('change sets with this method'			findMethodInChangeSets)
		('revert to previous version'			revertToPreviousVersion				''		model)
		-
		('more...' 								openMessageListMenu)).
	^ aMenu! !
!MessageSetWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:56:34'!
                               addExtraMenu2ItemsTo: aMenu
	"The shifted selector-list menu is being built.  Add items specific to MessageSet"

	model growable ifTrue: [
		aMenu addList: #(
			-
			('remove from this browser'			removeMessageFromBrowser		''		model)
			('filter message list...'					filterMessageList))].
	aMenu add: 'sort by date' target: model action: #sortByDate! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:53:09' prior: 50338669!
    classListMenu
	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList: #(
		('browse full (b)'			browseMethodFull)
		('browse hierarchy (h)'		browseHierarchy)
		('browse protocol (p)'		browseFullProtocol)
		-
		('fileOut'					fileOutClass				''		model)
		-
		('show hierarchy'			hierarchy					''		model)
		('show definition'			editClass					''		model)
		('show comment'			editComment			''		model)
		-
		('inst var refs...'				browseInstVarRefs)
		('inst var defs...'			browseInstVarDefs)
		-
		('class var refs...'			browseClassVarRefs)
		('class vars'					browseClassVariables)
		('class refs (N)'				browseClassRefs)
		-
		('rename class ...'			renameClass				''		model)
		('copy class...'				copyClass				''		model)
		('remove class (x)'			removeClass				''		model)
		-
		('Run tests (t)'		runClassTests 	''	model)
		('more...'					offerClassListMenu2)).
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/5/2018 20:50:00' prior: 50344014!
                        messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList:#(
			('what to show...'					offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry						''		model)
            	-
			('browse full (b)' 					browseMethodFull)
			('browse hierarchy (h)'			browseHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'							fileOutMessage							''		model)
			('explore CompiledMethod'		exploreCompiledMethod				''		model)
			-
			('senders of... (n)'				browseSendersOfMessages)
			('implementors of... (m)'		browseMessages)
			('inheritance (i)'					methodHierarchy)
			('versions (v)'						browseVersions)
			-
			('inst var refs...'					browseInstVarRefs)
			('inst var defs...'					browseInstVarDefs)
			('class var refs...'				browseClassVarRefs)
			('class variables'					browseClassVariables)
			('class refs (N)'					browseClassRefs)
			-
			('remove method (x)'			removeMessage							''		model)
			('Run test (t)'						runMethodTest 							'' 		model)
			('Debug test (r)'					debugMethodTest 						'' 		model)
			-
			('more...'							openMessageListMenu2)).
	^ aMenu
! !

MessageSetWindow removeSelector: #addExtraShiftedItemsTo:!

MessageSetWindow removeSelector: #addExtraShiftedItemsTo:!

BrowserWindow removeSelector: #addExtraShiftedItemsTo:!

BrowserWindow removeSelector: #addExtraShiftedItemsTo:!

BrowserWindow removeSelector: #shiftedClassListMenu!

BrowserWindow removeSelector: #shiftedClassListMenu!

BrowserWindow removeSelector: #shiftedMessageListMenu!

BrowserWindow removeSelector: #shiftedMessageListMenu!

CodeWindow removeSelector: #offerShiftedClassListMenu!

CodeWindow removeSelector: #offerShiftedClassListMenu!

CodeWindow removeSelector: #offerUnshiftedClassListMenu!

CodeWindow removeSelector: #offerUnshiftedClassListMenu!

CodeWindow removeSelector: #openShiftedMessageListMenu!

CodeWindow removeSelector: #openShiftedMessageListMenu!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3315-BigMenuRefactor-p17-JuanVuletich-2018May05-20h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3315] on 6 May 2018 at 10:33:27 am'!
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:32:34'!
                addItemsFromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object. If nil, use defaultTarget. If a Symbol, send it as message to defaultTarget to get real target.
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item wantsIcons |
	wantsIcons _ Preferences wantsMenuIcons.
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ self addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object ifAbsent: [defaultTarget].
				realTarget isSymbol ifTrue: [ realTarget _ defaultTarget perform: realTarget ].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						self
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						self
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				wantsIcons ifTrue: [
					dict
						at: #icon
						ifPresent: [ :symbolOrFormOrNil |
							item setIcon: symbolOrFormOrNil ]].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]]! !
!TextEditor methodsFor: 'menu' stamp: 'jmv 5/6/2018 10:32:42' prior: 50395500!
         getMenu
	
	^(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#label 			-> 		'Set Alignment...'.
				#selector 		-> 		#chooseAlignment.
				#icon 			-> 		#formatJustifyLeftIcon
			} asDictionary.
		}`! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'jmv 5/6/2018 10:32:39' prior: 50395329!
   getMenu
	
	^(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#label 			-> 		'Debug it (D)'.	
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#label 			-> 		'Profile it'.	
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#label 			-> 		'Cancel (l)'.
				#selector 		-> 		#cancelEdits.
				#icon 			-> 		#cancelIcon
			} asDictionary.
			{
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'jmv 5/6/2018 10:32:41' prior: 50395428!
     openMenu2
	
	(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`;
	popUpInWorld: morph world.! !
!VersionsBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/6/2018 10:32:59' prior: 50395801!
  classCommentVersionsMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.				"all commands are implemented by the model, not the view"
	aMenu addTitle: 'versions'.
	aMenu addStayUpIcons.
	aMenu addItemsFromDictionaries: `{
		{
			#label 			-> 			'compare to current'.
			#selector 		-> 			#compareToCurrentVersion.
			#balloonText 	-> 			'compare selected version to the current version'
		} asDictionary.
		{
			#label 			-> 			'revert to selected version'.
			#selector 		-> 			#fileInSelections.
			#balloonText 	-> 			'resubmit the selected version, so that it becomes the current version'
		} asDictionary.
		nil.
		{
			#label 			-> 			'toggle diffing (D)'.
			#selector 		-> 			#toggleDiffing.
			#balloonText 	-> 			'toggle whether or not diffs should be shown here'
		} asDictionary.
		{
			#label 			-> 			'update list'.
			#selector 		-> 			#reformulateList.
			#balloonText 	-> 			'reformulate the list of versions, in case it somehow got out of synch with reality'
		} asDictionary.
		nil.
		{
			#label 			-> 			'help...'.
			#selector 		-> 			#offerVersionsHelp.
			#balloonText 	-> 			'provide an explanation of the use of this tool'
		} asDictionary.
	}`.
	^aMenu! !
!VersionsBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/6/2018 10:33:10' prior: 50395842!
                      methodVersionsMenu
	"Fill aMenu with menu items appropriate to the receiver"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Versions'.
	aMenu addStayUpIcons.
	model listIndex > 0 ifTrue:[
		(model list size > 1 ) ifTrue: [
			aMenu addItemsFromDictionaries: `{
				{
					#label 			-> 			'compare to current'.
					#object 			-> 			#model.
					#selector 		-> 			#compareToCurrentVersion.
					#balloonText 	-> 			'compare selected version to the current version'
				} asDictionary.
				{
					#label 			-> 			'compare to version...'.
					#object 			-> 			#model.
					#selector 		-> 			#compareToOtherVersion.
					#balloonText 	-> 			'compare selected version to another selected version'
				} asDictionary.
			}` ].
		"Note: Revert to selected should be visible for lists of length one for having the ability to revert to an accidentally deleted method"
		aMenu addItemsFromDictionaries: `{
			{
				#label 			-> 			'revert to selected version'.
				#object 			-> 			#model.
				#selector 		-> 			#fileInSelections.
				#balloonText 	-> 			'resubmit the selected version, so that it becomes the current version'
			} asDictionary.
		}` ].

	aMenu addItemsFromDictionaries: `{
		{
			#label 			-> 			'edit current method (O)'.
			#selector 		-> 			#openSingleMessageBrowser.
			#balloonText 	-> 			'open a single-message browser on the current version of this method'
		} asDictionary.
		nil.
		{
			#label 			-> 			'toggle diffing (D)'.
			#object 			-> 			#model.
			#selector 		-> 			#toggleDiffing.
			#balloonText 	-> 			'toggle whether or not diffs should be shown here'
		} asDictionary.
		{
			#label 			-> 			'update list'.
			#object 			-> 			#model.
			#selector 		-> 			#reformulateList.
			#balloonText 	-> 			'reformulate the list of versions, in case it somehow got out of synch with reality'
		} asDictionary.
		nil.
		{
			#label 			-> 			'senders (n)'.
			#selector 		-> 			#browseSenders.
			#balloonText 	-> 			'browse all senders of this selector'
		} asDictionary.
		{
			#label 			-> 			'implementors (m)'.
			#selector 		-> 			#browseImplementors.
			#balloonText 	-> 			'browse all implementors of this selector'
		} asDictionary.
		nil.
		{
			#label 			-> 			'help...'.
			#object 			-> 			#model.
			#selector 		-> 			#offerVersionsHelp.
			#balloonText 	-> 			'provide an explanation of the use of this tool'
		} asDictionary.
	}`.
	^aMenu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:32:44' prior: 50394762!
   buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	^(MenuMorph new defaultTarget: self)
		addStayUpIcons;
		addItemsFromDictionaries: `{
				{
					#label 			-> 		'Open...'.
					#selector 		-> 		#openOpenMenu.
					#icon 			-> 		#openIcon.
					#balloonText 	-> 		'Submenu to open various system tools'.
				} asDictionary.
				{
					#label 			-> 		'New morph...'.
					#selector 		-> 		#newMorph.
					#icon 			-> 		#morphsIcon.
					#balloonText 	-> 		'Offers a variety of ways to create new objects'.
				} asDictionary.
				{
					#label 			-> 		'Preferences...'.
					#selector 		-> 		#openPreferencesMenu.
					#icon 			-> 		#preferencesIcon.
					#balloonText 	-> 		'Opens a menu offering many controls over appearance and system preferences.'.
				} asDictionary.
				{
					#label 			-> 		'Windows...'.
					#selector 		-> 		#openWindowsMenu.
					#icon 			-> 		#windowIcon.
					#balloonText 	-> 		'Manage open windows'.
				} asDictionary.
				{
					#label 			-> 		'Help...'.
					#selector 		-> 		#openHelpMenu.
					#icon 			-> 		#helpIcon.
					#balloonText 	-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
				} asDictionary.
				nil.
				{
					#label 			-> 		'Changes...'.
					#selector 		-> 		#openChangesMenu.
					#icon 			-> 		#changesIcon.
					#balloonText 	-> 		'Opens a menu of useful tools for dealing with changes'.
				} asDictionary.
				{
					#label 			-> 		'Debug...'.
					#selector 		-> 		#openDebugMenu.
					#icon 			-> 		#debugIcon.
					#balloonText 	-> 		'a menu of debugging items'.
				} asDictionary.
				{
					#label 			-> 		'Restore Display (r)'.
					#object 			-> 		#myWorld.
					#selector 		-> 		#restoreDisplay.
					#icon 			-> 		#displayIcon.
					#balloonText 	-> 		'Repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'.
				} asDictionary.
				nil.
				{
					#label 			-> 		'Save'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveSession.
					#icon 			-> 		#saveIcon.
					#balloonText 	-> 		'Save the current version of the image on disk'.
				} asDictionary.
				{
					#label 			-> 		'Save as...'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveAs.
					#icon 			-> 		#saveAsIcon.
					#balloonText 	-> 		'Save the current version of the image on disk under a new name.'.
				} asDictionary.
				{
					#label 			-> 		'Save as New Version'.
					#object 			-> 		Smalltalk.
					#selector 		-> 		#saveAsNewVersion.
					#icon 			-> 		#saveAsNewVersionIcon.
					#balloonText 	-> 		('Save the current image a new version-stamped name\and save it under that name on disk.\',
												'Clear all user preferences and user state (class vars).') withNewLines.
				} asDictionary.
				{
					#label 			-> 		'Save and Quit'.
					#selector 		-> 		#saveAndQuit.
					#icon 			-> 		#saveAndQuitIcon.
					#balloonText 	-> 		'Save the image and quit out of Cuis.'.
				} asDictionary.
				{
					#label 			-> 		'Quit'.
					#selector 		-> 		#quitSession.
					#icon 			-> 		#quitIcon.
					#balloonText 	-> 		'Quit out of Cuis.'.
				} asDictionary.
			}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:32:45' prior: 50394865!
                     changesMenu
        "Build the changes menu for the world."

	^ (self menu: 'Changes...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Change Sorter'.
				#object 			-> 		ChangeSorterWindow.
				#selector 		-> 		#openChangeSorter.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Install New Updates'.
				#object 			-> 		ChangeSet.
				#selector 		-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Browse my Changes'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#label 			-> 		'Recently logged Changes...'.
				#object 			-> 		ChangeList.
				#selector 		-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Save World as morph file'.
				#selector 		-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:32:47' prior: 50394919!
debugMenu

	^ (self menu: 'Debug...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#inspect.
				#icon 			-> 		#inspectIcon.
			} asDictionary.
			{
				#label 			-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#explore.
				#icon 			-> 		#exploreIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally all Processes'.
				#selector 		-> 		#startMessageTally.
				#icon 			-> 		#systemMonitorIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally UI and Browse'.
				#selector 		-> 		#startThenBrowseMessageTally.
				#icon 			-> 		#editFindReplaceIcon.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#removeAllKnownFailing.
				#icon 			-> 		#graphicsIcon.
			} asDictionary.
			{
				#label 			-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#resumeAfterStepError.
				#icon 			-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#label 			-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 		-> 		#closeAllDebuggers.
				#icon 			-> 		#closeIcon.
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:32:49' prior: 50394961!
             helpMenu
	"Build the help menu for the world."

	^ (self menu: 'Help...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#aboutThisSystem.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'current version information.'
			} asDictionary.
			{
				#label 			-> 		'Terse Guide to Cuis'.
				#selector 		-> 		#openTerseGuide.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#label 			-> 		'Class Comment Browser'.
				#selector 		-> 		#openCommentGuide.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCodeManagementInCuis.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCuisAndGitHub.
				#icon 			->		#helpIcon.
				#balloonText 	-> 		'GitHub usage pattern.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 	-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 	-> 		'a window full of useful expressions.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'VM Statistics'.
				#selector 		-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 	-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#label 			-> 		'Space Left'.
				#selector 		-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 	-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:32:52' prior: 50395031!
             openMenu
	"Build the open window menu for the world."
	| menu items groups firstGroup itemsSorted itemsBase |
	menu _ self menu: 'Open...'.
	itemsBase _ (Smalltalk allClassesImplementing: #worldMenuForOpenGroup)
		collect: [ :item |
			item class == Metaclass ifTrue: [
				item soleInstance
					worldMenuForOpenGroup ] ]
		thenSelect: [ :item |
			item notNil ].
	items _ OrderedCollection new.
	"A single class may add more than one item to a menu"
	itemsBase do: [ :item |
		item class == Dictionary
			ifTrue: [ items add: item ]
			ifFalse: [ items addAll: item ]].
	groups _ (items collect: [ :item |
		item at: #itemGroup ]) asSet asSortedCollection.
	itemsSorted _ OrderedCollection new.
	firstGroup _ true.
	groups do: [ :group |
		firstGroup
			ifTrue: [ firstGroup _ false ]
			ifFalse: [ itemsSorted add: nil ].
		((items select: [ :item |
			(item at: #itemGroup) = group ]) sort: [ :item1 :item2 |
			(item1 at: #itemOrder) < (item2 at: #itemOrder) ]) do: [ :item |
			itemsSorted add: item ]].
	menu addItemsFromDictionaries: itemsSorted.
	^ menu.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:32:55' prior: 50395068!
                            preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		Preferences.
				#selector 		-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		Preferences.
				#selector 		-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Font Sizes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 		-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 		-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set display depth...'.
				#selector 		-> 		#setDisplayDepth.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'choose how many bits per pixel.'
			} asDictionary.
			{
				#label 			-> 		'Set desktop color...'.
				#selector 		-> 		#changeBackgroundColor.
				#icon 			-> 		#wallpaperIcon.
				#balloonText 	-> 		'choose a uniform color to use as desktop background.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 		-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 		-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'jmv 5/6/2018 10:32:56' prior: 50395169!
                       windowsMenu
        "Build the windows menu for the world."

	^ (self menu: 'Windows')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#label 			-> 		'Delete Both of the Above'.
				#selector 		-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'
			} asDictionary.
		}`! !

MenuMorph removeSelector: #buildFromDictionaries:!

MenuMorph removeSelector: #buildFromDictionaries:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3316-BigMenuRefactor-p18-JuanVuletich-2018May06-10h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3315] on 6 May 2018 at 11:21:29 am'!
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:51:49'!
                               add: aString action: aSymbol icon: symbolOrFormOrNil
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."
	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."

	^(self add: aString
		target: defaultTarget
		action: aSymbol
		argumentList: #())
			setIcon: symbolOrFormOrNil! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:51:24'!
                           add: aString action: aSymbol icon: symbolOrFormOrNil enabled: aBoolean
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."
	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."

	(self add: aString
		target: defaultTarget
		action: aSymbol
		argumentList: #())
			setIcon: symbolOrFormOrNil;
			isEnabled: aBoolean! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/6/2018 10:56:22'!
                  add: aString target: aTarget action: aSymbol icon: symbolOrFormOrNil
	^(self add: aString
		target: aTarget
		action: aSymbol
		argumentList: #())
			setIcon: symbolOrFormOrNil! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/6/2018 10:56:43' prior: 50395920!
            changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu isForBaseSystem |
	isForBaseSystem _ model changeSet isForBaseSystem.
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove 	icon: #fileOutIcon 	enabled: isForBaseSystem.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep 		icon: #fileOutIcon.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename 					icon: #saveAsIcon 	enabled: isForBaseSystem.
	aMenu add: 'Destroy change set (x)' 			action: #remove 					icon: #warningIcon 	enabled: isForBaseSystem.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble 			icon: #textEditorIcon.
				aMenu add: 'Remove preamble' 	action: #removePreamble 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 	action: #addPreamble 			icon: #listAddIcon ].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript 			icon: #textEditorIcon .
				aMenu add: 'Remove postscript' 	action: #removePostscript 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript 			icon: #listAddIcon ].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	(aMenu add: 'conflicts with other change sets' 	target: self 	action: #browseMethodConflicts 	icon: #emblemImportantIcon)
		setBalloonText: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	(aMenu add: 'trim history' 						action: #trimHistory 				icon: #clockIcon 		enabled: isForBaseSystem)
		setBalloonText: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	(aMenu add: 'view affected class categories' action: #viewAffectedClassCategories icon: #clockIcon)
		setBalloonText: ' Show class categories affected by any contained change'.

	^ aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/6/2018 11:20:40' prior: 50395986!
                              classListMenu
	"Fill aMenu with items appropriate for the class list"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'class list'.
	aMenu addStayUpIcons.
	aMenu 
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'delete class from change set (d)'.
				#object 			-> 		#model.
				#selector 		-> 		#forgetClass.
				#icon 			-> 		#warningIcon
			} asDictionary.
			{
				#label 			-> 		'remove class from system (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class vars'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
		}`.
	^ aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/6/2018 11:12:18' prior: 50396012!
                 messageMenu
	"Fill aMenu with items appropriate for the message list; could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'message list'.
	aMenu addStayUpIcons.
	aMenu 
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'delete method from changeSet (d)'.
				#object 			-> 		#model.
				#selector 		-> 		#forget.
				#icon 			-> 		#warningIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'remove method from system (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'browse method (O)'.
				#selector 		-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'senders of... (n)'.
				#selector 		-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#label 			-> 		'implementors of... (m)'.
				#selector 		-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#label 			-> 		'inheritance (i)'.
				#selector 		-> 		#methodHierarchy.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#label 			-> 		'versions (v)'.
				#selector 		-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
		}`.
	^ aMenu! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 5/6/2018 09:38:40' prior: 50392553!
                    addBlankIconsIfNecessary
	"If any of my items have an icon, ensure that all do by using anIcon for those that don't"

	| withIcons withoutIcons |
	withIcons _ Set new.
	withoutIcons _ Set new.
	self items do: [ :item |
		item hasIcon | item hasMarker
			ifTrue: [ withIcons add: item ]
			ifFalse: [ withoutIcons add: item ].
		item hasSubMenu ifTrue: [ item subMenu addBlankIconsIfNecessary ]].
"	(withIcons isEmpty or: [ withoutIcons isEmpty ]) ifTrue: [ ^self ]."
	withoutIcons do: [ :item | item setBlankIcon ]! !

MenuMorph removeSelector: #add:action:enabled:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3317-BigMenuRefactor-p19-JuanVuletich-2018May06-10h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3317] on 6 May 2018 at 11:55:36 am'!
!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'jmv 5/6/2018 11:54:04' prior: 16865516!
  from: aPopupMenu title: titleStringOrNil
	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."

	| menu items lines selections labelString j emphasis |
	menu _ self new.
	titleStringOrNil ifNotNil: [
		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].
	labelString _ aPopupMenu labelString.
	items _ labelString asString lines.
	(labelString is: #Text) ifTrue: [
		"Pass along text emphasis if present"
		j _ 1.
		items _ items collect: [ :item |
			j _ labelString asString findString: item startingAt: j.
			emphasis _ TextEmphasis new emphasisCode: (labelString emphasisAt: j).
			item asText addAttribute: emphasis]].
	lines _ aPopupMenu lineArray.
	lines ifNil: [lines _ #()].
	menu cancelValue: 0.
	menu defaultTarget: menu.
	selections _ (1 to: items size) asArray.
	1 to: items size do: [ :i |
		menu add: (items at: i) target: menu action: #selectMVCItem: argument: (selections at: i).
		(lines includes: i) ifTrue: [menu addLine]].
	^ menu
! !

MenuMorph removeSelector: #add:selector:argument:!

MenuMorph removeSelector: #add:selector:argument:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3318-BigMenuRefactor-p20-JuanVuletich-2018May06-11h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3318] on 6 May 2018 at 4:50:12 pm'!
!TextEditor methodsFor: 'attributes' stamp: 'jmv 5/6/2018 16:14:40' prior: 16931498!
                   changeEmphasisOrAlignment
	"This is a user command, and generates undo"

	| menuStrings aList reply code align menuList startIndex attribute |
	startIndex _ self startIndex.
	aList _ #(normal bold italic underlined struckThrough leftFlush centered rightFlush justified).
	align _ model actualContents alignmentAt: startIndex.
	code _ model actualContents emphasisAt: startIndex.
	menuList _ WriteStream on: Array new.
	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal'.
	menuList nextPutAll: (#(bold italic underlined struckThrough superscript subscript withST80Glyphs) collect: [ :emph |
		(code anyMask: (TextEmphasis perform: emph) emphasisCode)
			ifTrue: [ '<on>', emph asString ]
			ifFalse: [ '<off>', emph asString ]]).
	menuList nextPutAll: (#(leftFlush centered rightFlush justified) withIndexCollect: [ :type :i |
		align = (i-1)
			ifTrue: [ '<on>', type asString ]
			ifFalse: [ '<off>', type asString ]]).
	menuStrings _ menuList contents.
	aList _ #(normal bold italic underlined struckThrough superscript subscript withST80Glyphs leftFlush centered rightFlush justified).
	reply _ (SelectionMenu labelList: menuStrings lines: #(1 8) selections: aList) startUpMenu.
	reply ifNotNil: [
		(#(leftFlush centered rightFlush justified) includes: reply)
			ifTrue: [
				attribute _ TextAlignment perform: reply]
			ifFalse: [
				attribute _ TextEmphasis perform: reply].
		((menuStrings at: (aList indexOf: reply)) beginsWith: '<on>')
			ifTrue: [ self unapplyAttributes: {attribute} ]
			ifFalse: [ self applyAttribute:  attribute ]].
	^ true! !
!Preferences class methodsFor: 'menu icons' stamp: 'jmv 5/6/2018 16:43:04' prior: 50391880!
                    useMenuIcons

	self setPreference: #wantsMenuIcons toValue: true.
	Theme current class beCurrent! !
!Preferences class methodsFor: 'menu icons' stamp: 'jmv 5/6/2018 16:43:10' prior: 50391885!
useNoMenuIcons

	self setPreference: #wantsMenuIcons toValue: false.
	Theme current class beCurrent! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 5/6/2018 16:38:18' prior: 50372203!
                 bigFonts
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences bigFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 11)
			(setListFontTo: 11)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 11)
			(setButtonFontTo: 11)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 5/6/2018 16:38:21' prior: 50372219!
         hugeFonts
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences hugeFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 17)
			(setListFontTo: 17)
			(setMenuFontTo: 17)
			(setWindowTitleFontTo: 22)
			(setCodeFontTo: 17)
			(setButtonFontTo: 17)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 5/6/2018 16:38:23' prior: 50372235!
                             smallFonts
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences smallFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 8)
			(setMenuFontTo: 8)
			(setWindowTitleFontTo: 11)
			(setCodeFontTo: 8)
			(setButtonFontTo: 8)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 5/6/2018 16:38:26' prior: 50372251!
          standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 5/6/2018 16:38:28' prior: 50372267!
                               tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 7)
			(setListFontTo: 5)
			(setMenuFontTo: 5)
			(setWindowTitleFontTo: 7)
			(setCodeFontTo: 5)
			(setButtonFontTo: 5)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 5/6/2018 16:38:30' prior: 50372283!
   veryBigFonts
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences veryBigFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 14)
			(setListFontTo: 14)
			(setMenuFontTo: 14)
			(setWindowTitleFontTo: 17)
			(setCodeFontTo: 14)
			(setButtonFontTo: 14)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 5/6/2018 16:38:32' prior: 50372299!
                       verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences verySmallFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 7)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 5/6/2018 16:04:24' prior: 16934722!
                      startMessageTally
	"Tally on all the processes in the system, and not only the UI"
	
	| d |
	(self confirm: 'MessageTally all the processes in
the system, until the mouse pointer
goes to the top of the screen') ifTrue: [
		[
			d _ Delay forMilliseconds: 100.
			AndreasSystemProfiler spyAllOn: [
				[Sensor peekMousePt y > 10] whileTrue: [d wait]]
			] forkAt: Processor userInterruptPriority
		]! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 16:07:49' prior: 50396888!
                     debugMenu

	^ (self menu: 'Debug...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#inspect.
				#icon 			-> 		#inspectIcon.
			} asDictionary.
			{
				#label 			-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#explore.
				#icon 			-> 		#exploreIcon.
			} asDictionary.
			{
				#label 			-> 		'MessageTally all Processes'.
				#selector 		-> 		#startMessageTally.
				#icon 			-> 		#systemMonitorIcon.
			} asDictionary.
			nil.
			{
				#label 			-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#removeAllKnownFailing.
				#icon 			-> 		#graphicsIcon.
			} asDictionary.
			{
				#label 			-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#resumeAfterStepError.
				#icon 			-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#label 			-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 		-> 		#closeAllDebuggers.
				#icon 			-> 		#closeIcon.
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 16:21:32' prior: 50397037!
                 preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		Preferences.
				#selector 		-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		Preferences.
				#selector 		-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Font Sizes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 		-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 		-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 		-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 		-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`! !
!Theme class methodsFor: 'instance creation' stamp: 'jmv 5/6/2018 16:45:50' prior: 16936855!
      beCurrent
	self currentTheme: self.
	self inform: 'Please close and reopen all windows'! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 5/6/2018 16:42:00' prior: 16936893!
           changeFontSizes

	(MenuMorph new defaultTarget: Preferences)
		addTitle: 'Choose a size';
		addStayUpIcons;
		add: 'Huge Fonts' action: #hugeFonts;
		add: 'Very big Fonts' action: #veryBigFonts;
		add: 'Big Fonts' action: #bigFonts;
		add: 'Standard Fonts' action: #standardFonts;
		add: 'Small Fonts' action: #smallFonts;
		add: 'Very small Fonts'action: #verySmallFonts;
		add: 'Tiny Fonts'action: #tinyFonts;
		popUpInWorld: self runningWorld! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 5/6/2018 16:43:14' prior: 50392065!
     changeIcons

	(MenuMorph new defaultTarget: Preferences)
		addTitle: 'Menu Icons';
		addStayUpIcons;
		add: 'Use icons for menu entries' action: #useMenuIcons;
		add: 'Don''t use icons for menu entries' action: #useNoMenuIcons;
		popUpInWorld: self runningWorld! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 5/6/2018 16:49:26' prior: 16936926!
                             changeTheme

	| menu |
	menu _ MenuMorph new.
	menu
		addTitle: 'Choose a theme';
		addStayUpIcons.
	Theme withAllSubclassesDo: [ :themeClass |
		menu add: themeClass name target: themeClass action: #beCurrent ].
	menu popUpInWorld: self runningWorld! !
!Theme class methodsFor: 'icons by menu' stamp: 'jmv 5/6/2018 16:44:00' prior: 50390828!
         addBasicIconsTo: aCollectorCollection

	aCollectorCollection
		add: #('save' ) -> #saveIcon;
		add: #('change category...' 'rename') -> #saveAsIcon;
		add: #('quit') -> #quitIcon;
		add: #('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher' 'stop CPUWatcher')
			-> #inspectIcon;
		add: #('explore' 'explore it (I)' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'references finder' 'weight explorer' 'explore CompiledMethod') -> #exploreIcon;
		add: #('find...(f)' 'find class... (f)' 'find method...' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon;
		add: #('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon;
		add: #('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript''stop StackSizeWatcher' ) -> #deleteIcon;
		add: #('delete method from changeset (d)' 'delete class from change set (d)' 'revert & remove from changes' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete' 'start StackSizeWatcher') -> #warningIcon;
		add: #('revert to previous version') -> #undoIcon;
		add: #('copy to clipboard (c)' 'copy class...' 'copy name to clipboard') -> #copyIcon
! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 5/6/2018 16:27:31' prior: 16890977!
                         startUpWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self startUpWithCaption: captionOrNil at: Sensor mousePoint allowKeyboard: Preferences menuKeyboardControl! !

PopUpMenu removeSelector: #startUpWithCaption:at:!

PopUpMenu removeSelector: #startUpWithCaption:at:!

PopUpMenu removeSelector: #startUpWithoutKeyboard!

PopUpMenu removeSelector: #startUpWithoutKeyboard!

TheWorldMenu removeSelector: #changeBackgroundColor!

TheWorldMenu removeSelector: #changeBackgroundColor!

TheWorldMenu removeSelector: #setDisplayDepth!

TheWorldMenu removeSelector: #setDisplayDepth!

TheWorldMenu removeSelector: #startThenBrowseMessageTally!

TheWorldMenu removeSelector: #startThenBrowseMessageTally!

ProgressBarMorph removeSelector: #addCustomMenuItems:hand:!

ProgressBarMorph removeSelector: #addCustomMenuItems:hand:!

ProgressBarMorph removeSelector: #changeProgressColor:!

ProgressBarMorph removeSelector: #changeProgressColor:!

ProgressBarMorph removeSelector: #changeProgressValue:!

ProgressBarMorph removeSelector: #changeProgressValue:!

ProgressBarMorph removeSelector: #progressColor!

ProgressBarMorph removeSelector: #progressColor!

ProgressBarMorph removeSelector: #progressColor:!

ProgressBarMorph removeSelector: #progressColor:!

Morph removeSelector: #changeColorTarget:selector:originalColor:hand:!

Morph removeSelector: #changeColorTarget:selector:originalColor:hand:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3319-BigMenuRefactor-p21-JuanVuletich-2018May06-15h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3293] on 10 May 2018 at 8:53:39 pm'!
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 5/10/2018 20:52:39'!
                          extent: aPoint
	"Native depth"

	^self extent: aPoint depth: (Smalltalk isLittleEndian ifTrue: [ -8 ] ifFalse: [ 8 ])! !
!Color class methodsFor: 'class initialization' stamp: 'jmv 5/10/2018 20:43:18' prior: 50386360!
      initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"
	Color initializeIndexedColors
	"
	"
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: (Color r: 1 g: 0 b: 0); display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: (Color r: 0 g: 1 b: 0); display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: (Color r: 0 g: 0 b: 1); display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: (Color r: 0.5 g: 0.5 b: 0.5); display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: Color blue; display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: Color green; display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: Color red; display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: Color cyan; display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: Color yellow; display.
ColorForm extent: 128@128 :: fillColor: Color black :: colorAt: 10@10 put: Color magenta; display.
	"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: `Color r: 1.0 g: 1.0 b: 1.0`.		"white or transparent"
	a at: 2 put: `Color r: 0.0 g: 0.0 b: 0.0`.	"black"

	"additional colors for 2-bit color"
	a at: 3 put: `Color r: 1.0 g: 1.0 b: 1.0`.	"opaque white"
	a at: 4 put: `Color r: 0.5 g: 0.5 b: 0.5`.	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: Color red.
	a at:  6 put: Color green.
	a at:  7 put: Color blue.
	a at:  8 put: Color cyan.
	a at:  9 put: Color yellow.
	a at: 10 put: Color magenta.

	a at: 11 put: `Color r: 0.125 g: 0.125 b: 0.125`.		"1/8 gray"
	a at: 12 put: `Color r: 0.25 g: 0.25 b: 0.25`.			"2/8 gray"
	a at: 13 put: `Color r: 0.375 g: 0.375 b: 0.375`.		"3/8 gray"
	a at: 14 put: `Color r: 0.625 g: 0.625 b: 0.625`.		"5/8 gray"
	a at: 15 put: `Color r: 0.75 g: 0.75 b: 0.75`.			"6/8 gray"
	a at: 16 put: `Color r: 0.875 g: 0.875 b: 0.875`.		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Color r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube may repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Color r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	Color initializeIndexedColors!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3320-ColorForm-fix-JuanVuletich-2018May10-20h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3319] on 13 May 2018 at 3:03:58 pm'!
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 18:53:59' prior: 50396209!
                  classListMenu
	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class List'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutClass.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'show hierarchy'.
				#object 			-> 		#model.
				#selector 		-> 		#hierarchy.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'show definition'.
				#object 			-> 		#model.
				#selector 		-> 		#editClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'show comment'.
				#object 			-> 		#model.
				#selector 		-> 		#editComment.
				#icon 			-> 		#findIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class vars'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'rename class ...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#label 			-> 		'copy class...'.
				#object 			-> 		#model.
				#selector 		-> 		#copyClass.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runClassTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 18:42:05' prior: 50396111!
                         classListMenu2
	"Set up the menu to apply to the receiver's class list when the shift key is down"

	| aMenu |
	aMenu := MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'unsent methods'.
				#selector 		-> 		#browseUnusedMethods.
				#icon 			->		#junkIcon.
				#balloonText 	-> 		'browse all methods defined by this class that have no senders'
			} asDictionary.
			{
				#label 			-> 		'unreferenced inst vars'.
				#selector 		-> 		#showUnreferencedInstVars.
				#icon 			->		#junkIcon.
				#balloonText 	-> 		'show a list of all instance variables that are not referenced in methods'
			} asDictionary.
			{
				#label 			-> 		'unreferenced class vars'.
				#selector 		-> 		#showUnreferencedClassVars.
				#icon 			->		#junkIcon.
				#balloonText 	-> 		'show a list of all class variables that are not referenced in methods'
			} asDictionary.
			{
				#label 			-> 		'subclass template'.
				#object 			-> 		#model.
				#selector 		-> 		#makeNewSubclass.
				#icon 			->		#classIcon.
				#balloonText 	-> 		'put a template into the code pane for defining of a subclass of this class'
			} asDictionary.
			nil.
			{
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			->		#instanceIcon.
				#balloonText 	-> 		'give me a sample instance of this class, if possible'
			} asDictionary.
			{
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			->		#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class'
			} asDictionary.
			{
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			->		#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class and of all of its subclasses'
			} asDictionary.
			nil.
			{
				#label 			-> 		'create inst var accessors'.
				#object 			-> 		#model.
				#selector 		-> 		#createInstVarAccessors.
				#icon 			->		#sendReceiveIcon.
				#balloonText 	-> 		'compile instance-variable access methods for any instance variables that do not yet have them'
			} asDictionary.
			nil.
			{
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu.
				#icon 			->		#listAddIcon.
				#balloonText 	-> 		'return to the standard class-list menu'
			} asDictionary.
		}`.
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 18:59:39' prior: 50338703!
                         messageCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.			"All the options are for the model."
	aMenu addTitle: 'Message Category'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fileOut'.
				#selector 		-> 		#fileOutMessageCategories.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'reorganize'.
				#selector 		-> 		#editMessageCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#label 			-> 		'alphabetize'.
				#selector 		-> 		#alphabetizeMessageCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#label 			-> 		'remove empty categories'.
				#selector 		-> 		#removeEmptyCategories.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#label 			-> 		'categorize all uncategorized'.
				#selector 		-> 		#categorizeAllUncategorizedMethods.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#label 			-> 		'new category...'.
				#selector 		-> 		#addCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'rename...'.
				#selector 		-> 		#renameCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#label 			-> 		'remove'.
				#selector 		-> 		#removeMessageCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Run tests'.
				#selector 		-> 		#runMessageCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 20:10:56' prior: 50396243!
                             messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Message List'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'what to show...'.
				#selector 		-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
            	nil.
			{
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'browse method (O)'.
				#selector 		-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#label 			-> 		'explore CompiledMethod'.
				#object 			-> 		#model.
				#selector 		-> 		#exploreCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'senders of... (n)'.
				#selector 		-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#label 			-> 		'implementors of... (m)'.
				#selector 		-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#label 			-> 		'inheritance (i)'.
				#selector 		-> 		#methodHierarchy.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#label 			-> 		'versions (v)'.
				#selector 		-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class variables'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#label 			-> 		'Run test (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#label 			-> 		'Debug test (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'more...'.
				#selector 		-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 20:25:02' prior: 50396156!
                               messageListMenu2
	"Fill aMenu with the items appropriate when the shift key is held down"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Message List'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleDiffing.
				#icon 			-> 		#switchIcon
			} asDictionary.
			{
				#label 			-> 		'implementors of sent messages'.
				#selector 		-> 		#browseAllMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'local senders of...'.
				#selector 		-> 		#browseLocalSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#label 			-> 		'local implementors of...'.
				#selector 		-> 		#browseLocalImplementors.
				#icon 			-> 		#classIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'spawn sub-protocol'.
				#selector 		-> 		#browseProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#label 			-> 		'spawn full protocol'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#speadsheetTemplateIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
		}`.

	self addExtraMenu2ItemsTo: aMenu.
	aMenu add: 'change category...' target: model action: #changeCategory icon: #saveAsIcon.

	model canShowMultipleMessageCategories ifTrue: [	
		aMenu add: 'show category (C)' target: model action: #showHomeCategory icon: #packageIcon ].
	aMenu
		add: 'change sets with this method' action: #findMethodInChangeSets icon: #changesIcon;
		add: 'revert to previous version' target: model action: #revertToPreviousVersion icon: #undoIcon;
		addLine;
		add: 'more...' action: #openMessageListMenu icon: #listAddIcon.
	^ aMenu! !
!CodeFileBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 18:53:57' prior: 16809604!
                       classListMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class List'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'definition'.
				#object 			-> 		#model.
				#selector 		-> 		#editClass.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'comment'.
				#object 			-> 		#model.
				#selector 		-> 		#editComment.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'fileIn'.
				#object 			-> 		#model.
				#selector 		-> 		#fileInClass.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutClass.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'remove existing'.
				#object 			-> 		#model.
				#selector 		-> 		#removeUnmodifiedCategories.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	^aMenu! !
!CodeFileBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 19:03:29' prior: 16809635!
                              messageCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.			"All the options are for the model."
	aMenu addTitle: 'Message Category'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fileIn'.
				#selector 		-> 		#fileInMessageCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#label 			-> 		'fileOut'.
				#selector 		-> 		#fileOutMessageCategories.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'reorganize'.
				#selector 		-> 		#editMessageCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'add item...'.
				#selector 		-> 		#addCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'rename...'.
				#selector 		-> 		#renameCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#label 			-> 		'remove'.
				#selector 		-> 		#removeMessageCategory.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'remove existing'.
				#selector 		-> 		#removeUnmodifiedMethods.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	^ aMenu! !
!CodeFileBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 20:10:06' prior: 16809652!
                         messageListMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Message List'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fileIn'.
				#object 			-> 		#model.
				#selector 		-> 		#fileInMessage.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'senders (n)'.
				#selector 		-> 		#browseSenders.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#label 			-> 		'implementors (m)'.
				#selector 		-> 		#browseImplementors.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#label 			-> 		'method inheritance (h)'.
				#selector 		-> 		#methodHierarchy.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#label 			-> 		'versions (v)'.
				#selector 		-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	^ aMenu! !
!MessageSetWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 20:22:14' prior: 50396195!
                  addExtraMenu2ItemsTo: aMenu
	"The shifted selector-list menu is being built.  Add items specific to MessageSet"

	model growable ifTrue: [
		aMenu
			addItemsFromDictionaries: `{
				{
					#label 			-> 		'remove from this browser'.
					#object 			-> 		#model.
					#selector 		-> 		#removeMessageFromBrowser.
					#icon 			-> 		#listRemoveIcon
				} asDictionary.
				{
					#label 			-> 		'filter message list...'.
					#selector 		-> 		#filterMessageList.
					#icon 			-> 		#findIcon
				} asDictionary.
			}`.
		].
	aMenu add: 'sort by date' target: model action: #sortByDate icon: #dateIcon! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/7/2018 18:53:45' prior: 50397417!
       classListMenu
	"Fill aMenu with items appropriate for the class list"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class List'.
	aMenu 
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'delete class from change set (d)'.
				#object 			-> 		#model.
				#selector 		-> 		#forgetClass.
				#icon 			-> 		#warningIcon
			} asDictionary.
			{
				#label 			-> 		'remove class from system (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class vars'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
		}`.
	^ aMenu! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3321-BigMenuRefactor-p22-JuanVuletich-2018May13-14h50m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3319] on 13 May 2018 at 3:33:06 pm'!
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 15:28:48' prior: 16793385!
         systemCatSingletonMenu

	| aMenu |
	self flag: #renameSystemCategory.	"temporarily disabled"
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class category'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse all'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'update'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	^aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 15:32:04' prior: 50338765!
           systemCategoryMenu

	| aMenu |
	self flag: #renameSystemCategory.	"temporarily disabled"
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class category'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'recent classes... (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#recent.
				#icon 			-> 		#clockIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse all'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editSystemCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#label 			-> 		'alphabetize'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeSystemCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'update'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#label 			-> 		'add item...'.
				#object 			-> 		#model.
				#selector 		-> 		#addSystemCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'move to top'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryTop.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'move up'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryUp.
				#icon 			-> 		#goUpIcon
			} asDictionary.
			{
				#label 			-> 		'move down'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryDown.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#label 			-> 		'move to bottom'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryBottom.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runSystemCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	^aMenu! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3322-BigMenuRefactor-p23-JuanVuletich-2018May13-15h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3319] on 13 May 2018 at 4:26:25 pm'!
!CodeFileBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 15:58:47' prior: 16809623!
                     codeFileListMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Code File'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass
			} asDictionary.
			nil.
			{
				#label 			-> 		'fileIn'.
				#object 			-> 		#model.
				#selector 		-> 		#fileIn
			} asDictionary.
			{
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOut
			} asDictionary.
			{
				#label 			-> 		'remove existing'.
				#object 			-> 		#model.
				#selector 		-> 		#removeUnmodifiedClasses
			} asDictionary.
		}`.
	^ aMenu! !
!ChangeListWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 15:53:28' prior: 50344451!
                    listMenu
	"Fill aMenu up so that it comprises the primary changelist-browser menu"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Change List'.
	aMenu addStayUpIcons.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fileIn selections'.
				#object 			-> 		#model.
				#selector 		-> 		#fileInSelections.
				#balloonText 	-> 		'import the selected items into the image'.
			} asDictionary.
			{
				#label 			-> 		'fileOut selections...	'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSelections.
				#balloonText 	-> 		'create a new file containing the selected items'.
			} asDictionary.
			{
				#label 			-> 		'fileOut current version of selections...'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutCurrentVersionsOfSelections.
				#balloonText 	-> 		'create a new file containing the current (in-image) counterparts of the selected methods'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'compare to current'.
				#object 			-> 		#model.
				#selector 		-> 		#compareToCurrentVersion.
				#balloonText 	-> 		'open a separate window which shows the text differences between the on-file version and the in-image version.'.
			} asDictionary.
			{
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleDiffing.
				#balloonText 	-> 		'start or stop showing diffs in the code pane.'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'select new methods'.
				#object 			-> 		#model.
				#selector 		-> 		#selectNewMethods.
				#balloonText 	-> 		'select methods in the file that do not currently exist in the image'.
			} asDictionary.
			{
				#label 			-> 		'select changes for absent classes'.
				#object 			-> 		#model.
				#selector 		-> 		#selectAllForAbsentClasses.
				#balloonText 	-> 		'select methods in the file for classes that are not defined in the image'.
			} asDictionary.
			{
				#label 			-> 		'select all changes for this class'.
				#object 			-> 		#model.
				#selector 		-> 		#selectAllForThisClass.
				#balloonText 	-> 		'select all methods in the file that belong to the currently-selected class'.
			} asDictionary.
			{
				#label 			-> 		'select unchanged methods'.
				#object 			-> 		#model.
				#selector 		-> 		#selectUnchangedMethods.
				#balloonText 	-> 		'select methods in the file whose in-image versions are the same as their in-file counterparts'.
			} asDictionary.
			{
				#label 			-> 		'select methods equivalent to current'.
				#object 			-> 		#model.
				#selector 		-> 		#selectEquivalentMethods.
				#balloonText 	-> 		'select methods in the file whose in-image versions have the same behavior as their in-file counterparts'.
			} asDictionary.
			{
				#label 			-> 		'select methods older than current'.
				#object 			-> 		#model.
				#selector 		-> 		#selectMethodsOlderThanCurrent.
				#balloonText 	-> 		'select methods in the file that are older than the one currently in the image'.
			} asDictionary.
			{
				#label 			-> 		'select removals of sent methods'.
				#object 			-> 		#model.
				#selector 		-> 		#selectRemovalsOfSent.
				#balloonText 	-> 		'select all method removals of methods that have some sender in the image'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'select all (a)'.
				#object 			-> 		#model.
				#selector 		-> 		#selectAll.
				#balloonText 	-> 		'select all the items in the list'.
			} asDictionary.
			{
				#label 			-> 		'deselect all'.
				#object 			-> 		#model.
				#selector 		-> 		#deselectAll.
				#balloonText 	-> 		'deselect all the items in the list'.
			} asDictionary.
			{
				#label 			-> 		'invert selections'.
				#object 			-> 		#model.
				#selector 		-> 		#invertSelections.
				#balloonText 	-> 		'select every item that is not currently selected, and deselect every item that *is* currently selected'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse class and method'.
				#selector 		-> 		#browseMethodFull.
				#balloonText 	-> 		'open a full browser showing the selected method'.
			} asDictionary.
			{
				#label 			-> 		'browse all versions of single selection'.
				#selector 		-> 		#browseVersions.
				#balloonText 	-> 		'open a version browser showing the versions of the currently selected method'.
			} asDictionary.
			{
				#label 			-> 		'browse current versions of selections'.
				#selector 		-> 		#browseCurrentVersionsOfSelections.
				#balloonText 	-> 		'open a message-list browser showing the current (in-image) counterparts of the selected methods'.
			} asDictionary.
			{
				#label 			-> 		'destroy current methods of selections'.
				#object 			-> 		#model.
				#selector 		-> 		#destroyCurrentCodeOfSelections.
				#balloonText 	-> 		'remove (*destroy*) the in-image counterparts of all selected methods'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'remove doIts'.
				#object 			-> 		#model.
				#selector 		-> 		#removeDoIts.
				#balloonText 	-> 		'remove all items that are doIts rather than definitions'.
			} asDictionary.
			{
				#label 			-> 		'remove older versions'.
				#object 			-> 		#model.
				#selector 		-> 		#removeOlderMethodVersions.
				#balloonText 	-> 		'remove all but the most recent versions of methods in the list'.
			} asDictionary.
			{
				#label 			-> 		'remove up-to-date versions'.
				#object 			-> 		#model.
				#selector 		-> 		#removeUpToDate.
				#balloonText 	-> 		'remove all items whose code is the same as the counterpart in-image code'.
			} asDictionary.
			{
				#label 			-> 		'remove empty class comments'.
				#object 			-> 		#model.
				#selector 		-> 		#removeEmptyClassComments.
				#balloonText 	-> 		'remove all empty class comments'.
			} asDictionary.
			{
				#label 			-> 		'remove selected items'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSelections.
				#balloonText 	-> 		'remove the selected items from the change-list'.
			} asDictionary.
			{
				#label 			-> 		'remove unselected items'.
				#object 			-> 		#model.
				#selector 		-> 		#removeNonSelections.
				#balloonText 	-> 		'remove all the items not currently selected from the change-list'.
			} asDictionary.
		}`.
	^ aMenu! !
!DebuggerWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 16:02:25' prior: 16831143!
                       contextFieldListMenu
	"Arm the supplied menu with items for the field-list of the receiver"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'explore (I)'.
				#selector 		-> 		#exploreContextSelection
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#contextClassHierarchy
			} asDictionary.
		}`.
	^ aMenu! !
!DebuggerWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 16:05:17' prior: 50391627!
                        contextStackMenu
	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fullStack (f)'.
				#selector 		-> 		#fullStack
			} asDictionary.
			{
				#label 			-> 		'restart (r)'.
				#selector 		-> 		#restarl
			} asDictionary.
			{
				#label 			-> 		'proceed (p)'.
				#selector 		-> 		#proceed
			} asDictionary.
			{
				#label 			-> 		'step (t)'.
				#selector 		-> 		#doStep
			} asDictionary.
			{
				#label 			-> 		'step through (T)'.
				#selector 		-> 		#stepIntoBlock
			} asDictionary.
			{
				#label 			-> 		'send (e)'.
				#selector 		-> 		#send
			} asDictionary.
			{
				#label 			-> 		'where (w)'.
				#selector 		-> 		#where
			} asDictionary.
			{
				#label 			-> 		'peel to first like this'.
				#selector 		-> 		#peelToFirst
			} asDictionary.
			nil.
			{
				#label 			-> 		'return entered value'.
				#selector 		-> 		#returnValue
			} asDictionary.
			{
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleBreakOnEntry
			} asDictionary.
		}`.
	^aMenu! !
!DebuggerWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 16:01:41' prior: 16831180!
     receiverFieldListMenu
	"Arm the supplied menu with items for the field-list of the receiver"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'explore (I)'.
				#selector 		-> 		#exploreReceiverSelection
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#receiverClassHierarchy
			} asDictionary.
		}`.
	^ aMenu! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 16:07:20' prior: 16843430!
                     volumeMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory.
	^ aMenu! !
!InspectorWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 16:19:22' prior: 50376358!
                   fieldListMenu
	"Arm the supplied menu with items for the field-list of the receiver"

	| aMenu object |
	aMenu _ MenuMorph new defaultTarget: self.

	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'inspect (i)'.
				#selector 		-> 		#inspectSelection.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#label 			-> 		'explore (I)'.
				#selector 		-> 		#exploreSelection.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#label 			-> 		'copy to clipboard (c)'.
				#selector 		-> 		#copySelectionToClipboard.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'basic inspect'.
				#selector 		-> 		#inspectBasic.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#label 			-> 		'references finder'.
				#selector 		-> 		#openReferencesFinder.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#label 			-> 		'weight explorer'.
				#selector 		-> 		#openWeightExplorer.
				#icon 			-> 		#exploreIcon
			} asDictionary.
		}`.

	object _ model object.
	(object is: #Dictionary) ifTrue: [
		aMenu addItemsFromDictionaries: `{
			nil.
			{
				#label 			-> 		'senders of this key'.
				#selector 		-> 		#sendersOfSelectedKey.
			} asDictionary.
			{
				#label 			-> 		'add key'.
				#selector 		-> 		#addEntry.
			} asDictionary.
			{
				#label 			-> 		'rename key'.
				#selector 		-> 		#renameEntry.
			} asDictionary.
			{
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSelection.
			} asDictionary.
		}` ]
	
	ifFalse: [ (object is: #Set) ifTrue: [
		aMenu addItemsFromDictionaries: `{
			nil.
			{
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSelection.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
		}` ]].

	aMenu
		addItemsFromDictionaries: `{
		nil.
			{
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
		}`.
	^ aMenu! !
!ObjectExplorerWindow methodsFor: 'building menus' stamp: 'jmv 5/13/2018 16:25:51' prior: 50393093!
                  genericMenu
	"Borrow a menu from my inspector"
	
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	model getCurrentSelection
		ifNil: [
			aMenu
				add: '*nothing selected*'
				target: self
				action: #yourself]
		ifNotNil: [
			aMenu
				addItemsFromDictionaries: `{
					{
						#label 			-> 		'inspect (i)'.
						#selector 		-> 		#inspectSelection.
						#icon 			-> 		#inspectIcon
					} asDictionary.
					{
						#label 			-> 		'explore (I)'.
						#selector 		-> 		#exploreSelection.
						#icon 			-> 		#exploreIcon
					} asDictionary.
					{
						#label 			-> 		'copy to clipboard (c)'.
						#selector 		-> 		#copySelectionToClipboard.
						#icon 			-> 		#copyIcon
					} asDictionary.
					{
						#label 			-> 		'basic inspect'.
						#selector 		-> 		#inspectBasic.
						#icon 			-> 		#inspectIcon
					} asDictionary.
					{
						#label 			-> 		'references finder'.
						#selector 		-> 		#openReferencesFinder.
						#icon 			-> 		#exploreIcon
					} asDictionary.
					{
						#label 			-> 		'weight explorer'.
						#selector 		-> 		#openWeightExplorer.
						#icon 			-> 		#exploreIcon
					} asDictionary.
					nil.
					{
						#label 			-> 		'browse full (b)'.
						#selector 		-> 		#browseMethodFull.
						#icon 			-> 		#editFindReplaceIcon
					} asDictionary.
					{
						#label 			-> 		'browse hierarchy (h)'.
						#selector 		-> 		#browseHierarchy.
						#icon 			-> 		#goTopIcon
					} asDictionary.
					{
						#label 			-> 		'browse protocol (p)'.
						#selector 		-> 		#browseFullProtocol.
						#icon 			-> 		#spreadsheetIcon
					} asDictionary.
				}`.
			aMenu addLine;
				add: 'monitor changes'
				target: self
				action: #monitor:
				argument: model getCurrentSelection.
			model class == ReferencesExplorer ifTrue: [
				aMenu addLine;
					add: 'rescan'
					target: self
					action: #rescan ]].
	model basicMonitorList isEmptyOrNil
		ifFalse: [
			aMenu addLine;
				add: 'stop monitoring all'
				target: self
				action: #stopMonitoring ].
	^ aMenu! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3323-BigMenuRefactor-p24-JuanVuletich-2018May13-15h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3323] on 13 May 2018 at 6:14:25 pm'!
!AbstractFont class methodsFor: 'instance accessing' stamp: 'jmv 5/13/2018 18:14:09'!
    availableFonts
	^AvailableFonts! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3324-availableFonts-JuanVuletich-2018May13-18h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3323] on 13 May 2018 at 6:53:04 pm'!
!MenuMorph methodsFor: 'construction' stamp: 'jmv 5/13/2018 18:48:20'!
                        add: aString action: aSymbol balloonText: stringOrText
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."
	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."

	^(self add: aString
		target: defaultTarget
		action: aSymbol
		argumentList: #())
			setBalloonText: stringOrText! !
!MessageSetWindow methodsFor: 'menu commands' stamp: 'jmv 5/13/2018 18:52:01' prior: 16870467!
                              filterMessageList
	"Allow the user to refine the list of messages."

	| aMenu |
	model messageList size <= 1 
		ifTrue: [ ^self inform: 'this is not a propitious filtering situation' ].

	aMenu _ MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Filter by only showing...'.
	aMenu addStayUpIcons.
	aMenu 
		add: 'unsent messages' action: #filterToUnsentMessages balloonText: 'filter to show only messages that have no senders';
		addLine;
		add: 'messages that send...' action: #filterToSendersOf balloonText: 'filter to show only messages that send a selector I specify';
		add: 'messages that do not send...' action: #filterToNotSendersOf balloonText: 'filter to show only messages that do not send a selector I specify';
		addLine;
		add: 'messages whose selector is...' action: #filterToImplementorsOf balloonText: 'filter to show only messages with a given selector I specify';
		add: 'messages whose selector is NOT...' action: #filterToNotImplementorsOf balloonText: 'filter to show only messages whose selector is NOT a seletor I specify';
		addLine;
		add: 'messages in any change set' action: #filterToAnyChangeSet balloonText: 'filter to show only messages that occur in at least one change set';
		add: 'messages not in any change set' action: #filterToNotAnyChangeSet balloonText: 'filter to show only messages that do not occur in any change set in the system';
		addLine;
		add: 'messages authored by me' action: #filterToCurrentAuthor balloonText: 'filter to show only messages whose authoring stamp has my initials';
		add: 'messages not authored by me' action: #filterToNotCurrentAuthor balloonText: 'filter to show only messages whose authoring stamp does not have my initials';
		addLine;
		add: 'messages logged in .changes file' action: #filterToMessagesInChangesFile balloonText: 'filter to show only messages whose latest source code is logged in the .changes file';
		add: 'messages only in .sources file' action: #filterToMessagesInSourcesFile balloonText: 'filter to show only messages whose latest source code is logged in the .sources file';
		addLine;
		add: 'messages with prior versions' action: #filterToMessagesWithPriorVersions balloonText: 'filter to show only messages that have at least one prior version';
		add: 'messages without prior versions' action: #filterToMessagesWithoutPriorVersions balloonText: 'filter to show only messages that have no prior versions';
		addLine;
		add: 'uncommented messages' action: #filterToUncommentedMethods balloonText: 'filter to show only messages that do not have comments at the beginning';
		add: 'commented messages' action: #filterToCommentedMethods balloonText: 'filter to show only messages that have comments at the beginning'.
	aMenu popUpInWorld: self world! !
!MessageNamesWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 18:17:58' prior: 16867824!
                               selectorListMenu
	"Answer the menu associated with the selectorList"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	(aMenu add: 'senders (n)' action: #browseSenders icon: #mailForwardIcon)
		setBalloonText: 'browse senders of the chosen selector'.
	^ aMenu! !
!ProcessBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 18:44:18' prior: 50390021!
               processListMenu
	| menu rules |
	menu _ MenuMorph new defaultTarget: self.

	model selectedProcess
		ifNotNil: [ :selectedProcess |
			rules _ model class rulesFor: model selectedProcess.
			menu
				add: 'inspect (i)'				action: #inspectProcess 				icon: #inspectIcon;
				add: 'explore (I)'				action: #exploreProcess 				icon: #exploreIcon;
				add: 'references finder'	action: #openReferencesFinder 		icon: #exploreIcon.
			rules first
				ifTrue: [
					menu add: 'terminate (t)' target: model action: #terminateProcess icon: #cancelIcon.
					selectedProcess isSuspended
						ifTrue: [menu add: 'resume (r)' target: model action: #resumeProcess icon: #mediaPlaybackStartIcon]
						ifFalse: [menu add: 'suspend (s)' target: model action: #suspendProcess icon: #chatIcon]].
			rules second
				ifTrue: [
					menu
						add: 'change priority (p)'	action: #changePriority 	icon: #systemMonitorIcon;
						add: 'debug (d)'				action: #debugProcess 	icon: #debugIcon ].
			(selectedProcess suspendingList isKindOf: Semaphore)
				ifTrue: [menu add: 'signal Semaphore (S)' target: model action: #signalSemaphore icon: #haloHelpIcon ].
			menu add: 'full stack (k)' target: model action: #moreStack icon: #systemIcon.
			menu addLine].

	menu
		add: 'find context... (f)'					action: #findContext 	icon: #findIcon;
		add: 'find again (g)'	target: model 	action: #nextContext 	icon: #systemIcon.
	menu addLine.

	isStepping
		ifTrue: [ 	menu add: 'turn off auto-update (a)' 	action: #toggleAutoUpdate icon: #cancelIcon ]
		ifFalse: [ 	menu add: 'turn on auto-update (a)' 	action: #toggleAutoUpdate icon: #updateIcon ].
		
	menu add: 'update list (u)' target: model action: #updateProcessList icon: #updateIcon.

	menu addLine.
	CPUWatcher isMonitoring
			ifTrue: [ menu add: 'stop CPUWatcher' action: #stopCPUWatcher icon: #inspectIcon ]
			ifFalse: [ menu add: 'start CPUWatcher' action: #startCPUWatcher icon: #inspectIcon ].
	StackSizeWatcher isWatching
			ifTrue: [ menu add: 'stop StackSizeWatcher' action: #stopStackSizeWatcher icon: #inspectIcon ]
			ifFalse: [ menu add: 'start StackSizeWatcher' action: #startStackSizeWatcher  icon: #inspectIcon ].

	^ menu! !
!ProcessBrowserWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2018 18:25:38' prior: 16895392!
   stackListMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	model selectedContext
		ifNil: [^ aMenu].
	aMenu
		add: 'inspect context (c)' 		action: #inspectContext icon: #inspectIcon;
		add: 'explore context (C)' 		action: #exploreContext icon: #exploreIcon;
		add: 'inspect receiver (i)' 		action: #inspectReceiver icon: #inspectIcon;
		add: 'explore receiver (I)' 		action: #exploreReceiver icon: #exploreIcon;
		add: 'browse (b)' 				action: #browseContext icon: #editFindReplaceIcon.
	^aMenu! !
!TranscriptMorph methodsFor: 'menus' stamp: 'jmv 5/13/2018 18:22:44' prior: 16938623!
             getMenu
	"Set up the menu to apply to the receiver"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	doImmediateUpdates
		ifTrue: [ aMenu add: 'Only update in the regular Morphic cycle' 	action: #doRegularUpdates ]
		ifFalse: [ aMenu add: 'Immediately show each entry'	 				action: #doImmediateUpdates ].
	aMenu
		addLine;
		add: 'Workspace with Contents' 	action: #editContents;
		addLine;
		add: 'Clear Transcript' 							action: #clearInternal;
		add: 'Clear Transcript File' 						action: #clearFile;
		add: 'Clear Both' 								action: #clearAll;
		addLine.
	Transcript logsToFile
		ifTrue: [ aMenu add: 'Stop logging to File' 	action: #dontLogToFile ]
		ifFalse: [ aMenu add: 'Start logging to File' 	action: #logToFile ].
	^ aMenu! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3325-BigMenuRefactor-p25-JuanVuletich-2018May13-18h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3325] on 13 May 2018 at 7:42:11 pm'!
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 5/13/2018 19:25:31'!
                            profilerFriendlyPrimTimesTwoPower: anInteger 
	"
	This is an example on proper primitive reporting in AndreasSystemProfiler.
	See senders.
	"

	<primitive: 554>
	^nil! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 5/13/2018 19:25:53'!
  profilerFriendlyTimesTwoPower: anInteger 

	"This is an example on proper primitive reporting in AndreasSystemProfiler.
	It is a reimplementation of #timesTwoPower: in a Profiler friendly way.

	Compare the results of 
		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 timesTwoPower: 10000]].
	and
		AndreasSystemProfiler spyOn:[1000000 timesRepeat: [3.14159 profilerFriendlyTimesTwoPower: 10000]].

	See #profilerFriendlyCall:
	"
	
	| primResult |
	primResult _ self profilerFriendlyCall: [
		self profilerFriendlyPrimTimesTwoPower: anInteger ].
	primResult ifNotNil: [ :result | ^result ].
	
	"Make sure that (2.0 raisedTo: Integer) can be safely used without overflow
	For example:
		Float fminNormalized * (2.0 raisedTo: 2000) = Float infinity.
	while:
		(Float fminNormalized timesTwoPower: 2000) = (2.0 raisedTo: 2000+Float emin)."	
	anInteger > Float emax ifTrue: [^(self timesTwoPower: Float emax) timesTwoPower: anInteger - Float emax].
	
	"In case of gradual underflow, timesTwoPower: is not exact, so greatest care must be taken
	because two consecutive timesTwoPower: might differ from a single one"
	anInteger < Float emin
		ifTrue:
			[| deltaToUnderflow |
			deltaToUnderflow := Float emin - self exponent max: Float emin.
			deltaToUnderflow >= 0 ifTrue:
				["self is already near or past underflow, so don't care, result will be zero"
				deltaToUnderflow := Float emin].
			^(self timesTwoPower: deltaToUnderflow) timesTwoPower: anInteger - deltaToUnderflow].
	
	"If (2.0 raisedToInteger: anInteger) fit in a positive SmallInteger, then use faster SmallInteger conversion.
	Note that SmallInteger maxVal highBit = 30 in a 32 bits image, so 1 can be shifted 29 times."
	anInteger > -29 ifTrue: [
		anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].
		anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat]].
	
	^ self * (2.0 raisedToInteger: anInteger)! !

BoxedFloat64 removeSelector: #profilerFriendlyPrimTimesTwoPower:!

BoxedFloat64 removeSelector: #profilerFriendlyPrimTimesTwoPower:!

BoxedFloat64 removeSelector: #profilerFriendlyTimesTwoPower:!

BoxedFloat64 removeSelector: #profilerFriendlyTimesTwoPower:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3326-ProfilerDemoCodeFix-JuanVuletich-2018May13-19h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3325] on 13 May 2018 at 7:42:58 pm'!

Object subclass: #Theme
	instanceVariableNames: 'menuItemIcons '
	classVariableNames: 'Content CurrentTheme '
	poolDictionaries: ''
	category: 'Theme-Core'!

!classDefinition: #Theme category: #'Theme-Core'!
Object subclass: #Theme
	instanceVariableNames: 'menuItemIcons'
	classVariableNames: 'Content CurrentTheme'
	poolDictionaries: ''
	category: 'Theme-Core'!
!MenuMorph methodsFor: 'control' stamp: 'jmv 5/13/2018 19:12:18' prior: 50392328!
                              popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	self addBlankIconsIfNecessary.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 5/13/2018 19:12:24' prior: 50392354!
         popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	self addBlankIconsIfNecessary.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !

Theme class removeSelector: #addBasicIconsTo:!

Theme class removeSelector: #addBasicIconsTo:!

Theme class removeSelector: #addMiscellaneousIconsTo:!

Theme class removeSelector: #addMiscellaneousIconsTo:!

Theme removeSelector: #allIcons!

Theme removeSelector: #allIcons!

Theme removeSelector: #basicIcons!

Theme removeSelector: #basicIcons!

Theme removeSelector: #decorateMenu:!

Theme removeSelector: #decorateMenu:!

Theme removeSelector: #iconDefinersFor:!

Theme removeSelector: #iconDefinersFor:!

Theme removeSelector: #iconsDefinitionFor:!

Theme removeSelector: #iconsDefinitionFor:!

Theme removeSelector: #initialize!

Theme removeSelector: #initialize!

Theme removeSelector: #menuDecorations!

Theme removeSelector: #menuDecorations!

Theme removeSelector: #miscellaneousIcons!

Theme removeSelector: #miscellaneousIcons!

MenuItemMorph removeSelector: #set_icon:!

MenuItemMorph removeSelector: #set_icon:!

MenuMorph removeSelector: #addList:!

MenuMorph removeSelector: #addList:!

Object subclass: #Theme
	instanceVariableNames: ''
	classVariableNames: 'Content CurrentTheme'
	poolDictionaries: ''
	category: 'Theme-Core'!

!classDefinition: #Theme category: #'Theme-Core'!
Object subclass: #Theme
	instanceVariableNames: ''
	classVariableNames: 'Content CurrentTheme'
	poolDictionaries: ''
	category: 'Theme-Core'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3327-removeOldStyleMenuDecorations-JuanVuletich-2018May13-19h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3327] on 13 May 2018 at 7:48:23 pm'!
!ContentPack methodsFor: 'accessing' stamp: 'jmv 5/13/2018 19:47:44'!
                         from: key get: anArray

"
	Theme content from: #Theme get: #('16x16' 'actions' 'view-refresh.png' )
	Answer nil when the object isn't found.
		--cbr	"
		
	| object | object _ self at: key ifAbsent: [ ^ nil ].
	
	anArray do: [ :i | object _ object at: i ifAbsent: [ ^ nil ]].
	
	^ object! !
!Theme methodsFor: 'icon lookup' stamp: 'jmv 5/13/2018 19:47:13' prior: 16936742!
            fetch: aTuple "	#( 'resolution' 'context' 'filename' )	"

	"Get an icon from Content. See icons protocol."

	| contentSpecifier icon themeGuess |
	
	icon _ nil.
	themeGuess _ self class.
	contentSpecifier _ self appendExtensionToContentSpec: aTuple.

	[ icon isNil ] 
		whileTrue: [
			icon _ self class content
				from: themeGuess name
				get: contentSpecifier.
	
			icon ifNotNil: [ ^ icon ].
	
			themeGuess = Theme content
				ifTrue: [ ^ nil "See comment in ContentPack>>get: --cbr" ].
	
			themeGuess _ themeGuess superclass
		]! !

ContentPack removeSelector: #get:!

ContentPack removeSelector: #get:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3328-IconRetrievalOptimization-JuanVuletich-2018May13-19h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3328] on 14 May 2018 at 1:02:23 pm'!
!SystemWindow methodsFor: 'menu' stamp: 'jmv 5/14/2018 11:54:07' prior: 50333299!
 buildWindowMenu

	| aMenu |

	aMenu _ MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' 				action: #relabel 						icon: #saveAsIcon;
		add: 'window color...' 			action: #setWindowColor 			icon: #graphicsIcon;
		addLine;
		add: 'send to back' 				action: #sendToBack 				icon: #goBottomIcon;
		add: 'make next-to-topmost' 	action: #makeSecondTopmost 	icon: #goUpIcon;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ])
											action: #toggleStickiness 			icon: (self isSticky ifFalse: [#pushPinIcon]);
		addLine;
		add: 'close' 						action: #delete 						icon: #closeIcon;
		add: 'collapse' 					action: #collapse 						icon: #collapseIcon;
		add: 'expand / contract' 		action: #expandBoxHit 				icon: #expandIcon;
		addLine;
		add: 'resize...' 					action: #resize;
		add: 'resize full' 					action: #resizeFull;
		add: 'resize top' 					action: #resizeTop;
		add: 'resize left' 				action: #resizeLeft;
		add: 'resize bottom' 			action: #resizeBottom;
		add: 'resize right' 				action: #resizeRight;
		add: 'resize top left' 			action: #resizeTopLeft;
		add: 'resize top right' 			action: #resizeTopRight;
		add: 'resize bottom left' 		action: #resizeBottomLeft;
		add: 'resize bottom right' 		action: #resizeBottomRight.

	^ aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/14/2018 10:56:45' prior: 50397342!
      changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu isForBaseSystem |
	isForBaseSystem _ model changeSet isForBaseSystem.
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove 	icon: #fileOutIcon 	enabled: isForBaseSystem.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep 		icon: #fileOutIcon.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename 					icon: #saveAsIcon 	enabled: isForBaseSystem.
	aMenu add: 'Destroy change set (x)' 			action: #remove 					icon: #warningIcon 	enabled: isForBaseSystem.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble 			icon: #textEditorIcon.
				aMenu add: 'Remove preamble' 	action: #removePreamble 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 	action: #addPreamble 			icon: #listAddIcon ].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript 			icon: #textEditorIcon .
				aMenu add: 'Remove postscript' 	action: #removePostscript 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript 			icon: #listAddIcon ].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	(aMenu add: 'conflicts with other change sets' 	target: self 	action: #browseMethodConflicts 	icon: #emblemImportantIcon)
		setBalloonText: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	(aMenu add: 'trim history' 						action: #trimHistory 				icon: #clockIcon 		enabled: isForBaseSystem)
		setBalloonText: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	(aMenu add: 'view affected class categories' action: #viewAffectedClassCategories icon: #packageIcon)
		setBalloonText: ' Show class categories affected by any contained change'.

	^ aMenu! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 5/14/2018 10:28:53' prior: 50399269!
                               volumeMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon.
	^ aMenu! !
!TestRunnerWindow methodsFor: 'menu building' stamp: 'jmv 5/14/2018 11:10:46' prior: 50396042!
                             listMenu
	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Test Cases'.
	aMenu add: 'select all' target: model action: #selectAll icon: #selectAllIcon.
	aMenu add: 'deselect all' target: model action: #deselectAll icon: #selectAllIcon.
	aMenu add: 'toggle selections' target: model action: #invertSelections icon: #switchIcon.
	aMenu add: 'filter' target: model action: #setFilter icon: #findIcon.
	model runButtonState ifTrue: [
		aMenu add: 'stop' target: model action: #terminateRun icon: #cancelIcon ].
	model selectedSuite > 0 ifTrue: [ | cls |
		cls _ (model tests at: model selectedSuite ifAbsent: ['']) copyUpTo: Character space.
		cls _ cls asSymbol.
		cls _ (Smalltalk at: cls ifAbsent: nil).
		cls ifNotNil: [
			aMenu addLine.
			(aMenu add: 'browse' target: self action: #browse: argument: cls)
				setIcon: #editFindReplaceIcon.
		].
	].
	aMenu addLine.
	aMenu add: 'log to Transcript' target: model action: #showResult icon: #printerIcon.
	^aMenu! !
!WorkspaceWindow methodsFor: 'menu' stamp: 'jmv 5/14/2018 11:55:00' prior: 50375081!
               offerWindowMenu
	| aMenu |
	aMenu _ self buildWindowMenu.
	aMenu addLine.
	aMenu
		add: 'reset variables'
		target: model
		action: #initializeBindings
		icon: #warningIcon.
	aMenu
		addUpdating: #mustDeclareVariableWording
		target: model
		action: #toggleVariableDeclarationMode.
	aMenu
		addUpdating: #toggleStylingLabel
		target: model
		action: #toggleStyling.
	aMenu popUpInWorld: self world! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3329-BigMenuRefactor-p26-JuanVuletich-2018May14-13h01m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3329] on 22 May 2018 at 4:38:46 pm'!
!DebuggerWindow methodsFor: 'menu building' stamp: 'jmv 5/22/2018 16:16:36' prior: 50399211!
               contextStackMenu
	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fullStack (f)'.
				#selector 		-> 		#fullStack
			} asDictionary.
			{
				#label 			-> 		'restart (r)'.
				#selector 		-> 		#restart
			} asDictionary.
			{
				#label 			-> 		'proceed (p)'.
				#selector 		-> 		#proceed
			} asDictionary.
			{
				#label 			-> 		'step (t)'.
				#selector 		-> 		#doStep
			} asDictionary.
			{
				#label 			-> 		'step through (T)'.
				#selector 		-> 		#stepIntoBlock
			} asDictionary.
			{
				#label 			-> 		'send (e)'.
				#selector 		-> 		#send
			} asDictionary.
			{
				#label 			-> 		'where (w)'.
				#selector 		-> 		#where
			} asDictionary.
			{
				#label 			-> 		'peel to first like this'.
				#selector 		-> 		#peelToFirst
			} asDictionary.
			nil.
			{
				#label 			-> 		'return entered value'.
				#selector 		-> 		#returnValue
			} asDictionary.
			{
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleBreakOnEntry
			} asDictionary.
		}`.
	^aMenu! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3330-DebugMenuFix-JuanVuletich-2018May22-16h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3331] on 23 May 2018 at 11:33:10 am'!
!Form methodsFor: 'analyzing' stamp: 'jmv 5/23/2018 11:28:54'!
      isAnyPixel: pv
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv.
	Based on #yTallyPixelValue:orNot:
	Form lena isAnyPixel: 0
	Form lena isAnyPixel: 100
	"
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: slice width @ 1
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	(0 to: height-1) do: [ :y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits > 0 ifTrue: [ ^ true ]].
	^ false! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3331-isAnyPixel-JuanVuletich-2018May23-10h38m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3331] on 25 May 2018 at 10:41:35 am'!

Dictionary subclass: #OrderedDictionary
	instanceVariableNames: 'orderedKeys'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Sequenceable'!

!classDefinition: #OrderedDictionary category: #'Collections-Sequenceable'!
Dictionary subclass: #OrderedDictionary
	instanceVariableNames: 'orderedKeys'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Sequenceable'!
!OrderedDictionary commentStamp: '<historical>' prior: 0!
                      Like Python's OrderedDict!
!OrderedDictionary methodsFor: 'removing' stamp: 'jmv 3/9/2018 14:33:08'!
                           removeKey: key ifAbsent: aBlock 

	super removeKey: key ifAbsent: [
		^ aBlock value ].
	orderedKeys remove: key! !
!OrderedDictionary methodsFor: 'enumerating' stamp: 'jmv 3/9/2018 14:45:35'!
                               associationsDo: aBlock 
	"Evaluate aBlock for each of the receiver's elements (key/value 
	associations)."

	orderedKeys do: [ :key |
		aBlock value: (self associationAt: key ifAbsent: nil) ]! !
!OrderedDictionary methodsFor: 'enumerating' stamp: 'jmv 3/9/2018 14:45:31'!
                do: aBlock
	"Evaluate aBlock for each of the receiver's values."

	orderedKeys do: [ :key |
		aBlock value: (self at: key ifAbsent: nil) ]! !
!OrderedDictionary methodsFor: 'enumerating' stamp: 'jmv 3/9/2018 14:45:24'!
     keysDo: aBlock 
	"Evaluate aBlock for each of the receiver's keys."

	orderedKeys do: aBlock ! !
!OrderedDictionary methodsFor: 'accessing' stamp: 'jmv 5/25/2018 10:36:46'!
                   keysSortedSafely
	"Answer a sorted Collection containing the receiver's keys.
	Redefined from Dictionary: for us, propery sorted keys are keys in the order they were added."
	^ orderedKeys! !
!OrderedDictionary methodsFor: 'private' stamp: 'jmv 3/9/2018 14:33:17'!
                       atNewIndex: index put: anAssociation

	super atNewIndex: index put: anAssociation.
	orderedKeys add: anAssociation key! !
!OrderedDictionary methodsFor: 'private' stamp: 'jmv 3/9/2018 14:33:19'!
                             init: n

	super init: n.
	orderedKeys _ OrderedCollection new: n! !
!Dictionary methodsFor: 'accessing' stamp: 'jmv 5/25/2018 10:35:25' prior: 16833451!
       keysSortedSafely
	"Answer a sorted Collection containing the receiver's keys."
	| sortedKeys |
	sortedKeys _ OrderedCollection new: self size.
	self keysDo: [:each | sortedKeys addLast: each].
	sortedKeys sort:
		[ :x :y |  "Should really be use <obj, string, num> compareSafely..."
		((x isString and: [y isString])
			or: [x isNumber and: [y isNumber]])
			ifTrue: [x < y]
			ifFalse: [x class == y class
				ifTrue: [x printString < y printString]
				ifFalse: [x class name < y class name]]].
	^ sortedKeys! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3332-OrderedDictionary-JuanVuletich-2018May25-10h13m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3332] on 25 May 2018 at 2:06:45 pm'!
!Theme class methodsFor: 'instance creation' stamp: 'cbr 12/14/2010 01:55' prior: 50397945!
 beCurrent
	^ self currentTheme: self! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3333-fixHangOnImageSave-JuanVuletich-2018May25-14h06m-jmv.1.cs.st----!

----SNAPSHOT----#(25 May 2018 2:10:36.038874 pm) Cuis5.0-3333-v3.image priorSource: 1906987!

----QUIT----#(25 May 2018 2:10:52.374396 pm) Cuis5.0-3333-v3.image priorSource: 2196336!

----STARTUP----#(15 June 2018 11:06:21.767694 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3333-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3333] on 26 May 2018 at 5:40:37 pm'!
!Complex methodsFor: 'testing' stamp: 'jmv 5/20/2018 21:10:51'!
             isInfinite
	^real isInfinite or: [ imaginary isInfinite ]! !
!Complex methodsFor: 'private' stamp: 'jmv 5/20/2018 20:29:34'!
   setReal: aNumber1 imaginary: aNumber2
	"Private - initialize the real and imaginary parts of a Complex"
	real _ aNumber1.
	imaginary _ aNumber2! !
!Complex class methodsFor: 'instance creation' stamp: 'jmv 5/20/2018 20:32:34'!
                             basicReal: realPart imaginary: imaginaryPart
	"Answer a Complex even if imaginary part is zero. Usually you don't want this and just call #real:imaginary:"
	^self basicNew setReal: realPart imaginary: imaginaryPart! !
!Number methodsFor: 'converting' stamp: 'jmv 5/20/2018 20:33:20' prior: 16879859!
                    asComplex
	"Answer a Complex number that represents value of the the receiver."

	^ Complex basicReal: self imaginary: 0! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 5/20/2018 20:30:21' prior: 16822388!
                 absSecure
	"Answer the distance of the receiver from zero (0 + 0 i).
	Try avoiding overflow and/or underflow"

	| scale |
	scale := real abs max: imaginary abs.
	^scale isZero 
		ifTrue: [scale]
		ifFalse: [(self class basicReal: real / scale imaginary: imaginary / scale) squaredNorm sqrt * scale]! !
!Complex class methodsFor: 'instance creation' stamp: 'jmv 5/20/2018 20:27:23' prior: 16822850!
                  abs: rho arg: theta
	| theta1 |
	"So that if theta is any integer multiple of twoPi, answer is real"
	theta1 _ theta \\ Float twoPi.
	^ self
		real: rho * theta1 cos
		imaginary: rho * theta1 sin! !
!Complex class methodsFor: 'instance creation' stamp: 'jmv 5/20/2018 17:14:55' prior: 16822864!
                         real: realPart imaginary: imaginaryPart
	^ imaginaryPart isZero
		ifTrue: [ realPart ]
		ifFalse: [ self basicReal: realPart imaginary: imaginaryPart ]! !

Complex removeSelector: #real:imaginary:!

Complex removeSelector: #real:imaginary:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3334-Complex-Creation-JuanVuletich-2018May26-17h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3334] on 26 May 2018 at 11:10:23 pm'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 17:51:33'!
 sqrt
	"Answer the square root of the receiver. 
	 Optional. See Object documentation whatIsAPrimitive."
	| exp guess eps delta prim |
	prim _ self primSqrt.
	prim isNaN ifFalse: [ ^prim ].

	"Newton-Raphson"
	self <= 0.0
		ifTrue: [
			^self = 0.0
				ifTrue: [0.0]
				ifFalse: [
					(0.0 - self) sqrt i ]].
	"first guess is half the exponent"
	exp := self exponent // 2.
	guess := self timesTwoPower: 0 - exp.
	"get eps value"
	eps := guess * Epsilon.
	eps := eps * eps.
	delta := self - (guess * guess) / (guess * 2.0).
	[delta * delta > eps]
		whileTrue: 
			[guess := guess + delta.
			delta := self - (guess * guess) / (guess * 2.0)].
	^ guess! !
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 5/21/2018 18:02:08'!
                              primSqrt
	"Answer the square root of the receiver. 
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 55>
	^Float nan! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 5/21/2018 18:02:14'!
                               primSqrt
	"Answer the square root of the receiver. 
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 555>
	^Float nan! !
!Complex methodsFor: 'testing' stamp: 'jmv 5/26/2018 23:00:13'!
                  isNaN
	^real isNaN or: [ imaginary isNaN ]! !
!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 23:01:31' prior: 16849723!
                  sqrt
	| d n answer |
	n _ numerator sqrt.
	d _ denominator sqrt.
	"The #sqrt method in integer will only answer a Float if there's no exact square root.
	So, we need a float anyway."
	(n isInfinite or: [ d isInfinite ]) ifTrue: [
		^self asFloat sqrt ].
	answer _ n / d.
	answer isNaN ifTrue: [
		^self asFloat sqrt ].
	^ answer! !
!LargeNegativeInteger methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 17:52:29' prior: 16862205!
        sqrt
	"Answer the square root of the receiver."
	^ self negated sqrt i! !
!SmallInteger methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 17:52:59' prior: 16909161!
                  sqrt
	self negative ifTrue: [
		^ self negated sqrt i ].
	^ super sqrt! !

SmallFloat64 removeSelector: #sqrt!

SmallFloat64 removeSelector: #sqrt!

BoxedFloat64 removeSelector: #sqrt!

BoxedFloat64 removeSelector: #sqrt!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3335-Complex-sqrt-JuanVuletich-2018May26-23h09m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3335] on 26 May 2018 at 6:10:15 pm'!

SmallInteger class removeSelector: #guideToDivision!

SmallInteger class removeSelector: #guideToDivision!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3336-RemoveOldGuideToDivision-JuanVuletich-2018May26-18h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3336] on 26 May 2018 at 11:05:24 pm'!
!Complex methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:57:33'!
  nthRoot: aPositiveInteger

	aPositiveInteger = 2 ifTrue: [
		^ self sqrt ].

	(aPositiveInteger isInteger not or: [ aPositiveInteger negative ])
		ifTrue: [^ ArithmeticError signal: 'nth root only defined for positive Integer n.'].

	^ Complex abs: (self abs nthRoot: aPositiveInteger) arg: self arg / aPositiveInteger! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 21:52:19' prior: 16844676!
 nthRoot: aPositiveInteger
	"Answer the nth root of the receiver."
	aPositiveInteger = 2 ifTrue: [
		^self sqrt ].

	(aPositiveInteger isInteger not or: [ aPositiveInteger negative ])
		ifTrue: [^ ArithmeticError signal: 'nth root only defined for positive Integer n.'].
	
	^self negative
		ifTrue: [
			aPositiveInteger even
				ifTrue: [ (Complex basicReal: self imaginary: 0) nthRoot: aPositiveInteger ]
				ifFalse: [ (self negated nthRoot: aPositiveInteger) negated ]]
		ifFalse: [ self raisedTo: 1.0 / aPositiveInteger ]! !
!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:57:41' prior: 50367830!
               nthRoot: aPositiveInteger
	"Answer the nth root of the receiver."
	| guess |
	aPositiveInteger = 2 ifTrue: [
		^ self sqrt ].

	(aPositiveInteger isInteger not or: [ aPositiveInteger negative ])
		ifTrue: [^ ArithmeticError signal: 'nth root only defined for positive Integer n.'].

	(self negative and: [ aPositiveInteger even ]) ifTrue: [
		^(Complex basicReal: self imaginary: 0) nthRoot: aPositiveInteger ].
	
	guess _ (numerator nthRootTruncated: aPositiveInteger) /
				(denominator nthRootTruncated: aPositiveInteger).
	(guess raisedTo: aPositiveInteger) = self ifTrue: [
		^ guess ].
	"There is no exact nth root, so answer a Float approximation"
	^ (self abs ln / aPositiveInteger) exp * self sign! !
!Integer methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:57:47' prior: 16859661!
                           nthRoot: aPositiveInteger
          "Answer the nth root of the receiver.
          Answer an Integer if root is exactly this Integer, else answer the Float nearest the exact root."
  
	| guess excess scaled nBits |
	self = 0 ifTrue: [ ^0 ].

	aPositiveInteger = 2 ifTrue: [
		^ self sqrt ].

	(aPositiveInteger isInteger not or: [ aPositiveInteger negative ])
		ifTrue: [^ ArithmeticError signal: 'nth root only defined for positive Integer n.'].

	(self negative and: [ aPositiveInteger even ]) ifTrue: [
		^ (Complex basicReal: self imaginary: 0) nthRoot: aPositiveInteger ].

	guess _ self nthRootRounded: aPositiveInteger.
	excess _ (guess raisedTo: aPositiveInteger) - self.
	excess = 0 ifTrue: [ ^ guess ].

	nBits _ Float precision - guess highBitOfMagnitude.
	nBits <= 0 ifTrue: [ ^(Fraction numerator: guess * 4 - excess sign denominator: 4) asFloat].

	scaled _ self << (nBits * aPositiveInteger).
	guess _ scaled nthRootRounded: aPositiveInteger.
	excess _ (guess raisedTo: aPositiveInteger) - scaled.
	^(Fraction numerator: guess * 4 - excess sign denominator: 1 << (nBits + 2)) asFloat! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3337-Complex-nthRoot-JuanVuletich-2018May26-23h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3336] on 26 May 2018 at 10:48:43 pm'!
!Complex methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:20:24'!
  raisedToFraction: aFraction
	^ (self nthRoot: aFraction denominator) raisedToInteger: aFraction numerator! !
!Number methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:28:10' prior: 50367798!
                     raisedTo: aNumber 
	"Answer the receiver raised to aNumber."

	aNumber isInteger ifTrue: [
		"Do the special case of integer power"
		^ self raisedToInteger: aNumber].
	aNumber isFraction ifTrue: [
		"Special case for fraction power by Nicolas Cellier:
		If aNumber is a fraction, but result must be a Float, learn it as quickly as possible, and give quick Float answer
		Allows evaluating:
		(2009/2000) raisedTo: (3958333/100000)
		"
		^ self raisedToFraction: aNumber].
	self < 0 ifTrue: [
		^(Complex basicReal: self imaginary: 0) raisedTo: aNumber ].
	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"
	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"
	0 = self ifTrue: [				"Special case of self = 0"
		aNumber < 0
			ifTrue: [^ (ZeroDivide dividend: self) signal]
			ifFalse: [^ self]].
	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !
!Number methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:22:44' prior: 50367760!
                 raisedToFraction: aFraction
	self isZero ifTrue: [
		aFraction negative ifTrue: [
			^ (ZeroDivide dividend: 1) signal ].
		^ self ].
	self negative ifFalse: [
		^ (self ln * aFraction) exp ].
	aFraction denominator = 2 ifTrue: [
		^ self sqrt raisedToInteger: aFraction numerator ].
	(self negative and: [ aFraction denominator even ]) ifTrue: [
		^ (Complex basicReal: self imaginary: 0) raisedToFraction: aFraction].
	^ (self negated ln * aFraction) exp negated! !
!Fraction methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:21:48' prior: 50367774!
            raisedToFraction: aFraction
	| root |
	aFraction denominator = 2 ifTrue: [
		^ self sqrt raisedToInteger: aFraction numerator ].
	(self negative and: [ aFraction denominator even ]) ifTrue: [
		^ (Complex basicReal: self imaginary: 0) raisedToFraction: aFraction].
	root _ (self numerator nthRootTruncated: aFraction denominator) /
			(self denominator nthRootTruncated: aFraction denominator).
	(root raisedToInteger: aFraction denominator) = self ifTrue: [
		^ root raisedToInteger: aFraction numerator ].
	^ super raisedToFraction: aFraction! !
!Integer methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:19:10' prior: 50367787!
                             raisedToFraction: aFraction
	| root |
	self = 0 ifTrue: [ ^0 ].
	aFraction denominator = 2 ifTrue: [
		^ self sqrt raisedToInteger: aFraction numerator ].
	(self negative and: [ aFraction denominator even ]) ifTrue: [
		^ (Complex basicReal: self imaginary: 0) raisedToFraction: aFraction].
	root _ self nthRootTruncated: aFraction denominator.
	(root raisedToInteger: aFraction denominator) = self ifTrue: [
		^ root raisedToInteger: aFraction numerator ].
	^ super raisedToFraction: aFraction! !
!Complex methodsFor: 'mathematical functions' stamp: 'jmv 5/26/2018 22:24:56' prior: 16822720!
               raisedTo: aNumber 
	"Answer the receiver raised to aNumber."

	aNumber isInteger ifTrue: [
		"Do the special case of integer power"
		^ self raisedToInteger: aNumber].
	aNumber isFraction ifTrue: [
		^ self raisedToFraction: aNumber].
	
	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"
	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"
	0 = self ifTrue: [				"Special case of self = 0"
		aNumber < 0
			ifTrue: [^ (ZeroDivide dividend: self) signal]
			ifFalse: [^ self]].
	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3338-Complex-raisedTo-JuanVuletich-2018May26-22h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3338] on 27 May 2018 at 7:35:34 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 5/27/2018 19:35:13' prior: 16924221!
                    browseMethodsWithString: aString
	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-insensitive, unless the shift key is pressed, in which case the search is case-sensitive."

	^ self browseMethodsWithString: aString matchCase: false

	"Smalltalk browseMethodsWithString: 'Testing' matchCase: false"
	"Smalltalk browseMethodsWithString: 'Testing' matchCase: true"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3339-StringFind-CaseInsensituve-JuanVuletich-2018May27-19h31m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3339] on 1 June 2018 at 8:07:08 pm'!
!PseudoClass methodsFor: 'accessing' stamp: 'jmv 5/31/2018 21:51:33'!
     superclassName
	^definition copyUpTo: Character space! !
!Utilities class methodsFor: 'support windows' stamp: 'jmv 5/31/2018 19:23:46' prior: 16941075!
       codeManagementInCuisContents
	^ self class firstCommentAt: #codeManagementInCuisContents

"
(from http://jvuletich.org/Cuis/CodeManagementInCuis4.html )

Starting with version 4.0, Cuis includes tools and suggested procedures for managing Smalltalk code. Code that is not part of the Cuis Core image itself, like applications, frameworks and libraries, should be stored in Packages. New code that is meant as patches, fixes or additions; that could eventually become part of Cuis itself, is not part of any Package, and is therefore automatically stored in Change Sets.


Packages
------------

Let's start with Packages. The Package implementation in Cuis is based on PackageInfo, the standard way to specify packages in Squeak and its derivatives, and used, for example, by Monticello. It uses Package names, to specify prefixes for Class and Method categories. Classes and Methods whose categories match a Package's prefixes belong in that Package. More details about how PackageInfo decides what code belongs in a package are available at http://wiki.squeak.org/squeak/3329 .

To install packages (.pck.st files) in Cuis, use the FileList, navigate to the appropriate directory (on disk, or in a GitHub repository, etc), select the package file and click on [Install Package].

Cuis includes a tool to manage installed Packages. It is at World / Open / Installed Packages. To create a new package (instead of installing an existing one from a file), click on [Create Package] This creates a new package, and associates with it all the existing code in the image that matches the package name.

The operations available on installed or newly created packages are:

[Save] Saves a package on the file system. Overwrites any existing version. It is good to save package from time to time, to reduce the risk of losing code.

[Delete] Removes the Package instance from the image. Does not remove any code. This means, effectively, to merge back the code into Cuis.

[Browse unsaved Changes] This opens a ChangeSorter on the ChangeSet that captures all the changes done to the Package since it was last saved. Therefore it shows the work done on the package that would be lost if the package is not saved.

[Browse Package Code] This opens a Class Browser that only shows the code that belongs in the package. This is useful for working on a package, or studying it.

The tool shows, for each Package, the name, whether it is dirty (has unsaved changes) and the file it was installed from / saved to.

Handling Packages like this, Cuis behaves as a sort of document editor (like, for example a regular text editor) whose documents are Package files (.pck.st). Cuis doesn't handle Package versions, ancestries, etc. If versioning of Packages is desired, the best is to use a versioning file repository, such as Git or Mercurial. The recommendation is to use a GitHub repository with a name beginning with 'Cuis-Smalltalk', so it will be easy for anybody to find it. Cuis Package files (.pck.st) are uncompressed, use Lf (ASCII 10) as newLine, and are encoded in ISO 8859-15. This means that they are Git friendly, and Git/GitHub can diff and merge them, and browse them with syntax highlighting.

This is not unlike using Git or GitHub with a more conventional development environment such as Eclipse or a text editor. Like Cuis 4, these tools don't do version handling themselves, they just load and save files; and let Git do its magic.


Changes to the Cuis base image
--------------------------------------

The way ChangeSets are created and managed in Cuis 4 is very different from previous versions of Cuis (and Squeak & derivatives). This was done to make ChangeSets a good way to manage changes to the base Cuis Core image, while keeping code in Packages out of the way, so they don't get mixed together.

What is not in a Package belongs (at least temporarily) in the Cuis Core image. Such code is automatically captured in a ChangeSet. The ChangeSet for Core changes is created automatically and named like '1243-CuisCore-JuanVuletich-2012Apr03-22h50m'. The number at the beginning is the next number for the Cuis update stream, and is provided only as a suggestion. The 'CuisCore' part is to reveal that the code belongs in the base image and not in some package. Then we have author name and date / time of creation. These ChangeSets are created automatically. There is no longer a way to manually create them, or make them 'current' or 'active'. It is best not to rename them. These ChangeSets will not capture any code that belongs in a Package.

Opening a Change Sorter will show the CuisCore change set. This is useful, for example, to check that no code that was intended for a Package ends here by mistake (because of the wrong class or method category). But it is also useful when doing changes to the base system. Now, we can do changes both to the base system and to a number of packages, all in the same session, without having to be careful about selecting the proper change set before saving a method: The code is automatically added to the proper Package or ChangeSet, simply following the class or method category. Gone are the days of messed up change sets and lost code!!

When the changes to the base system are complete, it is a good time to review the CuisCore change set and, maybe remove from it changes that we don't want to keep (for example, experiments, halts, etc). Then, just do right click / File out and remove. This saves the ChangeSet on disk. It also removes it from the ChangeSorter (but it doesn't remove any code). This is good, because the next changes done will end in a new CuisCore change set, and there's no risk of having undesired changes in the old one. As changes to the base image progress, and several CuisCore change sets are saved to disk, these numbered files are created in sequence. They will be ready to be loaded back in proper order in a fresh Cuis image, or to be sent to Cuis maintainers for integration in the update stream and in next releases of Cuis.


Loading ChangeSet files into Cuis
---------------------------------------

There are two ways to load ChangeSet files (.cs): [FileIn] and [Install].

[FileIn] loads the code without creating a new ChangeSet object. This means that changes that belong in the base image (and not in a package) will be added to the current ChangeSet for Cuis core changes, as if they were done by the user. This is appropriate when we are combining code from more than one source into a single ChangeSet. Any change that belongs in an installed package will be added to it, and the package will appear as dirty.

[Install] loads the code into a separate ChangeSet object (viewable in the ChangeSorter tool). This is appropriate for loading Cuis updates, or other code that we are not authoring, as it doesn't add new items (class or method definitions) to the current ChangeSet for our changes to Cuis. Usually any ChangeSets should be installed before doing changes to the image. The reason is that an installed ChangeSet could overwrite changes done by you, or packages you have installed. If this is the case, the affected packages would appear as dirty, and your change set would include any installed changes (that don't belong in a package). Be careful when saving packages or change sets if this was the case!!
"

"
Utilities codeManagementInCuisContents edit
"! !
!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'jmv 5/31/2018 21:51:47' prior: 16896967!
                    fileInDefinition
	(self makeSureSuperClassExists: self superclassName) ifFalse:[^self].
	self hasDefinition ifTrue:[
		Transcript newLine; show:'Defining ', self name.
		self evaluate: self definition].
	self exists ifFalse:[^self].
	self hasComment ifTrue:[self realClass classComment: self comment].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3340-tweaks-JuanVuletich-2018Jun01-20h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3341] on 1 June 2018 at 8:59:47 pm'!
!CodePackage class methodsFor: 'installing' stamp: 'jmv 6/1/2018 20:59:14'!
             postPackageInstall
	"This gets called after installing all the package code.
	Redefine as appropriate"! !
!CodePackage class methodsFor: 'installing' stamp: 'jmv 6/1/2018 20:59:33'!
          prePackageInstall
	"This gets called after creating the package class and installing its code, but before installing the rest of the package code
	Redefine as appropriate"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3341-pre-post-packageInstall-CuisCore-JuanVuletich-2018Jun01-20h58m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3341] on 2 June 2018 at 5:00:22 pm'!
!CodePackage methodsFor: 'accessing' stamp: 'jmv 6/2/2018 16:58:49'!
                            codePackageClass
	"Answer the specific CodePackage subclass to use."

	self class == CodePackage ifFalse: [
		^ self class ].
	self classesDo: [ :cls |
		(cls inheritsFrom: CodePackage)
			ifTrue: [ ^ cls ]].
	^ nil! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 6/2/2018 16:59:03' prior: 50389797!
                   writeOnStream: aStream

	| sortedClasses |
	aStream
		nextChunkPut: ('Description ', description) printString;
		newLine.
	self writeFeatureSpecOn: aStream.
	self writeSystemCategoriesOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self
			write: {codePackageClass} classDefinitionsOn: aStream;
			write: {codePackageClass} classCommentsOn: aStream;
			write: {codePackageClass} methodsOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' prePackageInstall'; newLine ].

	sortedClasses _ Array streamContents: [ :strm |
		self classesInSafeOrderDo: [ :cls |
			cls == self class ifFalse: [
				strm nextPut: cls ]]].
	self
		write: sortedClasses classDefinitionsOn: aStream;
		write: sortedClasses classCommentsOn: aStream;
		write: sortedClasses methodsOn: aStream.

	self
		sortedExtensionMethodsDo:  [ :methodReference |
			methodReference isValid ifTrue: [
				self writeMethod: methodReference on: aStream ]]
		displayingProgress: 'Saving extension methods...'.
	self write: sortedClasses initializersOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self write: { codePackageClass } initializersOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' postPackageInstall'; newLine ]! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 6/2/2018 16:59:49' prior: 16810879!
      install: aFileStream
	"Installs the package. Replace all existing code in the CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		"Create, install and answer an instance of CodePackage"
		pckClass _ CodePackage.
		classes do: [ :ee | (ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [ 
			pckClass _ Smalltalk at: ee name ]].
		newCodePackage _ pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.
	].
	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !

CodePackage removeSelector: #writeInitializerExtensionMethods:on:!

CodePackage removeSelector: #writeInitializerExtensionMethods:on:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3342-supportFor-CodePackage-subclasses-JuanVuletich-2018Jun02-16h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3341] on 1 June 2018 at 8:56:07 pm'!

FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps '
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #Color category: #'Graphics-Primitives'!
FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!Color methodsFor: 'other' stamp: 'jmv 6/1/2018 20:55:02' prior: 50388992!
                         colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color.
	Return nil if named color support is not present"

	Color classPool 
		at: #ColorNamesDict
		ifPresent: [ :dict | ^dict keyAtValue: self ifAbsent: [nil]].
	^nil! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 6/1/2018 20:55:34' prior: 50389193!
 releaseClassCachedState
	"
	Color releaseClassCachedState
	"
	CachedColormaps _ nil. 		"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !

FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #Color category: #'Graphics-Primitives'!
FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3343-RemoveUnused-Color-classVar-JuanVuletich-2018Jun01-20h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3343] on 2 June 2018 at 5:24:58 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 6/2/2018 17:24:20' prior: 50375384!
                              knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 					'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('BenComan' 			'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 					'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 					'Doug Way')
	#('dgd' 					'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhn'	 				'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DM' 					'Duncan Mak')
	#('DSM' 					'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 					'Hari Balaraman')
	#('hjh' 					'Hannes Hirzel')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 					'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 					'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 					'Mike Rutenberg')
	#('mga' 					'Markus Galli')
	#('mha' 					'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 					'Peter Keeler')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 					'Paul McDonough')
	#('r++' 					'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 					'Ron Teitelbaum')
	#('RNG' 					'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 					'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 					'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 					'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sqr' 					'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 					'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 					'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 					'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3344-Add-NahuelGarbezza-asAuthor-JuanVuletich-2018Jun02-17h23m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3333] on 27 May 2018 at 1:46:20 am'!
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'RNG 5/27/2018 01:44:26'!
       messageCatListKey: aChar from: view

	aChar == $o ifTrue: [^ model fileOutMessageCategories ].
	aChar == $t ifTrue: [^ model runMessageCategoryTests ].
	aChar == $x ifTrue: [^ model removeMessageCategory ].! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'RNG 5/27/2018 01:43:23' prior: 16793073!
                   buildMorphicMessageCatList

	^PluggableListMorph
		model: model
		listGetter: #messageCategoryList
		indexGetter: #messageCategoryListIndex
		indexSetter: #messageCategoryListIndex:
		mainView: self
		menuGetter: #messageCategoryMenu
		keystrokeAction: #messageCatListKey:from:! !
!BrowserWindow methodsFor: 'menu building' stamp: 'RNG 5/27/2018 01:43:51' prior: 50398391!
           messageCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Message Category'.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessageCategories.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editMessageCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#label 			-> 		'alphabetize'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeMessageCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#label 			-> 		'remove empty categories'.
				#object 			-> 		#model.
				#selector 		-> 		#removeEmptyCategories.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#label 			-> 		'categorize all uncategorized'.
				#object 			-> 		#model.
				#selector 		-> 		#categorizeAllUncategorizedMethods.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#label 			-> 		'new category...'.
				#object 			-> 		#model.
				#selector 		-> 		#addCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessageCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMessageCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	^ aMenu! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3345-KeyboardShortcutForMessageCategories-NahuelGarbezza-2018May27-01h24m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3345] on 14 June 2018 at 2:11:19 pm'!
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 6/14/2018 14:06:32' prior: 50381363!
                           getPreambleFrom: aFileStream at: position
	|  writeStream c p |
	writeStream _ String new writeStream.
	p _ position.
	c _ nil.
	aFileStream position: p.
	aFileStream atEnd ifTrue: [ ^ nil ].
	[ p >= 0 and: [ c ~~ $!! ]] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		p _ p - 1 ].
	[ p >= 0] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		c == $!!
			ifTrue: [^ writeStream contents reverse ]
			ifFalse: [ writeStream nextPut: c ].
		p _ p - 1 ].
	^ nil! !
!RemoteString methodsFor: 'accessing' stamp: 'jmv 6/14/2018 14:11:09' prior: 16900625!
               string 
	"Answer the receiver's string if remote files are enabled."
	| theFile answer |
	(sourceFileNumber == nil or: [(SourceFiles at: sourceFileNumber) == nil]) ifTrue: [^nil].
	theFile _ SourceFiles at: sourceFileNumber.
	theFile position: filePositionHi.
	answer _ theFile nextChunk.
	^answer isEmpty ifTrue: [nil] ifFalse: [answer]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3346-FixSlowdownsWhenMissingChangesFile-JuanVuletich-2018Jun14-14h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3345] on 5 June 2018 at 11:03:34 am'!
!CodePackage methodsFor: 'naming' stamp: 'jmv 6/5/2018 11:02:21' prior: 16810412!
      packageName: aString
	packageName _ aString.
	description _ 'Please enter a description for this package'.
	featureSpec _ FeatureSpec new.
	featureSpec provides: (Feature name: packageName version: 1 revision: 0).
	hasUnsavedChanges _ self includesAnyCode.
	"But reset revision if it was incremented because of marking it dirty!!"
	featureSpec provides name: packageName version: 1 revision: 0! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3347-PackageInstallFix-JuanVuletich-2018Jun05-11h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3347] on 15 June 2018 at 10:10:07 am'!
!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'jmv 6/15/2018 10:06:19'!
     fileInDefinitionAndMetaclass
	self fileInDefinition.
	metaClass ifNotNil: [ metaClass fileInDefinition ]! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 6/15/2018 10:09:12' prior: 50401040!
                           install: aFileStream
	"Installs the package. Replace all existing code in the CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Create, install and answer a (sub)instance of CodePackage"
	pckClass _ CodePackage.
	classes do: [ :ee |
		(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
			ee fileInDefinitionAndMetaclass.
			pckClass _ Smalltalk at: ee name ]].
	newCodePackage _ pckClass
		named: packageName
		createIfAbsent: true
		registerIfNew: true.

	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3348-CreatePackageInstance-beforeInstall-JuanVuletich-2018Jun15-10h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3345] on 13 June 2018 at 4:12:00 pm'!
!BrowserWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 6/13/2018 16:07:19'!
            systemCatListKey: aChar from: view

	aChar == $r ifTrue: [^ model recent ].
	
	^super systemCatListKey: aChar from: view! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3349-recentClasses-shortcutFix-HernanWilkinson-2018Jun13-15h21m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3345] on 14 June 2018 at 12:30:21 pm'!

Object subclass: #PopUpMenu
	instanceVariableNames: 'labelString lineArray icons '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Menus'!

!classDefinition: #PopUpMenu category: #'Tools-Menus'!
Object subclass: #PopUpMenu
	instanceVariableNames: 'labelString lineArray icons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Menus'!
!MenuMorph methodsFor: 'construction' stamp: 'HAW 6/14/2018 12:12:12'!
 add: aString target: target action: aSymbol argument: arg icon: symbolOrFormOrNil
	
	^(self add: aString
		target: target
		action: aSymbol
		argumentList: { arg }) 
			setIcon: symbolOrFormOrNil;
			yourself
! !
!PopUpMenu methodsFor: 'accessing' stamp: 'HAW 6/14/2018 12:13:38'!
       iconAt: aPosition

	^icons at: aPosition ifAbsent: [ nil ]! !
!PopUpMenu methodsFor: 'private' stamp: 'HAW 6/14/2018 11:56:15'!
labels: aString lines: anArray icons: iconCollection

	labelString _ aString.
	lineArray _ anArray.
	icons _ iconCollection 
! !
!PopUpMenu class methodsFor: 'instance creation' stamp: 'HAW 6/14/2018 12:25:34'!
             labelArray: labelArray lines: lineArray icons: icons
	"Answer an instance of me whose items are in labelArray, with lines 
	drawn after each item indexed by anArray. 2/1/96 sw"

	labelArray isEmpty ifTrue: [self error: 'Menu must not be zero size'].
	^ self
		labels: (String streamContents: 
			[:stream |
			labelArray do: [:each | stream nextPutAll: each; newLine].
			stream skip: -1 "remove last newline"])
		lines: lineArray
		icons: icons

"Example:
	(PopUpMenu labelArray: #('frog' 'and' 'toad') lines: #() icons: #()) startUpWithCaption: 'Please pick one.'
"! !
!PopUpMenu class methodsFor: 'instance creation' stamp: 'HAW 6/14/2018 12:04:54'!
                   labels: aString lines: anArray icons: icons
	"Answer an instance of me whose items are in aString, with lines drawn 
	after each item indexed by anArray and icons per item."

	^ self new labels: aString lines: anArray icons: icons! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'HAW 6/14/2018 12:21:38'!
              confirm: queryString trueChoice: trueChoice falseChoice: falseChoice icons: icons
	"Put up a yes/no menu with caption queryString. The actual wording 
	for the two choices will be as provided in the trueChoice and 
	falseChoice parameters. Answer true if the response is the true-choice, 
	false if it's the false-choice.
	This is a modal question -- the user must respond one way or the other."

	"PopUpMenu confirm: 'Are you hungry?' trueChoice: 'yes, I''m famished' falseChoice: 'no, I just ate'"

	"PopUpMenu  confirm: 'Are you hungry?' trueChoice: 'yes, I''m famished' falseChoice: 'no, I just ate' icons: #(acceptIcon cancelIcon)"

	| menu choice |
	menu _ self labelArray: {trueChoice. falseChoice} lines: nil icons: icons.
	[(choice _ menu startUpWithCaption: queryString) isNil] whileTrue.
	^ choice = 1! !
!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'HAW 6/14/2018 12:13:56' prior: 50397564!
           from: aPopupMenu title: titleStringOrNil
	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."

	| menu items lines selections labelString j emphasis |
	menu _ self new.
	titleStringOrNil ifNotNil: [
		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].
	labelString _ aPopupMenu labelString.
	items _ labelString asString lines.
	(labelString is: #Text) ifTrue: [
		"Pass along text emphasis if present"
		j _ 1.
		items _ items collect: [ :item |
			j _ labelString asString findString: item startingAt: j.
			emphasis _ TextEmphasis new emphasisCode: (labelString emphasisAt: j).
			item asText addAttribute: emphasis]].
	lines _ aPopupMenu lineArray.
	lines ifNil: [lines _ #()].
	menu cancelValue: 0.
	menu defaultTarget: menu.
	selections _ (1 to: items size) asArray.
	1 to: items size do: [ :i |
		menu add: (items at: i) target: menu action: #selectMVCItem: argument: (selections at: i) icon: (aPopupMenu iconAt: i).
		(lines includes: i) ifTrue: [menu addLine]].
	^ menu
! !
!PopUpMenu methodsFor: 'private' stamp: 'HAW 6/14/2018 11:56:37' prior: 16891046!
   labels: aString lines: anArray

	self labels: aString lines: anArray icons: #()! !
!PopUpMenu class methodsFor: 'instance creation' stamp: 'HAW 6/14/2018 12:02:45' prior: 16891064!
           labelArray: labelArray lines: lineArray
	
	^self labelArray: labelArray lines: lineArray icons: #()! !
!PopUpMenu class methodsFor: 'instance creation' stamp: 'HAW 6/14/2018 12:04:21' prior: 16891089!
                       labels: aString lines: anArray
	"Answer an instance of me whose items are in aString, with lines drawn 
	after each item indexed by anArray."

	^ self labels: aString lines: anArray icons: #()! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'HAW 6/14/2018 12:18:59' prior: 50395775!
    confirm: queryString
	"Put up a yes/no menu with caption queryString. Answer true if the 
	response is yes, false if no. This is a modal question--the user must 
	respond yes or no."

	"
	PopUpMenu confirm: 'Are you hungry?'
	"

	^ self confirm: queryString trueChoice: 'Yes' falseChoice: 'No' icons: #(acceptIcon cancelIcon)! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'HAW 6/14/2018 12:17:00' prior: 16891125!
                               confirm: queryString orCancel: cancelBlock
	"Put up a yes/no/cancel menu with caption aString. Answer true if  
	the response is yes, false if no. If cancel is chosen, evaluate  
	cancelBlock. This is a modal question--the user must respond yes or no."

	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"

	| menu choice |
	menu _ self labelArray: {'Yes'. 'No'. 'Cancel'} lines: #() icons: #(acceptIcon cancelIcon collapseIcon).
	choice _ menu startUpWithCaption: queryString.
	choice = 1 ifTrue: [^ true].
	choice = 2 ifTrue: [^ false].
	^ cancelBlock value! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'HAW 6/14/2018 12:22:28' prior: 16891144!
        confirm: queryString trueChoice: trueChoice falseChoice: falseChoice
	
	"See #confirm:trueChoice:falseChoice:icons:"

	^self confirm: queryString trueChoice: trueChoice falseChoice: falseChoice icons: #()! !

PopUpMenu removeSelector: #icons!

Object subclass: #PopUpMenu
	instanceVariableNames: 'labelString lineArray icons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Menus'!

!classDefinition: #PopUpMenu category: #'Tools-Menus'!
Object subclass: #PopUpMenu
	instanceVariableNames: 'labelString lineArray icons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Menus'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3350-IconsInPopUpMenu-HernanWilkinson-2018Jun14-11h15m-HAW.1.cs.st----!

----SNAPSHOT----#(15 June 2018 11:06:28.139396 am) Cuis5.0-3350-v3.image priorSource: 2196430!

----QUIT----#(15 June 2018 11:06:54.952746 am) Cuis5.0-3350-v3.image priorSource: 2246729!

----STARTUP----#(11 July 2018 3:43:35.235421 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3350-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3350] on 15 June 2018 at 8:06:45 pm'!
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 19:47:32'!
 blockLevelOne

	^ #(
		blockStart1
		blockEnd1
		leftParenthesis1
		rightParenthesis1
	)! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 19:44:15'!
                     blockLevelThree

	^ #(
		blockStart3
		blockEnd3
		leftParenthesis3
		rightParenthesis3
	)
! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 19:45:51'!
                  blockLevelTwo

	^ #(
		blockStart2
		blockEnd2
		leftParenthesis2
		rightParenthesis2
	)
! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 19:53:16'!
                    blockLevelZero

	^ #(
		blockStart
		blockEnd
		leftParenthesis
		rightParenthesis
	)! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 19:53:22' prior: 16935803!
        defaults

	^ #(
		default
		arrayStart
		arrayEnd
		arrayStart1
		arrayEnd1
		leftBrace
		rightBrace
		cascadeSeparator
		chainSeparator
		statementSeparator
		externalCallType
		externalCallTypePointerIndicator
		blockArgColon
	)! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 20:06:29' prior: 16935821!
                       generateShoutConfig

	| styles colors |
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self literals . colors at: #literals}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelZero . colors at: #blockLevelZero}.
		{self blockLevelOne . colors at: #blockLevelOne}.
		{self blockLevelTwo . colors at: #blockLevelTwo}.
		{self blockLevelThree . colors at: #blockLevelThree}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . self italic}.
		{self symbols . colors at: #messages . #bold}.
		{self pattern . nil . #bold}.
		{self ansiAssignment . nil . #bold}.
		{self assignment . nil . #(#bold #withST80Glyphs)}.
		{self return . nil . #(#bold #withST80Glyphs)}.
		{self tempVars . colors at: #tempVars . self italic}.
		{self blockTemps . colors at: #tempBar . self italic}
	} do: [ :style |
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined .#bold}.
		{#unfinishedComment . colors at: #pseudoVariables . self italic}.
		{#comment . colors at: #comment . self italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . self italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 19:45:42' prior: 16935897!
                 instVar
	^ #(
		instVar
	)! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 6/15/2018 19:44:23' prior: 16935909!
   literals

	^ #(
			character
			integer
			number
			-
	)! !
!Theme methodsFor: 'shout' stamp: 'jmv 6/15/2018 20:06:11' prior: 16936786!
                       shout
	"Color symbols as an association list.
	SHTextStylerST80 initialize
	"
	
	^ {
		#defaults 					-> #black.
		#undefined 				-> #red.
		#comment 					-> #(green muchDarker).
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#literals 					-> #(green muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(cyan muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages 	-> #(gray veryMuchDarker).
		#blockLevelZero 			-> #black.
		#blockLevelOne 			-> #brown.
		#blockLevelTwo 			-> #magenta.
		#blockLevelThree 		-> #red.
		#blockLevelFour 			-> #(orange darker).
		#blockLevelFive 			-> #(orange muchDarker).
		#blockLevelSix 			-> #(green muchDarker).
		#blockLevelSeven 		-> #blue.
		#tempBar 					-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !

Theme removeSelector: #firstBlockLevel!

Theme removeSelector: #firstBlockLevel!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	SHTextStylerST80 initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3351-SyntaxHighlightEnhancements-JuanVuletich-2018Jun15-19h59m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3351] on 21 June 2018 at 2:06:07 pm'!
!PluggableMorph methodsFor: 'access' stamp: 'jmv 6/20/2018 22:42:04'!
        balloonText
	"Answer balloon help text or nil, if no help is available.
	NB: subclasses may override such that they programatically
	construct the text, for economy's sake, such as model phrases in
	a Viewer"

	| balloonText |
	balloonText _ super balloonText.
	balloonText isSymbol ifTrue: [ ^model perform: balloonText ].
	^ balloonText! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 6/20/2018 22:38:58' prior: 16875792!
             setBalloonText: stringTextOrSymbol
	"Set receiver's balloon help text. Pass nil to remove the help."

	 stringTextOrSymbol
		ifNil: [ self removeProperty: #balloonText ]
		ifNotNil: [
			self setProperty: #balloonText
			    	 toValue: ((stringTextOrSymbol  is: Text)
					ifTrue: [ stringTextOrSymbol asString ]
					ifFalse: [ stringTextOrSymbol ])]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 6/20/2018 22:33:30' prior: 50341582!
       addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #toggleCollapseOrShow.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: #label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3352-KeepTaskButtonBalloonUpdated-JuanVuletich-2018Jun21-14h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3351] on 21 June 2018 at 2:06:28 pm'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 6/21/2018 13:41:37' prior: 50371184!
                       parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth := 0.
	blockDepths _ OrderedCollection with: blockDepth.
	blockDepthsStartIndexes _ OrderedCollection with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollection new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		"Iterate once for methods, but pontentially several times for workspaces
		(to recover after errors, for possible good next lines or chunks)"
		[ sourcePosition <= source size ] whileTrue: [
			self parseStatementList.
			currentToken ifNotNil: [
				"Only if we are parsing a method, consider everything after this point as error."
				isAMethod ifTrue: [self error]]
		].
	] ensure: [errorBlock _ nil].
	^true! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3353-ShoutWorkspacesBychunks-JuanVuletich-2018Jun21-14h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3353] on 25 June 2018 at 12:07:56 pm'!
!Number methodsFor: 'mathematical functions' stamp: 'jmv 6/25/2018 12:03:06'!
                            argument
	"Answer the argument of the receiver (see Complex | argument).
	Answer is in (-Pi .. +Pi]
	Note: Assume the convention of 0+0i having argument=0"

	^self < 0
		ifFalse: [0]
		ifTrue: [Float pi]! !
!Number methodsFor: 'mathematical functions' stamp: 'jmv 6/25/2018 12:03:18'!
   phase
	"Answer the argument of the receiver.
	Answer is in (-Pi .. +Pi]
	Note: Assume the convention of 0+0i having argument=0"

	^ self argument! !
!Number methodsFor: 'arithmetic' stamp: 'jmv 6/25/2018 11:58:51' prior: 16879685!
                         arg
	"Answer the argument of the receiver (see Complex | arg).
	Note: #argument and #phase assume the convention of 0+0i having argument=0"
	
	self isZero ifTrue: [self error: 'Zero (0 + 0 i) does not have an argument.'].
	^self < 0
		ifFalse: [0]
		ifTrue: [Float pi]! !
!Complex methodsFor: 'accessing' stamp: 'jmv 6/25/2018 12:01:46' prior: 16822295!
                              argument
	"Answer the argument of the receiver.
	Answer is in (-Pi .. +Pi]"

	self isZero ifTrue: [ ^0.0 ].
	^imaginary arcTan: real! !
!Complex methodsFor: 'accessing' stamp: 'jmv 6/25/2018 11:52:36' prior: 16822305!
      magnitude
	"Answer the distance of the receiver from zero (0 + 0 i)."

	^ self abs! !
!Complex methodsFor: 'accessing' stamp: 'jmv 6/25/2018 12:03:15' prior: 16822311!
                        phase
	"Answer the argument of the receiver.
	Answer is in (-Pi .. +Pi]
	Note: Assume the convention of 0+0i having argument=0"

	^ self argument! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 6/25/2018 12:02:03' prior: 16822400!
                        arg
	"Answer the argument of the receiver.
	Answer is in (-Pi .. +Pi]
	Note: #argument and #phase assume the convention of 0+0i having argument=0"

	self isZero ifTrue: [self error: 'zero has no argument.'].
	^imaginary arcTan: real! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3354-Complex-enh-JuanVuletich-2018Jun25-10h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3348] on 30 June 2018 at 7:27:04 pm'!
!PopUpMenu class methodsFor: 'instance creation' stamp: 'HAW 6/30/2018 19:26:48'!
      labels: aString icons: icons
	"Answer an instance of me whose items are in aString."

	^self labels: aString lines: nil icons: icons! !
!PopUpMenu class methodsFor: 'dialogs' stamp: 'HAW 6/30/2018 19:26:35' prior: 50380089!
inform: aString
	"PopUpMenu inform: 'I like Cuis'"

	UISupervisor whenUIinSafeState: [ (self labels: ' OK ' icons: #(emblemImportantIcon)) startUpWithCaption: aString ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3355-inform_withIcon-HernanWilkinson-2018Jun30-19h26m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3348] on 1 July 2018 at 1:15:10 pm'!
!UndeclaredVariable methodsFor: 'exception handling' stamp: 'HAW 7/1/2018 13:05:18'!
                             defaultAction
	
	| labels actions lines caption choice icons |
	
	labels _ OrderedCollection new.
	actions _ OrderedCollection new.
	lines _ OrderedCollection new.
	icons _ OrderedCollection new.
	
	self createMenuOptionsAddingTo: labels actions: actions icons: icons lines: lines.
	caption _ 'Unknown variable: ' , name , ' please correct, or cancel:'.
	choice _ (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	
	self resume: (actions at: choice ifAbsent:[ nil ]).! !
!UndeclaredVariable methodsFor: 'exception handling - private' stamp: 'HAW 7/1/2018 12:59:52'!
     addAlternativesTo: labels actions: actions icons: icons
	
	| alternatives |
	
	alternatives _ parser possibleVariablesFor: name.
	alternatives do: [ :each |
		labels add: each.
		actions add: [ parser substituteVariable: each atInterval: interval ].
		icons add: nil ].
! !
!UndeclaredVariable methodsFor: 'exception handling - private' stamp: 'HAW 7/1/2018 12:55:34'!
               addCancelTo: labels actions: actions icons: icons
	
	labels add: 'cancel'.
	actions add: nil.
	icons add: #cancelIcon.
	
! !
!UndeclaredVariable methodsFor: 'exception handling - private' stamp: 'HAW 7/1/2018 12:50:36'!
    addGlobalVariableOptionsTo: labels actions: actions
	
	labels add: 'define new class'.
	actions add: [ parser defineClass: name ].
			
	labels add: 'declare global'.
	actions add: [ parser declareGlobal: name ].
			
	parser canDeclareClassVariable ifTrue: [
		labels add: 'declare class variable'.
		actions add: [ parser declareClassVar: name ]]
! !
!UndeclaredVariable methodsFor: 'exception handling - private' stamp: 'HAW 7/1/2018 12:49:43'!
  addLocalVariableOptionsTo: labels actions: actions

	labels add: 'declare block-local temp'.
	actions add: [ parser declareTemp: name at: #block ].
			
	labels add: 'declare method temp'.
	actions add: [ parser declareTemp: name at: #method ].
			
	parser canDeclareInstanceVariable ifTrue: [
		labels add: 'declare instance'.
		actions add: [ parser declareInstVar: name ]]! !
!UndeclaredVariable methodsFor: 'exception handling - private' stamp: 'HAW 7/1/2018 12:52:33'!
       addOptionsTo: labels actions: actions icons: icons

	name first isLowercase
		ifTrue: [ self addLocalVariableOptionsTo: labels actions: actions ]
		ifFalse: [ self addGlobalVariableOptionsTo: labels actions: actions ].
	labels size timesRepeat: [ icons add: #listAddIcon ].
		
! !
!UndeclaredVariable methodsFor: 'exception handling - private' stamp: 'HAW 7/1/2018 12:59:24'!
        createMenuOptionsAddingTo: labels actions: actions icons: icons lines: lines
	
	self addOptionsTo: labels actions: actions icons: icons.
	lines add: labels size.
	self addAlternativesTo: labels actions: actions icons: icons.
	lines add: labels size.
	self addCancelTo: labels actions: actions icons: icons.! !
!UndefinedVariable methodsFor: 'exception handling' stamp: 'HAW 7/1/2018 12:17:22'!
                      defaultAction

	| shouldResume |
	
	shouldResume := PopUpMenu confirm: name, ' appears to be\undefined at this point.\Proceed anyway?' withNewLines.
	^ self resume: shouldResume ! !
!UnknownSelector methodsFor: 'exception handling' stamp: 'HAW 7/1/2018 13:07:30'!
                        defaultAction 

	| alternatives labels lines caption choice icons |

	alternatives := Symbol possibleSelectorsFor: name.
	labels := Array streamContents: [:s | s nextPut: name; nextPutAll: alternatives; nextPut: 'cancel'].
	lines := {1. alternatives size + 1}.
	icons := Array new: labels size.
	icons at: 1 put: #acceptIcon.
	icons at: icons size put: #cancelIcon.
	caption := 'Unknown selector, please\confirm, correct, or cancel' withNewLines.
	
	choice := (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	choice = 1 ifTrue: [self resume: name asSymbol].
	choice = labels size ifTrue: [self resume: nil].
	self resume: (alternatives at: choice - 1 ifAbsent: [ nil ])
	
! !
!UnusedVariable methodsFor: 'exception handling' stamp: 'HAW 7/1/2018 12:14:01'!
     defaultAction
	
	| shouldResume |
	
	shouldResume := PopUpMenu confirm: name, ' appears to be\unused in this method.\OK to remove it?' withNewLines.
	self resume: shouldResume ! !

UnusedVariable removeSelector: #openMenuIn:!

UnusedVariable removeSelector: #openMenuIn:!

UnknownSelector removeSelector: #openMenuIn:!

UnknownSelector removeSelector: #openMenuIn:!

UndefinedVariable removeSelector: #openMenuIn:!

UndefinedVariable removeSelector: #openMenuIn:!

UndeclaredVariable removeSelector: #addAlternative:to:actions:icons:!

UndeclaredVariable removeSelector: #openMenuIn:!

UndeclaredVariable removeSelector: #openMenuIn:!

ParserNotification removeSelector: #defaultAction!

ParserNotification removeSelector: #defaultAction!

ParserNotification removeSelector: #openMenuIn:!

ParserNotification removeSelector: #openMenuIn:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3356-ParserNotification-Enhancements-HernanWilkinson-2018Jul01-12h05m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3356] on 4 July 2018 at 5:23:57 pm'!
!Complex class methodsFor: 'instance creation' stamp: 'jmv 7/4/2018 17:03:13'!
                        magnitude: rho phase: theta
	^ self abs: rho arg: theta! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3357-Complex-rho-phase-JuanVuletich-2018Jul04-16h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3348] on 2 July 2018 at 7:56:47 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 7/2/2018 19:55:29' prior: 16924171!
           browseMessageList: messageList name: labelString autoSelect: autoSelectString
	| title aSize |
	"Create and schedule a MessageSet browser on the message list."

	messageList size = 0 ifTrue: 
		[^ PopUpMenu inform: ('There are no\' , labelString) withNewLines ].

	title _ (aSize _ messageList size) > 1
		ifFalse:	[ labelString ]
		ifTrue:	[ '[', aSize printString, '] ', labelString].

	MessageSetWindow
		openMessageList: messageList
		label: title
		autoSelect: autoSelectString! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3358-inform-not-label-CuisCore-HernanWilkinson-2018Jul02-19h53m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3348] on 2 July 2018 at 8:04:58 pm'!
!SystemDictionary methodsFor: 'ui' stamp: 'HAW 7/2/2018 20:04:12' prior: 16923767!
                           confirmRemovalOf: aSelector on: aClass 
	"Determine if it is okay to remove the given selector. Answer 1 if it  
	should be removed, 2 if it should be removed followed by a senders  
	browse, and 3 if it should not be removed."
	| count aMenu answer caption allCalls |
	allCalls _ self allCallsOn: aSelector.
	(count _ allCalls size) = 0
		ifTrue: [^ 1].
	"no senders -- let the removal happen without warning"
	count = 1
		ifTrue: [(allCalls first actualClass == aClass
					and: [allCalls first methodSymbol == aSelector])
				ifTrue: [^ 1]].
	"only sender is itself"
	aMenu _ PopUpMenu labels: 'Remove it
Remove, then browse senders
Don''t remove, but show me those senders
Forget it -- do nothing -- sorry I asked'
		icons: #(acceptIcon acceptIcon cancelIcon cancelIcon).

	caption _ 'This message has ' , count printString , ' sender'.
	count > 1
		ifTrue: [caption _ caption copyWith: $s].
	answer _ aMenu startUpWithCaption: caption.
	answer = 3
		ifTrue: [self
				browseMessageList: allCalls
				name: 'Senders of ' , aSelector
				autoSelect: aSelector keywords first].
	answer = 0
		ifTrue: [answer _ 3].
	"If user didn't answer, treat it as cancel"
	^ answer min: 3! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3359-icon-on-method-removal-HernanWilkinson-2018Jul02-19h56m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3359] on 5 July 2018 at 4:03:31 pm'!
!Number methodsFor: 'accessing' stamp: 'jmv 7/5/2018 15:47:19'!
                          imaginary
	"Compatibility with Complex numbers"
	^ 0! !
!Number methodsFor: 'accessing' stamp: 'jmv 7/5/2018 15:47:55'!
        real
	"Compatibility with Complex numbers"
	^ self! !
!Number methodsFor: 'accessing' stamp: 'jmv 7/5/2018 15:48:09' prior: 50402132!
                          argument
	"Compatibility with Complex numbers.
	Answer the argument of the receiver (see Complex | argument).
	Answer is in (-Pi .. +Pi]
	Note: Assume the convention of 0+0i having argument=0"

	^self < 0
		ifFalse: [0]
		ifTrue: [Float pi]! !
!Number methodsFor: 'accessing' stamp: 'jmv 7/5/2018 15:48:20' prior: 16880163!
                            magnitude
	"Compatibility with Complex numbers"
	^self abs! !
!Number methodsFor: 'accessing' stamp: 'jmv 7/5/2018 15:48:29' prior: 50402141!
                  phase
	"Compatibility with Complex numbers.
	Answer the argument of the receiver.
	Answer is in (-Pi .. +Pi]
	Note: Assume the convention of 0+0i having argument=0"

	^ self argument! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3360-Number-ComplexProtocol-JuanVuletich-2018Jul05-10h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3345] on 5 July 2018 at 2:59:23 pm'!
!CodePackage methodsFor: 'accessing' stamp: 'HAW 7/5/2018 14:59:10' prior: 16810690!
           hasUnsavedChanges

	"Might be nil and breaks when a code package window is open and loading packages - Hernan
	This is not a lazy initialization, the variable is set to non nil value only when certain."
	^hasUnsavedChanges = true! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3361-FixPossibleWalkbackInPackageLoading-HernanWilkinson-2018Jul05-14h59m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3348] on 5 July 2018 at 3:17:35 pm'!
!Collection methodsFor: 'enumerating' stamp: 'HAW 7/5/2018 14:49:22'!
                           groupBy: keyBlock 

	^ self 
		inject: Dictionary new
		into: [ :groupedCollection :elementToGroup | | group |
			group := groupedCollection at: (keyBlock value: elementToGroup) ifAbsentPut: [ OrderedCollection new ].
			group add: elementToGroup.
			groupedCollection ]
		! !
!Collection methodsFor: 'enumerating' stamp: 'HAW 7/5/2018 15:14:50' prior: 16814398!
                     groupBy: keyBlock having: selectBlock 
	"Like in SQL operation - Split the receivers contents into collections of 
	elements for which keyBlock returns the same results, and return those 
	collections allowed by selectBlock. "
	
	^ (self groupBy: keyBlock) select: selectBlock! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3362-groupBy-HernanWilkinson-2018Jul02-20h04m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3348] on 5 July 2018 at 4:00:10 pm'!

Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #DynamicMenuBuilder category: #'Morphic-Menus'!
Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!DynamicMenuBuilder methodsFor: 'initialization' stamp: 'HAW 7/5/2018 15:42:29'!
                  initializeTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	title := aTitle.
	defaultTarget := aDefaultTarget.
	menuOptionsSelector := aMenuOptionsSelector ! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 15:59:10'!
  addGroupSeparation 

	menu addLine
	! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 15:56:23'!
   addGroupedMenuOptionsToMenu
	
	groups := items groupBy: [ :item | item at: #itemGroup ].
	groups keys asSortedCollection 
		do: [ :group | self addMenuOptionsOfGroup: group ]
		separatedBy: [ self addGroupSeparation ].
! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 15:55:59'!
            addMenuOptionsOfGroup: group

	| groupMenuOptions |
	
	groupMenuOptions := (groups at: group) asSortedCollection: [ :leftItem :rightItem | (leftItem at: #itemOrder) < (rightItem at: #itemOrder) ].
	menu addItemsFromDictionaries: groupMenuOptions.! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 15:53:08'!
                 collectMenuOptions

	items := (Smalltalk allClassesImplementing: menuOptionsSelector)
		collect: [ :item | item isMeta ifTrue: [ item soleInstance perform: menuOptionsSelector ] ]
		thenSelect: [ :item | item notNil ].! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/5/2018 15:41:58'!
        titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^self new initializeTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

! !
!DynamicMenuBuilder methodsFor: 'building' stamp: 'HAW 7/5/2018 15:57:34'!
        build

	self 
		createMenu;
	 	collectMenuOptions;
		addGroupedMenuOptionsToMenu.		
			
	^ menu.! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 15:52:31'!
       createMenu

	menu := MenuMorph entitled: title.
	menu 
		defaultTarget: defaultTarget; 
		addStayUpIcons! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 7/5/2018 15:47:16' prior: 50397000!
                           openMenu
	"Build the open window menu for the world."

	^(DynamicMenuBuilder titled: 'Open...' targeting: self collectingMenuOptionsWith: #worldMenuForOpenGroup) build

	! !

Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #DynamicMenuBuilder category: #'Morphic-Menus'!
Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3363-DynamicMenuBuilder-HernanWilkinson-2018Jul05-15h17m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3348] on 5 July 2018 at 6:42:58 pm'!
!DynamicMenuBuilder methodsFor: 'testing' stamp: 'HAW 7/5/2018 18:26:14'!
                         hasTitle

	^title ~= self class noTitle ! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 18:41:03'!
                               classesProvidingMenuOptions

	^(Smalltalk allClassesImplementing: menuOptionsSelector) select: [ :aClass | aClass isMeta ]! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/5/2018 18:25:03'!
        targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^self titled: self noTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

! !
!DynamicMenuBuilder class methodsFor: 'defaults' stamp: 'HAW 7/5/2018 18:25:09'!
                         noTitle

	^nil! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/5/2018 18:27:20'!
                             buildTargeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^(self targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector) build! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/5/2018 18:27:45'!
   buildTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^(self titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector) build! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/5/2018 18:37:46'!
      worldMenuOptions

	^`{{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		10.
		#label 			-> 		'Open...'.
		#selector 		-> 		#openOpenMenu.
		#icon 			-> 		#openIcon.
		#balloonText 	-> 		'Submenu to open various system tools'.
	} asDictionary.
	{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		20.
		#label 			-> 		'New morph...'.
		#selector 		-> 		#newMorph.
		#icon 			-> 		#morphsIcon.
		#balloonText 	-> 		'Offers a variety of ways to create new objects'.
	} asDictionary.
	{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		30.
		#label 			-> 		'Preferences...'.
		#selector 		-> 		#openPreferencesMenu.
		#icon 			-> 		#preferencesIcon.
		#balloonText 	-> 		'Opens a menu offering many controls over appearance and system preferences.'.
	} asDictionary.
				{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		40.
		#label 			-> 		'Windows...'.
		#selector 		-> 		#openWindowsMenu.
		#icon 			-> 		#windowIcon.
		#balloonText 	-> 		'Manage open windows'.
	} asDictionary.
	{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		50.
		#label 			-> 		'Help...'.
		#selector 		-> 		#openHelpMenu.
		#icon 			-> 		#helpIcon.
		#balloonText 	-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
	} asDictionary.
	{
		#itemGroup 	-> 		20.
		#itemOrder 		-> 		10.
		#label 			-> 		'Changes...'.
		#selector 		-> 		#openChangesMenu.
		#icon 			-> 		#changesIcon.
		#balloonText 	-> 		'Opens a menu of useful tools for dealing with changes'.
	} asDictionary.
	{
		#itemGroup 	-> 		20.
		#itemOrder 		-> 		20.
		#label 			-> 		'Debug...'.
		#selector 		-> 		#openDebugMenu.
		#icon 			-> 		#debugIcon.
		#balloonText 	-> 		'a menu of debugging items'.
	} asDictionary.
	{
		#itemGroup 	-> 		20.
		#itemOrder 		-> 		30.
		#label 			-> 		'Restore Display (r)'.
		#object 			-> 		#myWorld.
		#selector 		-> 		#restoreDisplay.
		#icon 			-> 		#displayIcon.
		#balloonText 	-> 		'Repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		10.
		#label 			-> 		'Save'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveSession.
		#icon 			-> 		#saveIcon.
		#balloonText 	-> 		'Save the current version of the image on disk'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		20.
		#label 			-> 		'Save as...'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveAs.
		#icon 			-> 		#saveAsIcon.
		#balloonText 	-> 		'Save the current version of the image on disk under a new name.'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		30.
		#label 			-> 		'Save as New Version'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveAsNewVersion.
		#icon 			-> 		#saveAsNewVersionIcon.
		#balloonText 	-> 		('Save the current image a new version-stamped name\and save it under that name on disk.\',
									'Clear all user preferences and user state (class vars).') withNewLines.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		40.
		#label 			-> 		'Save and Quit'.
		#selector 		-> 		#saveAndQuit.
		#icon 			-> 		#saveAndQuitIcon.
		#balloonText 	-> 		'Save the image and quit out of Cuis.'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		50.
		#label 			-> 		'Quit'.
		#selector 		-> 		#quitSession.
		#icon 			-> 		#quitIcon.
		#balloonText 	-> 		'Quit out of Cuis.'.
	} asDictionary.
}`! !
!Workspace class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:03:00' prior: 50393665!
                     worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		20.
			#label 			->		'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!Transcripter class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:02:53' prior: 50393678!
                         worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		30.
			#itemOrder 	-> 		20.
			#label 			->		'Emergency Evaluator'.
			#object 			-> 		Transcripter.
			#selector 		-> 		#emergencyEvaluator.
			#icon 			-> 		#emblemImportantIcon.
			#balloonText 	-> 		'When all else fails...'.
		} asDictionary}`! !
!TextEditor class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:02:41' prior: 50393691!
                         worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		10.
			#label 			->		'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:01:57' prior: 50393704!
                            worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		20.
			#itemOrder 	-> 		10.
			#label 			->		'Installed Packages'.
			#object 			-> 		CodePackageListWindow.
			#selector 		-> 		#openPackageList.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:01:26' prior: 50393718!
  worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		30.
			#label 			->		'Browser'.
			#object 			-> 		BrowserWindow.
			#selector 		-> 		#openBrowser.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:02:18' prior: 50393732!
                          worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		40.
			#label 			->		'Message Names'.
			#object 			-> 		MessageNamesWindow.
			#selector 		-> 		#openMessageNames.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:01:49' prior: 50393747!
                            worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		20.
			#itemOrder 	-> 		20.
			#label 			->		'Change Sorter'.
			#object 			-> 		ChangeSorterWindow.
			#selector 		-> 		#openChangeSorter.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:02:10' prior: 50393762!
                   worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		40.
			#itemOrder 	-> 		10.
			#label 			->		'File List'.
			#object 			-> 		FileListWindow.
			#selector 		-> 		#openFileList.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary}`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:02:24' prior: 50393775!
                   worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		30.
			#itemOrder 	-> 		10.
			#label 			->		'Process Browser'.
			#object 			-> 		ProcessBrowserWindow.
			#selector 		-> 		#openProcessBrowser.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:02:30' prior: 50393789!
                       worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		40.
			#itemOrder 	-> 		20.
			#label 			->		'SUnit Test Runner'.
			#object 			-> 		TestRunnerWindow.
			#selector 		-> 		#openTestRunner.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary}`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'HAW 7/5/2018 18:02:47' prior: 50393802!
            worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		50.
			#label 			->		'Transcript'.
			#object 			-> 		TranscriptWindow.
			#selector 		-> 		#openTranscript.
			#icon 			-> 		#printerIcon.
			#balloonText 	-> 		'A window showing contents of the System Transcript'.
		} asDictionary}`! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 18:41:32' prior: 50402608!
    collectMenuOptions

	items := OrderedCollection new.
	self classesProvidingMenuOptions do: [ :aClass | items addAll: (aClass soleInstance perform: menuOptionsSelector) ].
	! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 18:25:48' prior: 50402633!
           createMenu

	menu := self hasTitle ifTrue: [ MenuMorph entitled: title] ifFalse: [ MenuMorph new ].
	menu
		defaultTarget: defaultTarget;
		addStayUpIcons! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 7/5/2018 18:28:15' prior: 50396731!
         buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	^DynamicMenuBuilder buildTargeting: self collectingMenuOptionsWith: #worldMenuOptions
	! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 7/5/2018 18:28:15' prior: 50402640!
                    openMenu
	"Build the open window menu for the world."

	^DynamicMenuBuilder buildTitled: 'Open...' targeting: self collectingMenuOptionsWith: #worldMenuForOpenGroup
	! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3364-WorldMenuCustomization-HernanWilkinson-2018Jul05-16h00m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3358] on 7 July 2018 at 7:15:34 pm'!

Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups optionsChanger '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #DynamicMenuBuilder category: #'Morphic-Menus'!
Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups optionsChanger'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/6/2018 12:21:10'!
                  classListMenu2Options

	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'unsent methods'.
				#selector 		-> 		#browseUnusedMethods.
				#icon 			->		#junkIcon.
				#balloonText 	-> 		'browse all methods defined by this class that have no senders'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'unreferenced inst vars'.
				#selector 		-> 		#showUnreferencedInstVars.
				#icon 			->		#junkIcon.
				#balloonText 	-> 		'show a list of all instance variables that are not referenced in methods'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'unreferenced class vars'.
				#selector 		-> 		#showUnreferencedClassVars.
				#icon 			->		#junkIcon.
				#balloonText 	-> 		'show a list of all class variables that are not referenced in methods'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'subclass template'.
				#object 			-> 		#model.
				#selector 		-> 		#makeNewSubclass.
				#icon 			->		#classIcon.
				#balloonText 	-> 		'put a template into the code pane for defining of a subclass of this class'
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			->		#instanceIcon.
				#balloonText 	-> 		'give me a sample instance of this class, if possible'
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			->		#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class'
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			->		#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class and of all of its subclasses'
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'create inst var accessors'.
				#object 			-> 		#model.
				#selector 		-> 		#createInstVarAccessors.
				#icon 			->		#sendReceiveIcon.
				#balloonText 	-> 		'compile instance-variable access methods for any instance variables that do not yet have them'
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu.
				#icon 			->		#listAddIcon.
				#balloonText 	-> 		'return to the standard class-list menu'
			} asDictionary.
		}`! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/6/2018 11:58:54'!
                               classListMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutClass.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'show hierarchy'.
				#object 			-> 		#model.
				#selector 		-> 		#hierarchy.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'show definition'.
				#object 			-> 		#model.
				#selector 		-> 		#editClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'show comment'.
				#object 			-> 		#model.
				#selector 		-> 		#editComment.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'class vars'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class ...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'copy class...'.
				#object 			-> 		#model.
				#selector 		-> 		#copyClass.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runClassTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		70.
				#itemOrder 		-> 		20.
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/6/2018 12:24:58'!
                             messageCategoryMenuOptions

	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessageCategories.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editMessageCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'alphabetize'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeMessageCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove empty categories'.
				#object 			-> 		#model.
				#selector 		-> 		#removeEmptyCategories.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'categorize all uncategorized'.
				#object 			-> 		#model.
				#selector 		-> 		#categorizeAllUncategorizedMethods.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'new category...'.
				#object 			-> 		#model.
				#selector 		-> 		#addCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessageCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMessageCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 18:22:02'!
                messageListMenu2Options
	
	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleDiffing.
				#icon 			-> 		#switchIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'implementors of sent messages'.
				#selector 		-> 		#browseAllMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'local senders of...'.
				#selector 		-> 		#browseLocalSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'local implementors of...'.
				#selector 		-> 		#browseLocalImplementors.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'spawn sub-protocol'.
				#selector 		-> 		#browseProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'spawn full protocol'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#speadsheetTemplateIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'change category...'.
				#object 			-> 		#model.
				#selector 		-> 		#changeCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		50.
				#label 			-> 		'change sets with this method'.
				#selector 		-> 		#findMethodInChangeSets.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		60.
				#label 			-> 		'revert to previous version'.
				#object 			-> 		#model.
				#selector 		-> 		#revertToPreviousVersion.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#openMessageListMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.			
		}`! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 19:10:48'!
    messageListMenuOptions
	
	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'what to show...'.
				#selector 		-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'browse method (O)'.
				#selector 		-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'explore CompiledMethod'.
				#object 			-> 		#model.
				#selector 		-> 		#exploreCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'senders of... (n)'.
				#selector 		-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'implementors of... (m)'.
				#selector 		-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'inheritance (i)'.
				#selector 		-> 		#methodHierarchy.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'versions (v)'.
				#selector 		-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'class variables'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'run test (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'debug test (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 19:04:27'!
  systemCatSingletonMenuOptions

	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse all'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'update'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 19:02:29'!
                            systemCategoryMenuOptions

	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'recent classes... (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#recent.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse all'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editSystemCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'alphabetize'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeSystemCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'update'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'add item...'.
				#object 			-> 		#model.
				#selector 		-> 		#addSystemCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'move to top'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryTop.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'move up'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryUp.
				#icon 			-> 		#goUpIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'move down'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryDown.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		40.
				#label 			-> 		'move to bottom'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryBottom.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 	-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runSystemCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !
!DynamicMenuBuilder methodsFor: 'initialization' stamp: 'HAW 7/7/2018 18:43:12'!
                               initializeTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector changingThemWith: anOptionsChangerBlock

	title := aTitle.
	defaultTarget := aDefaultTarget.
	menuOptionsSelector := aMenuOptionsSelector.
	optionsChanger := anOptionsChangerBlock ! !
!DynamicMenuBuilder methodsFor: 'testing' stamp: 'HAW 7/5/2018 18:26:14' prior: 50402670!
           hasTitle

	^title ~= self class noTitle ! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/7/2018 18:40:31'!
                               changeOptions

	optionsChanger value: items! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 18:41:03' prior: 50402675!
            classesProvidingMenuOptions

	^(Smalltalk allClassesImplementing: menuOptionsSelector) select: [ :aClass | aClass isMeta ]! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/5/2018 18:25:03' prior: 50402682!
                        targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^self titled: self noTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/7/2018 18:42:10'!
                titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector changingThemWith: anOptionsChangerBlock

	^self new initializeTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector changingThemWith: anOptionsChangerBlock

! !
!DynamicMenuBuilder class methodsFor: 'defaults' stamp: 'HAW 7/5/2018 18:25:09' prior: 50402691!
  noTitle

	^nil! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/5/2018 18:27:20' prior: 50402695!
             buildTargeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^(self targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector) build! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/5/2018 18:27:45' prior: 50402703!
                   buildTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^(self titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector) build! !
!DynamicMenuBuilder class methodsFor: 'building' stamp: 'HAW 7/7/2018 18:42:56'!
     buildTitled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector changingThemWith: anOptionsChangerBlock

	^(self titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector changingThemWith: anOptionsChangerBlock) build! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 7/6/2018 12:14:46' prior: 50402988!
             buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	^(DynamicMenuBuilder buildTargeting: self collectingMenuOptionsWith: #worldMenuOptions)
		addStayUpIcons;
		yourself
	
	! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/5/2018 18:37:46' prior: 50402712!
            worldMenuOptions

	^`{{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		10.
		#label 			-> 		'Open...'.
		#selector 		-> 		#openOpenMenu.
		#icon 			-> 		#openIcon.
		#balloonText 	-> 		'Submenu to open various system tools'.
	} asDictionary.
	{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		20.
		#label 			-> 		'New morph...'.
		#selector 		-> 		#newMorph.
		#icon 			-> 		#morphsIcon.
		#balloonText 	-> 		'Offers a variety of ways to create new objects'.
	} asDictionary.
	{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		30.
		#label 			-> 		'Preferences...'.
		#selector 		-> 		#openPreferencesMenu.
		#icon 			-> 		#preferencesIcon.
		#balloonText 	-> 		'Opens a menu offering many controls over appearance and system preferences.'.
	} asDictionary.
				{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		40.
		#label 			-> 		'Windows...'.
		#selector 		-> 		#openWindowsMenu.
		#icon 			-> 		#windowIcon.
		#balloonText 	-> 		'Manage open windows'.
	} asDictionary.
	{
		#itemGroup 	-> 		10.
		#itemOrder 		-> 		50.
		#label 			-> 		'Help...'.
		#selector 		-> 		#openHelpMenu.
		#icon 			-> 		#helpIcon.
		#balloonText 	-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
	} asDictionary.
	{
		#itemGroup 	-> 		20.
		#itemOrder 		-> 		10.
		#label 			-> 		'Changes...'.
		#selector 		-> 		#openChangesMenu.
		#icon 			-> 		#changesIcon.
		#balloonText 	-> 		'Opens a menu of useful tools for dealing with changes'.
	} asDictionary.
	{
		#itemGroup 	-> 		20.
		#itemOrder 		-> 		20.
		#label 			-> 		'Debug...'.
		#selector 		-> 		#openDebugMenu.
		#icon 			-> 		#debugIcon.
		#balloonText 	-> 		'a menu of debugging items'.
	} asDictionary.
	{
		#itemGroup 	-> 		20.
		#itemOrder 		-> 		30.
		#label 			-> 		'Restore Display (r)'.
		#object 			-> 		#myWorld.
		#selector 		-> 		#restoreDisplay.
		#icon 			-> 		#displayIcon.
		#balloonText 	-> 		'Repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		10.
		#label 			-> 		'Save'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveSession.
		#icon 			-> 		#saveIcon.
		#balloonText 	-> 		'Save the current version of the image on disk'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		20.
		#label 			-> 		'Save as...'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveAs.
		#icon 			-> 		#saveAsIcon.
		#balloonText 	-> 		'Save the current version of the image on disk under a new name.'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		30.
		#label 			-> 		'Save as New Version'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveAsNewVersion.
		#icon 			-> 		#saveAsNewVersionIcon.
		#balloonText 	-> 		('Save the current image a new version-stamped name\and save it under that name on disk.\',
									'Clear all user preferences and user state (class vars).') withNewLines.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		40.
		#label 			-> 		'Save and Quit'.
		#selector 		-> 		#saveAndQuit.
		#icon 			-> 		#saveAndQuitIcon.
		#balloonText 	-> 		'Save the image and quit out of Cuis.'.
	} asDictionary.
	{
		#itemGroup 	-> 		30.
		#itemOrder 		-> 		50.
		#label 			-> 		'Quit'.
		#selector 		-> 		#quitSession.
		#icon 			-> 		#quitIcon.
		#balloonText 	-> 		'Quit out of Cuis.'.
	} asDictionary.
}`! !
!Workspace class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:15:27' prior: 50402821!
                     worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 		-> 		20.
			#label 			->		'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!Transcripter class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:15:19' prior: 50402834!
                        worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		30.
			#itemOrder 		-> 		20.
			#label 			->		'Emergency Evaluator'.
			#object 			-> 		Transcripter.
			#selector 		-> 		#emergencyEvaluator.
			#icon 			-> 		#emblemImportantIcon.
			#balloonText 	-> 		'When all else fails...'.
		} asDictionary}`! !
!TextEditor class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:14:50' prior: 50402847!
                        worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 		-> 		10.
			#label 			->		'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'HAW 7/5/2018 18:24:37' prior: 16887708!
          invokeWorldMenu
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	| menu |
	menu _ (TheWorldMenu new 
		world: self
		hand: self activeHand) buildWorldMenu.
	menu addTitle: Preferences desktopMenuTitle.
	menu popUpInWorld: self! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:13:05' prior: 50402860!
                         worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		20.
			#itemOrder 		-> 		10.
			#label 			->		'Installed Packages'.
			#object 			-> 		CodePackageListWindow.
			#selector 		-> 		#openPackageList.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 18:32:00' prior: 50396098!
    addExtraMenu2ItemsTo: optoins
	"The shifted selector-list menu is being built; some menu items are appropriate only for certain kinds of browsers, and this gives a hook for them to be added as approrpiate.  If any is added here, a line should be added first -- browse reimplementors of this message for examples."! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/6/2018 11:59:53' prior: 50398224!
        classListMenu
	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"

	^DynamicMenuBuilder buildTitled: 'Class List' targeting: self collectingMenuOptionsWith: #classListMenuOptions.! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/6/2018 12:18:34' prior: 50398313!
          classListMenu2
	"Set up the menu to apply to the receiver's class list when the shift key is down"

	^DynamicMenuBuilder buildTargeting: self collectingMenuOptionsWith: #classListMenu2Options.
	! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/6/2018 12:22:51' prior: 50401419!
                               messageCategoryMenu

	^DynamicMenuBuilder buildTitled: 'Message Category' targeting: self collectingMenuOptionsWith: #messageCategoryMenuOptions.
! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 19:09:07' prior: 50398441!
               messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	^DynamicMenuBuilder buildTitled: 'Message List' targeting: self collectingMenuOptionsWith: #messageListMenuOptions.
	! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 18:45:13' prior: 50398549!
   messageListMenu2
	"Fill aMenu with the items appropriate when the shift key is held down"

	^DynamicMenuBuilder 
		buildTitled: 'Message List' 
		targeting: self 
		collectingMenuOptionsWith: #messageListMenu2Options 
		changingThemWith: [ :options |
			self addExtraMenu2ItemsTo: options.
			model canShowMultipleMessageCategories ifTrue: [	
				options add: `{ 
					#itemGroup 	-> 		40.
					#itemOrder 		-> 		45.		
					#label 			-> 		'show category (C)'.
					#object 			-> 		#model.
					#selector 		-> 		#showHomeCategory.
					#icon 			-> 		#packageIcon
				} asDictionary` ]].
		
	! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 18:57:48' prior: 50398835!
                   systemCatSingletonMenu

	^DynamicMenuBuilder buildTitled: 'Class category' targeting: self collectingMenuOptionsWith: #systemCatSingletonMenuOptions.
! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 19:03:15' prior: 50398878!
           systemCategoryMenu

	^DynamicMenuBuilder buildTitled: 'Class category' targeting: self collectingMenuOptionsWith: #systemCategoryMenuOptions.! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/6/2018 11:53:52' prior: 50402874!
                 worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 		-> 		30.
			#label 			->		'Browser'.
			#object 			-> 		BrowserWindow.
			#selector 		-> 		#openBrowser.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`! !
!MessageSetWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 18:31:51' prior: 50398751!
                              addExtraMenu2ItemsTo: options
	"The shifted selector-list menu is being built.  Add items specific to MessageSet"

	model growable ifTrue: [
		options add: `{
			#itemGroup 	-> 		40.
			#itemOrder 		-> 		31.		
			#label 			-> 		'remove from this browser'.
			#object 			-> 		#model.
			#selector 		-> 		#removeMessageFromBrowser.
			#icon 			-> 		#listRemoveIcon 
		} asDictionary`.
		options add:`{
			#itemGroup 	-> 		40.
			#itemOrder 		-> 		32.		
			#label 			-> 		'filter message list...'.
			#selector 		-> 		#filterMessageList.
			#icon 			-> 		#findIcon
		} asDictionary`	].
	
	options add: `{
			#itemGroup 	-> 		40.
			#itemOrder 		-> 		33.		
			#label 			-> 		'sort by date'.
			#object 			-> 		#model.	
			#selector 		-> 		#sortByDate.
			#icon 			-> 		#dateIcon
		} asDictionary`.

! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:13:59' prior: 50402888!
                              worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 		-> 		40.
			#label 			->		'Message Names'.
			#object 			-> 		MessageNamesWindow.
			#selector 		-> 		#openMessageNames.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:12:50' prior: 50402903!
                           worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		20.
			#itemOrder 		-> 		20.
			#label 			->		'Change Sorter'.
			#object 			-> 		ChangeSorterWindow.
			#selector 		-> 		#openChangeSorter.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:13:27' prior: 50402918!
                  worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		40.
			#itemOrder 		-> 		10.
			#label 			->		'File List'.
			#object 			-> 		FileListWindow.
			#selector 		-> 		#openFileList.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary}`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:14:22' prior: 50402931!
                  worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		30.
			#itemOrder 		-> 		10.
			#label 			->		'Process Browser'.
			#object 			-> 		ProcessBrowserWindow.
			#selector 		-> 		#openProcessBrowser.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:14:27' prior: 50402945!
                      worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		40.
			#itemOrder 		-> 		20.
			#label 			->		'SUnit Test Runner'.
			#object 			-> 		TestRunnerWindow.
			#selector 		-> 		#openTestRunner.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary}`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:15:13' prior: 50402958!
           worldMenuForOpenGroup
	^ `{{
			#itemGroup 	-> 		10.
			#itemOrder 		-> 		50.
			#label 			->		'Transcript'.
			#object 			-> 		TranscriptWindow.
			#selector 		-> 		#openTranscript.
			#icon 			-> 		#printerIcon.
			#balloonText 	-> 		'A window showing contents of the System Transcript'.
		} asDictionary}`! !
!DynamicMenuBuilder methodsFor: 'building' stamp: 'HAW 7/7/2018 18:40:16' prior: 50402627!
             build

	self 
		createMenu;
	 	collectMenuOptions;
		changeOptions;
		addGroupedMenuOptionsToMenu.		
			
	^ menu.! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/5/2018 18:41:32' prior: 50402971!
      collectMenuOptions

	items := OrderedCollection new.
	self classesProvidingMenuOptions do: [ :aClass | items addAll: (aClass soleInstance perform: menuOptionsSelector) ].
	! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'HAW 7/6/2018 12:15:07' prior: 50402980!
           createMenu

	menu := self hasTitle ifTrue: [ MenuMorph entitled: title] ifFalse: [ MenuMorph new ].
	menu defaultTarget: defaultTarget! !
!DynamicMenuBuilder class methodsFor: 'instance creation' stamp: 'HAW 7/7/2018 18:41:32' prior: 50402618!
            titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector

	^self titled: aTitle targeting: aDefaultTarget collectingMenuOptionsWith: aMenuOptionsSelector changingThemWith: [ :options | ]! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 7/6/2018 12:14:08' prior: 50402997!
         openMenu
	"Build the open window menu for the world."

	^(DynamicMenuBuilder buildTitled: 'Open...' targeting: self collectingMenuOptionsWith: #worldMenuForOpenGroup) 
		addStayUpIcons;
		yourself
	! !

DynamicMenuBuilder class removeSelector: #buildTitled:targeting:collectingMenuOptionsWith:adding:!

DynamicMenuBuilder class removeSelector: #buildTitled:targeting:collectingMenuOptionsWith:changingOptionsWith:!

DynamicMenuBuilder class removeSelector: #titled:targeting:collectingMenuOptionsWith:adding:!

DynamicMenuBuilder class removeSelector: #titled:targeting:collectingMenuOptionsWith:changingOptionsWith:!

DynamicMenuBuilder removeSelector: #addOptionalOptions!

DynamicMenuBuilder removeSelector: #initializeTitled:targeting:collectingMenuOptionsWith:!

DynamicMenuBuilder removeSelector: #initializeTitled:targeting:collectingMenuOptionsWith:!

DynamicMenuBuilder removeSelector: #initializeTitled:targeting:collectingMenuOptionsWith:adding:!

DynamicMenuBuilder removeSelector: #initializeTitled:targeting:collectingMenuOptionsWith:changingOptionsWith:!

Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups optionsChanger'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #DynamicMenuBuilder category: #'Morphic-Menus'!
Object subclass: #DynamicMenuBuilder
	instanceVariableNames: 'title defaultTarget menuOptionsSelector menu items groups optionsChanger'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3365-DynamicMenusInBrowser-HernanWilkinson-2018Jul05-16h00m-HAW.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3365] on 9 July 2018 at 4:41:43 pm'!
!False methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:12:50'!
 and: aBlock1 and: aBlock2

	^self! !
!False methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:13:01'!
                          and: aBlock1 and: aBlock2 and: aBlock3

	^self! !
!False methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:13:06'!
             and: aBlock1 and: aBlock2 and: aBlock3 and: aBlock4

	^self! !
!False methodsFor: 'controlling' stamp: 'jmv 7/9/2018 16:37:10'!
or: aBlock1 or: aBlock2

	^aBlock1 value or: aBlock2! !
!False methodsFor: 'controlling' stamp: 'jmv 7/9/2018 16:39:33'!
       or: aBlock1 or: aBlock2 or: aBlock3

	^aBlock1 value or: aBlock2 or: aBlock3! !
!False methodsFor: 'controlling' stamp: 'jmv 7/9/2018 16:39:40'!
               or: aBlock1 or: aBlock2 or: aBlock3 or: aBlock4

	^aBlock1 value or: aBlock2 or: aBlock3 or: aBlock4! !
!True methodsFor: 'controlling' stamp: 'jmv 7/9/2018 16:38:32'!
                        and: aBlock1 and: aBlock2

	^aBlock1 value and: aBlock2! !
!True methodsFor: 'controlling' stamp: 'jmv 7/9/2018 16:39:09'!
     and: aBlock1 and: aBlock2 and: aBlock3

	^aBlock1 value and: aBlock2 and: aBlock3! !
!True methodsFor: 'controlling' stamp: 'jmv 7/9/2018 16:39:14'!
           and: aBlock1 and: aBlock2 and: aBlock3 and: aBlock4

	^aBlock1 value and: aBlock2 and: aBlock3 and: aBlock4 ! !
!True methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:13:31'!
                or: aBlock1 or: aBlock2

	^self! !
!True methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:13:43'!
                             or: aBlock1 or: aBlock2 or: aBlock3

	^self! !
!True methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:13:48'!
                 or: aBlock1 or: aBlock2 or: aBlock3 or: aBlock4

	^self! !
!Boolean methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:16:44' prior: 16790174!
                  and: block1 and: block2
	"Nonevaluating conjunction without deep nesting.
	The receiver is evaluated, followed by the blocks in order.
	If any of these evaluates as false, then return false immediately,
		without evaluating any further blocks.
	If all return true, then return true."

	self subclassResponsibility! !
!Boolean methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:16:50' prior: 16790189!
                and: block1 and: block2 and: block3
	"Nonevaluating conjunction without deep nesting.
	The receiver is evaluated, followed by the blocks in order.
	If any of these evaluates as false, then return false immediately,
		without evaluating any further blocks.
	If all return true, then return true."

	self subclassResponsibility! !
!Boolean methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:16:57' prior: 16790205!
    and: block1 and: block2 and: block3 and: block4
	"Nonevaluating conjunction without deep nesting.
	The receiver is evaluated, followed by the blocks in order.
	If any of these evaluates as false, then return false immediately,
		without evaluating any further blocks.
	If all return true, then return true."

	self subclassResponsibility! !
!Boolean methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:17:04' prior: 16790280!
                        or: block1 or: block2
	"Nonevaluating alternation without deep nesting.
	The receiver is evaluated, followed by the blocks in order.
	If any of these evaluates as true, then return true immediately,
		without evaluating any further blocks.
	If all return false, then return false."

	self subclassResponsibility! !
!Boolean methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:17:09' prior: 16790294!
                  or: block1 or: block2 or: block3
	"Nonevaluating alternation without deep nesting.
	The receiver is evaluated, followed by the blocks in order.
	If any of these evaluates as true, then return true immediately,
		without evaluating any further blocks.
	If all return false, then return false."

	self subclassResponsibility! !
!Boolean methodsFor: 'controlling' stamp: 'HAW 7/8/2018 20:17:17' prior: 16790310!
       or: block1 or: block2 or: block3 or: block4
	"Nonevaluating alternation without deep nesting.
	The receiver is evaluated, followed by the blocks in order.
	If any of these evaluates as true, then return true immediately,
		without evaluating any further blocks.
	If all return false, then return false."

	self subclassResponsibility! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3366-BooleanEnhancements-HernanWilkinson-JuanVuletich-2018Jul09-16h31m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3364] on 9 July 2018 at 10:16:59 am'!
!Float64Array methodsFor: 'arithmetic' stamp: 'jmv 7/8/2018 19:37:51'!
                    divideBy: aFloatArrayOrNumber ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue
	^aFloatArrayOrNumber isNumber
		ifTrue:[self divideByScalar: aFloatArrayOrNumber asFloat ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue]
		ifFalse:[self divideByArray: aFloatArrayOrNumber ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue]! !
!Float64Array methodsFor: 'primitives-plugin' stamp: 'jmv 7/9/2018 09:45:37'!
                        divideByArray: floatArray ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue

	"It would be nice to have FloatArrayPlugin or equivalent for Float64Array..."
	1 to: self size do:[:i| | dividend divisor quotient |
		dividend _ self at: i.
		divisor _ floatArray at: i.
		quotient _ 
			divisor isZero 
				ifTrue: [
					dividend isZero
						ifTrue: indeterminateBlockOrValue
						ifFalse: zeroDivisionBlockOrValue ]
				ifFalse: [dividend / divisor].
		self at: i put: quotient]! !
!Float64Array methodsFor: 'primitives-plugin' stamp: 'jmv 7/9/2018 09:45:23'!
                    divideByScalar: scalarValue ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue

	"It would be nice to have FloatArrayPlugin or equivalent for Float64Array..."
	1 to: self size do:[:i| | dividend quotient |
		dividend _ self at: i.
		quotient _ 
			scalarValue isZero 
				ifTrue: [
					dividend isZero
						ifTrue: indeterminateBlockOrValue
						ifFalse: zeroDivisionBlockOrValue ]
				ifFalse: [dividend / scalarValue].
		self at: i put: quotient]! !
!FloatArray methodsFor: 'arithmetic' stamp: 'jmv 7/9/2018 09:41:43'!
                         divideBy: aFloatArrayOrNumber ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue
	^aFloatArrayOrNumber isNumber
		ifTrue:[self divideByScalar: aFloatArrayOrNumber asFloat ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue]
		ifFalse:[self divideByArray: aFloatArrayOrNumber ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue]! !
!FloatArray methodsFor: 'primitives-plugin' stamp: 'jmv 7/9/2018 09:44:49'!
                          divideByArray: floatArray ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue

	(self primDivArray: floatArray) == #primitiveFailure ifTrue: [
		1 to: self size do:[:i| | dividend divisor quotient |
			dividend _ self at: i.
			divisor _ floatArray at: i.
			quotient _ 
				divisor isZero 
					ifTrue: [
						dividend isZero
							ifTrue: indeterminateBlockOrValue
							ifFalse: zeroDivisionBlockOrValue ]
					ifFalse: [dividend / divisor].
			self at: i put: quotient]]! !
!FloatArray methodsFor: 'primitives-plugin' stamp: 'jmv 7/8/2018 21:47:26'!
                         divideByScalar: scalarValue ifDivisorZero: zeroDivisionBlockOrValue ifBothZero: indeterminateBlockOrValue

	"This primitive doesn't fail if argument is zeros, just fills with infinity or nan"
	scalarValue isZero ifFalse: [
		^self primDivScalar: scalarValue ].
	1 to: self size do:[:i| | dividend quotient |
		dividend _ self at: i.
		quotient _ dividend isZero
				ifTrue: indeterminateBlockOrValue
				ifFalse: zeroDivisionBlockOrValue.
		self at: i put: quotient]! !
!Float64Array methodsFor: 'arithmetic' stamp: 'jmv 7/8/2018 18:52:23' prior: 16846212!
                   /= anObject

	^self divideBy: anObject
		ifDivisorZero: [^ZeroDivide signalWithDividend: self]
		ifBothZero: [^ZeroDivide signalWithDividend: self]! !
!FloatArray methodsFor: 'arithmetic' stamp: 'jmv 7/8/2018 18:52:33' prior: 16846470!
                    /= anObject

	^self divideBy: anObject
		ifDivisorZero: [^ZeroDivide signalWithDividend: self]
		ifBothZero: [^ZeroDivide signalWithDividend: self]! !
!FloatArray methodsFor: 'primitives-plugin' stamp: 'jmv 7/8/2018 19:29:26' prior: 16846584!
             primDivArray: floatArray

	<primitive: 'primitiveDivFloatArray' module: 'FloatArrayPlugin'>
	^#primitiveFailure! !
!FloatArray methodsFor: 'primitives-plugin' stamp: 'jmv 7/8/2018 19:53:08' prior: 16846592!
                 primDivScalar: scalarValue
	"This primitive doesn't fail if argument is zero. It fills result with infinity or nan.
	For consistency with division with arrays, and general practice, an exception block or value might be used in public protocol. If needed, call directly this method instead.

	#[1.0 2.0 3.141592 0.0] asFloatArray primDivScalar: 0.0.
	#[1.0 2.0 3.141592 0.0] asFloatArray / 0.0.
	#[1.0 2.0 3.141592 0.0] asFloatArray divideBy: 0.0 ifDivisorZero: -100 ifBothZero: -200
	"
	<primitive: 'primitiveDivScalar' module: 'FloatArrayPlugin'>
	1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue].! !

Float64Array removeSelector: #primDivArray:!

Float64Array removeSelector: #primDivArray:!

Float64Array removeSelector: #primDivScalar:!

Float64Array removeSelector: #primDivScalar:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3367-ArrayDivisionEnhancements-JuanVuletich-2018Jul09-10h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3358] on 9 July 2018 at 5:31:34 pm'!
!False methodsFor: 'controlling' stamp: 'HAW 7/9/2018 17:27:55' prior: 50404249!
                               or: aBlock1 or: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 value or: [ aBlock2 value ]
! !
!False methodsFor: 'controlling' stamp: 'HAW 7/9/2018 17:28:10' prior: 50404253!
 or: aBlock1 or: aBlock2 or: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 value or: [ aBlock2 value or: [ aBlock3 value ] ]! !
!False methodsFor: 'controlling' stamp: 'HAW 7/9/2018 17:28:37' prior: 50404258!
or: aBlock1 or: aBlock2 or: aBlock3 or: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 value or: [ aBlock2 value or: [ aBlock3 value or: [ aBlock4  value ]]].
! !
!True methodsFor: 'controlling' stamp: 'HAW 7/9/2018 17:29:32' prior: 50404264!
                              and: aBlock1 and: aBlock2

	"I sending value to aBlock2 to optimize the generated byte-code - Hernan"
	^aBlock1 value and: [ aBlock2 value ]! !
!True methodsFor: 'controlling' stamp: 'HAW 7/9/2018 17:29:59' prior: 50404268!
and: aBlock1 and: aBlock2 and: aBlock3

	"I sending value to aBlock3 to optimize the generated byte-code - Hernan"
	^aBlock1 value and: [ aBlock2 value and: [ aBlock3 value ]]! !
!True methodsFor: 'controlling' stamp: 'HAW 7/9/2018 17:30:40' prior: 50404273!
                             and: aBlock1 and: aBlock2 and: aBlock3 and: aBlock4

	"I sending value to aBlock4 to optimize the generated byte-code - Hernan"
	^aBlock1 value and: [ aBlock2 value and: [ aBlock3 value and: [ aBlock4 value ]]] ! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3368-BooleanEnhancements-take2-HernanWilkinson-2018Jul08-20h18m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3361] on 10 July 2018 at 7:12:14 pm'!
!SmalltalkEditor methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:08:18'!
                       createMenuCollectingOptionsWith: aMenuOptionsSelector
	
	^(DynamicMenuBuilder buildTitled: self class name targeting: self collectingMenuOptionsWith: aMenuOptionsSelector)
		addStayUpIcons;
		yourself
		
! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:08:50'!
           getMenu2
	
	^self createMenuCollectingOptionsWith: #smalltalkEditorMenu2Options! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:09:14'!
        openMenu: aMenu
	
	aMenu popUpInWorld: morph world! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:03:02'!
                               smalltalkEditorMenu2Options
	
	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`
! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 7/10/2018 18:57:42'!
  smalltalkEditorMenuOptions
	
	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'Debug it (D)'.	
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		60.
				#label 			-> 		'Profile it'.	
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cancel (l)'.
				#selector 		-> 		#cancelEdits.
				#icon 			-> 		#cancelIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:08:33' prior: 50396445!
                         getMenu
	
	^self createMenuCollectingOptionsWith: #smalltalkEditorMenuOptions! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:09:25' prior: 50395424!
                          openMenu
	
	self openMenu: self getMenu 
	! !
!SmalltalkEditor methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:09:34' prior: 50396540!
                             openMenu2
	
	self openMenu: self getMenu2
	! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3369-Make-SmalltalkEditorMenu-dynamic-HernanWilkinson-2018Jul10-18h51m-HAW.1.cs.st----!

----SNAPSHOT----#(11 July 2018 3:43:41.828695 pm) Cuis5.0-3369-v3.image priorSource: 2246825!

----QUIT----#(11 July 2018 3:43:52.96215 pm) Cuis5.0-3369-v3.image priorSource: 2342632!

----STARTUP----#(27 July 2018 10:45:18.046887 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3369-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3369] on 11 July 2018 at 5:18:12 pm'!
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 7/11/2018 17:16:50' prior: 50373579!
                     browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry browser |
	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol _ self selectedSymbol ifNil: [
		self
			evaluateSelectionAndDo: [ :result | result class name ]
			ifFail: [ morph flash ]
			profiled: false].

	aSymbol first isUppercase
		ifTrue: [
			anEntry _ (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry _ anEntry class].
			browser _ Browser new.
			browser setClass: anEntry selector: nil.
			BrowserWindow open: browser label:'System Browser: ',  aSymbol]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3370-browseIt-onObjects-JuanVuletich-2018Jul11-17h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3369] on 11 July 2018 at 6:10:38 pm'!
!Float methodsFor: 'printing' stamp: 'jmv 7/11/2018 18:06:31'!
  absPrintOn: aStream base: base mantissaSignificantBits: significantBits
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	This version performs all calculations with Floats instead of LargeIntegers, and loses
	about 3 lsbs of accuracy compared to an exact conversion."

	| fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |
	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].
	fBase := base asFloat.
	exp := self exponent.
	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue:
			[r := self.
			s := 1.0.
			mPlus := 1.0 timesTwoPower: exp - significantBits.
			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]
		ifFalse:
			[r := self timesTwoPower: significantBits.
			s := 1.0 timesTwoPower:  significantBits.
			mMinus := 1.0 timesTwoPower: (exp max: -1024).
			mPlus :=
				(exp = MinValLogBase2) | (self significand ~= 1.0)
					ifTrue: [mMinus]
					ifFalse: [mMinus * 2.0]].
	baseExpEstimate >= 0
		ifTrue:
			[exp = 1023
				ifTrue:   "scale down to prevent overflow to Infinity during conversion"
					[r := r / fBase.
					s := s * (fBase raisedToInteger: baseExpEstimate - 1).
					mPlus := mPlus / fBase.
					mMinus := mMinus / fBase]
				ifFalse:
					[s := s * (fBase raisedToInteger: baseExpEstimate)]]
		ifFalse:
			[exp < -1023
				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"
					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.
					scale := fBase raisedToInteger: d.
					r := r * scale.
					mPlus := mPlus * scale.
					mMinus := mMinus * scale.
					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]
				ifFalse:
				[scale := fBase raisedToInteger: baseExpEstimate negated].
			s := s / scale].
	(r + mPlus >= s)
		ifTrue: [baseExpEstimate := baseExpEstimate + 1]
		ifFalse:
			[s := s / fBase].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue:
			[decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]
		ifFalse:
			[decPointCount := 1].
	[d := (r / s) truncated.
	r := r - (d * s).
	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:
		[aStream nextPut: (Character digitValue: d).
		r := r * fBase.
		mPlus := mPlus * fBase.
		mMinus := mMinus * fBase.
		decPointCount := decPointCount - 1.
		decPointCount = 0 ifTrue: [aStream nextPut: $.]].
	tc2 ifTrue:
		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue:
		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].
		aStream nextPutAll: '.0'].
	fixedFormat ifFalse:
		[aStream nextPut: $e.
		aStream nextPutAll: (baseExpEstimate - 1) printString]! !
!Float methodsFor: 'printing' stamp: 'jmv 7/11/2018 17:45:59'!
          printAsIEEE32BitPrecisionFloatOn: aStream base: base
	"Handle sign, zero, and NaNs; all other values passed to absPrintOn:base:mantissaSignificantBits:
	Print as a 32 bit Float" 

	self isNaN ifTrue: [aStream nextPutAll: 'NaN'. ^ self]. "check for NaN before sign"
	self > 0.0
		ifTrue: [self absPrintOn: aStream base: base mantissaSignificantBits: 24]
		ifFalse:
			[self sign = -1
				ifTrue: [aStream nextPutAll: '-'].
			self = 0.0
				ifTrue: [aStream nextPutAll: '0.0'. ^ self]
				ifFalse: [self negated absPrintOn: aStream base: base mantissaSignificantBits: 24]]! !
!FloatArray methodsFor: 'printing' stamp: 'jmv 7/11/2018 17:49:59'!
                             printElementsOn: aStream
	"FloatArray elements are answered as 64 bit Float, but are really 32 bit Float.
	When printing, print them as 32 bit Float."
	aStream nextPut: $(.
	self do: [ :element |
		element printAsIEEE32BitPrecisionFloatOn: aStream base: 10.
		aStream space].
	self isEmpty ifFalse: [aStream skip: -1].
	aStream nextPut: $)! !
!Float methodsFor: 'printing' stamp: 'jmv 7/11/2018 17:43:34' prior: 16845413!
                          absPrintOn: aStream base: base
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	This version performs all calculations with Floats instead of LargeIntegers, and loses
	about 3 lsbs of accuracy compared to an exact conversion."

	self absPrintOn: aStream base: base mantissaSignificantBits: 50 "approximately 3 lsb's of accuracy loss during conversion"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3371-FloatArray-printAs32bitFloat-JuanVuletich-2018Jul11-18h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3371] on 15 July 2018 at 10:28:26 pm'!
!MouseEvent methodsFor: 'button state' stamp: 'jmv 7/15/2018 22:24:54' prior: 16879055!
    mouseButton1Pressed
	"Answer true if the mouseButton1 is being pressed.
	This is the first mouse button, usually the one at the left.
	But if they are combined with ctrl or option(Mac) keys, it is considered button 2 or 3 (depending on shift).
	See also #mouseButton1Changed"

	self controlKeyPressed ifTrue: [ ^ false ].
	^ buttons anyMask: InputSensor mouseButton1! !
!MouseEvent methodsFor: 'button state' stamp: 'jmv 7/15/2018 22:23:15' prior: 16879080!
                      mouseButton2Pressed
	"Answer true if the mouseButton2 is being pressed.
	This is usually the right mouse button or option+click on the Mac.
	It is also emulated here with shift-ctrl-click on any platform."

	(self controlKeyPressed and: [self shiftPressed] and: [ buttons anyMask: InputSensor mouseButton1 ])
		ifTrue: [ ^ true ].
	^ buttons anyMask: InputSensor mouseButton2! !
!MouseEvent methodsFor: 'button state' stamp: 'jmv 7/15/2018 22:21:11' prior: 16879089!
             mouseButton3Pressed
	"Answer true if the mouseButton3 is being pressed.
	This is usually the center (wheel) mouse button or cmd+click on the Mac or ctrl+click on Linux.
	It is also emulated here with ctrl-click on any platform (i.e. Windows)."

	(self controlKeyPressed and: [self shiftPressed not] and: [ buttons anyMask: InputSensor mouseButton1 ])
		ifTrue: [ ^ true ].
	^ buttons anyMask: InputSensor mouseButton3! !
!MouseButtonEvent methodsFor: 'accessing' stamp: 'jmv 7/15/2018 22:25:04' prior: 16878630!
mouseButton1Changed
	"Answer true if the mouseButton1 has changed.
	This is usually the left mouse button.
	But if they are combined with ctrl or option(Mac) keys, it is considered button 2 or 3 (depending on shift).
	The check for button change (instead of button press) is specially useful on buttonUp events.
	See also #mouseButton1Pressed"

	self controlKeyPressed ifTrue: [ ^ false ].
	^ whichButton anyMask: InputSensor mouseButton1! !
!MouseButtonEvent methodsFor: 'accessing' stamp: 'jmv 7/15/2018 22:22:40' prior: 16878657!
           mouseButton2Changed
	"Answer true if the mouseButton2 has changed.
	This is the usually the right mouse button or option+click on the Mac.
	It is also emulated here with shift-ctrl-click on any platform.
	The check for button change (instead of button press) is specially useful on buttonUp events."

	(self controlKeyPressed and: [self shiftPressed] and: [ whichButton anyMask: InputSensor mouseButton1 ])
		ifTrue: [ ^ true ].
	^ whichButton anyMask: InputSensor mouseButton2! !
!MouseButtonEvent methodsFor: 'accessing' stamp: 'jmv 7/15/2018 22:22:16' prior: 16878669!
    mouseButton3Changed
	"Answer true if the mouseButton3 has changed.
	This is usually the center (wheel) mouse button or cmd+click on the Mac or ctrl+click on Linux.
	It is also emulated here with ctrl-click on any platform (i.e. Windows).
	The check for button change (instead of button press) is specially useful on buttonUp events."

	(self controlKeyPressed and: [self shiftPressed not] and: [ whichButton anyMask: InputSensor mouseButton1 ])
		ifTrue: [ ^ true ].
	^ whichButton anyMask: InputSensor mouseButton3! !

Preferences class removeSelector: #commandClickOpensHalo!

Preferences class removeSelector: #commandClickOpensHalo!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3372-ctrlClick-shiftCtrlClick-MouseButtons-JuanVuletich-2018Jul15-22h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3372] on 16 July 2018 at 4:24:19 pm'!
!Array2D methodsFor: 'iterating' stamp: 'jmv 7/16/2018 15:12:46'!
           do: aBlock
	"Evaluate aBlock on each element"

	1 to: height do: [ :i |
		1 to: width do: [ :j |
			aBlock value: (self i: i j: j) ] ]! !
!Array2D methodsFor: 'iterating' stamp: 'jmv 7/16/2018 16:14:30'!
                    with: otherImage do: aBlock
	"Evaluate aBlock on each element"

	1 to: height do: [ :i |
		1 to: width do: [ :j |
			aBlock value: (self i: i j: j) value: (otherImage i: i j: j) ] ]! !
!Array2D methodsFor: 'iterating' stamp: 'jmv 7/16/2018 15:11:48' prior: 16780157!
                     withIndexesDo: aBlock
	"Evaluate aBlock on each element, including i, j indexes also as arguments"

	1 to: height do: [ :i |
		1 to: width do: [ :j |
			aBlock value: i value: j value: (self i: i j: j) ] ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3373-Array2D-iteration-JuanVuletich-2018Jul16-15h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3372] on 19 July 2018 at 9:35:19 am'!
!Number methodsFor: 'converting' stamp: 'jmv 7/18/2018 11:03:29'!
           inMinusPiToPiRange
	"Avoid conversion to Float if already ok"
	(self > Float pi negated and: [self <= Float pi]) ifTrue: [
		^ self ].
	^ self asFloat inMinusPiToPiRange! !
!Float methodsFor: 'converting' stamp: 'jmv 7/17/2018 15:52:15'!
                  inMinusPiToPiRange
	"For angles in radians. Add or remove whole turns until we get to the (-Pi .. +Pi] range"
	| answer |
	answer _ self \\ Twopi.
	answer > Pi ifTrue: [
		answer _ answer - Twopi ].
	^ answer! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3374-inMinusPiToPiRange-JuanVuletich-2018Jul19-09h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3374] on 26 July 2018 at 11:48:37 am'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 7/26/2018 09:42:55'!
                           smoothIsAbsBelow: threshold
	"A Function that is 1 at zero, 0 outside a bounded interval of size 4*threshold, and is continuous and differentiable.
	
	It is a 'smooth' version of the #isAbsBelow: function.
	Useful when we need to 'count' stuff, but still want continuous and differentiable stuff."
	"
	| g |
	Feature require: 'Morphic-Widgets-Extras'.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x abs < Float halfPi ifTrue: [1] ifFalse:[0] ] color: Color brown.
	g addFunction: [ :x | x smoothIsAbsBelow: Float halfPi ] color: Color red.
	(g embeddedInMorphicWindowLabeled: 'graph') openInWorld
	"
	| scaled |
	scaled _ self / threshold.
	^ scaled abs < 2 ifTrue: [ (scaled * Float halfPi) cos + 1.0 * 0.5 ] ifFalse: [ 0 ]! !
!Number methodsFor: 'arithmetic' stamp: 'jmv 7/26/2018 09:41:17' prior: 16879650!
                        \\ divisor
	"Modulo operation. Remainder of the integer division #// (Floored division, truncated to minus infinity, a.k.a Knuth's division)
	Answer a Number with the same sign as divisor. 
	9\\4 = 1
	-9\\4 = 3
	9\\-4 = -3
	0.9\\0.4 = 0.1
	See http://en.wikipedia.org/wiki/Modulo_operation
	See #\\, #rem: and #mod:
	See detailed discussion at http://mathforum.org/library/drmath/view/52343.html
	"

	^self - (self // divisor * divisor)

	"Evaluate the following:"
"
| g d |
d _ 1.
Feature require: 'Morphic-Widgets-Extras'.
g _ FunctionGraphMorph new.
g domain: (-4 to: 4).
g addFunction: [ :x | x \\ d ] color: Color green.
g addFunction: [ :x | x // d ] color: Color red.
g openInWorld
"
"
| g d |
d _ -1.
Feature require: 'Morphic-Widgets-Extras'.
g _ FunctionGraphMorph new.
g domain: (-4 to: 4).
g addFunction: [ :x | x \\ d ] color: Color green.
g addFunction: [ :x | x // d ] color: Color red.
g openInWorld
"! !
!Number methodsFor: 'arithmetic' stamp: 'jmv 7/26/2018 09:41:05' prior: 16879710!
                     mod: divisor
	"Modulo operation. Remainder of the integer division #div: (Euclidean division)
	Answer a Number that is never negative (it is positive or zero). 
	(9 mod: 4) = 1
	(-9 mod: 4) = 3
	(9 mod: -4) = 1
	(0.9 mod: 0.4) = 0.1
	See http://en.wikipedia.org/wiki/Modulo_operation
	See #\\, #rem: and #mod:
	See detailed discussion at http://mathforum.org/library/drmath/view/52343.html
	And https://biblio.ugent.be/input/download?func=downloadFile&recordOId=314490&fileOId=452146
	"
	"Answer r such that: 
		for some integer q, aNumber * q + r = self
		with 0 <= r < | aNumber |"

	^self \\ divisor abs

	"Evaluate the following:"
"
| g d |
d _ 1.
Feature require: 'Morphic-Widgets-Extras'.
g _ FunctionGraphMorph new.
g domain: (-4 to: 4).
g addFunction: [ :x | x mod: d ] color: Color green.
g addFunction: [ :x | x div: d ] color: Color red.
g openInWorld
"
"
| g d |
d _ -1.
Feature require: 'Morphic-Widgets-Extras'.
g _ FunctionGraphMorph new.
g domain: (-4 to: 4).
g addFunction: [ :x | x mod: d ] color: Color green.
g addFunction: [ :x | x div: d ] color: Color red.
g openInWorld
"
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3375-smothIsAbsBelow-JuanVuletich-2018Jul26-09h40m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3375] on 26 July 2018 at 3:11:29 pm'!
!Editor class methodsFor: 'help' stamp: 'jmv 7/26/2018 15:10:49' prior: 16836998!
  help
	"
	Editor help
	SimpleEditor help
	CellStyleEditor help
	TextEditor help
	SmalltalkEditor help
	"
	| allSpecs |
	allSpecs _ self cmdShortcutsSpec, self basicCmdShortcutsSpec.
	^String streamContents: [ :strm |
		allSpecs do: [ :triplet | | c |
			c _ triplet first = Character space
				ifFalse: [ triplet first asString, '   	' ]
				ifTrue: [ 'Space'].
			strm nextPutAll: ('Cmd-', c, String tab, String tab, triplet third).
			strm newLine ]]! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 7/26/2018 15:05:27' prior: 50341355!
          cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debug it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'jmv 7/26/2018 15:04:57' prior: 50404713!
    smalltalkEditorMenuOptions
	
	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 	-> 		10.
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		50.
				#label 			-> 		'Debug it (D)'.	
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		60.
				#label 			-> 		'Profile it'.	
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 	-> 		10.
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 	-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 	-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 	-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 	-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 	-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 	-> 		20.
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 	-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 	-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 	-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 	-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 	-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 	-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`! !

InnerTextMorph removeSelector: #cancelEdits!

InnerTextMorph removeSelector: #cancelEdits!

TextEditor removeSelector: #cancelEdits!

TextEditor removeSelector: #cancelEdits!

TextEditor removeSelector: #cancelEdits:!

TextEditor removeSelector: #cancelEdits:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3376-remove-cancel-command-JuanVuletich-2018Jul26-15h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3375] on 26 July 2018 at 3:17:53 pm'!
!CuisSourceFileArray commentStamp: '<historical>' prior: 16825649!
Cuis source code access mechanism.
Uses the range for sourcePointer in CompiledMethods (16r1000000 to 16r4FFFFFF) quite differently than StandardSourceFileArray (the older way, inherited from Squeak). First half is for Sources, second half is for Changes. The actual offset in the file is the sourcePointer minus 16r1000000 (or minus 16r3000000) multiplied by a scaling factor. This scaling factor is (right now) 32, raising the limit to 1Gb.

See the class comment at MigratingSourceFileArray to see how to activate this.!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3377-CuisSourceFileArray-comment-JuanVuletich-2018Jul26-15h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3377] on 26 July 2018 at 6:15:23 pm'!

Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName LastStats LogsUserChanges '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #Utilities category: #'System-Support'!
Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName LastStats LogsUserChanges'
	poolDictionaries: ''
	category: 'System-Support'!
!SystemDictionary methodsFor: 'image, changes name' stamp: 'jmv 7/26/2018 18:15:12'!
            defaultUserChangesName
	"Answer the default full path to the changes file corresponding to the image file name."
	"
	Smalltalk defaultUserChangesName
	"
	^(FileIOAccessor default baseNameFor: self imageName), '.user.changes'! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 7/26/2018 18:15:16'!
             logsUserChanges
	LogsUserChanges ifNil: [ LogsUserChanges _ true ].
	^ LogsUserChanges! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 7/26/2018 18:15:19'!
                       logsUserChanges: aBoolean
	LogsUserChanges _ aBoolean! !

Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName LastStats LogsUserChanges'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #Utilities category: #'System-Support'!
Object subclass: #Utilities
	instanceVariableNames: ''
	classVariableNames: 'AuthorInitials AuthorName LastStats LogsUserChanges'
	poolDictionaries: ''
	category: 'System-Support'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3378-logsUserChanges-JuanVuletich-2018Jul26-18h12m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3377] on 26 July 2018 at 6:28:18 pm'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 7/26/2018 18:22:27' prior: 16806554!
     classComment: aString stamp: aStamp
	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."

	| ptr header oldCommentRemoteStr |
	aString isRemote ifTrue: [
		SystemChangeNotifier uniqueInstance classCommented: self.
		^ self organization classComment: aString stamp: aStamp].

	oldCommentRemoteStr _ self organization commentRemoteStr.
	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].
		"never had a class comment, no need to write empty string out"

	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].
	SourceFiles ifNotNil: [ | file |
		(file _ SourceFiles at: 2) ifNotNil: [
			file setToEnd; newLine; nextPut: $!!.	"directly"
			header _ String streamContents: [:strm | strm nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
				aStamp storeOn: strm.
				strm nextPutAll: ' prior: '; nextPutAll: ptr printString].
			file nextChunkPut: header]].
	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
				stream newLine; nextPut: $!!.	"directly"
				header _ String streamContents: [:strm | strm nextPutAll: self name;
					nextPutAll: ' commentStamp: '.
					aStamp storeOn: strm.
					strm nextPutAll: ' prior: '; nextPutAll: ptr printString].
				stream nextChunkPut: header.
				stream newLine; nextChunkPut: aString.
			].
	].
	SystemChangeNotifier uniqueInstance classCommented: self! !
!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'jmv 7/26/2018 18:22:23' prior: 16782654!
              fileOutCommentOn: aFileStream moveSource: moveSource toFile: fileIndex
	"Copy the class comment to aFileStream.  If moveSource is true (as in compressChanges or compressSources, then update classComment to point to the new file."
	| fileComment |
	classComment ifNotNil: [
		aFileStream newLine.
		fileComment _ RemoteString newString: classComment text
						onFileNumber: fileIndex toFile: aFileStream.
		moveSource ifTrue: [classComment _ fileComment].
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			stream newLine; nextChunkPut: classComment text ]]! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 7/26/2018 18:22:32' prior: 16820535!
              putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock
	"Store the source code for the receiver on an external file.
	If no sources are available, i.e., SourceFile is nil, do nothing.
	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,
	in each case, storing a 4-byte source code pointer at the method end."

	| file remoteString  |
	(SourceFiles notNil and: [(file _ SourceFiles at: fileIndex) notNil]) ifTrue: [

		Smalltalk assureStartupStampLogged.
		file setToEnd.

		preambleBlock value: file.  "Write the preamble"
		remoteString _ RemoteString newString: sourceStr onFileNumber: fileIndex toFile: file.

		file nextChunkPut: ' '.
		InMidstOfFileinNotification signal ifFalse: [file flush].
		self checkOKToAdd: sourceStr size at: remoteString position in: fileIndex.
		self setSourcePosition: remoteString position inFile: fileIndex ].

	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			preambleBlock value: stream.  "Write the preamble"
			stream nextChunkPut: sourceStr.
			stream nextChunkPut: ' ' ]
	]! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 7/26/2018 17:58:26' prior: 50369617!
    logSnapshot: save andQuit: quit
	"Log quitting to changes file"
	| msg |
	self assureStartupStampLogged.
	msg _ self snapshotMessageFor: save andQuit: quit.
	(SourceFiles at: 2) ifNotNil: [
		save ifTrue: [
			LastQuitLogPosition _ (SourceFiles at: 2)
				 setToEnd;
				 position ]].
	self logChange: msg.
	Transcript
		 newLine;
		 show: msg;
		 newLine! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 7/26/2018 18:23:44' prior: 16923062!
                    assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp asString; newLine.
			self forceChangesToDisk ]].
	Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp asString; newLine ].
	StartupStamp _ nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 7/26/2018 17:58:32' prior: 16923264!
                       logChange: aStringOrText 
	"Write the argument, aString, onto the changes file."
	^ self logChange: aStringOrText preamble: nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 7/26/2018 18:27:21' prior: 16923287!
                        logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString _ aStringOrText asString.
	(aString findFirst: [:char | char isSeparator not]) = 0
		ifTrue: [^ self].  "null doits confuse replay"
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"
			self forceChangesToDisk ]].
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString ]]! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 7/26/2018 18:15:37' prior: 50366259!
 fileInAnnouncing: announcement
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	Utilities logsUserChanges: false.
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :barBlock | 
			[ self atEnd ] whileFalse: [
					barBlock value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, 
									because next line is a doit that does the stuff
									(or because it is handled elsewhere)"
									(chunk beginsWith: 'description:  ')
									| (chunk beginsWith: 'provides: ')
									| (chunk beginsWith: 'requires: ')
									| (chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Compiler evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Compiler evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex pass ]
										]] 
							on: InMidstOfFileinNotification
							do: [ :ex | ex resume: true ] ].
			].
	"Note:  The main purpose of this banner is to flush the changes file."
	Utilities logsUserChanges: true.
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3379-NewLogOfUserChanges-JuanVuletich-2018Jul26-18h15m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3379] on 27 July 2018 at 9:49:22 am'!
!ClassDescription methodsFor: 'accessing' stamp: 'jmv 7/27/2018 09:42:53' prior: 16805673!
                  comment: aStringOrText
	"Set the receiver's comment to be the argument, aStringOrText."

	self theNonMetaClass classComment: aStringOrText asString.! !
!ClassDescription methodsFor: 'accessing' stamp: 'jmv 7/27/2018 09:41:06' prior: 16805680!
             comment: aStringOrText stamp: aStamp
	"Set the receiver's comment to be the argument, aStringOrText."

	self theNonMetaClass classComment: aStringOrText asString stamp: aStamp.! !
!PseudoClass methodsFor: 'class' stamp: 'jmv 7/27/2018 09:43:05' prior: 16896748!
                          comment: aString
	self classComment: aString asString! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3380-tweaks-JuanVuletich-2018Jul27-09h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3380] on 27 July 2018 at 10:26:23 am'!
!FileSystemEntry methodsFor: 'convenience' stamp: 'jmv 7/27/2018 10:18:05'!
   ifExists: aBlock
	"Evaluate a block with receiver as argument if it exists on the file system. If not, do nothing."
	self exists ifTrue: [
		aBlock value: self ]! !
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 7/27/2018 10:24:05'!
                withPackageSubfoldersOf: aDirectoryEntry do: aBlock

	"Look in the requested directory"
	aBlock value: aDirectoryEntry.

	"Look in the usual Packages subfolders"
	aDirectoryEntry / 'Packages' ifExists: [ :packagesFolder |
		aBlock value: packagesFolder.
		packagesFolder / 'MorphicExamples' ifExists: [ :subFolder | aBlock value: subFolder ].
		packagesFolder / 'CompatibilityPackages' ifExists: [ :subFolder | aBlock value: subFolder ]].
	aDirectoryEntry / 'M3' ifExists: [ :subFolder | aBlock value: subFolder ]! !
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 7/27/2018 10:16:03' prior: 50376559!
inPackagesSubtreeOf: aDirectoryEntry do: aBlock

	"Direct subfolders"
	self withPackageSubfoldersOf: aDirectoryEntry do: aBlock.

	"Finally look in folders that follow the convention of naming package repositories
	with the 'Cuis-Smalltalk' prefix, and their possible 'Packages' subdir."
	aDirectoryEntry children do: [ :entry |
		(entry isDirectory and: [ entry name beginsWith: 'Cuis-Smalltalk' ]) ifTrue: [
			self withPackageSubfoldersOf: entry do: aBlock ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3381-PrerequisitesLoadingImprovements-JuanVuletich-2018Jul27-10h25m-jmv.1.cs.st----!

----SNAPSHOT----#(27 July 2018 10:45:24.93112 am) Cuis5.0-3381-v3.image priorSource: 2342727!

----QUIT----#(27 July 2018 10:45:47.931205 am) Cuis5.0-3381-v3.image priorSource: 2378184!

----STARTUP----#(2 August 2018 9:10:51.994686 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3381-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3381] on 27 July 2018 at 2:21:57 pm'!
!ChangeList class methodsFor: 'public access' stamp: 'jmv 7/27/2018 14:20:49' prior: 16796932!
                  browseRecentLogOn: origChangesFileName startingFrom: initialPos 
	"Prompt with a menu of how far back to go when browsing a changes file."

	| end banners positions pos chunk i |
	origChangesFileName asFileEntry readStreamDo: [ :changesFile |
		banners _ OrderedCollection new.
		positions _ OrderedCollection new.
		end _ changesFile size.
		pos _ initialPos.
		[pos = 0
			or: [banners size > 20]]
			whileFalse: [
				changesFile position: pos.
				chunk _ changesFile nextChunk.
				i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
				i > 0
					ifTrue: [
						positions addLast: pos.
						banners addLast: (chunk copyFrom: 5 to: i - 2).
						pos _ Number readFrom: (chunk copyFrom: i + 13 to: chunk size)]
					ifFalse: [
						positions addLast: 0.
						banners addLast: 'Whole file'.
						pos _ 0]].
	].
	banners size = 0 ifTrue: [^ self inform: 
'this image has never been saved
since changes were compressed'].
	pos _ (SelectionMenu labelList: banners selections: positions)
				startUpWithCaption: 'Browse as far back as...'.
	pos
		ifNil: [^ self].
	self browseRecent: end - pos on: origChangesFileName! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 7/27/2018 14:21:47' prior: 50405706!
         putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock
	"Store the source code for the receiver on an external file.
	If no sources are available, i.e., SourceFile is nil, do nothing.
	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,
	in each case, storing a 4-byte source code pointer at the method end."

	| file remoteString  |
	Smalltalk assureStartupStampLogged.
	(SourceFiles notNil and: [(file _ SourceFiles at: fileIndex) notNil]) ifTrue: [
		file setToEnd.
		preambleBlock value: file.  "Write the preamble"
		remoteString _ RemoteString newString: sourceStr onFileNumber: fileIndex toFile: file.
		file nextChunkPut: ' '.
		InMidstOfFileinNotification signal ifFalse: [file flush].
		self checkOKToAdd: sourceStr size at: remoteString position in: fileIndex.
		self setSourcePosition: remoteString position inFile: fileIndex ].

	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			preambleBlock value: stream.  "Write the preamble"
			stream nextChunkPut: sourceStr.
			stream nextChunkPut: ' ' ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3382-RecentChangesBrowseTweaks-JuanVuletich-2018Jul27-14h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3382] on 27 July 2018 at 6:17:35 pm'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 7/27/2018 18:16:30' prior: 50402086!
                parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	| continue |
	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth := 0.
	blockDepths _ OrderedCollection with: blockDepth.
	blockDepthsStartIndexes _ OrderedCollection with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollection new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		"Iterate once for methods, but pontentially several times for workspaces
		(to recover after errors, for possible good next lines or chunks)"
		continue _ true.
		[ continue ] whileTrue: [
			self parseStatementList.
			isAMethod
				ifTrue: [
					"Only if we are parsing a method, consider everything after this point as error."
					currentToken ifNotNil: [ self error ].
					continue _ false]
				ifFalse: [
					sourcePosition > source size ifTrue: [continue _ false]]].
	] ensure: [errorBlock _ nil].
	^true! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3383-WorkspaceShoutFix-JuanVuletich-2018Jul27-18h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3384] on 30 July 2018 at 9:40:43 am'!
!Number methodsFor: 'testing' stamp: 'jmv 7/30/2018 08:51:35'!
                             ifNotZero: aBlock
	"
	Useful for workarounding division by zero
	#(1.0 2.0 0.0) collect: [ :k | k ifNotZero: [100.0/k]]
	"
	^ self isZero ifFalse: aBlock ifTrue: [self]! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 7/30/2018 08:53:30' prior: 50365021!
                      scrollBy: delta
	"Move the contents in the direction delta."

	| newYoffset yRange xRange newXoffset |
	
	"Set the offset on the scroller"
	yRange _ self vLeftoverScrollRange.
	xRange _ self hLeftoverScrollRange.
	newYoffset _ self scrollerOffset y - delta y min: yRange max: 0.
	newXoffset _ self scrollerOffset x - delta x min: xRange max: 0.
	
	self scrollerOffset: newXoffset@newYoffset.

	"Update the scrollBars"
	scrollBar scrollValue: (yRange ifNotZero: [newYoffset asFloat / yRange]).
	hScrollBar scrollValue: (xRange ifNotZero: [newXoffset asFloat / xRange])! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 7/30/2018 08:58:19' prior: 50384511!
       scrollToShow: aRectangle
	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.
	This means that 0@0 is scrolling all the way top and all the way left"
	| deltaY |
	(aRectangle top >= (0.1*self viewableHeight) and: [
		aRectangle bottom <= (0.9*self viewableHeight) ])
		ifTrue: [
			"already visible"
			^self ].

	"Scroll center of selection into view if necessary"
	deltaY _ self viewableExtent y * 0.1 - aRectangle top.
	deltaY ~= 0 ifTrue: [
		self scrollBy: 0@deltaY ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3384-scrollToShow-JuanVuletich-2018Jul30-09h40m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3384] on 31 July 2018 at 5:43:12 pm'!
!ChangeList class methodsFor: 'public access' stamp: 'jmv 7/31/2018 17:40:24' prior: 50369846!
                   browseRecentLogOn: origChangesFileName 
	"figure out where the last snapshot or quit was, then browse the recent entries."

	| end done block positions prevBlock |
	origChangesFileName asFileEntry readStreamDo: [ :changesFile |
		positions _ SortedCollection new.
		end _ changesFile size.
		prevBlock _ end.
		block _ end - 1024 max: 0.
		done _ false.
		[ done or: [ positions size > 0 ]]
			whileFalse: [
				changesFile position: block.
				"ignore first fragment"
				changesFile nextChunk.
				[ changesFile position < prevBlock ]
					whileTrue: [
						| pos chunk |
						pos _ changesFile position.
						chunk _ changesFile nextChunk.
						((Smalltalk isQuitRecord: chunk) or: [ Smalltalk isSnapshotRecord: chunk ])
							ifTrue: [ positions add: pos ]].
				block = 0
					ifTrue: [done _ true]
					ifFalse: [
						prevBlock _ block.
						block _ block - 1024 max: 0]].
	].
	self browseRecentLogOn: origChangesFileName startingFrom: (positions isEmpty ifTrue: [0] ifFalse: [positions last])! !
!ChangeList class methodsFor: 'public access' stamp: 'jmv 7/31/2018 17:42:47' prior: 50405982!
              browseRecentLogOn: origChangesFileName startingFrom: initialPos 
	"Prompt with a menu of how far back to go when browsing a changes file."

	| end banners positions pos chunk i |
	origChangesFileName asFileEntry readStreamDo: [ :changesFile |
		banners _ OrderedCollection new.
		positions _ OrderedCollection new.
		end _ changesFile size.
		pos _ initialPos.
		[pos = 0
			or: [banners size > 20]] 		"Go back at most 20 image exits"
			whileFalse: [
				changesFile position: pos.
				chunk _ changesFile nextChunk.
				i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.
				i > 0
					ifTrue: [
						positions addLast: pos.
						banners addLast: (chunk copyFrom: 5 to: i - 2).
						pos _ Number readFrom: (chunk copyFrom: i + 13 to: chunk size)]
					ifFalse: [
						pos _ 0]].
	].
	positions addLast: 0.
	banners addLast: 'Whole file'.
	pos _ (SelectionMenu labelList: banners selections: positions)
				startUpWithCaption: 'Browse as far back as...'.
	pos
		ifNil: [^ self].
	self browseRecent: end - pos on: origChangesFileName! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 7/31/2018 17:21:48' prior: 16797019!
       serviceRecentChanges
	"Answer a service for opening a changelist browser on the tail end of a .changes file"

	^ SimpleServiceEntry 
		provider: self 
		label: 'recent changes in file'
		selector: #browseRecentLogOn:
		description: 'open a changelist tool on recent changes in file'
		buttonLabel: 'recent changes'! !

ChangeList class removeSelector: #browseRecentLogOnPath:!

ChangeList class removeSelector: #browseRecentLogOnPath:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3385-recentLog-Enh-JuanVuletich-2018Jul31-17h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3385] on 1 August 2018 at 5:29:52 pm'!

Object subclass: #FileSystemEntry
	instanceVariableNames: 'drive pathComponents parent name creationTime modificationTime primEntryInParent exists lastSync '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-FileMan-Core'!

!classDefinition: #FileSystemEntry category: #'System-FileMan-Core'!
Object subclass: #FileSystemEntry
	instanceVariableNames: 'drive pathComponents parent name creationTime modificationTime primEntryInParent exists lastSync'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-FileMan-Core'!
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 16:15:03'!
  name: aString parent: parentEntryOrNil
	name _ aString.
	parentEntryOrNil
		ifNil: [
			self pathString: aString ]
		ifNotNil: [
			parent _ parentEntryOrNil.
			drive _ parentEntryOrNil drive. "harmless if no drive supported, as in Unix"
			pathComponents _ parentEntryOrNil pathComponents copyWith: name ].
	self refresh! !
!FileSystemEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 16:20:13'!
                   updateFrom: primitiveArray entryInParent: index
	primEntryInParent _ index.
	lastSync _ DateAndTime now.
	exists _ true.
	creationTime _ DateAndTime fromSeconds: (primitiveArray at: 2).
	modificationTime _ DateAndTime fromSeconds: (primitiveArray at: 3)! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:12:40'!
             pathComponents: tokens drive: driveStringOrNil
	| firstToken  |
	tokens isEmptyOrNil ifTrue: [ ^pathComponents _ nil ].
	(driveStringOrNil isNil and: [ (firstToken _ tokens first) isDriveName])
		ifTrue: [
			self drive: firstToken.
			pathComponents _ tokens copyFrom: 2 to: tokens size ]
		ifFalse: [
			self drive: driveStringOrNil.
			pathComponents _ tokens ].

	pathComponents ifNotEmpty: [ name _ pathComponents last ].
	self refresh! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:15:35'!
                  pathString: aString 
	| tokens guessedDriveName |
"esto esta detectando el drive si corresponde y despues pasa nil para que se vuelva a detectar. repasar"
	tokens _ FileIOAccessor default absolutePathComponentsFor: aString.
	tokens ifEmpty: [^ nil].
	self fileAccessor isDriveSupported
		 ifTrue: [
			guessedDriveName _ tokens first asDriveName.
			guessedDriveName ifNotNil: [
"Yo creo que aca habria que llamar a #pathComponents:drive: y salir...."
				self drive: guessedDriveName.
				tokens := tokens copyFrom: 2 to: tokens size ]].
	self pathComponents: tokens drive: nil! !
!FileSystemEntry class methodsFor: 'instance creation' stamp: 'jmv 8/1/2018 16:16:01'!
   withPathComponents: comps drive: driveString
	"May exist or not"
	| instance |
	instance _ self new.
	instance pathComponents: comps drive: driveString.
	^instance! !
!FileSystemEntry class methodsFor: 'instance creation' stamp: 'jmv 8/1/2018 16:17:07'!
  withPathName: aString
	"May exist or not"
	| instance |
	instance _ self new.
	instance pathString: aString.
	^instance! !
!DirectoryEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 15:46:30'!
                               updateFrom: primitiveArray entryInParent: index
	super updateFrom: primitiveArray entryInParent: index.
	children _ nil.	"lazy initialization"! !
!FileEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 10:38:53'!
             primEntryInParent
	^ primEntryInParent! !
!FileEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 16:20:02'!
                     updateFrom: primitiveArray entryInParent: index
	super updateFrom: primitiveArray entryInParent: index.
	fileSize _ primitiveArray at: 5! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 7/31/2018 10:36:52' prior: 16842806!
                   fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font _ Preferences standardListFont.
	spaceWidth _ font widthOf: $ .
	nameStr _ entry isDirectory
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd _ namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr _ nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr _ (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits _ entry fileSize printString size.
	sizeStr _ entry fileSize printStringWithCommas.
	sizeDigitsAndCommas _ sizeStr size.
	spacesToAdd _ sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd _ spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr _ (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces _ String new: 6 withAll: $ .
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ]! !
!String methodsFor: 'fileman-converting' stamp: 'jmv 8/1/2018 16:17:21' prior: 16917503!
                      asDirectoryEntry
	"See examples in #asFileEntry method comment"
	^DirectoryEntry withPathName: self! !
!String methodsFor: 'fileman-converting' stamp: 'jmv 8/1/2018 16:17:23' prior: 16917538!
asFileEntry
	"

Windows	
	'C:\Windows' asFileEntry exists false
	'C:\Windows' asDirectoryEntry exists true
	'/' asFileEntry exists false
	'/' asDirectoryEntry exists false
	'C:\' asFileEntry exists false
	'C:\' asDirectoryEntry exists true
	('C:' asDirectoryEntry // 'Windows') exists false
	('C:' asDirectoryEntry / 'Windows') exists true
	
Linux
    '/var' asFileEntry exists
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists true
    '/media/cdrom' asFileEntry exists false
    '/media/cdrom' asDirectoryEntry exists true
    ('/bin' asDirectoryEntry / 'more') exists false
    ('/bin' asDirectoryEntry // 'more') exists true

MacOsX
    '/var' asFileEntry exists false
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists  true
    '/Volumes/SanDisk32-NTFS' asFileEntry exists false
    '/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
    'SanDisk32-NTFS' asFileEntry exists false
    'SanDisk32-NTFS' asDirectoryEntry exists false
	
	"
	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^FileEntry withPathName: self! !
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 8/1/2018 15:50:23' prior: 16841783!
             entriesIn: parentEntryOrNil
	"
	Warning: Private. Only to be called from within FileMan.
	Accepts nil as argument, but behavior depends on platform.

Windows (nil means root)
FileIOAccessor default entriesIn: nil #(C:\ D:\)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(\$Recycle.Bin \Config.Msi \Documents and Settings \gratMusic \hiberfil.sys \Intel \pagefile.sys \PerfLogs \Program Files \Program Files (x86) \ProgramData \Python27 \Recovery \SimuloHoy \System Volume Information \totalcmd \Users \Windows)

Linux  (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(Lots of stuff in current directory)
(FileIOAccessor default entriesIn: nil) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/vmlinuz /boot /sbin /srv /lib /lib32 /tmp /sys /home /etc /initrd.img /bin /dev /opt /proc /lost+found /var /root /lib64 /mnt /usr /run /media)

MacOsX (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(/Volumes/SanDisk32-NTFS/CuisTest/2554-REVISAR-JuanVuletich-2015Oct21-16h40m-jmv.1.cs.st /Volumes/SanDisk32-NTFS/CuisTest/Cog.app /Volumes/SanDisk32-NTFS/CuisTest/Cog.app.tgz /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.changes /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.image /Volumes/SanDisk32-NTFS/CuisTest/CuisV4.sources)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/.dbfseventsd /.DocumentRevisions-V100 /.DS_Store /.file /.fseventsd /.hotfiles.btree /.Spotlight-V100 /.Trashes /.vol /Applications /bin /cores /dev /etc /home /installer.failurerequests /Library /net /Network /opt /private /sbin /System /tmp /Users /usr /var /Volumes)

	"
	| entries index done entryArray entry isDirectory lookIn |
	entries _ OrderedCollection new: 200.
	index _ 1.
	done _ false.
	lookIn _ parentEntryOrNil ifNil: [''] ifNotNil: [parentEntryOrNil pathName].
	[done] whileFalse: [
		entryArray _ self primLookupEntryIn: lookIn index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^#()].
		entryArray == nil
			ifTrue: [done _ true]
			ifFalse: [
				isDirectory _ entryArray at: 4.
				entry _ isDirectory ifTrue: [DirectoryEntry new] ifFalse: [FileEntry new].
				entry name: (entryArray at: 1) parent: parentEntryOrNil.
				entry updateFrom: entryArray entryInParent: index.
				entries addLast: entry ].
		index _ index + 1].

	^entries asArray! !
!FileSystemEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 16:16:21' prior: 16843927!
                           ensureParent
	self pathComponents isEmpty
		ifTrue: [^ nil].
	parent _ DirectoryEntry
				withPathComponents: (self pathComponents copyFrom: 1 to: self pathComponents size - 1)
				drive: self drive.
	^ parent! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 09:19:11' prior: 16844018!
         refresh
	"Assume we know nothing about current state in the File System.
	This might be because we're just created.
	Or it might be because there is a chance the File System changed and we don't know current state."
	lastSync _ nil.
	exists _ nil.
	creationTime _ nil.
	modificationTime _ nil.! !
!DirectoryEntry methodsFor: 'actions-path' stamp: 'jmv 8/1/2018 16:16:10' prior: 16834409!
                            concatPathComponentsAsDirectory: components
	| entry entryComponents parentEntry |
	components ifEmpty: [ ^self ].
	parentEntry := self isRoot ifFalse: [ self ].
	entryComponents := self pathComponents.

	components do: [ :eachComponent |
		entryComponents := entryComponents copyWith: eachComponent.
		entry := DirectoryEntry withPathComponents: entryComponents drive: self drive.
		parentEntry ifNotNil: [
			entry setParent: parentEntry ].
		parentEntry := entry ].

	^entry! !
!DirectoryEntry methodsFor: 'actions-path' stamp: 'jmv 8/1/2018 16:16:14' prior: 16834427!
    concatPathComponentsAsFile: components

	| entry entryComponents parentEntry |
	components ifEmpty: [ ^self ].
	parentEntry := self isRoot ifFalse: [ self ].
	entryComponents := self pathComponents.

	components allButLast do: [ :eachComponent |
		entryComponents := entryComponents copyWith: eachComponent.
		entry := DirectoryEntry withPathComponents: entryComponents drive: self drive.
		parentEntry ifNotNil: [
			entry setParent: parentEntry ].
		parentEntry := entry ].

	entryComponents := entryComponents copyWith: components last.
	entry := FileEntry withPathComponents: entryComponents drive: self drive.
	parentEntry ifNotNil: [
		entry setParent: parentEntry ].

	^entry! !
!DirectoryEntry class methodsFor: 'instance creation' stamp: 'jmv 8/1/2018 16:17:15' prior: 16834792!
            currentDirectory
	"Answer the current directory.

	In Unix it is the current directory in the OS shell that started us.
	In Windows the same happens if the image file is in a subree of the Windows current directory.

	But it defaults to the directory in wich this Smalltalk image was started (or last saved) if this fails
	(this usually happens, for example, if the image is dropped on the VM in a Windows explorer).
	See #getCurrentWorkingDirectory

	DirectoryEntry currentDirectory
	"

	CurrentDirectory ifNil: [
		CurrentDirectory _ self withPathName: (Smalltalk getCurrentWorkingDirectory ifNil: [ Smalltalk imagePath ]) ].
	^ CurrentDirectory! !
!DirectoryEntry class methodsFor: 'instance creation' stamp: 'jmv 8/1/2018 16:17:17' prior: 16834830!
               smalltalkImageDirectory
	"Answer the directory on which this Smalltalk image was started (or last saved)

	DirectoryEntry smalltalkImageDirectory
	"

	ImageDirectory ifNil: [
		ImageDirectory _ self withPathName: Smalltalk imagePath ].
	^ ImageDirectory! !
!DirectoryEntry class methodsFor: 'instance creation' stamp: 'jmv 8/1/2018 16:17:19' prior: 16834841!
                         vmDirectory
	"Answer the directory containing the VM that runs us.

	DirectoryEntry vmDirectory
	"

	VMDirectory ifNil: [
		VMDirectory _ self withPathName: Smalltalk vmPath ].
	^ VMDirectory! !
!FileEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:19:41' prior: 16841472!
 refresh
	super refresh.
	fileSize _ nil! !

FileSystemEntry class removeSelector: #pathComponents:!

FileSystemEntry class removeSelector: #pathComponents:!

FileSystemEntry class removeSelector: #pathComponents:drive:!

FileSystemEntry class removeSelector: #pathComponents:drive:!

FileSystemEntry class removeSelector: #pathName:!

FileSystemEntry class removeSelector: #pathName:!

FileSystemEntry removeSelector: #basicPathComponents:!

FileSystemEntry removeSelector: #basicPathComponents:!

FileSystemEntry removeSelector: #parent:!

FileSystemEntry removeSelector: #parent:!

FileSystemEntry removeSelector: #pathComponents:!

FileSystemEntry removeSelector: #pathComponents:!

FileSystemEntry removeSelector: #pathComponents:detectDrive:!

FileSystemEntry removeSelector: #pathComponents:detectDrive:!

FileSystemEntry removeSelector: #pathName:!

FileSystemEntry removeSelector: #pathName:!

Object subclass: #FileSystemEntry
	instanceVariableNames: 'drive pathComponents parent name primEntryInParent lastSync exists creationTime modificationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-FileMan-Core'!

!classDefinition: #FileSystemEntry category: #'System-FileMan-Core'!
Object subclass: #FileSystemEntry
	instanceVariableNames: 'drive pathComponents parent name primEntryInParent lastSync exists creationTime modificationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-FileMan-Core'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3386-FileSystemEntry-refactor-JuanVuletich-2018Aug01-17h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3386] on 1 August 2018 at 5:32:47 pm'!
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 8/1/2018 17:11:06'!
          updateEntry: aFileSystemEntry
	| entryArray index lookIn isDirectory |

	"If the index in aFileSystemEntry is valid, use it. No need to iterate over all entries."
	aFileSystemEntry primEntryInParent ifNotNil: [ :tentativeIndex |
		(self primLookupEntryIn: aFileSystemEntry parent pathName index: tentativeIndex) ifNotNil: [ :found |
	 		found == #badDirectoryPath ifFalse: [
				aFileSystemEntry name = (found at: 1) ifTrue: [
					aFileSystemEntry updateFrom: found entryInParent: tentativeIndex.
					^ self ]]]].

	"Otherwise, do a full iteration"
	lookIn _ aFileSystemEntry parent pathName.
	index _ 1.
	[
		entryArray _ self primLookupEntryIn: lookIn index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^ self].
		entryArray == nil ifTrue: [
			^ self].
		isDirectory _ entryArray at: 4.
		aFileSystemEntry name = (entryArray at: 1) ifTrue: [
			isDirectory == aFileSystemEntry isDirectory ifTrue: [
				aFileSystemEntry updateFrom: entryArray entryInParent: index ].
			"If found, exit even if invalid. No point to keep iterating."
			^ self ].
		index _ index + 1] repeat! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 16:56:17'!
                    exists
	self invalidateIfOld.
	exists ifNil: [self updateExists].
	^exists! !
!FileSystemEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 16:28:04'!
           invalidateIfOld

	lastSync isNil ifTrue: [
		^ self invalidate ].
	(DateAndTime now - lastSync) totalSeconds > 2 ifTrue: [
		self invalidate ]! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:27:06'!
                            invalidate
	"Assume we know nothing about current state in the File System.
	This might be because we're just created.
	Or it might be because there is a chance the File System changed and we don't know current state."
	lastSync _ nil.
	exists _ nil.
	creationTime _ nil.
	modificationTime _ nil.! !
!DirectoryEntry methodsFor: 'testing' stamp: 'jmv 8/1/2018 16:55:24'!
              updateExists
	
	| pathName |
	(self fileAccessor isDriveSupported and: [self pathComponents isEmpty])
		 ifTrue: [^ exists _ self fileAccessor drives includes: self ].

	self isRoot ifTrue: [ ^ exists _ true ].
	
	pathName _ self pathName.
	pathName = self fileAccessor slash ifTrue: [ ^ exists _ true ].

	exists _ self fileAccessor basicDirectoryExists: pathName! !
!DirectoryEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:31:30'!
                               invalidate
	"Assume we know nothing about current state in the File System.
	This might be because we're just created.
	Or it might be because there is a chance the File System changed and we don't know current state."
	super invalidate.
	self invalidateChildren! !
!DirectoryEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:31:20'!
     invalidateChildren
	
	children _ nil! !
!FileEntry methodsFor: 'testing' stamp: 'jmv 8/1/2018 16:55:46'!
                       updateExists

	self fileSize "Updates both"! !
!FileEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:27:14'!
     invalidate
	"Assume we know nothing about current state in the File System.
	This might be because we're just created.
	Or it might be because there is a chance the File System changed and we don't know current state."
	super invalidate.
	fileSize _ nil! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 17:13:59' prior: 16843857!
      creationTime
	self invalidateIfOld.
	creationTime ifNil: [self fileAccessor updateEntry: self].
	^creationTime! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 17:01:34' prior: 16843875!
                     modificationTime
	self invalidateIfOld.
	modificationTime ifNil: [self fileAccessor updateEntry: self].
	^modificationTime! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 16:27:50' prior: 50406284!
         name: aString parent: parentEntryOrNil
	name _ aString.
	parentEntryOrNil
		ifNil: [
			self pathString: aString ]
		ifNotNil: [
			parent _ parentEntryOrNil.
			drive _ parentEntryOrNil drive. "harmless if no drive supported, as in Unix"
			pathComponents _ parentEntryOrNil pathComponents copyWith: name ].
	self invalidate! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 16:27:53' prior: 50406308!
                     pathComponents: tokens drive: driveStringOrNil
	| firstToken  |
	tokens isEmptyOrNil ifTrue: [ ^pathComponents _ nil ].
	(driveStringOrNil isNil and: [ (firstToken _ tokens first) isDriveName])
		ifTrue: [
			self drive: firstToken.
			pathComponents _ tokens copyFrom: 2 to: tokens size ]
		ifFalse: [
			self drive: driveStringOrNil.
			pathComponents _ tokens ].

	pathComponents ifNotEmpty: [ name _ pathComponents last ].
	self invalidate! !
!FileSystemEntry class methodsFor: 'class state access' stamp: 'jmv 8/1/2018 16:28:10' prior: 16844063!
                         releaseClassCachedState

	self allSubInstancesDo: [ :each | each invalidate]! !
!DirectoryEntry methodsFor: 'actions-directory' stamp: 'jmv 8/1/2018 16:31:28' prior: 16834541!
                delete
	self fileAccessor deleteDirectory: self pathName.
	self invalidateChildren! !
!DirectoryEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 16:31:26' prior: 16834573!
                    basicRecursiveDelete
	self invalidateChildren.
	self directoriesDo: [:dir | dir basicRecursiveDelete].
	self filesDo: [:file | file delete].
	self delete! !
!DirectoryEntry methodsFor: 'dictionary-like' stamp: 'jmv 8/1/2018 16:31:24' prior: 16834599!
     at: localFileName put: contents

	(self // localFileName) forceWriteStreamDo: [ :stream |
		self setContentsOf: stream to: contents ].
	self invalidateChildren.
	^contents! !
!DirectoryEntry methodsFor: 'dictionary-like' stamp: 'jmv 8/1/2018 16:31:32' prior: 16834639!
                   removeKey: localFileName ifAbsent: failBlock
	self fileAccessor deleteFile: (self // localFileName) pathName ifAbsent: [^failBlock value].
	self invalidateChildren.! !
!DirectoryEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 16:45:23' prior: 16834647!
children
	self invalidateIfOld.
	children ifNil: [self initChildren].
	^children! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 8/1/2018 16:27:36' prior: 16841288!
                      binaryContents: aByteArray
	self forceWriteStreamDo: [ :stream |
		self setContentsOf: stream binary to: aByteArray ].
	self invalidate! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 8/1/2018 16:27:44' prior: 16841337!
                               textContents: aString
	self forceWriteStreamDo: [ :stream |
		self setContentsOf: stream to: aString ].
	self invalidate! !
!FileEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 17:02:21' prior: 16841395!
                 fileSize

	self invalidateIfOld.

	"Slow version."
	"fileSize ifNil: [self fileAccessor updateEntry: self]."

	"Fast version, that asks just for the size of this file.
	Used if I was not created by reading a direcotry"
	fileSize ifNil: [
		fileSize _ self fileAccessor fileSize: self.
		exists _ fileSize notNil ].

	^fileSize! !
!FileEntry methodsFor: 'accessing' stamp: 'jmv 8/1/2018 16:27:47' prior: 16841423!
   writeStream
	"If the file already exists raise FileExistsException.
	Note: You need to eventually close the stream.
	Usually prefer #writeStreamDo: that closes the file for you.
	Creates the directory if it doesn't exist."

	self invalidate.
	self parent exists ifFalse: [self parent assureExistence].
	^self fileAccessor privateNewFile: self! !
!FileEntry methodsFor: 'private' stamp: 'jmv 8/1/2018 16:27:41' prior: 16841436!
                     forceWriteStream
	"If the file already exists, delete it first without asking. Do not raise FileExistsException.
	Note: You need to eventually close the stream.
	Usually prefer #forceWriteStreamDo: that closes the file for you.
	Creates the directory if it doesn't exist."

	self invalidate.
	self parent exists ifFalse: [self parent assureExistence].
	^self fileAccessor privateForceNewFile: self! !

FileEntry removeSelector: #exists!

FileEntry removeSelector: #exists!

FileEntry removeSelector: #fileSize:!

FileEntry removeSelector: #fileSize:!

FileEntry removeSelector: #initValuesFrom:!

FileEntry removeSelector: #initValuesFrom:!

FileEntry removeSelector: #refresh!

FileEntry removeSelector: #refresh!

DirectoryEntry removeSelector: #exists!

DirectoryEntry removeSelector: #exists!

DirectoryEntry removeSelector: #refresh!

DirectoryEntry removeSelector: #refresh!

DirectoryEntry removeSelector: #refreshChildren!

DirectoryEntry removeSelector: #refreshChildren!

FileSystemEntry removeSelector: #creationTime:!

FileSystemEntry removeSelector: #creationTime:!

FileSystemEntry removeSelector: #initValuesFrom:!

FileSystemEntry removeSelector: #initValuesFrom:!

FileSystemEntry removeSelector: #initValuesFromParent!

FileSystemEntry removeSelector: #initValuesFromParent!

FileSystemEntry removeSelector: #modificationTime:!

FileSystemEntry removeSelector: #modificationTime:!

FileSystemEntry removeSelector: #refresh!

FileSystemEntry removeSelector: #refresh!

FileIOAccessor removeSelector: #fileExists:!

FileIOAccessor removeSelector: #fileExists:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3387-FileSystemEntry-autosync-JuanVuletich-2018Aug01-17h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3387] on 1 August 2018 at 5:51:16 pm'!
!CodePackageFile class methodsFor: 'file list services' stamp: 'jmv 8/1/2018 08:49:06' prior: 50369177!
     serviceInstallPackage
	"Answer the service of installing a CodePackageFile (a chunk format file for a CodePackage)"

	^ (SimpleServiceEntry
		provider: self 
		label: 'install package'
		selector: #installPackage:
		description: 'install the package, replacing all existing code in the package (if any); create a new change set just for the installation'
		buttonLabel: 'install package')
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !

CodePackageFile class removeSelector: #installPackageStream:!

CodePackageFile class removeSelector: #installPackageStream:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3388-cleanup-JuanVuletich-2018Aug01-17h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3386] on 1 August 2018 at 6:36:13 pm'!
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 8/1/2018 18:34:46' prior: 50406325!
              pathString: aString
	| tokens |
	tokens _ FileIOAccessor default absolutePathComponentsFor: aString.
	tokens ifEmpty: [^ nil].
	self fileAccessor isDriveSupported
		 ifTrue: [
			tokens first asDriveName ifNotNil: [ :guessedDriveName |
				^ self pathComponents: (tokens copyFrom: 2 to: tokens size) drive: guessedDriveName ]].
	self pathComponents: tokens drive: nil! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3389-keepWindowsDrive-JuanVuletich-2018Aug01-18h34m-jmv.1.cs.st----!

----SNAPSHOT----#(2 August 2018 9:10:58.111269 am) Cuis5.0-3389-v3.image priorSource: 2378279!

----QUIT----#(2 August 2018 9:11:10.946556 am) Cuis5.0-3389-v3.image priorSource: 2413881!

----STARTUP----#(6 August 2018 6:24:48.905512 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3389-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3389] on 2 August 2018 at 4:49:36 pm'!
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 8/2/2018 16:49:19'!
    hasReferencesToInstanceVariableNamed: anInstanceVariableName

	"Returns true if only self has one or more methods referencing anInstanceVariableName - Hernan"

	^(self whichSelectorsAccess: anInstanceVariableName) notEmpty! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 8/2/2018 16:48:53'!
    isInstanceVariableNamedReferencedInHierarchy: anInstanceVariableName

	"Returns true if self or any subclass has one or more methods referencing anInstanceVariableName - Hernan"

	^self withAllSubclasses anySatisfy: [ :aClass | aClass hasReferencesToInstanceVariableNamed: anInstanceVariableName ]! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 8/2/2018 16:03:04' prior: 16784635!
         allUnreferencedInstanceVariables

	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"

	^ self allInstVarNames reject: [ :instanceVariableName | | definingClass |
		definingClass _ self classThatDefinesInstanceVariable: instanceVariableName.
		definingClass isInstanceVariableNamedReferencedInHierarchy: instanceVariableName ]! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 8/2/2018 15:59:42' prior: 16784677!
             unreferencedInstanceVariables
	"Return a list of the instance variables defined in the receiver which are not referenced in the receiver or any of its subclasses

	Object unreferencedInstanceVariables
	"

	^ self instVarNames reject: [ :instanceVariableName | self isInstanceVariableNamedReferencedInHierarchy: instanceVariableName ]
		! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3390-unreferencedIVars-enh-HernanWilkinson-2018Aug02-10h37m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3389] on 2 August 2018 at 8:36:25 pm'!
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 20:19:45'!
classListIndexOf: aClassNameToFind

	"Answer the index of the aClassName selection."

	aClassNameToFind ifNil: [ ^0 ].
	^self listClassesHierarchically 
		ifTrue: [ self classListIndexWhenShowingHierarchicallyOf: aClassNameToFind ]
		ifFalse: [ self classList indexOf: aClassNameToFind ]
! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 20:20:58'!
                          classListIndexWhenShowingHierarchicallyOf: aClassNameToFind

	^self classList findFirst: [ :showingClassName | showingClassName afterBlanksEndsWith: aClassNameToFind  ]
! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:37:45'!
                 createHierarchyTreeOf: col

	"Create a tree from a flat collection of classes"

	| transformed |

	transformed := col collect: [:ea | 
		| childs indexes |
		childs := col select: [:class | class superclass = ea].
		indexes := childs collect: [:child | col indexOf: child].
		ea -> indexes].
	transformed copy do: [:ea |
		ea value: (ea value collect: [:idx | 
			| val |
			val := transformed at: idx.
			transformed at: idx put: nil.
			val])].
	^ transformed select: [:ea | ea notNil].
! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 17:51:43'!
                 defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."

	^selectedSystemCategory
		ifNil: [#()]
		ifNotNil: [systemOrganizer listAtCategoryNamed: selectedSystemCategory]! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:38:01'!
       flattenHierarchyTree: classHierarchy on: col indent: indent

	^ self
		flattenHierarchyTree: classHierarchy
		on: col
		indent: indent
		by: '  '.! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:38:11'!
        flattenHierarchyTree: classHierarchy on: col indent: indent by: indentChars

	"Recursively add to col the names in classHierarchy indenting to show the hierarchical relationship. Use indentChars to do the indenting: spaces, tabs, etc."

	| plusIndent |

	plusIndent := indentChars.
	classHierarchy do: [:assoc |
		| class childs |
		class := assoc key.
		col add: indent , class name.
		childs := assoc value.
		self
			flattenHierarchyTree: childs
			on: col
			indent: indent , plusIndent
			by: indentChars].
	^ col! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:38:37'!
                    hierarchicalClassList

	"classNames are an arbitrary collection of classNames of the system.
	Reorder those class names so that they are sorted and indended by inheritance"

	| classes |

	"Creating the hierarchy is *really slow* for the full class list. Skip it for now."
	selectedSystemCategory = SystemOrganizer allCategory ifTrue: [^ self defaultClassList].		
	classes := self defaultClassList collect: [:sym | Smalltalk classNamed: sym].
	
	^ self
		flattenHierarchyTree: (self createHierarchyTreeOf: classes)
		on: OrderedCollection new
		indent: ''.! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:42:13'!
              listClassesHierarchically 

	^self class listClassesHierarchically ! !
!Browser class methodsFor: 'class list' stamp: 'HAW 8/2/2018 20:25:05'!
                 disableListClassesHierarchically
	
	^Preferences disable: #listClassesHierarchically ! !
!Browser class methodsFor: 'class list' stamp: 'HAW 8/2/2018 20:24:55'!
                               enableListClassesHierarchically
	
	^Preferences enable: #listClassesHierarchically ! !
!Browser class methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:21:34'!
 listClassesHierarchically
	
	^Preferences listClassesHierarchically ! !
!String methodsFor: 'converting' stamp: 'HAW 8/2/2018 20:19:09'!
                       afterBlanksEndsWith: aTail

	^(self endsWith: aTail) and: [self size = aTail size or: [ (self at: self size - aTail size) isSeparator]]
					
	! !
!String methodsFor: 'converting' stamp: 'HAW 8/2/2018 19:11:17'!
            withoutLeadingBlanks
	
	"Return a copy of the receiver from which leading blanks have been trimmed."
	
	| first |
	
	first := self findFirst: [:c | c isSeparator not ].
	first = 0 ifTrue: [^ ''].  
	first = 1 ifTrue: [^ self ].
	
	"no non-separator character"	
	^ self copyFrom: first to: self size
		
	" '    abc  d  ' withoutLeadingBlanks"
! !
!Preferences class methodsFor: 'standard queries'!
                   listClassesHierarchically
	^ self
		valueOfFlag: #listClassesHierarchically
		ifAbsent: [ true ].! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:42:28' prior: 16791804!
         classList

	^ self listClassesHierarchically
		ifTrue: [self hierarchicalClassList]
		ifFalse: [self defaultClassList].! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:42:49' prior: 16791814!
                   classListIndex
	"Answer the index of the current class selection."

	^self classListIndexOf: selectedClassName ! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:35:07' prior: 50390432!
                           classListIndex: anInteger 
	"Set anInteger to be the index of the current class selection."

	| className recent canSelectClass classList |

	classList _ self classList.
	canSelectClass _ classList isInBounds: anInteger.
	selectedClassName _ canSelectClass ifTrue: [	| newClassName |
		newClassName := classList at: anInteger ifAbsent: [ nil ].
		newClassName := newClassName ifNotNil: [newClassName withoutLeadingBlanks asSymbol].
		newClassName ].
	self setClassOrganizer.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	
	self classCommentIndicated ifFalse: [
		self editSelection: (canSelectClass
			ifTrue: [#editClass]
			ifFalse: [ metaClassIndicated | selectedSystemCategory isNil
				ifTrue: [#none]
				ifFalse: [#newClass]])].

	self selectedClass ifNotNil: [
		recent _ self class recentClasses.
		className _ self selectedClass name.
		(recent includes: className) ifTrue: [recent remove: className].
		recent addFirst: className.
		recent size > 16 ifTrue: [recent removeLast]].
	
	"We have to refresh the class list if somebody wants to select a class that does not exist anymore - Hernan"
	anInteger > classList size ifTrue: [ self changed: #classList ].
	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:44:06' prior: 16791874!
                       selectClass: classNotMeta

	self classListIndex: (self classListIndexOf: classNotMeta name)! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/2/2018 19:45:38' prior: 16791888!
               selectedClassName
	"Answer the name of the current class. Answer nil if no selection exists."

	^selectedClassName
	! !
!Browser methodsFor: 'metaclass' stamp: 'HAW 8/2/2018 19:45:57' prior: 16792546!
                       setClassOrganizer

	"Install whatever organization is appropriate"

	| theClass |

	classOrganizer _ nil.
	metaClassOrganizer _ nil.
	selectedClassName ifNil: [^ self].	
	theClass := self selectedClass ifNil: [ ^self ].
	classOrganizer _ theClass organization.
	metaClassOrganizer _ theClass class organization.! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'HAW 8/2/2018 20:06:54' prior: 50390554!
      classListIndex: newIndex

	"Cause system organization to reflect appropriate category"

	| newClassName ind i |

	(classList isInBounds: newIndex) ifTrue: [
		newClassName _ (classList at: newIndex) withoutLeadingBlanks.
		i _ systemOrganizer numberOfCategoryOfElement: newClassName.
		selectedSystemCategory _ i = 0 ifFalse: [ self systemCategoryList at: i]].
	ind _ super classListIndex: newIndex.
	self changed: #systemCategorySingleton.
	^ ind! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'HAW 8/2/2018 20:07:42' prior: 16853583!
                              potentialClassNames
	
	"Answer the names of all the classes that could be viewed in this browser"
	
	^ self classList collect: [:aName | aName withoutLeadingBlanks ]! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'HAW 8/2/2018 20:21:08' prior: 16853590!
                        selectClass: classNotMeta
	
	self classListIndex: (self classListIndexWhenShowingHierarchicallyOf: classNotMeta name)! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'HAW 8/2/2018 20:10:24' prior: 16853600!
        selectedClassName
	"Answer the name of the class currently selected.   di
	  bug fix for the case where name cannot be found -- return nil rather than halt"

	| aName |
	
	aName _ super selectedClassName.
	^ aName ifNotNil: [aName withoutLeadingBlanks asSymbol]! !
!HierarchyBrowser methodsFor: 'class list' stamp: 'HAW 8/2/2018 20:06:27' prior: 16853658!
                            classList

	classList _ classList select: [:each | Smalltalk includesKey: each withoutLeadingBlanks asSymbol].
	^ classList! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 8/2/2018 19:17:40' prior: 16906552!
                               findFirst: aBlock
	"Return the index of my first element for which aBlock evaluates as true."

	| index currentSize |
	
	index _ 0.
	currentSize _ self size.
	
	[(index _ index + 1) <= currentSize ] whileTrue:
		[(aBlock value: (self at: index)) ifTrue: [^index]].
	
	^ 0! !
!String methodsFor: 'converting' stamp: 'HAW 8/2/2018 19:17:01' prior: 16917010!
                            withoutTrailingBlanks
	"Return a copy of the receiver from which trailing blanks have been trimmed."

	| last |
	
	last _ self findLast: [:c | c isSeparator not].
	last = 0 ifTrue: [^ ''].  "no non-separator character"
	last = self size ifTrue: [ ^self ].
	
	^ self copyFrom: 1 to: last

	" ' abc  d   ' withoutTrailingBlanks"
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3391-BrowserListsHierarchically-HernanWilkinson-2018Aug02-16h49m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3389] on 3 August 2018 at 11:18:15 am'!
!String methodsFor: 'converting' stamp: 'HAW 8/3/2018 11:12:15'!
    firstNoBlankIndex 

	^self findFirst: [:aChar | aChar isSeparator not ]! !
!String methodsFor: 'converting' stamp: 'HAW 8/3/2018 11:12:25'!
                    lastNoBlankIndex

	^ self findLast: [:aChar | aChar isSeparator not].
	! !
!String methodsFor: 'converting' stamp: 'HAW 8/3/2018 10:57:30' prior: 50407272!
    afterBlanksEndsWith: aTail

	^(self endsWith: aTail) and: [ self firstNoBlankIndex = (self size - aTail size + 1) ]
! !
!String methodsFor: 'converting' stamp: 'HAW 8/3/2018 11:13:24' prior: 16916886!
                       withBlanksTrimmed
	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."

	| first |
	
	first _ self firstNoBlankIndex.
	first = 0 ifTrue: [^ ''].  "no non-separator character"
	
	^ self copyFrom: first to: self lastNoBlankIndex 

	" ' abc  d   ' withBlanksTrimmed"
! !
!String methodsFor: 'converting' stamp: 'HAW 8/3/2018 11:02:05' prior: 50407279!
                             withoutLeadingBlanks
	
	"Return a copy of the receiver from which leading blanks have been trimmed."
	
	| first |
	
	first := self firstNoBlankIndex.
	first = 0 ifTrue: [^ ''].  
	first = 1 ifTrue: [^ self ].
	
	"no non-separator character"	
	^ self copyFrom: first to: self size
		
	" '    abc  d  ' withoutLeadingBlanks"
! !
!String methodsFor: 'converting' stamp: 'HAW 8/3/2018 11:08:59' prior: 50407452!
        withoutTrailingBlanks
	"Return a copy of the receiver from which trailing blanks have been trimmed."

	| last |
	
	last _ self lastNoBlankIndex.
	last = 0 ifTrue: [^ ''].  "no non-separator character"
	last = self size ifTrue: [ ^self ].
	
	^ self copyFrom: 1 to: last

	" ' abc  d   ' withoutTrailingBlanks"
! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 8/3/2018 11:05:15' prior: 50405790!
   logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString _ aStringOrText asString.
	aString firstNoBlankIndex = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"
			self forceChangesToDisk ]].
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3392-String-cleanup-HernanWilkinson-2018Aug02-20h36m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3389] on 3 August 2018 at 11:45:47 am'!
!Browser methodsFor: 'class list' stamp: 'HAW 8/3/2018 11:45:20' prior: 50407366!
   selectedClassName
	"Answer the name of the current class. Answer nil if no selection exists."

	^selectedClassName ifNotNil: [ 
		"I send #defaultClassList and no #classList because when showing classes hierarchically we should remove spaces to see
		if class name is in the list and that consumes more time - Hernan"
		(self defaultClassList includes: selectedClassName) ifTrue: [ selectedClassName ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3393-Browser-recent-bug-fix-HernanWilkinson-2018Aug03-11h18m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3389] on 3 August 2018 at 2:54:59 pm'!

CodeProvider subclass: #Browser
	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer selectedSystemCategory selectedClassName selectedMessageCategory selectedMessage editSelection metaClassIndicated listClassesHierarchically '
	classVariableNames: 'RecentClasses '
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #Browser category: #'Tools-Browser'!
CodeProvider subclass: #Browser
	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer selectedSystemCategory selectedClassName selectedMessageCategory selectedMessage editSelection metaClassIndicated listClassesHierarchically'
	classVariableNames: 'RecentClasses'
	poolDictionaries: ''
	category: 'Tools-Browser'!
!Browser methodsFor: 'class list' stamp: 'HAW 8/3/2018 12:29:41'!
    enableListClassesAlphabetically

	self listClassesHierarchically: false! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/3/2018 12:29:30'!
                   enableListClassesHierarchically

	self listClassesHierarchically: true! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/3/2018 14:49:36'!
                    listClassesHierarchically: aBoolean

	listClassesHierarchically := aBoolean.
	
	self changed: #classList.
	self changed: #classListIndex.
! !
!Browser methodsFor: 'initialization' stamp: 'HAW 8/3/2018 14:51:55'!
            initialize

	super initialize.
	self initializeListClassesHierachically! !
!Browser methodsFor: 'initialization' stamp: 'HAW 8/3/2018 14:51:47'!
               initializeListClassesHierachically

	listClassesHierarchically _ self class listClassesHierarchically ! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 8/3/2018 11:59:30'!
            createClassButton

	| classSwitch |
	
	classSwitch := PluggableButtonMorph 
		model: model
		stateGetter: #classMessagesIndicated
		action: #indicateClassMessages.
	
	classSwitch
		label: 'class';
		setBalloonText: 'show class methods'.
		
	^classSwitch! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 8/3/2018 11:59:41'!
                     createCommentButton

	|  commentSwitch  |
	
	commentSwitch := PluggableButtonMorph 
		model: model
		stateGetter: #classCommentIndicated
		action: #plusButtonHit.
				
	commentSwitch 
		label: '?';
		setBalloonText: 'show class comment'.
		
	^commentSwitch ! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 8/3/2018 11:59:22'!
                 createInstanceButton

	| instanceSwitch |
	
	instanceSwitch := PluggableButtonMorph 
		model: model
		stateGetter: #instanceMessagesIndicated
		action: #indicateInstanceMessages.

	instanceSwitch 
		label: 'instance';
		setBalloonText: 'show instance methods'.

	^instanceSwitch ! !
!Browser methodsFor: 'class list' stamp: 'HAW 8/3/2018 14:52:35' prior: 50407251!
                   listClassesHierarchically 

	"I check for nil to support migration on already opened browser when the change is loaded in image - Hernan"
	^listClassesHierarchically ifNil: [ self initializeListClassesHierachically]! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 8/3/2018 14:54:25' prior: 16793097!
           buildMorphicSwitches

	| instanceSwitch commentSwitch classSwitch row buttonColor |
	
	instanceSwitch _ self createInstanceButton.
	commentSwitch _ self createCommentButton.
	classSwitch _ self createClassButton.
	
	row _ LayoutMorph newRow.
	row
		doAdoptWidgetsColor;
		addMorph: instanceSwitch proportionalWidth: 0.45;
		addMorph: commentSwitch proportionalWidth: 0.22;
		addMorph: classSwitch proportionalWidth: 0.33.
	buttonColor _ self buttonColor.
	row color: buttonColor.

	{ 
		instanceSwitch.
		commentSwitch.
		classSwitch} do: [:m |  m color: buttonColor ].
		
	^row! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 8/3/2018 14:47:08' prior: 50403114!
                        classListMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutClass.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		5.
				#label 			-> 		'show classes hierarchically'.
				#object 			-> 		#model.
				#selector 		-> 		#enableListClassesHierarchically.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		6.
				#label 			-> 		'show classes alphabetically'.
				#object 			-> 		#model.
				#selector 		-> 		#enableListClassesAlphabetically.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'show hierarchy'.
				#object 			-> 		#model.
				#selector 		-> 		#hierarchy.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'show definition'.
				#object 			-> 		#model.
				#selector 		-> 		#editClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'show comment'.
				#object 			-> 		#model.
				#selector 		-> 		#editComment.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'class vars'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class ...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'copy class...'.
				#object 			-> 		#model.
				#selector 		-> 		#copyClass.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runClassTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		70.
				#itemOrder 		-> 		20.
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !

HierarchyBrowserWindow removeSelector: #buildMorphicSwitches!

BrowserWindow removeSelector: #createListClassesAlphabetically!

BrowserWindow removeSelector: #createListClassesAlphabeticallyButton!

BrowserWindow removeSelector: #createListClassesHierarchically!

BrowserWindow removeSelector: #createListClassesHierarchicallyButton!

Browser removeSelector: #listClassesAlphabetically!

CodeProvider subclass: #Browser
	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer selectedSystemCategory selectedClassName selectedMessageCategory selectedMessage editSelection metaClassIndicated listClassesHierarchically'
	classVariableNames: 'RecentClasses'
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #Browser category: #'Tools-Browser'!
CodeProvider subclass: #Browser
	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer selectedSystemCategory selectedClassName selectedMessageCategory selectedMessage editSelection metaClassIndicated listClassesHierarchically'
	classVariableNames: 'RecentClasses'
	poolDictionaries: ''
	category: 'Tools-Browser'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3394-BrowserShowHierarchically-perBrowserOption-HernanWilkinson-2018Aug03-11h45m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3394] on 4 August 2018 at 2:48:52 pm'!
!Browser methodsFor: 'class list' stamp: 'jmv 8/4/2018 14:48:21' prior: 50407157!
     classListIndexOf: aClassNameToFind

	"Answer the index of the aClassName selection."

	aClassNameToFind ifNil: [ ^0 ].
	^self classList findFirst: [ :showingClassName |
		"Works regardless of currently showing hierarchically or alphabetically."
		showingClassName afterBlanksEndsWith: aClassNameToFind  ]! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'jmv 8/4/2018 14:48:30' prior: 50407413!
             selectClass: classNotMeta
	
	self classListIndex: (self classListIndexOf: classNotMeta name)! !

Browser removeSelector: #classListIndexWhenShowingHierarchicallyOf:!

Browser removeSelector: #classListIndexWhenShowingHierarchicallyOf:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3395-SlightSimplification-JuanVuletich-2018Aug04-14h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3395] on 4 August 2018 at 3:59:49 pm'!

Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom transformations currentTransformation cti currentMorph drawingMorphStack '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #MorphicCanvas category: #'Morphic-Support'!
Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom transformations currentTransformation cti currentMorph drawingMorphStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 8/4/2018 15:46:00' prior: 16877545!
   into: aMorph
	| location previousLast |
	location _ aMorph location.
	drawingMorphStack ifNil: [ drawingMorphStack _ transformations collect: [ :t | nil ]].
	drawingMorphStack size = transformations size ifFalse:  [ drawingMorphStack _ transformations collect: [ :t | nil ]].
	currentMorph _ aMorph.
	cti _ cti + 1.
	transformations size < cti
		ifTrue: [
			drawingMorphStack add: aMorph.
			currentTransformation _ currentTransformation composedWith: location.
			transformations add: currentTransformation ]
		ifFalse: [
			drawingMorphStack at: cti put: aMorph.
			previousLast _ currentTransformation.
			currentTransformation _ transformations at: cti.
			"reuse the instance if possible"
			(previousLast class == location class and: [ previousLast class == currentTransformation class ])
				ifTrue: [
					previousLast composedWith: location into: currentTransformation ]
				ifFalse: [
					currentTransformation _ previousLast composedWith: location.
					transformations at: cti put: currentTransformation ]]! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 8/4/2018 15:58:56' prior: 16877580!
           outOfMorph

	drawingMorphStack at: cti put: nil.			"Don't hold any morphs that could be collected"
	cti _ cti - 1.
	currentTransformation _ transformations at: cti.
"	currentMorph _ drawingMorphStack at: cti"
	currentMorph _ currentMorph owner! !
!MorphicCanvas methodsFor: 'initialization' stamp: 'jmv 8/4/2018 15:37:46' prior: 16877585!
             initializeWith: aForm origin: aPoint
	self initialize.
	self setForm: aForm.

	"We currently set up these only on initialization.
	This is safe (wrt walkbacks during world redraw) because a new instance is created
	each time the world is redrawn. See #drawInvalidAreasWorld:submorphs:
	Maybe this cleanup should be in an aux method that can be called each time on an existing instance..."
	currentTransformation _ MorphicTranslation withTranslation: aPoint.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollection with: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ].
	drawingMorphStack
		ifNil: [ drawingMorphStack _ OrderedCollection with: nil ]
		ifNotNil: [ drawingMorphStack at: cti put: nil ].! !

MorphicCanvas removeSelector: #intoLocation:!

MorphicCanvas removeSelector: #intoLocation:!

MorphicCanvas removeSelector: #outOfLocation!

MorphicCanvas removeSelector: #outOfLocation!

Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom transformations currentTransformation cti currentMorph drawingMorphStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #MorphicCanvas category: #'Morphic-Support'!
Object subclass: #MorphicCanvas
	instanceVariableNames: 'form clipLeft clipTop clipRight clipBottom transformations currentTransformation cti currentMorph drawingMorphStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
MorphicCanvas allSubInstancesDo: [ :each | each instVarNamed: 'drawingMorphStack' put: ((each instVarNamed: 'transformations') collect: [ :t | nil])].!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3396-MoreRobustCanvas-JuanVuletich-2018Aug04-15h58m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3395] on 4 August 2018 at 4:01:01 pm'!
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 8/4/2018 16:00:30' prior: 50407920!
            into: aMorph
	| location previousLast |
	location _ aMorph location.
	currentMorph _ aMorph.
	cti _ cti + 1.
	transformations size < cti
		ifTrue: [
			drawingMorphStack add: aMorph.
			currentTransformation _ currentTransformation composedWith: location.
			transformations add: currentTransformation ]
		ifFalse: [
			drawingMorphStack at: cti put: aMorph.
			previousLast _ currentTransformation.
			currentTransformation _ transformations at: cti.
			"reuse the instance if possible"
			(previousLast class == location class and: [ previousLast class == currentTransformation class ])
				ifTrue: [
					previousLast composedWith: location into: currentTransformation ]
				ifFalse: [
					currentTransformation _ previousLast composedWith: location.
					transformations at: cti put: currentTransformation ]]! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 8/4/2018 16:00:39' prior: 50407955!
                          outOfMorph

	drawingMorphStack at: cti put: nil.			"Don't hold any morphs that could be collected"
	cti _ cti - 1.
	currentTransformation _ transformations at: cti.
	currentMorph _ drawingMorphStack at: cti! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3397-MoreRobustCanvas-JuanVuletich-2018Aug04-15h59m-jmv.1.cs.st----!

----SNAPSHOT----#(6 August 2018 6:24:55.336826 pm) Cuis5.0-3397-v3.image priorSource: 2413977!

----QUIT----#(6 August 2018 6:25:12.899278 pm) Cuis5.0-3397-v3.image priorSource: 2445720!

----STARTUP----#(9 August 2018 6:35:06.413916 pm) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3397-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3397] on 9 August 2018 at 10:46:43 am'!
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 8/9/2018 10:41:27' prior: 16834451!
                               allChildrenDo: aBlock
	self childrenDo: [ :child | 
		aBlock value: child ].
	self allDirectoriesDo: [ :child |
		child allChildrenDo: aBlock]! !
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 8/9/2018 10:45:45' prior: 50405928!
                    withPackageSubfoldersOf: aDirectoryEntry do: aBlock

	"Look in the requested directory"
	aBlock value: aDirectoryEntry.

	"Look in ./Packages/ and subfolders"
	aDirectoryEntry / 'Packages' ifExists: [ :packagesFolder |
		aBlock value: packagesFolder.
		packagesFolder allDirectoriesDo: aBlock ]! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3398-PackageFolderReorganization-JuanVuletich-2018Aug09-09h22m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3398] on 9 August 2018 at 11:45:19 am'!

GeometryTransformation variableWordSubclass: #AffineTransformation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #AffineTransformation category: #'Graphics-Primitives'!
GeometryTransformation variableWordSubclass: #AffineTransformation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

GeometryTransformation variableWordSubclass: #Homography
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #Homography category: #'Graphics-Primitives'!
GeometryTransformation variableWordSubclass: #Homography
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!Homography commentStamp: '<historical>' prior: 0!
                              An homography (or perspective transformation) for resampling images (for example). Can apply or correct for the perspective resulting from taking a photograph to a 2D object that is not perpendicular to the camera axis (for example, taking an image of the ground ahead of the camera).

http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpperspective

To be of use, needs #map:to: in NumCuis/ImageProcessing.pck.st!

GeometryTransformation subclass: #MorphicTranslation
	instanceVariableNames: 'deltaX deltaY '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #MorphicTranslation category: #'Graphics-Primitives'!
GeometryTransformation subclass: #MorphicTranslation
	instanceVariableNames: 'deltaX deltaY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!Morph commentStamp: '<historical>' prior: 16873905!
             A Morph (from the Greek "shape" or "form") is an interactive graphical object. General information on the Morphic system can be found at http://wiki.squeak.org/squeak/morph. 

Morphs exist in a tree, rooted at a World (generally a PasteUpMorph). The morphs owned by a morph are its submorphs. Morphs are drawn recursively; if a Morph has no owner it never gets drawn. To hide a Morph and its submorphs, set its #visible property to false using the #visible: method. 

Structure:
instance var 	Type 						Description 
owner 		Morph		 				My parent Morph, or nil for the top-level Morph, which is a
 				or nil						world, typically a PasteUpMorph.
submorphs 	Array 						My child Morphs. 
location 		MorphicTranslation 		Specifies position (and possibly, angle of rotation and scale change) inside owner
				or AffineTransformation	
extension 	MorphExtension 			Allows extra properties to be stored without adding a
				or nil  						storage burden to all morphs. 
!
!GeometryTransformation methodsFor: 'testing' stamp: 'jmv 8/9/2018 11:25:47'!
            is: aSymbol
	^aSymbol == #GeometryTransformation or: [ super is: aSymbol ]! !
!GeometryTransformation methodsFor: 'testing' stamp: 'jmv 8/9/2018 11:27:48'!
    isPureTranslation
	"Return true if the receiver specifies no rotation or scaling."
	^false! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
                         a0
	^self at: 1! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
    a1
	^self at: 2! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
    a2
	^self at: 3! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
    b0
	^self at: 4! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
    b1
	^self at: 5! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
    b2
	^self at: 6! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
    c0
	^self at: 7! !
!Homography methodsFor: 'element access' stamp: 'jmv 8/9/2018 11:22:18'!
    c1
	^self at: 8! !
!Homography methodsFor: 'private access' stamp: 'jmv 8/9/2018 11:22:18'!
    at: index
	<primitive: 'primitiveAt' module: 'FloatArrayPlugin'>
	^Float fromIEEE32Bit: (self basicAt: index)! !
!Homography methodsFor: 'private access' stamp: 'jmv 8/9/2018 11:22:18'!
      at: index put: value
	<primitive: 'primitiveAtPut' module: 'FloatArrayPlugin'>
	value isFloat 
		ifTrue:[self basicAt: index put: value asIEEE32BitWord]
		ifFalse:[self at: index put: value asFloat].
	^value! !
!Homography methodsFor: 'converting coordinates' stamp: 'jmv 8/9/2018 11:22:18'!
                            map: aPoint
	| xx yy zz |
	xx _ (self a0 * aPoint x) + (self a1 * aPoint y) + self a2.
	yy _ (self b0 * aPoint x) + (self b1 * aPoint y) + self b2.
	zz _ (self c0 * aPoint x) + (self c1 * aPoint y) + 1.
	^(xx / zz) @ (yy / zz)! !
!Homography class methodsFor: 'instance creation' stamp: 'jmv 8/9/2018 11:22:18'!
        new
	^(self basicNew: 8) initialize! !
!Homography class methodsFor: 'instance creation' stamp: 'jmv 8/9/2018 11:23:34'!
       new: s
	self error: 'Please call Homography>>#new (without arguments).'.
	^self new! !
!MorphicTranslation methodsFor: 'comparing' stamp: 'jmv 8/9/2018 11:26:07' prior: 16878311!
             = aMorphicTranslation
	self == aMorphicTranslation ifTrue: [ ^ true ].
	(aMorphicTranslation is: #GeometryTransformation) ifFalse: [ ^false ].
	aMorphicTranslation isPureTranslation ifFalse: [ ^false ].
	^self translation = aMorphicTranslation translation! !

Homography class removeSelector: #map:to:!

GeometryTransformation subclass: #MorphicTranslation
	instanceVariableNames: 'deltaX deltaY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #MorphicTranslation category: #'Graphics-Primitives'!
GeometryTransformation subclass: #MorphicTranslation
	instanceVariableNames: 'deltaX deltaY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

Smalltalk removeClassNamed: #MorphicLocation!

Smalltalk removeClassNamed: #MorphicLocation!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3399-GeometryTransformation-refactor-JuanVuletich-2018Aug09-11h38m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3399] on 9 August 2018 at 1:17:11 pm'!
!Form methodsFor: 'pixel access' stamp: 'jmv 8/8/2018 14:17:49'!
                        i: i j: j
	"Compatibility with Matrices"
	^ self colorAt: j@i -1! !
!Form methodsFor: 'pixel access' stamp: 'jmv 8/8/2018 14:18:01'!
                           i: i j: j put: aColor
	"Compatibility with Matrices"
	^ self colorAt: j@i -1 put: aColor! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3400-Form-MatrixCompatibleElementAccess-JuanVuletich-2018Aug09-12h40m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3400] on 9 August 2018 at 6:13:10 pm'!
!Form methodsFor: 'displaying' stamp: 'jmv 8/9/2018 16:23:10'!
            displayAutoRangeAt: aPoint
	"Display receiver, mapping used range to available gray levels"

	^ self displayAutoRangeAt: aPoint zoom: 1! !
!Form methodsFor: 'displaying' stamp: 'jmv 8/9/2018 16:22:37'!
                      displayAutoRangeAt: aPoint zoom: scale
	"Display receiver, compatibility with Matrix and subclasses such as FloatImage"

	| form |
	form _ self.
	scale = 1 ifFalse: [
		form _ form magnifyBy: scale ].
	form displayAt: aPoint.
	^ form! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3401-Form-MatrixCompatibleDisplay-JuanVuletich-2018Aug09-16h22m-jmv.1.cs.st----!

----SNAPSHOT----#(9 August 2018 6:35:14.108338 pm) Cuis5.0-3401-v3.image priorSource: 2445816!

----QUIT----#(9 August 2018 6:35:26.927056 pm) Cuis5.0-3401-v3.image priorSource: 2454532!

----STARTUP----#(15 August 2018 3:59:23.282491 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3401-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3401] on 10 August 2018 at 11:07:42 am'!
!SinglePackageBrowser methodsFor: 'lists' stamp: 'jmv 8/10/2018 11:05:40'!
     defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	| answer |
	answer _ selectedSystemCategory
		ifNil: [#()]
		ifNotNil: [
			(package includesSystemCategory: selectedSystemCategory)
				ifTrue: [ systemOrganizer listAtCategoryNamed: selectedSystemCategory ]
				ifFalse: [ 
					package extensionClassNamesIn: (selectedSystemCategory copyFrom: 2 to: selectedSystemCategory size) ]].
	selectedClassName ifNil: [
		answer size = 0 ifFalse: [
			selectedClassName _ answer first.
			self setClassOrganizer.
			self editSelection: #editClass ]].
	^answer! !

SinglePackageBrowser removeSelector: #classList!

SinglePackageBrowser removeSelector: #classList!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3402-PackageBrowser-fix-JuanVuletich-2018Aug10-11h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3402] on 10 August 2018 at 4:45:43 pm'!
!Form methodsFor: 'converting' stamp: 'jmv 8/10/2018 15:19:49'!
                            asFormAutoRange
	"In optional packages (LinearAlgebra, ImageProcessing) we might have #asFormAutoRange
	 conversion methods for other kinds of objects."
	^self! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3403-asFormAutoRange-JuanVuletich-2018Aug10-15h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 12 August 2018 at 11:35:10 pm'!
!CompiledMethod methodsFor: 'comparing' stamp: 'jmv 8/12/2018 23:31:38' prior: 50334684!
 = method
	| numLits lit1 lit2 firstLitIndex |

	"Any object is equal to itself"
	self == method ifTrue: [ ^ true ].

	"Answer whether the receiver implements the same code as the 
	argument, method."
	(method is: #CompiledMethod) ifFalse: [ ^false ].
	self size = method size ifFalse: [ ^false ].
	self header = method header ifFalse: [ ^false ].
	self initialPC to: self endPC do: [ :i |
		(self at: i) = (method at: i) ifFalse: [ ^false ]].
	(numLits _ self numLiterals) ~= method numLiterals ifTrue: [ ^false ].

	"Dont bother checking FFI and named primitives''
	jmv: Does this make any sense?
	 (#(117 120) includes: self primitive) ifTrue: [^ true]."

	 "properties"
	(self properties analogousCodeTo: method properties) ifFalse: [
		^false  ].

	firstLitIndex _ 1.
	(#(117 120) includes: self primitive) ifTrue: [
		lit1 _ self literalAt: firstLitIndex.
		lit2 _ method literalAt: firstLitIndex.
			lit1 isArray
				ifTrue: [
					(lit2 isArray and: [ lit1 first = lit2 first and: [lit1 second = lit2 second]]) ifFalse: [
						^false ]]
				ifFalse: [ "ExternalLibraryFunction"
					(lit1 analogousCodeTo: lit2) ifFalse: [
						^false ]].
		firstLitIndex _ 2 ].

	"#penultimateLiteral is selector (or properties, just compared, above)
	Last literal is #methodClass.
	Don't compare them. Two methods might be equal even if they have different selector (or none at all)
	or are installed in different classes (or none at all)"
	firstLitIndex to: numLits-2 do: [ :i |
		lit1 _ self literalAt: i.
		lit2 _ method literalAt: i.
		lit1 = lit2 ifFalse: [
			"any other discrepancy is a failure"
			^ false ]].
	^true! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 8/12/2018 21:36:15' prior: 50391827!
            xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	[ | compiler method methodNode |
		compiler _ Compiler new.
		methodNode _ compiler compileNoPattern: buffer contents in: UndefinedObject context: nil notifying: nil ifFail: [].
		method _ methodNode generate.
		"Grab all messages sent while evaluating literal, so the main method will be shown as senders of them"
		sentInLiterals addAll: method messages.
		method literalsDo: [ :literal | literal isSymbol ifTrue: [ literal = #DoIt ifFalse: [sentInLiterals add: literal ]]].
		"Evaluate now."
		token _ nil withArgs: #() executeMethod: method.
	] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !
!Encoder methodsFor: 'results' stamp: 'jmv 8/12/2018 22:28:05' prior: 16837182!
     allLiterals
	addedSelectorAndMethodClassLiterals ifFalse:
		[addedSelectorAndMethodClassLiterals := true.
		"Put the optimized selectors in literals so as to browse senders more easily"
		optimizedSelectors := optimizedSelectors reject: [:e| literalStream originalContents hasLiteral: e].
		optimizedSelectors isEmpty ifFalse: [
			"Use one entry per literal if enough room, else make anArray"
			literalStream position + optimizedSelectors size + 2 >= self maxNumLiterals
				ifTrue: [self litIndex: optimizedSelectors asArray sort]
				ifFalse: [optimizedSelectors sorted do: [:e | self litIndex: e]]].
		"Add a slot for selector or MethodProperties"
		self litIndex: nil.
		self litIndex: self associationForClass].
	^literalStream contents! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
ProtoObject withAllSubclasses do: [:c | c compileAll ].!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3404-ThreeCompiledMethodBugFixes-JuanVuletich-2018Aug12-23h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3404] on 15 August 2018 at 3:42:44 pm'!
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 8/15/2018 15:42:06' prior: 16865939!
  activateSubmenu: evt
	"Activate our submenu; e.g., pass control to it"
	subMenu ifNil: [ ^false ]. "not applicable"
	(subMenu morphContainsPoint: (subMenu internalizeFromWorld: evt eventPosition)) ifFalse:[^false].
	subMenu activate: evt.
	^true! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 8/15/2018 15:41:44' prior: 50341137!
               deselect

	self isSelected: false.
	subMenu ifNotNil: [
		owner ifNotNil: [ owner activeSubmenu: nil ]]! !

MenuItemMorph removeSelector: #deselectTimeOut!

MenuItemMorph removeSelector: #deselectTimeOut!

MenuItemMorph removeSelector: #mouseLeave:!

MenuItemMorph removeSelector: #mouseLeave:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3405-MenuFix-JuanVuletich-2018Aug15-15h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 7:33:37 pm'!

ParseNode subclass: #MessageNode
	instanceVariableNames: 'receiver selector precedence special arguments sizes equalNode caseErrorNode originalReceiver originalSelector originalArguments keywordRanges '
	classVariableNames: 'MacroEmitters MacroPrinters MacroSelectors MacroSizers MacroTransformers '
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

!classDefinition: #MessageNode category: #'Compiler-ParseNodes'!
ParseNode subclass: #MessageNode
	instanceVariableNames: 'receiver selector precedence special arguments sizes equalNode caseErrorNode originalReceiver originalSelector originalArguments keywordRanges'
	classVariableNames: 'MacroEmitters MacroPrinters MacroSelectors MacroSizers MacroTransformers'
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

ParseNode subclass: #MethodNode
	instanceVariableNames: 'selectorOrFalse precedence arguments block primitive encoder temporaries properties sourceText locationCounter localsPool selectorKeywordsRanges '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

!classDefinition: #MethodNode category: #'Compiler-ParseNodes'!
ParseNode subclass: #MethodNode
	instanceVariableNames: 'selectorOrFalse precedence arguments block primitive encoder temporaries properties sourceText locationCounter localsPool selectorKeywordsRanges'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!
!CodeProvider methodsFor: 'message list menu' stamp: 'HAW 8/11/2018 18:52:25'!
              inspectCompiledMethod
	"Open an Inspector on the CompiledMethod itself"

	self selectedMessageName ifNotNil: [
		(self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)
			inspect ]! !
!Behavior methodsFor: 'methods' stamp: 'HAW 8/11/2018 18:49:25'!
                   methodNodeFor: aSourceCode

	|  parser methodNode |

	parser := self parserClass new
		encoderClass: EncoderForV3PlusClosures;
		yourself.
		
	methodNode := parser parse: aSourceCode class: self.
	methodNode sourceText: aSourceCode.
	
	^methodNode
			! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 8/11/2018 19:00:35'!
                               isInstanceVariableNode

	^false! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 8/11/2018 19:26:31'!
                           isMessageNamed: aSelector

	^ false! !
!Encoder methodsFor: 'temps' stamp: 'HAW 8/11/2018 19:09:30'!
                           bindArg: aName range: aRange
 
	^ self addMultiRange: aRange for: (self bindArg: aName)
! !
!Encoder methodsFor: 'temps' stamp: 'HAW 8/11/2018 19:13:38'!
      bindTemp: aName range: aRange

	^ self addMultiRange: aRange for: (self bindTemp: aName)! !
!Encoder methodsFor: 'encoding' stamp: 'HAW 8/11/2018 19:14:52'!
   encodeLiteral: object range: aRange

	^ self addMultiRange: aRange for: (self encodeLiteral: object)! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 19:11:31'!
                 addMultiRange: aRange for: aNode

	| ranges |
	
	"I'm using an OrderedCollection because ranges are added in order, while parsing the source code.
	If this constrain is not hold, a SortedCollection should be used - Hernan"
	ranges := sourceRanges at: aNode ifAbsentPut: [ OrderedCollection new ].
	ranges add: aRange.
	
	^aNode ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 19:30:24'!
             messageSendSelectorKeywordRangesOf: aSelector ifAbsent: aBlock
	
	| ranges sortedRanges |
	
	ranges := sourceRanges keys 
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ] 
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordRanges ].
		
	ranges isEmpty ifTrue: [ ^aBlock value ].
	sortedRanges := ranges asSortedCollection: [ :left :right | left first first < right first first ].
	
	^sortedRanges ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 18:59:11'!
              rangesForInstanceVariable: aName ifAbsent: aBlock

	^ self 
		rangesForVariable: aName 
		checkingType: [ :variableNode | variableNode isInstanceVariableNode ]
		ifAbsent: aBlock ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 18:59:25'!
  rangesForTemporaryVariable: aName ifAbsent: aBlock

	^ self 
		rangesForVariable: aName 
		checkingType: [ :variableNode | variableNode isTemp ]
		ifAbsent: aBlock ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 18:58:07'!
                 rangesForVariable: aName checkingType: nodeTypeCheckBlock ifAbsent: anAbsentBlock

	| variableNode |
	
	variableNode := scopeTable at: aName ifAbsent: [ ^anAbsentBlock value ].
	(nodeTypeCheckBlock value: variableNode) ifFalse: [ ^anAbsentBlock value ].
	
	^sourceRanges at: variableNode ifAbsent: anAbsentBlock ! !
!InstanceVariableNode methodsFor: 'testing' stamp: 'HAW 8/11/2018 19:00:19'!
                       isInstanceVariableNode

	^true! !
!MessageNode methodsFor: 'source ranges' stamp: 'HAW 8/11/2018 19:24:24'!
                    keywordRanges

	^keywordRanges! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 8/11/2018 19:23:56'!
                          isMessageNamed: aSelector

	^aSelector == selector key! !
!MessageNode methodsFor: 'initialization' stamp: 'HAW 8/11/2018 19:21:33'!
                           receiver: aReceiver selector: aSelector arguments: args precedence: aPrecedence from: anEncoder sourceRange: aSourceRange keywordsRanges: wordsRanges
	
	keywordRanges := wordsRanges.
	
	^self receiver: aReceiver selector: aSelector arguments: args precedence: aPrecedence from: anEncoder sourceRange: aSourceRange ! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 19:01:49'!
                        rangesForInstanceVariable: aName ifAbsent: aBlock

	^encoder rangesForInstanceVariable: aName ifAbsent: aBlock
! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 19:01:59'!
   rangesForTemporaryVariable: aName ifAbsent: aBlock

	^encoder rangesForTemporaryVariable: aName ifAbsent: aBlock
! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 8/11/2018 19:06:30'!
 selectorKeywordsRanges

	^selectorKeywordsRanges! !
!MethodNode methodsFor: 'initialization' stamp: 'HAW 8/11/2018 19:27:21'!
  selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict selectorKeywordsRanges: range
	
	selectorKeywordsRanges := range.
	
	^self selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict ! !
!CompiledMethod methodsFor: 'decompiling' stamp: 'HAW 8/11/2018 18:50:26' prior: 16820711!
    methodNode
	"Return the parse tree that represents self"
	
	| aClass source |
	
	aClass := self methodClass.
	source := self
				getSourceFor: (self selector ifNil: [self defaultSelector])
				in: aClass.
				
	^ aClass methodNodeFor: source
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 8/11/2018 18:51:50' prior: 50403373!
      messageListMenuOptions
	
	^`{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'what to show...'.
				#selector 		-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'browse method (O)'.
				#selector 		-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect CompiledMethod'.
				#object 			-> 		#model.
				#selector 		-> 		#inspectCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'senders of... (n)'.
				#selector 		-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'implementors of... (m)'.
				#selector 		-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'inheritance (i)'.
				#selector 		-> 		#methodHierarchy.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'versions (v)'.
				#selector 		-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'class variables'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'run test (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'debug test (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !

CodeProvider removeSelector: #exploreCompiledMethod!

CodeProvider removeSelector: #exploreCompiledMethod!

ParseNode subclass: #MessageNode
	instanceVariableNames: 'receiver selector precedence special arguments sizes equalNode caseErrorNode originalReceiver originalSelector originalArguments keywordRanges'
	classVariableNames: 'MacroEmitters MacroPrinters MacroSelectors MacroSizers MacroTransformers'
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

!classDefinition: #MessageNode category: #'Compiler-ParseNodes'!
ParseNode subclass: #MessageNode
	instanceVariableNames: 'receiver selector precedence special arguments sizes equalNode caseErrorNode originalReceiver originalSelector originalArguments keywordRanges'
	classVariableNames: 'MacroEmitters MacroPrinters MacroSelectors MacroSizers MacroTransformers'
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

ParseNode subclass: #MethodNode
	instanceVariableNames: 'selectorOrFalse precedence arguments block primitive encoder temporaries properties sourceText locationCounter localsPool selectorKeywordsRanges'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

!classDefinition: #MethodNode category: #'Compiler-ParseNodes'!
ParseNode subclass: #MethodNode
	instanceVariableNames: 'selectorOrFalse precedence arguments block primitive encoder temporaries properties sourceText locationCounter localsPool selectorKeywordsRanges'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-ParseNodes'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3406-ParserEnhancements-HernanWilkinson-2018Aug11-18h49m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 7:59:09 pm'!
!Parser methodsFor: 'scanning' stamp: 'HAW 8/11/2018 19:36:55'!
 advanceWithRangeDo: aBlock

	| lexema start end |
	
	start := self startOfNextToken + requestorOffset.
	lexema := self advance.
	end _ self endOfLastToken + requestorOffset.
	
	^ aBlock value: lexema value: (start to: end)! !
!Parser methodsFor: 'temps' stamp: 'HAW 8/11/2018 19:45:20'!
 bindArg: aName range: aRange

	^ self bindArg: aName! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 19:48:40' prior: 16886084!
                messagePart: level repeat: repeat

	| start receiver selector args precedence words keywordStart |
	
	[receiver := parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: 
			[start := self startOfNextToken.
			selector := WriteStream on: (String new: 32).
			args := OrderedCollection new.
			words := OrderedCollection new.
			[hereType == #keyword]
				whileTrue: 
					[keywordStart := self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])
				ifFalse: [ selector := self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ].
			precedence := 3]
		ifFalse: [
			
			(level >= 2 and: [hereType == #verticalBar or: [hereType == #upArrow]]) ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].
			((hereType == #binary )
				and: [level >= 2])
				ifTrue: 
					[start := self startOfNextToken.
					selector := self advance asSymbol.
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args := Array with: parseNode.
					precedence := 2]
				ifFalse: [hereType == #word
						ifTrue: 
							[start := self startOfNextToken.
							selector := self advance.
							args := #().
							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])
								ifFalse: [ selector := self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ].
							precedence := 1]
						ifFalse: [^args notNil]]].

	parseNode := MessageNode new
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken)
				keywordsRanges: words.
	repeat]
		whileTrue: [].
	^true! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 19:58:35' prior: 16886206!
      pattern: fromDoit inContext: ctxt
	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>
	{selector, arguments, precedence}."
	
	| args selector end start argumentName |
	
	doitFlag := fromDoit.
	fromDoit ifTrue:
		[^ctxt == nil
			ifTrue: [{#DoIt. {}. 1. nil }]
			ifFalse: [{#DoItIn:. {encoder encodeVariable: encoder doItInContextName}. 3. nil}]].

	hereType == #word ifTrue: [
		start _ self startOfNextToken + requestorOffset.
		selector _ self advance asSymbol.
		end _ self endOfLastToken + requestorOffset.
		^ {selector. {}. 1. {start to: end}}].

	(hereType == #verticalBar
			or: [hereType == #upArrow])
		ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].

	hereType == #binary ifTrue: [
		start _ self startOfNextToken + requestorOffset.
		selector _ self advance asSymbol.
		end _ self endOfLastToken + requestorOffset.

		start _ self startOfNextToken + requestorOffset.
		argumentName _ self argumentName.
		end _ self endOfLastToken + requestorOffset.
	
		args _ Array with: (encoder bindArg: argumentName range: (start to: end)).
		^ {selector. args. 2. {start to: end}}].

	hereType == #keyword ifTrue: [ | ranges |
		selector := WriteStream on: (String new: 32).
		args := OrderedCollection new.
		ranges := OrderedCollection new.
		[hereType == #keyword] whileTrue:[ | keywordAsString  |
			start _ self startOfNextToken + requestorOffset.
			keywordAsString _ self advance.
			end _ self endOfLastToken + requestorOffset.
			ranges add: (start to: end).
			selector nextPutAll: keywordAsString.
			
			start _ self startOfNextToken + requestorOffset.
			argumentName _ self argumentName.
			end _ self endOfLastToken + requestorOffset.
	
			args addLast: (encoder bindArg: argumentName range: (start to: end)).
		].
		^ {selector contents asSymbol. args. 3. ranges}].
	^self expected: 'Message pattern'
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3407-ParserEnhancements-HernanWilkinson-2018Aug11-19h33m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 8:12:52 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:12:10'!
              argumentNameWithRangeDo: aBlock

	hereType == #word ifFalse: [^self expected: 'Argument name'].
	
	^self advanceWithRangeDo: aBlock! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:07:48' prior: 16886157!
 method: doit context: ctxt 
	" pattern [ | temporaries ] block => MethodNode."

	| sap blk prim temps messageComment methodNode |
	sap := self pattern: doit inContext: ctxt.
	"sap={selector, arguments, precedence}"
	self properties selector: (sap at: 1).
	encoder selector: (sap at: 1).
	(sap at: 2) do: [:argNode | argNode beMethodArg].
	doit ifFalse: [self pragmaSequence].
	temps := self temporaries.
	messageComment := currentComment.
	currentComment := nil.
	doit ifFalse: [self pragmaSequence].
	prim := self pragmaPrimitives.
	self statements: #() innerBlock: doit.
	blk := parseNode.
	doit ifTrue: [blk returnLast]
		ifFalse: [blk returnSelfIfNoOther: encoder].
	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].
	methodNode := self newMethodNode comment: messageComment.
	methodNode
		selector: (sap at: 1)
		arguments: (sap at: 2)
		precedence: (sap at: 3)
		temporaries: temps
		block: blk
		encoder: encoder
		primitive: prim
		properties: properties
		selectorKeywordsRanges: (sap at: 4).
	self interactive ifTrue:
		[self declareUndeclaredTemps: methodNode.
		 self removeUnusedTemps].
	^methodNode! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:10:22' prior: 50409076!
 pattern: fromDoit inContext: ctxt
	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>
	{selector, arguments, precedence}."
	
	| args selector end start argumentName |
	
	doitFlag := fromDoit.
	fromDoit ifTrue:
		[^ctxt == nil
			ifTrue: [{#DoIt. {}. 1. nil }]
			ifFalse: [{#DoItIn:. {encoder encodeVariable: encoder doItInContextName}. 3. nil}]].

	hereType == #word 
		ifTrue: [^ self advanceWithRangeDo: [ :sel :range | {sel asSymbol. {}. 1. {range}} ]].

	(hereType == #verticalBar or: [hereType == #upArrow])
		ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].

	hereType == #binary ifTrue: [ | selectorRange |
		self advanceWithRangeDo: [ :sel :range |
			selector _ sel asSymbol.
			selectorRange _ range ].

		start _ self startOfNextToken + requestorOffset.
		argumentName _ self argumentName.
		end _ self endOfLastToken + requestorOffset.
	
		args _ Array with: (encoder bindArg: argumentName range: (start to: end)).
		^ {selector. args. 2. {selectorRange}}].

	hereType == #keyword ifTrue: [ | ranges |
		selector := WriteStream on: (String new: 32).
		args := OrderedCollection new.
		ranges := OrderedCollection new.
		[hereType == #keyword] whileTrue:[ 
			self advanceWithRangeDo: [ :keywordAsString :range |
				selector nextPutAll: keywordAsString.
				ranges add: range ].
			
			start _ self startOfNextToken + requestorOffset.
			argumentName _ self argumentName.
			end _ self endOfLastToken + requestorOffset.
	
			args addLast: (encoder bindArg: argumentName range: (start to: end)).
		].
		^ {selector contents asSymbol. args. 3. ranges}].
	^self expected: 'Message pattern'
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3408-ParserEnhancements-HernanWilkinson-2018Aug11-19h59m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 8:32:22 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:30:00'!
          addKeywordPatternPartTo: selector keywordRanges: keywordRanges arguments: arguments 
		
	self advanceWithRangeDo: [ :keywordAsString :range |
		selector nextPutAll: keywordAsString.
		keywordRanges add: range ].
			
	self argumentNameWithRangeDo: [ :argName :range |
		arguments addLast: (encoder bindArg: argName range: range)]
! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:25:57'!
           binaryPattern

	^ self advanceWithRangeDo: [ :selectorAsString :selectorRange | | arguments |
		self argumentNameWithRangeDo: [ :argumentName :argumentRange |
		arguments _ Array with: (encoder bindArg: argumentName range: argumentRange).
		{selectorAsString asSymbol. arguments. 2. {selectorRange}}]]! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:31:37'!
       doitPatternInContext: context

	^context 
		ifNil: [{#DoIt. {}. 1. nil }]
		ifNotNil: [{#DoItIn:. {encoder encodeVariable: encoder doItInContextName}. 3. nil}]! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:29:32'!
                     keywordPattern

	| keywordRanges selector arguments |
	
	selector := WriteStream on: (String new: 32).
	arguments := OrderedCollection new.
	keywordRanges := OrderedCollection new.
	
	[hereType == #keyword] whileTrue:[ 
		self addKeywordPatternPartTo: selector keywordRanges: keywordRanges arguments: arguments ].
		
	^ {selector contents asSymbol. arguments. 3. keywordRanges}
		! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:23:06'!
                        unaryPattern

	^ self advanceWithRangeDo: [ :sel :range | {sel asSymbol. {}. 1. {range}} ]! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:21:50' prior: 50409189!
          pattern: fromDoit inContext: ctxt
	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>
	{selector, arguments, precedence}."
	
	| args selector |
	
	doitFlag := fromDoit.
	fromDoit ifTrue:
		[^ctxt == nil
			ifTrue: [{#DoIt. {}. 1. nil }]
			ifFalse: [{#DoItIn:. {encoder encodeVariable: encoder doItInContextName}. 3. nil}]].

	hereType == #word 
		ifTrue: [^ self advanceWithRangeDo: [ :sel :range | {sel asSymbol. {}. 1. {range}} ]].

	(hereType == #verticalBar or: [hereType == #upArrow])
		ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].

	hereType == #binary ifTrue: [ | selectorRange |
		self advanceWithRangeDo: [ :sel :range |
			selector _ sel asSymbol.
			selectorRange _ range ].

		^ self argumentNameWithRangeDo: [ :argName :range |
			args _ Array with: (encoder bindArg: argName range: range).
			{selector. args. 2. {selectorRange}}]].

	hereType == #keyword ifTrue: [ | keywordRanges |
		selector := WriteStream on: (String new: 32).
		args := OrderedCollection new.
		keywordRanges := OrderedCollection new.
		[hereType == #keyword] whileTrue:[ 
			self advanceWithRangeDo: [ :keywordAsString :range |
				selector nextPutAll: keywordAsString.
				keywordRanges add: range ].
			
			self argumentNameWithRangeDo: [ :argName :range |
				args addLast: (encoder bindArg: argName range: range)].
		].
		^ {selector contents asSymbol. args. 3. keywordRanges}]. 
	^self expected: 'Message pattern'
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3409-ParserEnhancements-HernanWilkinson-2018Aug11-20h12m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 8:36:31 pm'!
!Parser methodsFor: 'scanning' stamp: 'HAW 8/11/2018 20:36:10'!
               transformVerticalBarAndUpArrowIntoABinarySelectorIfNecessary
	
	(hereType == #verticalBar or: [hereType == #upArrow])
		ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:33:48' prior: 50409304!
           pattern: fromDoit inContext: ctxt
	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>
	{selector, arguments, precedence}."
	
	doitFlag := fromDoit.
	fromDoit ifTrue: [^self doitPatternInContext: ctxt ].

	hereType == #word ifTrue: [^self unaryPattern ].

	(hereType == #verticalBar or: [hereType == #upArrow])
		ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].

	hereType == #binary ifTrue: [^self binaryPattern ].

	hereType == #keyword ifTrue: [^self keywordPattern ]. 
	
	^self expected: 'Message pattern'
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3410-ParserEnhancements-HernanWilkinson-2018Aug11-20h32m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 8:37:35 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 20:37:20' prior: 50409368!
                             pattern: fromDoit inContext: ctxt
	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>
	{selector, arguments, precedence}."
	
	doitFlag := fromDoit.
	
	fromDoit ifTrue: [^self doitPatternInContext: ctxt ].
	hereType == #word ifTrue: [^self unaryPattern ].
	self transformVerticalBarAndUpArrowIntoABinarySelectorIfNecessary.
	hereType == #binary ifTrue: [^self binaryPattern ].
	hereType == #keyword ifTrue: [^self keywordPattern ]. 
	
	^self expected: 'Message pattern'
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3411-ParserEnhancements-HernanWilkinson-2018Aug11-20h36m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 11:11:26 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 23:04:38' prior: 50409002!
                     messagePart: level repeat: repeat

	| start receiver selector args precedence words keywordStart |
	
	[receiver := parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: 
			[start := self startOfNextToken.
			selector := WriteStream on: (String new: 32).
			args := OrderedCollection new.
			words := OrderedCollection new.
			[hereType == #keyword]
				whileTrue: 
					[keywordStart := self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])
				ifFalse: [ selector := self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ].
			precedence := 3]
		ifFalse: [
			
			(level >= 2 and: [hereType == #verticalBar or: [hereType == #upArrow]]) ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].
			((hereType == #binary )
				and: [level >= 2])
				ifTrue: 
					[start := self startOfNextToken.
					selector := self advance asSymbol.
					words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args := Array with: parseNode.
					precedence := 2]
				ifFalse: [hereType == #word
						ifTrue: 
							[start := self startOfNextToken.
							selector := self advance.
							args := #().
							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])
								ifFalse: [ selector := self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ].
							precedence := 1]
						ifFalse: [^args notNil]]].

	parseNode := MessageNode new
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken)
				keywordsRanges: words.
	repeat]
		whileTrue: [].
	^true! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3412-ParserEnhancements-HernanWilkinson-2018Aug11-20h58m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3403] on 11 August 2018 at 11:32:56 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 23:20:34' prior: 16886240!
                 primaryExpression 
	hereType == #word 
		ifTrue: [
			parseNode _ self variable.
			
			"
			(parseNode isUndefTemp and: [self interactive] and: [
				((requestor isKindOf: Editor) or: [ requestor is: #Morph ])])
			"
			"If the requestor is of an exotic kind (like a telnet server) we might not be
			 allowed to open a PupUpMenu for querying the user"
				
			(parseNode isUndefTemp and: [ self interactive ])
				ifTrue: [self queryUndefined].
			parseNode nowHasRef.
			^ true].
	hereType == #leftBracket
		ifTrue: [
			self advance.
			self blockExpression.
			^true].
	hereType == #leftBrace
		ifTrue: [
			self braceExpression.
			^true].
	hereType == #leftParenthesis
		ifTrue: [
			self advance.
			self expression ifFalse: [^self expected: 'expression'].
			(self match: #rightParenthesis)
				ifFalse: [^self expected: 'right parenthesis'].
			^true].
	(hereType == #string or: [hereType == #number or: [hereType == #literal]])
		ifTrue: [ 
			parseNode := self advanceWithRangeDo: [ :lexema :range | encoder encodeLiteral: lexema range: range ].
			^true].
	(here == #- and: [tokenType == #number])
		ifTrue: [
			self advanceWithRangeDo: [ :minusChar :minusRange |
				self advanceWithRangeDo: [ :number :numberRange |
					parseNode := encoder encodeLiteral: number negated range: (minusRange first to: numberRange last)]].
			^true].
	^false! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 23:23:08' prior: 16886333!
                        temporaries
	" [ '|' (variable)* '|' ]"
	| vars theActualText |
	(self match: #verticalBar) ifFalse: 
		["no temps"
		doitFlag ifTrue:
			[tempsMark := self interactive
								ifTrue: [requestor selectionInterval first]
								ifFalse: [1].
			^ #()].
		tempsMark := hereMark	"formerly --> prevMark + prevToken".
		tempsMark > 0 ifTrue:
			[theActualText := source contents.
			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]
				whileTrue: [tempsMark := tempsMark + 1]].
			^ #()].
	vars := OrderedCollection new.
	[hereType == #word]
		whileTrue: [
			self advanceWithRangeDo: [ :variableName :range |
				vars addLast: (encoder bindTemp: variableName range: range)]].
	(self match: #verticalBar) ifTrue: 
		[tempsMark := prevMark.
		^ vars].
	^ self expected: 'Vertical bar'
! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/11/2018 23:30:36' prior: 16886405!
                      variable
	
	^self advanceWithRangeDo: [ :variableName :range | | varName result |
		varName := variableName.
		[result _ encoder encodeVariable: varName sourceRange: range ifUnknown: [ nil ].
		result ifNil: [
			result _ (UndeclaredVariableReference new)
				parser: self;
				varName: varName;
				varStart: range first;
				varEnd: range last;
				signal ].
		result isString ] whileTrue: [ varName _ result].
		encoder addMultiRange: range for: result ].
	! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3413-ParserEnhancements-HernanWilkinson-2018Aug11-23h11m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3411] on 13 August 2018 at 11:36:37 am'!
!Encoder methodsFor: 'source mapping' stamp: 'HAW 8/13/2018 11:35:34'!
rangesForLiteralNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litSet at: aName ifAbsent: [ ^aBlock value ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 8/13/2018 11:35:41'!
  rangesForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |
	
	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock value ].
	
	^sourceRanges at: variableNode ifAbsent: aBlock! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3414-ParserEnhancements-2-HernanWilkinson-2018Aug13-11h28m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3411] on 13 August 2018 at 7:15:52 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/13/2018 19:15:42'!
           performInteractiveChecks: aMethodNode

	self
		declareUndeclaredTemps: aMethodNode;
		removeUnusedTemps! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3415-ParserEnhancements-2-HernanWilkinson-2018Aug13-19h15m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3411] on 13 August 2018 at 7:16:22 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/13/2018 19:16:08' prior: 50409151!
                   method: doit context: ctxt 
	" pattern [ | temporaries ] block => MethodNode."

	| sap blk prim temps messageComment methodNode |
	
	sap := self pattern: doit inContext: ctxt.
	"sap={selector, arguments, precedence}"
	self properties selector: (sap at: 1).
	encoder selector: (sap at: 1).
	(sap at: 2) do: [:argNode | argNode beMethodArg].
	doit ifFalse: [self pragmaSequence].
	temps := self temporaries.
	messageComment := currentComment.
	currentComment := nil.
	doit ifFalse: [self pragmaSequence].
	prim := self pragmaPrimitives.
	self statements: #() innerBlock: doit.
	blk := parseNode.
	doit ifTrue: [blk returnLast]
		ifFalse: [blk returnSelfIfNoOther: encoder].
	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].
	methodNode := self newMethodNode comment: messageComment.
	methodNode
		selector: (sap at: 1)
		arguments: (sap at: 2)
		precedence: (sap at: 3)
		temporaries: temps
		block: blk
		encoder: encoder
		primitive: prim
		properties: properties
		selectorKeywordsRanges: (sap at: 4).
		
	self interactive ifTrue: [ self performInteractiveChecks: methodNode ].
	
	^methodNode! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3416-ParserEnhancements-2-HernanWilkinson-2018Aug13-19h15m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3411] on 13 August 2018 at 7:45:27 pm'!
!Encoder methodsFor: 'temps' stamp: 'HAW 8/13/2018 19:44:54'!
   bindBlockArg: name within: aBlockNode range: range
	
	^self addMultiRange: range for: (self bindBlockArg: name within: aBlockNode)
	
! !
!Encoder methodsFor: 'temps' stamp: 'HAW 8/13/2018 19:45:13'!
                         bindBlockTemp: name within: aBlockNode range: range

	^self addMultiRange: range for: (self bindBlockTemp: name within: aBlockNode)
	
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3417-ParserEnhancements-3-HernanWilkinson-2018Aug13-19h16m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3411] on 13 August 2018 at 7:48:17 pm'!
!Parser methodsFor: 'expression types' stamp: 'HAW 8/13/2018 19:47:02' prior: 16885972!
                    blockExpression
	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."

	| blockNode variableNodes temporaryBlockVariables start |
	blockNode := BlockNode new.
	variableNodes := OrderedCollection new.
	start := prevMark + requestorOffset.
	"Gather parameters."
	[self match: #colon] whileTrue:
		[self argumentNameWithRangeDo: [ :argumentName :range |
			variableNodes addLast: (encoder bindBlockArg: argumentName within: blockNode range: range)]].
	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue:
		[^self expected: 'Vertical bar'].

	temporaryBlockVariables := self temporaryBlockVariablesFor: blockNode.
	self statements: variableNodes innerBlock: true blockNode: blockNode.
	blockNode temporaries: temporaryBlockVariables.

	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].

	blockNode noteSourceRangeStart: start end: self endOfLastToken encoder: encoder.

	"The scope of the parameters and temporary block variables is no longer active."
	temporaryBlockVariables do: [:variable | variable scope: -1].
	variableNodes do: [:variable | variable scope: -1]! !
!Parser methodsFor: 'expression types' stamp: 'HAW 8/13/2018 19:47:49' prior: 16886386!
        temporaryBlockVariablesFor: aBlockNode
	"Scan and answer temporary block variables."

	| variables |
	(self match: #verticalBar) ifFalse:
		"There are't any temporary variables."
		[aBlockNode tempsMark: prevMark + requestorOffset.
		 ^#()].

	variables := OrderedCollection new.
	[hereType == #word] whileTrue:
		[self advanceWithRangeDo: [ :lexema :range |
			variables addLast: (encoder bindBlockTemp: lexema within: aBlockNode range: range)]].
	(self match: #verticalBar) ifFalse:
		[^self expected: 'Vertical bar'].
	aBlockNode tempsMark: prevMark + requestorOffset.
	^variables! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3418-ParserEnhancements-3-HernanWilkinson-2018Aug13-19h45m-HAW.1.cs.st----!

----SNAPSHOT----#(15 August 2018 3:59:36.247523 pm) Cuis5.0-3418-v3.image priorSource: 2454628!

----QUIT----#(15 August 2018 4:00:00.623775 pm) Cuis5.0-3418-v3.image priorSource: 2500024!

----STARTUP----#(25 August 2018 11:26:45.959061 am) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3418-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 15 August 2018 at 7:54:00 pm'!

Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick '
	classVariableNames: 'TypeTable '
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Scanner category: #'Compiler-Kernel'!
Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick'
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!Scanner methodsFor: 'expression types - private' stamp: 'HAW 8/15/2018 19:53:14'!
                     isBacktickAndShouldIgnoreIt 
	
	"I compare with true because there are many ways to initialize the scanner and ingoreBacktick could be nil - Hernan"
	^ ignoreBacktick == true and: [tokenType = #xBacktick]! !
!Scanner methodsFor: 'expression types - private' stamp: 'HAW 8/15/2018 19:53:27'!
                             skipDelimiters

	[(tokenType := self typeTableAt: hereChar) == #xDelimiter] whileTrue: [self step].  
! !
!Scanner methodsFor: 'expression types - private' stamp: 'HAW 8/15/2018 19:53:35'!
   skipDelimitersAndBacktickIfNecessary

	[self skipDelimiters.
	self isBacktickAndShouldIgnoreIt ] whileTrue: [self step].  ! !
!Scanner methodsFor: 'initialization' stamp: 'HAW 8/15/2018 19:51:51' prior: 50382605!
           initScanner

	buffer := WriteStream on: (String new: 40).
	typeTable := Scanner typeTable.
	isForTokenization := false.
	sentInLiterals := Set new.
	ignoreBacktick := true! !
!Scanner methodsFor: 'initialization' stamp: 'HAW 8/15/2018 19:52:00' prior: 16904201!
                          initScannerForTokenization
	"Don't raise xIllegal when enocuntering an _"
	"Simpler implementation for Cuis"
	isForTokenization _ true.
	ignoreBacktick _ true.! !

Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick'
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Scanner category: #'Compiler-Kernel'!
Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick'
	classVariableNames: 'TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3419-BacktickEvaluationOnlyWhenCompiling-HernanWilkinson-2018Aug15-19h51m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 15 August 2018 at 7:55:52 pm'!
!Scanner methodsFor: 'initialization' stamp: 'HAW 8/15/2018 19:55:10'!
             ignoreBacktick: aBoolean

	ignoreBacktick := aBoolean ! !
!Scanner methodsFor: 'expression types' stamp: 'HAW 8/15/2018 19:55:41' prior: 16903829!
             scanToken

	"Skip delimiters fast, there almost always is one."
	self skipDelimitersAndBacktickIfNecessary.

	mark := source position - 1.
	(tokenType at: 1) = $x "x as first letter"
		ifTrue: [self perform: tokenType "means perform to compute token & type"]
		ifFalse: [token := self step asSymbol "else just unique the first char"].
	^token! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3420-BacktickEvaluationOnlyWhenCompiling-HernanWilkinson-2018Aug15-19h54m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 15 August 2018 at 7:57:57 pm'!
!Compiler methodsFor: 'private' stamp: 'HAW 8/15/2018 19:56:18' prior: 16822062!
                       translate: aStream noPattern: noPattern ifFail: failBlock
	^self parser
		sourceStreamGetter: sourceStreamGetter;			"Cuis specific. Do not remove!!"
		ignoreBacktick: false;
		parse: aStream
		class: class
		category: category
		noPattern: noPattern
		context: context
		notifying: requestor
		ifFail: [^failBlock value]! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3421-BacktickEvaluationOnlyWhenCompiling-HernanWilkinson-2018Aug15-19h55m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 16 August 2018 at 6:44:54 am'!
!Scanner methodsFor: 'xBacktick processing - private' stamp: 'HAW 8/16/2018 06:37:45'!
       compileBacktickCode

	| compiler method methodNode |
	
	compiler _ Compiler new.
	methodNode _ compiler compileNoPattern: buffer contents in: UndefinedObject context: nil notifying: nil ifFail: [].
	method _ methodNode generate.
	
	"Grab all messages sent while evaluating literal, so the main method will be shown as senders of them"
	sentInLiterals addAll: method messages.
	method literalsDo: [ :literal | literal isSymbol ifTrue: [ literal = #DoIt ifFalse: [sentInLiterals add: literal ]]].
		
	"Evaluate now."
	token _ nil withArgs: #() executeMethod: method ! !
!Scanner methodsFor: 'xBacktick processing - private' stamp: 'HAW 8/16/2018 06:37:02'!
                 compileBacktickCodeHandlingErrors

	[[[self compileBacktickCode ] 
		on: SyntaxErrorNotification
		do: [ :ex | self notify: 'Can not compile: ', ex errorMessage at: mark]]
		on: UndeclaredVariableReference
		do: [ :ex | self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]]
		on: Error
		do: [ :ex | self notify: 'Can not evaluate code: ', ex description at: mark ].
	
	tokenType _ #literal! !
!Scanner methodsFor: 'xBacktick processing - private' stamp: 'HAW 8/16/2018 06:28:34'!
                           isAtBacktick
	
	^ hereChar == $` and: [aheadChar == $` ifTrue: [self step. false] ifFalse: [true]]! !
!Scanner methodsFor: 'xBacktick processing - private' stamp: 'HAW 8/16/2018 06:28:54'!
   readUpToNextBacktick
	
	self step.
	buffer reset.
	
	[self isAtBacktick]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd]) ifTrue: [^false]].
	self step.
	
	^true! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 06:38:36' prior: 50408469!
                     xBacktick
	
	"Smalltalk code evaluated at compile time as a literal."

	self readUpToNextBacktick ifFalse: [^self offEnd: 'Unmatched back quote'].
	self compileBacktickCodeHandlingErrors.! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3422-ScannerCleanup-HernanWilkinson-2018Aug15-19h57m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 16 August 2018 at 6:49:39 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 06:49:14'!
          doItCharacter

	^self class doItCharacterValue asCharacter! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3423-ScannerCleanup-HernanWilkinson-2018Aug16-06h44m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 16 August 2018 at 6:56:22 am'!
!Scanner methodsFor: 'expression types' stamp: 'HAW 8/16/2018 06:52:54' prior: 16903686!
scanAllTokenPositionsInto: aBlock
	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."

	| lastMark |
	lastMark := 1.
	[currentComment ifNotNil:
		[currentComment do:
			[:cmnt| | idx |
			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.
			 (idx > 0 and: [idx < mark]) ifTrue:
				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].
		 currentComment := nil].
	mark ifNotNil:
		[(token == #- 
		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue:
			[| savedMark |
			 savedMark := mark.
			 self scanToken.
			 token := token negated.
			 mark := savedMark].
		"Compensate for the fact that the parser uses two character lookahead.  Normally we must
		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."
		 aBlock
			value: mark
			value: (source position - (aheadChar = self class doItCharacterValue ifTrue: [hereChar = self doItCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]))].
	 (tokenType == #rightParenthesis
	  or: [tokenType == #doIt]) ifTrue:
		[^self].
	tokenType == #leftParenthesis
		ifTrue: 
			[self scanToken; scanAllTokenPositionsInto: aBlock]
		ifFalse: 
			[(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])
				ifTrue: 
					[self scanLitWord.
					 token == #true ifTrue: [token := true].
					 token == #false ifTrue: [token := false].
					 token == #nil ifTrue: [token := nil]]
				ifFalse:
					[(token == #- 
					  and: [(self typeTableAt: hereChar) == #xDigit])
						ifTrue: 
							[self scanToken.
							 token := token negated]]].
		self scanToken ] repeat! !
!Scanner methodsFor: 'expression types' stamp: 'HAW 8/16/2018 06:50:46' prior: 16903844!
                        step

	| c |
	c := hereChar.
	hereChar := aheadChar.
	source atEnd
		ifTrue: [aheadChar := self doItCharacter "doit"]
		ifFalse: [aheadChar := source next].
	^c! !
!Scanner methodsFor: 'xBacktick processing - private' stamp: 'HAW 8/16/2018 06:50:12' prior: 50409966!
                     readUpToNextBacktick
	
	self step.
	buffer reset.
	
	[self isAtBacktick]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = self doItCharacter and: [source atEnd]) ifTrue: [^false]].
	self step.
	
	^true! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 06:51:11' prior: 16904051!
         xDigit
	"Form a number."

	tokenType := #number.
	(aheadChar = self doItCharacter and: [source atEnd
			and:  [source skip: -1. source next ~= self doItCharacter]])
		ifTrue: [source skip: -1 "Read off the end last time"]
		ifFalse: [source skip: -2].
	token := [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].
	self step; step! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 06:51:33' prior: 16904073!
    xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := self doItCharacter.
    aStream := WriteStream on: (String new: 200).
    self step.
    [hereChar == $"]
        whileFalse:
            [(hereChar == stopChar and: [source atEnd])
                ifTrue: [^self offEnd: 'Unmatched comment quote'].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollection with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 06:51:48' prior: 16904108!
                            xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore]]] whileTrue:
			["open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
							ifTrue: [self doItCharacter "doit"]
							ifFalse: [source next]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])
					ifTrue: 
						[buffer nextPut: self step.
						"Allow any number of embedded colons in literal symbols"
						[(self typeTableAt: hereChar) == #xColon] whileTrue:
							[buffer nextPut: self step].
						#keyword]
					ifFalse: 
						[#word].
	token := buffer contents! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 06:52:09' prior: 16904168!
              xSingleQuote
	"String."

	self step.
	buffer reset.
	[hereChar == $' 
		and: [aheadChar == $' 
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: 
			[buffer nextPut: self step.
			(hereChar = self doItCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched string quote']].
	self step.
	token := buffer contents.
	tokenType := #string! !
!Scanner class methodsFor: 'cached class state' stamp: 'HAW 8/16/2018 06:52:18' prior: 50382992!
               initTypeTable
	| newTable |
	newTable := Array new: 256 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"

	1 to: 255
		do: [:index |
			(Character numericValue: index) isValidInIdentifiers
				ifTrue: [
					"Digits and $_ are overwritten later"
					newTable at: index put: #xLetter ]].

	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable atAll:  '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.

	newTable at: self doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!Parser methodsFor: 'scanning' stamp: 'HAW 8/16/2018 06:49:54' prior: 16885743!
   advance
	| this |
	prevMark := hereMark.
	prevEnd := hereEnd.
	this := here.
	here := token.
	hereType := tokenType.
	hereMark := mark.
	hereEnd := source position - (source atEnd ifTrue: [hereChar = self doItCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]).
	self scanToken.
	"Transcript show: 'here: ', here printString, ' mark: ', hereMark printString, ' end: ', hereEnd printString; cr."
	^this! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3424-ScannerCleanup-HernanWilkinson-2018Aug16-06h49m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 16 August 2018 at 7:01:54 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 07:00:43'!
                      isAt: aChar
	
	^ hereChar == aChar and: [aheadChar == aChar ifTrue: [self step. false] ifFalse: [true]]! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 07:01:00'!
       readUpToNext: aChar ifNotFound: aNotFoundBlock

	self step.
	buffer reset.
	
	[self isAt: aChar]
		whileFalse: 
			[buffer nextPut: self step.
			(hereChar = self doItCharacter and: [source atEnd]) ifTrue: [^aNotFoundBlock value ]].
	
	self step.
	token := buffer contents.
	! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3425-ScannerCleanup-HernanWilkinson-2018Aug16-06h56m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 16 August 2018 at 7:05:45 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 07:04:23' prior: 50409977!
  xBacktick
	
	"Smalltalk code evaluated at compile time as a literal."

	self readUpToNext: $` ifNotFound: [^self offEnd: 'Unmatched back quote'].
	self compileBacktickCodeHandlingErrors.! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 8/16/2018 07:03:12' prior: 50410146!
    xSingleQuote
	
	"String."

	self readUpToNext: $'  ifNotFound: [^self offEnd: 'Unmatched string quote'].
	tokenType := #string! !

Scanner removeSelector: #isAtBacktick!

Scanner removeSelector: #isAtBacktick!

Scanner removeSelector: #readUpToNextBacktick!

Scanner removeSelector: #readUpToNextBacktick!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3426-ScannerCleanup-HernanWilkinson-2018Aug16-07h01m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3426] on 19 August 2018 at 6:11:23 pm'!
!WorldState methodsFor: 'accessing' stamp: 'jmv 8/19/2018 18:11:12' prior: 50340367!
                runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| stepMessage |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [
			stepMessage _ stepList first.
			(stepMessage receiver shouldGetStepsFrom: world)
				ifFalse: [ stepList removeFirst ]
				ifTrue: [
					stepMessage valueAtTime: nowTime.
					stepMessage rescheduleAfter: nowTime.
					"We've just updated the  scheduled time for stepMessage.
					It might have been that stepMessage was removed altogether from stepList.
					It also may be the case that stepList got added or removed other elements while on #valueAtTime:
					Just reSort. It will be ok in any case."
					stepList reSort.
					]
		]! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3427-MorphicStepFix-JuanVuletich-2018Aug19-18h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3418] on 21 August 2018 at 4:01:58 pm'!
!ProtocolBrowser methodsFor: 'initialization' stamp: 'jmv 8/21/2018 16:01:20' prior: 50374662!
                           initialize
	super initialize.
	exclude _ OrderedCollection new! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3428-ProtocolBrowser-fix-JuanVuletich-2018Aug21-16h01m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3402] on 18 August 2018 at 2:44:44 pm'!
!Behavior methodsFor: 'private' stamp: 'pb 8/18/2018 14:12:12' prior: 16784915!
   handleFailingFailingBasicNew: sizeRequested
	"This basicNew: gets sent after handleFailingBasicNew: has done a full
	 garbage collection and possibly grown memory.  If this basicNew: fails
	 then the system really is low on space, so raise the OutOfMemory signal.

	 Primitive. Answer an instance of this class with the number of indexable
	 variables specified by the argument, sizeRequested.  Fail if this class is not
	 indexable or if the argument is not a positive Integer, or if there is not
	 enough memory available. Essential. See Object documentation whatIsAPrimitive."
	"space must be low."
	<primitive: 71>
	(sizeRequested isInteger and: [ sizeRequested > 0 ])
		ifTrue: [ OutOfMemory signal ]
		ifFalse: [ self error: 'sizeRequested must be a positive integer' ].
	^ self basicNew: sizeRequested"retry if user proceeds".! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3429-not-always-OOM-PhilBellalouna-2018Aug18-14h12m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3429] on 23 August 2018 at 4:37:09 pm'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 8/23/2018 09:45:40'!
       smoothStep
	"A Function that is
		x <= -1 		-> 		1
		-1 < x < 1 	->		smooth differentiable transition from 1 to 0
		1 <= x 		-> 		0
	
	It is a 'smooth' version of an #negative
	Has countless applications. For example in image and signal processing, but also in other fields."
	"
	| g |
	Feature require: 'Morphic-Widgets-Extras'.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x abs < 1 ifTrue: [1] ifFalse:[0] ] color: Color brown.
	g addFunction: [ :x | x smoothStep ] color: Color red.
	(g embeddedInMorphicWindowLabeled: 'graph') openInWorld
	"
	self > -1 ifFalse: [ ^ 1 ].
	1 > self ifFalse: [ ^ 0 ].
	^ (self +2 * Float halfPi) sin * 0.5 + 0.5! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 8/23/2018 09:30:56' prior: 16845643!
                          reciprocal
	^ 1.0 / self! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 8/23/2018 09:32:01' prior: 50405241!
       smoothIsAbsBelow: threshold
	"A Function that is 1 at zero, 0 outside a bounded interval of size 4*threshold, and is continuous and differentiable.
	
	It is a 'smooth' version of an #isAbsBelow: function: x abs < threshold.
	Useful when we need to 'count' stuff, but still want continuous and differentiable stuff."
	"
	| g |
	Feature require: 'Morphic-Widgets-Extras'.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x abs < Float halfPi ifTrue: [1] ifFalse:[0] ] color: Color brown.
	g addFunction: [ :x | x smoothIsAbsBelow: Float halfPi ] color: Color red.
	(g embeddedInMorphicWindowLabeled: 'graph') openInWorld
	"
	| scaled |
	scaled _ self / threshold.
	^ scaled abs < 2 ifTrue: [ (scaled * Float halfPi) cos + 1.0 * 0.5 ] ifFalse: [ 0 ]! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3430-FloatTweaks-JuanVuletich-2018Aug23-16h36m-jmv.1.cs.st----!

----SNAPSHOT----#(25 August 2018 11:26:53.680982 am) Cuis5.0-3430-v3.image priorSource: 2500121!

----QUIT----#(25 August 2018 11:27:16.731318 am) Cuis5.0-3430-v3.image priorSource: 2520942!

----STARTUP----#(8 October 2018 11:01:45.563759 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3430-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 2 September 2018 at 11:47:54 pm'!

Object subclass: #CharacterScanner
	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth kern paragraphStyle tabWidth defaultFont lastTabIndex lastTabX '
	classVariableNames: 'DefaultStopConditions StopConditionsWithPaddedSpace StopConditionsWithSpace '
	poolDictionaries: ''
	category: 'Graphics-Text'!

!classDefinition: #CharacterScanner category: #'Graphics-Text'!
Object subclass: #CharacterScanner
	instanceVariableNames: 'destX lastIndex xTable map destY stopConditions text alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth kern paragraphStyle tabWidth defaultFont lastTabIndex lastTabX'
	classVariableNames: 'DefaultStopConditions StopConditionsWithPaddedSpace StopConditionsWithSpace'
	poolDictionaries: ''
	category: 'Graphics-Text'!
!CharacterScanner methodsFor: 'private' stamp: 'jmv 9/2/2018 23:46:54' prior: 50370313!
                           setFont
	| attributes |
	"Set the font and other emphasis.
	In fact set actual ParagraphStyle (or nil), alignment, font and emphasis"

	self setActualFont: (text fontAt: lastIndex default: defaultFont).
	attributes _ text attributesAt: lastIndex.
	text
		withAttributeValues: attributes
		do: [ :familyNameInText :pointSizeInText :emphasisInText :colorInText :alignmentInText :characterStyleInText :paragraphStyleInText :backgroundColorInText |
			colorInText ifNotNil: [ self textColor: colorInText ].
			self backgroundColor: backgroundColorInText.
			alignment _ alignmentInText.
			paragraphStyle _ paragraphStyleInText ].
	
	"Hardcoded color for TextAction"
	attributes do: [ :attribute |
		attribute forTextActionInfoDo: [ :info |
			self textColor: TextAction textActionColor ]].

	"Install various parameters from the font."
	spaceWidth _ font widthOf: Character space.
	tabWidth _ font pointSize * 5 // 2.
	xTable _ font xTable! !
!CharacterScanner methodsFor: 'stop conditions' stamp: 'jmv 9/2/2018 23:46:57' prior: 16802073!
                    tabDestX
	"This is the basic method of adjusting destX for a tab."

	^paragraphStyle
		ifNotNil: [
			paragraphStyle
				nextTabXFrom: destX
				leftMargin: leftMargin
				rightMargin: rightMargin ]
		ifNil: [
			"Add the width of a tab for every two chars since last tab, to last tab x position."
			(lastIndex - lastTabIndex // 3 + 1) * tabWidth + lastTabX min: rightMargin ]! !
!CharacterScanner methodsFor: 'initialization' stamp: 'jmv 9/1/2018 20:32:04' prior: 16802089!
    initialize
	lastTabIndex _ lastTabX _ destX _ destY _ leftMargin _ rightMargin _ 0.! !
!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'jmv 9/2/2018 23:40:08' prior: 16801835!
    tab
	| currentX |
	currentX _ self tabDestX.
	lastSpaceOrTabWidth _ currentX - destX max: 0.
	currentX >= characterPoint x
		ifTrue: [
			lastCharacterWidth _ lastSpaceOrTabWidth.
			^ self crossedX ].
	destX _ currentX.
	lastIndex _ lastIndex + 1.
	lastTabX _ destX.
	lastTabIndex _ lastIndex.
	^false! !
!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 9/2/2018 23:30:31' prior: 16801846!
                characterBlockAtPoint: aPoint index: index in: textLine
	"This method is the Morphic characterBlock finder."
	| runLength lineStop stopCondition |
	line _ textLine.
	rightMargin _ line rightMargin.
	lastTabIndex _ lastIndex _ line first.
	self setFont.
	self setStopConditions.
	characterIndex _ index.  "nil means scanning for point"
	characterPoint _ aPoint.
	(characterPoint isNil or: [ characterPoint y > line bottom ])
		ifTrue: [ characterPoint _ line bottomRight ].
	(text isEmpty or: [( characterPoint y < line top or: [ characterPoint x < line left ])
				or: [ characterIndex notNil and: [ characterIndex < line first ]]])
		ifTrue:	[^ CharacterBlock
					stringIndex: line first
					text: text
					topLeft: line leftMargin@line top
					extent: 0 @ line lineHeight
					textLine: line].
	lastTabX _ destX _ leftMargin _ line leftMarginForAlignment: alignment.
	destY _ line top.
	runLength _ text runLengthFor: line first.
	lineStop _ characterIndex	"scanning for index"
		ifNil: [ line last ].			"scanning for point"
	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.
	lastCharacterWidth _ 0.
	spaceCount _ 0.

	self placeEmbeddedObject.
	[
		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex
			in: text string rightX: characterPoint x
			stopConditions: stopConditions kern: font baseKern.
		"see setStopConditions for stopping conditions for character block operations."
		lastCharacterWidth _ specialWidth ifNil: [ font widthOf: (text at: lastIndex) ].
		(self perform: stopCondition) ifTrue: [
			^characterIndex
				ifNil: [	"Result for characterBlockAtPoint: "
					CharacterBlock
						stringIndex: lastIndex
						text: text
						topLeft: characterPoint
						extent: lastCharacterWidth @ line lineHeight
						textLine: line ]
				ifNotNil: [	"Result for characterBlockForIndex: "
					CharacterBlock
						stringIndex: characterIndex
						text: text
						topLeft: characterPoint
						extent: lastCharacterWidth @ line lineHeight
						textLine: line ]]
		] repeat! !
!CompositionScanner methodsFor: 'scanning' stamp: 'jmv 9/2/2018 23:27:51' prior: 16822889!
                               composeFrom: startIndex inRectangle: lineRectangle firstLine: firstLine leftSide: leftSide rightSide: rightSide

	"Answer an instance of TextLineInterval that represents the next line in the paragraph."
	| runLength stopCondition xtraSpaceBefore spaceAfterParagraph |
	
	lastTabIndex _ lastIndex _ startIndex.	"scanning sets last index"
	destY _ lineRectangle top.
	lineHeight _ baseline _ 0.  "Will be increased by setFont"
	self setFont.
	self setStopConditions.

	"Set up margins"
	leftMargin _ lineRectangle left.
	rightMargin _ lineRectangle right.
	xtraSpaceBefore _ 0.
	spaceAfterParagraph _ 0.
	paragraphStyle ifNotNil: [
		leftSide ifTrue: [
			leftMargin _ leftMargin +
				((firstLine and: [ paragraphStyle isListStyle not ])
					ifTrue: [ paragraphStyle firstIndent ]
					ifFalse: [ paragraphStyle restIndent ])].
		rightSide ifTrue: [
			rightMargin _ rightMargin - paragraphStyle rightIndent].
		firstLine ifTrue: [ xtraSpaceBefore _ paragraphStyle spaceBefore ].
		spaceAfterParagraph _ paragraphStyle spaceAfter ].
	lastTabX _ destX _ spaceX _ leftMargin.

	runLength _ text runLengthFor: startIndex.
	runStopIndex _ lastIndex + runLength - 1.
	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)
				rectangle: lineRectangle.
	line isFirstLine: firstLine.
	spaceCount _ 0.
	lastLineBreakingSpace _ 0.
	leftMargin _ destX.
	line leftMargin: leftMargin.

	self placeEmbeddedObject.
	[
			stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex
				in: text string rightX: rightMargin stopConditions: stopConditions
				kern: font baseKern.
			"See setStopConditions for stopping conditions for composing."
			(self perform: stopCondition) ifTrue: [
				^ line 
					lineHeight: lineHeight + xtraSpaceBefore + 
						(stopCondition == #doNewLine ifTrue: [spaceAfterParagraph] ifFalse: [0]) 
					baseline: baseline + xtraSpaceBefore ]
	] repeat! !
!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 9/2/2018 23:40:01' prior: 16823086!
                 tab
	"Advance destination x according to tab settings in the current
	ParagraphStyle. Answer whether the character has crossed the right edge of 
	the composition rectangle of the TextComposition."

	destX _ self tabDestX.
	destX > rightMargin ifTrue: [^self crossedX].
	lastIndex _ lastIndex + 1.
	lastTabX _ destX.
	lastTabIndex _ lastIndex.
	^false
! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 9/2/2018 23:30:05' prior: 50371340!
     displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos x1 |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastTabIndex _ lastIndex _ line first.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	lastTabX _ destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				xTable _ font xTable.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: font baseKern.
		backgroundColor ifNotNil: [
			x1 _ destX.
			(Preferences backgroundColorFillsAllBackground and: [startIndex > line last]) ifTrue: [
				x1 _ rightMargin ].
			canvas
				fillRectangle: (lastPos corner: x1 @ (line bottom + textTopLeft y))
				color: backgroundColor.
			(Preferences backgroundColorFillsAllBackground and: [stopCondition = #tab]) ifTrue: [
				canvas
					fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
					color: backgroundColor ]].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !
!MorphicScanner methodsFor: 'stop conditions' stamp: 'jmv 9/2/2018 23:39:42' prior: 16878154!
     tab
	destX _ self tabDestX.
	lastIndex _ lastIndex + 1.
	lastTabX _ destX.
	lastTabIndex _ lastIndex.
	^ false! !

Object subclass: #CharacterScanner
	instanceVariableNames: 'destX lastIndex xTable destY stopConditions text alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth tabWidth kern paragraphStyle defaultFont lastTabX lastTabIndex'
	classVariableNames: 'DefaultStopConditions StopConditionsWithPaddedSpace StopConditionsWithSpace'
	poolDictionaries: ''
	category: 'Graphics-Text'!

!classDefinition: #CharacterScanner category: #'Graphics-Text'!
Object subclass: #CharacterScanner
	instanceVariableNames: 'destX lastIndex xTable destY stopConditions text alignment leftMargin rightMargin font line runStopIndex spaceCount spaceWidth tabWidth kern paragraphStyle defaultFont lastTabX lastTabIndex'
	classVariableNames: 'DefaultStopConditions StopConditionsWithPaddedSpace StopConditionsWithSpace'
	poolDictionaries: ''
	category: 'Graphics-Text'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3431-TabColumnsFix-JuanVuletich-2018Sep02-23h10m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 2 September 2018 at 11:54:19 pm'!
!Workspace class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:15:27' prior: 50403865!
               worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		20.
			#label 			->			'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#openWorkspace.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!Transcripter class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:15:19' prior: 50403878!
                      worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		30.
			#itemOrder 		-> 		20.
			#label 			->			'Emergency Evaluator'.
			#object 			-> 		Transcripter.
			#selector 		-> 		#emergencyEvaluator.
			#icon 			-> 		#emblemImportantIcon.
			#balloonText 	-> 		'When all else fails...'.
		} asDictionary}`! !
!TextEditor class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:14:50' prior: 50403891!
                      worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		10.
			#label 			->			'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#openTextEditor.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:13:05' prior: 50403916!
                         worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->			'Installed Packages'.
			#object 			-> 		CodePackageListWindow.
			#selector 		-> 		#openPackageList.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/6/2018 11:53:52' prior: 50404019!
                               worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		30.
			#label 			->			'Browser'.
			#object 			-> 		BrowserWindow.
			#selector 		-> 		#openBrowser.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:13:59' prior: 50404062!
                       worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		40.
			#label 			->			'Message Names'.
			#object 			-> 		MessageNamesWindow.
			#selector 		-> 		#openMessageNames.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:12:50' prior: 50404077!
                         worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		20.
			#label 			->			'Change Sorter'.
			#object 			-> 		ChangeSorterWindow.
			#selector 		-> 		#openChangeSorter.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:13:27' prior: 50404092!
                worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		10.
			#label 			->			'File List'.
			#object 			-> 		FileListWindow.
			#selector 		-> 		#openFileList.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary}`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:14:22' prior: 50404105!
                worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		30.
			#itemOrder 		-> 		10.
			#label 			->			'Process Browser'.
			#object 			-> 		ProcessBrowserWindow.
			#selector 		-> 		#openProcessBrowser.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:14:27' prior: 50404119!
                    worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		20.
			#label 			->			'SUnit Test Runner'.
			#object 			-> 		TestRunnerWindow.
			#selector 		-> 		#openTestRunner.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary}`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'HAW 7/7/2018 19:15:13' prior: 50404132!
         worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		50.
			#label 			->			'Transcript'.
			#object 			-> 		TranscriptWindow.
			#selector 		-> 		#openTranscript.
			#icon 			-> 		#printerIcon.
			#balloonText 	-> 		'A window showing contents of the System Transcript'.
		} asDictionary}`! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3432-FixSomeTabbing-JuanVuletich-2018Sep02-23h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 3 September 2018 at 12:02:50 am'!
!Collection methodsFor: 'converting' stamp: 'jmv 9/3/2018 00:00:57' prior: 50393640!
             asDictionary
	"Answer a Dictionary. Assume our elements are Associations.
	{
			#itemGroup 		-> 	10.
			#itemOrder 		-> 	30.
			#label 			-> 	'Browser'.
			#object 			-> 	BrowserWindow.
			#selector 		-> 	#openBrowser.
			#icon 			-> 	#editFindReplaceIcon.
			#balloonText 	-> 	'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary
	"

	^ self as: Dictionary! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:03:02' prior: 50404621!
                             smalltalkEditorMenu2Options
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`
! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'jmv 9/2/2018 23:59:47' prior: 50405415!
   smalltalkEditorMenuOptions
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'Debug it (D)'.	
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		60.
				#label 			-> 		'Profile it'.	
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 18:45:13' prior: 50403981!
            messageListMenu2
	"Fill aMenu with the items appropriate when the shift key is held down"

	^DynamicMenuBuilder 
		buildTitled: 'Message List' 
		targeting: self 
		collectingMenuOptionsWith: #messageListMenu2Options 
		changingThemWith: [ :options |
			self addExtraMenu2ItemsTo: options.
			model canShowMultipleMessageCategories ifTrue: [	
				options add: `{ 
					#itemGroup 		-> 		40.
					#itemOrder 		-> 		45.		
					#label 			-> 		'show category (C)'.
					#object 			-> 		#model.
					#selector 		-> 		#showHomeCategory.
					#icon 			-> 		#packageIcon
				} asDictionary` ]].
		
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/6/2018 12:21:10' prior: 50403028!
           classListMenu2Options

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'unsent methods'.
				#selector 		-> 		#browseUnusedMethods.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'browse all methods defined by this class that have no senders'
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'unreferenced inst vars'.
				#selector 		-> 		#showUnreferencedInstVars.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'show a list of all instance variables that are not referenced in methods'
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'unreferenced class vars'.
				#selector 		-> 		#showUnreferencedClassVars.
				#icon 			->			#junkIcon.
				#balloonText 	-> 		'show a list of all class variables that are not referenced in methods'
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'subclass template'.
				#object 			-> 		#model.
				#selector 		-> 		#makeNewSubclass.
				#icon 			->			#classIcon.
				#balloonText 	-> 		'put a template into the code pane for defining of a subclass of this class'
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			->			#instanceIcon.
				#balloonText 	-> 		'give me a sample instance of this class, if possible'
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			->			#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class'
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			->			#inspectIcon.
				#balloonText 	-> 		'open an inspector on all the extant instances of this class and of all of its subclasses'
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'create inst var accessors'.
				#object 			-> 		#model.
				#selector 		-> 		#createInstVarAccessors.
				#icon 			->			#sendReceiveIcon.
				#balloonText 	-> 		'compile instance-variable access methods for any instance variables that do not yet have them'
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu.
				#icon 			->			#listAddIcon.
				#balloonText 	-> 		'return to the standard class-list menu'
			} asDictionary.
		}`! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 8/3/2018 14:47:08' prior: 50407707!
                             classListMenuOptions

	^ `{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutClass.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		5.
				#label 			-> 		'show classes hierarchically'.
				#object 			-> 		#model.
				#selector 		-> 		#enableListClassesHierarchically.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		6.
				#label 			-> 		'show classes alphabetically'.
				#object 			-> 		#model.
				#selector 		-> 		#enableListClassesAlphabetically.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'show hierarchy'.
				#object 			-> 		#model.
				#selector 		-> 		#hierarchy.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'show definition'.
				#object 			-> 		#model.
				#selector 		-> 		#editClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'show comment'.
				#object 			-> 		#model.
				#selector 		-> 		#editComment.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'class vars'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class ...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'copy class...'.
				#object 			-> 		#model.
				#selector 		-> 		#copyClass.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runClassTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		20.
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/6/2018 12:24:58' prior: 50403222!
                            messageCategoryMenuOptions

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessageCategories.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editMessageCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'alphabetize'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeMessageCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove empty categories'.
				#object 			-> 		#model.
				#selector 		-> 		#removeEmptyCategories.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'categorize all uncategorized'.
				#object 			-> 		#model.
				#selector 		-> 		#categorizeAllUncategorizedMethods.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'new category...'.
				#object 			-> 		#model.
				#selector 		-> 		#addCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessageCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMessageCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 18:22:02' prior: 50403288!
                       messageListMenu2Options
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleDiffing.
				#icon 			-> 		#switchIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'implementors of sent messages'.
				#selector 		-> 		#browseAllMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'local senders of...'.
				#selector 		-> 		#browseLocalSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'local implementors of...'.
				#selector 		-> 		#browseLocalImplementors.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'spawn sub-protocol'.
				#selector 		-> 		#browseProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'spawn full protocol'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#speadsheetTemplateIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'change category...'.
				#object 			-> 		#model.
				#selector 		-> 		#changeCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		50.
				#label 			-> 		'change sets with this method'.
				#selector 		-> 		#findMethodInChangeSets.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		60.
				#label 			-> 		'revert to previous version'.
				#object 			-> 		#model.
				#selector 		-> 		#revertToPreviousVersion.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#openMessageListMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.			
		}`! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 8/11/2018 18:51:50' prior: 50408802!
      messageListMenuOptions
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'what to show...'.
				#selector 		-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'browse method (O)'.
				#selector 		-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect CompiledMethod'.
				#object 			-> 		#model.
				#selector 		-> 		#inspectCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'senders of... (n)'.
				#selector 		-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'implementors of... (m)'.
				#selector 		-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'inheritance (i)'.
				#selector 		-> 		#methodHierarchy.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'versions (v)'.
				#selector 		-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'class variables'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'run test (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'debug test (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 19:04:27' prior: 50403505!
                             systemCatSingletonMenuOptions

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse all'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'update'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 19:02:29' prior: 50403553!
     systemCategoryMenuOptions

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'recent classes... (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#recent.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse all'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editSystemCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'alphabetize'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeSystemCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'update'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'add item...'.
				#object 			-> 		#model.
				#selector 		-> 		#addSystemCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'move to top'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryTop.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'move up'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryUp.
				#icon 			-> 		#goUpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'move down'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryDown.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		40.
				#label 			-> 		'move to bottom'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryBottom.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runSystemCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !
!MessageSetWindow methodsFor: 'menu building' stamp: 'HAW 7/7/2018 18:31:51' prior: 50404033!
  addExtraMenu2ItemsTo: options
	"The shifted selector-list menu is being built.  Add items specific to MessageSet"

	model growable ifTrue: [
		options add: `{
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		31.		
			#label 			-> 		'remove from this browser'.
			#object 			-> 		#model.
			#selector 		-> 		#removeMessageFromBrowser.
			#icon 			-> 		#listRemoveIcon 
		} asDictionary`.
		options add:`{
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		32.		
			#label 			-> 		'filter message list...'.
			#selector 		-> 		#filterMessageList.
			#icon 			-> 		#findIcon
		} asDictionary`	].
	
	options add: `{
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		33.		
			#label 			-> 		'sort by date'.
			#object 			-> 		#model.	
			#selector 		-> 		#sortByDate.
			#icon 			-> 		#dateIcon
		} asDictionary`.

! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'HAW 7/5/2018 18:37:46' prior: 50403756!
                              worldMenuOptions

	^`{{
		#itemGroup 		-> 		10.
		#itemOrder 		-> 		10.
		#label 			-> 		'Open...'.
		#selector 		-> 		#openOpenMenu.
		#icon 			-> 		#openIcon.
		#balloonText 	-> 		'Submenu to open various system tools'.
	} asDictionary.
	{
		#itemGroup 		-> 		10.
		#itemOrder 		-> 		20.
		#label 			-> 		'New morph...'.
		#selector 		-> 		#newMorph.
		#icon 			-> 		#morphsIcon.
		#balloonText 	-> 		'Offers a variety of ways to create new objects'.
	} asDictionary.
	{
		#itemGroup 		-> 		10.
		#itemOrder 		-> 		30.
		#label 			-> 		'Preferences...'.
		#selector 		-> 		#openPreferencesMenu.
		#icon 			-> 		#preferencesIcon.
		#balloonText 	-> 		'Opens a menu offering many controls over appearance and system preferences.'.
	} asDictionary.
				{
		#itemGroup 		-> 		10.
		#itemOrder 		-> 		40.
		#label 			-> 		'Windows...'.
		#selector 		-> 		#openWindowsMenu.
		#icon 			-> 		#windowIcon.
		#balloonText 	-> 		'Manage open windows'.
	} asDictionary.
	{
		#itemGroup 		-> 		10.
		#itemOrder 		-> 		50.
		#label 			-> 		'Help...'.
		#selector 		-> 		#openHelpMenu.
		#icon 			-> 		#helpIcon.
		#balloonText 	-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
	} asDictionary.
	{
		#itemGroup 		-> 		20.
		#itemOrder 		-> 		10.
		#label 			-> 		'Changes...'.
		#selector 		-> 		#openChangesMenu.
		#icon 			-> 		#changesIcon.
		#balloonText 	-> 		'Opens a menu of useful tools for dealing with changes'.
	} asDictionary.
	{
		#itemGroup 		-> 		20.
		#itemOrder 		-> 		20.
		#label 			-> 		'Debug...'.
		#selector 		-> 		#openDebugMenu.
		#icon 			-> 		#debugIcon.
		#balloonText 	-> 		'a menu of debugging items'.
	} asDictionary.
	{
		#itemGroup 		-> 		20.
		#itemOrder 		-> 		30.
		#label 			-> 		'Restore Display (r)'.
		#object 			-> 		#myWorld.
		#selector 		-> 		#restoreDisplay.
		#icon 			-> 		#displayIcon.
		#balloonText 	-> 		'Repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'.
	} asDictionary.
	{
		#itemGroup 		-> 		30.
		#itemOrder 		-> 		10.
		#label 			-> 		'Save'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveSession.
		#icon 			-> 		#saveIcon.
		#balloonText 	-> 		'Save the current version of the image on disk'.
	} asDictionary.
	{
		#itemGroup 		-> 		30.
		#itemOrder 		-> 		20.
		#label 			-> 		'Save as...'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveAs.
		#icon 			-> 		#saveAsIcon.
		#balloonText 	-> 		'Save the current version of the image on disk under a new name.'.
	} asDictionary.
	{
		#itemGroup 		-> 		30.
		#itemOrder 		-> 		30.
		#label 			-> 		'Save as New Version'.
		#object 			-> 		Smalltalk.
		#selector 		-> 		#saveAsNewVersion.
		#icon 			-> 		#saveAsNewVersionIcon.
		#balloonText 	-> 		('Save the current image a new version-stamped name\and save it under that name on disk.\',
										'Clear all user preferences and user state (class vars).') withNewLines.
	} asDictionary.
	{
		#itemGroup 		-> 		30.
		#itemOrder 		-> 		40.
		#label 			-> 		'Save and Quit'.
		#selector 		-> 		#saveAndQuit.
		#icon 			-> 		#saveAndQuitIcon.
		#balloonText 	-> 		'Save the image and quit out of Cuis.'.
	} asDictionary.
	{
		#itemGroup 		-> 		30.
		#itemOrder 		-> 		50.
		#label 			-> 		'Quit'.
		#selector 		-> 		#quitSession.
		#icon 			-> 		#quitIcon.
		#balloonText 	-> 		'Quit out of Cuis.'.
	} asDictionary.
}`! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3433-FixSomeTabbing-JuanVuletich-2018Sep02-23h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 3 September 2018 at 12:04:11 am'!
!Number methodsFor: 'printing' stamp: 'jmv 9/3/2018 00:03:09' prior: 50371628!
              withBinaryUnitPrefixAndValue: aBlock
	"
	As in https://en.wikipedia.org/wiki/Binary_prefix
	{ 0.123456. 1.23456. 12.3456. 123.456. 1234.56. 12345.6. 123456. 1234560. 12345600 } do: [ :n | n withBinaryUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName | {value printString, ' ', unitPrefixSymbol. unitPrefixName} print]]
	"
	| prefixIndex factor nameAndSymbol |
	prefixIndex _ self log floor // 3.
	prefixIndex _ prefixIndex min: 8 max: 0.
	factor _ 1024 raisedToInteger: prefixIndex.
	nameAndSymbol _ {
		{''. 		''}.
		{'kibi'.	'Ki'}.
		{'mebi'.	'Mi'}.
		{'gibi'.	'Gi'}.
		{'tebi'.	'Ti'}.
		{'pebi'.	'Pi'}.
		{'exbi'.	'Ei'}.
		{'zebi'.	'Zi'}.
		{'yobi'.	'Yi'}
	} at: prefixIndex+1.
	aBlock value: (self / factor) asIntegerOrFloat value: nameAndSymbol second value: nameAndSymbol first! !
!Number methodsFor: 'printing' stamp: 'jmv 9/3/2018 00:03:34' prior: 50371656!
                withDecimalUnitPrefixAndValue: aBlock
	"
	As in https://en.wikipedia.org/wiki/Metric_prefix
	{ 0.00000123456. 0.0000123456. 0.000123456. 0.00123456. 0.0123456. 0.123456. 1.23456. 12.3456. 123.456. 1234.56. 12345.6. 123456. 1234560. 12345600 } do: [ :n | n withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName | {value printString, ' ', unitPrefixSymbol. unitPrefixName} print]]
	"
	| prefixIndex factor nameAndSymbol |
	prefixIndex _ self log floor // 3.
	prefixIndex _ prefixIndex min: 6 max: -6.
	factor _ 1000 raisedToInteger: prefixIndex.
	nameAndSymbol _ {
		{'atto'.		'a'}.
		{'femto'.	'f'}.
		{'pico'.		'p'}.
		{'nano'.		'n'}.
		{'micro'.	''}.
		{'milli'.	'm'}.
		{''. 			''}.
		{'kilo'.		'k'}.
		{'mega'.		'M'}.
		{'giga'.		'G'}.
		{'tera'.		'T'}.
		{'peta'.		'P'}.
		{'exa'.		'E'}
	} at: prefixIndex+7.
	aBlock value: self asFloat / factor value: nameAndSymbol second value: nameAndSymbol first! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'jmv 9/3/2018 00:03:51' prior: 50411086!
    smalltalkEditorMenuOptions
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 		-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 		-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 		-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 		-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'Debug it (D)'.
				#selector 		-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		60.
				#label 			-> 		'Profile it'.
				#selector 		-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Explain'.
				#selector 		-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 		-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 		-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 		-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 		-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 		-> 		#methodStringsContainingit.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Method Source with it'.
				#selector 		-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 		-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 		-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 		-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 		-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 		-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`! !
!Transcript class methodsFor: 'preferred protocol' stamp: 'jmv 9/3/2018 00:04:05' prior: 16938264!
      clear

	accessSemaphore critical: [
		"Having at least one entry simplifies handling of the entries circular collection"
		firstIndex _ 1.
		lastIndex _ 1.
		entries at: 1 put: 'Transcript'.
		unfinishedEntry reset.
		lastDisplayPosition _ 0.
		
		logToFile ifTrue: [
			self filename asFileEntry forceWriteStreamDo: [ :stream |
				stream nextPutAll: 'Transcript log started: '.
				DateAndTime now printOn: stream.
				stream
					newLine;
					nextPutAll: '------------------------------------------------------------------------';
					newLine ]]].
	self display! !
!Transcript class methodsFor: 'preferred protocol' stamp: 'jmv 9/3/2018 00:04:08' prior: 16938303!
   clearInternal

	accessSemaphore critical: [
		"Having at least one entry simplifies handling of the entries circular collection"
		firstIndex _ 1.
		lastIndex _ 1.
		entries at: 1 put: 'Transcript'.
		unfinishedEntry reset.
		lastDisplayPosition _ 0 ].
	self display! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 9/3/2018 00:03:40' prior: 16892604!
                       preDebugButtonSpec

	^{
		{'Proceed'.		#proceed. 	'continue execution' }.
		{'Abandon'.		#abandon. 	'abandon this execution by closing this window' }.
		{'Debug'.		#debug.		'bring up a debugger' }
	}! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3434-FixSomeTabbing-JuanVuletich-2018Sep03-00h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 3 September 2018 at 12:07:09 am'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 9/3/2018 00:05:26' prior: 50410370!
                     smoothStep
	"A Function that is
		x <= -1 		-> 		1
		-1 < x < 1 	->			smooth differentiable transition from 1 to 0
		1 <= x 		-> 		0
	
	It is a 'smooth' version of an #negative
	Has countless applications. For example in image and signal processing, but also in other fields."
	"
	| g |
	Feature require: 'Morphic-Widgets-Extras'.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x abs < 1 ifTrue: [1] ifFalse:[0] ] color: Color brown.
	g addFunction: [ :x | x smoothStep ] color: Color red.
	(g embeddedInMorphicWindowLabeled: 'graph') openInWorld
	"
	self > -1 ifFalse: [ ^ 1 ].
	1 > self ifFalse: [ ^ 0 ].
	^ (self +2 * Float halfPi) sin * 0.5 + 0.5! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 9/3/2018 00:05:46' prior: 50374220!
                            mouseScroll: aMouseEvent localPosition: localEventPosition
	aMouseEvent direction
		caseOf: {
			[ #up ] 		-> 		[  scrollBar scrollUp: 1 ].
			[ #down ] 	-> 		[ scrollBar scrollDown: 1 ].
			[ #left ] 	-> 		[  hScrollBar scrollUp: 1 ].
			[ #right ] 	-> 		[  hScrollBar scrollDown: 1 ] }! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 9/3/2018 00:06:36' prior: 50396930!
    helpMenu
	"Build the help menu for the world."

	^ (self menu: 'Help...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#aboutThisSystem.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'current version information.'
			} asDictionary.
			{
				#label 			-> 		'Terse Guide to Cuis'.
				#selector 		-> 		#openTerseGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#label 			-> 		'Class Comment Browser'.
				#selector 		-> 		#openCommentGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCodeManagementInCuis.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCuisAndGitHub.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'GitHub usage pattern.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 	-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 	-> 		'a window full of useful expressions.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'VM Statistics'.
				#selector 		-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 	-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#label 			-> 		'Space Left'.
				#selector 		-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 	-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3435-FixSomeTabbing-JuanVuletich-2018Sep03-00h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 3 September 2018 at 12:08:37 am'!
!LayoutSpec commentStamp: 'jmv 9/3/2018 00:07:43' prior: 16864138!
                          LayoutSpecs are the basis for the layout mechanism. Any Morph can be given a LayoutSpec, but in order to honor it, its owner must be a LayoutMorph.

A LayoutSpec specifies how a morph wants to be layed out. It can specify either a fixed width or a fraction of some available owner width. Same goes for height. If a fraction is specified, a minimum extent is also possible.


Alternatives:
	- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width
	- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width
	- proportionalWidth isNil, fixedWidth notNil		->		Use fixedWidth
	- proportionalWidth notNil, fixedWidth isNil		->		NOT VALID

Same goes for proportionalHeight and fixedHeight
!
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 9/3/2018 00:08:13' prior: 16864261!
             proportionalWidth: aNumberOrNil minimum: otherNumberOrNil
	"Alternatives:
		- proportionalWidth notNil, fixedWidth notNil 	->		Use fraction of available space, take fixedWidth as minimum desired width
		- proportionalWidth isNil, fixedWidth isNil  	->		Use current morph width
		- proportionalWidth isNil, fixedWidth notNil 	->		Use fixedWidth
		- proportionalWidth notNil, fixedWidth isNil 	->		NOT VALID"
	proportionalWidth _ aNumberOrNil.
	fixedWidth _ otherNumberOrNil! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 9/3/2018 00:08:20' prior: 16864285!
                setProportionalWidth: aNumberOrNil
	"Alternatives:
		- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width
		- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width
		- proportionalWidth isNil, fixedWidth notNil		->		Use fixedWidth
		- proportionalWidth notNil, fixedWidth isNil		->		NOT VALID"
	proportionalWidth _ aNumberOrNil! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3436-FixSomeTabbing-JuanVuletich-2018Sep03-00h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3436] on 6 September 2018 at 6:13:28 pm'!
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/6/2018 17:51:29'!
     argNext: aKeyboardEvent
	"Invoked by cmd-A.
	 Search forward from the end of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the end of the text.."

	| start t |
	t _ model actualContents.
	start _ t findString: ': ' startingAt: self startIndex.
	start = 0 ifTrue: [ start _ t size + 1].
	self deselectAndPlaceCursorAt: start + 2.
	^true! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/6/2018 18:09:53'!
                              argPrev: aKeyboardEvent
	"Invoked by cmd-Q.
	 Search backwards from the start of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the start of the text.."

	| t i |
	t _ model actualContents.
	i _ self stopIndex.
	i > 1 ifTrue: [
		i _ i -2.
		[i > 0 and: [ (t at: i) ~= $  or: [(t at: i-1) ~= $: ]]] whileTrue: [
			i _ i -1 ].
		self deselectAndPlaceCursorAt: i + 1.
	].
	^true! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 9/6/2018 17:56:10' prior: 16906691!
        quickFindLast: aBlock
	"Return the index of my last element for which aBlock evaluates as true.
	Assumes that receiver is sorted according with aBlock. Then, we are able to use faster binary search.
	Result is (in these cases) the same as #findLast:
	
	1 to: 1000 :: findLast: [:x | x squared < 123456]
	1 to: 1000 :: quickFindLast: [:x | x squared < 123456]
	
	1 to: 1000 :: findLast: [:x | x squared < -10]
	1 to: 1000 :: quickFindLast: [:x | x squared < -10]

	1 to: 1000 :: findLast: [:x | x squared < 1234560]
	1 to: 1000 :: quickFindLast: [:x | x squared < 1234560]
	"
	^self
		findBinaryIndex: [ :x | (aBlock value: x) ifTrue: [1] ifFalse: [-1]]
		do: [ :i | ]
		ifNone: [ :i1 :i2 | i1 ]! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/6/2018 17:47:15' prior: 16910004!
 displayIfFalse: aKeyboardEvent
	"Replace the current text selection with the text 'ifFalse:'--initiated by 
	cmd-F."

	self addString: 'ifFalse:'.
	^false! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 9/6/2018 17:47:27' prior: 16910012!
                             displayIfTrue: aKeyboardEvent
	"Replace the current text selection with the text 'ifTrue:'--initiated by 
	cmd-T."

	self addString: 'ifTrue:'.
	^false! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/6/2018 17:50:48' prior: 50405362!
                       cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$Q	#argPrev:							'Previous argument')
		#(		$A	#argNext:							'Next argument')
		#(		$D	#debugIt:							'Debug it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 9/6/2018 17:40:31' prior: 50366939!
handleKeystrokeBefore: kbEvent
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	| currentPos currentChar currentCharIsAlphaNumericOrColon keyValue ctrl cmd tab colon alphanum backspace esc space return keyChar  |
	currentPos _ textMorph editor startIndex-1.
	currentCharIsAlphaNumericOrColon _ currentPos > 0 and: [ model textSize >= currentPos and: [
			currentChar _ model actualContents at: currentPos. currentChar isAlphaNumeric | (currentChar == $:) ]].
	keyValue _ kbEvent keyValue.
	keyChar _ kbEvent keyCharacter.
	ctrl _ kbEvent controlKeyPressed.
	cmd _ kbEvent commandAltKeyPressed.
	tab _ keyChar = Character tab.
	colon _ keyChar = $:.
	alphanum _ kbEvent keyCharacter isAlphaNumeric.
	backspace _ keyValue = 8.
	esc _ keyValue = 27.
	space _ #(0 32 160) includes: keyValue.
	return _ kbEvent isReturnKey.

	"Stuff to do if the menu is not open"
	menuMorph ifNil: [
		"Ctrl-Space or Tab for open"
		"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
		(space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [
			(self opensWithTab and: [tab]) and: [ currentCharIsAlphaNumericOrColon ]])
				ifTrue: [ self openCompletionMenu. ^ true].
		"Auto-open - currently deactivated"
"		(ctrl not & cmd not & alphanum) 
			ifTrue: [ self openCompletionMenu ]."
		^ false].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	"Escape"
	esc ifTrue: [ self closeMenu. ^ true].
	"Backspace"
	backspace ifTrue: [
		currentCharIsAlphaNumericOrColon ifFalse: [ self closeMenu ].
		^ false].
	"Home"
	keyValue = 1 ifTrue: [ menuMorph goHome. ^ true ].
	"End"
	keyValue = 4 ifTrue: [ menuMorph goToEnd. ^ true].
	"?"
	keyChar = $? ifTrue: [ menuMorph help. ^true].
	"Arrow up"
	keyValue = 30 ifTrue: [ menuMorph goUp. ^ true].
	"Arrow down"
	keyValue = 31 ifTrue: [ menuMorph goDown. ^ true].
	"Page up"
	keyValue = 11 ifTrue: [ menuMorph goPageUp. ^ true].
	"Page down"
	keyValue = 12 ifTrue: [ menuMorph goPageDown. ^ true].
	"Return, Tab or Ctrl-Space"
	(return or: [ space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [ tab]]) ifTrue: [
		self insertSelected
			ifTrue: [^ true]].
	"All keys but the alphanumeric chars (without command and control ) 
	and the backspace key do close the menu"
	(ctrl not & cmd not and: [ alphanum | colon])
		ifFalse: [ self closeMenu ].
	^false! !

SmalltalkEditor removeSelector: #argAdvance:!

SmalltalkEditor removeSelector: #argAdvance:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3437-NextArgument-PreviousArgument-JuanVuletich-2018Sep06-18h13m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3437] on 10 September 2018 at 9:12:16 am'!
!Time class methodsFor: 'smalltalk-80' stamp: 'jmv 9/10/2018 09:11:34' prior: 16937449!
                        readFrom: aStream
	"Read a Time from the stream in the form:
		<hour>:<minute>:<second> <am/pm>

	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"

	| hour minute second ampm nanos nanosBuffer |
	hour := Integer readFrom: aStream.
	minute := 0.
	second := 0.
	nanosBuffer := '000000000' copy.
	nanos := WriteStream on: nanosBuffer.
	(aStream peekFor: $:) 
		ifTrue: [
			minute := Integer readFrom: aStream.
			(aStream peekFor: $:) 
				ifTrue: [
					second := Integer readFrom: aStream].
					(aStream peekFor: $.)
						ifTrue: [
							[aStream atEnd not and: [aStream peek isDigit]]
								whileTrue: [nanos nextPut: aStream next]]].
	aStream skipSeparators.
	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: 
		[ampm := aStream next asLowercase.
	
	(ampm = $p and: [hour < 12]) ifTrue: [hour := hour + 12].
		(ampm = $a and: [hour = 12]) ifTrue: [hour := 0].
	
	(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].
	^ self 
		hour: hour 
		minute: minute 
		second: second 
		nanoSecond: nanosBuffer asNumber

	"Time readFrom: (ReadStream on: '2:23:09 pm')"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3438-Avoid-String-asInteger-JuanVuletich-2018Sep10-09h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3437] on 10 September 2018 at 9:10:09 am'!

ImageReadWriter removeSelector: #space!

ImageReadWriter removeSelector: #space!

ImageReadWriter removeSelector: #tab!

ImageReadWriter removeSelector: #tab!

Stream removeSelector: #nextNumber!

Stream removeSelector: #nextNumber!

Stream removeSelector: #nextNumber:!

Stream removeSelector: #nextNumber:!

Stream removeSelector: #nextNumber:put:!

Stream removeSelector: #nextNumber:put:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3439-Cleanup-JuanVuletich-2018Sep10-09h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3439] on 10 September 2018 at 9:16:29 am'!
!Integer class methodsFor: 'instance creation' stamp: 'GC 9/10/2018 00:18:57' prior: 50331667!
                           readFrom: aStream base: base
	"Answer an instance of one of my concrete subclasses. Initial minus sign
	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
	allowed--use Number readFrom: for that. Raises an error if
	there are no digits."

	| digit value neg cc atLeastOneDigitRead |
	
	(aStream atEnd) ifTrue: [ self error: 'At least one digit expected here' ].
	
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	atLeastOneDigitRead _ false.
	[ aStream atEnd ]
		whileFalse: [
			cc _ aStream next.
			digit _ cc digitValue.
			(digit < 0 or: [digit >= base])
				ifTrue: [
					aStream skip: -1.
					atLeastOneDigitRead ifFalse: [self error: 'At least one digit expected here'].
					^neg
						ifTrue: [value negated]
						ifFalse: [value]].
			value _ value * base + digit.
			atLeastOneDigitRead _ true ].
	neg ifTrue: [^ value negated].
	^ value! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3440-Integer-readFrom-ErrorIfEmpty-GastonCaruso-2018Sep10-09h16m-GC.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3437] on 10 September 2018 at 10:25:41 am'!
!TestSuite class methodsFor: 'Creation - Private' stamp: 'jmv 9/10/2018 10:24:54' prior: 50338365!
forTestCaseClasses: testCaseClasses named: aName

	| suite |
	suite _ self named: aName.
	testCaseClasses do: [ :aTestCaseClass |
			aTestCaseClass isAbstract
				ifFalse: [ aTestCaseClass addToSuiteFromSelectors: suite ]].
		
	^suite! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3441-TestSystemCategory-fix-JuanVuletich-2018Sep10-10h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3440] on 10 September 2018 at 12:01:49 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 9/10/2018 12:01:33' prior: 50401198!
       knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons ')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3442-AddGastonAsAuthor-JuanVuletich-2018Sep10-10h35m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3442] on 16 September 2018 at 10:20:05 am'!
!PseudoClass methodsFor: 'accessing' stamp: 'JO 9/16/2018 10:19:39'!
  variablesAndOffsetsDo: aBinaryBlock
	"NOp"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3443-PackageFileBrowserFix-JavierOlaechea-2018Sep16-10h19m-JO.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3443] on 16 September 2018 at 10:48:40 am'!
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:45:54'!
         resizeBottomIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:46:11'!
          resizeBottomLeftIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:46:15'!
      resizeBottomRightIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:45:41'!
     resizeFullIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:45:50'!
            resizeLeftIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:45:59'!
            resizeRightIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:45:46'!
           resizeTopIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:46:03'!
             resizeTopLeftIcon
	^nil! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/16/2018 10:46:07'!
         resizeTopRightIcon
	^nil! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3444-PlaceholdersForResizeWindowIcons-JuanVuletich-2018Sep16-10h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3368] on 14 September 2018 at 9:47:11 pm'!

BorderedRectMorph subclass: #TileResizeMorph
	instanceVariableNames: 'selectedResize selectionColor action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #TileResizeMorph category: #'Morphic-Views'!
BorderedRectMorph subclass: #TileResizeMorph
	instanceVariableNames: 'selectedResize selectionColor action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!Preferences class methodsFor: 'get/set' stamp: 'MM 9/14/2018 10:03:28'!
                        disableTileResizerInWindowMenu

	Preferences disable: #tileResizerInWindowMenu.! !
!Preferences class methodsFor: 'get/set' stamp: 'MM 9/14/2018 10:03:16'!
    enableTileResizerInWindowMenu

	Preferences enable: #tileResizerInWindowMenu.! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 09:40:43'!
                            action: aBlock
	action _ aBlock! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 11:34:14'!
          drawOn: aCanvas

	super drawOn: aCanvas.
	
	selectedResize ifNil: [^ self].
	
	aCanvas fillRectangle: (self selectionRectangle: selectedResize) 
			color: selectionColor
			borderWidth: borderWidth
			borderStyleSymbol: #simple
			baseColorForBorder: borderColor.! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 09:41:56'!
  handlesMouseDown: aMouseButtonEvent

	^ true! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 09:44:47'!
                             handlesMouseHover
	^ true! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/14/2018 18:08:50'!
                initialize

	super initialize.
	extent _ 120@60.
	color _ Color white.
	selectionColor _ Color lightYellow .
	self borderColor: Color black.
	self borderWidth: 1.! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 11:20:20'!
       mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	self selectResize: localEventPosition! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 11:20:57'!
                             mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectResize: localEventPosition.
	action ifNotNil: [
		action value: selectedResize.
		self delete]! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 11:10:21'!
                           mouseHover: aMouseButtonEvent localPosition: localEventPosition
	self selectResize: localEventPosition! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 11:37:24'!
   resizeAtPoint: aPoint
	
	|region|
		
	region _ (aPoint min: extent - 1) // (extent // 3).
	
	^ region caseOf: {
		[0@0] -> [#topLeft].
		[1@0] -> [#top].
		[2@0] -> [#topRight].
		[0@1] -> [#left].
		[1@1] -> [#full].
		[2@1] -> [#right].
		[0@2] -> [#bottomLeft].
		[1@2] -> [#bottom].
		[2@2] -> [#bottomRight].
	} otherwise: [nil]! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 11:03:57'!
                            selectResize: localEventPosition

	| newResize |
	
	newResize _ self resizeAtPoint: localEventPosition.
	newResize ~= selectedResize ifTrue: [
		selectedResize _ newResize.
		self redrawNeeded]! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/14/2018 18:10:14'!
        selectionColor: aColor

	selectionColor _ aColor! !
!TileResizeMorph methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 11:33:29'!
                         selectionRectangle: region

	^ region caseOf: {
		[#topLeft] -> [0@0 corner: (extent // 2)].
		[#top] -> [0@0 corner: (extent x@(extent y // 2))].
		[#topRight] -> [(extent x // 2)@0 corner: (extent x@(extent y // 2))].
		[#left] -> [0@0 corner: (extent x // 2)@extent y].
		[#full] -> [0@0 corner: extent].
		[#right] -> [(extent x // 2)@0 corner: extent].
		[#bottomLeft] -> [0@(extent y // 2) corner: (extent x // 2)@extent y].
		[#bottomRight] -> [(extent x // 2)@(extent y // 2) corner: extent].
		[#bottom] -> [0@(extent y // 2) corner: extent].
	}! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 16:11:37'!
                         calculateTileRegions: aNumber
	
	^ self calculateTileRegionsIn: Display boundingBox by: aNumber! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 18:25:19'!
    calculateTileRegionsHorizontallyIn: aRectangle by: aNumber

	| rects rects1 rects2 |
	aNumber <= 2 ifTrue: [^ self divideRectHorizontally: aRectangle by: aNumber].
	
	rects _ self divideRectHorizontally: aRectangle by: 2.

	rects1 _ self calculateTileRegionsVerticallyIn: rects first by: aNumber // 2.
	rects2 _  self calculateTileRegionsVerticallyIn: rects second by: (aNumber - (aNumber // 2)). 
	
	^ rects1, rects2! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 16:13:08'!
  calculateTileRegionsIn: aRectangle by: aNumber
	
	^ self calculateTileRegionsHorizontallyIn: aRectangle by: aNumber! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 16:20:53'!
                calculateTileRegionsVerticallyIn: aRectangle by: aNumber

	| rects rects1 rects2 |
	aNumber <= 3 ifTrue: [^ self divideRectVertically: aRectangle by: aNumber].
	
	rects _ self divideRectVertically: aRectangle by: 2.

	rects1 _ self calculateTileRegionsHorizontallyIn: rects first by: aNumber // 2.
	rects2 _  self calculateTileRegionsHorizontallyIn: rects second by: (aNumber - (aNumber // 2)). 
	
	^ rects1, rects2! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 16:08:58'!
    divideRectHorizontally: aRectangle by: aNumber

	| w x rects |
	
	x _ aRectangle origin x.
	w _ aRectangle width // aNumber.
	rects _ OrderedCollection new.
	
	aNumber timesRepeat: [ |rect|
		rect _ Rectangle origin: x@aRectangle origin y extent: w@aRectangle height.
		x _ x + w.
		rects add: rect].
	
	 ^ rects
	
	! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 16:10:57'!
       divideRectVertically: aRectangle by: aNumber

	| h y rects |
	
	y _ aRectangle origin y.
	h _ aRectangle height // aNumber.
	rects _ OrderedCollection new.
	
	aNumber timesRepeat: [ |rect|
		rect _ Rectangle origin: aRectangle origin x@y extent: aRectangle width@h.
		y _ y + h.
		rects add: rect].
	
	 ^ rects
	
	! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/14/2018 10:01:07'!
         initialize

	Preferences
		addPreference: #tileResizerInWindowMenu
		category: #gui 
		default: true
		balloonHelp: 'If enabled, a tile resizer morph is embedded in windows menus.' withNewLines! !
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/13/2018 15:59:18'!
  tileOpenWindows
	
	|windows regions i |
	
	windows _ (SystemWindow
		windowsIn: self runningWorld
		satisfying: [ :w | w visible]).
		
	regions _ self calculateTileRegions: windows size.
	
	i _ 1.
	windows do: [:w | |r|
		r _ regions at: i.
		w resize: r.
		i _ i + 1]! !
!SystemWindow methodsFor: 'menu' stamp: 'MM 9/14/2018 18:21:38' prior: 50399917!
                               buildWindowMenu

	| aMenu |

	aMenu _ MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' 				action: #relabel 						icon: #saveAsIcon;
		add: 'window color...' 			action: #setWindowColor 			icon: #graphicsIcon;
		addLine;
		add: 'send to back' 				action: #sendToBack 				icon: #goBottomIcon;
		add: 'make next-to-topmost' 	action: #makeSecondTopmost 	icon: #goUpIcon;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ])
											action: #toggleStickiness 			icon: (self isSticky ifFalse: [#pushPinIcon]);
		addLine;
		add: 'close' 						action: #delete 						icon: #closeIcon;
		add: 'collapse' 					action: #collapse 						icon: #collapseIcon;
		add: 'expand / contract' 		action: #expandBoxHit 				icon: #expandIcon;
		addLine;
		add: 'resize...' 					action: #resize.
	"We can look at preferences here to decide what too do"
	(Preferences tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 					action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 					action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 			action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 		action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].

	^ aMenu! !
!TheWorldMenu methodsFor: 'windows & flaps menu' stamp: 'MM 9/14/2018 21:42:58' prior: 50397138!
                windowsMenu
        "Build the windows menu for the world."

	^ (self menu: 'Windows')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Tile open windows'.
				#object            ->       TileResizeMorph.
				#selector 		-> 		#tileOpenWindows.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Tile open windows'.
			} asDictionary.
			{
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 		-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#label 			-> 		'Delete Both of the Above'.
				#selector 		-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'
			} asDictionary.
		}`! !

TileResizeMorph initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3445-TileWindowResize-MarianoMontone-2018Sep13-01h34m-MM.4.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 18 September 2018 at 5:08:42 pm'!
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 9/18/2018 17:08:36'!
                         nextNumber
	"Answer a number from the (text) stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element = $- or: [element = $)]]]] whileFalse.
	element ifNil: [^nil].
	self skip: -1.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3446-Reintroduce-Stream-nextNumber-JuanVuletich-2018Sep18-17h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3445] on 17 September 2018 at 5:37:57 pm'!
!TileResizeMorph class methodsFor: 'as yet unclassified' stamp: 'MM 9/17/2018 17:36:57' prior: 50413240!
                         tileOpenWindows
	
	|windows regions i |
	
	windows _ (SystemWindow
		windowsIn: self runningWorld
		satisfying: [ :w | w visible]).
		
	windows ifEmpty: [^ self].
		
	regions _ self calculateTileRegions: windows size.
	
	i _ 1.
	windows do: [:w | |r|
		r _ regions at: i.
		w resize: r.
		i _ i + 1]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3447-tileWindowsFixWhenNoWindows-MarianoMontone-2018Sep17-17h36m-MM.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 19 September 2018 at 10:17:16 am'!
!ContentPack methodsFor: 'exporting' stamp: 'jmv 9/19/2018 10:08:59' prior: 16823316!
        exportInto: aDirectory

	aDirectory assureExistence.

	self associations do: [ :assoc |
		| klass thisDirectory fullPath | 
			klass _ assoc value class.
			thisDirectory _ aDirectory / assoc key.
			fullPath _  (aDirectory // assoc key) pathName.

		self flag: #note. "Add support for new file export type mappings here. --cbr"
		klass = ContentPack
			ifTrue: [ assoc value exportInto: thisDirectory ].
		
		klass = ColorForm
			ifTrue: [ assoc value writeBMPfileNamed: fullPath ].
			
		klass = Form
			ifTrue: [ assoc value writeBMPfileNamed: fullPath ]
	]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3448-ContentPackFix-JuanVuletich-2018Sep19-10h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 19 September 2018 at 10:17:34 am'!
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 9/19/2018 10:17:18' prior: 16841766!
                basicDirectoryExists: fullPathName

	| result |
	result := self primLookupEntryIn: fullPathName index: 1.
	result ifNil: [ ^ false ].
 	^(result == #badDirectoryPath) not! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3449-basicDirectoryExists-fix-JuanVuletich-2018Sep19-10h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3449] on 21 September 2018 at 5:02:42 pm'!
!ContentPack methodsFor: 'importing' stamp: 'jmv 9/21/2018 16:13:27'!
                              loadContentFrom: aDirectoryEntry
	
	| contentPacks |

	(self supportedFilesIn: aDirectoryEntry) do: [ :filename |			
		self flag: #todo. "Add hook for other media types here. Also consider renaming this method. --cbr"
		self at: filename name 
			put: (self import: [ Form fromFileEntry: filename ]) "This may yet be a cross-cutting concern, and need to be refactored when other media types become present. --cbr"
	].

	contentPacks _ aDirectoryEntry directoryNames collect: [ :i |
		i ->  (ContentPack new loadContentFrom: aDirectoryEntry / i)
	].
	
	^ self union: (contentPacks as: Dictionary)! !
!ContentPack class methodsFor: 'instance creation' stamp: 'jmv 9/21/2018 16:30:21'!
                     import
	"
	Feature require: 'Graphics-Files-Additional'.
	Theme content export.
	ContentPack import.
	Theme bootstrap.
	"
	
	^ self new loadContentFrom: self exportDirectory! !
!ContentPack class methodsFor: 'configuration' stamp: 'jmv 9/21/2018 16:07:27'!
                               exportDirectory
	
	^ DirectoryEntry smalltalkImageDirectory / self defaultContentDirectory / 'Exported'! !
!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'jmv 9/21/2018 16:56:49'!
                         putForm: aForm onFile: fileEntry
	"Store the given form on a file of the given name."

	fileEntry forceWriteStreamDo: [ :stream |
		(self onBinaryStream: stream binary) nextPutImage: aForm ]! !
!ContentPack methodsFor: 'exporting' stamp: 'jmv 9/21/2018 16:07:38' prior: 16823304!
        export

	"Answer true on success."

	"self break."

	self class exportDirectory exists
		ifTrue: [ Utilities inform: 
			'Before you can export, you must move, rename or delete this directory: ' ,
			self exportDirectory pathName.
			
			^ false.
		].
	
	self exportInto: self class exportDirectory.
	
	^ true! !
!ContentPack methodsFor: 'exporting' stamp: 'jmv 9/21/2018 16:58:00' prior: 50413512!
                 exportInto: aDirectory

	| featureName |
	featureName _ 'Graphics-Files-Additional'.
	(FeatureRequirement name: featureName) isAlreadySatisfied
		ifFalse: [
			self error: 'Please load "', featureName, '".'].

	aDirectory assureExistence.

	self associations do: [ :assoc |
		| klass thisDirectory fullPath | 
			klass _ assoc value class.
			thisDirectory _ aDirectory / assoc key.
			fullPath _  aDirectory // assoc key.

		self flag: #note. "Add support for new file export type mappings here. --cbr"
		klass = ContentPack
			ifTrue: [ assoc value exportInto: thisDirectory ].
		
		klass = ColorForm
			ifTrue: [ assoc value writePNGfile: fullPath ].
			
		klass = Form
			ifTrue: [ assoc value writePNGfile: fullPath ]
	]! !
!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'jmv 9/21/2018 16:56:41' prior: 16854489!
                           putForm: aForm onFileNamed: filename
	"Store the given form on a file of the given name."

	self putForm: aForm onFile: filename asFileEntry! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:24:43' prior: 50412997!
    resizeBottomIcon
	"
	Theme current resizeBottomIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-bottom' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:25:13' prior: 50413000!
     resizeBottomLeftIcon
	"
	Theme current resizeBottomLeftIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-bottom-left' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:25:35' prior: 50413003!
                        resizeBottomRightIcon
	"
	Theme current resizeBottomRightIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-bottom-right' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:28:59' prior: 50413006!
                     resizeFullIcon
	"
	Theme current resizeFullIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:26:03' prior: 50413009!
                resizeLeftIcon
	"
	Theme current resizeLeftIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-left' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:26:25' prior: 50413012!
           resizeRightIcon
	"
	Theme current resizeRightIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-right' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:26:43' prior: 50413015!
        resizeTopIcon
	"
	Theme current resizeTopIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-top' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:27:13' prior: 50413018!
              resizeTopLeftIcon
	"
	Theme current resizeTopLeftIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-top-left' )! !
!Theme methodsFor: 'icons' stamp: 'jmv 9/21/2018 16:27:17' prior: 50413021!
 resizeTopRightIcon
	"
	Theme current resizeTopRightIcon
	"
	^ self fetch: #( '16x16' 'resize' 'resize-top-right' )! !
!Theme methodsFor: 'icon lookup' stamp: 'jmv 9/21/2018 16:21:17' prior: 50399888!
                        fetch: aTuple "	#( 'resolution' 'context' 'filename' )	"

	"Get an icon from Content. See icons protocol."

	| contentSpecifier icon themeGuess |
	
	icon _ nil.
	themeGuess _ self class.
	contentSpecifier _ self appendExtensionToContentSpec: aTuple.

	[ icon isNil ] 
		whileTrue: [
			icon _ self class content
				from: themeGuess name
				get: contentSpecifier.
	
			icon ifNotNil: [ ^ icon ].
	
			themeGuess = Theme
				ifTrue: [ ^ nil "See comment in ContentPack>>from:get: --cbr" ].
	
			themeGuess _ themeGuess superclass
		]! !
!Theme class methodsFor: 'importing/exporting' stamp: 'jmv 9/21/2018 16:08:35' prior: 16936871!
       bootstrap

	"Destructive. Loads up initial content."
	self flag: #todo. "Consider removal. --cbr"
	
	Content _ ContentPack import! !

ContentPack class removeSelector: #default!

ContentPack class removeSelector: #default!

ContentPack removeSelector: #exportDirectory!

ContentPack removeSelector: #exportDirectory!

ContentPack removeSelector: #path:!

ContentPack removeSelector: #path:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3450-ContentPack-fixes-JuanVuletich-2018Sep21-17h01m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3450] on 22 September 2018 at 3:33:36 pm'!
!Number class methodsFor: 'instance creation' stamp: 'jmv 9/22/2018 09:01:25' prior: 16880670!
                   readRemainderOf: integerPart from: aStream base: base withSign: sign
	"Read optional fractional part and exponent, and return the final result"
	| value fraction fracpos peekChar |

	value := integerPart.
	(aStream peekFor: $.)
		ifTrue: [		 "<integer>.<fraction>"
			(aStream atEnd not and: [ aStream peek digitValue between: 0 and: base - 1 ])
				ifTrue:  [
					fracpos := aStream position.
					fraction := Integer readFrom: aStream base: base.
					fraction := fraction / (base raisedTo: aStream position - fracpos).
					value := value asFloat + fraction]
				ifFalse: [
					"oops - just <integer>."
					aStream skip: -1.
					"un-gobble the period"
					^ value * sign"Number readFrom: '3r-22.2'"]].
	peekChar := aStream peek.
	peekChar = $e | (peekChar = $d) | (peekChar = $q)
		ifTrue: [			"<number>(e|d|q)<exponent>>"
			aStream next.
			(aStream atEnd not and: [ (aStream peek digitValue between: 0 and: 9) or: [ aStream peek = $- ]])
				ifTrue:  [
					value := value * (base raisedTo: (Integer readFrom: aStream)) ]
				ifFalse: [
					"oops - just <number>."
					aStream skip: -1.]].
	^(value isFloat
		and: [ value = 0.0 and: [ sign = -1 ]])
			ifTrue: [ Float negativeZero ]
			ifFalse: [ value * sign ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3451-NumberFromString-fix-JuanVuletich-2018Sep22-15h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3451] on 24 September 2018 at 11:00:42 am'!
!Number class methodsFor: 'instance creation' stamp: 'jmv 9/24/2018 11:00:21' prior: 50413750!
          readRemainderOf: integerPart from: aStream base: base withSign: sign
	"Read optional fractional part and exponent, and return the final result"
	| value fraction fracpos peekChar exp scale |

	value := integerPart.
	(aStream peekFor: $.)
		ifTrue: [		 "<integer>.<fraction>"
			(aStream atEnd not and: [ aStream peek digitValue between: 0 and: base - 1 ])
				ifTrue:  [
					fracpos := aStream position.
					fraction := Integer readFrom: aStream base: base.
					fraction := fraction / (base raisedToInteger: aStream position - fracpos).
					value := value asFloat + fraction]
				ifFalse: [
					"oops - just <integer>."
					aStream skip: -1.
					"un-gobble the period"
					^ value * sign"Number readFrom: '3r-22.2'"]].
	peekChar := aStream peek.
	peekChar = $e | (peekChar = $d) | (peekChar = $q)
		ifTrue: [			"<number>(e|d|q)<exponent>>"
			aStream next.
			(aStream atEnd not and: [ (aStream peek digitValue between: 0 and: 9) or: [ aStream peek = $- ]])
				ifTrue:  [
					exp := Integer readFrom: aStream.
					scale := base raisedToInteger: exp.
					value := (value isFloat and: [ scale asFloat < Float fminNormalized ])
						ifTrue: [
							"Avoid Float arithmetic to allow stuff like
								12345678901234567890.0e-330
								(Float fminNormalized / 10) storeString asNumber = ((Float fminNormalized / 10))
								"
							(value asTrueFraction * scale) asFloat ]
						ifFalse: [ value * scale ] ]
				ifFalse: [
					"oops - just <number>."
					aStream skip: -1.]].
	^(value isFloat
		and: [ value = 0.0 and: [ sign = -1 ]])
			ifTrue: [ Float negativeZero ]
			ifFalse: [ value * sign ]! !
!Float methodsFor: 'printing' stamp: 'jmv 9/24/2018 10:31:30' prior: 16845315!
absPrintExactlyOn: aStream base: base
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	This version guarantees that the printed representation exactly represents my value
	by using exact integer arithmetic."

	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |
	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].
	significand := self significandAsInteger.
	roundingIncludesLimits := significand even.
	exp := (self exponent - 52) max: MinValLogBase2.
	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue:
			[significand ~= 16r10000000000000
				ifTrue:
					[r := significand bitShift: 1 + exp.
					s := 2.
					mPlus := mMinus := 1 bitShift: exp]
				ifFalse:
					[r := significand bitShift: 2 + exp.
					s := 4.
					mPlus := 2 * (mMinus := 1 bitShift: exp)]]
		ifFalse:
			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000]) & false
				ifTrue:
					"jmv 2018-9-24. Deactivated. Makes the following false (See Tests package):"
					"
					| float |
					float _ (Float fminNormalized / 2) successor.
					float storeString asNumber = float
					"
					[r := significand bitShift: 1.
					s := 1 bitShift: 1 - exp.
					mPlus := mMinus := 1]
				ifFalse:
					[r := significand bitShift: 2.
					s := 1 bitShift: 2 - exp.
					mPlus := 2.
					mMinus := 1]].
	baseExpEstimate >= 0
		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]
		ifFalse:
			[scale := base raisedToInteger: baseExpEstimate negated.
			r := r * scale.
			mPlus := mPlus * scale.
			mMinus := mMinus * scale].
	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])
		ifTrue: [baseExpEstimate := baseExpEstimate + 1]
		ifFalse:
			[r := r * base.
			mPlus := mPlus * base.
			mMinus := mMinus * base].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue:
			[decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]
		ifFalse:
			[decPointCount := 1].
	slowbit := 1 - s lowBit .
	shead := s bitShift: slowbit.
	[d := (r bitShift: slowbit) // shead.
	r := r - (d * s).
	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |
	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:
		[aStream nextPut: (Character digitValue: d).
		r := r * base.
		mPlus := mPlus * base.
		mMinus := mMinus * base.
		decPointCount := decPointCount - 1.
		decPointCount = 0 ifTrue: [aStream nextPut: $.]].
	tc2 ifTrue:
		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue:
		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].
		aStream nextPutAll: '.0'].
	fixedFormat ifFalse:
		[aStream nextPut: $e.
		aStream nextPutAll: (baseExpEstimate - 1) printString]! !
!Float methodsFor: 'printing' stamp: 'jmv 9/24/2018 10:56:53' prior: 50405041!
   absPrintOn: aStream base: base
	"In Cuis, print Floats with enough digits to be able to recover later exactly the same Float."

	self absPrintExactlyOn: aStream base: base! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3452-FloatStringConversionFixes-JuanVuletich-2018Sep24-09h04m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3452] on 24 September 2018 at 1:41:19 pm'!
!Float methodsFor: 'printing' stamp: 'jmv 9/24/2018 13:40:33' prior: 50413852!
                  absPrintExactlyOn: aStream base: base
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	https://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
	This version guarantees that the printed representation exactly represents my value
	by using exact integer arithmetic."

	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |
	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].
	significand := self significandAsInteger.
	roundingIncludesLimits := significand even.
	exp := (self exponent - 52) max: MinValLogBase2.
	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue:
			[significand ~= 16r10000000000000
				ifTrue:
					[r := significand bitShift: 1 + exp.
					s := 2.
					mPlus := mMinus := 1 bitShift: exp]
				ifFalse:
					[r := significand bitShift: 2 + exp.
					s := 4.
					mPlus := 2 * (mMinus := 1 bitShift: exp)]]
		ifFalse:
			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])
				ifTrue:
					[r := significand bitShift: 1.
					s := 1 bitShift: 1 - exp.
					mPlus := mMinus := 1]
				ifFalse:
					[r := significand bitShift: 2.
					s := 1 bitShift: 2 - exp.
					mPlus := 2.
					mMinus := 1]].
	baseExpEstimate >= 0
		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]
		ifFalse:
			[scale := base raisedToInteger: baseExpEstimate negated.
			r := r * scale.
			mPlus := mPlus * scale.
			mMinus := mMinus * scale].
	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])
		ifTrue: [baseExpEstimate := baseExpEstimate + 1]
		ifFalse:
			[r := r * base.
			mPlus := mPlus * base.
			mMinus := mMinus * base].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue:
			[decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]
		ifFalse:
			[decPointCount := 1].
	slowbit := 1 - s lowBit .
	shead := s bitShift: slowbit.
	[d := (r bitShift: slowbit) // shead.
	r := r - (d * s).
	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |
	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:
		[aStream nextPut: (Character digitValue: d).
		r := r * base.
		mPlus := mPlus * base.
		mMinus := mMinus * base.
		decPointCount := decPointCount - 1.
		decPointCount = 0 ifTrue: [aStream nextPut: $.]].
	tc2 ifTrue:
		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue:
		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].
		aStream nextPutAll: '.0'].
	fixedFormat ifFalse:
		[aStream nextPut: $e.
		aStream nextPutAll: (baseExpEstimate - 1) printString]! !
!Float methodsFor: 'printing' stamp: 'jmv 9/24/2018 13:40:36' prior: 50404906!
                        absPrintOn: aStream base: base mantissaSignificantBits: significantBits
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	https://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
	This version performs all calculations with Floats instead of LargeIntegers, and loses
	about 3 lsbs of accuracy compared to an exact conversion."

	| fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |
	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].
	fBase := base asFloat.
	exp := self exponent.
	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue:
			[r := self.
			s := 1.0.
			mPlus := 1.0 timesTwoPower: exp - significantBits.
			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]
		ifFalse:
			[r := self timesTwoPower: significantBits.
			s := 1.0 timesTwoPower:  significantBits.
			mMinus := 1.0 timesTwoPower: (exp max: -1024).
			mPlus :=
				(exp = MinValLogBase2) | (self significand ~= 1.0)
					ifTrue: [mMinus]
					ifFalse: [mMinus * 2.0]].
	baseExpEstimate >= 0
		ifTrue:
			[exp = 1023
				ifTrue:   "scale down to prevent overflow to Infinity during conversion"
					[r := r / fBase.
					s := s * (fBase raisedToInteger: baseExpEstimate - 1).
					mPlus := mPlus / fBase.
					mMinus := mMinus / fBase]
				ifFalse:
					[s := s * (fBase raisedToInteger: baseExpEstimate)]]
		ifFalse:
			[exp < -1023
				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"
					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.
					scale := fBase raisedToInteger: d.
					r := r * scale.
					mPlus := mPlus * scale.
					mMinus := mMinus * scale.
					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]
				ifFalse:
				[scale := fBase raisedToInteger: baseExpEstimate negated].
			s := s / scale].
	(r + mPlus >= s)
		ifTrue: [baseExpEstimate := baseExpEstimate + 1]
		ifFalse:
			[s := s / fBase].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue:
			[decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]
		ifFalse:
			[decPointCount := 1].
	[d := (r / s) truncated.
	r := r - (d * s).
	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:
		[aStream nextPut: (Character digitValue: d).
		r := r * fBase.
		mPlus := mPlus * fBase.
		mMinus := mMinus * fBase.
		decPointCount := decPointCount - 1.
		decPointCount = 0 ifTrue: [aStream nextPut: $.]].
	tc2 ifTrue:
		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue:
		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].
		aStream nextPutAll: '.0'].
	fixedFormat ifFalse:
		[aStream nextPut: $e.
		aStream nextPutAll: (baseExpEstimate - 1) printString]! !

Float removeSelector: #absByteEncode:base:!

Float removeSelector: #absByteEncode:base:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3453-FloatStringConversionStuff-JuanVuletich-2018Sep24-13h39m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3453] on 26 September 2018 at 11:48:12 am'!
!Float commentStamp: 'jmv 9/24/2018 20:52:43' prior: 50375942!
  A note About Floating Point numbers and Floating Point Arithmetic.

The following is not specific to Cuis or Smalltalk at all. This is about the properties of Float numbers in any computer implementation.

If you haven't done so already, read https://en.wikipedia.org/wiki/Floating-point_arithmetic

But if you find the Wikipedia article too detailed, or hard to read, then try http://fabiensanglard.net/floating_point_visually_explained/ (get past "How Floating Point are usually explained" and read "A different way to explain...").

Other great reads are:
	"Why don't my numbers add up?":
		http://floating-point-gui.de/
and
	"What Every Computer Scientist Should Know About Floating-Point Arithmetic":
		http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
and also maybe
	"Comparing floating point numbers"
		https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

Now that you read them, and we are on the same boat, some further comments (from jmv):

Floats are (conceptually) approximate real numbers. That's why trig and other trascendental functions always answer Floats. That's why it is ok to round the result of operations. That's why Float is considered more general than Fraction in ST-80 and most Smalltalks. So, when we have a Float value, we must not think about it as a Rational but as a Real (actually as some unknown Real that could hopefully be close to the Rational we can actually represent). Keep this in mind when dealing with Floats, and especially avoid comparing them for equality.

When doing mixed operations with Floats and Fractions, Cuis, as most other Smalltalks, converts all values to Floats. Some other systems, including Pharo Smalltalk, Scheme and Lisp have two rules: when the answer is a Number, they convert to Float. But when the answer is a boolean (#<, #=, #<=, etc.) they convert to Fraction. We think this is a mistake. There should never be implicit conversions from Float to Fraction. Fractions are to hold exact values, and people expect Fractions to be exact. On the other hand, Floats are to hold approximations (and people should be aware of that!!). But an implicit conversion from Float to Fraction would give a Fraction that should not be considered an exact value (the value comes from an inexact Float), but that knowledge is lost, as it is an instance of Fraction.

If you want exact arithmetic, usual mathematical properties (like transitivity of equality), can live in the limited world of Rational numbers, and can afford a slight performance penalty, use Fraction instead. Avoid trascendental functions and never convert to Float.

In any case, most numeric computation is done on Float numbers. There are good reasons for that. One is that in most cases we don't need an exact answer. And in many cases we can't really have it: the inputs to algorithms already have a limited precision, or they use trascendental functions. And even when exact arithmetic possible, if we are doing sound synthesis, 24 bits of resolution is enough. For image processing and graphics, the result is never more than 16 bits per channel. So, these fields don't really need 64 bit Doubles. 32 bit Floats are enough. Other fields do need 64 bit Doubles, like physics simulations and geometry. Games usually prefer special, faster 32 bit Float operations in GPUs that have greater errors but are faster.

There are some things that can be done to increase the confidence you can have on Float results. One is to do an error propagation analysis on the code you are running. This is not easy, but it is done for any widely used numerical method. Then, you can know real bounds and/or estimates of the errors made. So, understanding your inputs and your algorithms (for example error propagation, condition number, numeric stability), and using Float number if appropriate, is the usual advice.

Perhaps you have heard about "interval arithmetic". It is a bit better than simple Float, but doesn't really fix the problems.

The ultimate solution is to do Monte Carlo analysis, with random perturbation of inputs. After the Monte Carlo run, it is needed to do statistical analysis of possible correlations between the distributions of the random noise added to imputs and the result of the algorithm.

Additional food for thought: http://www.cs.berkeley.edu/~wkahan/Mindless.pdf . According to this, doing Monte Carlo as described above attacks a slightly different problem. This might be yet another reason (besides performance) to try something like the next paragraph. I (jmv) came up with it, and I don't really know if it has been described and or tried before or not. Mhhh. Maybe a defensive publication is in order.

A possibility that could be a practical solution, being much cheaper than Monte Carlo, but better than interval arithmetic, is to represent each value by 2 Floats: an estimation of the real value (i.e. an estimation of the mean value of the distribution of the corresponding Monte Carlo result), and an estimation of the error (i.e. an estimation of the standard deviation of the corresponding Monte Carlo result). Or perhaps even 3 of them. In addition to the estimation of the real value and an estimation of the error, we could add a hard bound on the error. In many cases it will be useless, because the error can not really be bound. But in those cases where it is possible to bound it, applications could really know about the quality of computed values.

=======================================================================

My instances represent IEEE-754 floating-point double-precision numbers. They have about 16 decimal digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:
	
	8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12

Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:

	3r20.2 --> 6.66666666666667
	8r20.2 --> 16.25

If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...
	sign		1 bit
	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent
						in the range -1023 .. +1024
				- 16r000:
					significand = 0: Float zero
					significand ~= 0: Denormalized number (exp = -1023 + 1 = -1022, no hidden '1' bit in mantissa)
				- 16r7FF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.

The single-precision format is...
	sign		1 bit
	exponent	8 bits, with bias of 127, to represent -126 to +127
                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)
                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)
	mantissa	24 bits, but only 23 are stored
This format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.

You might also check https://en.wikipedia.org/wiki/IEEE_754_revision

Other great reads (covering broader but interesting issues):
https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
http://www.ima.umn.edu/2010-2011/W1.10-14.11/activities/Leeser-Miriam/Leeser-GPU-IMA-Jan2011.pdf!
!Float methodsFor: 'converting' stamp: 'jmv 9/26/2018 09:32:40' prior: 16844861!
            asTrueFraction
	" Answer a fraction that EXACTLY represents self,
	  a double precision IEEE floating point number.
	  By David N. Smith with significant performance
	  improvements by Luciano Esteban Notarfrancesco.
	  (Version of 11April97).
	Refactoring and simplification by jmv"
	
	^self
		partValues: [ :sign :exponent :mantissa | | zeroBitsCount |
			" Prepare result. If exponent is greater than mantissa size, result is an integer"
			(exponent >= 52 or: [
					zeroBitsCount _ mantissa lowBit - 1.
					exponent + zeroBitsCount >= 52 ])
				ifTrue: [
					"result is an integer number"
					 sign * mantissa bitShift: exponent - 52 ]
				ifFalse: [
					" This is the 'obvious' way. Better do Luciano's trick below:"
					"result := Fraction
						numerator: sign * mantissa
						denominator: (1 bitShift: 52 - exponent)."
					" Form the result. When exp>52, the exponent is adjusted by
					  the number of trailing zero bits in the mantissa to minimize
					  the (huge) time could be spent in #gcd:. "
					Fraction
						numerator: (sign * (mantissa bitShift: 0 - zeroBitsCount))
						denominator: (1 bitShift: 52 - exponent - zeroBitsCount) ]
		]
		ifInfinite: [ self error: 'Cannot represent infinity as a fraction' ]
		ifNaN: [ self error: 'Cannot represent Not-a-Number as a fraction' ].! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 9/26/2018 11:31:38' prior: 16844982!
 exponentPart
	"
	Exponent part of the Floating Point representation.
	For any Floating Point number (except zeros, infinities and NaNs)
	Includes correction of stored exponent bits for denormals (where it acts as a label, not a real exponent)
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 9/26/2018 11:30:23' prior: 16844994!
          mantissaPart
	"Equivalent to #significandAsInteger."
	"The actual bits in the mantissa of the receiver, as an integer number, including the implicit leading 1 if appropriate.
	Does not include de sign.
	See #exponentPart and #signPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f mantissaPart * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | mantissa ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 9/26/2018 11:29:42' prior: 16845031!
                          signPart
	"The sign of the mantissa.
	See #mantissaPart and #exponentPart"
	"
	| f |
	f := -2.0.
	(f signPart * f mantissaPart * (2 raisedToInteger: f exponentPart-52)) asFloat.
	"
	^self partValues: [ :sign :exponent :mantissa | sign ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 9/26/2018 11:33:16' prior: 16845037!
                 significand
	"Answers mantissa as a Float between one and two (or between -1 and -2). See #exponent.
	See also #signPart,  #significandAsInteger and #exponentPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. f significand * (2 raisedToInteger: f exponent) = f } print ].
	"
	^ self timesTwoPower: (self exponent negated)! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 9/26/2018 11:31:01' prior: 16845042!
              significandAsInteger
	"The actual bits in the mantissa of the receiver, as an integer number, including the implicit leading 1 if appropriate.
	See #exponentPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | mantissa ]! !
!BoxedFloat64 methodsFor: 'truncation and round off' stamp: 'jmv 9/26/2018 11:33:06' prior: 16790833!
                    exponent
	"Primitive. Consider the receiver to be represented as a power of two
	multiplied by a mantissa between one and two  or between -1 and -2 (#significand).
	 Answer with the SmallInteger to whose power two is raised.
	Optional. See Object documentation whatIsAPrimitive.
	See also #signPart,  #significandAsInteger and #exponentPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. f significand * (2 raisedToInteger: f exponent) = f } print ].
	"

	| positive |
	<primitive: 53>
	self >= 1.0 ifTrue: [^self floorLog: 2].
	self > 0.0
		ifTrue: 
			[positive _ (1.0 / self) exponent.
			self = (1.0 / (1.0 timesTwoPower: positive))
				ifTrue: [^positive negated]
				ifFalse: [^positive negated - 1]].
	self = 0.0 ifTrue: [^-1].
	^self negated exponent! !
!SmallFloat64 methodsFor: 'truncation and round off' stamp: 'jmv 9/26/2018 11:17:00' prior: 16908499!
                   exponent
	"Primitive. Consider the receiver to be represented as a power of two
	multiplied by a mantissa between one and two (#significand).
	 Answer with the SmallInteger to whose power two is raised.
	Optional. See Object documentation whatIsAPrimitive.
	See comment at BoxedFloat64"

	| positive |
	<primitive: 553>
	self >= 1.0 ifTrue: [^self floorLog: 2].
	self > 0.0
		ifTrue: 
			[positive _ (1.0 / self) exponent.
			self = (1.0 / (1.0 timesTwoPower: positive))
				ifTrue: [^positive negated]
				ifFalse: [^positive negated - 1]].
	self = 0.0 ifTrue: [^-1].
	^self negated exponent! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3454-FloatCommentsEnhancements-JuanVuletich-2018Sep26-11h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3454] on 26 September 2018 at 1:32:50 pm'!
!Number class methodsFor: 'instance creation' stamp: 'jmv 9/26/2018 13:28:05' prior: 50413799!
                              readRemainderOf: integerPart from: aStream base: base withSign: sign
	"Read optional fractional part and exponent, and return the final result"
	| value fraction fracpos peekChar exp scale convertToFloat |

	convertToFloat := false.
	value := integerPart.
	(aStream peekFor: $.)
		ifTrue: [		 "<integer>.<fraction>"
			(aStream atEnd not and: [ aStream peek digitValue between: 0 and: base - 1 ])
				ifTrue:  [
					fracpos := aStream position.
					fraction := Integer readFrom: aStream base: base.
					fraction := fraction / (base raisedToInteger: aStream position - fracpos).
					value := value + fraction.
					convertToFloat := true ]
				ifFalse: [
					"oops - just <integer>."
					aStream skip: -1.
					"un-gobble the period"
					^ value * sign"Number readFrom: '3r-22.2'"]].
	peekChar := aStream peek.
	peekChar = $e | (peekChar = $d) | (peekChar = $q)
		ifTrue: [			"<number>(e|d|q)<exponent>>"
			aStream next.
			(aStream atEnd not and: [ (aStream peek digitValue between: 0 and: 9) or: [ aStream peek = $- ]])
				ifTrue:  [
					exp := Integer readFrom: aStream.
					scale := base raisedToInteger: exp.
					value := value * scale ]
				ifFalse: [
					"oops - just <number>."
					aStream skip: -1.]].
	^convertToFloat
		ifTrue: [
			(value = 0.0 and: [ sign = -1 ])
				ifTrue: [ Float negativeZero ]
				ifFalse: [ (value * sign) asFloat ]]
		ifFalse: [ value * sign ]! !
!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:48' prior: 50413973!
                               absPrintExactlyOn: aStream base: base
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	https://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
	This version guarantees that the printed representation exactly represents my value
	by using exact integer arithmetic."

	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |
	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].
	significand := self significandAsInteger.
	roundingIncludesLimits := significand even.
	"What follows is equivalent, but faster than
		exp := self exponentPart - 52."
	exp := (self exponent - 52) max: MinValLogBase2.
	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue:
			[significand ~= 16r10000000000000
				ifTrue:
					[r := significand bitShift: 1 + exp.
					s := 2.
					mPlus := mMinus := 1 bitShift: exp]
				ifFalse:
					[r := significand bitShift: 2 + exp.
					s := 4.
					mPlus := 2 * (mMinus := 1 bitShift: exp)]]
		ifFalse:
			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])
				ifTrue:
					[r := significand bitShift: 1.
					s := 1 bitShift: 1 - exp.
					mPlus := mMinus := 1]
				ifFalse:
					[r := significand bitShift: 2.
					s := 1 bitShift: 2 - exp.
					mPlus := 2.
					mMinus := 1]].
	baseExpEstimate >= 0
		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]
		ifFalse:
			[scale := base raisedToInteger: baseExpEstimate negated.
			r := r * scale.
			mPlus := mPlus * scale.
			mMinus := mMinus * scale].
	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])
		ifTrue: [baseExpEstimate := baseExpEstimate + 1]
		ifFalse:
			[r := r * base.
			mPlus := mPlus * base.
			mMinus := mMinus * base].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue:
			[decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]
		ifFalse:
			[decPointCount := 1].
	slowbit := 1 - s lowBit .
	shead := s bitShift: slowbit.
	[d := (r bitShift: slowbit) // shead.
	r := r - (d * s).
	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |
	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:
		[aStream nextPut: (Character digitValue: d).
		r := r * base.
		mPlus := mPlus * base.
		mMinus := mMinus * base.
		decPointCount := decPointCount - 1.
		decPointCount = 0 ifTrue: [aStream nextPut: $.]].
	tc2 ifTrue:
		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue:
		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].
		aStream nextPutAll: '.0'].
	fixedFormat ifFalse:
		[aStream nextPut: $e.
		aStream nextPutAll: (baseExpEstimate - 1) printString]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3455-FloatFromString-fix-JuanVuletich-2018Sep26-13h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3450] on 22 September 2018 at 10:28:10 am'!

"Change Set:		3451-CuisCore-AuthorName-2018Sep22-10h25m
Date:			22 September 2018
Author:			Nahuel Garbezza

Method #average: for Collection. Basically the composition of #collect: and #average"!
!Collection methodsFor: 'statistics' stamp: 'RNG 9/22/2018 10:26:52'!
  average: aBlock

	^ (self sum: aBlock) / self size! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3456-Collection_average_withArgument-NahuelGarbezza-2018Sep22-10h25m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3456] on 27 September 2018 at 11:14:05 am'!

String removeSelector: #asCharacter!

String removeSelector: #asCharacter!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3457-Remove-String-asCharacter-JuanVuletich-2018Sep27-10h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3451] on 23 September 2018 at 10:09:08 pm'!
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:03:43'!
                       isAlphaNumeric

	^ self keyCharacter isAlphaNumeric! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:29:31'!
   isArrowDown

	^ keyValue = 31! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:29:05'!
                         isArrowUp

	^ keyValue = 30! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:26:20'!
                           isBackspace

	^ keyValue = 8! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:04:09'!
                          isColon

	^ self keyCharacter = $:.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:34:21'!
                   isCtrlSpace
	
	^ (self controlKeyPressed or: [ self rawMacOptionKeyPressed ]) and: [ self isSpace ]! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:27:43'!
                   isEnd
	
	^ keyValue = 4! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:25:30'!
                               isEsc

	^ keyValue = 27! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:27:07'!
                               isHome
	
	^ keyValue = 1! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:30:29'!
                              isPageDown

	^ keyValue = 12! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:30:07'!
                          isPageUp

	^ keyValue = 11! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:28:26'!
                            isQuesitonMark
	
	^ self keyCharacter = $? ! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 20:55:17'!
           isSpace

	^ #(0 32 160) includes: keyValue.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 20:55:13'!
           isTab

	^self keyCharacter = Character tab.! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 9/23/2018 21:16:16'!
isTab: kbEvent and: shouldOpenMoprh
	
	^ self opensWithTab 
		and: [ kbEvent isTab 
		and: [ shouldOpenMoprh ]]! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 9/23/2018 21:35:54'!
                            openCompletionMenuFor: kbEvent if: shouldOpenMorph

	"Ctrl-Space or Tab for open"
	"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
	(kbEvent isCtrlSpace or: [self isTab: kbEvent and: shouldOpenMorph]) ifTrue: [ self openCompletionMenu. ^ true].
		
	"Auto-open - currently deactivated"
"	(ctrl not & cmd not & alphanum) ifTrue: [ self openCompletionMenu ]."
	
	^ false! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 9/23/2018 21:06:20'!
                    shouldCloseMenu: kbEvent

	"All keys but the alphanumeric chars (without command and control ) 
	and the backspace key do close the menu"

	^ ((kbEvent controlKeyPressed not and: [ kbEvent commandAltKeyPressed not ]) and: [ kbEvent isAlphaNumeric or: [ kbEvent isColon ]]) not
! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 9/23/2018 20:58:51'!
                      shouldInsertSelected: kbEvent
	
	^ kbEvent isReturnKey 
		or: [ (kbEvent isSpace and: [ kbEvent controlKeyPressed or: [ kbEvent rawMacOptionKeyPressed ]]) 
		or: [ kbEvent isTab]]! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 9/23/2018 19:46:17'!
                        shouldOpenMorph

	| currentPos currentChar   |
	
	currentPos _ textMorph editor startIndex-1.
	currentPos <= 0 ifTrue: [ ^ false ].
	currentChar _ model actualContents at: currentPos.
	
	^ currentChar = Character space
		ifTrue: [ self shouldOpenMorphWhenNoPrefixAt: currentPos-1 ]
		ifFalse: [ self shouldOpenMorphWhenPrefixAt: currentPos and: currentChar ].
	


	! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 9/23/2018 21:23:06'!
                              shouldOpenMorphWhenNoPrefixAt: currentPos 
	
	^  model textSize >= currentPos 
		and: [ currentPos > 0
		and: [ (model actualContents at: currentPos) isAlphaNumeric ]] ! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 9/23/2018 19:48:46'!
   shouldOpenMorphWhenPrefixAt: currentPos and: currentChar 
	
	^ model textSize >= currentPos and: [ currentChar isAlphaNumeric or: [ currentChar == $: ]] 


	! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:30:07'!
         canComputeMessageEntriesFor: prevRange and: prevPrevRange

	^ prevRange notNil and: [ prevPrevRange isNil or: [ (#(binary keyword) includes: prevPrevRange rangeType) not]]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:17:21'!
                           computeEntriesOfMessageOrIdentifiersFor: allSource using: last3Ranges at: range in: contextClass and: specificModel
	
	prefix _ allSource copyFrom: range start to: range end.
	(parser isMessage: range rangeType) ifTrue: [ ^self computeMessageEntriesWhenSendinMessageFor: allSource using: last3Ranges in: contextClass and: specificModel ].	
	(parser isPartialOrFullIdentifier: range rangeType) ifTrue: [ ^self computeIdentifierEntries ].
	
	"If we don't know what to do, do nothing"
	entries _ #() ! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:26:07'!
                     computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClass |
	
	id _ allSource copyFrom: range start to: range end.
	receiverClass _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ self classOfInstVarNamed: id in: specificModel ].
			[ #tempVar ] 			-> [ self classOfTempVarNamed: id in: specificModel ].
			[ #workspaceVar ]		-> [ self classOfWorkspaceVarNamed: id in: specificModel ].
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #thisContext ] 		-> [ self classOfThisContextIn: specificModel ]. } 
		otherwise: [ nil ].
		
	self computeMessageEntries: receiverClass! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:29:16'!
            computeMessageEntriesWhenSendinMessageFor: allSource using: last3Ranges in: contextClass and: specificModel 
	
	| prevPrevRange prevRange |
	
	"If previous range is a constant or a well known identifier, we might filter messages"
	prevRange _ last3Ranges second.
	prevPrevRange _ last3Ranges first.
	
	"3 if -> ifNil: but not ifTrue:
	3=4 -> ifNil: or ifTrue:"
	^ (self canComputeMessageEntriesFor: prevRange and: prevPrevRange) 
		ifTrue: [ self computeMessageEntriesFor: allSource at: prevRange in: contextClass and: specificModel ]
		ifFalse: [ self computeMessageEntries: nil ]
! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:18:09'!
computeMessageEntriesWithEmptyPrefixFor: allSource at: range in: contextClass and: specificModel 
	
	prefix _ ''.
	self computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel ! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:03:49'!
                            parse: sourceToParse in: contextClass and: specificModel
	
	parser _ SHParserST80 new.
	parser
		workspace: ((specificModel is: #providesBindings) ifTrue: [specificModel]);
		classOrMetaClass: contextClass;
		source: sourceToParse.
	parser parse.
	
	^ parser last3Ranges.
! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:01:52'!
                      selectedClassOrMetaClassIn: specificModel

	^ (specificModel is: #CodeProvider) ifTrue: [ specificModel selectedClassOrMetaClass ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 19:30:43'!
    textProviderOrModel

	^ (model is: #hasTextProvider) ifTrue: [ model textProvider ] ifFalse: [ model ].! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 22:03:28'!
  classOfInstVarNamed: aName in: specificModel
	
	(specificModel isKindOf: Debugger) ifTrue: [ ^specificModel contextStackIndex ~= 0 ifTrue: [ (specificModel receiver instVarNamed: aName) class] ].
	
	^nil
	! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 16:52:20'!
                            classOfLiteral: aLiteral in: aClass 
	
	| compilerClass |
	
	compilerClass := aClass ifNil: [ Compiler ] ifNotNil: [ aClass compilerClass ].
	
	^ (compilerClass evaluate: aLiteral) class ! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 16:52:36'!
              classOfLocalBindingNamed: aName in: aClass 
	
	^  (aClass localBindingOf: aName) ifNotNil: [ :aBinding | aBinding value class ]! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 22:04:08'!
          classOfTempVarNamed: aName in: specificModel 
		
	(specificModel isKindOf: Workspace) ifTrue: [ ^ self classOfTempVarNamed: aName inWorkspace: specificModel ].
	(specificModel isKindOf: Debugger)    ifTrue: [ ^ self classOfTempVarNamed: aName inDebugger: specificModel ]. 
	(specificModel isKindOf: Inspector)    ifTrue: [ ^ self classOfTempVarNamed: aName inInspector: specificModel ]. 
	
	^ nil! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 19:31:39'!
                             classOfTempVarNamed: aName inDebugger: aDebugger
		
	| context tempIndex |
							
	context := aDebugger selectedContext.
	tempIndex := context tempNames indexOf: aName.
	
	^ tempIndex ~= 0 ifTrue: [(context tempAt: tempIndex) class]! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 21:50:35'!
classOfTempVarNamed: aName inInspector: anInspector
 
	^ (anInspector bindingOf: aName) value ifNotNil: [ :aValue | aValue class ] ! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 16:38:27'!
      classOfTempVarNamed: aName inWorkspace: aWorkspace

	^ (aWorkspace bindingOf: aName) value ifNotNil: [ :aValue | aValue class ] ! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 19:31:57'!
         classOfThisContextIn: specificModel
	
	"thisContext could mean ContextPart or BlockClosure..."
	^ (specificModel isKindOf: Debugger) ifTrue: [ self classOfThisContextInDebugger: specificModel ]
		! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 17:06:19'!
     classOfThisContextInDebugger: aDebugger
		
	^ aDebugger selectedContext class! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 22:05:20'!
                            classOfWorkspaceVarNamed: id in: specificModel
	
	(specificModel isKindOf: Workspace) ifTrue: [ ^ self classOfWorkspaceVarNamed: id inWorkspace: specificModel ].
	(specificModel isKindOf: Inspector) ifTrue: [ ^self classOfWorkspaceVarNamed: id inInspector: specificModel ].
	
	^nil! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 16:44:50'!
                classOfWorkspaceVarNamed: aName inInspector: anInspector 

	^  (anInspector object instVarNamed: aName) class ! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 16:43:48'!
                           classOfWorkspaceVarNamed: aName inWorkspace: aWorkspace
												
	^  (aWorkspace bindingOf: aName) value ifNotNil: [ :aValue | aValue class ] ! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'HAW 9/23/2018 21:30:54' prior: 50412571!
                   handleKeystrokeBefore: kbEvent
	
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	
	| shouldOpenMorph |
	
	shouldOpenMorph _ self shouldOpenMorph.
	
	"Stuff to do if the menu is not open"
	menuMorph ifNil: [ ^ self openCompletionMenuFor: kbEvent if: shouldOpenMorph ].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	
	kbEvent isEsc ifTrue: [ self closeMenu. ^ true].
	kbEvent isBackspace ifTrue: [ shouldOpenMorph ifFalse: [ self closeMenu ]. ^ false].
	kbEvent isHome ifTrue: [ menuMorph goHome. ^ true ].
	kbEvent isEnd ifTrue: [ menuMorph goToEnd. ^ true].
	kbEvent isQuesitonMark ifTrue: [ menuMorph help. ^true].
	kbEvent isArrowUp ifTrue: [ menuMorph goUp. ^ true].
	kbEvent isArrowDown ifTrue: [ menuMorph goDown. ^ true].
	kbEvent isPageUp ifTrue: [ menuMorph goPageUp. ^ true].
	kbEvent isPageDown ifTrue: [ menuMorph goPageDown. ^ true].
	(self shouldInsertSelected: kbEvent) ifTrue: [ self insertSelected ifTrue: [^ true]].
	(self shouldCloseMenu: kbEvent) ifTrue: [ self closeMenu ]. 
	
	^false! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'HAW 9/23/2018 19:18:00' prior: 50367911!
                          computeEntries

	| allSource contextClass specificModel last3Ranges range |
	
	allSource _ model actualContents string.
	specificModel _ self textProviderOrModel.
	contextClass _ self selectedClassOrMetaClassIn: specificModel. 
	last3Ranges _ self parse: (allSource copyFrom: 1 to: position) in: contextClass and: specificModel.
	range _ last3Ranges third ifNil: [ ^entries _ #() ].

	range end = position
		ifTrue: [ self computeEntriesOfMessageOrIdentifiersFor: allSource using: last3Ranges at: range in: contextClass and: specificModel ]
	 	ifFalse: [ self computeMessageEntriesWithEmptyPrefixFor: allSource at: range in: contextClass and: specificModel ].

	! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'HAW 9/23/2018 19:23:35' prior: 16909351!
           newCursorPosition: anEntry

	^anEntry indexOf: $ ! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'HAW 9/23/2018 19:23:40' prior: 16909355!
                selectedEntry

	^(self entries at: menuMorph selected) separateKeywords! !

SmalltalkCompleter removeSelector: #canDetectTypeOf:in:!

SmalltalkCompleter removeSelector: #classForInstVarNamed:in:!

SmalltalkCompleter removeSelector: #classOfLiteral:!

SmalltalkCompleter removeSelector: #classOfLocalBindingNamed:of:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inBindingsProvider:!

SmalltalkCompleter removeSelector: #computeEntriesOf:in:!

AutoCompleter removeSelector: #isArrowDown:!

AutoCompleter removeSelector: #isArrowUp:!

AutoCompleter removeSelector: #isCtrlSpace:!

AutoCompleter removeSelector: #isEnd:!

AutoCompleter removeSelector: #isHome:!

AutoCompleter removeSelector: #isPageDown:!

AutoCompleter removeSelector: #isPageUp:!

AutoCompleter removeSelector: #isQuesitonMark:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3458-SmalltalkCompleterEnhancements-p1-HernanWilkinson-2018Sep23-12h02m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3451] on 23 September 2018 at 10:28:44 pm'!
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 22:24:12'!
          classOfBlockArgNamed: aName in: specificModel

	(specificModel isKindOf: Debugger) ifTrue: [ ^ self classOfBlockArgNamed: aName inDebugger: specificModel ].
	
	^ nil! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/23/2018 22:27:23'!
    classOfBlockArgNamed: aName inDebugger: aDebugger 
	
	^ aDebugger contextStackIndex ~= 0 ifTrue: [ | selectedContext tempIndex |
		selectedContext := aDebugger selectedContext.
		tempIndex := selectedContext tempNames indexOf: aName ifAbsent: [ ^nil ].
		(selectedContext namedTempAt: tempIndex) class ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/23/2018 22:23:41' prior: 50414973!
       computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClass |
	
	id _ allSource copyFrom: range start to: range end.
	receiverClass _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ self classOfInstVarNamed: id in: specificModel ].
			[ #tempVar ] 			-> [ self classOfTempVarNamed: id in: specificModel ].
			[ #workspaceVar ]		-> [ self classOfWorkspaceVarNamed: id in: specificModel ].
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #thisContext ] 		-> [ self classOfThisContextIn: specificModel ]. 
			[ #blockArg ]			-> [ self classOfBlockArgNamed: id in: specificModel ].} 
		otherwise: [ nil ].
		
	self computeMessageEntries: receiverClass! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3459-SmalltalkCompleterEnhancements-p2-HernanWilkinson-2018Sep23-22h09m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3451] on 24 September 2018 at 3:31:12 pm'!
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:03:26'!
          classOfInstVarNamed: aName inDebugger: aDebugger 
	
	^aDebugger contextStackIndex ~= 0 ifTrue: [ (aDebugger receiver instVarNamed: aName) class]! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:04:44'!
                         classOfInstVarNamed: aName inInspector: anInspector 
	
	^ (anInspector object instVarNamed: aName) class ! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:17:20'!
classOfTempVarNamed: aName inContext: context

	| tempIndex |
	
	tempIndex := context tempNames indexOf: aName.
	
	^ tempIndex ~= 0 ifTrue: [(context tempAt: tempIndex) class]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/24/2018 13:25:49' prior: 50415305!
       computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClass |
	
	id _ allSource copyFrom: range start to: range end.
	receiverClass _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ self classOfInstVarNamed: id in: specificModel ].
			[ #tempVar ] 			-> [ self classOfTempVarNamed: id in: specificModel ].
			[ #workspaceVar ]		-> [ self classOfWorkspaceVarNamed: id in: specificModel ].
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #thisContext ] 		-> [ self classOfThisContextIn: specificModel ]. 
			[ #blockArg ]			-> [ self classOfBlockArgNamed: id in: specificModel ].} 
		otherwise: [ nil ].
		
	self computeMessageEntries: receiverClass! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/24/2018 12:48:26' prior: 50415048!
                 parse: sourceToParse in: contextClass and: specificModel
	
	parser _ SHParserST80 new.
	parser
		workspace: ((specificModel is: #providesBindings) ifTrue: [specificModel]);
		classOrMetaClass: contextClass;
		source: sourceToParse.
	parser parse: (specificModel is: #CodeProvider).
	
	^ parser last3Ranges.
! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/24/2018 12:58:46' prior: 50415060!
   selectedClassOrMetaClassIn: specificModel

	(specificModel is: #CodeProvider) ifTrue: [ ^ specificModel selectedClassOrMetaClass ].
	
	"I can not use #selectedClassOrMetaClass becuase it changes with the selection but when compiling to evaluate it assumes object as receiver - Hernan"
	^ (specificModel isKindOf: Inspector) ifTrue: [ specificModel object class ] ! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:02:09' prior: 50415284!
              classOfBlockArgNamed: aName in: specificModel

	^ (specificModel isKindOf: Debugger) ifTrue: [ self classOfBlockArgNamed: aName inDebugger: specificModel ].
	! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:03:54' prior: 50415073!
                           classOfInstVarNamed: aName in: specificModel

	(specificModel isKindOf: Debugger) ifTrue: [ ^ self classOfInstVarNamed: aName inDebugger: specificModel ]. 
	^ (specificModel isKindOf: Inspector) ifTrue: [ self classOfInstVarNamed: aName inInspector: specificModel ].
	
	! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:16:59' prior: 50415115!
           classOfTempVarNamed: aName inDebugger: aDebugger
		
	| context |
							
	context := aDebugger selectedContext.
	
	^self classOfTempVarNamed: aName inContext: context! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:29:14' prior: 50415154!
                   classOfWorkspaceVarNamed: id in: specificModel
	
	(specificModel isKindOf: Workspace) ifTrue: [ ^ self classOfWorkspaceVarNamed: id inWorkspace: specificModel ].
	^ (specificModel isKindOf: Inspector) ifTrue: [ self classOfWorkspaceVarNamed: id inInspector: specificModel ].
	! !
!SmalltalkCompleter methodsFor: 'class detection' stamp: 'HAW 9/24/2018 15:19:44' prior: 50415166!
     classOfWorkspaceVarNamed: aName inInspector: anInspector 

	^ self classOfTempVarNamed: aName inContext: anInspector object

! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3460-SmalltalkCompleterEnhancements-p3-HernanWilkinson-2018Sep24-08h59m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3451] on 24 September 2018 at 3:44:30 pm'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 9/24/2018 15:44:19' prior: 16909302!
                               computeIdentifierEntries
	"Use an aux Set to avoid duplicates, but keep the order given."
	| entriesSet |
	
	entriesSet _ Set new.
	entries _ Array streamContents: [ :strm | 
		parser namesBeginningWith: prefix do: [ :identifier |
			(entriesSet includes: identifier) ifFalse: [
				entriesSet  add: identifier.
				strm nextPut: identifier ]]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3461-SmalltalkCompleterEnhancements-p4-HernanWilkinson-2018Sep24-15h31m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3463] on 28 September 2018 at 12:16:58 pm'!
!ContentPack commentStamp: 'jmv 9/28/2018 12:16:02' prior: 16823123!
    ContentPack lets you read in and write out the (supported files in the) contents of a directory on your file system. It also allows you to trivially create "messenger" subclasses that capture the information containted in these directory trees, including any implicit communication that's there in the structure of the directory hierarchy itself, which are captured in your changes file. You can then file out a change set that contains a representation of the (supported file/object types and directory structurein) the stuff on your disk, or in your image. This subclass is a dummy which ContentPack compiles methods into containing base 64 encoded data. You can load this into another image, as long as that image has ContentPack loaded. The filed in class can then recreate the ContentPack on the other end with the media files and structure intact.

The current implementation is based on #storeString, but the plan is to change that to SmartRefStream in the long run to support serializing things like morphs.

ContentPack instances hang onto the actual tree of media objects. It has a nice simple EDSL that just interprets an array of strings from beginning to end as a "path" to a file (really a series of dictionary lookups to a Smalltalk object, wherin the dictionaries mirror the structure of what was on the disk, sans unsupported files.) This mechanism will likely change a little bit at some point, 

ContentPack came into the world a little faster than I expected, as I ended up using it to send some icons back in time to fix the Cuis update stream without having to sort my changes all over again. As such it had some unusual design pressures... it had to be able to carry information in and out of both the change set stream and the filesystem, as well as function in a slightly earlier (unreleased) version of Cuis than it was written in, and not break anything on it's way back up through the build to head.

The code, in particular the way things are named, has not settled yet, and that's why this comment contains no code examples. Use with care and read the code first, for now.

Currently, .bmp import and .png import are implemented, and both can be exported. Anything you can import, you can also shuffle into a change set. Plans are in the works to support audio, change sets, and text files. I'll support video if someone has a good importer, exporter, and player under the MIT license that'll work under Cuis. 

Currently, objects are serialized into single methods, which works for small icons, but likely doesn't work well (if at all) for larger files. My intent is to add some behavior that breaks up large objects into smaller chunks so that this becomes a non-issue. I'll likely get to that when I've removed most of the repetitive subtle variations of the same recursive tree walking visitor-trick from the code, and renamed everything. I think in essence this class is slightly smaller than it is as represented currently.

Hopefully I will be able to explain all of this better once I've clarified the code a bit so that I can show off some examples.

	- cbr

-----------------------------------
Alternative description (need to merge both!!)

Forms (and potentially other media types) can exist in three forms:

1) As external files, such as jpg, png, etc. This is the representation we need to use external tools (such as image processing apps, cameras, scanners, web, etc) to work on them.
2) As methods. Non human readable, base-64 encoded binary data. We need this to be able to include such stuff in the update stream, or in packages. After we update an image, we usually delete these methods, just keeping 3).
3) Live objects in the image, for example, stored in class variables. This is to make use of them in Cuis.

Most of the time, we use 3). But we need 2) for the update stream. We also need 1) sometimes to work on them. ContentPack supports the conversion between these 3 formats. The implementation is quite simple. What is really great is that Casey realized we need some tool to move comfortably between these 3 representations. And he also implemented it.

	- jmv
	
-------------------------------------------
Usage hints

Feature require: 'Graphics-Files-Additional'.
Theme content export.

"Build 'Import' directory copying the structure of 'Exported', with stuff to be loaded"

"Just build an instance from files"
ContentPack import.

"Build an instance and generate code"
ContentPack generateCode: ContentPack import.

"Build an instance from code generated"
ContentPack decode.

"Build and merge. Usually do this in the postscript of the change set that includes the generated code"
Theme content merge: ContentPack decode.
ContentPack removeCategory: ContentPack generatedMethodsCategory!
!ContentPack methodsFor: 'importing' stamp: 'jmv 9/28/2018 11:50:48'!
          decodeContent
	"Load content in us.
	Start with an empty instance!!"

	self decodeContentFrom: self contentMap! !
!ContentPack methodsFor: 'testing' stamp: 'jmv 9/28/2018 12:02:29'!
          is: aSymbol
	^aSymbol == #ContentPack or: [ super is: aSymbol ]! !
!ContentPack methodsFor: 'merge' stamp: 'jmv 9/28/2018 12:03:37'!
                           merge: aDictionaryOrContentPack
	"Merge aDictionaryOrContentPack into us"

	aDictionaryOrContentPack keysAndValuesDo: [ :key :value |
		(value is: #ContentPack)
			ifFalse: [
				self at: key put: value ]
			ifTrue: [
				(self at: key ifAbsentPut: [ContentPack new])
					merge: value ]]! !
!ContentPack class methodsFor: 'instance creation' stamp: 'jmv 9/28/2018 11:51:51'!
        decode
	
	^ self new decodeContent! !
!ContentPack class methodsFor: 'code pack' stamp: 'jmv 9/28/2018 10:47:25'!
              generateCode: aDictionary

	| contentMap |

	self resetImporter.
	
	contentMap _ self encodeContentFrom: aDictionary.
	
	self compilePayloadWith: contentMap.
	
	self resetImporter.! !
!ContentPack class methodsFor: 'configuration' stamp: 'jmv 9/28/2018 12:14:18'!
                        generatedMethodsCategory
	^ 'generated code'! !
!ContentPack class methodsFor: 'configuration' stamp: 'jmv 9/28/2018 10:37:22'!
importDirectory
	
	^ DirectoryEntry smalltalkImageDirectory / self defaultContentDirectory / 'Import'! !
!ContentPack methodsFor: 'importing' stamp: 'jmv 9/28/2018 11:56:08' prior: 16823258!
 decodeContentFrom: associationList
	"Load content in us, frin geberated code.
	Start with an empty instance!!"

	associationList do: [ :assoc |
		(assoc at: 2) class == Array
			ifTrue: [ 
				self at: (assoc at: 1) put: (ContentPack new decodeContentFrom: (assoc at: 2)) ]
			ifFalse: [ 
				self at: (assoc at: 1) put: (Compiler 
					evaluate: (self 
						perform: 
							('object' , (assoc at: 2) asString) asSymbol) base64Decoded)
			]
	]! !
!ContentPack methodsFor: 'importing' stamp: 'jmv 9/28/2018 11:55:59' prior: 50413556!
         loadContentFrom: aDirectoryEntry
	"Load content in us, from files.
	Start with an empty instance!!"

	(self supportedFilesIn: aDirectoryEntry) do: [ :filename |			
		self flag: #todo. "Add hook for other media types here. Also consider renaming this method. --cbr"
		self at: filename name 
			put: (Form fromFileEntry: filename)
	].

	aDirectoryEntry directoryNames do: [ :i |
		self at: i put: (ContentPack new loadContentFrom: aDirectoryEntry / i)
	]! !
!ContentPack class methodsFor: 'instance creation' stamp: 'jmv 9/28/2018 10:37:34' prior: 50413578!
                   import
	"
	Feature require: 'Graphics-Files-Additional'.
	Theme content export.
	ContentPack import.
	Theme bootstrap.
	"
	
	^ self new loadContentFrom: self importDirectory! !
!ContentPack class methodsFor: 'code pack' stamp: 'jmv 9/28/2018 12:14:28' prior: 16823429!
                   compilePayloadWith: contentMap

	| category |
	category _ self generatedMethodsCategory.
	self
		compile: 'contentMap' , String newLineString , '	^ ' , contentMap asString
		classified: category.

	self
		compile: 'objectCount' , String newLineString , '	^ ' , payload size asString
		classified: category.

	payload withIndexDo: [ :blob :index | | selector |
		selector _ 'object', index asString.
		self
			compile: selector, String newLineString, '	^ ', blob surroundedBySingleQuotes
			classified: category ]! !

ContentPack class removeSelector: #withDictionary:!

ContentPack class removeSelector: #withDictionary:!

ContentPack removeSelector: #import:!

ContentPack removeSelector: #import:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3462-ContentPack-enhancements-JuanVuletich-2018Sep28-11h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3462] on 28 September 2018 at 12:20:08 pm'!
!ContentPack methodsFor: 'generated code' stamp: 'jmv 9/28/2018 10:41:53'!
          contentMap
	^ #(#('Theme' 1))! !
!ContentPack methodsFor: 'generated code' stamp: 'jmv 9/28/2018 10:41:53'!
                    object1
	^ 'KChDb250ZW50UGFjayBuZXcpIGFkZDogKCcxNngxNictPigoQ29udGVudFBhY2sgbmV3KSBh
ZGQ6ICgncmVzaXplJy0+KChDb250ZW50UGFjayBuZXcpIGFkZDogKCdyZXNpemUzLnBuZyct
PihGb3JtCglleHRlbnQ6IDE2QDE2CglkZXB0aDogMzIKCWZyb21BcnJheTogIyggNDI5NDk2
NzI5NSA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyNDQ2
MzU2NDcgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0MjQ0
NTY5ODU0IDQyNDQ1Njk4NTQgNDI0NDU2OTg1NCA0MjQ0NTY5ODU0IDQyNDQ1Njk4NTQgNDI5
NDk2NzI5NSA0MjQ0NjM1NjQ3IDQyNzg5Nzk1OTYgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODk3OTU5NiA0Mjk0MTExOTg2IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAg
NDI3ODE5MDA4MCA0MjQ0NTY5ODU0IDQyNDQ2MzU2NDcgNDI3ODg0ODAxMCA0Mjk0MzA5MzY1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0MTExOTg2IDQyOTQ5MDE1MDIgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNDQ1Njk4NTQgNDI0NDYzNTY0NyA0Mjc4NTg0
ODM4IDQyOTQ1NzI1MzcgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI0NDU2OTg1NCA0MjQ0
NjM1NjQ3IDQyNzgzODc0NTkgNDI5NDc2OTkxNiA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0
MjQ0NTY5ODU0IDQyNDQ2MzU2NDcgNDI3ODI1NTg3MyA0Mjk0OTAxNTAyIDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjc4MTkwMDgwIDQyNDQ1Njk4NTQgNDI0NDYzNTY0NyA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjQ0NjM1NjQ3IDQy
NDQ2MzU2NDcgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyNzgxOTAwODAgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ3MDQxMjMgNDI3ODU4NDgzOCA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI3
ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDgzNTcwOSA0Mjc4NDUzMjUyIDQyNDQ2MzU2NDcg
NDI0NDYzNTY0NyA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTAxNTAyIDQyNzgzODc0
NTkgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI3ODMyMTY2NiA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI3ODE5MDA4MCA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5MDE1MDIgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MjU1ODczIDQyNDQ2MzU2NDcgNDI5NDk2NzI5NSA0
MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcg
NDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3
IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI5NDk2NzI5
NSkKCW9mZnNldDogMEAwKSk7IGFkZDogKCdyZXNpemUtcmlnaHQucG5nJy0+KEZvcm0KCWV4
dGVudDogMTZAMTYKCWRlcHRoOiAzMgoJZnJvbUFycmF5OiAjKCA0Mjc4MTkwMDgwIDQyNzgx
OTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSAzODkyMjQ4NTc2IDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjc4MTI0NTQ0
IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQwMDk2ODkw
ODggNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAx
NzYwIDQyNzgxMjQ1NDQgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDAyNjQ2NjMwNCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDQyOTQ5MDE3NjAgNDI3ODEyNDU0NCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0MDI2NDY2MzA0IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0MjYxMzQ3MzI4IDQyNzgxOTAwODAg
NDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQwMjY0NjYzMDQgNDI5NDkwMTc2
MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyNjEzNDcz
MjggNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDAyNjQ2
NjMwNCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgNDI2MTM0NzMyOCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0MDI2NDY2MzA0IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCA0MjYxMzQ3MzI4IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQwNDMyNDM1MjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyNjEzNDczMjggNDI3ODE5MDA4
MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDA0MzI0MzUyMCA0Mjk0OTAx
NzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI0NDU3
MDExMiA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MDYw
MDIwNzM2IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCA0MjQ0NTcwMTEyIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQwNjAwMjA3MzYgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyNDQ1NzAxMTIgNDI3ODE5MDA4MCA0Mjc4MTkwMDgw
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDA2MDAyMDczNiA0Mjk0OTAxNzYwIDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI0NDU3MDExMiA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MDc2Nzk3OTUyIDQyOTQ5
MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0MjI3
NzkyODk2IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDM5
OTI5MTE4NzIgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyMTEwMTU2ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAg
NDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgw
IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4
MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwKQoJb2Zmc2V0
OiAwQDApKTsgYWRkOiAoJ3Jlc2l6ZS1ib3R0b20tcmlnaHQucG5nJy0+KEZvcm0KCWV4dGVu
dDogMTZAMTYKCWRlcHRoOiAzMgoJZnJvbUFycmF5OiAjKCA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5
MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgx
OTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0MTEw
NDE3OTE5IDM4OTIzMTQxMTEgMzg5MjMxNDExMSAzODkyMzE0MTExIDM4OTIzMTQxMTEgMzg5
MjMxNDExMSA0MTEwNDE3OTE5IDQxMTAzNTIzODQgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDM4
OTIyNDg1NzYgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDQxMTAzNTIzODQgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDM4OTIzMTQxMTEgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDM4OTIzMTQxMTEgMzg5MjI0ODU3NiA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgMzg5MjI0ODU3
NiA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgMzg5MjMxNDExMSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgMzg5MjMxNDExMSAzODkyMjQ4
NTc2IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkw
MTc2MCAzODkyMjQ4NTc2IDQyNzgxOTAwODAgNDI3ODE5MDA4MCAzODkyMzE0MTExIDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSAzODky
MzE0MTExIDM4OTIyNDg1NzYgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCA0Mjk0OTAxNzYwIDM4OTIyNDg1NzYgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDM4
OTIzMTQxMTEgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDM4OTIzMTQxMTEgMzg5MjI0ODU3NiA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgMzg5MjI0ODU3NiA0Mjc4MTkwMDgw
IDQyNzgxOTAwODAgMzg5MjMxNDExMSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgMzg5MjMxNDExMSAzODkyMjQ4NTc2IDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCAzODkyMjQ4
NTc2IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0MTEwNDE3OTE5IDM4OTIzMTQxMTEgMzg5MjMx
NDExMSAzODkyMzE0MTExIDM4OTIzMTQxMTEgMzg5MjMxNDExMSA0MTEwNDE3OTE5IDQxMTAz
NTIzODQgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDM4OTIyNDg1NzYgMzg5MjI0ODU3NiAzODky
MjQ4NTc2IDQxMTAzNTIzODQgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwKQoJb2Zmc2V0OiAw
QDApKTsgYWRkOiAoJ3Jlc2l6ZS10b3AucG5nJy0+KEZvcm0KCWV4dGVudDogMTZAMTYKCWRl
cHRoOiAzMgoJZnJvbUFycmF5OiAjKCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4
MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkw
MTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2
MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0OTAx
NzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkw
MTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0
OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2
MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAx
NzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkw
MTc2MCA0Mjk0OTAxNzYwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgw
IDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwKQoJb2Zmc2V0OiAwQDApKTsgYWRkOiAo
J3Jlc2l6ZS1ib3R0b20tbGVmdC5wbmcnLT4oRm9ybQoJZXh0ZW50OiAxNkAxNgoJZGVwdGg6
IDMyCglmcm9tQXJyYXk6ICMoIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAg
NDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgx
OTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQxMTAzNTIzODQgMzg5MjI0ODU3
NiAzODkyMjQ4NTc2IDM4OTIyNDg1NzYgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDQxMTAzNTIz
ODQgNDExMDQxNzkxOSAzODkyMzE0MTExIDM4OTIzMTQxMTEgMzg5MjMxNDExMSAzODkyMzE0
MTExIDM4OTIzMTQxMTEgNDExMDQxNzkxOSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgMzg5MjI0
ODU3NiA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgMzg5MjI0ODU3NiAzODkyMzE0MTExIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSAzODkyMzE0MTExIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCAzODkyMjQ4NTc2IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCAzODkyMjQ4NTc2IDM4OTIzMTQxMTEgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDM4OTIzMTQxMTEg
NDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDM4OTIyNDg1NzYgNDI5NDkwMTc2MCA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDM4OTIyNDg1NzYgMzg5MjMxNDEx
MSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgMzg5MjMxNDExMSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgMzg5MjI0ODU3NiA0Mjk0OTAx
NzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgMzg5MjI0
ODU3NiAzODkyMzE0MTExIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSAzODkyMzE0MTExIDQyNzgxOTAwODAgNDI3ODE5MDA4MCAzODky
MjQ4NTc2IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCAzODkyMjQ4NTc2IDM4OTIzMTQxMTEgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDM4OTIzMTQxMTEgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDQxMTAzNTIzODQgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDM4OTIyNDg1NzYg
Mzg5MjI0ODU3NiAzODkyMjQ4NTc2IDQxMTAzNTIzODQgNDExMDQxNzkxOSAzODkyMzE0MTEx
IDM4OTIzMTQxMTEgMzg5MjMxNDExMSAzODkyMzE0MTExIDM4OTIzMTQxMTEgNDExMDQxNzkx
OSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5
MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODApCglvZmZzZXQ6IDBAMCkpOyBhZGQ6ICgncmVz
aXplLXRvcC1yaWdodC5wbmcnLT4oRm9ybQoJZXh0ZW50OiAxNkAxNgoJZGVwdGg6IDMyCglm
cm9tQXJyYXk6ICMoIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5
MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0MTEwNDE3OTE5IDM4OTIz
MTQxMTEgMzg5MjMxNDExMSAzODkyMzE0MTExIDM4OTIzMTQxMTEgMzg5MjMxNDExMSA0MTEw
NDE3OTE5IDQxMTAzNTIzODQgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDM4OTIyNDg1NzYgMzg5
MjI0ODU3NiAzODkyMjQ4NTc2IDQxMTAzNTIzODQgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDM4
OTIzMTQxMTEgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDM4OTIzMTQxMTEgMzg5MjI0ODU3NiA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgMzg5MjI0ODU3NiA0Mjc4MTkwMDgw
IDQyNzgxOTAwODAgMzg5MjMxNDExMSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgMzg5MjMxNDExMSAzODkyMjQ4NTc2IDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCAzODkyMjQ4
NTc2IDQyNzgxOTAwODAgNDI3ODE5MDA4MCAzODkyMzE0MTExIDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSAzODkyMzE0MTExIDM4OTIy
NDg1NzYgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDM4OTIyNDg1NzYgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDM4OTIzMTQxMTEgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDM4
OTIzMTQxMTEgMzg5MjI0ODU3NiA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgMzg5MjI0ODU3NiA0Mjc4MTkwMDgwIDQyNzgxOTAwODAg
Mzg5MjMxNDExMSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgMzg5MjMxNDExMSAzODkyMjQ4NTc2IDQyOTQ5MDE3NjAgNDI5NDkwMTc2
MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCAzODkyMjQ4NTc2IDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0MTEwNDE3OTE5IDM4OTIzMTQxMTEgMzg5MjMxNDExMSAzODkyMzE0
MTExIDM4OTIzMTQxMTEgMzg5MjMxNDExMSA0MTEwNDE3OTE5IDQxMTAzNTIzODQgMzg5MjI0
ODU3NiAzODkyMjQ4NTc2IDM4OTIyNDg1NzYgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDQxMTAz
NTIzODQgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4
MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5
MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDQyNzgxOTAwODApCglvZmZzZXQ6IDBAMCkpOyBhZGQ6ICgncmVzaXplLWxl
ZnQucG5nJy0+KEZvcm0KCWV4dGVudDogMTZAMTYKCWRlcHRoOiAzMgoJZnJvbUFycmF5OiAj
KCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI3ODI1NTg3MyA0Mjc5MzA4NTYxIDQyNzkzMDg1NjEgNDI3OTE3
Njk3NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjc4
MTkwMDc5IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MTYwNzQ5NTY3IDQxNjA3NDk1NjcgNDE3
NzUyNjc4MyAzOTA5MDkxMzI3IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyNjE0MTI4NjMgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQwMjY1MzE4MzkgNDI3ODE5MDA4MCA0Mjc4MTkwMDgw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2
MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI0NDYzNTY0NyA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDA0MzMwOTA1NSA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkw
MTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0MjI3ODU4NDMxIDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MDc2
ODYzNDg3IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQy
MTEwODEyMTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQwOTM2NDA3MDMgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDE5NDMwMzk5OSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDExMDQxNzkxOSA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAx
NzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0MTc3NTI2NzgzIDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MTQzOTcyMzUxIDQyNzgx
OTAwODAgNDI3ODE5MDA4MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQxNDM5NzIzNTEgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQx
NjA3NDk1NjcgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDEyNzE5NTEzNSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDE5NDMwMzk5OSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2
MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0MTEwNDE3OTE5IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjExMDgxMjE1IDQyNzgxOTAwODAgNDI3ODE5
MDA4MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQwNzY4NjM0ODcgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyMjc4NTg0MzEgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDA2MDA4NjI3MSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI0NDYzNTY0NyA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2
MCA0MDI2NTMxODM5IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0MjYxNDEyODYzIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTAx
NzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkw
MTc2MCA0Mjk0OTAxNzYwIDM4OTIzMTQxMTEgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDE0Mzk3MjM1MSA0MTQzOTcyMzUxIDQwNjAwODYyNzEgNDI3ODE5MDA4MCA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwKQoJb2Zmc2V0OiAwQDApKTsgYWRkOiAoJ3Jlc2l6ZS5wbmcnLT4oRm9ybQoJ
ZXh0ZW50OiAxNkAxNgoJZGVwdGg6IDMyCglmcm9tQXJyYXk6ICMoIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzg4NDgwMTAgNDI0MDE2MTcyMyA0MjI3ODU4NDMxIDQy
Mjc4NTg0MzEgNDIyNzg1ODQzMSA0MjI3ODU4NDMxIDQyMjc4NTg0MzEgNDIyNzg1ODQzMSA0
MjM5ODk4NTUxIDQyNzk1NzE3MzMgNDI3OTE3Njk3NSA0Mjc4NzE2NDI0IDQyNzk3MDMzMTkg
NDI3ODE5MDA4MCA0Mjc4OTEzODAzIDQyNzkyNDI3NjggNDI5MDU1OTE2NCA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI4OTQ0MDY4MyA0Mjc4OTc5NTk2IDQyNzgyNTU4
NzMgNDI3ODcxNjQyNCA0Mjc4MTkwMDgwIDQyNzkxNzY5NzUgNDI3OTMwODU2MSA0MjkwNDkz
MzcxIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjkwNDkzMzcxIDQyNzky
NDI3NjggNDI3ODkxMzgwMyA0Mjc4NzE2NDI0IDQyNzg5MTM4MDMgNDI5MDY5MDc1MCA0Mjkx
MjE3MDk0IDQyNzk1NzE3MzMgNDI5MDAzMjgyMCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjkwNDI3NTc4IDQy
Nzk1MDU5NDAgNDI5MDgyMjMzNiA0Mjg5NTcyMjY5IDQyNzkyNDI3NjggNDI1NzEzNjMxOCA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5MTIxNzA5NCA0Mjc5NTcxNzMzIDQyODk5NjcwMjcg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjkwMzYxNzg1
IDQyNzk1MDU5NDAgNDI5MDg4ODEyOSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI1NjYwOTk3
NCA0MjQ0NjM1NjQ3IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTE2MTE4
NTIgNDI3OTc2OTExMiA0Mjg5OTY3MDI3IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjkwMzYx
Nzg1IDQyNzk3MDMzMTkgNDI5MTI4Mjg4NyA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0MjQ0NjM1NjQ3IDQyNDQ2MzU2NDcgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0MjkxNjExODUyIDQyNzk3NjkxMTIgNDI4OTkwMTIzNCA0Mjkw
MzYxNzg1IDQyNzk3MDMzMTkgNDI5MTI4Mjg4NyA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5MTYxMTg1MiA0
Mjc5MzA4NTYxIDQyNzkyNDI3NjggNDI5MTI4Mjg4NyA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI0NDYzNTY0NyA0MjQ0NjM1NjQ3
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0MjkwMjMwMTk5IDQyNzkzNzQzNTQgNDI3OTQ0MDE0NyA0Mjg5ODM1NDQxIDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjQ0NjM1
NjQ3IDQyNDQ2MzU2NDcgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0MjkwMjMwMTk5IDQyNzk3MDMzMTkgNDI5MTM0ODY4MCA0MjkxNjc3NjQ1IDQyNzk3
NjkxMTIgNDI4OTgzNTQ0MSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyNDQ2MzU2NDcgNDI0NDYzNTY0NyA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0MjkwMjMwMTk5IDQyNzk3MDMzMTkgNDI5MTQxNDQ3MyA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5MTc0MzQzOCA0Mjc5NzY5MTEyIDQyODk4MzU0NDEgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI0NDYzNTY0NyA0MjU3NTMxMDc2IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0MjkwMTY0NDA2IDQyNzk3MDMzMTkgNDI5MTQxNDQ3MyA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTE3NDM0MzggNDI3OTc2OTEx
MiA0Mjg5NzY5NjQ4IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjU2OTM4OTM5IDQyNzk1MDU5
NDAgNDI5MDU1OTE2NCA0MjkwMTY0NDA2IDQyNzk3NjkxMTIgNDI5MTQxNDQ3MyA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0MjkxNzQzNDM4IDQyNzk4MzQ5MDUgNDI4OTc2OTY0OCA0MjkwNTU5MTY0IDQyNzg4
NDgwMTAgNDI3ODU4NDgzOCA0Mjc4OTEzODAzIDQyNzkzNzQzNTQgNDI5MTY3NzY0NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5MTY3NzY0NSA0Mjc5Mzc0MzU0IDQy
NzkwNDUzODkgNDI3ODE5MDA4MCA0Mjc4NTg0ODM4IDQyNzg0NTMyNTIgNDI3OTA0NTM4OSA0
MjkwMDMyODIwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0MjkwNDI3NTc4
IDQyNzg5MTM4MDMgNDI3ODQ1MzI1MiA0Mjc4MTkwMDgwIDQyNjE5MzkyMDggNDI3ODE5MDA4
MCA0Mjc4MTkwMDgwIDQyNjE5MzkyMDggNDEwNTYxNTAzMCA0MDQzMzA5MDU1IDQwNDMzMDkw
NTUgNDA0MzMwOTA1NSA0MDQzMzA5MDU1IDQwNDMzMDkwNTUgNDA0MzMwOTA1NSA0MDg5Njkz
MTIzIDQyNDYxNDg4ODcgNDI2MjA3MDc5NCA0MjYyMDcwNzk0IDQyNDU0MjUxNjQpCglvZmZz
ZXQ6IDBAMCkpOyBhZGQ6ICgncmVzaXplLXRvcC1sZWZ0LnBuZyctPihGb3JtCglleHRlbnQ6
IDE2QDE2CglkZXB0aDogMzIKCWZyb21BcnJheTogIyggNDI3ODE5MDA4MCA0Mjc4MTkwMDgw
IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4
MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQxMTAzNTIzODQgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDM4OTIyNDg1NzYgMzg5MjI0
ODU3NiAzODkyMjQ4NTc2IDQxMTAzNTIzODQgNDExMDQxNzkxOSAzODkyMzE0MTExIDM4OTIz
MTQxMTEgMzg5MjMxNDExMSAzODkyMzE0MTExIDM4OTIzMTQxMTEgNDExMDQxNzkxOSA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgMzg5MjI0ODU3NiA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgMzg5MjI0ODU3NiAzODkyMzE0MTExIDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSAz
ODkyMzE0MTExIDQyNzgxOTAwODAgNDI3ODE5MDA4MCAzODkyMjQ4NTc2IDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCAzODkyMjQ4NTc2
IDM4OTIzMTQxMTEgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDM4OTIzMTQxMTEgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDM4OTIyNDg1
NzYgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAx
NzYwIDM4OTIyNDg1NzYgMzg5MjMxNDExMSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgMzg5MjMxNDExMSA0Mjc4MTkwMDgwIDQyNzgx
OTAwODAgMzg5MjI0ODU3NiA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDQyOTQ5MDE3NjAgMzg5MjI0ODU3NiAzODkyMzE0MTExIDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSAzODkyMzE0MTExIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCAzODkyMjQ4NTc2IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCAzODkyMjQ4NTc2IDM4OTIzMTQxMTEg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDM4OTIzMTQxMTEgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQxMTAzNTIzODQgMzg5MjI0ODU3
NiAzODkyMjQ4NTc2IDM4OTIyNDg1NzYgMzg5MjI0ODU3NiAzODkyMjQ4NTc2IDQxMTAzNTIz
ODQgNDExMDQxNzkxOSAzODkyMzE0MTExIDM4OTIzMTQxMTEgMzg5MjMxNDExMSAzODkyMzE0
MTExIDM4OTIzMTQxMTEgNDExMDQxNzkxOSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgx
OTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4
MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCkKCW9mZnNldDogMEAw
KSk7IGFkZDogKCdyZXNpemUtYm90dG9tLnBuZyctPihGb3JtCglleHRlbnQ6IDE2QDE2Cglk
ZXB0aDogMzIKCWZyb21BcnJheTogIyggNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAw
ODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5
MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUg
NDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0
OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5
NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQy
OTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0
Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyNzgxOTAwODAg
NDI3ODE5MDA4MCA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1
IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5
NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5Njcy
OTUgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3
Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2
NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5NjcyOTUgNDI5NDk2NzI5NSA0Mjk0OTY3Mjk1IDQyOTQ5
NjcyOTUgNDI5NDk2NzI5NSA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0
Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI3ODE5MDA4
MCA0Mjc4MTkwMDgwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAx
NzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkw
MTc2MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5
NDkwMTc2MCA0Mjk0OTAxNzYwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjk0OTAxNzYwIDQy
OTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0
Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAg
NDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgw
IDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2
MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3
NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjc4MTkw
MDgwIDQyNzgxOTAwODAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkw
MTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5
MDE3NjAgNDI5NDkwMTc2MCA0Mjk0OTAxNzYwIDQyOTQ5MDE3NjAgNDI5NDkwMTc2MCA0Mjk0
OTAxNzYwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3
ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQy
NzgxOTAwODAgNDI3ODE5MDA4MCA0Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCA0
Mjc4MTkwMDgwIDQyNzgxOTAwODAgNDI3ODE5MDA4MCkKCW9mZnNldDogMEAwKSk7IHlvdXJz
ZWxmKSk7IHlvdXJzZWxmKSk7IHlvdXJzZWxmKQ=='! !
!ContentPack methodsFor: 'generated code' stamp: 'jmv 9/28/2018 10:41:53'!
objectCount ^ 1! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

Theme content merge: ContentPack decode.
ContentPack removeCategory: ContentPack generatedMethodsCategory!

ContentPack removeSelector: #contentMap!

ContentPack removeSelector: #object1!

ContentPack removeSelector: #objectCount!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3463-AddNewResizeIcons-JuanVuletich-2018Sep28-12h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3461] on 2 October 2018 at 4:57:52 pm'!
!TextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:32:43'!
  classOfBlockArgNamed: aName

	^ nil! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:55:03'!
                 classOfBlockTempVarNamed: aName

	^ nil! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:32:49'!
             classOfInstVarNamed: aName

	^ nil! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:32:56'!
                  classOfTempVarNamed: aName

	^ nil! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:33:03'!
                  classOfThisContext

	^ nil! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:33:09'!
                          classOfWorkspaceVarNamed: aName

	^ nil! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:34:05'!
    classOfBlockArgNamed: aName

	^ textProvider classOfBlockArgNamed: aName ! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:56:47'!
  classOfBlockTempVarNamed: aName

	^ textProvider classOfBlockTempVarNamed: aName ! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:34:21'!
                          classOfInstVarNamed: aName

	^ textProvider classOfInstVarNamed: aName ! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:34:36'!
    classOfTempVarNamed: aName

	^ textProvider classOfTempVarNamed: aName ! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:34:50'!
    classOfThisContext

	^ textProvider classOfThisContext ! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:35:04'!
                    classOfWorkspaceVarNamed: aName

	^ textProvider classOfWorkspaceVarNamed: aName ! !
!Workspace methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:50:00'!
   classOfBindingOf: aName
												
	^ (self bindingOf: aName) value ifNotNil: [ :aValue | aValue class ] ! !
!Workspace methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:50:14'!
         classOfTempVarNamed: aName

	^ self classOfBindingOf: aName ! !
!Workspace methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:50:27'!
                        classOfWorkspaceVarNamed: aName
												
	^ self classOfBindingOf: aName ! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 9/28/2018 13:50:02'!
    classOfBlockArgNamed: aName

	^ nil! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:54:36'!
              classOfBlockTempVarNamed: aName

	^ nil! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 9/28/2018 13:50:17'!
          classOfInstVarNamed: aName

	^ nil! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 9/28/2018 13:50:42'!
               classOfTempVarNamed: aName

	^ nil! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 9/28/2018 13:51:28'!
               classOfThisContext

	^ nil! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 9/28/2018 13:51:53'!
                       classOfWorkspaceVarNamed: aName

	^ nil! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:52:39'!
              classOfBlockArgNamed: aName

	^self classOfTempVarNamed: aName ! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:52:47'!
                      classOfBlockTempVarNamed: aName

	^self classOfTempVarNamed: aName ! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:37:49'!
                  classOfInstVarNamed: aName 
	
	^ contextStackIndex ~= 0 ifTrue: [ (self receiver instVarNamed: aName) class]! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:53:29'!
         classOfTempVarNamed: aName
		
	| context tempIndex |
							
	context := self selectedContext.
	tempIndex := context tempNames indexOf: aName ifAbsent: [ ^ nil ].
	
	^ (self debuggerMap namedTempAt: tempIndex in: context) class
	
	! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:52:45'!
              classOfThisContext
	
	^ self selectedContext class! !
!Inspector methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 15:38:26'!
  classOfInstVarNamed: aName 
	
	^ (object instVarNamed: aName) class ! !
!Character methodsFor: 'testing' stamp: 'HAW 10/2/2018 16:31:57'!
                      isRightBracket

	^self = $]! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:19:24'!
             classOfBlockArgNamed: aName

	^ nil! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:55:33'!
     classOfBlockTempVarNamed: aName

	^ nil! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:19:34'!
 classOfInstVarNamed: aName

	^ nil! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:19:42'!
      classOfTempVarNamed: aName

	^ nil! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:19:51'!
      classOfThisContext

	^ nil! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 10/2/2018 16:19:58'!
              classOfWorkspaceVarNamed: aName

	^ nil! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 10/2/2018 16:36:34'!
    shouldOpenMorphWhenNoPrefixFor: currentChar 
	
	^currentChar isAlphaNumeric or: [ currentChar isRightBracket ]! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 10/2/2018 16:34:55' prior: 50414929!
             shouldOpenMorphWhenNoPrefixAt: currentPos 
	
	^  model textSize >= currentPos 
		and: [ currentPos > 0
		and: [ self shouldOpenMorphWhenNoPrefixFor: (model actualContents at: currentPos) ]]! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'HAW 10/2/2018 16:29:25' prior: 50415219!
    computeEntries

	| allSource contextClass specificModel last3Ranges range |
	
	allSource _ model actualContents string.
	specificModel _ self textProviderOrModel.
	contextClass _ self selectedClassOrMetaClassIn: specificModel. 
	last3Ranges _ self parse: (allSource copyFrom: 1 to: position) in: contextClass and: specificModel.
	range _ last3Ranges third ifNil: [ ^entries _ #() ].

	range end = position
		ifTrue: [ self computeEntriesOfMessageOrIdentifiersFor: allSource using: last3Ranges at: range in: contextClass and: specificModel ]
	 	ifFalse: [ self computeMessageEntriesWithEmptyPrefixFor: allSource at: range in: contextClass and: specificModel ].

	! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 10/2/2018 16:50:09' prior: 50415382!
computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClass |
	
	id _ allSource copyFrom: range start to: range end.
	receiverClass _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ specificModel classOfInstVarNamed: id ].
			[ #tempVar ] 			-> [ specificModel classOfTempVarNamed: id ].
			[ #workspaceVar ]		-> [ specificModel classOfWorkspaceVarNamed: id ].
			[ #blockArg ]			-> [ specificModel classOfBlockArgNamed: id ].
			[ #blockTempVar ]		-> [ specificModel classOfBlockTempVarNamed: id ].
			[ #thisContext ] 		-> [ specificModel classOfThisContext ]. 
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #blockEnd ]			-> [ BlockClosure ]. } 
		otherwise: [ nil ].
		
	self computeMessageEntries: receiverClass! !

SmalltalkCompleter removeSelector: #classOfBlockArgNamed:in:!

SmalltalkCompleter removeSelector: #classOfBlockArgNamed:in:!

SmalltalkCompleter removeSelector: #classOfBlockArgNamed:inDebugger:!

SmalltalkCompleter removeSelector: #classOfBlockArgNamed:inDebugger:!

SmalltalkCompleter removeSelector: #classOfInstVarNamed:in:!

SmalltalkCompleter removeSelector: #classOfInstVarNamed:in:!

SmalltalkCompleter removeSelector: #classOfInstVarNamed:inDebugger:!

SmalltalkCompleter removeSelector: #classOfInstVarNamed:inDebugger:!

SmalltalkCompleter removeSelector: #classOfInstVarNamed:inInspector:!

SmalltalkCompleter removeSelector: #classOfInstVarNamed:inInspector:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:in:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:in:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inContext:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inContext:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inDebugger:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inDebugger:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inInspector:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inInspector:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inWorkspace:!

SmalltalkCompleter removeSelector: #classOfTempVarNamed:inWorkspace:!

SmalltalkCompleter removeSelector: #classOfThisContextIn:!

SmalltalkCompleter removeSelector: #classOfThisContextIn:!

SmalltalkCompleter removeSelector: #classOfThisContextInDebugger:!

SmalltalkCompleter removeSelector: #classOfThisContextInDebugger:!

SmalltalkCompleter removeSelector: #classOfWorkspaceVarNamed:in:!

SmalltalkCompleter removeSelector: #classOfWorkspaceVarNamed:in:!

SmalltalkCompleter removeSelector: #classOfWorkspaceVarNamed:inInspector:!

SmalltalkCompleter removeSelector: #classOfWorkspaceVarNamed:inInspector:!

SmalltalkCompleter removeSelector: #classOfWorkspaceVarNamed:inWorkspace:!

SmalltalkCompleter removeSelector: #classOfWorkspaceVarNamed:inWorkspace:!

SmalltalkCompleter removeSelector: #shouldOpenMorphWhenNoPrefixFor:!

Debugger removeSelector: #classOfThisContextIn:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3464-SmalltalkCompleterEnhancements-HernanWilkinson-2018Sep28-13h49m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3464] on 3 October 2018 at 3:23:41 pm'!
!Float methodsFor: 'truncation and round off' stamp: 'nice 3/1/2014 00:32' prior: 16845048!
   successor
	| ulp |
	self isFinite ifFalse: [
		(self isNaN or: [self positive]) ifTrue: [^self].
		^Float fmax negated].
	ulp := self ulp.
	^self + (0.5 * ulp) = self
		ifTrue: [self * -1.0 - ulp * -1.0 "This trick is for obtaining a negativeZero"]
		ifFalse: [self + (0.5 * ulp)]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3465-Float-successor-fix-NicolasCellier-2018Oct03-14h28m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 1 October 2018 at 4:22:14 pm'!
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 10/1/2018 16:21:56' prior: 50335176!
                     open: model label: aString message: messageString
	|  window |
	(Preferences usePreDebugWindow or: [messageString notNil])
		ifTrue: [
			window _ self new.
			window
				model: model;
				buildMorphicWindowMessage: messageString print.
			aString ifNotNil: [ window setLabel: aString ].
			 window openInWorld ]
		ifFalse: [
			model openFullMorphicLabel: aString ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3466-UsePreDebugWindowIfMessageToUser-JuanVuletich-2018Oct01-16h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3466] on 3 October 2018 at 4:37:19 pm'!
!Float methodsFor: 'comparing' stamp: 'nice 10/27/2014 21:57'!
                            literalEqual: aFloat
	"Two float literals can be replaced by a single one only if their representation have the same bits.
	For example, zero and negativeZero are equal, but not literally equal."

	^self class == aFloat class and: [(self at: 1) = (aFloat at: 1) and: [(self at: 2) = (aFloat at: 2)]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3467-Float-literalEqual-JuanVuletich-2018Oct03-16h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3467] on 3 October 2018 at 5:18:30 pm'!
!Float methodsFor: 'arithmetic' stamp: 'nice 12/20/2012 23:16' prior: 16845131!
                            negated
	"Answer a Number that is the negation of the receiver.
	Implementation note: this version cares of negativeZero."

	^-1.0 * self! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3468-Float-negated-fix-NicolasCellier-2018Oct03-17h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3468] on 3 October 2018 at 5:52:09 pm'!
!Fraction methodsFor: 'mathematical functions' stamp: 'nice 4/25/2018 09:43'!
                               floorLog: radix
	"Unlike super, this version is exact when radix is integer"
	
	| d n |
	radix isInteger ifFalse: [^super floorLog: radix].
	n := numerator floorLog: radix.
	d := denominator floorLog: radix.
	^(numerator * (radix raisedTo: d))
		< (denominator * (radix raisedTo: n))
		ifTrue: [n - d - 1]
		ifFalse: [n - d]! !
!Integer methodsFor: 'mathematical functions' stamp: 'nice 4/25/2018 09:43'!
           floorLog: radix
	"Unlike super, this version is exact when radix is integer"
	
	radix isInteger ifFalse: [^super floorLog: radix].
	self <= 0 ifTrue: [^DomainError signal: 'floorLog: is only defined for x > 0.0'].
	^(self numberOfDigitsInBase: radix) - 1! !
!Number methodsFor: 'mathematical functions' stamp: 'nice 12/11/2012 19:18' prior: 16880105!
 floorLog: radix
	"Answer the floor of the log base radix of the receiver."

	^(self log: radix) floor! !
!Float methodsFor: 'mathematical functions' stamp: 'nice 6/3/2012 17:26' prior: 16844655!
                             floorLog: radix
	"Answer the floor of the log base radix of the receiver.
	The result may be off by one due to rounding errors, except in base 2."

	(radix = 2 and: [self > 0.0 and: [self isFinite]]) ifTrue: [^self exponent].
	^ (self log: radix) floor
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3469-floorLog-exactWhenPossible-JuanVuletich-2018Oct03-17h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3430] on 2 October 2018 at 4:54:47 pm'!
!ClosureTraceNode methodsFor: 'printing' stamp: 'sqr 10/2/2018 16:14:51'!
        dumpOn: aStream

	self dumpOn: aStream depth: 0! !
!ClosureTraceNode methodsFor: 'printing' stamp: 'sqr 10/2/2018 16:54:39'!
   dumpOn: aStream depth: anInteger

	anInteger timesRepeat: [aStream tab].
	self printOn: aStream.
	aStream newLine.
	self paths do: [:each | each dumpOn: aStream depth: anInteger + 1]! !
!ClosureTraceNode methodsFor: 'printing' stamp: 'sqr 10/2/2018 16:16:41'!
                            dumpString

	| answer |
	answer := String new writeStream.
	self dumpOn: answer.
	^answer contents! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3470-ClosureTraceNode-dumpString-ud-2018Oct02-16h14m-sq.st----!

----SNAPSHOT----#(8 October 2018 11:01:54.56262 am) Cuis5.0-3470-v3.image priorSource: 2521040!

----QUIT----#(8 October 2018 11:02:13.140988 am) Cuis5.0-3470-v3.image priorSource: 2748647!

----STARTUP----#(22 October 2018 2:45:55.321668 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3470-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3470] on 8 October 2018 at 6:54:40 pm'!
!Character class methodsFor: 'class initialization' stamp: 'jmv 10/8/2018 18:36:22'!
                     releaseClassState
	UnaccentedTable _ nil.
	UnicodeCodePoints _ nil! !
!Character class methodsFor: 'constants' stamp: 'jmv 10/8/2018 18:39:44'!
                unaccentedTable
	UnaccentedTable ifNil: [ self initializeLookupTables ].
	^UnaccentedTable! !
!Character class methodsFor: 'constants' stamp: 'jmv 10/8/2018 18:37:36'!
                        unicodeCodePoints
	UnicodeCodePoints ifNil: [ self initializeUnicodeCodePoints ].
	^UnicodeCodePoints! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 10/8/2018 18:29:30'!
       releaseClassState
	"Do not remove them in every image save (#releaseClassCachedState) to save startup time."
	"
	Color releaseClassState
	"
	CachedColormaps _ nil. 			"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !
!BitBlt class methodsFor: 'cached state access' stamp: 'jmv 10/8/2018 18:31:40'!
                          releaseClassState
	"Do not remove them in every image save (#releaseClassCachedState) to save startup time."

	CachedFontColorMaps _ ColorConvertingMaps _ nil! !
!StrikeFont class methodsFor: 'class cached access' stamp: 'jmv 10/8/2018 18:53:44'!
         releaseClassState
	"Do not remove them in every image save (#releaseClassCachedState) to save startup time."
	"
	StrikeFont releaseClassState
	"
	"Deallocate synthetically derived copies of base fonts to save space"
	self allSubInstancesDo: [ :sf | sf reset ]! !
!BitBltCanvas class methodsFor: 'cached state access' stamp: 'jmv 10/8/2018 18:33:14'!
  releaseClassState
	"Do not remove them in every image save (#releaseClassCachedState) to save startup time."
	"
	BitBltCanvas releaseClassState
	"
	CachedForms _ nil.! !
!Behavior methodsFor: 'system startup' stamp: 'jmv 10/8/2018 18:31:00' prior: 16785005!
                              releaseClassCachedState
	"Will be called for each class on shutdown or snapshot.
	All class vars or class instVar vars that can be cheaply recreated lazily on demand, should be nilled.
	For more expensive stuff to recreate, consider #releaseClassState that is not called on every image save.
	See implementors for examples"! !
!Character methodsFor: 'accessing' stamp: 'jmv 10/8/2018 18:39:19' prior: 16800364!
     codePoint
	"
	self assert: $A codePoint hex = '16r41'.
	self assert: $ codePoint hex = '16r20AC'.
	"
	^self class unicodeCodePoints at: self numericValue + 1! !
!Character methodsFor: 'converting' stamp: 'jmv 10/8/2018 18:44:52' prior: 16800616!
         asUnaccented
	"
	$A asUnaccented
	$ asUnaccented
	(0 to: 255) collect: [ :i | (Character numericValue: i) asUnaccented ]
	(0 to: 255) collect: [ :i | (Character numericValue: i) asUnaccented  asLowercase]
	"
	^ Character
		numericValue: (self class unaccentedTable at: self numericValue + 1)! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 10/8/2018 18:46:39' prior: 16800743!
                   initialize
	"Create the table of unique Characters.
	Character initialize
	"
	self initializeLookupTables .
	self initializeUnicodeCodePoints.! !
!Character class methodsFor: 'converting' stamp: 'jmv 10/8/2018 18:37:44' prior: 16801210!
                   iso8859s15CodeForUnicodeCodePoint: codePoint
	"
	Answer nil if the Unicode codePoint is not a valid ISO 8859-15 character
	
	self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r41) = $A iso8859s15Code.
	self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r20AC) = $ iso8859s15Code.
	"
	| code |
	code _ (self unicodeCodePoints indexOf: codePoint) -1.
	code = -1 ifTrue: [ ^nil ].
	^code! !
!BitBltCanvas class methodsFor: 'cached state access' stamp: 'jmv 10/8/2018 18:33:24' prior: 16787424!
                               releaseClassCachedState
	"
	BitBltCanvas releaseClassCachedState
	"
	AccessProtect _ nil.
	AuxForm _ nil.
	AuxBlitter _ nil! !

StrikeFont class removeSelector: #releaseClassCachedState!

StrikeFont class removeSelector: #releaseClassCachedState!

BitBlt class removeSelector: #releaseClassCachedState!

BitBlt class removeSelector: #releaseClassCachedState!

Color class removeSelector: #releaseClassCachedState!

Color class removeSelector: #releaseClassCachedState!

Character class removeSelector: #initClassCachedState!

Character class removeSelector: #initClassCachedState!

Character class removeSelector: #releaseClassCachedState!

Character class removeSelector: #releaseClassCachedState!

Character initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3471-KeepExpensiveCachedStuff-JuanVuletich-2018Oct08-18h41m-jmv.3.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3470] on 8 October 2018 at 4:36:36 pm'!
!Float methodsFor: 'comparing' stamp: 'jmv 10/8/2018 16:29:40' prior: 16845719!
                   hash
	"Hash is reimplemented because = is implemented. Both words of the float are used. (The bitShift:'s ensure that the intermediate results do not become a large integer.) Care is taken to answer same hash as an equal Integer."

	| asInteger |
	self isFinite ifTrue: [
		asInteger _ self truncated.
		asInteger = self ifTrue: [
			^ asInteger hash ]].
	^ ((self basicAt: 1) bitShift: -4) +
	   ((self basicAt: 2) bitShift: -4)! !
!Fraction methodsFor: 'comparing' stamp: 'jmv 10/8/2018 16:30:04' prior: 16849531!
                            hash
	"Hash is reimplemented because = is implemented.
	Care is taken that a Fraction equal to a Float also have an equal hash"

	^ self asFloat hash! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3472-Fraction-hash-consistentWithFloat-JuanVuletich-2018Oct08-16h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3472] on 9 October 2018 at 9:53:17 am'!
!Float methodsFor: 'converting' stamp: 'jmv 10/8/2018 18:05:43'!
                  partBits: aThreeArgumentBlock
	"
	Extract the bits for Sign, Mantissa and Exponent parts of the Floating Point representation.
	Just extract the bits. Do not add implicit bit. Do not correct denormals. Do not substract exponent bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	| allBits signBit exponentBits mantissaBits |

	" Extract the bits of an IEEE double float "
	allBits _ ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).

	" Extract the sign and the biased exponent "
	signBit _ allBits bitShift: -63.
	exponentBits _ (allBits bitShift: -52) bitAnd: 16r7FF.

	" Extract fractional part "
	mantissaBits _ allBits bitAnd: 16r000FFFFFFFFFFFFF.

	"Evaluate the block"
	^aThreeArgumentBlock value: signBit value: exponentBits value: mantissaBits! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 10/8/2018 18:10:16'!
                             exponentBits
	"
	Actual bits for the exponent part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not substract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f exponentBits. f exponentPart. f exponent } print ].
	"

	self partBits: [ :signBit :exponentBits :mantissaBits |
		^ exponentBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 10/8/2018 18:23:14'!
      mantissaBits
	"
	Actual bits for the mantissa part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not substract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f mantissaBits. f mantissaPart. f significand. } print ].
	"
	self partBits: [ :signBit :exponentBits :mantissaBits |
		^ mantissaBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 10/8/2018 18:15:24'!
   signBit
	"
	Actual bits for the exponent part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not substract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0. 0.0. -0.0} do: [ :f |
		{ f. f signBit. f signPart. f sign } print ].
	"

	self partBits: [ :signBit :exponentBits :mantissaBits |
		^ signBit ]! !
!Float methodsFor: 'converting' stamp: 'jmv 10/8/2018 18:17:37' prior: 16844918!
                partValues: aThreeArgumentBlock ifInfinite: infiniryBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"
	| sign exponent mantissa |

	self partBits: [ :signBit :exponentBits :mantissaBits |

		" Extract the sign"
		sign _ signBit = 0 ifTrue: [1] ifFalse: [-1].

		" Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infiniryBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent _ exponentBits - 16r3FF.

		" Replace omitted leading 1 in fraction if appropriate"
		"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa"	
		exponentBits = 0
			ifTrue: [
				mantissa _ mantissaBits.
				exponent _ exponent + 1 ]
			ifFalse: [
				mantissa _ mantissaBits bitOr: 16r0010000000000000 ].

		"Evaluate the block"
		^aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 10/8/2018 18:13:53' prior: 50414541!
           significandAsInteger
	"The actual bits in the mantissa of the receiver, as an integer number, including the implicit leading 1 if appropriate.
	See #exponentPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self mantissaPart! !
!BoxedFloat64 methodsFor: 'truncation and round off' stamp: 'jmv 10/8/2018 17:52:44' prior: 50414558!
                            exponent
	"Primitive. Consider the receiver to be represented as a power of two
	multiplied by a mantissa between one and two  or between -1 and -2 (#significand).
	 Answer with the SmallInteger to whose power two is raised.
	Optional. See Object documentation whatIsAPrimitive.
	See also #signPart,  #significandAsInteger and #exponentPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. f significand . f exponent. f significand * (2 raisedToInteger: f exponent) = f } print ].
	"

	| positive |
	<primitive: 53>
	self >= 1.0 ifTrue: [^self floorLog: 2].
	self > 0.0
		ifTrue: 
			[positive _ (1.0 / self) exponent.
			self = (1.0 / (1.0 timesTwoPower: positive))
				ifTrue: [^positive negated]
				ifFalse: [^positive negated - 1]].
	self = 0.0 ifTrue: [^-1].
	^self negated exponent! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3473-Float-partBits-JuanVuletich-2018Oct09-09h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3471] on 9 October 2018 at 2:29:53 pm'!
!LargeNegativeInteger methodsFor: 'comparing' stamp: 'jmv 10/9/2018 14:20:27'!
             hash

	self > Float maxExactInteger negated ifFalse: [
		^ self asFloat hash ].
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !
!Float methodsFor: 'comparing' stamp: 'jmv 10/9/2018 12:30:01' prior: 50417715!
                             hash
	"Hash is reimplemented because = is implemented. Both words of the float are used. (The bitShift:'s ensure that the intermediate results do not become a large integer.) Care is taken to answer same hash as an equal Integer."

	| asInteger |
	self isFinite ifTrue: [
		asInteger _ self truncated.
		asInteger abs < Float maxExactInteger ifTrue: [
			^ asInteger hash ]].
	^ ((self basicAt: 1) bitShift: -4) +
	   ((self basicAt: 2) bitShift: -4)! !
!Fraction methodsFor: 'comparing' stamp: 'jmv 10/8/2018 16:30:04' prior: 50417732!
       hash
	"Hash is reimplemented because = is implemented.
	Care is taken that a Fraction equal to a Float also have an equal hash"

	^ self asFloat hash! !
!Integer methodsFor: 'comparing' stamp: 'jmv 10/9/2018 12:30:19' prior: 50333045!
                     hash
	"Hash is reimplemented because = is implemented.
	| s |
	s _ (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	self abs < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].
	^self hashMultiply! !
!LargePositiveInteger methodsFor: 'comparing' stamp: 'jmv 10/9/2018 14:20:30' prior: 16862513!
            hash

	self < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3474-Integer-hash-consistentWithFloat-JuanVuletich-2018Oct09-14h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3474] on 9 October 2018 at 2:51:00 pm'!
!LargePositiveInteger methodsFor: 'comparing' stamp: 'jmv 10/9/2018 14:49:10' prior: 50417966!
   hash
	self < `(2 raisedToInteger: Float emax+1)` ifFalse: [
		^ `Float infinity hash` ].
	self < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !
!LargeNegativeInteger methodsFor: 'comparing' stamp: 'jmv 10/9/2018 14:50:07' prior: 50417923!
   hash

	self > `(2 raisedToInteger: Float emax+1) negated` ifFalse: [
		^ `Float negativeInfinity hash` ].
	self > Float maxExactInteger negated ifFalse: [
		^ self asFloat hash ].
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3475-Faster-LargeInteger-hash-JuanVuletich-2018Oct09-14h38m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3476] on 9 October 2018 at 4:31:26 pm'!
!Number methodsFor: 'truncation and round off' stamp: 'jmv 10/9/2018 16:30:05' prior: 16880603!
                              rounded
	"Answer the integer nearest the receiver."
	"See https://en.wikipedia.org/wiki/Rounding#Round_half_to_even"

	| truncated fractionPartAbs |
	truncated _ self truncated.
	fractionPartAbs _ (self-truncated) abs.
	fractionPartAbs = (1/2)
		ifTrue: [ truncated even ifTrue: [^truncated] ifFalse: [^truncated + self sign]].
	fractionPartAbs < (1/2)
		ifTrue: [^ truncated]
		ifFalse: [^ truncated + self sign]! !

Float removeSelector: #rounded!

Float removeSelector: #rounded!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3476-RoundHalfToEven-JuanVuletich-2018Oct09-16h28m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3476] on 10 October 2018 at 3:49:14 pm'!
!Integer methodsFor: 'comparing' stamp: 'jmv 10/10/2018 15:44:51' prior: 50417956!
       hash
	"Hash is reimplemented because = is implemented.
	| s |
	s _ (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	"Can only happen in 64 bits images..."
	self abs < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].

	"In 32 bit image it will always go this way"
	^self hashMultiply! !
!LargePositiveInteger methodsFor: 'comparing' stamp: 'jmv 10/10/2018 15:44:55' prior: 50417981!
                    hash

	self < `(2 raisedToInteger: Float emax+1)` ifFalse: [
		^ `Float infinity hash` ].

	self < Float maxExactInteger ifFalse: [
		"Will always enter here for 64 bits images."
		^ self asFloat hash ].

	"May only reach here in 32 bit images"
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !
!LargeNegativeInteger methodsFor: 'comparing' stamp: 'jmv 10/10/2018 15:45:00' prior: 50417991!
        hash

	self > `(2 raisedToInteger: Float emax+1) negated` ifFalse: [
		^ `Float negativeInfinity hash` ].

	self > Float maxExactInteger negated ifFalse: [
		"Will always enter here for 64 bits images."
		^ self asFloat hash ].

	"May only reach here in 32 bit images"
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3477-hashComments-JuanVuletich-2018Oct10-15h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3476] on 10 October 2018 at 3:58:36 pm'!
!Float methodsFor: 'comparing' stamp: 'jmv 10/10/2018 15:53:22' prior: 50417931!
                               hash
	"Hash is reimplemented because = is implemented. Both words of the float are used. (The bitShift:'s ensure that the intermediate results do not become a large integer.) Care is taken to answer same hash as an equal Integer."

	| asInteger |
	self isFinite ifTrue: [
		asInteger _ self truncated.
		(asInteger = self and: [ asInteger abs < Float maxExactInteger ]) ifTrue: [
			^ asInteger hash ]].
	^ ((self basicAt: 1) bitShift: -4) +
	   ((self basicAt: 2) bitShift: -4)! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3478-Float-hash-fix-JuanVuletich-2018Oct10-15h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3478] on 18 October 2018 at 9:52:42 am'!
!Float methodsFor: 'comparing' stamp: 'jmv 10/18/2018 09:52:13' prior: 50418082!
           hash
	"Hash is reimplemented because = is implemented. Both words of the float are used. (The bitShift:'s ensure that the intermediate results do not become a large integer.) Care is taken to answer same hash as an equal Integer."

	| asInteger |
	self isFinite ifTrue: [
		asInteger _ self truncated.
		"See Integer>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
		"Very big integers will answer true when asked #= with their own conversion to Float,
		But that Float will #asInteger to a different integer. Use Float hash in those cases.
		In addition, there is a performance improvement: the hash in LargeIntegers could
		get very slow for very big numbers"
		(asInteger = self and: [ asInteger abs < Float maxExactInteger ]) ifTrue: [
			^ asInteger hash ]].
	^ ((self basicAt: 1) bitShift: -4) +
	   ((self basicAt: 2) bitShift: -4)! !
!Integer methodsFor: 'comparing' stamp: 'jmv 10/18/2018 09:48:12' prior: 50418035!
              hash
	"Hash is reimplemented because = is implemented.
	| s |
	s _ (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	"Can only happen in 64 bits images...
	See Float>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
	self abs < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].

	"In 32 bit image it will always go this way"
	^self hashMultiply! !
!LargePositiveInteger methodsFor: 'comparing' stamp: 'jmv 10/18/2018 09:48:28' prior: 50418048!
     hash

	self < `(2 raisedToInteger: Float emax+1)` ifFalse: [
		^ `Float infinity hash` ].

	self < Float maxExactInteger ifFalse: [
		"Will always enter here for 64 bits images.
		See Float>>#hash, Integer>>#hash and LargeNegativeInteger>>#hash"
		^ self asFloat hash ].

	"May only reach here in 32 bit images"
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !
!LargeNegativeInteger methodsFor: 'comparing' stamp: 'jmv 10/18/2018 09:48:53' prior: 50418061!
     hash

	self > `(2 raisedToInteger: Float emax+1) negated` ifFalse: [
		^ `Float negativeInfinity hash` ].

	self > Float maxExactInteger negated ifFalse: [
		"Will always enter here for 64 bits images.
		See Float>>#hash, Integer>>#hash and LargePositiveInteger>>#hash"
		^ self asFloat hash ].

	"May only reach here in 32 bit images"
	^ByteArray
		hashBytes: self
		startingWith: self species hash! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3479-Float-Integer-hash-comments-JuanVuletich-2018Oct18-09h46m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3478] on 18 October 2018 at 9:59:15 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 10/18/2018 09:58:57' prior: 50412783!
                               knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons ')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3480-AddFacundoAsKnownAuthor-JuanVuletich-2018Oct18-09h52m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3470] on 12 October 2018 at 12:23:20 pm'!
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/8/2018 12:49:55'!
                 askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector withCaption: aCaptionText ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass = aSuperclass ifTrue: [ { aClass } ] ifFalse: [ aClass withAllSuperclassesUpTo: aSuperclass ].
	chosenClassIndex _ PopUpMenu
		withCaption: aCaptionText
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/8/2018 12:38:20'!
               implement: aMessage inCategory: aCategory fromClass: aClass context: aContext

	aClass
		compile: (aMessage createStubMethodFor: aClass)
		classified: aCategory.
		
	aContext privRefreshWith: (aClass lookupSelector: aMessage selector).
	aMessage arguments withIndexDo: [ :arg :index | aContext tempAt: index put: arg ].
	self resetContext: aContext! !
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/8/2018 12:50:42' prior: 50336675!
       askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	^ self askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector withCaption: 'Define #', aSelector, ' in which class?' ifCancel: cancelBlock! !
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/12/2018 12:22:13'!
                               createMethodWhenDoesNotUnderstand

	| message chosenClass interruptedContext |
	
	"The doesNotUndertand context must be selected - Hernan"
	contextStackIndex = 1 ifFalse: [ self contextStackIndex: 1 oldContextWas: self selectedContext ].
		
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	
	self implement: message inClass: chosenClass context: self selectedContext

! !
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/12/2018 12:22:26' prior: 50336762!
       createMethod

	self wasInterrupedOnDoesNotUnderstand ifTrue: [ ^self createMethodWhenDoesNotUnderstand ].
	self wasInterruptedOnSubclassResponsibility ifTrue: [ ^self createMethodOnSubclassResponsibility ].
	self wasInterruptedOnOverridableMethod ifTrue: [ ^self overrideMethodOnSubclass ].
	
	self inform: 'Only available to override methods or for #doesNotUnderstand: and #subclassResponsibility' ! !
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/8/2018 12:37:52' prior: 50368123!
                    implement: aMessage inClass: aClass context: aContext 
	
	self implement: aMessage inCategory: (self askForCategoryIn: aClass default: 'as yet unclassified') fromClass: aClass context: aContext! !
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/8/2018 13:20:36'!
                  overrideMethodOnSubclass

	| chosenClass lastPossibleClass message methodCategory methodClass receiverClass |

	methodCategory _ self interruptedContext method category.
	methodClass _ self interruptedContext method methodClass.
	receiverClass _ self interruptedContext receiver class.
	lastPossibleClass _ (receiverClass withAllSuperclassesPreviousTo: methodClass) last.
	message _ self interruptedContext messageForYourself.

	chosenClass _ self
		askForSuperclassOf: receiverClass
		upTo: lastPossibleClass
		toImplement: message selector
		withCaption: 'Override #', message selector, ' in which class?'
		ifCancel: [^self].
	
	^ self implement: message inCategory: methodCategory fromClass: chosenClass context: self interruptedContext! !
!Debugger methodsFor: 'method creation' stamp: 'FJG 10/8/2018 13:20:43'!
               wasInterruptedOnOverridableMethod
	| methodClass receiverClass |
	
	methodClass _ self interruptedContext method methodClass.
	receiverClass _ self interruptedContext receiver class.
	
	^ methodClass ~= receiverClass! !
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'FJG 10/8/2018 13:21:29'!
                 allSuperclassesPreviousTo: aSuperclass
	
	| superclasses |
	
	superclasses _ self allSuperclassesUpTo: aSuperclass.
	
	^ superclasses allButLast! !
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'FJG 10/8/2018 13:21:39'!
                         withAllSuperclassesPreviousTo: aSuperclass

	| classes |
	
	classes _ self withAllSuperclassesUpTo: aSuperclass.
	
	^ classes allButLast! !

Debugger removeSelector: #createMethodWhenDoesNotUndertand!

Debugger removeSelector: #createMethodWhenDoesNotUndertand!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3481-OverrideMethodsOnDebugger-FJG.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3481] on 18 October 2018 at 10:40:55 am'!
!Theme class methodsFor: 'consistency verification' stamp: 'HAW 10/10/2018 16:57:50'!
                      verifyShoutConfig

	"
	self verifyShoutConfig
	"
	^self allSubclasses
		inject: OrderedCollection new into: [ :errors :themeClass |
			[ themeClass new generateShoutConfig ] on: Error do: [:anError | | atIfAbsentContext key |
				"I have to do this because error is not resumable - Hernan"
				atIfAbsentContext := thisContext.
				10 timesRepeat: [ atIfAbsentContext := atIfAbsentContext sender ].
				key := atIfAbsentContext tempAt: 1.
				errors add: themeClass -> key.
				atIfAbsentContext receiver at: key put: Color black.
				atIfAbsentContext restart ].
			errors ]! !
!Theme methodsFor: 'shout' stamp: 'jmv 10/18/2018 10:39:38' prior: 50401988!
                shout
	"Color symbols as an association list.
	SHTextStylerST80 initialize
	"

	^ {
		#defaults 					-> #black.
		#undefined 					-> #red.
		#comment 					-> #(green muchDarker).
		#methodTags 				-> #(green muchDarker).
		#pseudoVariables 			-> #(red muchDarker).
		#literals 					-> #(green muchDarker).
		#messages 					-> #(blue darker).
		#arguments 					-> #(cyan muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages 		-> #(gray veryMuchDarker).
		#blockLevelZero 			-> #black.
		#blockLevelOne 			-> #brown.
		#blockLevelTwo 			-> #magenta.
		#blockLevelThree 			-> #red.
		#blockLevelFour 			-> #(orange darker).
		#blockLevelFive 			-> #(orange muchDarker).
		#blockLevelSix 			-> #(green muchDarker).
		#blockLevelSeven 			-> #blue.
		#tempBar 					-> #gray.
		#tempVars 					-> #(gray muchDarker).
	}! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3482-VerifyShoutConfig-HernanWilkinson-2018Oct18-10h28m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3482] on 18 October 2018 at 11:06:39 am'!
!Float methodsFor: 'mathematical functions' stamp: 'RNG 10/12/2018 05:43:21' prior: 16844725!
                  sign: aNumber
	"Return a Number with the same sign as aNumber and same magnitude as self.
	Implementation is different from super to handle the special case of Float negativeZero."

	(self isZero and: [aNumber sign negative]) ifTrue: [^Float negativeZero].
	^aNumber copySignTo: self! !
!Float methodsFor: 'converting' stamp: 'jmv 10/18/2018 10:56:50' prior: 16844793!
               asIEEE32BitWord
	"Convert the receiver into a 32 bit Integer value representing the same number in IEEE 32 bit format.
	Used for conversion in FloatArrays only."
	
	| word1 word2 sign mantissa exponent destWord truncatedBits mask roundToUpper |
	
	"quickly skip positive and negative zero"
	self isZero ifTrue: [^self basicAt: 1].
	
	"retrieve 64 bits of IEEE 754 double"
	word1 := self basicAt: 1.
	word2 := self basicAt: 2.
	
	"prepare sign exponent and mantissa of 32 bits float"
	sign := word1 bitAnd: 16r80000000.
	exponent := ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.
	mantissa := (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).
	truncatedBits := (word2 bitAnd: 16r1FFFFFFF).

	"We must now honour default IEEE rounding mode (round to nearest even)"
	
	"we are below gradual underflow, even if rounded to upper mantissa"
	exponent < -24 ifTrue: [^sign "this can be negative zero"].
	
	"BEWARE: rounding occurs on less than 23bits when gradual underflow"
	exponent <= 0
		ifTrue:
			[mask := 1 bitShift: exponent negated.
			mantissa := mantissa bitOr: 16r800000.
			roundToUpper := (mantissa bitAnd: mask) isZero not
				and: [truncatedBits isZero not
					or: [(mantissa bitAnd: mask - 1) isZero not
						or: [(mantissa bitAnd: mask*2) isZero not]]].
			mantissa := mantissa bitShift: exponent - 1.
			"exponent := exponent + 1"]
		ifFalse:
			[roundToUpper := (truncatedBits bitAnd: 16r10000000) isZero not
				and: [(mantissa bitAnd: 16r1) isZero not
					or: [(truncatedBits bitAnd: 16r0FFFFFFF) isZero not]]
			].
		
	"adjust mantissa and exponent due to IEEE rounding mode"
	roundToUpper
		ifTrue:
			[mantissa := mantissa + 1.
			mantissa > 16r7FFFFF
				ifTrue:
					[mantissa := 0.
					exponent := exponent+1]].

	exponent > 254 ifTrue: ["Overflow"
		exponent := 255.
		self isNaN
			ifTrue: [mantissa isZero
				ifTrue: ["BEWARE: do not convert a NaN to infinity due to truncatedBits"
					mantissa := 1]]
			ifFalse: [mantissa := 0]].
		
	"Encode the word"
	destWord := (sign bitOr: ((exponent max: 0) bitShift: 23)) bitOr: mantissa.
	^ destWord! !
!Float methodsFor: 'converting' stamp: 'RNG 10/12/2018 05:44:04' prior: 16844974!
                              withNegativeSign
	"Same as super, but handle the subtle case of Float negativeZero"
	
	self isZero ifTrue: [^self class negativeZero].  
	^super withNegativeSign! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 10/18/2018 10:59:41' prior: 16845001!
                           predecessor
	| ulp |
	self isFinite ifFalse: [
		(self isNaN or: [self negative]) ifTrue: [^self].
		^Float fmax].
	ulp := self ulp.
	^self - (0.5 * ulp) = self
		ifTrue: [self - ulp]
		ifFalse: [self - (0.5 * ulp)]! !
!Float methodsFor: 'truncation and round off' stamp: 'RNG 10/12/2018 05:43:53' prior: 16845059!
     ulp
	"Answer the unit of least precision of self (the power of two corresponding to last bit of mantissa)"
	
	| exponent |
	self isFinite ifFalse: [^self abs].
	self isZero ifTrue: [^Float fmin].
	exponent := self exponent.
	^exponent < self class emin
		ifTrue: [Float fminDenormalized]
 		ifFalse: [Float epsilon timesTwoPower: exponent]! !
!Float methodsFor: 'testing' stamp: 'RNG 10/12/2018 05:46:10' prior: 16845075!
                          isFinite
	"simple, byte-order independent test for rejecting Not-a-Number and (Negative)Infinity"

	^(self - self) isZero! !
!Float methodsFor: 'printing' stamp: 'RNG 10/12/2018 05:43:01' prior: 50405006!
                   printAsIEEE32BitPrecisionFloatOn: aStream base: base
	"Handle sign, zero, and NaNs; all other values passed to absPrintOn:base:mantissaSignificantBits:
	Print as a 32 bit Float" 

	self isNaN ifTrue: [aStream nextPutAll: 'NaN'. ^ self]. "check for NaN before sign"
	self > 0.0
		ifTrue: [self absPrintOn: aStream base: base mantissaSignificantBits: 24]
		ifFalse:
			[self sign = -1
				ifTrue: [aStream nextPutAll: '-'].
			self isZero
				ifTrue: [aStream nextPutAll: '0.0'. ^ self]
				ifFalse: [self negated absPrintOn: aStream base: base mantissaSignificantBits: 24]]! !
!Float methodsFor: 'printing' stamp: 'RNG 10/12/2018 05:43:12' prior: 16845527!
                printOn: aStream base: base
	"Handle sign, zero, and NaNs; all other values passed to absPrintOn:base:" 

	self isNaN ifTrue: [aStream nextPutAll: 'NaN'. ^ self]. "check for NaN before sign"
	self > 0.0
		ifTrue: [self absPrintOn: aStream base: base]
		ifFalse:
			[self sign = -1
				ifTrue: [aStream nextPutAll: '-'].
			self isZero
				ifTrue: [aStream nextPutAll: '0.0'. ^ self]
				ifFalse: [self negated absPrintOn: aStream base: base]]! !
!Float methodsFor: 'printing' stamp: 'RNG 10/12/2018 05:43:39' prior: 16845574!
                  storeOn: aStream base: base 
	"Print the Number exactly so it can be interpreted back unchanged"
	self isFinite
		ifTrue: [self sign = -1 ifTrue: [aStream nextPutAll: '-'].
			base = 10 ifFalse: [aStream print: base; nextPut: $r].
			self isZero
				ifTrue: [aStream nextPutAll: '0.0']
				ifFalse: [self abs absPrintExactlyOn: aStream base: base]]
		ifFalse: [self isNaN
				ifTrue: [aStream nextPutAll: 'Float nan']
				ifFalse: [self > 0.0
						ifTrue: [aStream nextPutAll: 'Float infinity']
						ifFalse: [aStream nextPutAll: 'Float infinity negated']]]! !
!Color methodsFor: 'access' stamp: 'RNG 10/12/2018 05:45:04' prior: 50353255!
                               hue
	"Return the hue of this color, an angle in the range [0.0..360.0].
	Color orange hue
	"

	| r g b max min span h |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	span _ (max - min) asFloat.
	span isZero ifTrue: [ ^ 0.0 ].

	r = max ifTrue: [
		h _ ((g - b) asFloat / span) * 60.0.
	] ifFalse: [
		g = max
			ifTrue: [ h _ 120.0 + (((b - r) asFloat / span) * 60.0). ]
			ifFalse: [ h _ 240.0 + (((r - g) asFloat / span) * 60.0). ].
	].

	^h mod: 360.0! !
!Color methodsFor: 'access' stamp: 'RNG 10/12/2018 05:45:46' prior: 50353301!
                saturation
	"Return the saturation of this color, a value between 0.0 and 1.0.
	Color red saturation
	Color gray saturation
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	max isZero ifTrue: [ ^0.0 ].
	^max - min / max! !
!Color class methodsFor: 'class initialization' stamp: 'RNG 10/12/2018 05:45:57' prior: 50354666!
                   initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollection new.
	grayIndices _ OrderedCollection new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation isZero ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !
!TranslucentColor methodsFor: 'queries' stamp: 'RNG 10/12/2018 05:46:53' prior: 50356600!
           isTransparent
	^ self alpha isZero! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3483-Use-isZero-NahuelGarbezza-2018Oct18-10h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3461] on 15 October 2018 at 10:06:14 pm'!
!Behavior methodsFor: 'as yet unclassified' stamp: 'HAW 10/15/2018 20:57:14'!
           addMethodsTo: methodsReferencingLiteral thatReferenceTo: aLiteral special: specialFlag byte: specialByte
	
	| selectors |
	
	selectors _ self whichSelectorsReferTo: aLiteral special: specialFlag byte: specialByte.
	selectors do: [ :sel | methodsReferencingLiteral add: (MethodReference class: self selector: sel) ]! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'HAW 10/15/2018 20:57:14'!
                    addTo: aSet methodsThatReferenceInHierarchyTo: aSymbol special: special byte: byte.
	
	self withAllSuperAndSubclassesDoGently: [ :class |
		class addMethodsTo: aSet thatReferenceTo: aSymbol special: special byte: byte ] 
		! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'HAW 10/15/2018 20:59:04'!
               rejectSelectorsFrom: selectors thatReferenceTo: aLiteral byte: specialByte 

	"For special selectors, look for the literal in the source code.
	Otherwise, for example, searching for senders of #== will include senders of #ifNil.
	Except for #at:put:, because it has two arguments and won't find it in the source code like that."

	^ (specialByte isNil or: [ aLiteral = #at:put: ]) 
		ifTrue: [ selectors ]
		ifFalse: [ selectors select: [ :sel | ((self sourceCodeAt: sel) findString: aLiteral) > 0]]! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'HAW 10/15/2018 21:56:17' prior: 16784461!
     whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |

	Preferences thoroughSenders 
		ifTrue: [ who _ self thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte ]
		ifFalse: [ 
			who _ Set new.
			self selectorsAndMethodsDo: [:sel :method |
				((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]]) ifTrue: [
					((literal isVariableBinding) not or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
						or: [(method indexOfLiteral: literal) ~= 0]]) ifTrue: [who add: sel]]]].
		
	^self rejectSelectorsFrom: who thatReferenceTo: literal byte: specialByte ! !
!Behavior methodsFor: 'user interface' stamp: 'HAW 10/15/2018 20:58:17' prior: 50343709!
allLocalCallsOn: aSymbol
	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."

	| aSet special byte cls |
	
	aSet _ Set new.
	cls _ self theNonMetaClass.
	special _ Smalltalk hasSpecialSelector: aSymbol ifTrueSetByte: [ :b | byte _ b ].
	
	cls addTo: aSet methodsThatReferenceInHierarchyTo: aSymbol special: special byte: byte.
	cls class addTo: aSet methodsThatReferenceInHierarchyTo: aSymbol special: special byte: byte.
	
	^aSet! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 10/15/2018 20:57:14' prior: 50332942!
                               allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection special byte |

	#(23 48 'fred' (new open:label:)) size.
	"Example above should find #open:label:, though it is deeply embedded here."

	aCollection _ OrderedCollection new.
	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].
	self allBehaviorsDo: [:class | class addMethodsTo: aCollection thatReferenceTo: aLiteral special: special byte: byte ].
	
	^ aCollection! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 10/15/2018 21:07:56' prior: 16922089!
       numberOfSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	"
	| count specialFlag specialByte |

	count _ 0.
	specialFlag _ self hasSpecialSelector: aSymbol ifTrueSetByte: [ :b | specialByte _ b ].
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			((method hasLiteral: aSymbol) or: [specialFlag and: [(method scanFor: specialByte) and: [ ((class sourceCodeAt: sel) findString: aSymbol) > 0 ]]])
				ifTrue: [ count _ count + 1 ]]].
	^ count! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 10/15/2018 20:57:14' prior: 16924287!
                            browseViewReferencesFromNonViews
	"
	Smalltalk browseViewReferencesFromNonViews
	"
	| aLiteral aCollection |

	aCollection _ OrderedCollection new.

	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)"
"	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"
	PluggableMorph withAllSubclassesDo: [ :view |
"	MenuMorph withAllSubclassesDo: [ :view |"
		
		aLiteral _ view name.
		
		"tweak to linclude refs to SysWindow subhierarchy or not"
		(view includesBehavior: SystemWindow) & false ifFalse: [
			Smalltalk allBehaviorsDo: [ :class |
				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [
					class addMethodsTo: aCollection thatReferenceTo: aLiteral special: false byte: nil ]]]].
	
	Smalltalk
		browseMessageList: aCollection asSet asArray sort
		name: 'References to Views from non-Views'
		autoSelect: ''.! !

Behavior removeSelector: #addMethodsTo:thatReferTo:special:byte:!

Behavior removeSelector: #addTo:referencesInHierarchyTo:special:byte:!

Behavior removeSelector: #addTo:referencesTo:special:byte:!

Behavior removeSelector: #addTo:referencesTo:special:byte:!

Behavior removeSelector: #rejectSelectorsFrom:thatReferTo:byte:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3484-Fix-whichSelectorsReferTo-HernanWilkinson-2018Oct02-16h57m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3484] on 22 October 2018 at 2:36:01 pm'!
!MorphicTranslation methodsFor: 'transforming rects' stamp: 'jmv 10/22/2018 14:32:45' prior: 16878595!
                        displayBoundsOfTransformOf: aRectangle
	"Externalize aRectangle, and find a bounding rectangle with horizontal 
	and vertical bounds and integer coordinates (i.e. adisplayBounds)."

	^(aRectangle translatedBy: self translation) rounded! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3485-displayBounds-fix-JuanVuletich-2018Oct22-14h35m-jmv.1.cs.st----!

----SNAPSHOT----#(22 October 2018 2:46:03.124313 pm) Cuis5.0-3485-v3.image priorSource: 2748744!

----QUIT----#(22 October 2018 2:46:33.049559 pm) Cuis5.0-3485-v3.image priorSource: 2797526!

----STARTUP----#(30 November 2018 9:34:20.981965 am) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3485-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3485] on 5 November 2018 at 1:32:47 pm'!
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/5/2018 13:32:18' prior: 16811768!
annotationForSelector: aSelector ofClass: aClass 
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"
	| stamp sendersCount implementorsCount aCategory separator aString aList aComment stream requestList |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].
	aSelector == #Hierarchy
		ifTrue: [^ self annotationForHierarchyFor: aClass].
	stream _ WriteStream on: String new.
	requestList _ self annotationRequests.
	separator _ requestList size > 1
				ifTrue: [self annotationSeparator]
				ifFalse: [''].
	requestList
		do: [:aRequest | 
			aRequest == #firstComment
				ifTrue: [
					aComment _ aClass firstCommentAt: aSelector.
					aComment isEmptyOrNil
						ifFalse: [stream nextPutAll: aComment , separator]].
			aRequest == #masterComment
				ifTrue: [
					aComment _ aClass supermostPrecodeCommentFor: aSelector.
					aComment isEmptyOrNil
						ifFalse: [stream nextPutAll: aComment , separator]].
			aRequest == #documentation
				ifTrue: [
					aComment _ aClass precodeCommentOrInheritedCommentFor: aSelector.
					aComment isEmptyOrNil
						ifFalse: [stream nextPutAll: aComment , separator]].
			aRequest == #timeStamp
				ifTrue: [
					stamp _ self timeStamp.
					stream
						nextPutAll: (stamp size > 0
								ifTrue: [stamp , separator]
								ifFalse: ['no timeStamp' , separator])].
			aRequest == #messageCategory
				ifTrue: [
					aCategory _ aClass organization categoryOfElement: aSelector.
					aCategory
						ifNotNil: ["woud be nil for a method no longer present,  
							e.g. in a recent-submissions browser"
							stream nextPutAll: aCategory , separator]].
			aRequest == #sendersCount
				ifTrue: [
					sendersCount _ Smalltalk numberOfSendersOf: aSelector.
					sendersCount _ sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
					stream nextPutAll: sendersCount , separator].
			aRequest == #implementorsCount
				ifTrue: [
					implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.
					implementorsCount _ implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
					stream nextPutAll: implementorsCount , separator].
			aRequest == #priorVersionsCount
				ifTrue: [
					self
						addPriorVersionsCountForSelector: aSelector
						ofClass: aClass
						to: stream].
			aRequest == #priorTimeStamp
				ifTrue: [
					stamp _ VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
					stamp
						ifNotNil: [stream nextPutAll: 'prior time stamp: ' , stamp , separator]].
			aRequest == #packages
				ifTrue: [
					(aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm |
						(CodePackage packageOfMethod: cm methodReference ifNone: nil)
							ifNil: [ stream nextPutAll: 'part of base system (i.e. not in a package)' ]
							ifNotNil: [ :codePackage |
								stream nextPutAll: 'in package '; nextPutAll: codePackage packageName ].
						stream nextPutAll: separator]].
			aRequest == #changeSets
				ifTrue: [
					aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
					aList size > 0
						ifTrue: [aList size = 1
								ifTrue: [stream nextPutAll: 'only in change set ']
								ifFalse: [stream nextPutAll: 'in change sets:'].
							aList
								do: [:aChangeSet | stream nextPut: Character space; nextPutAll: aChangeSet name ]
								separatedBy: [ stream nextPut: $, ]]
						ifFalse: [stream nextPutAll: 'in no change set'].
					stream nextPutAll: separator].
			aRequest == #allChangeSets
				ifTrue: [
					aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
					aList size > 0
						ifTrue: [aList size = 1
								ifTrue: [stream nextPutAll: 'only in change set ']
								ifFalse: [stream nextPutAll: 'in change sets:'].
							aList
								do: [:aChangeSet | stream nextPut: Character space; nextPutAll: aChangeSet name ]
								separatedBy: [ stream nextPut: $, ]]
						ifFalse: [stream nextPutAll: 'in no change set'].
					stream nextPutAll: separator].
			aRequest == #allBaseSystemChangeSets
				ifTrue: [
					aList _ (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
					aList size > 0
						ifTrue: [
							aList size = 1
								ifTrue: [stream nextPutAll: 'only in base system change set']
								ifFalse: [stream nextPutAll: 'in base system change sets:'].
							aList
								do: [:aChangeSet | stream nextPut: Character space; nextPutAll: aChangeSet name ]
								separatedBy: [ stream nextPut: $, ]]
						ifFalse: [stream nextPutAll: 'in no base system change set'].
					stream nextPutAll: separator].
			aRequest == #closuresInfo
				ifTrue: [
					aString _ aClass closuresInfoAt: aSelector.
					aString size > 0
						ifTrue: [stream nextPutAll: aString , separator]].
		].
	^ stream contents! !
!Preferences class methodsFor: 'parameters' stamp: 'jmv 11/5/2018 13:23:10' prior: 16893375!
     setDefaultAnnotationInfo
	"
	Preferences setDefaultAnnotationInfo
	"
	^ self parameters at: #MethodAnnotations put: #(timeStamp messageCategory implementorsCount sendersCount  packages changeSets)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

Preferences setDefaultAnnotationInfo!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3486-MethodAnnotationsEnhancements-JuanVuletich-2018Nov05-13h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3487] on 17 November 2018 at 11:46:04 am'!
!Collection methodsFor: 'private' stamp: 'HAW 11/17/2018 11:40:56'!
   emptyCollectionDescription

	^self class emptyCollectionDescription ! !
!Collection class methodsFor: 'error descriptions' stamp: 'HAW 11/17/2018 11:41:14'!
   emptyCollectionDescription

	^'this collection is empty'! !
!Collection methodsFor: 'private' stamp: 'HAW 11/17/2018 11:39:51' prior: 16814643!
                errorEmptyCollection

	self error: self emptyCollectionDescription! !
!Collection methodsFor: 'statistics' stamp: 'HAW 11/17/2018 11:34:23' prior: 50414780!
   average: aBlock

	^ self average: aBlock ifEmpty: [ self errorEmptyCollection ]! !
!Collection methodsFor: 'statistics' stamp: 'HAW 11/17/2018 11:38:13'!
      average: aBlock ifEmpty: emptyBlock 
	
	^ (self sum: aBlock ifEmpty: [ ^emptyBlock value ]) / self size! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3487-Average-ifEmpty-HernanWilkinson-2018Nov17-11h28m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3490] on 17 November 2018 at 1:28:17 pm'!
!Collection methodsFor: 'private' stamp: 'GC 11/17/2018 13:12:25'!
           errorCollectionTooSmall

	self error: self class collectionTooSmallDescription! !
!Collection class methodsFor: 'error descriptions' stamp: 'GC 11/17/2018 13:12:24'!
                          collectionTooSmallDescription

	^ 'this collection is too small'! !
!Collection class methodsFor: 'error descriptions' stamp: 'GC 11/17/2018 13:23:46'!
        notKeyedDescription

	^ 'Instances of {1} do not respond to keyed accessing messages.' format: { self className }! !
!Collection class methodsFor: 'error descriptions' stamp: 'GC 11/17/2018 13:18:00'!
                       objectNotFoundDescription

	^ 'Object is not in the collection'! !
!Collection class methodsFor: 'error descriptions' stamp: 'GC 11/17/2018 13:17:06'!
         sizesDoNotMatchDescription

	^ 'collection sizes do not match'! !
!Collection methodsFor: 'private' stamp: 'GC 11/17/2018 13:15:10' prior: 50419283!
           errorEmptyCollection

	self error: self class emptyCollectionDescription! !
!Collection methodsFor: 'private' stamp: 'GC 11/17/2018 13:17:21' prior: 16814647!
 errorNoMatch

	self error: self class sizesDoNotMatchDescription! !
!Collection methodsFor: 'private' stamp: 'GC 11/17/2018 13:18:15' prior: 16814651!
         errorNotFound: anObject
	"Actually, this should raise a special Exception not just an error."

	self error: self class objectNotFoundDescription! !
!Collection methodsFor: 'private' stamp: 'GC 11/17/2018 13:23:53' prior: 16814658!
                         errorNotKeyed

	self error: self class notKeyedDescription
! !
!Collection methodsFor: 'statistics' stamp: 'HAW 11/17/2018 11:34:23' prior: 50419288!
          average: aBlock

	^ self average: aBlock ifEmpty: [ self errorEmptyCollection ]! !
!Collection methodsFor: 'statistics' stamp: 'HAW 11/17/2018 11:38:13' prior: 50419293!
                      average: aBlock ifEmpty: emptyBlock 
	
	^ (self sum: aBlock ifEmpty: [ ^emptyBlock value ]) / self size! !
!Collection class methodsFor: 'error descriptions' stamp: 'GC 11/17/2018 13:13:11' prior: 50419278!
                 emptyCollectionDescription

	^ 'this collection is empty'! !
!SequenceableCollection methodsFor: 'accessing' stamp: 'GC 11/17/2018 13:12:01' prior: 16905895!
  penultimate
	"Answer the penultimate element of the receiver.
	Raise an error if the collection is empty or has just one element."

	| size |
	(size _ self size) < 2 ifTrue: [self errorCollectionTooSmall].
	^ self at: size-1! !

Collection class removeSelector: #collectionToSmallDescription!

Collection class removeSelector: #notKeyedDescription:!

Collection removeSelector: #emptyCollectionDescription!

Collection removeSelector: #emptyCollectionDescription!

Collection removeSelector: #errorCollectionToSmall!

Collection removeSelector: #errorCollectionToSmall!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3488-CollectionErrorsCleanup-GastonCaruso-2018Nov17-13h07m-GC.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3488] on 20 November 2018 at 12:19:12 pm'!
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/20/2018 12:18:39' prior: 16798356!
    fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	nameToUse _ self name.
	nameToUse _ nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse _ Preferences changeSetVersionNumbers
				ifTrue: [
					DirectoryEntry currentDirectory
						nextNameFor: nameToUse coda: '-', Utilities authorInitials
						extension: 'cs.st' ]
				ifFalse: [ (nameToUse , '.' , Utilities dateTimeSuffix , '.cs.st') asFileName ].
		
	nameToUse asFileEntry writeStreamDo: [ :stream |
		stream timeStamp.
		self fileOutPreambleOn: stream.
		self fileOutOn: stream.
		self fileOutPostscriptOn: stream ].
	
	self hasUnsavedChanges: false.
	Preferences checkForSlips
		ifFalse: [^ self].
	slips _ self checkForSlips.
	(slips size > 0
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3489-fixChangeSetFilenamewhenAuthorUsesTilde-JuanVuletich-2018Nov20-12h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3485] on 11 November 2018 at 7:26:03 pm'!
!Parser methodsFor: 'public access' stamp: 'HAW 11/11/2018 19:31:01'!
  parse: sourceStreamOrString class: behavior noPattern: aBoolean

	^ self
		parse: sourceStreamOrString readStream
		class: behavior
		noPattern: aBoolean
		context: nil
		notifying: nil
		ifFail: [^nil]! !
!Workspace methodsFor: 'accessing' stamp: 'HAW 11/11/2018 19:24:17'!
             methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ UndefinedObject methodNodeFor: aSourceCode noPattern: true ] on: Error do: aParsingErrorBlock
! !
!CodeProvider methodsFor: 'contents' stamp: 'HAW 11/11/2018 19:21:24'!
                    methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ self selectedClassOrMetaClass methodNodeFor: aSourceCode ] on: Error do: aParsingErrorBlock
	! !
!Inspector methodsFor: 'contents' stamp: 'HAW 11/11/2018 19:21:12'!
                        methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ self selectedClassOrMetaClass methodNodeFor: aSourceCode noPattern: true ] on: Error do:  aParsingErrorBlock ! !
!Behavior methodsFor: 'methods' stamp: 'HAW 11/11/2018 15:07:12'!
          methodNodeFor: aSourceCode noPattern: aBoolean

	|  parser methodNode |

	parser := self parserClass new
		encoderClass: EncoderForV3PlusClosures;
		yourself.

	methodNode := parser parse: aSourceCode class: self noPattern: aBoolean.
	methodNode sourceText: aSourceCode.

	^methodNode
			! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 11/11/2018 14:27:34'!
                    parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |

	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 11/11/2018 14:26:13'!
         withRangesOf: nodeAtRange including: aPosition do: aBlock

	| currentNodeRange ranges |

	currentNodeRange := nodeAtRange value.
	ranges := currentNodeRange isInterval ifTrue: [ Array with: currentNodeRange ] ifFalse: [ currentNodeRange ].

	ranges do: [ :aRange | (aRange includes: aPosition) ifTrue: [ aBlock value: aRange ]].

	! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 11/11/2018 14:16:41'!
      parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	^encoder parseNodeIncluding: aPosition ifAbsent: aBlockClosure
! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'HAW 11/11/2018 14:29:56'!
                      implementorsOfItWhenErrorsParsing

	"Open an implementors browser on the selected selector"

	| aSelector |

	self lineSelectAndEmptyCheck: [^ self].
	(aSelector _ self selectedSelector) ifNil: [^ morph flash].
	Smalltalk browseAllImplementorsOf: aSelector! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'HAW 11/11/2018 14:15:34'!
             sendersOfItWhenErrorsParsing

	"Open a senders browser on the selected selector"

	| aSelector |

	self lineSelectAndEmptyCheck: [^ self].
	(aSelector _ self selectedSelector) ifNil: [^ morph flash].
	Smalltalk browseAllCallsOn: aSelector! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'HAW 11/11/2018 14:36:04'!
                               withSelectorUnderCursorDo: aBlock ifErrorsParsing: aParsingErrorBlock

	self withSelectorUnderCursorDo: aBlock ifErrorsParsing: aParsingErrorBlock ifNoSelector: [ morph flash ]! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'HAW 11/11/2018 15:30:45'!
                             withSelectorUnderCursorDo: aBlock ifErrorsParsing: aParsingErrorBlock ifNoSelector: aNoSelectorBlock

	| methodNode nodeAtRange nodeUnderCursor |

	methodNode := self codeProvider methodNodeOf: model actualContents ifErrorsParsing: [ :anError | ^ aParsingErrorBlock value: anError ].

	self startIndex < methodNode selectorLastPosition ifTrue: [ ^aBlock value: methodNode selector ].
	nodeAtRange := methodNode parseNodeIncluding: self startIndex ifAbsent: [ ^ aNoSelectorBlock value ].
	nodeUnderCursor := nodeAtRange key.
	nodeUnderCursor isMessageNode ifTrue: [ ^aBlock value: nodeAtRange key selector key ].
	(nodeUnderCursor isLiteralNode and: [ nodeUnderCursor literalValue isSymbol ]) ifTrue: [ ^aBlock value: nodeUnderCursor literalValue ].

	^ aNoSelectorBlock value ! !
!Behavior methodsFor: 'methods' stamp: 'HAW 11/11/2018 15:07:41' prior: 50408642!
  methodNodeFor: aSourceCode

	^self methodNodeFor: aSourceCode noPattern: false! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 11/11/2018 15:21:21'!
   selectorLastPosition

	"If #DoIt selector, returns 0 - Hernan"

	^self selector isUnary
		ifTrue: [ selectorKeywordsRanges ifNil: [ 0 ] ifNotNil: [ selectorKeywordsRanges last last ]]
		ifFalse: [ (encoder sourceRangeFor: arguments last) first last ]! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'HAW 11/11/2018 14:32:52' prior: 16909904!
   implementorsOfIt

	"Open an implementors browser on the  selector under cursor. If it can not parse the source code it uses
	old implementation that looks for the selected selector if any - Hernan"

	self
		withSelectorUnderCursorDo: [ :aSelector | Smalltalk browseAllImplementorsOf: aSelector ]
		ifErrorsParsing: [ :anError | self implementorsOfItWhenErrorsParsing ]

! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'HAW 11/11/2018 15:13:54' prior: 16909977!
           sendersOfIt

	"Open a senders browser on the  selector under cursor. If it can not parse the source code it uses
	old implementation that looks for the selected selector if any - Hernan"

	self
		withSelectorUnderCursorDo: [ :aSelector | Smalltalk browseAllCallsOn: aSelector ]
		ifErrorsParsing: [ :anError | self sendersOfItWhenErrorsParsing ]
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3490-SendersImplementorsEnhancements-HernanWilkinson-2018Nov11-14h14m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3490] on 20 November 2018 at 12:51:56 pm'!
!Message methodsFor: 'comparing' stamp: 'jmv 11/20/2018 12:51:32'!
       = aMessage

	"Any object is equal to itself"
	self == aMessage ifTrue: [ ^ true ].

	self class == aMessage class ifFalse: [ ^false ].
	selector = aMessage selector ifFalse: [ ^false ].
	lookupClass = aMessage lookupClass ifFalse: [ ^false ].
	^args = aMessage arguments! !
!Message methodsFor: 'comparing' stamp: 'jmv 11/20/2018 12:47:30'!
           hash
	"Hash is reimplemented because = is implemented."
	^selector hash bitXor: args hash! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3491-MessageEqualAndHash-JuanVuletich-2018Nov20-12h46m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3485] on 26 October 2018 at 6:11:52 am'!

"Change Set:		3486-CuisCore-AuthorName-2018Oct26-06h03m
Date:			26 October 2018
Author:			Nahuel Garbezza

This adds some shortcuts to browser category list section"!
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'RNG 10/26/2018 06:10:22' prior: 50338653!
                     systemCatListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."

	aChar == $f ifTrue: [ ^ self findClass ].
	aChar == $x ifTrue: [ ^ model removeSystemCategory ].
	aChar == $t ifTrue: [ ^ model runSystemCategoryTests ].
	aChar == $a ifTrue: [ ^ model addSystemCategory ].
	aChar == $A ifTrue: [ ^ model alphabetizeSystemCategories ].
	aChar == $b ifTrue: [ ^ self openSystemCategoryBrowser ].
	aChar == $B ifTrue: [ ^ self browseAllClasses ].
	aChar == $o ifTrue: [ ^ model fileOutSystemCategory ].
	aChar == $u ifTrue: [ ^ model updateSystemCategories ].
	
	^ self classListKey: aChar from: view! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'RNG 10/26/2018 06:10:09' prior: 50411774!
                          systemCategoryMenuOptions

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'recent classes... (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#recent.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse all (B)'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse (b)'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editSystemCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'alphabetize (A)'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeSystemCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'update (u)'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'add item... (a)'.
				#object 			-> 		#model.
				#selector 		-> 		#addSystemCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'rename...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'move to top'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryTop.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'move up'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryUp.
				#icon 			-> 		#goUpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'move down'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryDown.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		40.
				#label 			-> 		'move to bottom'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryBottom.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runSystemCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3492-SystemCategoryMenuOptionsEnh-NahuelGarbezza-2018Oct26-06h03m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3492] on 20 November 2018 at 7:10:56 pm'!
!Message methodsFor: 'comparing' stamp: 'jmv 11/20/2018 19:10:34' prior: 50419649!
                              = aMessage

	"Any object is equal to itself"
	self == aMessage ifTrue: [ ^ true ].

	self class == aMessage class ifFalse: [ ^false ].
	selector = aMessage selector ifFalse: [ ^false ].
	lookupClass = aMessage lookupClass ifFalse: [ ^false ].
	^args literalEqual: aMessage arguments! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3493-MessageEqualFix-JuanVuletich-2018Nov20-19h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3485] on 8 November 2018 at 6:23:20 pm'!
!BlockClosure methodsFor: 'scheduling' stamp: 'jmv 11/8/2018 18:23:08' prior: 16788299!
       fork
	"Create and schedule a Process running the code in the receiver."
	
	"jmv - Do NOT answer the new process.
	
	See http://lists.squeakfoundation.org/pipermail/squeak-dev/2008-February/124960.html
	
	Most times, these methods return before resuming the new process (if priority of new process is less 
	or equal than current). But they might return afterwards.
	
	This means it is very dangerous to use the returned process in code that stores it in some variable 
	and checks for nil to start a new one. If these methods happen to return after the new process is forked,
	chances are the code that starts all this runs again, that variable is nil, and a second process is forked,
	perhaps breaking some shared state. This kind of bug is hard to spot and debug.
	
	Callers wanting the new process object, should call #newProcess, store the answer, and then #resume.
	
	A way to ensure this bug will not ever happen again is just to answer nil"

	self newProcess resume.
	^nil! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3494-fork-commentEnh-JuanVuletich-2018Nov08-18h22m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3494] on 21 November 2018 at 5:40:44 pm'!
!Float methodsFor: 'comparing' stamp: 'jmv 11/21/2018 17:04:24' prior: 50418107!
                    hash
	"Hash is reimplemented because = is implemented."

	| asInteger |
	self isFinite ifTrue: [
		asInteger _ self truncated.
		"See Integer>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
		"Very big integers will answer true when asked #= with their own conversion to Float,
		But that Float will #asInteger to a different integer. Use Float hash in those cases, to ensure equal hash value.
		In addition, there is a performance improvement: the hash in LargeIntegers could
		get very slow for very big numbers"
		(asInteger = self and: [ asInteger abs < Float maxExactInteger ]) ifTrue: [
			^ asInteger hash ]].
	"Both words of the float are used. (The bitShift:'s ensure that the intermediate results do not become a large integer.)
	Care is taken to answer same hash as an equal Integer."
	^ ((self basicAt: 1) bitShift: -4) +
	   ((self basicAt: 2) bitShift: -4)! !
!LargePositiveInteger methodsFor: 'comparing' stamp: 'jmv 11/21/2018 17:32:14' prior: 50418152!
 hash

	self < `(2 raisedToInteger: Float emax+1)` ifFalse: [
		^ `Float infinity hash` ].

	self < Float maxExactInteger ifFalse: [
		"Will always enter here for 64 bits images.
		See Float>>#hash, Integer>>#hash and LargeNegativeInteger>>#hash"
		^ self asFloat hash ].

	"May normally only reach here in 32 bit images"

	"If could be a SmallInteger (regardless of the current word size, we want consistency between 32/64 bit systems)"
	self digitLength <= 8 ifTrue: [
		^ self hashMultiply ].

	^ByteArray
		hashBytes: self
		startingWith: self species hash! !
!LargeNegativeInteger methodsFor: 'comparing' stamp: 'jmv 11/21/2018 17:32:25' prior: 50418167!
             hash

	self > `(2 raisedToInteger: Float emax+1) negated` ifFalse: [
		^ `Float negativeInfinity hash` ].

	self > Float maxExactInteger negated ifFalse: [
		"Will always enter here for 64 bits images.
		See Float>>#hash, Integer>>#hash and LargePositiveInteger>>#hash"
		^ self asFloat hash ].

	"May normally only reach here in 32 bit images"

	"If could be a SmallInteger (regardless of the current word size, we want consistency between 32/64 bit systems)"
	self digitLength <= 8 ifTrue: [
		^ self hashMultiply ].

	^ByteArray
		hashBytes: self
		startingWith: self species hash! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3495-SmallInteger-LargeInteger-hash-consistency-JuanVuletich-2018Nov21-16h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3495] on 27 November 2018 at 9:04:27 am'!

"Change Set:		3497-CuisCore-AuthorName-2018Nov27-09h04m
Date:			27 November 2018
Author:			Juan Vuletich
"
(FeatureRequirement name: 'Statistics') isAlreadySatisfied ifTrue: [ self inform: 'You have the Statistics package already loaded in this image. Please reinstall it after loading this change set (#3496).' ]!

SortedCollection removeSelector: #median!

SortedCollection removeSelector: #median!

Collection removeSelector: #median!

Collection removeSelector: #median!

Collection removeSelector: #sampleStandardDeviation!

Collection removeSelector: #sampleStandardDeviation!

Collection removeSelector: #sampleVariance!

Collection removeSelector: #sampleVariance!

Collection removeSelector: #standardDeviation!

Collection removeSelector: #standardDeviation!

Collection removeSelector: #variance!

Collection removeSelector: #variance!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3496-CleanBaseImageOfPackageStuff-JuanVuletich-2018Nov27-08h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3496] on 27 November 2018 at 9:20:13 am'!
!Color class methodsFor: 'instance creation' stamp: 'jmv 11/26/2018 17:17:17' prior: 50354347!
                      colorFrom: parm
	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"

	| aColor firstParm |
	(parm is: #Color) ifTrue: [ ^ parm ].
	parm isSymbol ifTrue: [ ^ self perform: parm ].
	parm isString ifTrue: [ ^ self fromHexString: parm ].
	(parm isSequenceableCollection and: [ parm size > 0 ])
		ifTrue: [
			firstParm _ parm first.
			firstParm isNumber ifTrue: [
				^ self fromRgbTriplet: parm].
			aColor _ self colorFrom: firstParm.
			parm withIndexDo: [ :sym :ind |
				ind > 1 ifTrue: [
					aColor _ aColor perform: sym ]].
			^ aColor].
	^ parm

"
Color colorFrom: #(blue darker)
Color colorFrom: Color blue darker
Color colorFrom: #blue
Color colorFrom: #(0.0 0.0 1.0)
Color colorFrom: '#D7B360'
"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3497-Color-fromFrom-hexString-JuanVuletich-2018Nov27-09h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3496] on 27 November 2018 at 9:21:11 am'!
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/26/2018 18:20:34' prior: 50381273!
          selectionChanged

	self textComposition selectionRects do: [ :r | self invalidateLocalRect: r ].
	editor hasSelection
		ifTrue: [ self stopBlinking ]
		ifFalse: [ self hasKeyboardFocus ifTrue: [self startBlinking ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3498-FixTextCursorBlinking-JuanVuletich-2018Nov27-09h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3496] on 27 November 2018 at 9:28:07 am'!
!CodeWindow methodsFor: 'updating' stamp: 'jmv 11/26/2018 18:36:46' prior: 50387981!
      decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		`Color tan`.							"no sends to super. there is an override in some subclass"
		`Color red`.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		`Color red`.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		`Color red muchLighter`.			"doesn't have sub; has super but doesn't call it"
		`Color r: 0.94 g: 0.823 b: 0.673`.		"has sub; has super but doesn't call it"
		`Color green muchLighter`.			"doesn't have sub; has super and callsl it"
		`Color blue muchLighter`.			"has sub; has super and callsl it"

	} at: flags + 1.
	Theme current useUniformColors
		ifTrue: [
			aButton color: (self buttonColor mixed: 0.8 with: aColor) ]
		ifFalse: [
			aButton color: aColor ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3499-softInheritanceButtonColoring-JuanVuletich-2018Nov27-09h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3485] on 27 November 2018 at 9:33:43 am'!
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 3/19/2012 08:41' prior: 16909395!
                         initialize
	"
	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...
	[ SmalltalkCompleter initialize ]timeToRun
	Selectors inspect
	"
	| maxSortValue allImplemented |
	SystemChangeNotifier uniqueInstance
		removeActionsWithReceiver: self.	 "avoid double registration"

	SystemChangeNotifier uniqueInstance
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #methodAdded send: #methodAdded:selector:inClass:requestor: to: self;
		when: #methodAddedInProtocol send: #methodAdded:selector:inProtocol:class:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self.
	
	self protected: [
		allImplemented _ Smalltalk allImplementedMessages.
		Selectors _ Trie new.
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				Selectors at: sel ifAbsentPut: [ 0 ].
				method messages do: [ :sentMsg |
					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				self addSelector: sel method: method allImplemented: allImplemented]].
		""
	
		"The following might not be found in #messages. Give them maximum priority."
		maxSortValue _ SmallInteger maxVal.
		"From MessageNode>>#initialize"
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |
				Selectors at: sel put: maxSortValue ].
	
		maxSortValue _ SmallInteger maxVal-1.
		"From SystemDictionary >>#recreateSpecialObjectsArray"
		(1 to: Smalltalk specialSelectorSize) do:  [ :i |
				Selectors at: (Smalltalk specialSelectorAt: i) put: maxSortValue ]]! !

SmalltalkCompleter initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmalltalkCompleter initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3500-Initialize-Smalltalk-Completer-JuanVuletich-2018Nov27-09h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3500] on 27 November 2018 at 10:16:21 am'!

Theme subclass: #BrightTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Core'!

!classDefinition: #BrightTheme category: #'Theme-Core'!
Theme subclass: #BrightTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Core'!
!BrightTheme commentStamp: '<historical>' prior: 0!
                       Default bright colored theme for Cuis.!
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 11/26/2018 18:00:55' prior: 50401908!
                        generateShoutConfig

	| styles colors |
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self literals . colors at: #literals}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelZero . colors at: #blockLevelZero}.
		{self blockLevelOne . colors at: #blockLevelOne}.
		{self blockLevelTwo . colors at: #blockLevelTwo}.
		{self blockLevelThree . colors at: #blockLevelThree}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . self italic}.
		{self symbols . colors at: #messages . #bold}.
		{self pattern . colors at: #selector . #bold}.
		{self ansiAssignment . nil . #bold}.
		{self assignment . nil . #(#bold #withST80Glyphs)}.
		{self return . nil . #(#bold #withST80Glyphs)}.
		{self tempVars . colors at: #tempVars . self italic}.
		{self blockTemps . colors at: #tempBar . self italic}
	} do: [ :style |
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined .#bold}.
		{#unfinishedComment . colors at: #pseudoVariables . self italic}.
		{#comment . colors at: #comment . self italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . self italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'shout' stamp: 'jmv 11/27/2018 09:59:21' prior: 50418566!
                  shout
	"Color symbols as an association list.
	SHTextStylerST80 initialize
	"
	^ {
		#selector  					-> nil.
		#arguments 					-> #(cyan muchDarker).
		#comment 					-> #(green muchDarker).
		#tempBar 					-> #gray.
		#tempVars 					-> #(gray muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#pseudoVariables 			-> #(red muchDarker).
		#literals 					-> #(green muchDarker).
		#messages 					-> #(blue darker).
		#incompleteMessages 		-> #(gray veryMuchDarker).
		#blockLevelZero 			-> #black.
		#blockLevelOne 			-> #brown.
		#blockLevelTwo 			-> #magenta.
		#blockLevelThree 			-> #red.
		#blockLevelFour 			-> #(orange darker).
		#blockLevelFive 			-> #(orange muchDarker).
		#blockLevelSix 			-> #(green muchDarker).
		#blockLevelSeven 			-> #blue.
		#defaults 					-> #black.
		#undefined 					-> #red.
		#methodTags 				-> #(green muchDarker).
	}! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 11/27/2018 10:14:54' prior: 50397980!
    changeTheme

	| menu |
	menu _ MenuMorph new.
	menu
		addTitle: 'Choose a theme';
		addStayUpIcons.
	(Theme allSubclasses sorted: [ :a :b | a name < b name ]) do: [ :themeClass |
		menu add: themeClass name target: themeClass action: #beCurrent ].
	menu popUpInWorld: self runningWorld! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
BrightTheme beCurrent.!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3501-BrightTheme-JuanVuletich-2018Nov27-09h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3501] on 27 November 2018 at 10:20:03 am'!
!Workspace methodsFor: 'accessing' stamp: 'jmv 11/27/2018 10:19:24' prior: 50419461!
                          methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ UndefinedObject methodNodeFor: aSourceCode noPattern: true ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
! !
!CodeProvider methodsFor: 'contents' stamp: 'jmv 11/27/2018 10:19:13' prior: 50419469!
       methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ self selectedClassOrMetaClass methodNodeFor: aSourceCode ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
	! !
!Inspector methodsFor: 'contents' stamp: 'jmv 11/27/2018 10:19:17' prior: 50419477!
           methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ self selectedClassOrMetaClass methodNodeFor: aSourceCode noPattern: true ] on: Error, UndeclaredVariableReference do:  aParsingErrorBlock ! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3502-FixSendersImplementorsEnhancements-JuanVuletich-2018Nov27-10h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3501] on 27 November 2018 at 10:24:18 am'!

CodePackage subclass: #ColorExtrasPackage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Color-Extras'!

!classDefinition: #ColorExtrasPackage category: #'Color-Extras'!
CodePackage subclass: #ColorExtrasPackage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Color-Extras'!
!SmallInteger methodsFor: 'bit manipulation' stamp: 'SqR 8/3/2000 13:29' prior: 16908824!
                              hashMultiply
	"Multiply by 1664525, take lower 28 bits, do not use LargeIntegers (not even in 32 bit images)"
	| low |

	low _ self bitAnd: 16383.
	^(16r260D * low + ((16r260D * (self bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384))
			bitAnd: 16r0FFFFFFF! !

Smalltalk removeClassNamedIfInBaseSystem: #ColorExtrasPackage!

Smalltalk removeClassNamed: #ColorExtrasPackage!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3503-hashMultiplyComment-JuanVuletich-2018Nov27-10h22m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3501] on 27 November 2018 at 1:42:06 pm'!

Number subclass: #Float
	instanceVariableNames: ''
	classVariableNames: 'E Epsilon Halfpi Infinity Ln10 Ln2 MaxVal MaxValLn MinValLogBase2 NaN NegativeInfinity NegativeZero Pi RadiansPerDegree Sqrt2 Twopi '
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!classDefinition: #Float category: #'Kernel-Numbers'!
Number subclass: #Float
	instanceVariableNames: ''
	classVariableNames: 'E Epsilon Halfpi Infinity Ln10 Ln2 MaxVal MaxValLn MinValLogBase2 NaN NegativeInfinity NegativeZero Pi RadiansPerDegree Sqrt2 Twopi'
	poolDictionaries: ''
	category: 'Kernel-Numbers'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 13:10:52'!
                 arcTanNonPrimitive
	"Answer the angle in radians."

	| theta delta sinTheta cosTheta |

	"Newton-Raphson"
	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].

	"first guess"
	theta _ (self * Halfpi) / (self + 1.0).

	"iterate"
	[
		sinTheta _ theta sin.
		cosTheta _ theta cos.
		delta _ (sinTheta * cosTheta) - (self * cosTheta * cosTheta).
		delta abs >= theta ulp ]
		whileTrue: [
			theta _ theta - delta ].
	^ theta! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 13:24:16'!
         expNonPrimitive
	"Answer E raised to the receiver power."

	| base fract correction delta div |

	"Taylor series"
	"check the special cases"
	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].
	self = 0.0 ifTrue: [^ 1].
	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].

	"get first approximation by raising e to integer power"
	base _ E raisedToInteger: (self truncated).

	"now compute the correction with a short Taylor series"
	"fract will be 0..1, so correction will be 1..E"
	"in the worst case, convergance time is logarithmic with 1/Epsilon"
	fract _ self fractionPart.
	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"

	correction _ 1.0 + fract.
	delta _ fract * fract / 2.0.
	div _ 2.0.
	[delta >= base ulp] whileTrue: [
		correction _ correction + delta.
		div _ div + 1.0.
		delta _ delta * fract / div].
	correction _ correction + delta.
	^ base * correction! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 13:32:39'!
                 lnNonPrimitive
	"Answer the natural logarithm of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	| expt n mant x div pow delta sum |

	"Taylor series"
	self <= 0.0 ifTrue: [DomainError signal: 'ln is only defined for x > 0.0'].

	"get a rough estimate from binary exponent"
	expt := self exponent.
	n := Ln2 * expt.
	mant := self timesTwoPower: 0 - expt.

	"compute fine correction from mantinssa in Taylor series"
	"mant is in the range [0..2]"
	"we unroll the loop to avoid use of abs"
	x := mant - 1.0.
	div := 1.0.
	pow := delta := sum := x.
	x := x negated.  "x <= 0"
	[delta > (n + sum) ulp] whileTrue: [
		"pass one: delta is positive"
		div := div + 1.0.
		pow := pow * x.
		delta := pow / div.
		sum := sum + delta.
		"pass two: delta is negative"
		div := div + 1.0.
		pow := pow * x.
		delta := pow / div.
		sum := sum + delta].

	^ n + sum

	"Float e ln 1.0"! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 13:40:01'!
                sinNonPrimitive
	"Answer the sine of the receiver taken as an angle in radians."

	| sum delta self2 i |

	"Taylor series"
	"normalize to the range [0..Pi/2]"
	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].
	self > Twopi ifTrue: [^ (self \\ Twopi) sin].
	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].
	self > Halfpi ifTrue: [^ (Pi - self) sin].

	"unroll loop to avoid use of abs"
	sum _ delta _ self.
	self2 _ 0.0 - (self * self).
	i _ 2.0.
	[delta >= sum ulp] whileTrue: [
		"once"
		delta _ (delta * self2) / (i * (i + 1.0)).
		i _ i + 2.0.
		sum _ sum + delta.
		"twice"
		delta _ (delta * self2) / (i * (i + 1.0)).
		i _ i + 2.0.
		sum _ sum + delta].
	^ sum! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 13:10:59'!
                  sqrtNonPrimitive
	"Answer the square root of the receiver. "
	| exp guess delta |

	"Complex answer"
	self <= 0.0
		ifTrue: [
			^ self = 0.0
				ifFalse: [ (0.0 - self) sqrt i ]
				ifTrue: [ self ]	"Answer 0.0 for 0.0, but -0.0 for -0.0. See IEEE 754 standard"
				].

	"NaN and Infinity"
	self isFinite ifFalse: [
		^ self ].

	"Newton-Raphson"
	"first guess is half the exponent"
	exp _ self exponent // 2.
	guess _ self timesTwoPower: 0 - exp.
	[
		delta _ self - (guess * guess) / (guess * 2.0).
		delta abs >= guess ulp ]
	whileTrue: [
		guess _ guess + delta ].
	^ guess! !
!Number methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:09:00' prior: 16880047!
                           arcTan
	"The receiver is the tangent of an angle. Answer the angle measured in  radians.
	Note: If the purpose is to recover the angle of some vector, prefer #arcTan:
		See, for example, Complex>>#argument"

	^self asFloat arcTan! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 10:57:09' prior: 50400367!
                         sqrt
	"Answer the square root of the receiver. 
	 Use primitive if available, or Smalltalk code if primitive is unavailable or fails."

	| prim |
	prim _ self primSqrt.
	prim isNaN ifFalse: [ ^prim ].

	^ self sqrtNonPrimitive! !
!Float class methodsFor: 'class initialization' stamp: 'jmv 11/27/2018 13:40:39' prior: 16845982!
                        initClassCachedState
	"Float initialize"
	"Constants from Computer Approximations, pp. 182-183:
		Pi = 3.14159265358979323846264338327950288
		Pi/2 = 1.57079632679489661923132169163975144
		Pi*2 = 6.28318530717958647692528676655900576
		Pi/180 = 0.01745329251994329576923690768488612
		2.0 ln = 0.69314718055994530941723212145817657
		2.0 sqrt = 1.41421356237309504880168872420969808"

	Pi _ 3.14159265358979323846264338327950288.
	Halfpi _ Pi / 2.0.
	Twopi _ Pi * 2.0.
	RadiansPerDegree _ Pi / 180.0.

	Ln2 _ 0.69314718055994530941723212145817657.
	Ln10 _ 10.0 ln.
	Sqrt2 _ 1.41421356237309504880168872420969808.
	E _ 2.718281828459045235360287471353.

	MaxVal _ 1.7976931348623157e308.
	MaxValLn _ 709.782712893384.
	MinValLogBase2 _ -1074.

	Infinity _ MaxVal * MaxVal.
	NegativeInfinity _ 0.0 - Infinity.
	NaN _ Infinity - Infinity.
	NegativeZero _ 1.0 / Infinity negated.
! !
!Float class methodsFor: 'class initialization' stamp: 'jmv 11/27/2018 13:40:43' prior: 16846031!
             releaseClassCachedState

	Pi _ nil.
	Halfpi _ nil.
	Twopi _ nil.
	RadiansPerDegree _ nil.

	Ln2 _ nil.
	Ln10 _ nil.
	Sqrt2 _ nil.
	E _ nil.

	MaxVal _ nil.
	MaxValLn _ nil.
	MinValLogBase2 _ nil.

	Infinity _ nil.
	NegativeInfinity _ nil.
	NaN _ nil.
	NegativeZero _ nil! !
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:12:00' prior: 16790579!
         arcTan
	"Answer the angle in radians.
	 Optional. See Object documentation whatIsAPrimitive.
	Note: If the purpose is to recover the angle of some vector, prefer #arcTan:
		See, for example, Complex>>#argument"

	<primitive: 57>
	^ self arcTanNonPrimitive! !
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:14:01' prior: 16790598!
                        exp
	"Answer E raised to the receiver power.
	 Optional. See Object documentation whatIsAPrimitive." 

	<primitive: 59>
	^ self expNonPrimitive! !
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:14:45' prior: 16790631!
        ln
	"Answer the natural logarithm of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 58>
	^ self lnNonPrimitive! !
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:15:17' prior: 16790733!
    sin
	"Answer the sine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 56>
	^ self sinNonPrimitive! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:11:58' prior: 16908312!
                  arcTan
	"Answer the angle in radians.
	 Optional. See Object documentation whatIsAPrimitive.
	Note: If the purpose is to recover the angle of some vector, prefer #arcTan:
		See, for example, Complex>>#argument"

	<primitive: 557>
	^self arcTanNonPrimitive! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:13:51' prior: 16908332!
                        exp
	"Answer E raised to the receiver power.
	 Optional. See Object documentation whatIsAPrimitive." 

	<primitive: 559>
	^ self expNonPrimitive! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:14:36' prior: 16908365!
       ln
	"Answer the natural logarithm of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 558>
	^ self lnNonPrimitive! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 11:15:23' prior: 16908397!
   sin
	"Answer the sine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 556>
	^ self sinNonPrimitive! !
!Integer methodsFor: 'mathematical functions' stamp: 'jmv 11/27/2018 10:30:26' prior: 16859841!
                      sqrt
	"Answer the square root of the receiver."

	| selfAsFloat floatResult guess |
	selfAsFloat _ self asFloat.
	floatResult _ selfAsFloat sqrt.

	floatResult isInfinite ifFalse: [
		guess _ floatResult truncated.

		"If got an exact answer, answer it. Otherwise answer float approximate answer."
		guess squared = self
			ifTrue: [ ^ guess ]].

	"In this case, maybe it failed because we are such a big integer that the Float method becomes
	inexact, even if we are a whole square number. So, try the slower but more general method."
	selfAsFloat >= Float maxExactInteger asFloat squared
		ifTrue: [
			guess _ self sqrtFloor.
			guess squared = self
				ifTrue: [ ^guess ].
			
			"Nothing else can be done. No exact answer means answer must be a Float.
			Answer the best we can which is the rounded sqrt."
			^ self sqrtRounded asFloat ].

	"We need an approximate result"
	^floatResult! !

Number subclass: #Float
	instanceVariableNames: ''
	classVariableNames: 'E Halfpi Infinity Ln10 Ln2 MaxVal MaxValLn MinValLogBase2 NaN NegativeInfinity NegativeZero Pi RadiansPerDegree Sqrt2 Twopi'
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!classDefinition: #Float category: #'Kernel-Numbers'!
Number subclass: #Float
	instanceVariableNames: ''
	classVariableNames: 'E Halfpi Infinity Ln10 Ln2 MaxVal MaxValLn MinValLogBase2 NaN NegativeInfinity NegativeZero Pi RadiansPerDegree Sqrt2 Twopi'
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3504-Float-Refactor-RemoveEpsilonClassVar-JuanVuletich-2018Nov27-10h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3504] on 27 November 2018 at 2:34:48 pm'!
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/27/2018 14:28:37'!
               withSelectorUnderCursorDo: aBlock otherwise: failBlock

	self withSelectorUnderCursorDo: aBlock ifErrorsParsing: failBlock ifNoSelector: failBlock! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/27/2018 14:29:28' prior: 50419613!
           implementorsOfIt

	"Open an implementors browser on the  selector under cursor. If it can not parse the source code it uses
	old implementation that looks for the selected selector if any - Hernan"

	self
		withSelectorUnderCursorDo: [ :aSelector | Smalltalk browseAllImplementorsOf: aSelector ]
		otherwise: [ self implementorsOfItWhenErrorsParsing ]! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/27/2018 14:29:23' prior: 50419628!
                              sendersOfIt

	"Open a senders browser on the  selector under cursor. If it can not parse the source code it uses
	old implementation that looks for the selected selector if any - Hernan"

	self
		withSelectorUnderCursorDo: [ :aSelector | Smalltalk browseAllCallsOn: aSelector ]
		otherwise: [ self sendersOfItWhenErrorsParsing ]! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 11/27/2018 14:33:01' prior: 50419570!
                     withSelectorUnderCursorDo: aBlock ifErrorsParsing: aParsingErrorBlock ifNoSelector: aNoSelectorBlock

	| methodNode nodeAtRange nodeUnderCursor |

	methodNode := self codeProvider methodNodeOf: model actualContents ifErrorsParsing: [ :anError | ^ aParsingErrorBlock valueWithPossibleArgument: anError ].

	self startIndex < methodNode selectorLastPosition ifTrue: [ ^aBlock value: methodNode selector ].
	nodeAtRange := methodNode parseNodeIncluding: self startIndex ifAbsent: [ ^ aNoSelectorBlock value ].
	nodeUnderCursor := nodeAtRange key.
	nodeUnderCursor isMessageNode ifTrue: [ ^aBlock value: nodeAtRange key selector key ].
	(nodeUnderCursor isLiteralNode and: [ nodeUnderCursor literalValue isSymbol ]) ifTrue: [ ^aBlock value: nodeUnderCursor literalValue ].

	^ aNoSelectorBlock value ! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3505-FixSendersImplementorsEnhancements-JuanVuletich-2018Nov27-14h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3505] on 27 November 2018 at 2:46:58 pm'!
!Theme class methodsFor: 'instance creation' stamp: 'jmv 11/27/2018 14:45:06' prior: 50400278!
          beCurrent
	self currentTheme: self.
	self inform: 'Please close and reopen all windows'! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 11/27/2018 14:42:55' prior: 50420321!
         changeTheme

	| menu |
	"In Theme-Themes.pck.st"
	(FeatureRequirement name: 'Theme-Themes') isAlreadySatisfied ifFalse: [
		(PopUpMenu 
			confirm: 'The Additional Themes package is not loaded', String newLineString, 'Would you like me to load it for you now?')
				ifTrue: [Feature require: #'Theme-Themes'] 
	].
	menu _ MenuMorph new.
	menu
		addTitle: 'Choose a theme';
		addStayUpIcons.
	(Theme allSubclasses sorted: [ :a :b | a name < b name ]) do: [ :themeClass |
		menu add: themeClass name target: themeClass action: #beCurrent ].
	menu popUpInWorld: self runningWorld! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3506-Themes-enh-JuanVuletich-2018Nov27-14h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3505] on 27 November 2018 at 4:39:19 pm'!
!PluggableTextModel commentStamp: '<historical>' prior: 16890049!
                           A TextModel whose contents are stored elsewhere (ivar textProvider)!
!TextProvider methodsFor: 'accessing' stamp: 'jmv 11/27/2018 16:38:04'!
                   methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^[ UndefinedObject methodNodeFor: aSourceCode noPattern: true ] on: Error, UndeclaredVariableReference do: aParsingErrorBlock
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3507-yetAnother-JuanVuletich-2018Nov27-16h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3507] on 28 November 2018 at 6:06:10 pm'!
!Theme class methodsFor: 'instance creation' stamp: 'cbr 12/14/2010 01:55' prior: 50420829!
   beCurrent
	^ self currentTheme: self! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3508-AvoidHangOnImageSave-JuanVuletich-2018Nov28-18h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3508] on 29 November 2018 at 1:05:06 pm'!

Theme subclass: #BrightColorTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Core'!

!classDefinition: #BrightColorTheme category: #'Theme-Core'!
Theme subclass: #BrightColorTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Core'!
!BrightColorTheme commentStamp: '<historical>' prior: 0!
               Default bright colored theme for Cuis.!

Theme subclass: #DarkTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Core'!

!classDefinition: #DarkTheme category: #'Theme-Core'!
Theme subclass: #DarkTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Theme-Core'!
!DarkTheme commentStamp: '<historical>' prior: 0!
                    A low contrast, darker gray theme.!
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/27/2018 10:07:19'!
                          background
	^ `Color black`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/26/2018 18:24:15'!
                               buttonLabel
	^ `Color gray: 0.48`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/27/2018 10:07:25'!
                         defaultWindowColor
	^ `Color hue: 212 chroma: 0.015 luminance: 0.25`! !
!DarkTheme methodsFor: 'colors' stamp: 'cbr 10/10/2012 20:18'!
                         missingCommentTextColor

	^ TextColor cyan! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/26/2018 16:59:09'!
                paneBackgroundFrom: aColor
	^ aColor alphaMixed: 0.7 with: Color black! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/27/2018 09:59:07'!
                    shout
	"Color symbols as an association list."

	^ {
		#selector  					-> '#B59F60'.
		#arguments 					-> '#289078'.
		#comment 					-> #(green duller).
		#tempBar 					-> #gray.
		#tempVars 					-> '#767836'.
		#instVar 					-> '#B3695A'.
		#pseudoVariables 			-> '#2070E0'.
		#literals 					-> #green.
		#messages 					-> '#6FB3BD'.
		#incompleteMessages  	-> '#F08060'.
		#blockLevelZero 			-> '#6FB3BD'.
		#blockLevelOne 			-> '#FFB0B0'.
		#blockLevelTwo 			-> '#B0FFB0'.
		#blockLevelThree 			-> '#B0B0FF'.
		#blockLevelFour 			-> '#00B0B0'.
		#blockLevelFive 			-> '#E03030'.
		#blockLevelSix 			-> '#30E030'.
		#blockLevelSeven 			-> '#3030E0'.
		#defaults 					-> '#A1AFBF'.
		#undefined 					-> '#E04020'.
		#methodTags 				-> #green.
	}! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/27/2018 10:07:33'!
                text
	^ `Color veryLightGray`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/26/2018 18:08:53'!
                             textHighlight
	"A nice light blue."
	"
	^ Color r: 0.71 g: 0.835 b: 1.0
	^ Color hue: 214 chroma: 0.29 luminance: 0.816
	"
	^ `Color hue: 204 chroma: 0.29 luminance: 0.22`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/27/2018 10:07:40'!
               textPane
	^ `Color gray`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 11/27/2018 10:07:46'!
  unfocusedTextHighlightFrom: aColor
	^ aColor adjustSaturation: -0.15 brightness: -0.07! !
!DarkTheme methodsFor: 'colors' stamp: 'cbr 10/10/2012 18:32'!
       useUniformColors
	^ true! !
!DarkTheme methodsFor: 'other options' stamp: 'jmv 11/27/2018 10:07:56'!
                           windowLabel
	^ `Color gray: 0.55`! !
!DarkTheme methodsFor: 'menu colors' stamp: 'jmv 11/26/2018 18:29:15'!
                    menu
	^ `Color darkGray`! !
!DarkTheme methodsFor: 'menu colors' stamp: 'jmv 11/26/2018 18:31:04'!
                             menuText
	^ self text! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
BrightColorTheme beCurrent!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3509-AddDarkTheme-JuanVuletich-2018Nov29-13h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3508] on 29 November 2018 at 1:05:30 pm'!

Smalltalk removeClassNamed: #BrightTheme!

Smalltalk removeClassNamed: #BrightTheme!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3510-cleanup-JuanVuletich-2018Nov29-13h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3510] on 30 November 2018 at 9:29:13 am'!
!Editor methodsFor: 'new selection' stamp: 'jmv 11/30/2018 09:26:44' prior: 16836464!
           selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter finalDelimiter direction match level string here hereChar start stop |
	string _ self privateCurrentString.
	string size < 2 ifTrue: [^self selectFrom: 1 to: 1].
	here _ self pointIndex min: string size max: 2.
	initialDelimiter _ string at: here - 1.
	match _ leftDelimiters indexOf: initialDelimiter.
	match > 0
		ifTrue: [
			"delimiter is on left -- match to the right"
			start _ here.
			direction _ 1.
			here _ here - 1.
			finalDelimiter _ rightDelimiters at: match]
		ifFalse: [
			initialDelimiter _ string at: here.
			match _ rightDelimiters indexOf: initialDelimiter.
			match > 0
				ifTrue: [
					"delimiter is on right -- match to the left"
					stop _ here - 1.
					direction _ -1.
					finalDelimiter _ leftDelimiters at: match]
				ifFalse: [
					"no delimiters -- select a token"
					direction _ -1]].
	level _ 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < string size]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar _ string at: (here _ here + direction).
			match = 0
				ifTrue: [
					"token scan goes left, then right"
					hereChar isValidInIdentifiers 	"Consider $: as a word separator"
						ifTrue: [
							here = 1
								ifTrue: [
									start _ 1.
									"go right if hit string start"
									direction _ 1]]
						ifFalse: [
							direction < 0
								ifTrue: [
									start _ here + 1.
									"go right if hit non-token"
									direction _ 1]
								ifFalse: [level _ 0]]]
				ifFalse: [
					"delimiter match just counts nesting level"
					hereChar = finalDelimiter
						ifTrue: [level _ level - 1"leaving nest"]
						ifFalse: [
							hereChar = initialDelimiter 
								ifTrue: [level _ level + 1"entering deeper nest"]]]].
	level > 0 ifTrue: [
		"If we failed to find final delimiter, then just select word."
		^self selectWordLeftDelimiters: '' rightDelimiters: '' ].
	direction > 0
		ifTrue: [
			"If a word ends with $: (a keyword), consider it part of the word"
			hereChar = $: ifTrue: [here _ here + 1].
			self selectFrom: start to: here - 1]
		ifFalse: [
			"But if a word starts with $: (this is the argument to a keyword), then it is not part of the word."
			self selectFrom: here + 1 to: stop]! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'HAW 11/29/2018 19:11:47' prior: 50404871!
                       browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry browser |
	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol _ self selectedSymbol ifNil: [
		self
			evaluateSelectionAndDo: [ :result | result class name ]
			ifFail: [ ^morph flash ]
			profiled: false].

	aSymbol first isUppercase
		ifTrue: [
			anEntry _ (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry _ anEntry class].
			browser _ Browser new.
			browser setClass: anEntry selector: nil.
			BrowserWindow open: browser label:'System Browser: ',  aSymbol]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3511-AutoSelectToBrowse-fix-HernanWilkinson-2018Nov30-09h28m-HAW.1.cs.st----!

----SNAPSHOT----#(30 November 2018 9:34:32.067126 am) Cuis5.0-3511-v3.image priorSource: 2797624!

----QUIT----#(30 November 2018 9:34:55.232912 am) Cuis5.0-3511-v3.image priorSource: 2863724!

----STARTUP----#(21 December 2018 5:45:57.13997 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3511-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3511] on 1 December 2018 at 11:24:55 am'!
!Editor methodsFor: 'new selection' stamp: 'jmv 12/1/2018 11:23:07' prior: 50421032!
           selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter finalDelimiter direction match level string here hereChar start stop |
	string _ self privateCurrentString.
	string size < 2 ifTrue: [^self selectFrom: 1 to: 1].
	here _ self pointIndex min: string size max: 2.
	initialDelimiter _ string at: here - 1.
	match _ leftDelimiters indexOf: initialDelimiter.
	match > 0
		ifTrue: [
			"delimiter is on left -- match to the right"
			start _ here.
			direction _ 1.
			here _ here - 1.
			finalDelimiter _ rightDelimiters at: match]
		ifFalse: [
			initialDelimiter _ string at: here.
			match _ rightDelimiters indexOf: initialDelimiter.
			match > 0
				ifTrue: [
					"delimiter is on right -- match to the left"
					stop _ here - 1.
					direction _ -1.
					finalDelimiter _ leftDelimiters at: match]
				ifFalse: [
					"no delimiters -- select a token"
					direction _ -1]].
	level _ 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < string size]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar _ string at: (here _ here + direction).
			match = 0
				ifTrue: [
					"token scan goes left, then right"
					hereChar isValidInIdentifiers 	"Consider $: as a word separator"
						ifTrue: [
							here = 1
								ifTrue: [
									start _ 1.
									"go right if hit string start"
									direction _ 1]]
						ifFalse: [
							direction < 0
								ifTrue: [
									start _ here + 1.
									"go right if hit non-token"
									direction _ 1]
								ifFalse: [level _ 0]]]
				ifFalse: [
					"delimiter match just counts nesting level"
					hereChar = finalDelimiter
						ifTrue: [level _ level - 1"leaving nest"]
						ifFalse: [
							hereChar = initialDelimiter 
								ifTrue: [level _ level + 1"entering deeper nest"]]]].
	level > 0 ifTrue: [
		leftDelimiters size + rightDelimiters size = 0 ifFalse: [
			"If we failed to find final delimiter, then just select word."
			^self selectWordLeftDelimiters: '' rightDelimiters: '' ].
		here _ here + direction ].
	direction > 0
		ifTrue: [
			"If a word ends with $: (a keyword), consider it part of the word"
			hereChar = $: ifTrue: [here _ here + 1].
			self selectFrom: start to: here - 1]
		ifFalse: [
			"But if a word starts with $: (this is the argument to a keyword), then it is not part of the word."
			self selectFrom: here + 1 to: stop]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3512-TripleClickOnTextEditorFix-JuanVuletich-2018Dec01-11h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3512] on 4 December 2018 at 12:19:11 pm'!
!Float methodsFor: 'converting' stamp: 'jmv 12/4/2018 12:11:37' prior: 50417747!
                           partBits: aThreeArgumentBlock
	"
	Extract the bits for Sign, Mantissa and Exponent parts of the Floating Point representation.
	Just extract the bits. Do not add implicit bit. Do not correct denormals. Do not substract exponent bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	| allBits signBit exponentBits mantissaBits |

	"Extract the bits of an IEEE double float "
	allBits _ ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).

	"Extract the sign and the biased exponent "
	signBit _ allBits bitShift: -63.
	exponentBits _ (allBits bitShift: -52) bitAnd: 16r7FF.

	"Extract fractional part "
	mantissaBits _ allBits bitAnd: 16r000FFFFFFFFFFFFF.

	"Evaluate the block"
	^aThreeArgumentBlock value: signBit value: exponentBits value: mantissaBits! !
!Float methodsFor: 'converting' stamp: 'jmv 12/4/2018 12:12:49' prior: 50417828!
                              partValues: aThreeArgumentBlock ifInfinite: infiniryBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"
	| sign exponent mantissa |

	self partBits: [ :signBit :exponentBits :mantissaBits |

		"Extract the sign"
		sign _ signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infiniryBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent _ exponentBits - 16r3FF.

		"Add back implicit leading 1 in fraction if appropriate"
		"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa"	
		exponentBits = 0
			ifTrue: [
				mantissa _ mantissaBits.
				exponent _ exponent + 1 ]
			ifFalse: [
				mantissa _ 16r0010000000000000 bitOr: mantissaBits ].

		"Evaluate the block"
		^aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 12:13:25' prior: 50414496!
            mantissaPart
	"Equivalent to #significandAsInteger."
	"The actual bits in the mantissa of the receiver, as an integer, including the implicit leading 1 if appropriate.
	Does not include de sign.
	See #exponentPart and #signPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f mantissaPart * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | mantissa ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 12:15:28' prior: 50418693!
 predecessor
	"Answer the largest Float smaller than self"
	| ulp |
	self isFinite ifFalse: [
		(self isNaN or: [self negative]) ifTrue: [^self].
		^Float fmax].
	ulp := self ulp.
	^self - (0.5 * ulp) = self
		ifTrue: [self - ulp]
		ifFalse: [self - (0.5 * ulp)]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 12:13:37' prior: 50417871!
                        significandAsInteger
	"The actual bits in the mantissa of the receiver, as an integer number, including the implicit leading 1 if appropriate.
	See #mantissaPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self mantissaPart! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 12:15:19' prior: 50417397!
   successor
	"Answer the smallest Float greater than self"
	| ulp |
	self isFinite ifFalse: [
		(self isNaN or: [self positive]) ifTrue: [^self].
		^Float fmax negated].
	ulp := self ulp.
	^self + (0.5 * ulp) = self
		ifTrue: [self * -1.0 - ulp * -1.0 "This trick is for obtaining a negativeZero"]
		ifFalse: [self + (0.5 * ulp)]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 12:15:44' prior: 50418703!
                      ulp
	"Answer the unit of least precision of the receiver"
	
	| exponent |
	self isFinite ifFalse: [^self abs].
	self isZero ifTrue: [^Float fmin].
	exponent := self exponent.
	^exponent < self class emin
		ifTrue: [Float fminDenormalized]
 		ifFalse: [Float epsilon timesTwoPower: exponent]! !
!Float methodsFor: 'printing' stamp: 'jmv 12/4/2018 12:17:36' prior: 50418745!
           printOn: aStream base: base
	"Handle sign, zero, and NaNs; all other values passed to absPrintOn:base:" 

	self isNaN ifTrue: [aStream nextPutAll: 'NaN'. ^ self]. "check for NaN before sign"
	self > 0.0
		ifTrue: [self absPrintOn: aStream base: base]
		ifFalse:
			[self sign = -1
				ifTrue: [aStream nextPutAll: '-'].
			self isZero
				ifTrue: [aStream nextPutAll: '0.0']
				ifFalse: [self negated absPrintOn: aStream base: base]]! !
!Float class methodsFor: 'constants' stamp: 'jmv 12/4/2018 11:57:45' prior: 16845874!
                    emin
	"Answer the exponent of the non-denormal value with smallest magnitude"
	
	^-1022! !
!Float class methodsFor: 'constants' stamp: 'jmv 12/4/2018 11:58:23' prior: 16845952!
               precision
	"Answer the apparent precision of the floating point representation.
	That is the maximum number of radix-based digits (bits if radix=2) representable in floating point without rounding error.
	Technically, 52 bits are stored in the representation, and normalized numbers have an implied leading 1 that does not need to be stored.
	Note that denormalized floating point numbers don't have the implied leading 1, and thus gradually lose precision.
	This format implements the IEEE-754 binary64 format."
	
	^53! !
!Fraction methodsFor: 'converting' stamp: 'jmv 12/4/2018 11:57:12' prior: 16849556!
 asFloat
	"Answer a Float that closely approximates the value of the receiver.
	This implementation will answer the closest floating point number to the receiver.
	In case of a tie, it will use the IEEE 754 round to nearest even mode.
	In case of overflow, it will answer +/- Float infinity."

	| a b mantissa exponent floatMantissa hasTruncatedBits lostBit n ha hb hm |
	a := numerator abs.
	b := denominator.	"denominator is always positive"
	ha := a highBit.
	hb := b highBit.
	
	"Number of bits to keep in mantissa plus one to handle rounding."
	n := 1 + Float precision.

	"If both numerator and denominator are represented exactly as floating point number,
	float division is fastest."
	(ha < n and: [hb < n]) ifTrue: [^numerator asFloat / denominator asFloat].

	"Shift the fraction by a power of two exponent so as to obtain a mantissa with n bits.
	The first guess is approximate, the mantissa might have n+1 bits."
	exponent := ha - hb - n.
	exponent >= 0
		ifTrue: [b := b bitShift: exponent]
		ifFalse: [a := a bitShift: exponent negated].
	mantissa := a quo: b.
	hasTruncatedBits := a > (mantissa * b).
	hm := mantissa highBit.
	
	"Check for gradual underflow, in which case the mantissa will lose bits.
	Keep at least one bit to let underflow preserve the sign of zero."
	lostBit := Float emin - (exponent + hm - 1).
	lostBit > 0 ifTrue: [n := n - lostBit max: 1].

	"Remove excess bits in the mantissa."
	hm > n
		ifTrue:
			[exponent := exponent + hm - n.
			hasTruncatedBits := hasTruncatedBits or: [mantissa anyBitOfMagnitudeFrom: 1 to: hm - n].
			mantissa := mantissa bitShift: n - hm].

	"Check if mantissa must be rounded upward.
	The case of tie will be handled by Integer>>asFloat."
	(hasTruncatedBits and: [mantissa odd])
		ifTrue: [mantissa := mantissa + 1].

	floatMantissa := mantissa asFloat.
	self positive ifFalse: [floatMantissa := floatMantissa negated].
	^floatMantissa timesTwoPower: exponent! !
!Integer methodsFor: 'bit manipulation' stamp: 'jmv 12/4/2018 11:59:58' prior: 16859338!
                             highBitOfMagnitude
	"Answer the position of the leading bit or zero if the  
	receiver is zero. Receiver has to be positive!!"

	| shifted bitNo |
	shifted := self < 0 ifTrue: [0 - self] ifFalse: [self].
	bitNo := 0.
	[shifted < 65536]
		whileFalse: 
			[shifted := shifted bitShift: -16.
			bitNo := bitNo + 16].
	shifted < 256
		ifFalse: 
			[shifted := shifted bitShift: -8.
			bitNo := bitNo + 8].
		
	"The high bits table can be obtained with:
	(1 to: 8) inject: #[0] into: [:highBits :rank | highBits , (highBits collect: [:e | rank])]."
	^bitNo + ( #[0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8] at: shifted + 1)! !
!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'jmv 12/4/2018 11:59:42' prior: 16862428!
                       highBit
	"Answer the position of the leading bit or zero if the  
	receiver is zero. Raise an error if the receiver is negative, since  
	negative integers are defined to have an infinite number of leading 1's 
	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  
	get the highest bit of the magnitude."
	^ self highBitOfMagnitude! !
!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'jmv 12/4/2018 12:04:04' prior: 16862443!
                        highBitOfMagnitude
	"Answer the position of the leading bit or zero if the  
	receiver is zero. 
	This method is used for LargeNegativeIntegers as well,  
	since Squeak's LargeIntegers are sign/magnitude."
	| byteIndex msByte |
	byteIndex := self digitLength.
	[byteIndex > 0] whileTrue:
		[
			msByte  := self at: byteIndex.
			msByte  > 0 ifTrue: [^byteIndex - 1 * 8 + msByte  highBit].
			byteIndex := byteIndex - 1
		].
	^0! !
!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'jmv 12/4/2018 11:59:30' prior: 16862144!
           highBit
	"Answer the position of the leading bit or zero if the  
	receiver is zero. Raise an error if the receiver is negative, since  
	negative integers are defined to have an infinite number of leading 1's 
	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  
	get the highest bit of the magnitude."

	^self error: 'highBit is not defined for negative integers'! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3513-NumericsCleanup-JuanVuletich-2018Dec04-10h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3512] on 4 December 2018 at 12:21:28 pm'!
!Float methodsFor: 'converting' stamp: 'jmv 12/4/2018 12:20:55' prior: 50421275!
      partValues: aThreeArgumentBlock ifInfinite: infinityBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"
	| sign exponent mantissa |

	self partBits: [ :signBit :exponentBits :mantissaBits |

		"Extract the sign"
		sign _ signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infinityBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent _ exponentBits - 16r3FF.

		"Add back implicit leading 1 in fraction if appropriate"
		"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa"	
		exponentBits = 0
			ifTrue: [
				mantissa _ mantissaBits.
				exponent _ exponent + 1 ]
			ifFalse: [
				mantissa _ 16r0010000000000000 bitOr: mantissaBits ].

		"Evaluate the block"
		^aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3514-NumericsCleanup-JuanVuletich-2018Dec04-12h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3512] on 4 December 2018 at 12:26:03 pm'!
!Float methodsFor: 'printing' stamp: 'jmv 12/3/2018 18:27:17' prior: 16845515!
                        hex
	^ String streamContents: [ :strm | | word nibble |
		1 to: 2 do: [ :i |
			word := self at: i.
			1 to: 8 do: [ :s |
				nibble := (word bitShift: -8+s*4) bitAnd: 16rF.
				strm nextPut: ('0123456789ABCDEF' at: nibble+1)]]]
"
(-2.0 to: 2.0) collect: [:f | f hex]
"! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3515-NumericsCleanup-JuanVuletich-2018Dec04-12h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3515] on 4 December 2018 at 3:51:34 pm'!
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 15:21:29'!
                             nextAwayFromZero
	"Answer the Float with smallest magnitude but larger than ours, with the same sign
	Only for finite numbers."

	| exponent mantissa |
	self partValues: [ :sign :myExponent :myMantissa |
		myMantissa = 16r1FFFFFFFFFFFFF
			ifTrue: [
				mantissa _ 16r10000000000000.
				exponent _ myExponent +1 ]
			ifFalse: [
				mantissa _ myMantissa+1.
				exponent _ myExponent ].
		^ Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 15:21:25'!
 nextTowardsZero
	"Answer the Float with largest magnitude but smaller than ours, with the same sign.
	Only for finite, non zero numbers."

	| exponent mantissa |
	self partValues: [ :sign :myExponent :myMantissa |
		myMantissa isZero ifTrue: [ self error: 'Not for zero values' ].
		(myMantissa = 16r10000000000000 and: [myExponent > Float emin])
			ifTrue: [
				mantissa _ 16r1FFFFFFFFFFFFF.
				exponent _ myExponent -1 ]
			ifFalse: [
				mantissa _ myMantissa-1.
				exponent _ myExponent ].
		^ Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float class methodsFor: 'instance creation' stamp: 'jmv 12/4/2018 14:10:38'!
                    signBit: signBit mantissaBits: mantissaBits exponentBits: exponentBits 
	"
	Float signBit: Float pi signBit mantissaBits: Float pi mantissaBits exponentBits: Float pi exponentBits
	"
	| answer leastSignificativeWord mostSignificativeWord |
	answer _ BoxedFloat64 new.
	mostSignificativeWord _ (signBit bitShift: 31) + (exponentBits bitShift: 20) + (mantissaBits bitShift: -32).
	leastSignificativeWord _ mantissaBits bitAnd: 16rFFFFFFFF.
	answer basicAt: 1 put: mostSignificativeWord.
	answer basicAt: 2 put: leastSignificativeWord.
	^ answer! !
!Float class methodsFor: 'instance creation' stamp: 'jmv 12/4/2018 14:09:38'!
                signPart: signPart mantissaPart: mantissaPart exponentPart: exponentPart
	"
	Float signPart: Float pi signPart mantissaPart: Float pi mantissaPart exponentPart: Float pi exponentPart
	"
	^ signPart * mantissaPart asFloat timesTwoPower: exponentPart-52! !
!Float methodsFor: 'converting' stamp: 'jmv 12/4/2018 13:37:51' prior: 50421242!
                partBits: aThreeArgumentBlock
	"
	Extract the bits for Sign, Mantissa and Exponent parts of the Floating Point representation.
	Just extract the bits. Do not add implicit bit. Do not correct denormals. Do not substract exponent bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	| signBit exponentBits mantissaBits leastSignificativeWord mostSignificativeWord |

	mostSignificativeWord _ self basicAt: 1.
	leastSignificativeWord _ self basicAt: 2.
	signBit _ mostSignificativeWord bitShift: -31 .
	exponentBits _ (mostSignificativeWord bitShift: -20 ) bitAnd: 16r7FF.
	mantissaBits _ ((mostSignificativeWord bitAnd: 16r000FFFFF) bitShift: 32) + leastSignificativeWord.

	"Evaluate the block"
	^aThreeArgumentBlock value: signBit value: exponentBits value: mantissaBits! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 14:54:42' prior: 50421336!
 predecessor
	"Answer the largest Float smaller than self"

	self isFinite ifFalse: [
		(self isNaN or: [self negative]) ifTrue: [^self].
		^Float fmax].
	self isZero ifTrue: [
		"Both for positive and negative zero"
		^ -0.0 nextAwayFromZero ].
	^self > 0.0
		ifTrue: [ self nextTowardsZero ]
		ifFalse: [ self nextAwayFromZero ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 14:54:36' prior: 50421363!
                    successor
	"Answer the smallest Float greater than self"

	self isFinite ifFalse: [
		(self isNaN or: [self positive]) ifTrue: [^self].
		^Float fmax negated].
	self isZero ifTrue: [
		"Both for positive and negative zero"
		^ 0.0 nextAwayFromZero ].
	^self < 0.0
		ifTrue: [ self nextTowardsZero ]
		ifFalse: [ self nextAwayFromZero ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/4/2018 14:51:27' prior: 50421377!
              ulp
	"Answer the unit of least precision of the receiver"
	
	self isFinite ifFalse: [^self abs].
	^ (self nextAwayFromZero - self) abs! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3516-muchBetterUlpPredecessorSuccessor-JuanVuletich-2018Dec04-15h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3508] on 6 December 2018 at 12:58:58 pm'!

VariableScopeFinder removeSelector: #visitFieldNode:!

VariableScopeFinder removeSelector: #visitFieldNode:!

ParseNodeEnumerator removeSelector: #visitFieldNode:!

ParseNodeEnumerator removeSelector: #visitFieldNode:!

ParseNodeVisitor removeSelector: #visitFieldNode:!

ParseNodeVisitor removeSelector: #visitFieldNode:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3517-Cleanup-HernanWilkinson-2018Dec06-12h58m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3517] on 10 December 2018 at 6:59:08 pm'!
!Float methodsFor: 'converting' stamp: 'jmv 12/10/2018 18:49:42' prior: 50421587!
           partValues: aThreeArgumentBlock ifInfinite: infinityBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"
	| sign exponent mantissa |

	^ self partBits: [ :signBit :exponentBits :mantissaBits |

		"Extract the sign"
		sign _ signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infinityBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent _ exponentBits - 16r3FF.

		"Add back implicit leading 1 in fraction if appropriate"
		"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa"	
		exponentBits = 0
			ifTrue: [
				mantissa _ mantissaBits.
				exponent _ exponent + 1 ]
			ifFalse: [
				mantissa _ 16r0010000000000000 bitOr: mantissaBits ].

		"Evaluate the block"
		aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/10/2018 18:49:08' prior: 50417780!
          exponentBits
	"
	Actual bits for the exponent part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not substract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f exponentBits. f exponentPart. f exponent } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | exponentBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/10/2018 18:49:15' prior: 50417796!
                       mantissaBits
	"
	Actual bits for the mantissa part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not substract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f mantissaBits. f mantissaPart. f significand. } print ].
	"
	^ self partBits: [ :signBit :exponentBits :mantissaBits | mantissaBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/10/2018 18:54:58' prior: 50421656!
                    nextAwayFromZero
	"Answer the Float with smallest magnitude but larger than ours, with the same sign
	Only for finite numbers."

	| exponent mantissa |
	^ self partValues: [ :sign :myExponent :myMantissa |
		myMantissa = 16r1FFFFFFFFFFFFF
			ifTrue: [
				mantissa _ 16r10000000000000.
				exponent _ myExponent +1 ]
			ifFalse: [
				mantissa _ myMantissa+1.
				exponent _ myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/10/2018 18:55:04' prior: 50421673!
                nextTowardsZero
	"Answer the Float with largest magnitude but smaller than ours, with the same sign.
	Only for finite, non zero numbers."

	| exponent mantissa |
	^ self partValues: [ :sign :myExponent :myMantissa |
		myMantissa isZero ifTrue: [ self error: 'Not for zero values' ].
		(myMantissa = 16r10000000000000 and: [myExponent > Float emin])
			ifTrue: [
				mantissa _ 16r1FFFFFFFFFFFFF.
				exponent _ myExponent -1 ]
			ifFalse: [
				mantissa _ myMantissa-1.
				exponent _ myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/10/2018 18:49:24' prior: 50417812!
  signBit
	"
	Actual bits for the exponent part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not substract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0. 0.0. -0.0} do: [ :f |
		{ f. f signBit. f signPart. f sign } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | signBit ]! !
!Integer methodsFor: 'bit manipulation' stamp: 'jmv 12/10/2018 18:36:21' prior: 16859375!
         lowBit
	"Answer the index of the low order bit of this number"

	| byte byteIndex byteSize |
	byteIndex _ 1.
	byteSize _ self digitLength.
	[ byteIndex <= byteSize ] whileTrue: [
		byte _ self at: byteIndex.
		byte > 0 ifTrue: [ ^ byteIndex - 1 * 8 + byte lowBit ].
		byteIndex _ byteIndex + 1 ].
	^ 0.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3518-AvoidNonLocalReturns-JuanVuletich-2018Dec10-14h13m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3517] on 11 December 2018 at 1:42:08 pm'!
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/11/2018 13:10:34' prior: 50421786!
     ulp
	"Answer the unit of least precision of the receiver.
	Follow John Harrison's definition as described at
	https://en.wikipedia.org/wiki/Unit_in_the_last_place"
	
	self isFinite ifFalse: [^self abs].
	self isZero ifTrue: [^0.0 nextAwayFromZero].
	^ (self - self nextTowardsZero) abs! !
!Float class methodsFor: 'constants' stamp: 'jmv 12/11/2018 13:21:21' prior: 16845879!
        epsilon
	"Answer difference between 1.0 and next representable value.
	Note: does not equal 1.0 ulp."
	
	^1.0 successor - 1.0! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3519-UseJohnHarrisonsUlp-JuanVuletich-2018Dec11-10h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3511] on 12 December 2018 at 12:40:54 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 12/12/2018 12:22:30' prior: 16799212!
                   notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]		-> Test
	(Installing beginsWith: Install-')																					-> Install
	Installing isNil 																											-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]	-> Normal
	"! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 12/12/2018 12:40:08' prior: 50401553!
  install: aFileStream
	"Installs the package. Replace all existing code in the CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Create, install and answer a (sub)instance of CodePackage"
	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS _ ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS _ nil ].
		pckClass _ CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				ee fileInDefinitionAndMetaclass.
				pckClass _ Smalltalk at: ee name ]].
		newCodePackage _ pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].
	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3520-AvoidSuperfluousCSOnPackageInstall-JuanVuletich-2018Dec12-12h40m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3520] on 13 December 2018 at 5:20:43 pm'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/12/2018 16:22:24' prior: 16904023!
                          xBinary

	tokenType _ #binary.
	token _ String streamContents: [ :stream |
	stream nextPut: self step.
	[	| type |
		type _ self typeTableAt: hereChar.
		type == #xBinary and: [hereChar ~= $- or: [aheadChar isDigit not]]
		] whileTrue: [
		stream nextPut: self step]].
	token _ token asSymbol! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 12/12/2018 15:33:25' prior: 50410161!
                      initTypeTable
	| newTable |
	newTable := Array new: 256 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"

	1 to: 255
		do: [:index |
			(Character numericValue: index) isValidInIdentifiers
				ifTrue: [
					"Digits and $_ are overwritten later"
					newTable at: index put: #xLetter ]].

	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable atAll:  '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.

	newTable at: self doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!Parser methodsFor: 'private' stamp: 'jmv 12/12/2018 16:17:46' prior: 16885517!
                 privateReadSelector
	| args selector |
	doitFlag := false.

	hereType == #word ifTrue: [
		^ here asSymbol ].

	self transformVerticalBarAndUpArrowIntoABinarySelector.

	hereType == #binary ifTrue: [
		^ here asSymbol ].

	hereType == #keyword ifTrue: [
		selector := WriteStream on: (String new: 32).
		args := OrderedCollection new.
		[hereType == #keyword] whileTrue: [
			selector nextPutAll: self advance.
			args addLast: (encoder bindArg: self argumentName).
		].
		^ selector contents asSymbol ].

	^self expected: 'Message pattern'! !
!Parser methodsFor: 'scanning' stamp: 'jmv 12/13/2018 17:07:02' prior: 16885783!
               transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Also do the same with some other special characters that are allowed as binary selectors, in addition to their traditional meaning"
	| special |
	special _ #(verticalBar upArrow).
	(special identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asString.
	hereType := #binary.
	[(special identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asString.
			hereEnd := hereEnd + 1.
			self scanToken].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken].! !
!Parser methodsFor: 'expression types' stamp: 'jmv 12/12/2018 16:17:30' prior: 50409422!
         messagePart: level repeat: repeat

	| start receiver selector args precedence words keywordStart |
	
	[receiver := parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: 
			[start := self startOfNextToken.
			selector := WriteStream on: (String new: 32).
			args := OrderedCollection new.
			words := OrderedCollection new.
			[hereType == #keyword]
				whileTrue: 
					[keywordStart := self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])
				ifFalse: [ selector := self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ].
			precedence := 3]
		ifFalse: [
			
			level >= 2 ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].
			((hereType == #binary )
				and: [level >= 2])
				ifTrue: 
					[start := self startOfNextToken.
					selector := self advance asSymbol.
					words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args := Array with: parseNode.
					precedence := 2]
				ifFalse: [hereType == #word
						ifTrue: 
							[start := self startOfNextToken.
							selector := self advance.
							args := #().
							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])
								ifFalse: [ selector := self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ].
							precedence := 1]
						ifFalse: [^args notNil]]].

	parseNode := MessageNode new
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken)
				keywordsRanges: words.
	repeat]
		whileTrue: [].
	^true! !
!Parser methodsFor: 'expression types' stamp: 'jmv 12/12/2018 16:16:14' prior: 50409396!
                      pattern: fromDoit inContext: ctxt
	" unarySelector | binarySelector arg | keyword arg {keyword arg} =>
	{selector, arguments, precedence}."
	
	doitFlag := fromDoit.
	
	fromDoit ifTrue: [^self doitPatternInContext: ctxt ].
	hereType == #word ifTrue: [^self unaryPattern ].
	self transformVerticalBarAndUpArrowIntoABinarySelector.
	hereType == #binary ifTrue: [^self binaryPattern ].
	hereType == #keyword ifTrue: [^self keywordPattern ]. 
	
	^self expected: 'Message pattern'
! !

Parser removeSelector: #transformVerticalBarAndUpArrowIntoABinarySelectorIfNecessary!

Parser removeSelector: #transformVerticalBarAndUpArrowIntoABinarySelectorIfNecessary!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3521-AdditionalPossibleBinarySelectors-JuanVuletich-2018Dec13-17h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3521] on 13 December 2018 at 7:37:45 pm'!
!Parser methodsFor: 'scanning' stamp: 'jmv 12/13/2018 19:37:11' prior: 50422194!
            transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain."
	| toMakeBinary |
	toMakeBinary _ #(verticalBar upArrow colon).
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asString.
	hereType := #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asString.
			hereEnd := hereEnd + 1.
			self scanToken].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken].! !
!SHParserST80 methodsFor: 'token testing' stamp: 'jmv 12/13/2018 19:37:20' prior: 16902034!
                 isBinary
	| c |
	(currentToken isNil or: [self isName or: [self isKeyword]]) 
		ifTrue: [^false].
	"Special case: '::' is not a binary selector but the Chain operator"
	(sourcePosition - currentTokenSourcePosition = 1 and: [
		(source at: currentTokenSourcePosition ifAbsent: nil) = $: and: [		
			(source at: sourcePosition ifAbsent: nil) = $: ]])
				ifTrue: [^ false ].
	1 to: currentToken size do: [ :i |
		c := currentToken at: i.
		((self isBinarySelectorCharacter: c) or: [c == $:])
			ifFalse: [^false]].
	^true! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3522-AllowColonAsBinarySelector-JuanVuletich-2018Dec13-19h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3508] on 13 December 2018 at 4:50:45 pm'!

Object subclass: #StackSizeWatcher
	instanceVariableNames: 'watcher timeBetweenChecks stackSizeThreashold delay delayBetweenChecks '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'
!

!classDefinition: #StackSizeWatcher category: #'Tools-Profiling'!
Object subclass: #StackSizeWatcher
	instanceVariableNames: 'watcher timeBetweenChecks stackSizeThreashold delay delayBetweenChecks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!
!StackSizeWatcher methodsFor: 'configuration changing' stamp: 'HAW 12/13/2018 16:28:08' prior: 50389898!
                       changeTimeBetweenChecksTo: aTimeBetweenChecks

	"time in milliseconds - Hernan"

	delayBetweenChecks _ Delay forMilliseconds: aTimeBetweenChecks.
! !
!StackSizeWatcher methodsFor: 'testing' stamp: 'HAW 12/13/2018 16:48:10' prior: 50389929!
                shouldStopAndDebug: aProcess

	"Verify the process can be debugged before #isStackTooDeepAt: to avoid
	loosing time in #isStackDeeperThan: that is more expensive - Hernan"

	^(self canDebug: aProcess) and: [self isStackTooDeepAt: aProcess]

! !
!StackSizeWatcher methodsFor: 'private' stamp: 'HAW 12/13/2018 16:29:13' prior: 50389965!
                 watch

	| processToWatch |

	delayBetweenChecks wait.
	processToWatch := Processor nextReadyProcess.
	(self shouldStopAndDebug: processToWatch) ifTrue: [ self debug: processToWatch ]
! !
!StackSizeWatcher class methodsFor: 'start/stop' stamp: 'HAW 12/13/2018 16:21:22' prior: 50389993!
  isWatching

	^ current notNil and: [ current isWatching ]! !

Object subclass: #StackSizeWatcher
	instanceVariableNames: 'watcher stackSizeThreashold delayBetweenChecks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'
!

!classDefinition: #StackSizeWatcher category: #'Tools-Profiling'!
Object subclass: #StackSizeWatcher
	instanceVariableNames: 'watcher stackSizeThreashold delayBetweenChecks'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3523-StackSizeWatcher-improvements-HernanWilkinson-2018Dec13-16h20m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3523] on 13 December 2018 at 8:18:41 pm'!
!Debugger methodsFor: 'private' stamp: 'jmv 12/13/2018 20:18:10' prior: 16830176!
       resumeProcess
	| mustTerminateActive mustRedisplay |
	mustRedisplay _ self runningWorld.
	savedCursor
		ifNotNil: [savedCursor activateCursor].
	mustTerminateActive _ false.
	interruptedProcess isTerminated ifFalse: [
		Processor activeProcess animatedUI = interruptedProcessUI ifTrue: [
			interruptedProcess animatedUI: interruptedProcessUI.
			mustTerminateActive _ true ].
		interruptedProcess resume ].
	"if old process was terminated, just terminate current one"
	interruptedProcess _ nil.
	contextStackIndex _ 0.
	contextStack _ nil.
	contextStackTop _ nil.
	receiverInspector _ nil.
	contextVariablesInspector _ nil.
	mustRedisplay ifNotNil: [ :w | UISupervisor whenUIinSafeState: [ w displayWorld ]].
	"restart low space handler"
	Smalltalk installLowSpaceWatcher.
	"If this process was the UI process, then it will terminate and never return to caller."
	mustTerminateActive
		ifTrue: [ Processor terminateActive ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3524-DebuggerResumeRedisplayFix-JuanVuletich-2018Dec13-20h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3524] on 14 December 2018 at 3:43:44 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 12/14/2018 15:30:45'!
              isValidInBinarySelectors
	"Can be part of a binary selector?
		$< isValidInBinarySelectors
		$| isValidInBinarySelectors
		$^ isValidInBinarySelectors
		$: isValidInBinarySelectors
	"
	^#(verticalBar upArrow xColon xBinary) statePointsTo: (Scanner typeTable at: self numericValue)! !
!String methodsFor: 'converting' stamp: 'jmv 12/14/2018 15:40:54' prior: 16916666!
                 findSelector
	"Revised to use scanner for better removal of extraneous stuff"
	| sel colonIndex |
	sel _ self withBlanksTrimmed.
	colonIndex _ sel indexOf: $:.
	"possible keyword selector"
	(colonIndex > 1 and: [ (self at: colonIndex - 1) isLetter ]) ifTrue: [
		sel _ Scanner findSelectorIn: sel ].
	sel isEmpty ifTrue: [ ^ nil ].
	Symbol
		hasInterned: sel
		ifTrue: [ :aSymbol |
			^ aSymbol ].
	^ nil.! !
!String methodsFor: 'converting' stamp: 'jmv 12/14/2018 09:53:01' prior: 16916699!
                    keywords
	"Answer an array of the keywords that compose the receiver."
	| kwd char keywords isAllLeters |
	keywords _ Array streamContents: [ :kwds |
		kwd _ WriteStream on: (String new: 16).
		isAllLeters _ true.
		1
			to: self size
			do: [ :i |
				char _ self at: i.
				kwd nextPut: char.
				char = $: & isAllLeters
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllLeters _ true ]
					ifFalse: [
						char isLetter ifFalse: [ isAllLeters _ false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!String methodsFor: 'system primitives' stamp: 'jmv 12/14/2018 15:27:30' prior: 16917278!
                    numArgs
	"Answer either the number of arguments that the receiver would take if considered a selector. 
	Answer -1 if it couldn't be a selector. 
		Note that currently this will answer -1 for anything begining with an uppercase letter even though 
		the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."
	| firstChar numColons start ix |
	self size = 0 ifTrue: [ ^ -1 ].
	"Binary messages"
	(self allSatisfy: [ :c | c isValidInBinarySelectors ])
		ifTrue: [ ^1 ].
	"Unary and keyword messages"
	firstChar _ self at: 1.
	firstChar isValidStartOfIdentifiers ifTrue: [
		"Fast reject if any chars are non-alphanumeric"
		(self
			findSubstring: '~'
			in: self
			startingAt: 1
			matchTable: Tokenish) > 0 ifTrue: [ ^ -1 ].
		"Fast colon count"
		numColons _ 0.
		start _ 1.
		[
		(ix _ self
			findSubstring: ':'
			in: self
			startingAt: start
			matchTable: CaseSensitiveOrder) > 0 ] whileTrue: [
			numColons _ numColons + 1.
			start _ ix + 1 ].
		^ numColons ].
	^ -1.! !
!Symbol methodsFor: 'accessing' stamp: 'jmv 12/14/2018 15:41:59' prior: 16918441!
                              precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise.  The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self size = 0 ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c _ self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last = $: ifTrue: [^ 3].
	^ 1! !
!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 12/14/2018 15:39:18' prior: 50386078!
   isBinarySelectorCharacter: aCharacter
	aCharacter = $: ifTrue: [^ false].
	^aCharacter isValidInBinarySelectors! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3525-MiscFixesForColonAsBinarySelector-JuanVuletich-2018Dec14-13h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3512] on 17 December 2018 at 10:09:21 am'!
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 12/17/2018 10:09:17' prior: 16923172!
                forceChangesToDisk
	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."

	| changesFile |
	"Expensive and not worth doing, esp. in Windows with antivirus active, when installing large packages"
	ChangeSet notInstallOrTestRun ifTrue: [
		changesFile _ SourceFiles at: 2.
		changesFile isFileStream ifTrue: [
			changesFile flush.
			changesFile close.
			changesFile open: changesFile name forWrite: true.
			changesFile setToEnd.
		].
	]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 12/17/2018 10:05:42' prior: 16799185!
           installing: aCodePackageOrChangeSetName do: aBlock

	| currentCS currentCSNumber newHighestUpdate |
	Installing _ 'Install-', aCodePackageOrChangeSetName.
	aBlock ensure: [ Installing _ nil ].
	Smalltalk forceChangesToDisk.

	SystemVersion current registerUpdate: aCodePackageOrChangeSetName.
	newHighestUpdate _  SystemVersion current highestUpdate.

	currentCSNumber _ self currentBaseCSNumber.
	currentCS _ self changeSetForBaseSystem.
	currentCS isEmpty ifTrue: [
		ChangeSet removeChangeSet: currentCS.
		currentCSNumber > newHighestUpdate ifFalse: [
			CurrentBaseCSNumber _ newHighestUpdate + 1 ]]! !
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 12/17/2018 10:08:59' prior: 16909373!
                 addSelector: aSymbol method: aCompiledMethod allImplemented: implemented

	| sentValue value |
	self protected: [
		value _ ChangeSet notInstallOrTestRun
			ifTrue: [
				"Expensive and not worth doing, esp. in Windows with antivirus active, when installing large packages"
				aCompiledMethod dateSortingValue ]
			ifFalse: [ 0 ].
		Selectors at: aSymbol put: (value  max: (Selectors at: aSymbol ifAbsent: [0])).
		aCompiledMethod messages do: [ :sentMsg |
			((Selectors includesKey: sentMsg) or: [ 
				implemented
					ifNotNil: [ implemented includes: sentMsg ]
					ifNil: [ Smalltalk isThereAnImplementorOf: sentMsg ]])
						ifTrue: [
							sentValue _ value max: (Selectors at: sentMsg ifAbsent: [0]).
							Selectors at: sentMsg put: sentValue ]]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3526-FasterPackageInstallInWindows-JuanVuletich-2018Dec17-10h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3526] on 18 December 2018 at 12:49:31 pm'!
!Color class methodsFor: 'examples' stamp: 'jmv 12/17/2018 16:29:53'!
            experimentsTowardsANewColorPalette
"
self experimentsTowardsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Color random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Color new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Color new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Color new setHue: h chroma: selectedChroma luminance: v.
"		color _ Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !

Color class removeSelector: #experimentsTowarsANewColorPalette!

Color class removeSelector: #experimentsTowarsANewColorPalette!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3527-Color-tweak-JuanVuletich-2018Dec18-12h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3526] on 18 December 2018 at 12:50:08 pm'!
!Number methodsFor: 'comparing' stamp: 'jmv 12/18/2018 09:09:38'!
                  % another
	"Answer the relative distance between two number"
	^ (self - another) abs / (self abs + another abs / 2)! !
!Float methodsFor: 'truncation and round off' stamp: 'sqr 12/14/2018 23:01:59'!
                         floatsAwayFrom: aFloat

	| count2 count1 |
	(self isNaN or: [ aFloat isNaN ]) ifTrue: [ ^ Float nan ].
	self partBits: [:s :e :m | count2 := (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	aFloat partBits: [:s :e :m | count1 := (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	^count2 - count1! !
!Float methodsFor: 'comparing' stamp: 'sqr 12/14/2018 23:04:40'!
                             isWithin: anInteger floatsFrom: aNumber

	^self floatsAwayFrom: aNumber :: abs <= anInteger! !
!Float methodsFor: 'mathematical functions' stamp: 'sqr 12/14/2018 23:35:21' prior: 16844641!
   degreeCos
	"If finite, allow for special values such as cos(60 degrees) = 1/2"
	
	self isFinite ifTrue: [^super degreeCos].
	^self degreesToRadians cos! !
!Float methodsFor: 'mathematical functions' stamp: 'sqr 12/14/2018 23:35:44' prior: 16844648!
       degreeSin
	"If finite, allow for special values such as cos(30 degrees) = 1/2"
	
	self isFinite ifTrue: [^super degreeSin].
	^self degreesToRadians sin! !
!Interval class methodsFor: 'instance creation' stamp: 'sqr 12/15/2018 00:19:19' prior: 16861321!
   from: start to: stop by: step
	"Answer an instance of me, starting at start, ending at 
	stop, and with an interval increment of step.
	The actual interval creation uses start, stop and count, to avoid accumulation of rounding errors.
	We need to tell apart things like
		(0.0 to: 2.4 by: 0.1)	the caller wants to honor end
	from
		(0.0 to: 10.0 by: 3.0) 	the caller actually wants to end at 9.0.
		
	Before this,
		(0 to: 2.4 by: 0.1) last 
	used to answer 2.3"
	| count end |
	count _ stop - start / step + 1.
	(count isFloat and: [count isWithin: 5 floatsFrom: count rounded asFloat])
		ifTrue: [
			count _ count rounded.
			end _ stop ]
		ifFalse: [
			count _ count truncated.
			end _ count-1 * step + start ].
	^self from: start to: end count: count! !

Float removeSelector: #closeTo:!

Float removeSelector: #closeTo:!

Float removeSelector: #isWithin:ulpsFrom:!

Float removeSelector: #isWithin:ulpsFrom:!

Float removeSelector: #reduce!

Float removeSelector: #reduce!

Number removeSelector: #closeTo:!

Number removeSelector: #closeTo:!

Number removeSelector: #isWithin:ulpsFrom:!

Number removeSelector: #isWithin:ulpsFrom:!

Number removeSelector: #reduce!

Number removeSelector: #reduce!

Object removeSelector: #closeTo:!

Object removeSelector: #closeTo:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3528-Numerics-tweaks-JuanVuletich-2018Dec18-12h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3526] on 17 December 2018 at 6:04:42 pm'!
!String methodsFor: 'converting' stamp: 'HAW 12/17/2018 18:03:42' prior: 50422544!
            keywords
	"Answer an array of the keywords that compose the receiver."
	| kwd char keywords isAllValidInIdentifiers |
	keywords _ Array streamContents: [ :kwds |
		kwd _ WriteStream on: (String new: 16).
		isAllValidInIdentifiers _ true.
		1
			to: self size
			do: [ :i |
				char _ self at: i.
				kwd nextPut: char.
				char = $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers _ true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers _ false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3529-FixToColonAsBinarySelector-HernanWilkinson-2018Dec17-18h03m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3529] on 20 December 2018 at 10:58:38 am'!
!ObjectExplorer methodsFor: 'user interface support' stamp: 'jmv 12/20/2018 10:52:46'!
                            methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^aParsingErrorBlock value: nil! !
!TestResult methodsFor: 'Running' stamp: 'jmv 12/20/2018 10:58:20' prior: 16927991!
          runCase: aTestCase

	| testCasePassed |

	testCasePassed _
		[
			[
				Transcript show: 'Will run: '; print: aTestCase; newLine.
				aTestCase runCase.
				Transcript show: 'finished.'; newLine.
				true]
					on: self class failure
					do: [ :signal |
						Transcript print: signal; newLine.
						(self failures isEmpty or: [ (failures last == aTestCase) not ])
							ifTrue: [ failures add: aTestCase ].
						signal sunitExitWith: false ]]
							on: self class error
							do: [ :signal |
								Transcript print: signal; newLine.
								aTestCase errored: signal.
								self errors add: aTestCase.
								signal sunitExitWith: false ].

	testCasePassed
		ifTrue: [ self passed add: aTestCase ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3530-FixImplementorsInExplorer-LogTestInfoToTranscript-JuanVuletich-2018Dec20-10h50m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3529] on 20 December 2018 at 11:08:36 am'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/20/2018 11:07:32'!
                            storeOn: aStream
	self == Smalltalk ifTrue: [
		^ aStream nextPutAll: 'Smalltalk'].
	^ super storeOn: aStream! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3531-FixInfiniteRecursionOnDecompilingSmalltalkRefs-JuanVuletich-2018Dec20-10h58m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3529] on 20 December 2018 at 11:16:32 am'!
!FileIOAccessor methodsFor: 'private' stamp: 'pb 5/25/2016 00:32' prior: 50413540!
                        basicDirectoryExists: fullPathName

	| result |
	result := self primLookupEntryIn: fullPathName index: 1.
 	^(result == #badDirectoryPath) not! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3532-EmptyDirectoryDoesExist-JuanVuletich-2018Dec20-11h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3529] on 19 December 2018 at 6:02:57 pm'!

SmallInteger removeSelector: #instVarAt:!

SmallInteger removeSelector: #instVarAt:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3533-RemoveSmallIntegerInstVarAt-JuanVuletich-2018Dec19-18h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3533] on 21 December 2018 at 7:33:06 am'!
!Number methodsFor: 'arithmetic' stamp: 'jmv 12/20/2018 16:59:41'!
                         ^ another
	"Covenient, usual idiom.
	2 ^ 8
	"
	^ self raisedTo: another! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3534-CaretAsRaisedTo-JuanVuletich-2018Dec21-07h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3533] on 21 December 2018 at 7:39:11 am'!
!Number methodsFor: 'printing' stamp: 'jmv 12/20/2018 17:54:18' prior: 16880287!
printOn: aStream fractionDigits: placesDesired
	"Print a representation of the receiver on aStream in decimal notation with prescribed number of places after decimal separator."

	| rounder rounded roundedFractionPart |
	placesDesired > 0 ifFalse: [ ^ self rounded printOn: aStream ].
	rounder _ 10 raisedToInteger: placesDesired.
	rounded _ self roundTo: rounder reciprocal.
	rounded negative ifTrue: [ aStream nextPut: $- ].
	rounded _ rounded abs.
	rounded integerPart truncated printOn: aStream.
	aStream nextPut: $..
	roundedFractionPart _ (rounded fractionPart * rounder) truncated.
	roundedFractionPart
		printOn: aStream
		base: 10
		length: placesDesired
		padded: true! !
!Number methodsFor: 'printing' stamp: 'jmv 12/20/2018 16:30:54' prior: 16880311!
     printOn: aStream integerDigits: placesLeftOfFractionPoint fractionDigits: placesRightOfFractionPoint
	"placesLeftOfFractionPoint is the minimum to be used (use more if required)
	placesRightOfFractionPoint is strict. Add extra zeros or round as appropriate."
	"
	String streamContents: [ :strm | 23 printOn: strm integerDigits: 3 fractionDigits: 5 ]
	String streamContents: [ :strm | 1.23 printOn: strm integerDigits: 3 fractionDigits: 5 ]
	String streamContents: [ :strm | 123456.23 printOn: strm integerDigits: 3 fractionDigits: 5 ]
	String streamContents: [ :strm | Float pi printOn: strm integerDigits: 3 fractionDigits: 5 ]
	String streamContents: [ :strm | Float nan printOn: strm integerDigits: 3 fractionDigits: 5 ]
	String streamContents: [ :strm | Float infinity printOn: strm integerDigits: 3 fractionDigits: 5 ]
	String streamContents: [ :strm | Float negativeInfinity printOn: strm integerDigits: 3 fractionDigits: 5 ]
	String streamContents: [ :strm | Float zero printOn: strm integerDigits: 3 fractionDigits: 5 ]
	"

	^self printOn: aStream integerDigits: placesLeftOfFractionPoint padWith: nil fractionDigits: placesRightOfFractionPoint positiveIndicator: nil! !
!Float methodsFor: 'printing' stamp: 'jmv 12/21/2018 07:38:12' prior: 16845543!
                     printOn: aStream fractionDigits: placesDesired
	"This implementation avoids any rounding error caused by rounded or roundTo:
	The approach is simple. Round to appropriate integer, take the digits, and just 
	add the decimal point in the appropriate place."

	| i s scaled |
	self isFinite ifFalse: [ ^self printOn: aStream ].

	placesDesired > 0 ifFalse: [
		^self rounded printOn: aStream ].

	scaled _ self * (10 raisedTo: placesDesired).
	"If rounding could possible print a sequence that is read back as a different float, then go the more expensive Fraction way.
	If the following line is commented, #testPrintShowingDecimalPlaces4 will fail!!"
	scaled ulp > 1 ifTrue: [
		^ self asTrueFraction printOn: aStream fractionDigits: placesDesired ].
	i _ scaled rounded.
	i negative ifTrue: [
		aStream nextPut: $-.
		i _ i negated ].
	s _ i printString.
	placesDesired + 1 > s size
		ifTrue: [
			aStream nextPutAll: '0.'.
			placesDesired - s size timesRepeat: [ aStream nextPut: $0 ].
			aStream nextPutAll: s ]
		ifFalse: [
			aStream
				nextPutAll: (s copyFrom: 1 to: s size-placesDesired);
				nextPut: $.;
				nextPutAll: (s copyFrom: s size-placesDesired+1 to: s size) ]! !
!Fraction methodsFor: 'printing' stamp: 'jmv 12/20/2018 17:54:02' prior: 16849803!
              printOn: aStream fractionDigits: placesDesired
	"Same as super, but provides a faster implementation by inlining some Fraction protocol thus avoiding intermediate Fraction creation."
	
	| roundedFractionPart integerPart scaling |
	placesDesired > 0
		ifFalse: [self rounded printOn: aStream]
		ifTrue: [
			scaling := 10 raisedToInteger: placesDesired.
			integerPart := numerator abs quo: denominator.
			roundedFractionPart := (numerator abs - (integerPart * denominator)) * scaling * 2 + denominator quo: denominator * 2.
			roundedFractionPart = scaling
				ifTrue:
					[integerPart := integerPart + 1.
					roundedFractionPart := 0].
			"Don't print minus sign if result is rouded to zero"
			(numerator negative and: [integerPart > 0 or: [roundedFractionPart > 0]]) ifTrue: [aStream nextPut: $-].
			integerPart printOn: aStream.
			aStream nextPut: $..
			roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true].! !
!Integer methodsFor: 'printing' stamp: 'jmv 12/20/2018 17:54:47' prior: 16859997!
                        printOn: aStream fractionDigits: placesDesired
	"Same as super, but provides a faster implementation because fraction part and rounding are trivial."
	
	self printOn: aStream base: 10.

	placesDesired > 0
		ifTrue: [
			aStream nextPut: $..
			placesDesired timesRepeat: [
				aStream nextPut: $0 ]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3535-printOnFractionDigits-fix-JuanVuletich-2018Dec21-07h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3537] on 21 December 2018 at 2:50:39 pm'!
!Editor class methodsFor: 'help' stamp: 'jmv 12/21/2018 10:14:26' prior: 50405344!
                help
	"
	TextEditor help edit
	SmalltalkEditor help edit
	"
	| allSpecs |
	allSpecs _ self cmdShortcutsSpec, self basicCmdShortcutsSpec.
	^String streamContents: [ :strm |
		allSpecs do: [ :triplet | | c |
			c _ triplet first = Character space
				ifFalse: [ triplet first asString, '   	' ]
				ifTrue: [ 'Space'].
			strm nextPutAll: ('Cmd-', c, String tab, String tab, triplet third).
			strm newLine ]]! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 12/21/2018 14:43:04' prior: 50383114!
                          basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:					'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:			'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R		#indent:						'Indent (same as [Tab], move selection one tab-stap right)')
		#(		$Y		#makeUppercase:			'Force selection to uppercase')
		#(		$U		#changeLineEndsToLf:		'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H		#cursorTopHome:			'Move cursor to start of text')
		#(		$L		#outdent:					'Outdent (same as [Shift][Tab], move selection one tab-stop left)')

		#(		$Z		#redo:						'Redo (multiple levels)')
		#(		$X		#makeLowercase:			'Force selection to lowercase')
		#(		$C		#compareToClipboard:		'Compare argument to clipboard')

		#(		$ 		#selectWord:				'Select the current word as with double clicking')
	)! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3536-EditorHelpTweaks-JuanVuletich-2018Dec21-14h50m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3538] on 21 December 2018 at 2:53:25 pm'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 12/21/2018 11:06:01' prior: 50420453!
                           expNonPrimitive
	"Answer e raised to the receiver power."

	| base fract correction delta div |

	"Taylor series"
	"check the special cases"
	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].
	self = 0.0 ifTrue: [^ 1].
	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].

	"get first approximation by raising e to integer power"
	base _ E raisedToInteger: (self truncated).

	"now compute the correction with a short Taylor series"
	"fract will be 0..1, so correction will be 1..E"
	"in the worst case, convergance time is logarithmic with 1/Epsilon"
	fract _ self fractionPart.
	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"

	correction _ 1.0 + fract.
	delta _ fract * fract / 2.0.
	div _ 2.0.
	[delta >= base ulp] whileTrue: [
		correction _ correction + delta.
		div _ div + 1.0.
		delta _ delta * fract / div].
	correction _ correction + delta.
	^ base * correction! !
!Float methodsFor: 'converting' stamp: 'jmv 12/21/2018 11:12:14' prior: 50421725!
             partBits: aThreeArgumentBlock
	"
	Extract the bits for Sign, Mantissa and Exponent parts of the Floating Point representation.
	Just extract the bits. Do not add implicit bit. Do not correct denormals. Do not subtract exponent bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	| signBit exponentBits mantissaBits leastSignificativeWord mostSignificativeWord |

	mostSignificativeWord _ self basicAt: 1.
	leastSignificativeWord _ self basicAt: 2.
	signBit _ mostSignificativeWord bitShift: -31 .
	exponentBits _ (mostSignificativeWord bitShift: -20 ) bitAnd: 16r7FF.
	mantissaBits _ ((mostSignificativeWord bitAnd: 16r000FFFFF) bitShift: 32) + leastSignificativeWord.

	"Evaluate the block"
	^aThreeArgumentBlock value: signBit value: exponentBits value: mantissaBits! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/21/2018 11:12:06' prior: 50421861!
 exponentBits
	"
	Actual bits for the exponent part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f exponentBits. f exponentPart. f exponent } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | exponentBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/21/2018 11:12:10' prior: 50421878!
                        mantissaBits
	"
	Actual bits for the mantissa part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f mantissaBits. f mantissaPart. f significand. } print ].
	"
	^ self partBits: [ :signBit :exponentBits :mantissaBits | mantissaBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/21/2018 11:12:18' prior: 50421934!
                     signBit
	"
	Actual bits for the exponent part of the Floating Point representation.
	Just extract the bits. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0. 0.0. -0.0} do: [ :f |
		{ f. f signBit. f signPart. f sign } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | signBit ]! !
!Float class methodsFor: 'constants' stamp: 'jmv 12/21/2018 11:02:26' prior: 16845865!
             e
	"Answer the constant, e."

	^E! !
!Float class methodsFor: 'constants' stamp: 'jmv 12/21/2018 12:54:06' prior: 16845869!
    emax
	"Answer exponent of the maximal representable value"
	
	^1023! !
!Float class methodsFor: 'constants' stamp: 'jmv 12/21/2018 12:54:26' prior: 50421982!
  epsilon
	"Answer the difference between 1.0 and the next representable value.
	Note: does not equal 1.0 ulp."
	
	^1.0 successor - 1.0! !
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/21/2018 11:04:53' prior: 50420638!
                  exp
	"Answer e raised to the receiver power.
	 Optional. See Object documentation whatIsAPrimitive." 

	<primitive: 59>
	^ self expNonPrimitive! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/21/2018 11:05:17' prior: 50420675!
        exp
	"Answer e raised to the receiver power.
	 Optional. See Object documentation whatIsAPrimitive." 

	<primitive: 559>
	^ self expNonPrimitive! !
!Fraction methodsFor: 'printing' stamp: 'jmv 12/21/2018 11:15:47' prior: 50423093!
                         printOn: aStream fractionDigits: placesDesired
	"Same as super, but provides a faster implementation by inlining some Fraction protocol thus avoiding intermediate Fraction creation."
	
	| roundedFractionPart integerPart scaling |
	placesDesired > 0
		ifFalse: [self rounded printOn: aStream]
		ifTrue: [
			scaling := 10 raisedToInteger: placesDesired.
			integerPart := numerator abs quo: denominator.
			roundedFractionPart := (numerator abs - (integerPart * denominator)) * scaling * 2 + denominator quo: denominator * 2.
			roundedFractionPart = scaling
				ifTrue:
					[integerPart := integerPart + 1.
					roundedFractionPart := 0].
			"Don't print minus sign if result is rounded to zero"
			(numerator negative and: [integerPart > 0 or: [roundedFractionPart > 0]]) ifTrue: [aStream nextPut: $-].
			integerPart printOn: aStream.
			aStream nextPut: $..
			roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3537-FixTyposInNumerics-JuanVuletich-2018Dec21-14h52m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3535] on 21 December 2018 at 9:18:35 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/21/2018 09:18:25' prior: 50418191!
   knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3538-AddAngelAsKnownAuthor-JuanVuletich-2018Dec21-09h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3538] on 21 December 2018 at 3:11:09 pm'!
!TextEditor methodsFor: 'editing keys' stamp: 'AY 12/17/2018 17:05:42'!
                           tabKey: aKeyboardEvent
	"Add/remove a tab at the front of every line occupied by the selection if there is one; treat as a normal character otherwise."
	
	aKeyboardEvent shiftPressed 
		ifTrue: [ ^ self outdent: aKeyboardEvent ].
	
	^ self hasSelection 
		ifTrue: [ self indent: aKeyboardEvent ]
		ifFalse: [ self normalCharacter: aKeyboardEvent ]! !
!TextEditor class methodsFor: 'class initialization' stamp: 'AY 12/21/2018 13:10:43'!
           initializeShortcuts
	
	super initializeShortcuts.
	shortcuts at: 9 + 1 put: #tabKey:.! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 12/21/2018 08:09:38' prior: 50423163!
                            basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:					'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:			'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R		#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y		#makeUppercase:			'Force selection to uppercase')
		#(		$U		#changeLineEndsToLf:		'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H		#cursorTopHome:			'Move cursor to start of text')
		#(		$L		#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z		#redo:						'Redo (multiple levels)')
		#(		$X		#makeLowercase:			'Force selection to lowercase')
		#(		$C		#compareToClipboard:		'Compare argument to clipboard')

		#(		$ 		#selectWord:				'Select the current word as with double clicking')
	)! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/21/2018 09:21:39' prior: 16874864!
          focusKeyboardFor: aKeyboardEvent

	"If aKeyboardEvent ctrl-tab or shift-ctrl-tab use it to navigate keyboard focus.
	Warning: This doesn't work on Windows... the event is not sent"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent controlKeyPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ]
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ].
			^ true ].
	"On Windows use at least some keystroke to navigate morphs... even shift-Tab that should navigate backwards"
"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent shiftPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent hand keyboardFocusNext.
			^ true ].
"

	"Cycle through windows with cmdAlt + < and cmdAlt + >.
	VM and platform peculiarities are hidden in #isCmdAltLessThan and #isCmdAltGreaterThan"
	"This was done as an attempt to mimic the Mac OSX keystrokes for 'Move focus to next window in active application'. Unfortunately, it only works if OS X is set to use any other keys for this. If (as for example, with German defaults), OS-X uses these keystrokes, then they are not sent to the VM. This is a long standing issues in Chromium and PhotoShop, for example..."
	self disableCode: [
		aKeyboardEvent isCmdAltLessThan ifTrue: [
			aKeyboardEvent hand activatePreviousWindow.
			^true ].
		aKeyboardEvent isCmdAltGreaterThan ifTrue: [
			aKeyboardEvent hand activateNextWindow.
			^true ]].
	"Alternative for Mac OS-X: option-Tab and option-shift-Tab"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent rawMacOptionKeyPressed ])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand activatePreviousWindow ]
				ifFalse: [ aKeyboardEvent hand activateNextWindow ].
			^ true ].
	"Alternative for non-Mac OS-X: alt-< and alt->"
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $< ]) ifTrue: [
		aKeyboardEvent hand activatePreviousWindow.
		^true ].
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $> ]) ifTrue: [
		aKeyboardEvent hand activateNextWindow.
		^true ].
	^false! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 12/21/2018 09:28:14' prior: 50374894!
 generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time localMillisecondClock ].
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [
		(keyValue = 9 and: [(modifiers anyMask: 1) and: [Smalltalk platformName = 'unix']])
			ifTrue: [
				"Linux VMs don't generate shift-tab keystroke. Turn #keyUp into #keystroke"
				pressType _ EventSensor eventKeyChar ]
			ifFalse: [type _ #keyUp ]].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [
			"Control key pressed"
			keyValue < 27 ifTrue: [
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [
					"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [
						"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96
								"shift not pressed: conver to lowercase letter" ]]]].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]]].
	buttons _ modifiers bitShift: 3.
	((modifiers anyMask: 2) and: [
		keyValue
			between: (Preferences ctrlArrowsScrollHorizontally ifTrue: [28] ifFalse: [30])
			and: 31])
		ifTrue: [ "We're hijacking ctl-up/down arrow since that is what the VM sends us for scroll events.  We're going to convert these to MouseScrollEvent and throw away the keyboard event"
			"ThisPrecludes the use of up and down arrows with control, that are standard keystrokes in Windows to control the cursor.
			But as Linux, Mac and Windows VMs generate ctrl-up and ctrl-down for mouse wheel events, we must honor them.
			Some day, it would be good for the VMs to report mouse wheel events differently fom ctrl-up & ctrl-down..."
			"Also do ctrl-left and ctrl-right for horizontal scroll."
			^ MouseScrollEvent new
				setType: #mouseScroll
				position: self morphPosition
				direction:
					(keyValue caseOf: {
						"Implementing as a caseof to allow for easy adding of left/right/other events should they become available"
						[ 30 ] -> [ #up ].
						[ 31 ] -> [ #down ].
						[ 28 ] -> [ #left ].
						[ 29 ] -> [ #right ].
						})
				buttons: buttons
				hand: self
				stamp: stamp ]
		ifFalse: [ ^ KeyboardEvent new
				setType: type
				buttons: buttons
				position: self morphPosition
				keyValue: keyValue
				hand: self
				stamp: stamp ].! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'AY 12/17/2018 16:57:52' prior: 50414914!
            shouldOpenMorph

	| currentPos currentChar |
	
	textMorph editor hasSelection ifTrue: [ ^ false ].
	
	currentPos _ textMorph editor startIndex-1.
	currentPos <= 0 ifTrue: [ ^ false ].
	currentChar _ model actualContents at: currentPos.
	
	^ currentChar = Character space
		ifTrue: [ self shouldOpenMorphWhenNoPrefixAt: currentPos-1 ]
		ifFalse: [ self shouldOpenMorphWhenPrefixAt: currentPos and: currentChar ].! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Editor initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3539-TabShiftTabToIndentOutdent-AngelYan-2018Dec21-15h06m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3526] on 19 December 2018 at 7:42:39 pm'!
!SystemDictionary methodsFor: 'testing' stamp: 'HAW 12/19/2018 16:09:00'!
   isLiveTypeInformationInstalled
	
	^(FeatureRequirement name: #LiveTypeInformation) isAlreadySatisfied! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/19/2018 19:41:54'!
returnTypeOfEnclosedExpressionAt: aRange 
	
	Smalltalk isLiveTypeInformationInstalled ifFalse: [ ^nil ].
	
	^self 
		withParserSourceMethodNodeDo: [ :methodNode | self returnTypeOfEnclosedExpresionIn: methodNode at: aRange end ]
		ifError: [ :anError | nil ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/19/2018 16:43:55'!
   returnTypeOfUnaryMessage: aSelector at: aRange 
	
	Smalltalk isLiveTypeInformationInstalled ifFalse: [ ^nil ].
	
	^self 
		withParserSourceMethodNodeDo: [ :methodNode | self returnTypeOfNodeUnderCursorIn: methodNode at: aRange end]
		ifError: [ :anError | nil ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/19/2018 16:18:52'!
withParserSourceMethodNodeDo: doBlock ifError: anErrorBlock

	^ [[ doBlock value: (parser classOrMetaClass methodNodeFor: parser source) ] 
		on: UndeclaredVariableReference 
		do: [  :anUndeclareVariableReference | anUndeclareVariableReference declareTempAndResume ]]
		on: Error
		do: anErrorBlock
		
	! !
!UndeclaredVariableReference methodsFor: 'handling' stamp: 'HAW 12/19/2018 19:34:38'!
                      declareTempAndResume

	parser declareTemp: varName at: #method.
	self resume: varName! !
!UndeclaredVariableReference methodsFor: 'handling' stamp: 'HAW 12/19/2018 19:34:42' prior: 16939960!
 defaultAction

	^parser correctVariable: varName interval: (varStart to: varEnd)! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 12/18/2018 19:03:40' prior: 50419497!
                    parseNodeIncluding: aPosition ifAbsent: aBlockClosure

	| smallestRangeSize nodeWithRangeAtPosition |

	smallestRangeSize := SmallInteger maxVal.
	nodeWithRangeAtPosition := nil.

	sourceRanges associationsDo: [ :nodeAtRange |
		self withRangesOf: nodeAtRange including: aPosition do: [ :aRange | | currentNodeRangeSize |
				currentNodeRangeSize := aRange size.
				currentNodeRangeSize < smallestRangeSize ifTrue: [
					smallestRangeSize := currentNodeRangeSize.
					nodeWithRangeAtPosition := nodeAtRange key -> aRange ]]].

	^ nodeWithRangeAtPosition ifNil: aBlockClosure ifNotNil: [ nodeWithRangeAtPosition ]
			! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 12/18/2018 19:04:26' prior: 50419532!
                      parseNodeIncluding: aPosition ifAbsent: aBlockClosure 
	
	^encoder parseNodeIncluding: aPosition ifAbsent: aBlockClosure 
! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 12/18/2018 18:41:14' prior: 50417233!
shouldOpenMorphWhenNoPrefixFor: currentChar 
	
	^currentChar isAlphaNumeric 
		or: [ currentChar isRightBracket
		or: [ currentChar = $) ]]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/19/2018 19:41:54' prior: 50417273!
          computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClassOrEntries |

	id _ allSource copyFrom: range start to: range end.
	receiverClassOrEntries _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ specificModel classOfInstVarNamed: id ].
			[ #methodArg ] 		-> [ specificModel classOfTempVarNamed: id ].
			[ #tempVar ] 			-> [ specificModel classOfTempVarNamed: id ].
			[ #workspaceVar ]		-> [ specificModel classOfWorkspaceVarNamed: id ].
			[ #blockArg ]			-> [ specificModel classOfBlockArgNamed: id ].
			[ #blockTempVar ]		-> [ specificModel classOfBlockTempVarNamed: id ].
			[ #thisContext ] 		-> [ specificModel classOfThisContext ]. 
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #blockEnd ]			-> [ BlockClosure ].
			[ #unary ]				-> [ self returnTypeOfUnaryMessage: id at: range ].
			[ #rightParenthesis ]  -> [ self returnTypeOfEnclosedExpressionAt: range ]. }
		otherwise: [ nil ].
	
	receiverClassOrEntries isCollection 
		ifTrue: [ 
			receiverClassOrEntries isEmpty
				ifTrue: [ self computeMessageEntries: nil ]
				ifFalse: [ entries _ receiverClassOrEntries asArray sort ]]
		ifFalse: [ self computeMessageEntries: receiverClassOrEntries ]! !
!SHParserST80 methodsFor: 'accessing' stamp: 'HAW 12/19/2018 16:10:09'!
        classOrMetaClass
	
	^classOrMetaClass! !

MethodNode removeSelector: #topParseNodeIncluding:ifAbsent:!

Encoder removeSelector: #topParseNodeIncluding:ifAbsent:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3540-AutoCompleteImprovements-HernanWilkinson-2018Dec18-18h31m-HAW.4.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3526] on 20 December 2018 at 9:43:37 am'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 09:41:03'!
                       computeMessageEntriesForSelectors: selectors

	selectors isEmpty
		ifTrue: [ self computeMessageEntries: nil ]
		ifFalse: [ | prefixedSelectors |
			prefixedSelectors := selectors select: [ :aSelector | aSelector beginsWith: prefix ].
			entries _ prefixedSelectors asArray sort ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 09:38:26' prior: 50424025!
                             computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClassOrEntries |

	id _ allSource copyFrom: range start to: range end.
	receiverClassOrEntries _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ specificModel classOfInstVarNamed: id ].
			[ #methodArg ] 		-> [ specificModel classOfTempVarNamed: id ].
			[ #tempVar ] 			-> [ specificModel classOfTempVarNamed: id ].
			[ #workspaceVar ]		-> [ specificModel classOfWorkspaceVarNamed: id ].
			[ #blockArg ]			-> [ specificModel classOfBlockArgNamed: id ].
			[ #blockTempVar ]		-> [ specificModel classOfBlockTempVarNamed: id ].
			[ #thisContext ] 		-> [ specificModel classOfThisContext ]. 
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #blockEnd ]			-> [ BlockClosure ].
			[ #unary ]				-> [ self returnTypeOfUnaryMessage: id at: range ].
			[ #rightParenthesis ]  -> [ self returnTypeOfEnclosedExpressionAt: range ]. }
		otherwise: [ nil ].
	
	receiverClassOrEntries isCollection 
		ifTrue: [ self computeMessageEntriesForSelectors: receiverClassOrEntries ]
		ifFalse: [ self computeMessageEntries: receiverClassOrEntries ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3541-AutoCompleterSmallEnh-HernanWilkinson-2018Dec19-19h45m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3526] on 20 December 2018 at 3:12:35 pm'!

AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser '
	classVariableNames: 'AccessLock Selectors EntriesLimit '
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #SmalltalkCompleter category: #'Tools-Autocompletion'!
AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!
!Object methodsFor: 'private' stamp: 'HAW 12/20/2018 14:18:53'!
          errorDescriptionForSubcriptBounds: index

	^'subscript is out of bounds: ' , index printString! !
!SequenceableCollection methodsFor: 'assertions' stamp: 'HAW 12/20/2018 14:40:40'!
           assertIsInBounds: anIndex

	(self isInBounds: anIndex) ifFalse: [ self errorSubscriptBounds: anIndex ]
	! !
!ArrayedCollection methodsFor: 'inserting' stamp: 'HAW 12/20/2018 14:54:55'!
       insert: anObject shiftingRightAt: anInsertionIndex

	"Inserts anObject at anInsertionIndex, moving right object between anInsertionIndex and self size, 
	loosing last object. Example: 
	#(0 1 3 4 5) insert: 2 shiftingRightAt: 3
	returns:  #(0 1 2 3 4) 
	" 
	| currentIndex |
	
	self assertIsInBounds: anInsertionIndex.
	currentIndex _ self size .
	
	[currentIndex > anInsertionIndex] whileTrue: [
		self at: currentIndex put: (self at: currentIndex-1).
		currentIndex _ currentIndex - 1].
	
	self at: anInsertionIndex put: anObject
! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 14:43:28'!
                 add: selector and: lastUsedTime to: selectorsToShow

	^ selectorsToShow size < EntriesLimit
		ifTrue: [ self add: selector and: lastUsedTime whenNotFullTo: selectorsToShow ]
		ifFalse: [ self add: selector and: lastUsedTime whenFullTo: selectorsToShow ]	! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 14:44:54'!
       add: selector and: lastUsedTime whenFullTo: selectorsToShow

	selectorsToShow
		findBinaryIndex: [ :selectorAndTime | selectorAndTime second < lastUsedTime ifTrue: [ -1 ] ifFalse: [ 1 ]]
		do: [ :found | ]
		ifNone: [ :leftBound :rightBound | self insert: selector and: lastUsedTime at: rightBound to: selectorsToShow ].
		
	^selectorsToShow 
! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 14:49:34'!
              add: selector and: lastUsedTime whenNotFullTo: selectorsToShow
			
	selectorsToShow add: { selector . lastUsedTime }.
	
	^selectorsToShow size = EntriesLimit 
		ifTrue: [ self sortByLastUsedTime: selectorsToShow ]
		ifFalse: [ selectorsToShow ]
	! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 14:45:44'!
               insert: selector and: lastUsedTime at: insertionIndex to: selectorsToShow

	insertionIndex <= EntriesLimit ifTrue: [ selectorsToShow insert: { selector . lastUsedTime } shiftingRightAt: insertionIndex ].
	
	^selectorsToShow ! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 14:44:13'!
     sortByLastUsedTime: selectorsToShow

	^selectorsToShow asArray sort: [ :leftSelectorAndTime :rightSelectorAndTime | leftSelectorAndTime second > rightSelectorAndTime second ]! !
!Object methodsFor: 'private' stamp: 'HAW 12/20/2018 14:17:22' prior: 16882709!
                              errorSubscriptBounds: index 
	"Create an error notification that an improper integer was used as an index."

	self error: (self errorDescriptionForSubcriptBounds: index)! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 12/20/2018 14:19:58'!
               should: aBlockToFail raise: anExceptionHandlingCondition withMessageText: anExpectedErrorMessageCreator

	self 
		should: aBlockToFail 
		raise: anExceptionHandlingCondition 
		withExceptionDo: [ :anException | self assert: anExpectedErrorMessageCreator value equals: anException messageText ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 14:47:00' prior: 16909310!
                computeMessageEntries: receiverClass

	| selectorsToShow notUnderstoodSelectors |
	
	selectorsToShow _ OrderedCollection new.
	notUnderstoodSelectors _ OrderedCollection new.
	
	self class protected: [
		Selectors forPrefix: prefix keysAndValuesDo: [ :selector :lastUsedTime |
			(receiverClass isNil or: [ receiverClass canUnderstand: selector ]) 
				ifTrue: [ selectorsToShow := self add: selector and: lastUsedTime to: selectorsToShow ]
				ifFalse: [ notUnderstoodSelectors := self add: selector and: lastUsedTime to: notUnderstoodSelectors ]]].
				
	selectorsToShow isEmpty ifTrue: [ selectorsToShow _ notUnderstoodSelectors ]. 
	selectorsToShow size < EntriesLimit ifTrue: [ selectorsToShow _  self sortByLastUsedTime: selectorsToShow ].
	
	" To see the timestamps in the menu (need to tweak #insertCompletion: to activate. Right now, just for debugging)
	entries _ selectorsToShow collect: [ :ary | ary first, '(', ((DateAndTime fromString: '01/01/1996 00:00') + ary second minutes) printString,')' ]
	"
	entries _ selectorsToShow collect: [ :selectorAndTime | selectorAndTime first ]
	
! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/20/2018 11:32:31' prior: 50424116!
             computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClassOrEntries |

	id _ allSource copyFrom: range start to: range end.
	receiverClassOrEntries _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ specificModel classOfInstVarNamed: id ].
			[ #methodArg ] 		-> [ specificModel classOfTempVarNamed: id ].
			[ #tempVar ] 			-> [ specificModel classOfTempVarNamed: id ].
			[ #workspaceVar ]		-> [ specificModel classOfWorkspaceVarNamed: id ].
			[ #blockArg ]			-> [ specificModel classOfBlockArgNamed: id ].
			[ #blockTempVar ]		-> [ specificModel classOfBlockTempVarNamed: id ].
			[ #thisContext ] 		-> [ specificModel classOfThisContext ]. 
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #blockEnd ]			-> [ BlockClosure ].
			[ #arrayEnd ]			-> [ Array ].
			[ #rightBrace ]		-> [ Array ].
			[ #unary ]				-> [ self returnTypeOfUnaryMessage: id at: range ].
			[ #rightParenthesis ]  -> [ self returnTypeOfEnclosedExpressionAt: range ]. }
		otherwise: [ nil ].
	
	receiverClassOrEntries isCollection 
		ifTrue: [ self computeMessageEntriesForSelectors: receiverClassOrEntries ]
		ifFalse: [ self computeMessageEntries: receiverClassOrEntries ]! !
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'HAW 12/20/2018 11:51:22' prior: 50420127!
                initialize
	"
	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...
	[ SmalltalkCompleter initialize ]timeToRun
	Selectors inspect
	"
	| maxSortValue allImplemented |
	
	EntriesLimit _ 400.
	
	SystemChangeNotifier uniqueInstance
		removeActionsWithReceiver: self.	 "avoid double registration"

	SystemChangeNotifier uniqueInstance
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #methodAdded send: #methodAdded:selector:inClass:requestor: to: self;
		when: #methodAddedInProtocol send: #methodAdded:selector:inProtocol:class:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self.
	
	self protected: [
		allImplemented _ Smalltalk allImplementedMessages.
		Selectors _ Trie new.
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				Selectors at: sel ifAbsentPut: [ 0 ].
				method messages do: [ :sentMsg |
					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				self addSelector: sel method: method allImplemented: allImplemented]].
		""
	
		"The following might not be found in #messages. Give them maximum priority."
		maxSortValue _ SmallInteger maxVal.
		"From MessageNode>>#initialize"
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |
				Selectors at: sel put: maxSortValue ].
	
		maxSortValue _ SmallInteger maxVal-1.
		"From SystemDictionary >>#recreateSpecialObjectsArray"
		(1 to: Smalltalk specialSelectorSize) do:  [ :i |
				Selectors at: (Smalltalk specialSelectorAt: i) put: maxSortValue ]]! !

AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #SmalltalkCompleter category: #'Tools-Autocompletion'!
AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

SmalltalkCompleter initialize!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3542-AutoCompleterEnhancements-HernanWilkinson-2018Dec20-09h43m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3542] on 21 December 2018 at 5:34:41 pm'!
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 12/21/2018 17:33:20' prior: 50422677!
           addSelector: aSymbol method: aCompiledMethod allImplemented: implemented

	| sentValue value |
	self protected: [
		value _ (ChangeSet notInstallOrTestRun or: [Smalltalk platformName ~= 'Win32'])
			ifTrue: [
				"Expensive and not worth doing in Windows with antivirus active, when installing large packages"
				aCompiledMethod dateSortingValue ]
			ifFalse: [ 0 ].
		Selectors at: aSymbol put: (value  max: (Selectors at: aSymbol ifAbsent: [0])).
		aCompiledMethod messages do: [ :sentMsg |
			((Selectors includesKey: sentMsg) or: [ 
				implemented
					ifNotNil: [ implemented includes: sentMsg ]
					ifNil: [ Smalltalk isThereAnImplementorOf: sentMsg ]])
						ifTrue: [
							sentValue _ value max: (Selectors at: sentMsg ifAbsent: [0]).
							Selectors at: sentMsg put: sentValue ]]]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3543-IgnorePackageMethodDateForAutocompleteOnlyOnWindows-JuanVuletich-2018Dec21-17h30m-jmv.1.cs.st----!

----SNAPSHOT----#(21 December 2018 5:46:03.733937 pm) Cuis5.0-3543-v3.image priorSource: 2863823!

----QUIT----#(21 December 2018 5:46:13.041218 pm) Cuis5.0-3543-v3.image priorSource: 2971944!

----STARTUP----#(1 January 2019 8:25:31.451567 pm) as /home/juan/Cuis/Cuis-Smalltalk-Dev/Cuis5.0-3543-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3543] on 23 December 2018 at 11:25:59 am'!
!Behavior methodsFor: 'methods' stamp: 'KLG 12/23/2018 11:18:27' prior: 50419485!
                  methodNodeFor: aSourceCode noPattern: aBoolean

	|  parser methodNode |

	parser := self parserClass new.

	methodNode := parser parse: aSourceCode class: self noPattern: aBoolean.
	methodNode sourceText: aSourceCode.

	^methodNode
			! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3544-DontHardCodeEncoderClass-KLG-2018Dec23-11h18m-KLG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3544] on 24 December 2018 at 12:15:36 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/24/2018 12:15:14' prior: 50423417!
             knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3545-AddGeraldKlixAsKnownAuthor-JuanVuletich-2018Dec24-12h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3531] on 24 December 2018 at 10:41:52 am'!

Object subclass: #DropFilesAction
	instanceVariableNames: 'shouldAskForCancel dropFilesEvent cancelBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

!classDefinition: #DropFilesAction category: #'Morphic-Worlds'!
Object subclass: #DropFilesAction
	instanceVariableNames: 'shouldAskForCancel dropFilesEvent cancelBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

MorphicEvent subclass: #DropFilesEvent
	instanceVariableNames: 'position wasHandled numberOfFiles'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #DropFilesEvent category: #'Morphic-Events'!
MorphicEvent subclass: #DropFilesEvent
	instanceVariableNames: 'position wasHandled numberOfFiles'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!Morph methodsFor: 'dropping/grabbing' stamp: 'HAW 12/24/2018 07:21:44'!
             dropFiles: aDropFilesEvent

	"I do nothing, subclasses should redefine if they handle this event - Hernan"! !
!Morph methodsFor: 'event handling testing' stamp: 'HAW 12/24/2018 07:13:50'!
    allowsFilesDrop
	"Answer whether we accept dropping files. By default answer false."

	"Use a property test to allow individual instances to specify this."
	^ self hasProperty: #'allowsFilesDrop'! !
!Morph methodsFor: 'events-processing' stamp: 'HAW 12/24/2018 09:28:32'!
                processDropFiles: aDropFilesEvent localPosition: localEventPosition
	"Handle a dropping file."

	aDropFilesEvent wasHandled ifTrue: [ ^self ]. 
	
	aDropFilesEvent wasHandled: true.
	self dropFiles: aDropFilesEvent! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'HAW 12/24/2018 07:13:56'!
                       allowsFilesDrop

	^ true! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'HAW 12/24/2018 10:27:39'!
                    dropFiles: aDropFilesEvent

	(DropFilesAction for: aDropFilesEvent) value! !
!HandMorph methodsFor: 'events-processing' stamp: 'HAW 12/24/2018 09:25:29'!
      startDropFilesEventDispatch: aDropFilesEvent

	owner dispatchEvent: aDropFilesEvent localPosition: aDropFilesEvent eventPosition.
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'private events' stamp: 'HAW 12/24/2018 09:29:07'!
                         generateDropFilesEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| position stamp numberOfFiles dragType |
	
	stamp := evtBuf second.
	stamp = 0 ifTrue: [stamp := Time localMillisecondClock].
	dragType := evtBuf third.
	position := evtBuf fourth @ evtBuf fifth.
	numberOfFiles := evtBuf seventh.
	
	^ dragType = 4 ifTrue: [ DropFilesEvent at: position with: numberOfFiles from: self].
! !
!DropFilesAction methodsFor: 'initialization' stamp: 'HAW 12/24/2018 10:29:45'!
   initializeFor: aDropFilesEvent 

	dropFilesEvent := aDropFilesEvent.
	shouldAskForCancel := aDropFilesEvent numberOfFiles > 1! !
!DropFilesAction methodsFor: 'evaluating' stamp: 'HAW 12/24/2018 10:34:38'!
                   value

	cancelBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/24/2018 10:33:29'!
                    ask: aQueation onYes: aYesBlock 

	| yesSelected |
	
	yesSelected := shouldAskForCancel 
		ifTrue: [ self confirm: aQueation orCancel: cancelBlock ]
		ifFalse: [ self confirm: aQueation ].
		
	^yesSelected ifTrue: aYesBlock ! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/24/2018 10:33:54'!
      canBeFiledIn: aFileName

	^aFileName endsWith: '.st'! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/24/2018 10:33:43'!
                  canBeInstalled: aFileName

	^(aFileName endsWith: '.cs.st') or: [ aFileName endsWith: '.pck.st' ]! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/24/2018 10:36:41'!
     fileNamedDropped: aFileName 

	(self canBeInstalled: aFileName) 
		ifTrue: [ self ifUserWantsInstall: aFileName ]
		ifFalse: [ (self canBeFiledIn: aFileName) 
			ifTrue: [ self ifUserWantsFileIn: aFileName ]
			ifFalse: [ self inform: 'Dropped file ', aFileName, ' not supported' ]]! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/24/2018 10:32:40'!
            ifUserWantsFileIn: aFileName 

	self ask: 'Do you want to file in ', aFileName, ' ?' onYes:  [ ChangeSet fileIn: aFileName asFileEntry ] ! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/24/2018 10:32:12'!
                             ifUserWantsInstall: aFileName 

	self ask: 'Do you want to install ', aFileName, ' ?' onYes: [ ChangeSet install: aFileName asFileEntry ]
		! !
!DropFilesAction class methodsFor: 'instance creation' stamp: 'HAW 12/24/2018 10:29:14'!
                       for: aDropFilesEvent

	^self new initializeFor: aDropFilesEvent 
	! !
!DropFilesEvent methodsFor: 'initialization' stamp: 'HAW 12/24/2018 09:32:07'!
           initializeAt: aPosition with: aNumberOfFiles from: aHand

	position := aPosition.
	numberOfFiles := aNumberOfFiles.
	source := aHand.
	wasHandled := false.! !
!DropFilesEvent methodsFor: 'testing' stamp: 'HAW 12/24/2018 09:27:00'!
                         isDropEvent

	^true! !
!DropFilesEvent methodsFor: 'testing' stamp: 'HAW 12/24/2018 09:27:13'!
 wasHandled

	^wasHandled! !
!DropFilesEvent methodsFor: 'testing' stamp: 'HAW 12/24/2018 09:27:26'!
                            wasHandled: aBool

	"This is ugly, and means that events are copied in many places..."
	self flag: #jmvVer.

	wasHandled _ aBool! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'HAW 12/24/2018 09:24:16'!
                dispatchWith: aMorph localPosition: positionInAMorph
	"Drop is done on the innermost target that accepts it."

	| eventPositionInChild |

	"Try to get out quickly"
	(aMorph fullContainsPoint: positionInAMorph) ifFalse: [ ^#rejected ].

	"Go looking if any of our submorphs wants it"
	aMorph submorphsDo: [ :eachChild |
		eventPositionInChild _ eachChild internalize: positionInAMorph.
		(eachChild dispatchEvent: self localPosition: eventPositionInChild) == #rejected ifFalse: [ ^self ]].

	(aMorph allowsFilesDrop and: [ aMorph containsPoint: positionInAMorph event: self ])
		ifTrue: [^ self sentTo: aMorph localPosition: positionInAMorph ].
	
	^#rejected! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'HAW 12/24/2018 07:20:35'!
                               sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into aMorph"

	^aMorph processDropFiles: self localPosition: positionInAMorph! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'HAW 12/24/2018 07:53:42'!
                            startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startDropFilesEventDispatch: self! !
!DropFilesEvent methodsFor: 'position' stamp: 'HAW 12/24/2018 09:30:41'!
           eventPosition

	^position! !
!DropFilesEvent methodsFor: 'primitives' stamp: 'HAW 12/24/2018 09:39:09'!
                        primDropRequestFileHandle: dropIndex
	"Primitive. Return the (read-only) file handle for some file that was just dropped onto Squeak.
	Fail if dropIndex is out of range or the primitive is not supported."
	<primitive: 'primitiveDropRequestFileHandle' module:'DropPlugin'>
	^nil! !
!DropFilesEvent methodsFor: 'primitives' stamp: 'HAW 12/24/2018 09:38:59'!
                            primDropRequestFileName: dropIndex
	"Primitive. Return the file name for some file that was just dropped onto Squeak.
	Fail if dropIndex is out of range or the primitive is not supported."
	<primitive: 'primitiveDropRequestFileName' module:'DropPlugin'>
	^nil! !
!DropFilesEvent methodsFor: 'files' stamp: 'HAW 12/24/2018 09:38:25'!
                   fileNamesDo: aBlock

	1 to: numberOfFiles do: [ :fileNumber | | fileName |
		fileName := self primDropRequestFileName: fileNumber.
		fileName ifNotNil: aBlock ]! !
!DropFilesEvent methodsFor: 'files' stamp: 'HAW 12/24/2018 10:34:28'!
                      numberOfFiles

	^numberOfFiles! !
!DropFilesEvent class methodsFor: 'instance creation' stamp: 'HAW 12/24/2018 09:32:07'!
      at: aPosition with: aNumberOfFiles from: aHand

	^self new initializeAt: aPosition with: aNumberOfFiles from: aHand

! !
!StandardFileStream class methodsFor: 'error handling' stamp: 'HAW 12/24/2018 09:50:28' prior: 16913802!
                              readOnlyFileDoesNotExistUserHandling: fullFileName

	| dir files choices selection newName fileName |
	dir _ fullFileName asFileEntry parent.
	files _ dir fileNames.
	fileName _ fullFileName asFileEntry name.
	choices _ fileName correctAgainst: files.
	choices add: 'Choose another name'.
	choices add: 'Cancel'.
	selection _ (PopUpMenu labelArray: choices lines: (Array with: 5) )
		startUpWithCaption: fullFileName asFileEntry name, '
does not exist.'.
	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].
	selection < (choices size - 1) ifTrue: [
		newName _ (dir pathName , '/', (choices at: selection))].
	selection = (choices size - 1) ifTrue: [
		newName _ FillInTheBlankMorph 
							request: 'Enter a new file name' 
							initialAnswer: fileName.
		"If Cancel was pressed, no file should be opened - Hernan"
		newName isEmpty ifTrue: [ ^nil ]].
	newName = '' ifFalse: [^ FileIOAccessor default privateReadOnlyFile: newName asFileEntry ].
	^ self error: 'Could not open a file'! !
!HandMorph methodsFor: 'event handling' stamp: 'HAW 12/24/2018 09:29:37' prior: 16851755!
                               processEventQueue
	"Process user input events from the local input devices."

	| evt evtBuf type hadAny mcs |
	mcs _ mouseClickState.
	hadAny := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		evt := nil.	"for unknown event types"
		type := evtBuf first.
		type = EventSensor eventTypeMouse
			ifTrue: [ evt _ self generateMouseEvent: evtBuf ] ifFalse: [
		type = EventSensor eventTypeKeyboard 
			ifTrue: [ evt _ self generateKeyboardEvent: evtBuf ] ifFalse: [
		type = EventSensor eventTypeWindow
			ifTrue: [ evt _ self generateWindowEvent: evtBuf ] ifFalse: [
		type = EventSensor eventTypeDragDropFiles
			ifTrue: [evt _ self generateDropFilesEvent: evtBuf]]]].
		"All other events are ignored"
		evt
			ifNil: [ 
				"I have to consume all eventTypeDragDropFiles of type 2 quicky, that is why
				I check if it was an eventTypeDragDropFiles to continue in the loop - Hernan"
				type ~= EventSensor eventTypeDragDropFiles ifTrue: [^hadAny]]
			ifNotNil: [
				"Finally, handle it"
				self startEventDispatch: evt.
				hadAny := true.
				"For better user feedback, return immediately after a mouse event has been processed."
				evt isMouse ifTrue: [ ^hadAny ]]].
	"note: if we come here we didn't have any mouse events"
	mcs 
		ifNotNil: [ 
			"No mouse events during this cycle. Make sure click states time out accordingly"
			mcs
				handleEvent: (self lastMouseEvent asMouseMove: (Time localMillisecondClock - self lastMouseEventTime max: 0))
				from: self ].
	^hadAny! !
!ChangeSet class methodsFor: 'services' stamp: 'HAW 12/24/2018 09:44:22' prior: 16799274!
           fileIn: aFileEntry
	"File in the entire contents of the file specified by the name provided"

	aFileEntry ifNil: [^ Smalltalk beep ].
	aFileEntry readStreamDo: [ :stream |
		stream ifNotNil: [ stream fileIn ]]! !

DropFilesEvent removeSelector: #inittializeAt:with:from:!

DropFilesEvent removeSelector: #sentTo:!

DropFilesEvent removeSelector: #type!

StandardFileStream removeSelector: #primDropRequestFileHandle:!

StandardFileStream removeSelector: #primDropRequestFileHandle:!

StandardFileStream removeSelector: #primDropRequestFileName:!

StandardFileStream removeSelector: #primDropRequestFileName:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3546-DropFileSupport-HernanWilkinson-2018Dec20-15h12m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3546] on 27 December 2018 at 5:58:46 pm'!
!Float class methodsFor: 'constants' stamp: 'jmv 12/26/2018 12:50:56' prior: 50423348!
 emax
	"Answer exponent of the maximal representable finite value"
	
	^1023! !
!Float class methodsFor: 'class initialization' stamp: 'jmv 12/26/2018 13:08:28' prior: 50420583!
                initClassCachedState
	"Float initialize"
	"Constants from Computer Approximations, pp. 182-183:
		Pi = 3.14159265358979323846264338327950288
		Pi/2 = 1.57079632679489661923132169163975144
		Pi*2 = 6.28318530717958647692528676655900576
		Pi/180 = 0.01745329251994329576923690768488612
		2.0 ln = 0.69314718055994530941723212145817657
		2.0 sqrt = 1.41421356237309504880168872420969808"

	Pi _ 3.14159265358979323846264338327950288.
	Halfpi _ Pi / 2.0.
	Twopi _ Pi * 2.0.
	RadiansPerDegree _ Pi / 180.0.

	Ln2 _ 0.69314718055994530941723212145817657.
	Ln10 _ 10.0 ln.
	Sqrt2 _ 1.41421356237309504880168872420969808.
	E _ 2.718281828459045235360287471353.

	MaxVal _ 1.7976931348623157e308.
	MaxValLn _ 709.782712893384.
	MinValLogBase2 _ -1074.

	Infinity _ MaxVal * MaxVal.
	NegativeInfinity _ 0.0 - Infinity.
	NaN _ Infinity - Infinity.
	NegativeZero _ Float fmin negated nextTowardsZero.
! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3547-NicerNegativeZeroInit-JuanVuletich-2018Dec27-17h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3546] on 26 December 2018 at 1:54:58 pm'!
!Float commentStamp: 'jmv 12/26/2018 13:44:13' prior: 50414186!
                         A note About Floating Point numbers and Floating Point Arithmetic.

The following is not specific to Cuis or Smalltalk at all. This is about the properties of Float numbers in any computer implementation.

If you haven't done so already, read https://en.wikipedia.org/wiki/Floating-point_arithmetic

But if you find the Wikipedia article too detailed, or hard to read, then try http://fabiensanglard.net/floating_point_visually_explained/ (get past "How Floating Point are usually explained" and read "A different way to explain...").

Other great reads are:
	"Why don't my numbers add up?":
		http://floating-point-gui.de/
and
	"What Every Computer Scientist Should Know About Floating-Point Arithmetic":
		http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
and also maybe
	"Comparing floating point numbers"
		https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

Now that you read them, and we are on the same boat, some further comments (from jmv):

Floats are (conceptually) approximate real numbers. That's why trig and other trascendental functions always answer Floats. That's why it is ok to round the result of operations. That's why Float is considered more general than Fraction in ST-80 and most Smalltalks. So, when we have a Float value, we must not think about it as a Rational but as a Real (actually as some unknown Real that could hopefully be close to the Rational we can actually represent). Keep this in mind when dealing with Floats, and especially avoid comparing them for equality.

When doing mixed operations with Floats and Fractions, Cuis, as most other Smalltalks, converts all values to Floats. Some other systems, including Pharo Smalltalk, Scheme and Lisp have two rules: when the answer is a Number, they convert to Float. But when the answer is a boolean (#<, #=, #<=, etc.) they convert to Fraction. We think this is a mistake. There should never be implicit conversions from Float to Fraction. Fractions are to hold exact values, and people expect Fractions to be exact. On the other hand, Floats are to hold approximations (and people should be aware of that!!). But an implicit conversion from Float to Fraction would give a Fraction that should not be considered an exact value (the value comes from an inexact Float), but that knowledge is lost, as it is an instance of Fraction.

If you want exact arithmetic, usual mathematical properties (like transitivity of equality), can live in the limited world of Rational numbers, and can afford a slight performance penalty, use Fraction instead. Avoid trascendental functions and never convert to Float.

In any case, most numeric computation is done on Float numbers. There are good reasons for that. One is that in most cases we don't need an exact answer. And in many cases we can't really have it: the inputs to algorithms already have a limited precision, or they use trascendental functions. And even when exact arithmetic possible, if we are doing sound synthesis, 24 bits of resolution is enough. For image processing and graphics, the result is never more than 16 bits per channel. So, these fields don't really need 64 bit Doubles. 32 bit Floats are enough. Other fields do need 64 bit Doubles, like physics simulations and geometry. Games usually prefer special, faster 32 bit Float operations in GPUs that have greater errors but are faster.

There are some things that can be done to increase the confidence you can have on Float results. One is to do an error propagation analysis on the code you are running. This is not easy, but it is done for any widely used numerical method. Then, you can know real bounds and/or estimates of the errors made. So, understanding your inputs and your algorithms (for example error propagation, condition number, numeric stability), and using Float number if appropriate, is the usual advice.

Perhaps you have heard about "interval arithmetic". It is a bit better than simple Float, but doesn't really fix the problems.

The ultimate solution is to do Monte Carlo analysis, with random perturbation of inputs. After the Monte Carlo run, it is needed to do statistical analysis of possible correlations between the distributions of the random noise added to imputs and the result of the algorithm.

Additional food for thought: http://www.cs.berkeley.edu/~wkahan/Mindless.pdf . According to this, doing Monte Carlo as described above attacks a slightly different problem. This might be yet another reason (besides performance) to try something like the next paragraph. I (jmv) came up with it, and I don't really know if it has been described and or tried before or not. Mhhh. Maybe a defensive publication is in order.

A possibility that could be a practical solution, being much cheaper than Monte Carlo, but better than interval arithmetic, is to represent each value by 2 Floats: an estimation of the real value (i.e. an estimation of the mean value of the distribution of the corresponding Monte Carlo result), and an estimation of the error (i.e. an estimation of the standard deviation of the corresponding Monte Carlo result). Or perhaps even 3 of them. In addition to the estimation of the real value and an estimation of the error, we could add a hard bound on the error. In many cases it will be useless, because the error can not really be bound. But in those cases where it is possible to bound it, applications could really know about the quality of computed values.

=======================================================================

My instances represent IEEE 754 floating-point double-precision numbers. They have about 16 decimal digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:
	
	8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12

Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:

	3r20.2 --> 6.66666666666667
	8r20.2 --> 16.25

If you don't have access to the definition of IEEE754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...
	sign		1 bit
	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent
						in the range -1023 .. +1024
				- 16r000:
					significand = 0: Float zero
					significand ~= 0: Denormalized number (exp = -1023 + 1 = -1022, no hidden '1' bit in mantissa)
				- 16r7FF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE 754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.

The single-precision format is...
	sign		1 bit
	exponent	8 bits, with bias of 127, to represent -126 to +127
                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)
                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)
	mantissa	24 bits, but only 23 are stored
This format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.

You might also check https://en.wikipedia.org/wiki/IEEE_754_revision

Other great reads (covering broader but interesting issues):
https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
http://www.ima.umn.edu/2010-2011/W1.10-14.11/activities/Leeser-Miriam/Leeser-GPU-IMA-Jan2011.pdf!
!Float methodsFor: 'testing' stamp: 'jmv 12/26/2018 13:43:52' prior: 16845106!
               sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.
	Handle IEEE754 negative-zero by reporting a sign of -1
	Warning!! This makes Float negativeZero the only number in the system such that
		x sign negated = x negated sign
	evaluates to false!!
	This precludes the simpler implementation in #signPart
	0.0 sign  ->  0
	0.0 signPart   ->  1
	Float negativeZero sign   ->  -1
	Float negativeZero signPart   ->  -1
	"

	self > 0 ifTrue: [^ 1].
	(self < 0 or: [((self at: 1) bitShift: -31) = 1]) ifTrue: [^ -1].
	^ 0! !
!Float class methodsFor: 'instance creation' stamp: 'jmv 12/26/2018 13:54:36' prior: 50421714!
   signPart: signPart mantissaPart: mantissaPart exponentPart: exponentPart
	"
	Float signPart: Float pi signPart mantissaPart: Float pi mantissaPart exponentPart: Float pi exponentPart
	"
	^ mantissaPart asFloat * signPart timesTwoPower: exponentPart-52! !
!Float class methodsFor: 'constants' stamp: 'jmv 12/26/2018 13:44:22' prior: 50421412!
          precision
	"Answer the apparent precision of the floating point representation.
	That is the maximum number of radix-based digits (bits if radix=2) representable in floating point without rounding error.
	Technically, 52 bits are stored in the representation, and normalized numbers have an implied leading 1 that is not stored.
	Note that denormalized floating point numbers don't have the implied leading 1, and thus gradually lose precision.
	This format implements the IEEE 754 binary64 format."
	
	^53! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3548-FloatCosmetics-JuanVuletich-2018Dec26-13h28m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3546] on 26 December 2018 at 2:34:46 pm'!
!Float methodsFor: 'converting' stamp: 'jmv 12/26/2018 14:05:07' prior: 50414433!
             asTrueFraction
	" Answer a fraction that EXACTLY represents self,
	  a double precision IEEE floating point number.
	  By David N. Smith with significant performance
	  improvements by Luciano Esteban Notarfrancesco.
	  (Version of 11April97).
	Refactoring and simplification by jmv"
	
	^self
		partValues: [ :sign :exponent :mantissa | | zeroBitsCount |
			" Prepare result. If exponent is greater than mantissa size, result is an integer"
			(exponent >= 52 or: [
					zeroBitsCount _ mantissa lowBit - 1.
					exponent + zeroBitsCount >= 52 ])
				ifTrue: [
					"result is an integer number"
					 sign * mantissa bitShift: exponent - 52 ]
				ifFalse: [
					" This is the 'obvious' way. Better do Luciano's trick below:"
					"result := Fraction
						numerator: sign * mantissa
						denominator: (1 bitShift: 52 - exponent)."
					" Form the result. When exp>52, the exponent is adjusted by
					  the number of trailing zero bits in the mantissa to minimize
					  the (huge) time that could be spent in #gcd:. "
					Fraction
						numerator: (sign * (mantissa bitShift: 0 - zeroBitsCount))
						denominator: (1 bitShift: 52 - exponent - zeroBitsCount) ]
		]
		ifInfinite: [ self error: 'Cannot represent infinity as a fraction' ]
		ifNaN: [ self error: 'Cannot represent Not-a-Number as a fraction' ].! !
!Float methodsFor: 'converting' stamp: 'jmv 12/26/2018 14:33:41' prior: 50423261!
         partBits: aThreeArgumentBlock
	"
	Extract the bits for Sign, Mantissa and Exponent parts of the floating point representation.
	Just extract the bits. Do not add implicit bit. Do not correct denormals. Do not subtract exponent bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	| signBit exponentBits mantissaBits leastSignificativeWord mostSignificativeWord |

	mostSignificativeWord _ self basicAt: 1.
	leastSignificativeWord _ self basicAt: 2.
	signBit _ mostSignificativeWord bitShift: -31 .
	exponentBits _ (mostSignificativeWord bitShift: -20 ) bitAnd: 16r7FF.
	mantissaBits _ ((mostSignificativeWord bitAnd: 16r000FFFFF) bitShift: 32) + leastSignificativeWord.

	"Evaluate the block"
	^aThreeArgumentBlock value: signBit value: exponentBits value: mantissaBits! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/26/2018 14:32:49' prior: 50423294!
 exponentBits
	"
	Actual bits for the exponent part of the floating point representation.
	Just extract the bits. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f exponentBits. f exponentPart. f exponent } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | exponentBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/26/2018 14:33:27' prior: 50414477!
                        exponentPart
	"
	Exponent part of the floating point representation.
	Valid for any floating point number (except zeros, infinities and NaNs).
	Includes correction of stored exponent bits for denormals (where it acts as a label, not a real exponent).
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/26/2018 14:34:33' prior: 50423311!
 mantissaBits
	"
	Actual bits for the mantissa part of the floating point representation.
	Just extract the bits. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{ f. f mantissaBits. f mantissaPart. f significand. } print ].
	"
	^ self partBits: [ :signBit :exponentBits :mantissaBits | mantissaBits ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/26/2018 14:28:48' prior: 50421318!
                     mantissaPart
	"Equivalent to #significandAsInteger."
	"The actual bits in the mantissa of the receiver, as an integer, including the implicit leading 1 if appropriate.
	Does not include the sign.
	See #exponentPart and #signPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f mantissaPart * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | mantissa ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/26/2018 14:34:07' prior: 50423328!
                               signBit
	"
	Actual bits for the exponent part of the floating point representation.
	Just extract the bits. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0. 0.0. -0.0} do: [ :f |
		{ f. f signBit. f signPart. f sign } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | signBit ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3549-FloatCosmetics-JuanVuletich-2018Dec26-13h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3546] on 26 December 2018 at 2:41:21 pm'!
!Float methodsFor: 'converting' stamp: 'jmv 12/26/2018 14:41:18' prior: 50421818!
               partValues: aThreeArgumentBlock ifInfinite: infinityBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"
	| sign exponent mantissa |

	^ self partBits: [ :signBit :exponentBits :mantissaBits |

		"Extract the sign"
		sign _ signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infinityBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent _ exponentBits - 16r3FF.
	
		exponentBits ~= 0
			ifTrue: [
				"Add back implicit leading 1 in fraction."
				mantissa _ 16r0010000000000000 bitOr: mantissaBits ]
			ifFalse: [
				"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa."
				mantissa _ mantissaBits.
				exponent _ exponent + 1 ].

		"Evaluate the block"
		aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3550-FloatCosmetics-JuanVuletich-2018Dec26-14h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3550] on 27 December 2018 at 6:03:32 pm'!
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/26/2018 14:59:25' prior: 50425634!
               signBit
	"
	Actual sigh bit part of the floating point representation.
	Just extract the bit. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0. 0.0. -0.0} do: [ :f |
		{ f. f signBit. f signPart. f sign } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | signBit ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/26/2018 15:00:07' prior: 50421348!
                  significandAsInteger
	"The actual bits in the mantissa of the receiver, as an integer, including the implicit leading 1 if appropriate.
	See #mantissaPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self mantissaPart! !
!Float methodsFor: 'printing' stamp: 'jmv 12/26/2018 14:57:20' prior: 50423053!
                         printOn: aStream fractionDigits: placesDesired
	"This implementation avoids rounding errors doue to #rounded or #roundTo:
	Round to a suitable integer and insert the decimal point in the appropriately between the digits."

	| i s scaled |
	self isFinite ifFalse: [ ^self printOn: aStream ].

	placesDesired > 0 ifFalse: [
		^self rounded printOn: aStream ].

	scaled _ self * (10 raisedTo: placesDesired).
	"If rounding could possibly print a sequence that is read back as a different float, then go the more expensive Fraction way.
	If the following line is commented, #testPrintShowingDecimalPlaces4 will fail!!"
	scaled ulp > 1 ifTrue: [
		^ self asTrueFraction printOn: aStream fractionDigits: placesDesired ].
	i _ scaled rounded.
	i negative ifTrue: [
		aStream nextPut: $-.
		i _ i negated ].
	s _ i printString.
	placesDesired + 1 > s size
		ifTrue: [
			aStream nextPutAll: '0.'.
			placesDesired - s size timesRepeat: [ aStream nextPut: $0 ].
			aStream nextPutAll: s ]
		ifFalse: [
			aStream
				nextPutAll: (s copyFrom: 1 to: s size-placesDesired);
				nextPut: $.;
				nextPutAll: (s copyFrom: s size-placesDesired+1 to: s size) ]! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3551-FloatCosmetics-JuanVuletich-2018Dec27-18h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3550] on 27 December 2018 at 6:26:26 pm'!
!SequenceableCollection methodsFor: 'comparing' stamp: 'jmv 12/27/2018 18:20:09' prior: 16906017!
                               hasEqualElements: otherCollection
	"Answer whether the receiver's size is the same as otherCollection's
	size, and each of the receiver's elements equal the corresponding 
	element of otherCollection.
	This should probably replace the current definition of #= ."

	| size |
	otherCollection isSequenceable ifFalse: [^ false].
	(size _ self size) = otherCollection size ifFalse: [^ false].
	1 to: size do:
		[:index |
		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].
	^ true! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 12/26/2018 15:47:12' prior: 16906652!
          polynomialEval: thisX
	"Treat myself as the coefficients of a polynomial in X.  Evaluate it with thisX.  First element is the constant and last is the coefficient for the highest power.
	https://en.wikipedia.org/wiki/Horner's_method"
	"  #(1 2 3) polynomialEval: 2   "   "is 3*X^2 + 2*X + 1 with X = 2"

	| index sum |
	sum := self at: (index := self size).
	[ (index := index - 1) >= 1 ] whileTrue: [
		sum := sum * thisX + (self at: index) ].
	^sum! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 12/27/2018 18:25:18' prior: 50419999!
                           colorFrom: parm
	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"

	| aColor firstParm |
	(parm is: #Color) ifTrue: [ ^ parm ].
	parm isSymbol ifTrue: [ ^ self perform: parm ].
	parm isString ifTrue: [ ^ self fromHexString: parm ].
	(parm isCollection and: [ parm isSequenceable and: [ parm size > 0 ]])
		ifTrue: [
			firstParm _ parm first.
			firstParm isNumber ifTrue: [
				^ self fromRgbTriplet: parm].
			aColor _ self colorFrom: firstParm.
			parm withIndexDo: [ :sym :ind |
				ind > 1 ifTrue: [
					aColor _ aColor perform: sym ]].
			^ aColor].
	^ parm

"
Color colorFrom: #(blue darker)
Color colorFrom: Color blue darker
Color colorFrom: #blue
Color colorFrom: #(0.0 0.0 1.0)
Color colorFrom: '#D7B360'
"! !
!ParseNode methodsFor: 'printing' stamp: 'jmv 12/27/2018 18:25:45' prior: 16884894!
           nodePrintOn: aStrm indent: nn
	| var aaStrm myLine |
	"Show just the sub nodes and the code."

	(aaStrm := aStrm) ifNil: [aaStrm := WriteStream on: (String new: 500)].
	nn timesRepeat: [aaStrm tab].
	aaStrm nextPutAll: self class name; space.
	myLine := self printString withBlanksCondensed.
	myLine := myLine copyFrom: 1 to: (myLine size min: 70).
	aaStrm nextPutAll: myLine; newLine.
	1 to: self class instSize do: [:ii | 
		var := self instVarAt: ii.
		(var respondsTo: #asReturnNode) ifTrue: [var nodePrintOn: aaStrm indent: nn+1]].
	1 to: self class instSize do: [:ii | 
		var := self instVarAt: ii.
		(var isCollection and: [var isSequenceable]) ifTrue: [
			var do: [ :aNode | 
				(aNode respondsTo: #asReturnNode) ifTrue: [
					aNode nodePrintOn: aaStrm indent: nn+1]]]].
	^ aaStrm! !

SequenceableCollection removeSelector: #allButFirstDo:!

SequenceableCollection removeSelector: #allButFirstDo:!

SequenceableCollection removeSelector: #allButLastDo:!

SequenceableCollection removeSelector: #allButLastDo:!

SequenceableCollection removeSelector: #at:incrementBy:!

SequenceableCollection removeSelector: #at:incrementBy:!

SequenceableCollection removeSelector: #errorFirstObject:!

SequenceableCollection removeSelector: #errorFirstObject:!

SequenceableCollection removeSelector: #forceTo:paddingStartWith:!

SequenceableCollection removeSelector: #forceTo:paddingStartWith:!

SequenceableCollection removeSelector: #forceTo:paddingWith:!

SequenceableCollection removeSelector: #forceTo:paddingWith:!

SequenceableCollection removeSelector: #integerAt:!

SequenceableCollection removeSelector: #integerAt:!

SequenceableCollection removeSelector: #integerAt:put:!

SequenceableCollection removeSelector: #integerAt:put:!

SequenceableCollection removeSelector: #isSequenceableCollection!

SequenceableCollection removeSelector: #isSequenceableCollection!

Object removeSelector: #isSequenceableCollection!

Object removeSelector: #isSequenceableCollection!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3552-SequenceableCollectionCleanup-JuanVuletich-2018Dec27-18h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3543] on 25 December 2018 at 5:16:22 pm'!

RectangleLikeMorph subclass: #DraggingGuideMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

!classDefinition: #DraggingGuideMorph category: #'Morphic-Kernel'!
RectangleLikeMorph subclass: #DraggingGuideMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Browser methodsFor: 'message category functions' stamp: 'AY 12/22/2018 11:56:46'!
                 categorizeUnderCategoryAt: aMessageCategoryListIndex messageAt: aMessageListIndex

	self selectedClassOrMetaClass ifNotNil: [ :class | | categorySelector messageSelector |
		categorySelector _ self messageCategoryList at: aMessageCategoryListIndex ifAbsent: [^self].
		messageSelector _ self messageList at: aMessageListIndex ifAbsent: [^self].
		categorySelector ~= Categorizer allCategory
			ifTrue: [
				class organization classify: messageSelector under: categorySelector suppressIfDefault: false.
				self changed: #messageList]]! !
!PluggableListMorph methodsFor: 'accessing' stamp: 'HAW 12/25/2018 12:21:46'!
                       rowAtLocation: aPoint ifNone: aNoneBlock 
	
	| listMorph |
	
	listMorph _ self listMorph.
	^listMorph rowAtLocation: (listMorph internalize: aPoint) ifNone: aNoneBlock! !
!PluggableListMorph methodsFor: 'drawing' stamp: 'AY 12/25/2018 16:51:46'!
          flashRow: aRow

	^self listMorph flashRow: aRow.! !
!PluggableListMorph methodsFor: 'events' stamp: 'AY 12/25/2018 17:02:10'!
  dragEvent: aMouseEvent localPosition: localEventPosition

	| row dragged |
	
	row _ self rowAtLocation: localEventPosition ifNone: [ ^self ].

	dragged _ DraggingGuideMorph new.
	dragged addMorph: (StringMorph contents: (self getListItem: row)).
	dragged setProperty: #dragSource toValue: self.
	dragged setProperty: #dropSelectorArgument toValue: row.
	
	aMouseEvent hand attachMorphBeside: dragged.! !
!PluggableListMorph methodsFor: 'event handling testing' stamp: 'AY 12/22/2018 11:50:28'!
                  allowsMorphDrop

	^self hasProperty: #allowsMorphDrop! !
!PluggableListMorph methodsFor: 'private' stamp: 'AY 12/22/2018 01:26:29'!
                            itemsAreDraggable
	
	^self hasProperty: #draggableItems! !
!PluggableListMorph methodsFor: 'accessing - properties' stamp: 'AY 12/22/2018 12:26:06'!
           acceptDropsFrom: aMorph performing: aDropActionSelector

	self setProperty: #allowsMorphDrop toValue: true.
	self setProperty: #acceptedDragSource toValue: aMorph.
	self setProperty: #dropActionSelector toValue: aDropActionSelector.! !
!PluggableListMorph methodsFor: 'accessing - properties' stamp: 'AY 12/22/2018 12:25:54'!
                          makeItemsDraggable

	self setProperty: #draggableItems toValue: true! !
!PluggableListMorph methodsFor: 'accessing - properties' stamp: 'AY 12/22/2018 01:26:39'!
                              makeItemsUndraggable

	self removeProperty: #draggableItems! !
!PluggableListMorph methodsFor: 'accessing - properties' stamp: 'AY 12/22/2018 12:27:38'!
       rejectDrops

	self removeProperty: #allowsMorphDrop.
	self removeProperty: #acceptedDragSource.
	self removeProperty: #dropActionSelector.! !
!PluggableListMorph methodsFor: 'layout' stamp: 'AY 12/25/2018 16:52:06'!
        acceptDroppingMorph: aMorph event: dropEvent

	| localPosition row dropActionSelector args |
	
	localPosition _ self internalizeFromWorld: dropEvent eventPosition.
	row _ self rowAtLocation: localPosition ifNone: [ ^self ].
	
	self flashRow: row.
	
	dropActionSelector _ self valueOfProperty: #dropActionSelector.
	args _ dropActionSelector numArgs.
	args = 1 ifTrue: [
		model perform: dropActionSelector with: row.
		^self].
	args = 2 ifTrue: [ | dropSelectorArgument |
		dropSelectorArgument _ aMorph
			valueOfProperty: #dropSelectorArgument
			ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
		model perform: dropActionSelector with: row with: dropSelectorArgument.
		^self].
	
	self error: 'dropActionSelector must be a 1- or 2-keyword symbol'! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'HAW 12/25/2018 12:22:07'!
                              wantsDroppedMorph: aMorph event: evt

	^(aMorph is: #DraggingGuideMorph)
		and: [ (aMorph valueOfProperty: #dragSource) = (self valueOfProperty: #acceptedDragSource) ]! !
!DraggingGuideMorph methodsFor: 'initialization' stamp: 'AY 12/21/2018 16:05:14'!
   defaultColor

	^Color transparent! !
!DraggingGuideMorph methodsFor: 'initialization' stamp: 'AY 12/21/2018 16:06:08'!
         initialize

	super initialize.
	extent _ 0@0.! !
!DraggingGuideMorph methodsFor: 'testing' stamp: 'AY 12/21/2018 16:05:22'!
    is: aSymbol

	^aSymbol == #DraggingGuideMorph or: [ super is: aSymbol ]! !
!DraggingGuideMorph methodsFor: 'dropping/grabbing' stamp: 'AY 12/25/2018 16:49:57'!
justDroppedInto: newOwnerMorph event: anEvent 
	
	self delete.
	anEvent hand redrawNeeded.! !
!HandMorph methodsFor: 'double click support' stamp: 'AY 12/21/2018 16:07:39'!
                   waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel dragSel: dragSel
	
	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: dragSel
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: Preferences tapAndHoldEmulatesButton2! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'AY 12/25/2018 17:06:43'!
          attachMorphBeside: aMorph

	"Position the given morph beside this hand, then grab it."

	aMorph aboutToBeGrabbedBy: self.
	^self grabMorph: aMorph delta: (self morphWidth)@0! !
!InnerListMorph methodsFor: 'list management' stamp: 'HAW 12/25/2018 12:21:42'!
                               rowAtLocation: aPoint ifNone: aNoneBlock

	| potentialRowNumber |
	
	potentialRowNumber := aPoint y // font height + 1.
	
	^(listItems isInBounds: potentialRowNumber) 
		ifTrue: [ potentialRowNumber ]
		ifFalse: aNoneBlock! !
!InnerListMorph methodsFor: 'drawing' stamp: 'AY 12/25/2018 16:51:08'!
                       flashRow: aRow

	self world ifNotNil: [ :world | world canvas ifNotNil: [ :canvas | 
		Display flash: (canvas externalizeDisplayBounds: (self drawBoundsForRow: aRow) from: self) ]].
	
! !
!PluggableListMorph methodsFor: 'events' stamp: 'HAW 12/25/2018 12:22:40' prior: 16888625!
         mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| row |
	
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		self listMorph noSelection].
	row _ self 
		rowAtLocation: localEventPosition
		ifNone:  [^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view.
	Model update will be done on mouse button up, so this feedback will be visible before that."
	self listMorph highlightedRow: row.

	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: (self itemsAreDraggable ifTrue: [ #dragEvent:localPosition: ] ifFalse: [ nil ])! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'AY 12/22/2018 12:18:24' prior: 16793141!
                         buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList |

	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	messageList makeItemsDraggable.
	messageCatList acceptDropsFrom: messageList performing: #categorizeUnderCategoryAt:messageAt:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: self buildMorphicSystemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: self buildMorphicClassColumn proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3553-DragAndDropToCategorizeMethods-AngelYan-2018Dec25-17h15m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3544] on 27 December 2018 at 10:16:55 am'!
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/27/2018 10:07:52'!
                categorizeUnderNewCategoryMessageAt: aSelectorToCategorize

	self selectedClassOrMetaClass ifNotNil: [ :class | | newCategory |
		newCategory _ self newCategoryNameIfNone: [ ^self ].
		class organization 
			addCategory: newCategory;
			classify: aSelectorToCategorize under: newCategory suppressIfDefault: false.
			
		self changed: #messageCategoryList.
		self changed: #messageList]! !
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/27/2018 10:04:30'!
       newCategoryNameIfNone: aNoneBlock

	| labels lines menuIndex newName reject |
	
	labels _ OrderedCollection with: 'new...'.
	reject _ Set new.
	reject
		addAll: self selectedClassOrMetaClass organization categories;
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	lines _ OrderedCollection new.
	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |
		cls = Object ifFalse: [
			cats _ cls organization categories reject:
				 [:cat | reject includes: cat].
			cats isEmpty ifFalse: [
				lines add: labels size.
				labels addAll: cats asArray sort.
				reject addAll: cats]]].
	newName _ (labels size = 1 or: [
		menuIndex _ (PopUpMenu labelArray: labels lines: lines)
		startUpWithCaption: 'Add Category'.
		menuIndex = 0 ifTrue: [^ aNoneBlock value].
		menuIndex = 1])
			ifTrue: [
				self request: 'Please type new category name'
					initialAnswer: 'category name']
			ifFalse: [
				labels at: menuIndex].
	
	^ newName isEmpty
		ifTrue: aNoneBlock
		ifFalse: [newName asSymbol].
! !
!PluggableListMorph methodsFor: 'accessing - properties' stamp: 'HAW 12/27/2018 09:32:34'!
     acceptDropsFrom: aMorph performing: aDropActionSelector whenOutsideList: aDropOutsideListActionSelector 

	(aDropActionSelector numArgs between: 1 and: 2) ifFalse: [ self error: 'dropActionSelector must be a 1- or 2-keyword symbol' ].
	aDropOutsideListActionSelector numArgs = 1 ifFalse: [ self error: 'dropOutsideListActionSelector must be a 1-keyword symbol' ].

	self setProperty: #allowsMorphDrop toValue: true.
	self setProperty: #acceptedDragSource toValue: aMorph.
	self setProperty: #dropActionSelector toValue: aDropActionSelector.
	self setProperty: #dropOutsideListActionSelector toValue: aDropOutsideListActionSelector ! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'HAW 12/27/2018 10:14:02'!
               acceptDroppingMorph: aMorph atRow: row withEvent: dropEvent

	| args dropActionSelector |

	self flashRow: row.

	dropActionSelector _ self valueOfProperty: #dropActionSelector.
	args _ dropActionSelector numArgs.
	args = 1 ifTrue: [ ^model perform: dropActionSelector with: row].
	args = 2 ifTrue: [ | dropSelectorArgument |
		dropSelectorArgument _ aMorph
			valueOfProperty: #dropSelectorArgument
			ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
		^model perform: dropActionSelector with: row with: dropSelectorArgument ].
	
	self error: 'dropActionSelector must be a 1- or 2-keyword symbol'
	
	! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'HAW 12/27/2018 09:28:18'!
                   acceptDroppingMorph: aMorph outsideListWithEvent: dropEvent

	| dropActionSelector dropSelectorArgument |
	
	dropActionSelector _ self valueOfProperty: #dropOutsideListActionSelector.
	dropSelectorArgument _ aMorph
		valueOfProperty: #dropSelectorArgument
		ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
	model perform: dropActionSelector with: dropSelectorArgument.
	! !
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/27/2018 10:02:04' prior: 16791958!
           addCategory
	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"

	| oldIndex newName |

	selectedClassName ifNil: [ ^self ].
	
	oldIndex _ self messageCategoryListIndex.
	newName _ self newCategoryNameIfNone: [ ^self ].
	
	self classOrMetaClassOrganizer
		addCategory: newName
		before: selectedMessageCategory.
	self changed: #messageCategoryList.
	self messageCategoryListIndex:
		(oldIndex = 0
			ifTrue: [self classOrMetaClassOrganizer categories size + 1]
			ifFalse: [oldIndex]).
	self changed: #messageCategoryList.
	
! !
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/27/2018 09:54:08' prior: 50425944!
            categorizeUnderCategoryAt: aMessageCategoryListIndex messageAt: aSelectorToCategorize

	self selectedClassOrMetaClass ifNotNil: [ :class | | categorySelector |
		categorySelector _ self messageCategoryList at: aMessageCategoryListIndex ifAbsent: [^self].
		categorySelector ~= Categorizer allCategory
			ifTrue: [
				class organization classify: aSelectorToCategorize under: categorySelector suppressIfDefault: false.
				self changed: #messageList]]! !
!PluggableListMorph methodsFor: 'accessing - properties' stamp: 'HAW 12/27/2018 09:19:35' prior: 50426024!
              rejectDrops

	self removeProperty: #allowsMorphDrop.
	self removeProperty: #acceptedDragSource.
	self removeProperty: #dropActionSelector.
	self removeProperty: #dropOutsideListActionSelector! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'HAW 12/27/2018 10:12:59' prior: 50426031!
                       acceptDroppingMorph: aMorph event: dropEvent

	| localPosition row |
	
	localPosition _ self internalizeFromWorld: dropEvent eventPosition.
	row _ self rowAtLocation: localPosition ifNone: [ ^self acceptDroppingMorph: aMorph outsideListWithEvent: dropEvent ].
	
	self acceptDroppingMorph: aMorph atRow: row withEvent: dropEvent.
	
	! !
!PluggableListMorph methodsFor: 'events' stamp: 'HAW 12/27/2018 10:10:27' prior: 50425976!
                     dragEvent: aMouseEvent localPosition: localEventPosition

	| row dragged listItem |
	
	row _ self rowAtLocation: localEventPosition ifNone: [ ^self ].
	listItem _ self getListItem: row.

	dragged _ DraggingGuideMorph new.
	dragged addMorph: (StringMorph contents: listItem).
	dragged setProperty: #dragSource toValue: self.
	dragged setProperty: #dropSelectorArgument toValue: listItem.
	
	aMouseEvent hand attachMorphBeside: dragged.! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 12/27/2018 10:09:58' prior: 50426168!
              buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList |

	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:messageAt: 
		whenOutsideList: #categorizeUnderNewCategoryMessageAt:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: self buildMorphicSystemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: self buildMorphicClassColumn proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

PluggableListMorph removeSelector: #acceptDropsFrom:performing:!

PluggableListMorph removeSelector: #acceptDropsFrom:performing:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3554-AllowMethodDropAfterLastCategory-HernanWilkinson-2018Dec27-09h14m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3544] on 27 December 2018 at 10:21:22 am'!
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/27/2018 10:21:17' prior: 50424882!
                fileNamedDropped: aFileName 

	(self canBeInstalled: aFileName) ifTrue: [ ^self ifUserWantsInstall: aFileName ].
	(self canBeFiledIn: aFileName) ifTrue: [ ^self ifUserWantsFileIn: aFileName ].
			
	self inform: 'Dropped file ', aFileName, ' not supported'! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3555-tweak-HernanWilkinson-2018Dec27-10h16m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3544] on 27 December 2018 at 10:29:13 am'!
!HandMorph methodsFor: 'event handling' stamp: 'HAW 12/27/2018 10:28:27'!
                     createEventFrom: eventBuffer ofType: type

	type = EventSensor eventTypeMouse ifTrue: [ ^self generateMouseEvent: eventBuffer ].
	type = EventSensor eventTypeKeyboard ifTrue: [ ^self generateKeyboardEvent: eventBuffer ].
	type = EventSensor eventTypeWindow ifTrue: [ ^self generateWindowEvent: eventBuffer ].
	type = EventSensor eventTypeDragDropFiles ifTrue: [ ^self generateDropFilesEvent: eventBuffer ].
		
	"All other events are ignored"
	^nil ! !
!HandMorph methodsFor: 'event handling' stamp: 'HAW 12/27/2018 10:28:17' prior: 50425058!
  processEventQueue
	"Process user input events from the local input devices."

	| evt evtBuf type hadAny mcs |
	mcs _ mouseClickState.
	hadAny := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		type := evtBuf first.
		evt := self createEventFrom: evtBuf ofType: type.
		evt
			ifNil: [ 
				"I have to consume all eventTypeDragDropFiles of type 2 quicky, that is why
				I check if it was an eventTypeDragDropFiles to continue in the loop - Hernan"
				type ~= EventSensor eventTypeDragDropFiles ifTrue: [^hadAny]]
			ifNotNil: [
				"Finally, handle it"
				self startEventDispatch: evt.
				hadAny := true.
				"For better user feedback, return immediately after a mouse event has been processed."
				evt isMouse ifTrue: [ ^hadAny ]]].
	"note: if we come here we didn't have any mouse events"
	mcs 
		ifNotNil: [ 
			"No mouse events during this cycle. Make sure click states time out accordingly"
			mcs
				handleEvent: (self lastMouseEvent asMouseMove: (Time localMillisecondClock - self lastMouseEventTime max: 0))
				from: self ].
	^hadAny! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3556-ReadabilityTweak-HernanWilkinson-2018Dec27-10h21m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3544] on 27 December 2018 at 1:42:37 pm'!
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/27/2018 13:11:10'!
                          categorizeUnderCategoryAt: aMessageCategoryListIndex selector: aSelectorToCategorize

	self selectedClassOrMetaClass ifNotNil: [ :class | | categorySelector |
		categorySelector _ self messageCategoryList at: aMessageCategoryListIndex ifAbsent: [^self].
		categorySelector ~= Categorizer allCategory
			ifTrue: [
				class organization classify: aSelectorToCategorize under: categorySelector suppressIfDefault: false.
				self changed: #messageList]]! !
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/27/2018 13:10:15'!
      categorizeUnderNewCategorySelector: aSelectorToCategorize

	self selectedClassOrMetaClass ifNotNil: [ :class | | newCategory |
		newCategory _ self newCategoryNameIfNone: [ ^self ].
		class organization 
			addCategory: newCategory;
			classify: aSelectorToCategorize under: newCategory suppressIfDefault: false.
			
		self changed: #messageCategoryList.
		self changed: #messageList]! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/27/2018 13:30:46'!
         categorizeUnderCategoryAt: aSystemCategoryIndex class: aClassName 

	systemOrganizer classify: aClassName under: (self systemCategoryList at: aSystemCategoryIndex).
	self changed: #classList! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/27/2018 13:39:38'!
           categorizeUnderNewCategoryClass: aClassName

	| newCategory |
	
	newCategory _ self newCategoryNameIfNone: [ ^self ].
	
	systemOrganizer
		addCategory: newCategory;
		classify: aClassName under: newCategory.
		
	self changed: #systemCategoryList.
	self changed: #classList.! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 12/27/2018 13:14:38'!
                               buildMorphicClassColumnWith: classList

	| column |
	
	column _ LayoutMorph newColumn.
	column
		addMorphUseAll: classList;
		addAdjusterAndMorph: self buildMorphicSwitches fixedHeight: (Theme current minimalWindows ifTrue: [AbstractFont default height + 4] ifFalse: [AbstractFont default height *2-4]).
		
	^column! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/27/2018 13:37:37' prior: 16792558!
                              addSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	
	| oldIndex newName |
	
	oldIndex _ self systemCategoryListIndex.
	newName _ self newCategoryNameIfNone: [ ^self ].
	
	systemOrganizer
		addCategory: newName
		before: selectedSystemCategory.
	self systemCategoryListIndex:
		(oldIndex = 0
			ifTrue: [self systemCategoryList size]
			ifFalse: [oldIndex]).
	self changed: #systemCategoryList.! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/27/2018 13:38:14' prior: 50426220!
                              newCategoryNameIfNone: aNoneBlock

	| newName |
	
	newName _ self
		request: 'Please type new category name'
		initialAnswer: 'Category-Name'.
	
	^newName isEmpty
		ifTrue: aNoneBlock 
		ifFalse: [newName asSymbol].! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 12/27/2018 13:15:08' prior: 16793040!
         buildMorphicClassColumn
	
	^self buildMorphicClassColumnWith: self buildMorphicClassList! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 12/27/2018 13:16:43' prior: 50426399!
        buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCatList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList makeItemsDraggable.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategoryAt:class:
		whenOutsideList: #categorizeUnderNewCategoryClass:.
		
	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3557-DragAndDropToCategorizeClasses-HernanWilkinson-2018Dec27-10h29m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3544] on 27 December 2018 at 1:50:32 pm'!
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/27/2018 13:48:49' prior: 50426554!
                  categorizeUnderCategoryAt: aSystemCategoryIndex class: aClassName 

	systemOrganizer classify: aClassName withBlanksTrimmed asSymbol under: (self systemCategoryList at: aSystemCategoryIndex).
	self changed: #classList! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/27/2018 13:48:56' prior: 50426563!
categorizeUnderNewCategoryClass: aClassName

	| newCategory |
	
	newCategory _ self newCategoryNameIfNone: [ ^self ].
	
	systemOrganizer
		addCategory: newCategory;
		classify: aClassName withBlanksTrimmed asSymbol under: newCategory.
		
	self changed: #systemCategoryList.
	self changed: #classList.! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3558-ClassesDnDFix-HernanWilkinson-2018Dec27-13h42m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3558] on 28 December 2018 at 11:02:37 am'!
!ClassDescription class methodsFor: 'utilities' stamp: 'jmv 12/28/2018 10:34:16'!
                        printPackageExtensionCategories
	"In a bare image, without any packages, should print nothing
	ClassDescription printPackageExtensionCategories
	ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories].
	"
	ClassDescription allSubInstances do: [ :cls |
		cls organization categories do: [ :cat |
			(cat beginsWith:  '*') ifTrue: [
				{cls. cat} print ]]].! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3559-RemovePackageLeftovers-JuanVuletich-2018Dec28-10h58m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3559] on 28 December 2018 at 11:16:11 am'!
!SelectionMenu methodsFor: 'basic control sequence' stamp: 'KLG 12/28/2018 14:05:30' prior: 16904809!
                              startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean
	"Overridden to return value returned by manageMarker.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

	| index |
	index _ super startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
	selections ifNil: [ ^index ].  "If there are no selections defined, show the super class' behavior."
	index between: 1 and: selections size :: ifFalse: [ ^nil ].
	^ selections at: index! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3560-FixFor-SelectionMenu-confirm-GeraldKlix-2018Dec28-11h15m-KLG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3560] on 28 December 2018 at 11:29:52 am'!
!CodeProvider methodsFor: 'misc' stamp: 'HAW 12/28/2018 09:33:38' prior: 16812484!
                              okayToAccept
	"Answer whether it is okay to accept the receiver's input"

	self showingByteCodes ifTrue: [
		self inform: 
'Sorry, you can only submit changes here 
when you are showing source.'.
		^ false].

	self showingDocumentation ifTrue: [
		self inform: 
'Sorry, you can only submit changes here 
when you are showing source.'.
		^ false].

	self showingAnyKindOfDiffs ifTrue: [
		^ SelectionMenu confirm: 
'Caution!!  You are "showing diffs" here, so 
there is a danger that some of the text in the
code pane is contaminated by the "diff" display'
		trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider' icons: #(acceptIcon cancelIcon)
	].

	^ true! !

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3561-AddIconsTo-okayToAccept-HernanWilkinson-2018Dec28-11h27m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3561] on 28 December 2018 at 12:44:11 pm'!
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/28/2018 12:37:44'!
    newMethodCategoryNameIfNone: aNoneBlock

	| labels lines menuIndex newName reject |
	
	labels _ OrderedCollection with: 'new...'.
	reject _ Set new.
	reject
		addAll: self selectedClassOrMetaClass organization categories;
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	lines _ OrderedCollection new.
	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |
		cls = Object ifFalse: [
			cats _ cls organization categories reject:
				 [:cat | reject includes: cat].
			cats isEmpty ifFalse: [
				lines add: labels size.
				labels addAll: cats asArray sort.
				reject addAll: cats]]].
	newName _ (labels size = 1 or: [
		menuIndex _ (PopUpMenu labelArray: labels lines: lines)
		startUpWithCaption: 'Add Category'.
		menuIndex = 0 ifTrue: [^ aNoneBlock value].
		menuIndex = 1])
			ifTrue: [
				self request: 'Please type new category name'
					initialAnswer: 'category name']
			ifFalse: [
				labels at: menuIndex].
	
	^ newName isEmpty
		ifTrue: aNoneBlock
		ifFalse: [newName asSymbol].
! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/28/2018 12:37:19'!
       newSystemCategoryNameIfNone: aNoneBlock

	| newName |
	
	newName _ self
		request: 'Please type new category name'
		initialAnswer: 'Category-Name'.
	
	^newName isEmpty
		ifTrue: aNoneBlock 
		ifFalse: [newName asSymbol].! !
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/28/2018 12:37:56' prior: 50426317!
                           addCategory
	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"

	| oldIndex newName |

	selectedClassName ifNil: [ ^self ].
	
	oldIndex _ self messageCategoryListIndex.
	newName _ self newMethodCategoryNameIfNone: [ ^self ].
	
	self classOrMetaClassOrganizer
		addCategory: newName
		before: selectedMessageCategory.
	self changed: #messageCategoryList.
	self messageCategoryListIndex:
		(oldIndex = 0
			ifTrue: [self classOrMetaClassOrganizer categories size + 1]
			ifFalse: [oldIndex]).
	self changed: #messageCategoryList.
	
! !
!Browser methodsFor: 'message category functions' stamp: 'HAW 12/28/2018 12:38:40' prior: 50426539!
      categorizeUnderNewCategorySelector: aSelectorToCategorize

	self selectedClassOrMetaClass ifNotNil: [ :class | | newCategory |
		newCategory _ self newMethodCategoryNameIfNone: [ ^self ].
		class organization 
			addCategory: newCategory;
			classify: aSelectorToCategorize under: newCategory suppressIfDefault: false.
			
		self changed: #messageCategoryList.
		self changed: #messageList]! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/28/2018 12:38:00' prior: 50426589!
                   addSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	
	| oldIndex newName |
	
	oldIndex _ self systemCategoryListIndex.
	newName _ self newSystemCategoryNameIfNone: [ ^self ].
	
	systemOrganizer
		addCategory: newName
		before: selectedSystemCategory.
	self systemCategoryListIndex:
		(oldIndex = 0
			ifTrue: [self systemCategoryList size]
			ifFalse: [oldIndex]).
	self changed: #systemCategoryList.! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 12/28/2018 12:38:10' prior: 50426683!
                        categorizeUnderNewCategoryClass: aClassName

	| newCategory |
	
	newCategory _ self newSystemCategoryNameIfNone: [ ^self ].
	
	systemOrganizer
		addCategory: newCategory;
		classify: aClassName withBlanksTrimmed asSymbol under: newCategory.
		
	self changed: #systemCategoryList.
	self changed: #classList.! !

Browser removeSelector: #categorizeUnderCategoryAt:messageAt:!

Browser removeSelector: #categorizeUnderCategoryAt:messageAt:!

Browser removeSelector: #categorizeUnderNewCategoryMessageAt:!

Browser removeSelector: #categorizeUnderNewCategoryMessageAt:!

Browser removeSelector: #newCategoryNameIfNone:!

Browser removeSelector: #newCategoryNameIfNone:!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3562-ClassesDragAndDropFix-HernanWilkinson-2018Dec28-12h33m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 29 December 2018 at 11:17:58 am'!

ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder icon '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #SimpleServiceEntry category: #'Tools-FileList'!
ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder icon'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

Object subclass: #DropFilesAction
	instanceVariableNames: 'shouldAskForCancel dropFilesEvent cancelBlock stopHereBlock selectedFileEntry shouldAskToStop '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

!classDefinition: #DropFilesAction category: #'Morphic-Worlds'!
Object subclass: #DropFilesAction
	instanceVariableNames: 'shouldAskForCancel dropFilesEvent cancelBlock stopHereBlock selectedFileEntry shouldAskToStop'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Worlds'!
!SimpleServiceEntry methodsFor: 'accessing' stamp: 'HAW 12/29/2018 09:55:38'!
                       icon

	^icon ! !
!SimpleServiceEntry methodsFor: 'accessing' stamp: 'HAW 12/29/2018 09:55:29'!
 icon: anIcon

	icon := anIcon ! !
!SimpleServiceEntry class methodsFor: 'instance creation' stamp: 'HAW 12/29/2018 10:21:57'!
  provider: anObject label: aString selector: aSymbol description: anotherString buttonLabel: aLabel icon: anIcon
	
	^ (self provider: anObject label: aString selector: aSymbol description: anotherString buttonLabel: aLabel)
		icon: anIcon;
		yourself! !
!SimpleServiceEntry class methodsFor: 'instance creation' stamp: 'HAW 12/29/2018 10:21:33'!
       provider: anObject label: aString selector: aSymbol description: anotherString icon: anIcon

	^(self provider: anObject label: aString selector: aSymbol description: anotherString)
		icon: anIcon;
		yourself! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/29/2018 11:14:32'!
                       createMenuFor: options

	| icons lines labels |

	"options is a small collection, no problem to collect twice - Hernan"	
	labels := options collect: [ :option | option label ].
	icons := options collect: [ :option | option icon ].

	shouldAskToStop 
		ifTrue: [
			lines := Array with: labels size.
			labels add: 'stop here'.
			icons add: #cancelIcon ]
		ifFalse: [ lines := #() ].
		
	^PopUpMenu labelArray: labels lines: lines icons: icons! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/29/2018 11:06:41'!
           performService: aService

	aService 
		argumentProvider: self;
		performService 
! !
!DropFilesAction methodsFor: 'FileList protocol' stamp: 'HAW 12/28/2018 20:31:41'!
                        fullName
	
	^selectedFileEntry name ! !
!DropFilesAction methodsFor: 'FileList protocol' stamp: 'HAW 12/28/2018 20:26:43'!
     selectedFileEntry
	
	^selectedFileEntry! !
!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'HAW 12/29/2018 10:06:58' prior: 50369059!
            serviceBrowseCode
	"Answer the service of opening a file-contents browser"

	^ (SimpleServiceEntry
		provider: self 
		label: 'browse code'
		selector: #browseCode:
		description: 'open a "file-contents browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'code'
		icon: #editFindReplaceIcon)
			sortOrder: 10;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!CodeFileBrowser class methodsFor: 'instance creation' stamp: 'HAW 12/29/2018 10:07:24' prior: 50369075!
                          serviceBrowsePackage
	"Answer the service of opening a file-contents browser"

	^ (SimpleServiceEntry
		provider: self 
		label: 'browse package'
		selector: #browsePackage:
		description: 'open a "package file browser" on this file, allowing you to view and selectively load its code'
		buttonLabel: 'package browser'
		icon: #editFindReplaceIcon)
			sortOrder: 10;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'HAW 12/29/2018 10:01:13' prior: 50369091!
                   serviceContents
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'see code file contents'
		selector: #browseContents:
		description: 'open a code file contents tool on this file'
		buttonLabel: 'contents'
		icon: #changesIcon)
			sortOrder: 20;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'HAW 12/29/2018 09:59:06' prior: 50369105!
          servicePackageContents
	"Answer a service for opening a changelist browser on a file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'see package file contents'
		selector: #browsePackageContents:
		description: 'open a code file contents tool on this package file'
		buttonLabel: 'pck contents'
		icon: #changesIcon)
			sortOrder: 20;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'HAW 12/29/2018 10:01:37' prior: 50406244!
             serviceRecentChanges
	"Answer a service for opening a changelist browser on the tail end of a .changes file"

	^ SimpleServiceEntry 
		provider: self 
		label: 'see recent changes in file'
		selector: #browseRecentLogOn:
		description: 'open a changelist tool on recent changes in file'
		buttonLabel: 'recent changes'
		icon: #changesIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:23:22' prior: 16842644!
                  serviceAddNewDirectory
	"Answer a service entry characterizing the 'add new directory' command"

	^ SimpleServiceEntry 
		provider: self 
		label: 'add new directory' 
		selector: #addNewDirectory
		description: 'adds a new, empty directory (folder)' 
		icon: #listAddIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:42:05' prior: 16842655!
                     serviceAddNewFile
	"Answer a service entry characterizing the 'add new file' command"

	^ SimpleServiceEntry 
		provider: self 
		label: 'add new file' 
		selector: #addNewFile 
		description: 'create a new,. empty file, and add it to the current directory.'
		icon: #newIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:24:39' prior: 16842665!
                  serviceCopyName

	^ SimpleServiceEntry 
		provider: self 
		label: 'copy name to clipboard' 
		selector: #copyName 
		description:'copy name to clipboard' 
		icon: #copyIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:26:03' prior: 16842672!
                        serviceDeleteFile

	^ SimpleServiceEntry 
		provider: self 
		label: 'delete' 
		selector: #deleteFile
		description: 'delete the seleted item'
		icon: #deleteIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:41:24' prior: 16842679!
  serviceGet
	"Answer a service for getting the entire file"

	^ SimpleServiceEntry 
		provider: self 
		label: 'get entire file' 
		selector: #get
		description: 'if the file has only been partially read in, because it is very large, read the entire file in at this time.'
		icon: #textEditorIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:40:08' prior: 16842690!
                              serviceGetHex

	^ SimpleServiceEntry 
		provider: self 
		label: 'view as hex' 
		selector: #getHex
		description: 'view as hex'
		icon: #fontXGenericIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:27:40' prior: 16842697!
           serviceRenameFile

	^ SimpleServiceEntry 
		provider: self 
		label: 'rename' 
		selector: #renameFile 
		description: 'rename file'
		icon: #saveAsIcon! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:31:06' prior: 16842704!
             serviceSortByDate
	"Answer a service for sorting by date"
	| buttonLabel |
	buttonLabel _ sortMode = #date
		ifTrue: [
			sortAscending
				ifTrue: [ '[^] - date' ]
				ifFalse: [ '[v] - date' ]]
		ifFalse: [ 'date' ].
	^  (SimpleServiceEntry 
			provider: self 
			label: 'by date' 
			selector: #sortByDate 
			description: 'sort entries by date'
			icon: #sendReceiveIcon)
		extraSelector: #sortingByDate;
		buttonLabel: buttonLabel! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:31:00' prior: 16842720!
                  serviceSortByName
	"Answer a service for soring by name"
	| buttonLabel |
	buttonLabel _ sortMode = #name
		ifTrue: [
			sortAscending
				ifTrue: [ '[^] - name' ]
				ifFalse: [ '[v] - name' ]]
		ifFalse: [ 'name' ].
	^ (SimpleServiceEntry 
		provider: self 
		label: 'by name' 
		selector: #sortByName 
		description: 'sort entries by name'
		icon: #sendReceiveIcon)
			extraSelector: #sortingByName;
			buttonLabel: buttonLabel! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:29:42' prior: 16842735!
                       serviceSortBySize
	"Answer a service for sorting by size"
	| buttonLabel |
	buttonLabel _ sortMode = #size
		ifTrue: [
			sortAscending
				ifTrue: [ '[^] - size' ]
				ifFalse: [ '[v] - size' ]]
		ifFalse: [ 'size' ].
	^ (SimpleServiceEntry
		provider: self
		label: 'by size'
		selector: #sortBySize
		description: 'sort entries by size'
		icon: #sendReceiveIcon)
			extraSelector: #sortingBySize;
			buttonLabel: buttonLabel.! !
!FileList methodsFor: 'own services' stamp: 'HAW 12/29/2018 10:33:04' prior: 16842750!
                         serviceViewContentsInWorkspace
	"Answer a service for viewing the contents of a file in a workspace"
	
	^ SimpleServiceEntry 
		provider: self 
		label: 'workspace with contents' 
		selector: #viewContentsInWorkspace
		description: 'open a new Workspace whose contents are set to the contents of this file'
		icon: #terminalIcon! !
!SimpleServiceEntry methodsFor: 'services menu' stamp: 'HAW 12/29/2018 10:20:15' prior: 50392959!
                  addServiceFor: served toMenu: aMenu
	argumentProvider _ served.
	aMenu 
		add: self label 
		target: self 
		action: #performService
		icon: icon.
	self useLineAfter ifTrue: [ aMenu addLine ].! !
!SimpleServiceEntry methodsFor: 'initialization' stamp: 'HAW 12/29/2018 10:20:39' prior: 50369297!
                         initialize

	triggerFileListChanged _ false.
	sortOrder _ 1.
	icon _ nil.! !
!DropFilesAction methodsFor: 'initialization' stamp: 'HAW 12/29/2018 11:14:32' prior: 50424847!
                   initializeFor: aDropFilesEvent 

	dropFilesEvent := aDropFilesEvent.
	shouldAskToStop := aDropFilesEvent numberOfFiles > 1! !
!DropFilesAction methodsFor: 'evaluating' stamp: 'HAW 12/29/2018 11:14:49' prior: 50424854!
      value

	stopHereBlock := [ ^self ].
	dropFilesEvent fileNamesDo: [ :fileName | self fileNamedDropped: fileName ]
		
! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'HAW 12/29/2018 11:15:10' prior: 50426443!
  fileNamedDropped: aFileName 

	| options selectionIndex menu |
	
	selectedFileEntry := aFileName asFileEntry.
	options := FileList itemsForFile: aFileName.
	options isEmpty ifTrue: [ ^self inform: 'No action found for ', selectedFileEntry name ].
	menu := self createMenuFor: options.
		
	selectionIndex := menu startUpWithCaption: 'Select action for ', selectedFileEntry name.
	
	selectionIndex = 0 ifTrue: [ ^self ].
	(options isInBounds: selectionIndex) ifTrue: [ ^self performService: (options at: selectionIndex) ].
	"The only available option is 'stop here'. This could change if #createMenuFor: changes - Hernan"
	stopHereBlock value
	
! !
!ChangeSet class methodsFor: 'file list services' stamp: 'HAW 12/29/2018 10:04:54' prior: 50369148!
                     serviceFileIn
	"Answer a service for filing in an entire file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'file in'
		selector: #fileIn:
		description: 'file in the entire contents of the file, which is expected to contain Smalltalk code in fileout ("chunk") format'
		buttonLabel: 'filein'
		icon: #saveIcon)
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!ChangeSet class methodsFor: 'file list services' stamp: 'HAW 12/29/2018 10:05:49' prior: 50369164!
         serviceInstall
	"Answer a service for filing in an entire file"

	^ (SimpleServiceEntry 
		provider: self 
		label: 'install code'
		selector: #install:
		description: 'install change set'
		buttonLabel: 'install'
		icon: #saveIcon)
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !
!CodePackageFile class methodsFor: 'file list services' stamp: 'HAW 12/29/2018 10:16:53' prior: 50407037!
                         serviceInstallPackage
	"Answer the service of installing a CodePackageFile (a chunk format file for a CodePackage)"

	^ (SimpleServiceEntry
		provider: self 
		label: 'install package'
		selector: #installPackage:
		description: 'install the package, replacing all existing code in the package (if any); create a new change set just for the installation'
		buttonLabel: 'install package'
		icon: #saveIcon)
			sortOrder: 100;
			argumentGetter: [ :fileList | fileList selectedFileEntry ]! !

DropFilesAction removeSelector: #ask:onYes:!

DropFilesAction removeSelector: #ask:onYes:!

DropFilesAction removeSelector: #canBeFiledIn:!

DropFilesAction removeSelector: #canBeFiledIn:!

DropFilesAction removeSelector: #canBeInstalled:!

DropFilesAction removeSelector: #canBeInstalled:!

DropFilesAction removeSelector: #ifUserWantsFileIn:!

DropFilesAction removeSelector: #ifUserWantsFileIn:!

DropFilesAction removeSelector: #ifUserWantsInstall:!

DropFilesAction removeSelector: #ifUserWantsInstall:!

DropFilesAction removeSelector: #isAChangeSet:!

DropFilesAction removeSelector: #isChangeSet:!

ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder icon'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #SimpleServiceEntry category: #'Tools-FileList'!
ActiveModel subclass: #SimpleServiceEntry
	instanceVariableNames: 'provider label selector useLineAfter stateSelector description argumentGetter buttonLabel argumentProvider triggerFileListChanged sortOrder icon'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

Object subclass: #DropFilesAction
	instanceVariableNames: 'dropFilesEvent selectedFileEntry shouldAskToStop stopHereBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

!classDefinition: #DropFilesAction category: #'Morphic-Worlds'!
Object subclass: #DropFilesAction
	instanceVariableNames: 'dropFilesEvent selectedFileEntry shouldAskToStop stopHereBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Worlds'!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3563-DropFileEnhancements-HernanWilkinson-2018Dec28-17h36m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 29 December 2018 at 11:34:36 am'!
!SystemDictionary methodsFor: 'testing' stamp: 'HAW 12/29/2018 11:34:08'!
            isLiveTypingInstalled
	
	^(FeatureRequirement name: #LiveTyping) isAlreadySatisfied! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/29/2018 11:34:08' prior: 50423940!
  returnTypeOfEnclosedExpressionAt: aRange 
	
	Smalltalk isLiveTypingInstalled ifFalse: [ ^nil ].
	
	^self 
		withParserSourceMethodNodeDo: [ :methodNode | self returnTypeOfEnclosedExpresionIn: methodNode at: aRange end ]
		ifError: [ :anError | nil ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 12/29/2018 11:34:08' prior: 50423951!
                            returnTypeOfUnaryMessage: aSelector at: aRange 
	
	Smalltalk isLiveTypingInstalled ifFalse: [ ^nil ].
	
	^self
		withParserSourceMethodNodeDo: [ :methodNode | self returnTypeOfNodeUnderCursorIn: methodNode at: aRange end]
		ifError: [ :anError | nil ]! !

SystemDictionary removeSelector: #isLiveTypeInformationInstalled!

SystemDictionary removeSelector: #isLiveTypeInformationInstalled!

----End fileIn of /home/juan/Cuis/Cuis-Smalltalk-Dev/CoreUpdates/3564-LiveTyping-Enhancements-HernanWilkinson-2018Dec29-11h17m-HAW.1.cs.st----!

----SNAPSHOT----#(1 January 2019 8:25:44.949058 pm) Cuis5.0-3564-v3.image priorSource: 2972043!

----QUIT----#(1 January 2019 8:26:18.1987 pm) Cuis5.0-3564-v3.image priorSource: 3064981!

----STARTUP----#(28 January 2019 10:38:59.056154 am) as /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/Cuis5.0-3564-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 8 January 2019 at 4:25:22 pm'!
!Parser methodsFor: 'scanning' stamp: 'HAW 1/8/2019 16:24:45'!
                     compensateTwoCharacterLookahead

	^source position - (aheadChar == self doItCharacter ifTrue: [hereChar == self doItCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2])
	! !
!Scanner methodsFor: 'expression types' stamp: 'HAW 1/8/2019 16:21:59' prior: 50410005!
                             scanAllTokenPositionsInto: aBlock
	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."

	| lastMark |
	lastMark := 1.
	[currentComment ifNotNil:
		[currentComment do:
			[:cmnt| | idx |
			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.
			 (idx > 0 and: [idx < mark]) ifTrue:
				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].
		 currentComment := nil].
	mark ifNotNil:
		[(token == #- 
		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue:
			[| savedMark |
			 savedMark := mark.
			 self scanToken.
			 token := token negated.
			 mark := savedMark].
		"Compensate for the fact that the parser uses two character lookahead.  Normally we must
		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."
		 aBlock
			value: mark
			value: (source position - (aheadChar == self doItCharacter ifTrue: [hereChar == self doItCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]))].
	 (tokenType == #rightParenthesis
	  or: [tokenType == #doIt]) ifTrue:
		[^self].
	tokenType == #leftParenthesis
		ifTrue: 
			[self scanToken; scanAllTokenPositionsInto: aBlock]
		ifFalse: 
			[(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])
				ifTrue: 
					[self scanLitWord.
					 token == #true ifTrue: [token := true].
					 token == #false ifTrue: [token := false].
					 token == #nil ifTrue: [token := nil]]
				ifFalse:
					[(token == #- 
					  and: [(self typeTableAt: hereChar) == #xDigit])
						ifTrue: 
							[self scanToken.
							 token := token negated]]].
		self scanToken ] repeat! !
!Parser methodsFor: 'scanning' stamp: 'HAW 1/8/2019 16:21:24' prior: 50410209!
           advance
	| this |
	prevMark := hereMark.
	prevEnd := hereEnd.
	this := here.
	here := token.
	hereType := tokenType.
	hereMark := mark.
	hereEnd := source position - (aheadChar == self doItCharacter ifTrue: [hereChar == self doItCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]).
	self scanToken.
	"Transcript show: 'here: ', here printString, ' mark: ', hereMark printString, ' end: ', hereEnd printString; cr."
	^this! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3565-ParserFix-HernanWilkinson-2019Jan08-11h39m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 8 January 2019 at 4:27:21 pm'!
!Scanner methodsFor: 'expression types' stamp: 'HAW 1/8/2019 16:26:05' prior: 50427453!
                        scanAllTokenPositionsInto: aBlock
	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."

	| lastMark |
	lastMark := 1.
	[currentComment ifNotNil:
		[currentComment do:
			[:cmnt| | idx |
			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.
			 (idx > 0 and: [idx < mark]) ifTrue:
				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].
		 currentComment := nil].
	mark ifNotNil:
		[(token == #- 
		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue:
			[| savedMark |
			 savedMark := mark.
			 self scanToken.
			 token := token negated.
			 mark := savedMark].
		"Compensate for the fact that the parser uses two character lookahead.  Normally we must
		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."
		 aBlock
			value: mark
			value: self compensateTwoCharacterLookahead ].
	 (tokenType == #rightParenthesis
	  or: [tokenType == #doIt]) ifTrue:
		[^self].
	tokenType == #leftParenthesis
		ifTrue: 
			[self scanToken; scanAllTokenPositionsInto: aBlock]
		ifFalse: 
			[(tokenType == #word or: [tokenType == #keyword or: [tokenType == #colon]])
				ifTrue: 
					[self scanLitWord.
					 token == #true ifTrue: [token := true].
					 token == #false ifTrue: [token := false].
					 token == #nil ifTrue: [token := nil]]
				ifFalse:
					[(token == #- 
					  and: [(self typeTableAt: hereChar) == #xDigit])
						ifTrue: 
							[self scanToken.
							 token := token negated]]].
		self scanToken ] repeat! !
!Parser methodsFor: 'scanning' stamp: 'HAW 1/8/2019 16:25:50' prior: 50427508!
          advance
	| this |
	prevMark := hereMark.
	prevEnd := hereEnd.
	this := here.
	here := token.
	hereType := tokenType.
	hereMark := mark.
	hereEnd := self compensateTwoCharacterLookahead.
	self scanToken.
	"Transcript show: 'here: ', here printString, ' mark: ', hereMark printString, ' end: ', hereEnd printString; cr."
	^this! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3566-ParserFix-HernanWilkinson-2019Jan08-16h25m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 2 January 2019 at 7:08:02 pm'!
!FileList methodsFor: 'own services' stamp: 'HAW 1/2/2019 19:06:52' prior: 50427150!
                         serviceGetHex

	^ SimpleServiceEntry 
		provider: self 
		label: 'view as hex' 
		selector: #getHex
		description: 'view as hex'
		icon: #preferencesDesktopFontIcon! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3567-HexFileListIcon-HernanWilkinson-2018Dec29-11h34m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 7 January 2019 at 4:06:33 pm'!
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 07:04:14'!
            removeProperties
	
	self penultimateLiteral: self selector! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 07:06:51'!
     withPropertiesDo: withBlock

	^self withPropertiesDo: withBlock ifSelector: [ :selector | nil ]! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 07:03:13'!
withPropertiesDo: withBlock ifSelector: notBlock

	| penultimalLiteral |
	
	penultimalLiteral := self penultimateLiteral.
	
	^penultimalLiteral isMethodProperties 
		ifTrue: [ withBlock value: penultimalLiteral ]
		ifFalse: [ notBlock value: penultimalLiteral ]! !
!CompiledMethod methodsFor: 'accessing' stamp: 'HAW 1/3/2019 07:03:14' prior: 16819533!
                               properties

	"Answer the method properties of the receiver."
	
	^self 
		withPropertiesDo: [ :properties | properties ] 
		ifSelector: [ :selector | AdditionalMethodState forMethod: self selector: selector ]! !
!CompiledMethod methodsFor: 'accessing' stamp: 'HAW 1/7/2019 15:49:22' prior: 16819588!
                     selector
	"Answer a method's selector.  This is either the penultimate literal,
	 or, if the method has any properties or pragmas, the selector of
	 the MethodProperties stored in the penultimate literal."
	
	^self 
		withPropertiesDo: [ :properties | properties selector ] 
		ifSelector: [ :selector | selector ]
! !
!CompiledMethod methodsFor: 'accessing' stamp: 'HAW 1/7/2019 15:56:36' prior: 16819602!
          selector: aSelector
	"Set a method's selector.  This is either the penultimate literal,
	 or, if the method has any properties or pragmas, the selector of
	 the MethodProperties stored in the penultimate literal."
	
	| numberOfLiterals | 
	
	self 
		withPropertiesDo: [ :properties | properties selector: aSelector ] 
		ifSelector: [ :selector |
			(numberOfLiterals := self numLiterals) < 2 ifTrue: [self error: 'insufficient literals to hold selector'].
			self literalAt: numberOfLiterals - 1 put: aSelector]! !
!CompiledMethod methodsFor: 'literals' stamp: 'HAW 1/3/2019 07:06:51' prior: 16820025!
      hasLiteralSuchThat: litBlock
	"Answer true if litBlock returns true for any literal in this method, even if embedded in array structure."
	
	| lit |
	
	self withPropertiesDo: [ :properties | (properties hasLiteralSuchThat: litBlock) ifTrue: [ ^true ]]. 

	2 to: self numLiterals + 1 do: [ :index |
		lit := self objectAt: index.
		((litBlock value: lit)
		or: [lit isArray and: [lit hasLiteralSuchThat: litBlock]]) ifTrue:
			[^true]].
	^false! !
!CompiledMethod methodsFor: 'literals' stamp: 'HAW 1/3/2019 07:06:51' prior: 16820042!
          hasLiteralThorough: literal
	"Answer true if any literal in this method is literal,
	even if embedded in array structure."

	| lit |
	
	self withPropertiesDo: [ :properties | (properties hasLiteralThorough: literal) ifTrue:[^true]].
	
	2 to: self numLiterals - 1 "exclude superclass + selector/properties"
	   do: [ :index |
		(((lit := self objectAt: index) literalEqual: literal)
		 or: [(lit isVariableBinding and: [lit key == literal])
		 or: [lit isArray and: [lit hasLiteral: literal]]]) ifTrue:
			[^ true]].
	^ false ! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 07:03:14' prior: 16820939!
  pragmaAt: aKey

	"Answer the pragma with selector aKey, or nil if none."

	^self withPropertiesDo: [ :properties | properties at: aKey ifAbsent: nil ] ifSelector: [ :selector | nil ].
	! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 07:03:14' prior: 16820950!
                      pragmas
	
	^self withPropertiesDo: [ :properties | properties pragmas ] ifSelector: [ :selector | #() ]! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 07:18:59' prior: 16820959!
        propertyKeysAndValuesDo: aBlock

	"Enumerate the receiver with all the keys and values."

	self withPropertiesDo: [ :properties | properties propertyKeysAndValuesDo: aBlock]! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 16:57:04' prior: 16820970!
  propertyValueAt: propName

	^self withPropertiesDo: [ :properties | properties propertyValueAt: propName ifAbsent: nil] ! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/3/2019 17:01:07' prior: 16820980!
                       propertyValueAt: propName ifAbsent: aBlock
	
	^self withPropertiesDo: [ :properties | properties propertyValueAt: propName ifAbsent: aBlock ] ifSelector: [ :selector | aBlock value ]
	! !
!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'HAW 1/7/2019 15:45:43' prior: 16820991!
                       propertyValueAt: propName put: propValue
	"Set or add the property with key propName and value propValue.
	 If the receiver does not yet have a method properties create one and replace
	 the selector with it.  Otherwise, either relace propValue in the method properties
	 or replace method properties with one containing the new property."
	
	self 
		withPropertiesDo: [:properties | 
			(properties includesProperty: propName) ifTrue: [^properties at: propName put: propValue].
			self penultimateLiteral: (properties
								copyWith: (Association
												key: propName asSymbol
												value: propValue)).
			^propValue ] 
		ifSelector: [ :selector |
			self penultimateLiteral: ((AdditionalMethodState
									selector: selector
									with: (Association
											key: propName asSymbol
											value: propValue))
									setMethod: self;
									yourself).
			^propValue].! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3568-CompiledMethodPropertiesCleanup-HernanWilkinson-2019Jan02-19h08m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 7 January 2019 at 4:23:57 pm'!
!ClassBuilder methodsFor: 'validation' stamp: 'HAW 1/7/2019 16:20:34'!
                       doesClassNameStartWithUppercase: aClassName
	
	^ aClassName first isUppercase! !
!ClassBuilder methodsFor: 'validation' stamp: 'HAW 1/7/2019 16:20:34' prior: 16803747!
                        validateClassName: aString
	"Validate the new class name"
	
	(self doesClassNameStartWithUppercase: aString) ifFalse:[
		self error: 'Class names must be capitalized'.
		^false].
	Smalltalk at: aString ifPresent:[:old|
		(old isKindOf: Behavior) ifFalse:[
			self notify: aString asText allBold, 
						' already exists!!\Proceed will store over it.' withNewLines]].
	^true! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3569-Tweak-HernanWilkinson-2019Jan07-16h06m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3569] on 8 January 2019 at 5:28:27 pm'!
!ProcessBrowser class methodsFor: 'process control' stamp: 'jmv 1/8/2019 17:27:55' prior: 16895117!
                              rulesFor: aProcess
	"Answer two flags: allow-stop, and allow-debug"

	"Don't mess with the process running the ProcessBrowser.
	If we support several active UIs, we'd detect the UI process running us"
	self flag: #jmvVer2.
	aProcess == Processor activeProcess
		ifTrue: [^{false. false}].

	aProcess name = 'Sound Player'
		ifTrue: [ ^{false. false}].

	^ [aProcess caseOf: {
		[] -> [{false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{false. false}].
		[WeakArray runningFinalizationProcess] -> [{false. false}].
		[Processor activeProcess] -> [{false. true}].
		[Processor backgroundProcess] -> [{false. false}].
		[Sensor interruptWatcherProcess] -> [{false. false}].
		[Sensor eventTicklerProcess] -> [{false. false}].
		[CPUWatcher currentWatcherProcess] -> [{false. false}].
		[Delay timerProcess] -> [{false. false}]}
		otherwise: [ {true. true}]]
		ifError: [ :err :rcvr | {true. true}]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3570-rulesForFix-JuanVuletich-2019Jan08-17h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 7 January 2019 at 10:46:01 pm'!
!ClassBuilder class methodsFor: 'accessing' stamp: 'HAW 1/7/2019 22:32:41'!
 reservedNames

	"Return a list of names that must not be used for variables"

	^#(#self #super #true #false #nil #thisContext)! !
!ClassBuilder methodsFor: 'private' stamp: 'HAW 1/7/2019 22:32:29' prior: 50368678!
          reservedNames

	"Return a list of names that must not be used for variables"

	^self class reservedNames ! !
!Theme methodsFor: 'private - shout mappings' stamp: 'HAW 1/7/2019 22:33:06' prior: 16935932!
                     pseudoVariables

	^ ClassBuilder reservedNames ! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3571-ClassBuilderCleanup-HernanWilkinson-2019Jan07-17h05m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 8 January 2019 at 5:05:17 pm'!

Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick '
	classVariableNames: 'TypeTable DoItCharacter '
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Scanner category: #'Compiler-Kernel'!
Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick'
	classVariableNames: 'DoItCharacter TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!Scanner class methodsFor: 'class initialization' stamp: 'HAW 1/8/2019 17:02:07'!
                               initializeDoitCharacter

	DoItCharacter := self doItCharacterValue asCharacter ! !
!Scanner class methodsFor: 'class initialization' stamp: 'HAW 1/8/2019 17:01:11' prior: 16904320!
           initialize
	"
	Scanner initialize
	"
	self initTypeTable.
	self initializeDoitCharacter! !

Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick'
	classVariableNames: 'DoItCharacter TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Scanner category: #'Compiler-Kernel'!
Object subclass: #Scanner
	instanceVariableNames: 'source mark hereChar aheadChar token tokenType currentComment buffer typeTable isForTokenization sentInLiterals ignoreBacktick'
	classVariableNames: 'DoItCharacter TypeTable'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

Scanner initialize!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3572-SlightParserSpeedup-HernanWilkinson-2019Jan08-16h27m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 8 January 2019 at 5:13:05 pm'!
!Scanner methodsFor: 'expression types' stamp: 'HAW 1/8/2019 17:08:16' prior: 50410061!
                              step

	| c |
	c := hereChar.
	hereChar := aheadChar.
	source atEnd
		ifTrue: [aheadChar := DoItCharacter "doit"]
		ifFalse: [aheadChar := source next].
	^c! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 1/8/2019 17:08:09' prior: 50410238!
    readUpToNext: aChar ifNotFound: aNotFoundBlock

	self step.
	buffer reset.
	
	[self isAt: aChar]
		whileFalse: 
			[buffer nextPut: self step.
			(hereChar == DoItCharacter and: [source atEnd]) ifTrue: [^aNotFoundBlock value ]].
	
	self step.
	token := buffer contents.
	! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 1/8/2019 17:10:01' prior: 50410080!
                xDigit
	"Form a number."

	tokenType := #number.
	(aheadChar == DoItCharacter and: [source atEnd
			and:  [source skip: -1. source next ~~ DoItCharacter]])
		ifTrue: [source skip: -1 "Read off the end last time"]
		ifFalse: [source skip: -2].
	token := [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].
	self step; step! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 1/8/2019 17:10:14' prior: 50410094!
              xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := WriteStream on: (String new: 200).
    self step.
    [hereChar == $"]
        whileFalse:
            [(hereChar == stopChar and: [source atEnd])
                ifTrue: [^self offEnd: 'Unmatched comment quote'].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollection with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!Scanner methodsFor: 'multi-character scans' stamp: 'HAW 1/8/2019 17:10:25' prior: 50410120!
  xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore]]] whileTrue:
			["open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
							ifTrue: [DoItCharacter "doit"]
							ifFalse: [source next]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])
					ifTrue: 
						[buffer nextPut: self step.
						"Allow any number of embedded colons in literal symbols"
						[(self typeTableAt: hereChar) == #xColon] whileTrue:
							[buffer nextPut: self step].
						#keyword]
					ifFalse: 
						[#word].
	token := buffer contents! !
!Parser methodsFor: 'scanning' stamp: 'HAW 1/8/2019 17:07:55' prior: 50427444!
  compensateTwoCharacterLookahead

	^source position - (aheadChar == DoItCharacter ifTrue: [hereChar == DoItCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2])
	! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3573-SlightParserSpeedup-HernanWilkinson-2019Jan08-17h05m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 8 January 2019 at 5:37:28 pm'!

Scanner removeSelector: #doItCharacter!

Scanner removeSelector: #doItCharacter!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3574-SlightParserSpeedup-HernanWilkinson-2019Jan08-17h13m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3574] on 9 January 2019 at 12:29:29 pm'!
!TextEditor methodsFor: 'private' stamp: 'AY 1/2/2019 22:24:14'!
     firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine _ textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine _ currentLine first.
	endOfIndentation _ self privateCurrentString
		skipDelimiters: (String with: Character tab)
		startingAt: beginningOfLine.
		
	stops _ OrderedCollection with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!Editor methodsFor: 'private' stamp: 'AY 1/9/2019 12:18:54' prior: 16836757!
                      beginningOfParagraph: position
	| s |
	s _ self privateCurrentString.
	^ (s
		lastIndexOf: Character newLineCharacter
		startingAt: (position-1 min: s size)
		ifAbsent: [ 0 ])
			+ 1.! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'AY 1/9/2019 12:29:03' prior: 16932328!
  cursorEnd: aKeyboardEvent 

	"Private - Move cursor end of current line."

	self
		moveCursor: [ :position |
			"Mac standard keystrole"		
			(aKeyboardEvent commandAltKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ self endOfText ]
					ifFalse: [ self endOfLine: position ]]
		forward: true
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'AY 1/9/2019 12:28:01' prior: 16932347!
                    cursorHome: aKeyboardEvent

	"Private - Move cursor from position in current line to beginning of current line or end of indentation (see #firstOfBeginningOfLineOrEndOfIndentationLeftOf:).
	If control key is pressed put cursor at beginning of text"

	self
		moveCursor: [ :position |
			"Mac standard keystrole"		
			(aKeyboardEvent commandAltKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ self beginningOfText ]
					ifFalse: [ self firstOfBeginningOfLineOrEndOfIndentationLeftOf: position ]]
		forward: false
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'private' stamp: 'jmv 1/9/2019 12:27:48' prior: 16932811!
          sameColumn: start newLine: lineBlock forward: isForward
	"Private - Compute the index in my text
	with the line number derived from lineBlock,"
	" a one argument block accepting the old line number.
	The position inside the line will be preserved as good as possible"
	"The boolean isForward is used in the border case to determine if
	we should move to the beginning or the end of the line."
	| column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |
	lines _ textComposition lines.
	numberOfLines _ textComposition numberOfLines.
	currentLineNumber  _ textComposition lineIndexFor: start.
	currentLine _ lines at: currentLineNumber.
	column _ start - currentLine first.
	targetLineNumber _ ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.
	offsetAtTargetLine _ (lines at: targetLineNumber) first.
	targetEOL _ (lines at: targetLineNumber) last + (targetLineNumber = numberOfLines ifTrue:[1]ifFalse:[0]).
	targetLineNumber = currentLineNumber
	"No movement or movement failed. Move to beginning or end of line."
		ifTrue:[
			^isForward
				ifTrue:[targetEOL]
				ifFalse:[offsetAtTargetLine]].
	^offsetAtTargetLine + column min: targetEOL.! !

Preferences class removeSelector: #wordStyleCursorMovement!

Preferences class removeSelector: #wordStyleCursorMovement!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3575-CursorHomeEnh-AngelYan-JuanVuletich-2019Jan09-12h09m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3575] on 11 January 2019 at 4:57:40 pm'!

Error subclass: #AttemptToMutateObjectInCallStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #AttemptToMutateObjectInCallStack category: #'Exceptions Kernel'!
Error subclass: #AttemptToMutateObjectInCallStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!AttemptToMutateObjectInCallStack commentStamp: '<historical>' prior: 0!
   A become operation tries to mutate an object that is the receiver ('self') in a method currently in execution, and part of the stack of calls of some process.!
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/11/2019 11:08:09'!
                   anyReceiverInStackIn: anArray
	"Iterate over all methods currently in execution. Answer true if in any of them 'self' an element of argument"
	"
	Processor anyReceiverInStackIn: { self runningWorld }
	Processor anyReceiverInStackIn: { Object new }
	"
	self processesDo: [ :p | ] withStackFramestDo: [ :p :c |
		(anArray statePointsTo: c receiver)
			ifTrue: [ ^ true ]].
	^ false! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/11/2019 11:11:48'!
                    anyReceiverInStackIn: anArray orIn: anotherArray
	"Iterate over all methods currently in execution. Answer true if in any of them 'self' an element of argument"
	"
	Processor anyReceiverInStackIn: {} orIn: { self runningWorld }
	Processor anyReceiverInStackIn: {} orIn: { Object new }
	"
	self processesDo: [ :p | ] withStackFramestDo: [ :p :c | | r |
		r _ c receiver.
		(anArray statePointsTo: r)
			ifTrue: [ ^ true ].
		(anotherArray statePointsTo: r)
			ifTrue: [ ^ true ]].
	^ false! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/9/2019 16:02:19'!
        anyReceiverInStackIsKindOf: aClass
	"Iterate over all methods currently in execution. Answer true if in any of them 'self' is a (sub)instance of aClass"
	"
	Processor anyReceiverInStackIsKindOf: Morph
	Processor anyReceiverInStackIsKindOf: DifferenceFinder
	"
	self processesDo: [ :p | ] withStackFramestDo: [ :p :c |
		(c receiver isKindOf: aClass)
			ifTrue: [ ^ true ]].
	^ false! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/9/2019 15:54:20'!
                  processesDo: aBlock
	"Iterate over processes that can run"
	"
	Processor processesDo: [ :p | p print ].
	"
	Process allSubInstancesDo: [ :p |
		p isTerminated ifFalse: [
			aBlock value: p ]]! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/9/2019 15:59:16'!
                 processesDo: aBlock withStackFramestDo: twoArgBlock
	"Iterate over processes that can run.
	For each process, iterate over stack frames (i.e. contexts)."
	"
	Processor
		processesDo: [ :p |
			'--------------' print.
			p print. 
			'--------------' print ]
		withStackFramestDo: [ :p :c |
			('        ', c printString) print ].
	"
	self processesWithTopContextDo: [ :process :topContext | | context |
		aBlock value: process.
		context _ topContext.
		[ context notNil ] whileTrue: [
			twoArgBlock value: process value: context.
			context _ context sender ]]! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/9/2019 15:54:54'!
                              processesWithTopContextDo: aBlock
	"Iterate over processes that can run. Include top context in block arguments."
	"
	Processor processesWithTopContextDo: [ :p :c | p print. ('------->', c printString) print ].
	"
	self processesDo: [ :process |
		aBlock
			value: process
			value: (process isRunning ifTrue: [ thisContext ] ifFalse: [ process suspendedContext ]) ]! !
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 1/11/2019 16:52:15' prior: 16896514!
                become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	| oldObjects newObjects |
	oldObjects _ { self }.
	newObjects _ { otherObject }.
	self class == otherObject class ifFalse: [
		(Processor anyReceiverInStackIn: oldObjects orIn: newObjects) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: 'Can not do #become: Either receiver or argument has some method currently in execution.']].
	oldObjects elementsExchangeIdentityWith: newObjects! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/11/2019 16:52:24' prior: 16882299!
                             becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger."

	| oldObjects |
	oldObjects _ { self }.
	self class == otherObject class ifFalse: [
		(Processor anyReceiverInStackIn: oldObjects) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: 'Can not do #become: Receiver has some method currently in execution.']].
	oldObjects elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/11/2019 16:52:33' prior: 16882310!
            becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger."

	| oldObjects |
	oldObjects _ { self }.
	self class == otherObject class ifFalse: [
		(Processor anyReceiverInStackIn: oldObjects) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: 'Can not do #become: Receiver has some method currently in execution.']].
	oldObjects
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!Behavior methodsFor: 'private' stamp: 'jmv 1/11/2019 11:39:10' prior: 16784728!
              becomeCompact
	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."
	| cct index |

	Smalltalk isSpur ifTrue: [ ^ self halt: 'No Compact Classes support in Spur' ].
	self isWeak ifTrue:[ ^ self halt: 'You must not make a weak class compact' ].
	(Processor anyReceiverInStackIsKindOf: self)
		ifTrue: [ ^self halt: self name, ' has some (sub)instance with some method currently in execution.' ].
	cct _ Smalltalk compactClassesArray.
	(self indexIfCompact > 0 or: [cct includes: self])
		ifTrue: [^ self halt: self name, ' is already compact'].
	index _ cct indexOf: nil
		ifAbsent: [^ self halt: 'compact class table is full'].
	"Install this class in the compact class table"
	cct at: index put: self.
	"Update instspec so future instances will be compact"
	format _ format + (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Purge any old instances"
	Smalltalk garbageCollect.! !
!Behavior methodsFor: 'private' stamp: 'jmv 1/11/2019 11:39:04' prior: 16784797!
        becomeUncompact
	| cct index |
	cct _ Smalltalk compactClassesArray.
	(index _ self indexIfCompact) = 0
		ifTrue: [^ self].
	(Processor anyReceiverInStackIsKindOf: self)
		ifTrue: [ ^self halt: self name, ' has some (sub)instance with some method currently in execution.' ].
	(cct includes: self)
		ifFalse: [^ self halt  "inconsistent state"].
	"Update instspec so future instances will not be compact"
	format _ format - (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Make sure there are no compact ones left around"
	Smalltalk garbageCollect.
	"Remove this class from the compact class table"
	cct at: index put: nil.
! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/11/2019 16:55:48' prior: 16803207!
                class: oldClass instanceVariableNames: instVarString unsafe: unsafe
	"This is the basic initialization message to change the definition of
	an existing Metaclass"
	| instVars newClass needNew copyOfOldClass |
	instVars _ Scanner new scanFieldNames: instVarString.
	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].
		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil].
		(Processor anyReceiverInStackIsKindOf: oldClass) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: oldClass name, ' has some (sub)instance with some method currently in execution.'. ^nil ]].
	"See if we need a new subclass or not"
	needNew _ self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.
	needNew ifNil:[^nil]. "some error"
	needNew ifFalse:[^oldClass]. "no new class needed"

	"Create the new class"
	copyOfOldClass _ oldClass copy.
	newClass _ self 
		newSubclassOf: oldClass superclass 
		type: oldClass typeOfClass
		instanceVariables: instVars
		from: oldClass.
		
	newClass _ self recompile: false from: oldClass to: newClass mutate: false.
	self doneCompiling: newClass.
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/11/2019 16:56:13' prior: 16803265!
              name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory |
	instVars _ Scanner new scanFieldNames: instVarString.
	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass _ Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"
	copyOfOldClass _ oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil].
		(Processor anyReceiverInStackIsKindOf: oldClass) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: oldClass name, ' has some (sub)instance with some method currently in execution.'. ^nil ]].

	"See if we need a new subclass"
	needNew _ self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class"
		newClass _ self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass _ oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force _ (newClass declare: classVarString) | (newClass sharing: poolString).

	"... classify ..."
	newCategory _ category asSymbol.
	organization _ Smalltalk organization.
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	newClass _ self recompile: force from: oldClass to: newClass mutate: false.

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: category].
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/11/2019 11:58:48' prior: 16803437!
                               recompile: force from: oldClass to: newClass mutate: forceMutation
	"Do the necessary recompilation after changing oldClass to newClass.
	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass
	and all its subclasses. If forceMutation is true force a mutation even
	if oldClass and newClass are the same."

	oldClass
		ifNil: [^ newClass].

	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[
		^newClass].

	currentClassIndex _ 0.
	maxClassIndex _ oldClass withAllSubclasses size.

	(oldClass == newClass and:[forceMutation not]) ifTrue:[
		"Recompile from newClass without mutating"
		self informUserDuring:[
			newClass withAllSubclassesDo:[:cl|
				self showProgressFor: cl.
				cl compileAll]].
		^newClass].
	"Recompile and mutate oldClass to newClass"
	self informUserDuring:[
		self mutate: oldClass to: newClass.
	].
	^oldClass "now mutated to newClass"! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/11/2019 16:56:52' prior: 16804069!
  moveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName
	"Move the given instVar from srcClass to dstClass"
	| instancesOk |
	(srcClass instVarNames includes: instVarName)
		ifFalse:[^self error: instVarName,' is not an instance variable of ', srcClass name].
	(prevInstVarName isNil or:[dstClass instVarNames includes: prevInstVarName])
		ifFalse:[^self error: prevInstVarName, 'is not an instance variable of', dstClass name].
	instancesOk _ false.
	(srcClass inheritsFrom: dstClass) ifTrue:[
		"Move the instvar up the hierarchy."
		(Processor anyReceiverInStackIsKindOf: dstClass) ifTrue: [ 
			AttemptToMutateObjectInCallStack
				signal: dstClass name, ' has some (sub)instance with some method currently in execution.'  ^false ].
		instancesOk _ true.
		(self validateClass: srcClass forMoving: instVarName upTo: dstClass)
			ifFalse:[^false].
	].
	(dstClass inheritsFrom: srcClass) ifTrue:[
		"Move the instvar down the hierarchy"
		(Processor anyReceiverInStackIsKindOf: srcClass) ifTrue: [ 
			AttemptToMutateObjectInCallStack
				signal: srcClass name, ' has some (sub)instance with some method currently in execution.'  ^false ].
		instancesOk _ true.
		(self validateClass: srcClass forMoving: instVarName downTo: dstClass)
			ifFalse:[^false].
	].
	instancesOk ifFalse: [	"disjunt hierarchies"
		(Processor anyReceiverInStackIsKindOf: dstClass) ifTrue: [ 
			AttemptToMutateObjectInCallStack
				signal: dstClass name, ' has some (sub)instance with some method currently in execution.'  ^false ].
		(Processor anyReceiverInStackIsKindOf: srcClass) ifTrue: [ 
			AttemptToMutateObjectInCallStack
				signal: srcClass name, ' has some (sub)instance with some method currently in execution.'  ^false ]].
	^self silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName! !
!Array methodsFor: 'converting' stamp: 'jmv 1/11/2019 11:10:01' prior: 16779671!
elementsExchangeIdentityWith: otherArray
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.
	 At the same time, all pointers to the elements of otherArray are replaced by
	 pointers to the corresponding elements of this array.  The identityHashes remain
	 with the pointers rather than with the objects so that objects in hashed structures
	 should still be properly indexed after the mutation.

	Warning. This is a dangerous operation and it could lead to a crash if some object in receiver or argument is receiver of a method currently in execution. See #anyReceiverInStackIn: See senders for examples."

	<primitive: 128 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	ec == #'insufficient object memory' ifTrue:
		[| maxRequired |
		 "In Spur, two-way become may involve making each pair of objects into a forwarder into a copy of the other.
		 So if become fails with #'insufficient object memory', garbage collect, and if necessary, grow memory."
		 maxRequired := (self detectSum: [:obj | obj class byteSizeOfInstanceOfSize: obj basicSize])
						+ (otherArray detectSum: [:obj | obj class byteSizeOfInstanceOfSize: obj basicSize]).
		 (Smalltalk garbageCollectMost < maxRequired
		  and: [Smalltalk garbageCollect < maxRequired]) ifTrue:
			[Smalltalk growMemoryByAtLeast: maxRequired].
		 ^self elementsExchangeIdentityWith: otherArray].
	self primitiveFailed! !
!Array methodsFor: 'converting' stamp: 'jmv 1/11/2019 11:09:50' prior: 16779730!
             elementsForwardIdentityTo: otherArray
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.
	 The identityHashes remain with the pointers rather than with the objects so that
	 the objects in this array should still be properly indexed in any existing hashed
	 structures after the mutation.

	Warning. This is a dangerous operation and it could lead to a crash if some object in receiver or argument is receiver of a method currently in execution. See #anyReceiverInStackIn: See senders for examples."

	<primitive: 72 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	ec == #'insufficient object memory' ifTrue:
		[self error: 'The virtual machine is out-of-date.  Please upgrade.'].
	self primitiveFailed! !
!Array methodsFor: 'converting' stamp: 'jmv 1/11/2019 11:09:40' prior: 16779768!
       elementsForwardIdentityTo: otherArray copyHash: copyHash
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.
	 If copyHash is true, the identityHashes remain with the pointers rather than with the
	 objects so that the objects in the receiver should still be properly indexed in any
	 existing hashed structures after the mutation.  If copyHash is false, then the hashes
	 of the objects in otherArray remain unchanged.  If you know what you're doing this
	 may indeed be what you want.

	Warning. This is a dangerous operation and it could lead to a crash if some object in receiver or argument is receiver of a method currently in execution. See #anyReceiverInStackIn: See senders for examples."
	<primitive: 249 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	self primitiveFailed! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3576-dontBecomeObjectIfRunningSomeMethod-JuanVuletich-2019Jan11-16h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3576] on 14 January 2019 at 4:35:29 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/14/2019 16:34:53' prior: 50424555!
         knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !
!MessageNode methodsFor: 'equation translation' stamp: 'jmv 1/14/2019 16:15:00' prior: 16867989!
   arguments: list
	arguments := list asArray! !
!MessageNode methodsFor: 'cascading' stamp: 'jmv 1/14/2019 16:14:02' prior: 16868573!
                            receiver: rcvr arguments: args precedence: p

	receiver := rcvr.
	originalReceiver := rcvr copy.
	arguments := args asArray.
	originalArguments := arguments copy.
	sizes := Array new: arguments size.
	precedence := p! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3577-MessageNodeFix-JuanVuletich-2019Jan14-16h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3577] on 16 January 2019 at 8:40:56 am'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 1/16/2019 08:38:06'!
     allButFirstDo: block

	2 to: self size do:
		[:index | block value: (self at: index)]! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 1/16/2019 08:38:18'!
                    allButLastDo: block

	1 to: self size - 1 do:
		[:index | block value: (self at: index)]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3578-AddBack-allButFirstDo-allButLastDo-JuanVuletich-2019Jan16-08h38m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3564] on 16 January 2019 at 12:05:04 pm'!
!Preferences class methodsFor: 'code generation' stamp: 'KLG 1/16/2019 11:51:32'!
                 leftArrowAssignmentsInGeneratedCodeWithComputedDefault
	^ self
		valueOfFlag: #leftArrowAssignmentsInGeneratedCode
		ifAbsent: [ 
			self syntaxHighlightingAsYouTypeLeftArrowAssignment or: [
				self syntaxHighlightingAsYouTypeAnsiAssignment not ]].! !
!Browser methodsFor: 'class functions' stamp: 'KLG 1/16/2019 11:52:48' prior: 16791579!
           createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"
	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		aClass instVarNames do: [ :aName | | newMessage setter |
			(aClass canUnderstand: aName asSymbol) ifFalse: [
				newMessage _ aName , '
	"Answer the value of ' , aName , '"

	^ ' , aName.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ].
			(aClass canUnderstand: (setter _ aName , ':') asSymbol) ifFalse: [
				newMessage _ setter , ' anObject
	"Set the value of ' , aName , '"

	' , aName , ' ' ,
					(Preferences leftArrowAssignmentsInGeneratedCodeWithComputedDefault
						ifTrue: [ '_' ]
						ifFalse: [ ':=' ]) , ' anObject'.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ]]]! !
!Message methodsFor: 'stub creation' stamp: 'KLG 1/16/2019 11:51:59' prior: 50389604!
                    addSetterCodeOn: stream 
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: (Preferences leftArrowAssignmentsInGeneratedCodeWithComputedDefault
			ifTrue: [ ' _ ' ]
			ifFalse: [ ' := ' ]);
		nextPutAll: self arguments first argumentName ! !
!Preferences class methodsFor: 'standard queries' stamp: 'KLG 1/16/2019 12:03:07'!
                              leftArrowAssignmentsInGeneratedCode
	^ self
		valueOfFlag: #leftArrowAssignmentsInGeneratedCode
		ifAbsent: [ false ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3579-CodeGenerationHonorsAssignmentPreferences-KLG-ConsistentAssignment-In-Generated-Code-KLG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3564] on 17 January 2019 at 7:00:11 pm'!
!CodePackage methodsFor: 'enumerating' stamp: 'KLG 1/17/2019 18:40:59'!
           coreMethodsForFileinOf: aClass do: aBlock
	"Evaluate aBlock with the actual method objects in this package.
	Only enumerate those methods that might be needed for proper filein.
	such as #compilerClass."

	aClass organization categories do: [ :cat |
		(self isForeignClassExtension: cat) ifFalse: [
			(aClass organization listAtCategoryNamed: cat) do: [ :s |
				(self selectorNeededForFilein: s) ifTrue: [
					aBlock value: (self referenceForMethod: s ofClass: aClass) ]]]]! !
!CodePackage methodsFor: 'testing' stamp: 'KLG 1/17/2019 18:43:05'!
                            selectorNeededForFilein: aSelector
	"Answer true if aSelector might be needed for proper filein of the remaing methods."

	^ Metaclass isScarySelector: aSelector! !
!CodePackage methodsFor: 'saving' stamp: 'KLG 1/17/2019 18:54:50'!
                        write: classes methodsForFileinOn: aStream

	classes
		do: [ :class |
			self 
				writeCoreMethodsForFileinOf: class class on: aStream;
				writeCoreMethodsForFileinOf: class on: aStream ]
		displayingProgress: 'Saving methods...'! !
!CodePackage methodsFor: 'saving' stamp: 'KLG 1/17/2019 18:56:42'!
                  writeCoreMethodsForFileinOf: aClass on: aStream

	self coreMethodsForFileinOf: aClass do: [ :methodReference |
		methodReference isValid
			ifTrue: [
				self writeMethod: methodReference on: aStream ]]! !
!CodePackage methodsFor: 'enumerating' stamp: 'KLG 1/17/2019 18:44:19' prior: 50377154!
                          coreMethodsOf: aClass do: aBlock
	"Evaluate aBlock with the actual method objects in this package.
	
	Leave out all the methods needed for filein."

	aClass organization categories do: [ :cat |
		(self isForeignClassExtension: cat) ifFalse: [
			(aClass organization listAtCategoryNamed: cat) do: [ :s |
				(self selectorNeededForFilein: s) ifFalse: [
					aBlock value: (self referenceForMethod: s ofClass: aClass) ]]]]! !
!CodePackage methodsFor: 'saving' stamp: 'KLG 1/17/2019 18:55:00' prior: 50377176!
    write: classes methodsOn: aStream

	classes
		do: [ :class |
			self 
				writeCoreMethodsOf: class on: aStream;
			 	writeCoreMethodsOf: class class on: aStream ]
		displayingProgress: 'Saving methods...'! !
!CodePackage methodsFor: 'saving' stamp: 'KLG 1/17/2019 18:56:15' prior: 50400998!
                            writeOnStream: aStream

	| sortedClasses |
	aStream
		nextChunkPut: ('Description ', description) printString;
		newLine.
	self writeFeatureSpecOn: aStream.
	self writeSystemCategoriesOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self
			write: {codePackageClass} classDefinitionsOn: aStream;
			write: {codePackageClass} classCommentsOn: aStream;
			write: {codePackageClass} methodsOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' prePackageInstall'; newLine ].

	sortedClasses _ Array streamContents: [ :strm |
		self classesInSafeOrderDo: [ :cls |
			cls == self class ifFalse: [
				strm nextPut: cls ]]].
	self
		write: sortedClasses classDefinitionsOn: aStream;
		write: sortedClasses classCommentsOn: aStream;
		write: sortedClasses methodsForFileinOn: aStream;
		write: sortedClasses methodsOn: aStream.

	self
		sortedExtensionMethodsDo:  [ :methodReference |
			methodReference isValid ifTrue: [
				self writeMethod: methodReference on: aStream ]]
		displayingProgress: 'Saving extension methods...'.
	self write: sortedClasses initializersOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self write: { codePackageClass } initializersOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' postPackageInstall'; newLine ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3580-ScarySelectorsFirstInPackages-KLG-fileout-methods-for-filein-first-2019Jan17-16h55m-KLG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 11 January 2019 at 12:22:25 pm'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/9/2019 19:00:12' prior: 50424343!
                 computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClassOrEntries |

	id _ allSource copyFrom: range start to: range end.
	receiverClassOrEntries _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ specificModel classOfInstVarNamed: id ].
			[ #methodArg ] 		-> [ specificModel classOfTempVarNamed: id ].
			[ #tempVar ] 			-> [ specificModel classOfTempVarNamed: id ].
			[ #workspaceVar ]		-> [ specificModel classOfWorkspaceVarNamed: id ].
			[ #blockArg ]			-> [ specificModel classOfBlockArgNamed: id ].
			[ #blockTempVar ]		-> [ specificModel classOfBlockTempVarNamed: id ].
			[ #thisContext ] 		-> [ specificModel classOfThisContext ]. 
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #blockEnd ]			-> [ BlockClosure ].
			[ #arrayEnd ]			-> [ Array ].
			[ #rightBrace ]		-> [ Array ].
			[ #unary ]				-> [ self returnTypeOfUnaryMessage: id at: range ].
			[ #rightParenthesis ]  -> [ self returnTypeOfEnclosedExpressionAt: range ]. }
		otherwise: [ nil ].
	
	receiverClassOrEntries isCollection 
		ifTrue: [ self computeMessageEntriesForSelectors: receiverClassOrEntries ]
		ifFalse: [ 
"			Descomentar para que suceda solo para cuando el receiver es una clase"
			"(receiverClassOrEntries notNil and: [ receiverClassOrEntries isMeta ])"
			(receiverClassOrEntries notNil)
				ifTrue: [  self computeMessageForMetaclass: receiverClassOrEntries ] 
				ifFalse: [ self computeMessageEntries: receiverClassOrEntries ]]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/11/2019 12:17:09'!
                    computeMessageForMetaclass: aMetaclass 
	
	| selectorsToShow addedSelectorsFastSet current |
	
	true ifTrue: [ ^self computeMessageForMetaclassWithCategories: aMetaclass ].
	false ifTrue: [ ^self computeMessageForMetaclassAddingCategory: aMetaclass ].
	
	selectorsToShow := OrderedCollection new.
	addedSelectorsFastSet := IdentitySet new.
	current := aMetaclass.
	[ current notNil ] whileTrue: [ | currentSelectors |
		currentSelectors := current selectors select: [ :aSelector | (aSelector beginsWith: prefix) and: [ (addedSelectorsFastSet includes: aSelector) not ]].
		
		selectorsToShow addAll: currentSelectors sorted.
		addedSelectorsFastSet addAll: currentSelectors.
		
		current := current superclass.
		"Comentar/Descomentar abajo para poner separador por clase"
		"selectorsToShow add: '-- ', current name, ':'"].
	
	"Comentar/Descomentar abajo para poner separador con Object class"
	"selectorsToShow ifNotEmpty: [ selectorsToShow add: '-- ', current name ]."
	
	"self computeMessageEntries: Object class."
	"Falta sacar repetidos de entries"
	"entries := selectorsToShow asArray, entries."
	entries := selectorsToShow asArray.	

	"Comentar todo lo de arriba y descomentar esto para ver el comportamiento original"
	"
	self computeMessageEntries: aMetaclass .
	"
	   ! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/9/2019 19:01:26'!
        computeMessageForMetaclassAddingCategory: aMetaclass 
	
	| selectorsToShow addedSelectorsFastSet current |
	
	selectorsToShow := OrderedCollection new.
	addedSelectorsFastSet := IdentitySet new.
	current := aMetaclass.
	[ current notNil ] whileTrue: [ | currentSelectors organization |
		organization := current organization.
		currentSelectors := (current selectors select: [ :aSelector | (aSelector beginsWith: prefix) and: [ (addedSelectorsFastSet includes: aSelector) not ]]) sorted.
		currentSelectors do: [ :aSelector | selectorsToShow add: aSelector, ' | ', (organization categoryOfElement: aSelector) ].
		
		addedSelectorsFastSet addAll: currentSelectors.
		
		current := current superclass.
		"Comentar/Descomentar abajo para poner separador por clase"
		"selectorsToShow add: '-- ', current name, ':'"].
	
	"Comentar/Descomentar abajo para poner separador con Object class"
	selectorsToShow ifNotEmpty: [ selectorsToShow add: '-- ', current name ].
	
	self computeMessageEntries: Object class.
	"Falta sacar repetidos de entries"
	entries := selectorsToShow asArray, entries.
	
	"Comentar todo lo de arriba y descomentar esto para ver el comportamiento original"
	"
	self computeMessageEntries: aMetaclass .
	"
	   ! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/9/2019 19:01:35'!
                             computeMessageForMetaclassWithCategories: aMetaclass 
	
	| selectorsToShow categoriesWithSelectors addedSelectorsFastSet current |

	categoriesWithSelectors := OrderedDictionary new.
	addedSelectorsFastSet := IdentitySet new.
	current := aMetaclass.
	[ current notNil ] whileTrue: [ | currentSelectors organization |
		organization := current organization.
		organization categories do: [ :aCategory | 
			currentSelectors := (organization listAtCategoryNamed: aCategory) 
				select: [ :aSelector |  (aSelector beginsWith: prefix) and: [ (addedSelectorsFastSet includes: aSelector) not ] ].
			(categoriesWithSelectors at: aCategory ifAbsentPut: [ OrderedCollection new ]) addAll: currentSelectors.
			addedSelectorsFastSet addAll: currentSelectors ].
		
		current := current superclass].
	 
	selectorsToShow := OrderedCollection new.
	categoriesWithSelectors 
		at: 'instance creation' 
		ifPresent: [ :instanceCreationSelectors | 
			instanceCreationSelectors isEmpty ifFalse: [
				selectorsToShow add: '-- instance creation'; addAll: instanceCreationSelectors.
				categoriesWithSelectors removeKey: 'instance creation' ]].
		  	
	categoriesWithSelectors associationsDo: [ :categoryAndSelectors |
		categoryAndSelectors value isEmpty ifFalse: [
		selectorsToShow 
			add: '-- ', categoryAndSelectors key;
			addAll: categoryAndSelectors value ]].
		
	"Comentar/Descomentar abajo para poner separador con Object class"
	"selectorsToShow ifNotEmpty: [ selectorsToShow add: '-- ', current name ]."
	
	"Falta sacar repetidos de entries"
"	self computeMessageEntries: Object class.
	entries := selectorsToShow asArray, entries."
	entries := selectorsToShow asArray.
	
	"Comentar todo lo de arriba y descomentar esto para ver el comportamiento original"
	"
	self computeMessageEntries: aMetaclass .
	"
	   ! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3581-AutoCompleterEnhancements-HernanWilkinson-2019Jan08-17h37m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 17 January 2019 at 4:48:31 pm'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/17/2019 16:33:43' prior: 50427400!
               returnTypeOfEnclosedExpressionAt: aRange 

	Smalltalk isLiveTypingInstalled ifFalse: [ ^nil ].
	
	^self 
		withParserSourceMethodNodeDo: [ :methodNode | self returnTypeOfEnclosedExpresionIn: methodNode at: aRange end - 1 ]
		ifError: [ :anError | nil ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3582-AutoCompleterFix-HernanWilkinson-2019Jan11-12h22m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3562] on 18 January 2019 at 12:58:36 am'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/18/2019 00:58:19'!
                        typeOfCascadeReceiverAt: aRange 
	
	| positionBeforeSemiColon |
	
	Smalltalk isLiveTypingInstalled ifFalse: [ ^nil ].
	
	positionBeforeSemiColon := aRange end - 1.
	
	"I have to parse excluding the last semi-colon because if not a syntax error will be signaled 
	because the cascade message is not finished - Hernan"
	^self
		withMethodNodeOf: (parser source first: positionBeforeSemiColon) 
		do: [ :methodNode | self typeOfCascadeReceiverIn: methodNode at: positionBeforeSemiColon ]
		ifError: [ :anError | nil ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/18/2019 00:14:55'!
    withMethodNodeOf: aSourceCode do: doBlock ifError: anErrorBlock

	^ [[ doBlock value: (parser classOrMetaClass methodNodeFor: aSourceCode) ] 
		on: UndeclaredVariableReference 
		do: [  :anUndeclareVariableReference | anUndeclareVariableReference declareTempAndResume ]]
		on: Error
		do: anErrorBlock
		
	! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/18/2019 00:21:47'!
                    withMethodNodeOfAllSourceCodeDo: doBlock ifError: anErrorBlock

	^ self withMethodNodeOf: parser source do: doBlock ifError: anErrorBlock 
	! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'HAW 1/17/2019 23:26:04' prior: 50424017!
               shouldOpenMorphWhenNoPrefixFor: currentChar 
	
	^currentChar isAlphaNumeric 
		or: [ currentChar isRightBracket
		or: [ currentChar = $) 
		or: [ currentChar = $; ]]]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/17/2019 16:49:38' prior: 50414945!
                canComputeMessageEntriesFor: prevRange and: prevPrevRange

	^ prevRange notNil and: [ prevPrevRange isNil or: [ prevPrevRange rangeType ~= #binary ]]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/17/2019 23:33:22' prior: 50429301!
 computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClassOrEntries |

	id _ allSource copyFrom: range start to: range end.
	receiverClassOrEntries _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ specificModel classOfInstVarNamed: id ].
			[ #methodArg ] 		-> [ specificModel classOfTempVarNamed: id ].
			[ #tempVar ] 			-> [ specificModel classOfTempVarNamed: id ].
			[ #workspaceVar ]		-> [ specificModel classOfWorkspaceVarNamed: id ].
			[ #blockArg ]			-> [ specificModel classOfBlockArgNamed: id ].
			[ #blockTempVar ]		-> [ specificModel classOfBlockTempVarNamed: id ].
			[ #thisContext ] 		-> [ specificModel classOfThisContext ]. 
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #blockEnd ]			-> [ BlockClosure ].
			[ #arrayEnd ]			-> [ Array ].
			[ #rightBrace ]		-> [ Array ].
			[ #unary ]				-> [ self returnTypeOfUnaryMessage: id at: range ].
			[ #rightParenthesis ]  -> [ self returnTypeOfEnclosedExpressionAt: range ].
			[ #cascadeSeparator]	-> [ self typeOfCascadeReceiverAt: range ]. }
		otherwise: [ nil ].
	
	receiverClassOrEntries isCollection 
		ifTrue: [ self computeMessageEntriesForSelectors: receiverClassOrEntries ]
		ifFalse: [ 
"			Descomentar para que suceda solo para cuando el receiver es una clase"
			"(receiverClassOrEntries notNil and: [ receiverClassOrEntries isMeta ])"
			(receiverClassOrEntries notNil)
				ifTrue: [  self computeMessageForMetaclass: receiverClassOrEntries ] 
				ifFalse: [ self computeMessageEntries: receiverClassOrEntries ] ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/18/2019 00:21:47' prior: 50429525!
                               returnTypeOfEnclosedExpressionAt: aRange 

	Smalltalk isLiveTypingInstalled ifFalse: [ ^nil ].
	
	^self 
		withMethodNodeOfAllSourceCodeDo: [ :methodNode | self returnTypeOfEnclosedExpresionIn: methodNode at: aRange end - 1 ]
		ifError: [ :anError | nil ]! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/18/2019 00:45:13' prior: 50427412!
                       returnTypeOfUnaryMessage: aSelector at: aRange 
	
	Smalltalk isLiveTypingInstalled ifFalse: [ ^nil ].
	
	^self
		withMethodNodeOfAllSourceCodeDo: [ :methodNode | self returnTypeOfNodeUnderCursorIn: methodNode at: aRange end]
		ifError: [ :anError | nil ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3583-AutocompleterHandlesCascade-HernanWilkinson-2019Jan17-16h48m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3583] on 18 January 2019 at 12:32:51 pm'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 1/18/2019 12:32:36' prior: 50429601!
                           computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id receiverClassOrEntries |

	id _ allSource copyFrom: range start to: range end.
	receiverClassOrEntries _ range rangeType 
		caseOf: {
			[ #globalVar ] 		-> [ (Smalltalk at: id asSymbol) class ].
			[ #self ] 				-> [ contextClass ].
			[ #super ] 				-> [ contextClass superclass ].
			[ #true ] 				-> [ True ].
			[ #false ] 				-> [ False ].
			[ #nil ] 				-> [ UndefinedObject ].
			[ #character ] 		-> [ id first class ].
			[ #number ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #string ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #symbol ] 			-> [ self classOfLiteral: id in: contextClass ].
			[ #stringSymbol ]  	-> [ self classOfLiteral: id in: contextClass ].
			[ #instVar ] 			-> [ specificModel classOfInstVarNamed: id ].
			[ #methodArg ] 		-> [ specificModel classOfTempVarNamed: id ].
			[ #tempVar ] 			-> [ specificModel classOfTempVarNamed: id ].
			[ #workspaceVar ]		-> [ specificModel classOfWorkspaceVarNamed: id ].
			[ #blockArg ]			-> [ specificModel classOfBlockArgNamed: id ].
			[ #blockTempVar ]		-> [ specificModel classOfBlockTempVarNamed: id ].
			[ #thisContext ] 		-> [ specificModel classOfThisContext ]. 
			[ #classVar ] 			-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #poolConstant ] 	-> [ self classOfLocalBindingNamed: id in: contextClass ].
			[ #blockEnd ]			-> [ BlockClosure ].
			[ #arrayEnd ]			-> [ Array ].
			[ #rightBrace ]		-> [ Array ].
			[ #unary ]				-> [ self returnTypeOfUnaryMessage: id at: range ].
			[ #rightParenthesis ] -> [ self returnTypeOfEnclosedExpressionAt: range ].
			[ #cascadeSeparator]	-> [ self typeOfCascadeReceiverAt: range ]. }
		otherwise: [ nil ].
	
	receiverClassOrEntries isCollection 
		ifTrue: [ self computeMessageEntriesForSelectors: receiverClassOrEntries ]
		ifFalse: [ self computeMessageEntries: receiverClassOrEntries ]! !

SmalltalkCompleter removeSelector: #computeMessageForMetaclass:!

SmalltalkCompleter removeSelector: #computeMessageForMetaclass:!

SmalltalkCompleter removeSelector: #computeMessageForMetaclassAddingCategory:!

SmalltalkCompleter removeSelector: #computeMessageForMetaclassAddingCategory:!

SmalltalkCompleter removeSelector: #computeMessageForMetaclassWithCategories:!

SmalltalkCompleter removeSelector: #computeMessageForMetaclassWithCategories:!

SmalltalkCompleter removeSelector: #withParserSourceMethodNodeDo:ifError:!

SmalltalkCompleter removeSelector: #withParserSourceMethodNodeDo:ifError:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3584-AutoCompleter-removeExperimentalCode-HernanWilkinson-2019Jan18-12h29m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3584] on 21 January 2019 at 12:44:58 pm'!
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/21/2019 12:43:41'!
             anyReceiverInStackIn: anArray orIn: anotherArray runningProcessSearchStart: aContextOrNil
	"Iterate over all methods currently in execution. Answer true if in any of them 'self' an element of argument"
	"
	Processor anyReceiverInStackIn: {} orIn: { self runningWorld } runningProcessSearchStart: nil
	Processor anyReceiverInStackIn: {} orIn: { Object new } runningProcessSearchStart: nil
	"
	self
		processesDo: [ :p | ] withStackFramestDo: [ :p :c | | r |
			r _ c receiver.
			(anArray statePointsTo: r)
				ifTrue: [ ^ true ].
			(anotherArray statePointsTo: r)
				ifTrue: [ ^ true ]]
		runningProcessSearchStart: aContextOrNil.
	^ false! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/21/2019 12:43:55'!
              anyReceiverInStackIn: anArray runningProcessSearchStart: aContextOrNil
	"Iterate over all methods currently in execution. Answer true if in any of them 'self' an element of argument"
	"
	Processor anyReceiverInStackIn: { self runningWorld } runningProcessSearchStart: nil
	Processor anyReceiverInStackIn: { Object new } runningProcessSearchStart: nil
	"
	self
		processesDo: [ :p | ] withStackFramestDo: [ :p :c |
			(anArray statePointsTo: c receiver)
				ifTrue: [ ^ true ]]
		runningProcessSearchStart: aContextOrNil.
	^ false! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/21/2019 12:25:46'!
                              processesDo: aBlock withStackFramestDo: twoArgBlock runningProcessSearchStart: aContextOrNil
	"Iterate over processes that can run.
	For each process, iterate over stack frames (i.e. contexts)."
	"
	Processor
		processesDo: [ :p |
			'--------------' print.
			p print. 
			'--------------' print ]
		withStackFramestDo: [ :p :c |
			('        ', c printString) print ].
	"
	self
		processesWithTopContextDo: [ :process :topContext | | context |
			aBlock value: process.
			context _ topContext.
			[ context notNil ] whileTrue: [
				twoArgBlock value: process value: context.
				context _ context sender ]]
		runningProcessSearchStart: aContextOrNil! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/21/2019 12:25:07'!
  processesWithTopContextDo: aBlock runningProcessSearchStart: aContextOrNil
	"Iterate over processes that can run. Include top context in block arguments."
	"
	Processor processesWithTopContextDo: [ :p :c | p print. ('------->', c printString) print ].
	"
	self processesDo: [ :process |
		aBlock
			value: process
			value: (process isRunning ifTrue: [ aContextOrNil ifNil: [thisContext] ] ifFalse: [ process suspendedContext ]) ]! !
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 1/21/2019 12:37:38' prior: 50428308!
                become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	| oldObjects newObjects |
	oldObjects _ { self }.
	newObjects _ { otherObject }.
	self class == otherObject class ifFalse: [
		(Processor anyReceiverInStackIn: oldObjects orIn: newObjects runningProcessSearchStart: thisContext sender) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: 'Can not do #become: Either receiver or argument has some method currently in execution.']].
	oldObjects elementsExchangeIdentityWith: newObjects! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/21/2019 12:37:46' prior: 50428332!
               becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger."

	| oldObjects |
	oldObjects _ { self }.
	self class == otherObject class ifFalse: [
		(Processor anyReceiverInStackIn: oldObjects runningProcessSearchStart: thisContext sender) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: 'Can not do #become: Receiver has some method currently in execution.']].
	oldObjects elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/21/2019 12:37:50' prior: 50428351!
                              becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger."

	| oldObjects |
	oldObjects _ { self }.
	self class == otherObject class ifFalse: [
		(Processor anyReceiverInStackIn: oldObjects runningProcessSearchStart: thisContext sender) ifTrue: [
			AttemptToMutateObjectInCallStack
				signal: 'Can not do #become: Receiver has some method currently in execution.']].
	oldObjects
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/21/2019 12:34:33' prior: 50428215!
                    anyReceiverInStackIn: anArray
	"Iterate over all methods currently in execution. Answer true if in any of them 'self' an element of argument"
	"
	Processor anyReceiverInStackIn: { self runningWorld }
	Processor anyReceiverInStackIn: { Object new }
	"
	self
		processesDo: [ :p | ]
		withStackFramestDo: [ :p :c |
			(anArray statePointsTo: c receiver)
				ifTrue: [ ^ true ]]
		runningProcessSearchStart: nil.
	^ false! !
!ProcessorScheduler methodsFor: 'accessing' stamp: 'jmv 1/21/2019 12:34:49' prior: 50428248!
                             anyReceiverInStackIsKindOf: aClass
	"Iterate over all methods currently in execution. Answer true if in any of them 'self' is a (sub)instance of aClass"
	"
	Processor anyReceiverInStackIsKindOf: Morph
	Processor anyReceiverInStackIsKindOf: DifferenceFinder
	"
	self
		processesDo: [ :p | ]
		withStackFramestDo: [ :p :c |
			(c receiver isKindOf: aClass)
				ifTrue: [ ^ true ]]
		runningProcessSearchStart: nil.
	^ false! !

ProcessorScheduler removeSelector: #anyReceiverInStackIn:orIn:!

ProcessorScheduler removeSelector: #anyReceiverInStackIn:orIn:!

ProcessorScheduler removeSelector: #processesDo:withStackFramestDo:!

ProcessorScheduler removeSelector: #processesDo:withStackFramestDo:!

ProcessorScheduler removeSelector: #processesWithTopContextDo:!

ProcessorScheduler removeSelector: #processesWithTopContextDo:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3585-becomeStackCheckStartsAtSender-JuanVuletich-2019Jan21-12h39m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3584] on 21 January 2019 at 12:19:58 pm'!
!Debugger methodsFor: 'private' stamp: 'jmv 1/21/2019 12:17:19'!
         fixReceiverInspector
	"Make receiver inspector work on current context receiver.
	Create a new inspector if needed"

	| currentReceiver requiredInspectorClass oldInspectorClass |
	currentReceiver _ self receiver.
	requiredInspectorClass _ currentReceiver inspectorClass.
	oldInspectorClass _ receiverInspector class.
	
	oldInspectorClass ~= requiredInspectorClass ifTrue: [
		oldInspectorClass format = requiredInspectorClass format
			ifTrue: [receiverInspector primitiveChangeClassTo: requiredInspectorClass basicNew]
			ifFalse: [receiverInspector becomeForward: (requiredInspectorClass basicNew copyFrom: receiverInspector)]].
	
	receiverInspector object: currentReceiver! !
!Debugger methodsFor: 'private' stamp: 'jmv 1/21/2019 12:17:40' prior: 16830041!
        contextStackIndex: arg1 oldContextWas: arg2
	| temp3 temp4 temp5 |
	contextStackIndex _ arg1.
	arg1 = 0 ifTrue: [
		currentCompiledMethod _ nil.
		self changed: #contextStackIndex.
		self acceptedContentsChanged.
		contextVariablesInspector object: nil.
		self fixReceiverInspector.
		^ self ].
	temp4 _ contextVariablesInspector selectedSlotName.
	temp3 _ arg2
		ifNil: [ true ]
		ifNotNil: [ arg2 method ~~ (currentCompiledMethod _ self selectedContext method) ].
	temp3 ifTrue: [
		self acceptedContentsChanged.
		self pcRange ].
	self changed: #contextStackIndex.
	self triggerEvent: #decorateButtons.
	contextVariablesInspector object: self selectedContext.
	((temp5 _ contextVariablesInspector fieldList indexOf: temp4) ~= 0 and: [
		temp5 ~= contextVariablesInspector selectionIndex ]) ifTrue: [
			contextVariablesInspector toggleIndex: temp5 ].
	self fixReceiverInspector.
	temp3 ifFalse: [ self changed: #contentsSelection ].! !
!Inspector methodsFor: 'initialization' stamp: 'jmv 1/21/2019 12:12:06' prior: 50367138!
                            inspect: anObject 
	"Initialize the receiver so that it is inspecting anObject. There is no current selection."
	
	object := anObject. 
	self initialize! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3586-AvoidDangerousSelfBecomeInInspector-JuanVuletich-2019Jan21-12h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3586] on 22 January 2019 at 11:53:37 am'!
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 1/22/2019 10:51:42' prior: 16840926!
       placesToLookForPackagesDo: aBlock

	| base myDir |

	"Look inside my own folder"
	pathName ifNotNil: [
		myDir _ pathName asFileEntry parent.
		aBlock value: myDir ].

	"Look in Cuis image folder and reasonable subfolders"
	base _ DirectoryEntry smalltalkImageDirectory.
	base allDirectoriesDo: aBlock.
	
	"Look in parent directory and reasonable subfolders. 
	Useful when image is stored in a subdirectory of the main app directory.
	This could be the case when the package comes from a 'main' git repo, and image is copied from gitHub"
	base parent allDirectoriesDo: aBlock.

	"Also look in host OS current directory"
	(base ~= DirectoryEntry currentDirectory and: [base parent ~= DirectoryEntry currentDirectory])
		ifTrue: [
			base _ DirectoryEntry currentDirectory.
			base allDirectoriesDo: aBlock ]! !

FeatureRequirement removeSelector: #inPackagesSubtreeOf:do:!

FeatureRequirement removeSelector: #inPackagesSubtreeOf:do:!

FeatureRequirement removeSelector: #withPackageSubfoldersOf:do:!

FeatureRequirement removeSelector: #withPackageSubfoldersOf:do:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3587-SearchPackagesInAllFolderTree-JuanVuletich-2019Jan22-11h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3587] on 22 January 2019 at 12:56:51 pm'!
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 1/22/2019 12:29:29' prior: 16891757!
                            fileIn
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler."

	self fileInAnnouncing: 'Reading ' , self name.
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ]! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 1/22/2019 12:25:39' prior: 50405824!
                   fileInAnnouncing: announcement
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	Utilities logsUserChanges: false.
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :barBlock | 
			[ self atEnd ] whileFalse: [
					barBlock value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, 
									because next line is a doit that does the stuff
									(or because it is handled elsewhere)"
									(chunk beginsWith: 'description:  ')
									| (chunk beginsWith: 'provides: ')
									| (chunk beginsWith: 'requires: ')
									| (chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Compiler evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Compiler evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex pass ]
										]] 
							on: InMidstOfFileinNotification, UndeclaredVariableWarning
							do: [ :ex | ex resume: true ] ].
			].
	"Note:  The main purpose of this banner is to flush the changes file."
	Utilities logsUserChanges: true.
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !
!FileStream methodsFor: 'fileIn/Out' stamp: 'jmv 1/22/2019 12:27:38' prior: 16843707!
fileIn
	"Guarantee that the receiver is readOnly before fileIn for efficiency and
	to eliminate remote sharing conflicts."

	self readOnly.
	self fileInAnnouncing: 'Loading ', self localName.
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].
! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 1/22/2019 12:56:06' prior: 50422015!
                 install: aFileStream
	"Installs the package. Replace all existing code in the CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].

	"Create, install and answer a (sub)instance of CodePackage"
	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS _ ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS _ nil ].
		pckClass _ CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				ee fileInDefinitionAndMetaclass.
				pckClass _ Smalltalk at: ee name ]].
		newCodePackage _ pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].
	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	^newCodePackage! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3588-AvoidUndeclaredWarningsDuringPackageInstall-JuanVuletich-2019Jan22-12h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3588] on 23 January 2019 at 2:56:32 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/23/2019 14:56:17' prior: 50428862!
                       knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3589-AddPaoloAsKnownAuthor-JuanVuletich-2019Jan23-14h56m-jmv.1.cs.st----!

----SNAPSHOT----#(28 January 2019 10:39:22.58203 am) Cuis5.0-3589-v3.image priorSource: 3065078!

----QUIT----#(28 January 2019 10:39:44.870652 am) Cuis5.0-3589-v3.image priorSource: 3163314!

----STARTUP----#(16 February 2019 9:33:12.580539 pm) as /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/Cuis5.0-3589-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3589] on 29 January 2019 at 1:03:47 pm'!

Error subclass: #MethodInCallStackToBecomeInvalid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #MethodInCallStackToBecomeInvalid category: #'Exceptions Kernel'!
Error subclass: #MethodInCallStackToBecomeInvalid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!MethodInCallStackToBecomeInvalid commentStamp: '<historical>' prior: 0!
                            A become operation tries to mutate an object that is the receiver ('self') in a method currently in execution, and part of the stack of calls of some process. This would render the method invalid and is potentially catastrophic.!
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 1/29/2019 12:03:51' prior: 50429881!
                            become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	| selfMethod otherObjectMethod selector contextReceiver |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				contextReceiver _ context receiver.
				(self == contextReceiver or: [ otherObject == contextReceiver ]) ifTrue: [
					selector _ context method selector.
					selfMethod _ self class lookupSelector: selector.
					otherObjectMethod _ otherObject class lookupSelector: selector.
					selfMethod = otherObjectMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: contextReceiver class name, ' has some instance running #', selector, ' that would become invalid.'.
						^ true ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsExchangeIdentityWith: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/29/2019 12:03:48' prior: 50429906!
          becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger."

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, ' that would become invalid.'.
						^ true ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/29/2019 12:03:50' prior: 50429927!
                      becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger."

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :proces :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, ' that would become invalid.'.
						^ true ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self }
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!Behavior methodsFor: 'private' stamp: 'jmv 8/16/2016 09:31:16' prior: 50428374!
                         becomeCompact
	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."
	| cct index |

	Smalltalk isSpur ifTrue: [^ self halt: 'No Compact Classes support in Spur'].
	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].
	cct _ Smalltalk compactClassesArray.
	(self indexIfCompact > 0 or: [cct includes: self])
		ifTrue: [^ self halt: self name , 'is already compact'].
	index _ cct indexOf: nil
		ifAbsent: [^ self halt: 'compact class table is full'].
	"Install this class in the compact class table"
	cct at: index put: self.
	"Update instspec so future instances will be compact"
	format _ format + (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Purge any old instances"
	Smalltalk garbageCollect.! !
!Behavior methodsFor: 'private' stamp: 'jmv 11/27/2008 16:05' prior: 50428414!
     becomeUncompact
	| cct index |
	cct _ Smalltalk compactClassesArray.
	(index _ self indexIfCompact) = 0
		ifTrue: [^ self].
	(cct includes: self)
		ifFalse: [^ self halt  "inconsistent state"].
	"Update instspec so future instances will not be compact"
	format _ format - (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Make sure there are no compact ones left around"
	Smalltalk garbageCollect.
	"Remove this class from the compact class table"
	cct at: index put: nil.
! !
!ClassDescription methodsFor: 'initialization' stamp: 'jmv 1/29/2019 12:03:46' prior: 16807271!
     updateInstancesFrom: oldClass
	"Recreate any existing instances of the argument, oldClass, as instances of 
	 the receiver, which is a newly changed class. Permute variables as necessary,
	 and forward old instances to new instances.. Answer nil to defeat any clients
	 that expected the old behaviour of answering the array of old instances."
	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:"
	| newMethod oldMethod selector |
	Processor 
		processesDo: [ :p | ]
		withStackFramestDo: [ :process :context |
			(context receiver isKindOf: oldClass) ifTrue: [
				selector _ context method selector.
				oldMethod _ oldClass lookupSelector: selector.
				newMethod _ self lookupSelector: selector.
				oldMethod = newMethod ifFalse: [
					MethodInCallStackToBecomeInvalid
						signal: self class name, ' has some instance running ', oldMethod printString, ' that would become invalid.'.
					^nil ]]]
		runningProcessSearchStart: nil.
	self updateInstances: oldClass allInstances asArray from: oldClass isMeta: self isMeta.
	^nil

"This attempts to crash the VM by stepping off the end of an instance.
 As the doctor says, do not do this."
"	| crashingBlock class |
	class := Object subclass: #CrashTestDummy
		instanceVariableNames: 'instVar'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	class compile:'instVar: value instVar := value'.
	class compile:'crashingBlock ^[instVar]'.
	crashingBlock := (class new) instVar: 42; crashingBlock.
	Object subclass: #CrashTestDummy
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	crashingBlock value"! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 5/20/2015 12:51' prior: 50428439!
               class: oldClass instanceVariableNames: instVarString unsafe: unsafe
	"This is the basic initialization message to change the definition of
	an existing Metaclass"
	| instVars newClass needNew copyOfOldClass |
	instVars _ Scanner new scanFieldNames: instVarString.
	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].
		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].
	"See if we need a new subclass or not"
	needNew _ self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.
	needNew ifNil:[^nil]. "some error"
	needNew ifFalse:[^oldClass]. "no new class needed"

	"Create the new class"
	copyOfOldClass _ oldClass copy.
	newClass _ self 
		newSubclassOf: oldClass superclass 
		type: oldClass typeOfClass
		instanceVariables: instVars
		from: oldClass.
		
	newClass _ self recompile: false from: oldClass to: newClass mutate: false.
	self doneCompiling: newClass.
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 5/20/2015 12:51' prior: 50428488!
                         name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory |
	instVars _ Scanner new scanFieldNames: instVarString.
	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass _ Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"
	copyOfOldClass _ oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew _ self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class"
		newClass _ self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass _ oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force _ (newClass declare: classVarString) | (newClass sharing: poolString).

	"... classify ..."
	newCategory _ category asSymbol.
	organization _ Smalltalk organization.
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	newClass _ self recompile: force from: oldClass to: newClass mutate: false.

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: category].
	^newClass! !
!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:40' prior: 50428635!
                     moveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName
	"Move the given instVar from srcClass to dstClass"
	(srcClass instVarNames includes: instVarName)
		ifFalse:[^self error: instVarName,' is not an instance variable of ', srcClass name].
	(prevInstVarName isNil or:[dstClass instVarNames includes: prevInstVarName])
		ifFalse:[^self error: prevInstVarName, 'is not an instance variable of', dstClass name].
	(srcClass inheritsFrom: dstClass) ifTrue:[
		"Move the instvar up the hierarchy."
		(self validateClass: srcClass forMoving: instVarName upTo: dstClass)
			ifFalse:[^false].
	].
	(dstClass inheritsFrom: srcClass) ifTrue:[
		"Move the instvar down the hierarchy"
		(self validateClass: srcClass forMoving: instVarName downTo: dstClass)
			ifFalse:[^false].
	].
	^self silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName! !

ProcessorScheduler removeSelector: #anyReceiverInStackIn:orIn:runningProcessSearchStart:!

ProcessorScheduler removeSelector: #anyReceiverInStackIn:orIn:runningProcessSearchStart:!

ProcessorScheduler removeSelector: #anyReceiverInStackIn:runningProcessSearchStart:!

ProcessorScheduler removeSelector: #anyReceiverInStackIn:runningProcessSearchStart:!

ProcessorScheduler removeSelector: #anyReceiverInStackIsKindOf:!

ProcessorScheduler removeSelector: #anyReceiverInStackIsKindOf:!

Smalltalk removeClassNamed: #AttemptToMutateObjectInCallStack!

Smalltalk removeClassNamed: #AttemptToMutateObjectInCallStack!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3590-BetterCheckForInvalidMethodsInCallStack-JuanVuletich-2019Jan29-12h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3590] on 30 January 2019 at 11:26:24 am'!
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 1/30/2019 11:26:18' prior: 16804333!
                       update: oldClass to: newClass
	"Convert oldClass, all its instances and possibly its meta class into newClass,
	 instances of newClass and possibly its meta class. The process is surprisingly
	 simple in its implementation and surprisingly complex in its nuances and potentially
	 bad side effects.
	 We can rely on two assumptions (which are critical):
		#1: The method #updateInstancesFrom: will not create any lasting pointers to
			 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do
			 a become of the old vs. the new instances and therefore it will not create
			 pointers to *new* instances before the #become: which are *old* afterwards)
		#2: The non-preemptive execution of the critical piece of code guarantees that
			 nobody can get a hold by 'other means' (such as process interruption and
			 reflection) on the old instances.
	 Given the above two, we know that after #updateInstancesFrom: there are no pointers
	 to any old instances. After the forwarding become there will be no pointers to the old
	 class or meta class either.
	<preSpur> Meaning that if we throw in a nice fat GC at the end of the critical block, everything will 
	be gone (but see the comment right there). </preSpur> 
	 Andreas Raab, 2/27/2003 23:42"
	| meta |
	meta := oldClass isMeta.
	"Note: Everything from here on will run without the ability to get interrupted
	to prevent any other process to create new instances of the old class."
	["Note: The following removal may look somewhat obscure and needs an explanation.
	  When we mutate the class hierarchy we create new classes for any existing subclass.
	  So it may look as if we don't have to remove the old class from its superclass. However,
	  at the top of the hierarchy (the first class we reshape) that superclass itself is not newly
	  created so therefore it will hold both the oldClass and newClass in its (obsolete or not)
	  subclasses. Since the #become: below will transparently replace the pointers to oldClass
	  with newClass the superclass would have newClass in its subclasses TWICE. With rather
	  unclear effects if we consider that we may convert the meta-class hierarchy itself (which
	  is derived from the non-meta class hierarchy).
	  Due to this problem ALL classes are removed from their superclass just prior to converting
	  them. Here, breaking the superclass/subclass invariant really doesn't matter since we will
	  effectively remove the oldClass 
	(<spur>becomeForward:</spur> or <preSpur>become+GC</preSpur>) just a few lines below."

		"Convert the instances of oldClass into instances of newClass"
		newClass updateInstancesFrom: oldClass.

		oldClass superclass removeSubclass: oldClass.
		oldClass superclass removeObsoleteSubclass: oldClass.

		"make sure that the VM cache is clean"
		oldClass methodDict do: [:cm | cm flushCache].

		meta
			ifTrue:
				[oldClass becomeForward: newClass.
				 oldClass updateMethodBindingsTo: oldClass binding]
			ifFalse:
				[{oldClass. oldClass class} elementsForwardIdentityTo: {newClass. newClass class}.
				 oldClass updateMethodBindingsTo: oldClass binding.
				 oldClass class updateMethodBindingsTo: oldClass class binding].

 Smalltalk isSpur
	ifTrue: [
		"eem 5/31/2014 07:22 At this point there used to be a garbage collect whose purpose was
		 to ensure no old instances existed after the becomeForward:.  Without the GC it was possible
		 to resurrect old instances using e.g. allInstancesDo:.  This was because the becomeForward:
		 updated references from the old objects to new objects but didn't destroy the old objects.
		 But as of late 2013/early 2014 becomeForward: has been modified to free all the old objects."
		]

	ifFalse: [
		"jmv: Squeak 4.6 (pre Spur) includes the GC. So, do it if not Spur.
		Not really sure if needed on newer Cog and Stack non-Spur VMs.
		Not sure if needed for SqueakJS.
		Remove it when we are sure.
		
		Original note by Andreas Raab below."
		Smalltalk garbageCollect.
		"Warning: Read this before you even think about removing the GC. Yes, it slows us down. Quite heavily if you have a large image. However, there's no good and simple alternative here, since unfortunately, #become: does change class pointers. What happens is that after the above become all of the instances of the old class will have a class pointer identifying them as instances of newClass. If we get our hands on any of these instances we will break immediately since their expected instance layout (that of its class, e.g., newClass) will not match their actual instance layout (that of oldClass). And getting your hands on any of those instances is really simple - just reshaping one class two times in rapid succession will do it. Reflection techniques, interrupts, etc. will only add to this problem. In the case of Metaclass things get even worse since when we recompile the entire class hierarchy we will recompile both, Metaclass and its instances (and some of its instances will have the old and some the new layout).
		The only easy solution to this problem would be to 'fix up' the class pointers of the old instances to point to the old class (using primitiveChangeClassTo:). But this won't work either - as we do a one-way become we would have to search the entire object memory for the oldClass and couldn't even clearly identify it unless we give it some 'special token' which sounds quite error-prone. If you really need to get rid of the GC here are some alternatives:
		On the image level, one could create a copy of the oldClass before becoming it into the new class and, after becoming it, 'fix up' the old instances. That would certainly work but it sounds quite complex, as we need to make sure we're not breaking any of the superclass/subclass meta/non-meta class variants.
		Alternatively, fix up #becomeForward on the VM-level to 'dump the source objects' of #become. This would be quite doable (just 'convert' them into a well known special class such as bitmap) yet it has problems if (accidentally or not) one of the objects in #become: appears on 'both sides of the fence' (right now, this will work ... in a way ... even though the consequences are unclear).
		Another alternative is to provide a dedicated primitive for this (instead of using it implicitly in become) which would allow us to dump all the existing instances right here. This is equivalent to a more general primitiveChangeClassTo: and might be worthwhile but it would likely have to keep in mind the differences between bits and pointer thingies etc.
		Since all of the alternatives seem rather complex and magical compared to a straight-forward GC it seems best to stick with the GC solution for now. If someone has a real need to fix this problem, that person will likely be motivated enough to check out the alternatives. Personally I'd probably go for #1 (copy the old class and remap the instances to it) since it's a solution that could be easily reverted from within the image if there's any problem with it.
		 Andreas Raab, 2/27/2003 23:42"
		]
	] valueUnpreemptively! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3591-AvoidCrashWhenClassMutationFails-JuanVuletich-2019Jan30-11h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3591] on 30 January 2019 at 11:54:45 am'!
!ClassDescription methodsFor: 'initialization' stamp: 'jmv 1/30/2019 11:54:25' prior: 50430696!
                  updateInstancesFrom: oldClass
	"Recreate any existing instances of the argument, oldClass, as instances of 
	 the receiver, which is a newly changed class. Permute variables as necessary,
	 and forward old instances to new instances.. Answer nil to defeat any clients
	 that expected the old behaviour of answering the array of old instances."
	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:"
	| newMethod oldMethod selector |
	Processor 
		processesDo: [ :p | ]
		withStackFramestDo: [ :process :context |
			(context receiver isKindOf: oldClass) ifTrue: [
				selector _ context method selector.
				oldMethod _ oldClass lookupSelector: selector.
				newMethod _ self lookupSelector: selector.
				oldMethod = newMethod ifFalse: [
					MethodInCallStackToBecomeInvalid
						signal: self class name, ' has some instance running #', selector, ' that would become invalid.'.
					^nil ]]]
		runningProcessSearchStart: nil.
	self updateInstances: oldClass allInstances asArray from: oldClass isMeta: self isMeta.
	^nil

"This attempts to crash the VM by stepping off the end of an instance.
 As the doctor says, do not do this."
"	| crashingBlock class |
	class := Object subclass: #CrashTestDummy
		instanceVariableNames: 'instVar'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	class compile:'instVar: value instVar := value'.
	class compile:'crashingBlock ^[instVar]'.
	crashingBlock := (class new) instVar: 42; crashingBlock.
	Object subclass: #CrashTestDummy
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	crashingBlock value"! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3592-tweak-JuanVuletich-2019Jan30-11h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3592] on 30 January 2019 at 3:09:13 pm'!

Exception subclass: #MethodInCallStackToBecomeInvalid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #MethodInCallStackToBecomeInvalid category: #'Exceptions Kernel'!
Exception subclass: #MethodInCallStackToBecomeInvalid
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!MethodInCallStackToBecomeInvalid methodsFor: 'as yet unclassified' stamp: 'jmv 1/30/2019 15:04:38'!
                          defaultAction

	self noHandler! !
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 1/30/2019 15:02:54' prior: 50430541!
become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	| selfMethod otherObjectMethod selector contextReceiver |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				contextReceiver _ context receiver.
				(self == contextReceiver or: [ otherObject == contextReceiver ]) ifTrue: [
					selector _ context method selector.
					selfMethod _ self class lookupSelector: selector.
					otherObjectMethod _ otherObject class lookupSelector: selector.
					selfMethod = otherObjectMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: contextReceiver class name, ' has some instance running #', selector, ' that would become invalid.' ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsExchangeIdentityWith: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/30/2019 15:02:40' prior: 50430577!
                        becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger."

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, ' that would become invalid.' ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/30/2019 15:02:48' prior: 50430607!
    becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger."

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :proces :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, ' that would become invalid.' ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self }
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!ClassDescription methodsFor: 'initialization' stamp: 'jmv 1/30/2019 15:02:33' prior: 50431200!
                        updateInstancesFrom: oldClass
	"Recreate any existing instances of the argument, oldClass, as instances of 
	 the receiver, which is a newly changed class. Permute variables as necessary,
	 and forward old instances to new instances.. Answer nil to defeat any clients
	 that expected the old behaviour of answering the array of old instances."
	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:"
	| newMethod oldMethod selector |
	Processor 
		processesDo: [ :p | ]
		withStackFramestDo: [ :process :context |
			(context receiver isKindOf: oldClass) ifTrue: [
				selector _ context method selector.
				oldMethod _ oldClass lookupSelector: selector.
				newMethod _ self lookupSelector: selector.
				oldMethod = newMethod ifFalse: [
					MethodInCallStackToBecomeInvalid
						signal: self class name, ' has some instance running #', selector, ' that would become invalid.' ]]]
		runningProcessSearchStart: nil.
	self updateInstances: oldClass allInstances asArray from: oldClass isMeta: self isMeta.
	^nil

"This attempts to crash the VM by stepping off the end of an instance.
 As the doctor says, do not do this."
"	| crashingBlock class |
	class := Object subclass: #CrashTestDummy
		instanceVariableNames: 'instVar'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	class compile:'instVar: value instVar := value'.
	class compile:'crashingBlock ^[instVar]'.
	crashingBlock := (class new) instVar: 42; crashingBlock.
	Object subclass: #CrashTestDummy
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	crashingBlock value"! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3593-MethodInCallStackToBecomeInvalid-isResumable-JuanVuletich-2019Jan30-15h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3593] on 1 February 2019 at 10:32:03 am'!
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 2/1/2019 10:27:32' prior: 16909686!
doIt
	"Set the context to include pool vars of the model.  Then evaluate.
	Print the result on the Transcript"
	^ self
		evaluateSelectionAndDo: [ :result |
			Transcript finishEntry.
			result print ]
		ifFail: nil
		profiled: false! !
!Transcript class methodsFor: 'private' stamp: 'jmv 2/1/2019 10:27:12' prior: 16938455!
                           finishEntry
	| newEntry |
	self unfinishedEntrySize > 1 ifTrue: [
		newEntry _ unfinishedEntry contents.
		unfinishedEntry reset.
		lastDisplayPosition _ 0.
		self addEntry: newEntry.
		self display ].! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3594-TranscriptTweaks-JuanVuletich-2019Feb01-10h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3593] on 1 February 2019 at 10:33:43 am'!
!BreakpointManager class methodsFor: 'private' stamp: 'KLG 1/31/2019 17:21:07' prior: 16791259!
    compilePrototype: aSymbol in: aClass 
	"Compile and return a new method containing a break statement"

	| source node trailer |
	trailer _ (aClass compiledMethodAt: aSymbol) trailer.
	source := self breakpointMethodSourceFor: aSymbol in: aClass.
	node := aClass compilerClass new
		compile: source
		in: aClass 
		notifying: nil 
		ifFail: [self error: '[breakpoint] unable to install breakpoint'].
	^node ifNotNil: [ node generate: trailer ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3595-BreakpointManagerFix-GeraldKlix-2019Feb01-10h32m-KLG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3595] on 1 February 2019 at 11:08:47 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 2/1/2019 11:08:32' prior: 50430298!
                    knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3596-AddSteveAsKnownAuthor-JuanVuletich-2019Feb01-11h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3589] on 1 February 2019 at 10:06:52 am'!
!MenuMorph methodsFor: 'events' stamp: 'SLD 2/1/2019 09:58:38' prior: 50339248!
 keyStroke: aKeyboardEvent 
	| matchString char asc selectable |
	char := aKeyboardEvent keyCharacter.
	asc := char numericValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
					selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: [
							"self delete."
							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			^self delete].
	(asc = 28 or: [asc = 29]) 
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
				ifFalse: [^ self]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := char = Character backspace 
				ifTrue: [
					matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3597-MenuMorphDropLeftRigh-SteveDavies-2019Jan31-17h38m-SLD.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3589] on 4 February 2019 at 3:31:26 am'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'AY 2/4/2019 03:26:10'!
                              atFront
	
	^owner firstSubmorph == self! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'AY 2/4/2019 03:26:20' prior: 16876877!
                            comeToFront

	self atFront ifFalse: [owner addMorphFront: self]! !
!Morph methodsFor: 'user interface' stamp: 'AY 2/4/2019 03:30:37' prior: 50341560!
          toggleCollapseOrShow
	"If collapsed, show me.
	If visible, collapse me."

	(self visible and: [self atFront])
		ifTrue:  [ self collapse ]
		ifFalse: [ self showAndComeToFront ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3598-WindowSwitchingEnh-AngelYan-2019Feb04-03h15m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3589] on 7 February 2019 at 12:00:51 am'!

PluggableButtonMorph subclass: #HoverableButtonMorph
	instanceVariableNames: 'mouseEnterSelector mouseLeaveSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #HoverableButtonMorph category: #'Morphic-Views'!
PluggableButtonMorph subclass: #HoverableButtonMorph
	instanceVariableNames: 'mouseEnterSelector mouseLeaveSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'AY 2/4/2019 03:26:10' prior: 50431790!
  atFront
	
	^owner firstSubmorph == self! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 23:55:29'!
                      beginPreview

	(self visible and: [self atFront]) ifFalse: [
		self visibleBeforePreview: self visible.
		self morphBehindBeforePreview: (self owner submorphBehind: self).
		self previewing: true.
		self showAndComeToFront. ]! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 23:55:39'!
                            endPreview
	
	self previewing ifTrue: [
		self visible: self visibleBeforePreview.
		self owner addMorph: self inFrontOf: self morphBehindBeforePreview.
		self previewing: false. ]! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/4/2019 05:46:06'!
         endPreviewAndToggleCollapseOrShow

	self endPreview.
	self toggleCollapseOrShow.! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 05:28:28'!
             morphBehindBeforePreview

	^self valueOfProperty: #morphBehindBeforePreview! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 05:28:19'!
                  morphBehindBeforePreview: aMorph

	self setProperty: #morphBehindBeforePreview toValue: aMorph! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 23:56:03'!
                               previewing

	^(self valueOfProperty: #previewing) = true! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 23:56:28'!
     previewing: aBoolean

	self setProperty: #previewing toValue: aBoolean! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 05:27:23'!
                       visibleBeforePreview

	^self valueOfProperty: #visibleBeforePreview! !
!Morph methodsFor: 'previewing' stamp: 'AY 2/6/2019 05:25:28'!
                          visibleBeforePreview: aBoolean

	self setProperty: #visibleBeforePreview toValue: self visible! !
!HoverableButtonMorph methodsFor: 'initialization' stamp: 'AY 2/6/2019 04:01:16'!
            model: anObject stateGetter: getStateSel action: actionSel onMouseEnterSend: aMouseEnterSelector onMouseLeaveSend: aMouseLeaveSelector

	super model: anObject stateGetter: getStateSel action: actionSel label: nil.
	mouseEnterSelector _ aMouseEnterSelector.
	mouseLeaveSelector _ aMouseLeaveSelector.! !
!HoverableButtonMorph methodsFor: 'events' stamp: 'AY 2/4/2019 04:04:24'!
       mouseEnter: event
	
	mouseEnterSelector ifNotNil: [ model perform: mouseEnterSelector ].
	^super mouseEnter: event! !
!HoverableButtonMorph methodsFor: 'events' stamp: 'AY 2/4/2019 04:05:06'!
mouseLeave: event
	
	mouseLeaveSelector ifNotNil: [ model perform: mouseLeaveSelector ].
	^super mouseLeave: event! !
!HoverableButtonMorph class methodsFor: 'instance creation' stamp: 'AY 2/6/2019 03:59:26'!
               model: anObject stateGetter: getStateSel action: actionSel onMouseEnterSend: aMouseEnterSelector onMouseLeaveSend: aMouseLeaveSelector

	^ self new
		model: anObject
		stateGetter: getStateSel
		action: actionSel
		onMouseEnterSend: aMouseEnterSelector
		onMouseLeaveSend: aMouseLeaveSelector! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'AY 2/4/2019 03:26:20' prior: 50431795!
                               comeToFront

	self atFront ifFalse: [owner addMorphFront: self]! !
!TaskbarMorph methodsFor: 'services' stamp: 'AY 2/6/2019 04:01:56' prior: 50402064!
         addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ HoverableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #endPreviewAndToggleCollapseOrShow
			onMouseEnterSend: #beginPreview
			onMouseLeaveSend: #endPreview.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: #label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3599-WindowPreviewing-AngelYan-2019Feb06-03h50m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3597] on 8 February 2019 at 10:16:00 pm'!
!Browser methodsFor: 'class list' stamp: 'SLD 2/8/2019 22:07:43' prior: 50407312!
          classListIndex: anInteger 
	"Set anInteger to be the index of the current class selection."

	| className recent canSelectClass classList |

	classList _ self classList.
	canSelectClass _ classList isInBounds: anInteger.
	selectedClassName _ canSelectClass ifTrue: [	| newClassName |
		newClassName := classList at: anInteger ifAbsent: [ nil ].
		newClassName := newClassName ifNotNil: [newClassName withoutLeadingBlanks asSymbol].
		newClassName ].
	self setClassOrganizer.
	selectedMessage _ nil.
	
	self classCommentIndicated ifFalse: [
		self editSelection: (canSelectClass
			ifTrue: [#editClass]
			ifFalse: [ metaClassIndicated | selectedSystemCategory isNil
				ifTrue: [#none]
				ifFalse: [#newClass]])].

	self selectedClass ifNotNil: [
		recent _ self class recentClasses.
		className _ self selectedClass name.
		(recent includes: className) ifTrue: [recent remove: className].
		recent addFirst: className.
		recent size > 16 ifTrue: [recent removeLast]].

	"Clear selectedMessageCategory if there is no match in the new list of categories"
	(self messageCategoryList indexOf: selectedMessageCategory) = 0 ifTrue: [
		selectedMessageCategory _ nil].
		
	"We have to refresh the class list if somebody wants to select a class that does not exist anymore - Hernan"
	anInteger > classList size ifTrue: [ self changed: #classList ].
	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3600-try-to-keep-messageCategory-SteveDavies-2019Jan29-21h24m-SLD.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3597] on 4 February 2019 at 12:02:07 am'!
!PackageRequirementsList methodsFor: 'accessing' stamp: 'KLG 2/3/2019 23:50:55'!
                            updateSelectedRequirement

	| selectedPackage featureSpec newRequires selectedName |
	self selectionIndex ifNil: [ ^self ].
	self selectionIndex isZero ifTrue: [ ^self ].
	((codePackageList selectionIndex isNil)  or: [ codePackageList selectionIndex isZero ])
		ifTrue: [ ^self ].
		
	selectedPackage := codePackageList selection.
	featureSpec := selectedPackage featureSpec.
	newRequires := (featureSpec requires copyWithout: self selection),
			 {((selectedName _ self selection name) = Feature baseSystemFeature name)
				ifTrue: [ Feature baseSystemFeature requirementOfMe ]
				ifFalse: [ (CodePackage installedPackages at: selectedName) requirementOfMe]}.
	featureSpec 
		provides: featureSpec provides 
		requires: newRequires.
	selectedPackage hasUnsavedChanges: true.
	requirements := codePackageList selection requires asArray.
	self changed: #requirements

	
	! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'KLG 2/3/2019 23:30:07' prior: 50387930!
                   buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout updateReqButton |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	requirements color: Theme current textPane.
		
	deleteReqButton := PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete'.
	deleteReqButton color: self widgetsColor.
	updateReqButton _ PluggableButtonMorph 
							model: requirements model
							action: #updateSelectedRequirement 
							label: 'update'.
	updateReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newRow.
	buttonLayout 
		addMorph: deleteReqButton 
		layoutSpec: (LayoutSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						minorDirectionPadding: #top);
		color: self widgetsColor quiteWhiter;
		addMorph: updateReqButton 
		layoutSpec: (LayoutSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						minorDirectionPadding: #top);
		color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.8
							proportionalHeight: 1.0 
							minorDirectionPadding: #left);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.2 
							proportionalHeight: 1.0 
							minorDirectionPadding: #right);
		color: `Color transparent`;
		yourself
		! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'KLG 2/3/2019 23:35:44' prior: 16811558!
      addRequirement
	"Ask user for a FeatureRequirement based on loaded packages"
	
	| current currentName packageNames reqiredNames selectionNames choices selection cuisBaseName req selectedName |
	current _ model selection.
	current ifNil: [ ^self ].

	packageNames := model packages collect: [ :pak | pak packageName ].
	currentName := current packageName.
	reqiredNames := current requires collect: [ :r | r name ].
	selectionNames := packageNames select: [ :name |
		((name = currentName) or: [reqiredNames includes: name]) not ].
	cuisBaseName := Feature baseSystemFeature name.
	choices := OrderedCollection with: #CANCEL.
	(reqiredNames includes: cuisBaseName)
		ifFalse: [ choices add: cuisBaseName ].		
	choices addAll: selectionNames.
	choices size = 1 ifTrue: [
		^ PopUpMenu inform: 'All loaded packages are already required, as is Cuis base system' ].
	selection := PopUpMenu
		withCaption: 'Choose package to require' 
		chooseFrom: choices.
	selection <= 1
		ifTrue: [ ^ self ]  "1 -> Cance, 0 -> Clicked outside the menu"
		ifFalse: [
			selectedName := choices at: selection.
			req := (selectedName = cuisBaseName)
				ifTrue: [ Feature baseSystemFeature requirementOfMe ]
				ifFalse: [ (CodePackage installedPackages at: selectedName) requirementOfMe].
			current featureSpec requires: req.
			current hasUnsavedChanges: true.
			self changed: #requirement ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3601-InstalledPackagesTool-enh-GeraldKlix-BetterInstalledPackagesBrowser-KLG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3597] on 4 February 2019 at 4:55:07 pm'!
!Editor class methodsFor: 'class initialization' stamp: 'HAW 2/4/2019 16:54:10'!
          initializeCmdShortcutsUsing: anInitializationMessage

	| dynamicInitializationMessage |
	
	self putIntoCmdShortcuts: (self perform: anInitializationMessage).

	dynamicInitializationMessage := (self name asString uncapitalized, anInitializationMessage asString capitalized) asSymbol.
	(Smalltalk allClassesImplementing: dynamicInitializationMessage) do: [ :aClass | 
		self putIntoCmdShortcuts: (aClass soleInstance perform: dynamicInitializationMessage) ].


! !
!Editor class methodsFor: 'class initialization' stamp: 'HAW 2/4/2019 16:53:40'!
putIntoCmdShortcuts: shortcutsSpec

	shortcutsSpec do: [ :ary | cmdShortcuts at: ary first numericValue + 1 put: ary second ].! !
!Editor class methodsFor: 'class initialization' stamp: 'HAW 2/4/2019 16:51:32' prior: 16836915!
                             initializeCmdShortcuts
	"Initialize the (unshifted) command-key (or alt-key if not on Mac) shortcut table.
	If you want to add a new shortcut for an specific editor, for example SmalltalkEditor, you should
	define the message #smalltalkEditorCmdShortcutsSpec in a class of your category and it will
	be dynamically send"

	"NOTE: if you don't know what your keyboard generates, use Sensor test"

	"
	Editor initialize
	"

	cmdShortcuts _ Array new: 256 withAll: #noop:.

	self initializeCmdShortcutsUsing: #basicCmdShortcutsSpec.
	self initializeCmdShortcutsUsing: #cmdShortcutsSpec.
! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3602-PluggableEditorShortcuts-HernanWilkinson-2019Feb04-15h45m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3589] on 4 February 2019 at 11:11:35 pm'!
!Collection methodsFor: 'enumerating' stamp: 'AY 2/4/2019 23:11:18' prior: 50381591!
     select: selectBlock thenDo: doBlock
	"Equivalent to 
		(self select: selectBlock) do: doBlock
	but avoid creating an extra collection."

	self do: [ :each | (selectBlock value: each) ifTrue: [ doBlock value: each ]]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3603-CollectionSelectThenDoMessageFix-AngelYan-2019Feb04-23h11m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3598] on 6 February 2019 at 12:02:06 pm'!
!Boolean methodsFor: 'logical operations' stamp: 'HAW 2/6/2019 12:01:53'!
 xor: aBoolean

	self subclassResponsibility! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3604-Boolean-xor-HernanWilkinson-2019Feb06-12h00m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3598] on 6 February 2019 at 1:38:28 pm'!
!TestCase methodsFor: 'assertions' stamp: 'HAW 2/6/2019 12:17:47' prior: 50424292!
                  should: aBlockToFail raise: anExceptionHandlingCondition withMessageText: anExpectedErrorMessageCreator

	self 
		should: aBlockToFail 
		raise: anExceptionHandlingCondition 
		withExceptionDo: [ :anException | self assert: anExpectedErrorMessageCreator value equals: anException messageText ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3605-TestCase-enh-HernanWilkinson-2019Feb06-12h04m-HAW.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3598] on 6 February 2019 at 1:57:15 pm'!
!SHTextStylerST80 methodsFor: 'private' stamp: 'HAW 2/6/2019 13:57:03' prior: 50371889!
                  privateStyle

	| alpha end start count startIndexes c hue |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	Preferences highlightBlockNesting ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 10.0 min: 1.0.
			hue _ depth * 60.
			c _ Color h: hue s: 0.2 v: 0.5 alpha: alpha.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor color: c ) 
				from: start 
				to: end ]]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3606-TextStyler-tweak-HernanWilkinson-2019Feb06-13h38m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3598] on 6 February 2019 at 4:15:11 pm'!
!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'HAW 2/6/2019 16:14:45' prior: 16781473!
  updateColor

	| remaining alpha |

	remaining := (self timeout - self timeOfLastActivity).
	remaining < 1000 
		ifTrue: [
			alpha _ remaining / 1000.0.
			self color: (self color alpha: alpha).
			self borderColor: (borderColor alpha: alpha) ]
		ifFalse: [
			self color: self defaultColor.
			self borderColor: self defaultBorderColor ]
		
			! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3607-AutoCompleter-fix-HernanWilkinson-2019Feb06-16h14m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3607] on 16 February 2019 at 7:46:40 pm'!
!Morph methodsFor: 'drawing' stamp: 'jmv 2/7/2019 20:44:52' prior: 50337366!
   visible: aBoolean
	"set the 'visible' attribute of the receiver to aBoolean"

	self visible == aBoolean
		ifTrue: [ ^ self ].
	aBoolean ifFalse: [
		self redrawNeeded ].
	self setProperty: #visible toValue: aBoolean.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	aBoolean ifTrue: [
		self redrawNeeded]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 2/7/2019 20:45:05' prior: 50337293!
      wasOpened: aMorph
	"aMorph was added to the world. Add button for aMorph if appropriate (see #taskbarIncludesAllWindows)"

	self addButtonFor: aMorph! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 2/7/2019 20:44:10' prior: 50337622!
      noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	aMorph submorphsDo: [ :m |
		self addButtonFor: m ].
	self notifyDisplayResize! !

TaskbarMorph removeSelector: #wasMadeVisible:!

TaskbarMorph removeSelector: #wasMadeVisible:!

Preferences class removeSelector: #taskbarIncludesAllWindows!

Preferences class removeSelector: #taskbarIncludesAllWindows!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3608-TaskbarAlwaysShowsAllWindows-JuanVuletich-2019Feb16-19h39m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3597] on 8 February 2019 at 11:44:02 pm'!

IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments '
	classVariableNames: 'EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp WordSize ChangesInitialFileSize '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #SystemDictionary category: #'System-Support'!
IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp WordSize'
	poolDictionaries: ''
	category: 'System-Support'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/8/2019 23:43:13' prior: 16922741!
           saveAs: newName andQuit: aBoolean clearAllClassState: clearAllStateFlag
	"Save the image  under a new name."

	| newChangesName |
	self currentChangesName ifNotNil: [ :oldChangesName |
		self closeSourceFiles. "so copying the changes file will always work"
		newChangesName _ self fullNameForChangesNamed: newName.
		FileIOAccessor default copy: oldChangesName asFileEntry to: newChangesName asFileEntry.
		ChangesInitialFileSize ifNotNil: [
			oldChangesName asFileEntry appendStreamDo: [ :strm | strm truncate: ChangesInitialFileSize ]]].

	self 
		changeImageNameTo: (self fullNameForImageNamed: newName);
		closeSourceFiles; openSourceFiles;  "so SNAPSHOT appears in new changes file"
		snapshot: true andQuit: aBoolean
		clearAllClassState: clearAllStateFlag! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/8/2019 23:32:57' prior: 50381428!
                               snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup guiRootObject guiRootObjectClass reopenTranscript |
	save not & quit
		ifTrue: [
			(SourceFiles at: 2) ifNotNil: [ :changes |
				ChangesInitialFileSize ifNotNil: [
					changes truncate: ChangesInitialFileSize ]]]
		ifFalse: [ self logSnapshot: save andQuit: quit ].

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	guiRootObjectClass _ UISupervisor ui class.
	guiRootObject _ UISupervisor ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"guiRootObject _ clearAllStateFlag ifFalse: [ UISupervisor ui ]."
	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			"The snapshot primitive answers false if it was just called to do the snapshot.
			But image startup is resumed by returning (again) from the primitive, but this time answering true."
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: DisplayScreen new.
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.

	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject _ guiRootObjectClass newWorld ]).
	Display triggerEvent: #screenSizeChanged.
	
	self restoreLostChangesIfNecessary.

	UISupervisor whenUIinSafeState: [
		"guiRootObject fullRepaintNeeded."
		reopenTranscript ifTrue: [
			TranscriptWindow openTranscript ]].

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 2/8/2019 23:33:15' prior: 16923339!
  openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or Lf/CrLf mixups."
	"Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes msg wmsg entry |
	msg _ 'Cuis cannot locate XfileRef
Please check that the file is named properly and is in the
same directory as this image.'.
	wmsg _ 'Cuis cannot write to XfileRef.

Please check that you have write permission for this file.

You won''t be able to save this image correctly until you fix this.'.

	"Do not open source files if internalized (i.e. notNil)"
	sources _ SourceFiles at: 1.
	sources ifNil: [
		entry _ Smalltalk defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry _ Smalltalk alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources _ [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preferences valueOfFlag: #warnIfNoSourcesFile ])
		ifTrue: [
			Smalltalk platformName = 'Mac OS' ifTrue: [
				msg _ msg , String newLineString, 'Make sure the sources file is not an Alias.'].
			self inform: (msg copyReplaceAll: 'XfileRef' with: 'the sources file named ' , entry pathName) ].

	"Do not open source files if internalized (i.e. notNil)"
	changes _ (SourceFiles at: 2) ifNil: [ 
		entry _ Smalltalk defaultChangesName asFileEntry.
		[ entry appendStream ] on: FileWriteError do: [ nil ] ].
	(changes isNil and: [ Preferences valueOfFlag: #warnIfNoChangesFile ])
		ifTrue: [self inform: (wmsg copyReplaceAll: 'XfileRef' with: 'the changes file named ' , entry pathName)].
	ChangesInitialFileSize _ changes ifNotNil: [ changes position ].

	SourceFiles _ Array with: sources with: changes! !

IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp WordSize'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #SystemDictionary category: #'System-Support'!
IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp WordSize'
	poolDictionaries: ''
	category: 'System-Support'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3609-TruncateChangesOnQuitNoSave-JuanVuletich-2019Feb08-23h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3609] on 16 February 2019 at 8:06:52 pm'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/16/2019 20:06:00' prior: 50369644!
snapshotMessageFor: save andQuit: quit

	| dateAndTime |
	dateAndTime _ DateAndTime now.
	^String streamContents: [ :stream |
		stream 
			nextPutAll: self tagHeader;
			nextPutAll: (self snapshotTagFor: save andQuit: quit);
			nextPutAll: self tagTail.
		stream nextPut: $(.
		dateAndTime date printOn: stream.
		stream space.
		dateAndTime time print24: true showSeconds: true on: stream.
		stream nextPut: $).
		stream
			space;
			nextPutAll: self imageName asFileEntry name;
			nextPutAll: ' priorSource: ';
			print: LastQuitLogPosition ].! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 2/16/2019 20:02:34' prior: 16923402!
                      timeStamp: aStream 
	"Writes system version and current time on stream aStream."

	| dateTime |
	dateTime _ DateAndTime now.
	aStream
		nextPutAll: 'From ';
		nextPutAll: Smalltalk datedVersion;
		nextPutAll: ' [';
		nextPutAll: Smalltalk lastUpdateString;
		nextPutAll: '] on '.
	dateTime date printOn: aStream.
	aStream
		nextPutAll: ' at '.
	dateTime time print24: false showSeconds: true on: aStream! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 2/16/2019 20:03:15' prior: 16925503!
                setStartupStamp

	| dateAndTime |
	dateAndTime _ DateAndTime now.
	StartupStamp _ String streamContents: [ :stream |
		stream nextPutAll: '----STARTUP---- ('.
		dateAndTime date printOn: stream.
		stream space.
		dateAndTime time print24: true showSeconds: true on: stream.
		stream
			nextPutAll: ') as ';
			nextPutAll: Smalltalk imageName ] 
! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3610-NicerStartupAndSnapshotStamps-JuanVuletich-2019Feb16-19h50m-jmv.1.cs.st----!

----SNAPSHOT----(16 February 2019 21:33:18) Cuis5.0-3610-v3.image priorSource: 3163412!

----QUIT----(16 February 2019 21:33:30) Cuis5.0-3610-v3.image priorSource: 3233626!

----STARTUP---- (15 March 2019 17:27:13) as /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/Cuis5.0-3610-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3598] on 10 February 2019 at 9:09:37 pm'!
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'HAW 2/10/2019 21:09:29' prior: 16902967!
    namesBeginningWith: aString do: aBlock
	"Evaluate aBlock for all available names that start with aString"

	self nonGlobalNamesDo: [ :name |
		(name beginsWith: aString) ifTrue: [ aBlock value: name ]].
	Smalltalk namesBeginningWith: aString do: aBlock
	
! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3611-CodeStylerTweak-HernanWilkinson-2019Feb06-16h15m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3598] on 14 February 2019 at 5:45:58 pm'!
!TextModelMorph methodsFor: 'initialization' stamp: 'HAW 2/14/2019 17:40:47'!
                              escAction: aBlock
	
	self textMorph escAction: aBlock! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'HAW 2/14/2019 17:37:45'!
                              escAction

	"Return the action to perform when user presses <Esc> key"

	^self valueOfProperty: #escAction! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'HAW 2/14/2019 17:40:40'!
         escAction: aBlock
	
	"Sets the action to perform when user presses <Esc> key"
	
	^self setProperty: #escAction toValue: aBlock ! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'HAW 2/14/2019 17:45:05' prior: 16855817!
                               processKeyStroke: evt
	| action |

	(acceptOnCR and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action value]].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action value]].
	
	self handleInteraction: [ editor processKeyStroke: evt ].

	"Is this really needed? It produces whole morph invalidation just by (for example)
	moving the cursor around... (jmv Aug 6, 2014)"
	"self updateFromTextComposition."

	self scrollSelectionIntoView! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'HAW 2/14/2019 17:42:22' prior: 50385752!
                       createTextPaneAcceptOnCR: acceptBoolean
	"create the textPane"
	| result |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"

	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	
	result 
		hasUnacceptedEdits: true;
		acceptOnCR: acceptBoolean;
		escAction: [ self cancelClicked ];
		morphExtent: `18@5` * self sizeUnit.
		
	self addMorph: result position: `1@2` * self sizeUnit.
	
	^ result! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3612-EscCancelsFillIntheBlankMorph-HernanWilkinson-2019Feb11-15h04m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3598] on 11 February 2019 at 3:04:48 pm'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3613-TestCase-MessageCategorization-HernanWilkinson-2019Feb11-14h14m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3612] on 19 February 2019 at 11:50:01 am'!
!SHParserST80 methodsFor: 'aux' stamp: 'jmv 2/19/2019 11:49:22'!
  namesBeginningWith: aString do: aBlock in: aCollection
	"aCollection is sorted"
	"
	self new namesBeginningWith: 'O' do: [ :each | each print ] in: Smalltalk classNames
	self new namesBeginningWith: 'ObjectExplorer' do: [ :each | each print ] in: Smalltalk classNames
	self new namesBeginningWith: 'ObjectExplorerWrapper' do: [ :each | each print ] in: Smalltalk classNames
	"
	| count |

	"Find the first element  starting with aString"
	count _ aCollection size.
	aCollection
		findBinaryIndex: [ :element |
			element < aString
				ifFalse: [ -1 ]
				ifTrue: [ 1 ] ]
		do: [ :found | "Will never find any" ]
		ifNone: [ :a :b | | i n |
			i _ b.
			[ i <= count and: [ 
				n _ aCollection at: i.
				aString isEmpty or: [
					n beginsWith: aString ]]] whileTrue: [
				aBlock value: n.
				i _ i + 1 ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 11:48:10' prior: 50432714!
                 namesBeginningWith: aString do: aBlock
	"Evaluate aBlock for all available names that start with aString"

	self nonGlobalNamesDo: [ :name |
		(name beginsWith: aString) ifTrue: [ aBlock value: name ]].
	self namesBeginningWith: aString do: aBlock in: Smalltalk classNames.
	self namesBeginningWith: aString do: aBlock in: Smalltalk nonClassNames
	
! !

SystemDictionary removeSelector: #namesBeginningWith:do:!

SystemDictionary removeSelector: #namesBeginningWith:do:!

SystemDictionary removeSelector: #namesBeginningWith:do:in:!

SystemDictionary removeSelector: #namesBeginningWith:do:in:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3614-CodeColorizerSmallRefactor-JuanVuletich-2019Feb19-11h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3612] on 19 February 2019 at 12:26:57 pm'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'jmv 2/19/2019 12:26:00' prior: 50415515!
             computeIdentifierEntries
	"Use an aux Set to avoid duplicates, but keep the order given."
	| entriesSet lastTitle |
	
	entriesSet _ Set new.
	lastTitle _ nil.
	entries _ Array streamContents: [ :strm |
		parser namesBeginningWith: prefix do: [ :identifier :kindOfIdentifierTitle |
			(entriesSet includes: identifier) ifFalse: [
				kindOfIdentifierTitle = lastTitle ifFalse: [
					strm nextPut: kindOfIdentifierTitle.
					lastTitle _ kindOfIdentifierTitle ].
				entriesSet  add: identifier.
				strm nextPut: identifier ]]]! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:28' prior: 16902093!
             isBlockArgName: aString 
	"Answer true if aString is the name of a block argument, false otherwise"

	self blockArgNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:18' prior: 16902101!
       isBlockTempName: aString 
	"Answer true if aString is the name of a block temporary. false otherwise"

	self blockTempNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:31' prior: 16902130!
    isIncompleteBlockArgName: aString 
	"Answer true if aString is the start of the name of a block argument, false otherwise"

	self blockArgNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:21' prior: 16902140!
    isIncompleteBlockTempName: aString 
	"Answer true if aString is the start of the name of a block temporary. false otherwise"

	self blockTempNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:05' prior: 16902150!
 isIncompleteClassVarName: aString 
	"Answer true if aString is the start of the name of a class variable, false otherwise"

	self classVarNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:54' prior: 16902168!
    isIncompleteInstVarName: aString 
	"Answer true if aString is the start of the name of an instance variable, false otherwise"

	self instVarNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:42' prior: 16902178!
  isIncompleteMethodArgName: aString 
	"Answer true if aString is the start of the name of a method argument, false otherwise.
    Does not check whether aString is also a blockArgName"

	self methodArgNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:34' prior: 16902190!
      isIncompleteMethodTempName: aString 
	"Answer true if aString is the start of the name of a method temporary, false otherwise."

	self methodTempNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:07:49' prior: 16902200!
                             isIncompletePoolConstantName: aString 
	"Answer true if aString is the start of the name of a pool constant, false otherwise"

	self poolConstantNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:07:38' prior: 16902219!
                             isIncompleteWorkspaceVarName: aString 
	"Answer true if aString is the  start of the name of an workspace variable, false otherwise"

	self workspaceNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:58' prior: 16902229!
                         isInstVarName: aString 
	"Answer true if aString is the name of an instance variable, false otherwise"

	self instVarNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:45' prior: 16902238!
     isMethodArgName: aString 
	"Answer true if aString is the name of a method argument, false otherwise.
    Does not check whether aString is also a blockArgName"

	self methodArgNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:28' prior: 16902248!
         isMethodTempName: aString 
	"Answer true if aString is the name of a method temporary, false otherwise.
    Does not check whether aString is also a block temporary
    or argument"

	self methodTempNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:23:37' prior: 16902922!
                blockArgNamesDo: aBlock
	"Iterate over block argument names valid at current blockDepth"

	| title |
	title _ '--- Block Arguments ---'.
	blockDepth to: 1 by: -1 do: [ :level |
		arguments at: level ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:23:47' prior: 16902931!
      blockTempNamesDo: aBlock
	"Iterate over block temp names valid at current blockDepth"

	| title |
	title _ '--- Block Variables ---'.
	blockDepth to: 1 by: -1 do: [ :level |
		temporaries at: level ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:23:53' prior: 16902940!
       classVarNamesDo: aBlock

	| title |
	title _ '--- Class Variables ---'.
	classOrMetaClass isBehavior 
		ifTrue: [
			classOrMetaClass theNonMetaClass withAllSuperclasses do: [ :c |
				c classPool keysDo: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:00' prior: 16902948!
                              instVarNamesDo: aBlock

	| title |
	title _ '--- Instance Variables ---'.
	instanceVariables do: [ :name | aBlock value: name value: title ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:05' prior: 16902953!
             methodArgNamesDo: aBlock
	"Iterate over method argument names"

	| title |
	title _ '--- Method Arguments ---'.
	^arguments at: 0  ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:10' prior: 16902960!
           methodTempNamesDo: aBlock
	"Iterate over method temporary names"

	| title |
	title _ '--- Method Variables ---'.
	^temporaries at: 0 ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:20:50' prior: 50432839!
        namesBeginningWith: aString do: aBlock
	"Evaluate aBlock for all available names that start with aString"

	self nonGlobalNamesDo: [ :name :kindOfIdentifierTitle |
		(name beginsWith: aString) ifTrue: [ aBlock value: name value: kindOfIdentifierTitle ]].
	self namesBeginningWith: aString do: [ :name | aBlock value: name value: '--- Classes ---' ] in: Smalltalk classNames.
	self namesBeginningWith: aString do: [ :name | aBlock value: name value: '--- Globals ---' ] in: Smalltalk nonClassNames! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:43' prior: 50368720!
         nonGlobalNamesDo: aBlock
	"Evaluate aBlock over all available names, except for globals"

	self
		blockArgNamesDo: aBlock;
		blockTempNamesDo: aBlock;
		methodArgNamesDo: aBlock;
		methodTempNamesDo: aBlock;
		instVarNamesDo: aBlock;
		classVarNamesDo: aBlock;
		poolConstantNamesDo: aBlock;
		workspaceNamesDo: aBlock.
	self
		reservedNames do: [ :name |
			aBlock value: name value: '--- Pseudovariables ---'  ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:53' prior: 16902993!
                            poolConstantNamesDo: aBlock

	| title |
	title _ '--- Pool Variables ---'.
	classOrMetaClass isBehavior 
		ifTrue: [
			classOrMetaClass theNonMetaClass withAllSuperclasses do: [ :c |
				c sharedPools do: [ :pool |
					pool bindingsDo: [ :assoc | aBlock value: assoc key value: title ]]]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:25:01' prior: 16903009!
                       workspaceNamesDo: aBlock

	| title |
	title _ '--- Workspace Variables ---'.
	workspace ifNotNil: [
		workspace bindingNamesDo: [ :name | aBlock value: name value: title ] ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3615-Autocompleter-GroupNamesByKind-JuanVuletich-2019Feb19-11h50m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3590] on 19 February 2019 at 2:11:35 pm'!

BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #AutoCompleterMorph category: #'Tools-Autocompletion'!
BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser possibleInvalidSelectors selectorsClasses '
	classVariableNames: 'AccessLock EntriesLimit Selectors '
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #SmalltalkCompleter category: #'Tools-Autocompletion'!
AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser possibleInvalidSelectors selectorsClasses'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

SmalltalkCompleter subclass: #DynamicTypingSmalltalkCompleter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #DynamicTypingSmalltalkCompleter category: #'Tools-Autocompletion'!
SmalltalkCompleter subclass: #DynamicTypingSmalltalkCompleter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

Object subclass: #AutoCompleterSelectorsCollector
	instanceVariableNames: 'categoriesWithSelectors addedSelectorsFastSet prefix entriesToShow possibleInvalidSelectors otherClasses selectorsLimit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #AutoCompleterSelectorsCollector category: #'Tools-Autocompletion'!
Object subclass: #AutoCompleterSelectorsCollector
	instanceVariableNames: 'categoriesWithSelectors addedSelectorsFastSet prefix entriesToShow possibleInvalidSelectors otherClasses selectorsLimit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepths blockDepthsStartIndexes allSource '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHParserST80 category: #'Tools-Syntax Highlighting'!
Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepths blockDepthsStartIndexes allSource'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!
!TextModel methodsFor: 'shout styling' stamp: 'HAW 1/19/2019 20:23:45'!
                shouldStyle: aText with: aSHTextStylerST80 
	
	^true! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:03'!
 computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:09'!
computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:14'!
                            computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:20'!
 computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 2/6/2019 20:21:41'!
                        computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName

	textProvider computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName
! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 2/6/2019 20:28:38'!
                             computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName

	textProvider computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 2/6/2019 19:56:26'!
                      computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName

	textProvider computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName 
! !
!PluggableTextModel methodsFor: 'auto complete' stamp: 'HAW 2/6/2019 20:11:16'!
                              computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName

	textProvider computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName
! !
!Workspace methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:46:35'!
        computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName

	anAutocompleter computeMessageEntriesForClassOrNil: (self classOfBindingOf: aName)! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:29'!
                               computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:35'!
                             computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:44'!
                         computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:30:51'!
                              computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 2/18/2019 18:18:51'!
 computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName

	self computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName
! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 2/6/2019 20:28:21'!
                computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName

	^self computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName ! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:35:07'!
           computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName

	contextStackIndex = 0 
		ifTrue: [ anAutocompleter computeMessageEntriesForUnknowClass ]
		ifFalse: [ anAutocompleter computeMessageEntriesForClass: (self receiver instVarNamed: aName) class]! !
!Debugger methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:35:07'!
                      computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName

	| context tempIndex |
							
	context := self selectedContext.
	tempIndex := context tempNames indexOf: aName ifAbsent: [ ^ anAutocompleter computeMessageEntriesForUnknowClass ].
	
	anAutocompleter computeMessageEntriesForClass: (self debuggerMap namedTempAt: tempIndex in: context) class

	! !
!Inspector methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:35:07'!
                computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName

	anAutocompleter computeMessageEntriesForClass: (object instVarNamed: aName) class ! !
!CompiledMethod methodsFor: 'auto complete' stamp: 'HAW 2/10/2019 17:37:57'!
                            autoCompleterDocumentationAppendingToParameter: aParameterAppendBlock toReturn: aReturnAppendBlock
	
	"This message is sent either by the dynamic typing or live typing auto complete. If you do not have 
	live typing installed you will see one sender, do not refactor it!! - Hernan"
	
	| methodNode text |
 
	text := self receiverTextAutoCompleterDocumentation.
	
	methodNode := self methodNode.
	text := self selectorAutoCompleterDocumentationAppendingTo: text using: methodNode appendingToParameter: aParameterAppendBlock.
	text := text append: aReturnAppendBlock value.
	text := self commentAutoCompleterDocumentationAppendigTo: text using: methodNode.
			
	^text! !
!CompiledMethod methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 18:52:30'!
                       commentAutoCompleterDocumentationAppendigTo: text using: methodNode
	
	| comment |

	comment := methodNode comment.
	^ comment
		ifNil: [ text ] 
		ifNotNil: [ text append: (self commentAutoCompleterDocumentationOf: comment)].
		
	! !
!CompiledMethod methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 18:53:01'!
         commentAutoCompleterDocumentationOf: comment
 	
	^ Text 
		string: (String streamContents: [ :stream |				
			stream
				newLine; newLine;
				nextPutAll: comment first ])
		attributes: (SHTextStylerST80 attributesFor: #comment)! !
!CompiledMethod methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 18:22:02'!
            dynamicTypingAutoCompleterDocumentation
	
	^ self 
		autoCompleterDocumentationAppendingToParameter: [ :parameterName | '' ]
		toReturn: [ '' ]! !
!CompiledMethod methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 18:37:27'!
 receiverTextAutoCompleterDocumentation
	
	| receiverString |
	
	receiverString := String streamContents: [ :stream |
		stream 
			print: self methodClass;
			nextPutAll: '>>' ].
	
	^Text string: receiverString attributes: (SHTextStylerST80 attributesFor: #patternKeyword).
		
	! !
!CompiledMethod methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 18:45:23'!
                           selectorAutoCompleterDocumentationAppendingTo: sourceText using: methodNode appendingToParameter: aParameterAppendBlock

	| selector text |
	
	selector := methodNode selectorNode key.
	selector isUnary 
		ifTrue: [ text := sourceText append: (Text string: selector attributes: (SHTextStylerST80 attributesFor: #patternKeyword)) ]
		ifFalse: [
			text := sourceText.
			selector keywords 
				with: methodNode argumentNames 
				do: [ :keyword :argumentName |
					text := text append: (Text string: keyword attributes: (SHTextStylerST80 attributesFor: #patternKeyword)).
					text := text append: (Text string: ' ', argumentName, ' ' attributes: (SHTextStylerST80 attributesFor: #methodArg)).
					text := text append: (aParameterAppendBlock value: argumentName) ] 
				separatedBy: [ text := text append: String newLineString, String tab ]].

	^ text
! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'HAW 2/12/2019 17:14:49'!
                         characterBlockForIndex: anIndex

	^ textComposition characterBlockForIndex: anIndex ! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/12/2019 18:22:48' prior: 16781439!
             resetMenu
	
	| width newExtent adjustedY |
	
	self hideSelectorDocumentation.
	firstVisible _ 1.
	self selected: 1.

	width _ self calculateWidth.
	newExtent _ width + 4 @ (self visibleItemsCount * self itemHeight+2).
	
	adjustedY := (self isYOutOfScreen: originalPosition with: newExtent) 
		ifTrue: [ originalPosition y - newExtent y - self itemHeight ]
		ifFalse: [ originalPosition y ].

	self morphPosition: originalPosition x @ adjustedY extent: newExtent.
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/11/2019 20:13:14'!
  adjust: aLocation ifOutOfScreenWith: anExtent xOffset: xOffset yOffset: yOffset  
	
	| adjustedLocationX adjustedLocationY |
	
	adjustedLocationX := (self isXOutOfScreen: aLocation with: anExtent)
		ifTrue: [ aLocation x - anExtent x - xOffset ]
		ifFalse: [ aLocation x ].
	
	adjustedLocationX < 0 ifTrue: [ adjustedLocationX := aLocation x ].
		
	adjustedLocationY := (self isYOutOfScreen: aLocation with: anExtent) 
		ifTrue: [ aLocation y - anExtent y - yOffset ]
		ifFalse: [ aLocation y ].
		
	^adjustedLocationX @ adjustedLocationY 
	! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/11/2019 18:22:59'!
                    calculateWidth

	| width font |
	
	width _ 120.
	font _ self class listFont.

	1
		to: completer entryCount
		do: [ :index | width _ width max: (font widthOfString: (completer entries at: index) asString)].
	
	completer entryCount > self class itemsPerPage ifTrue: [ width _ width + ScrollBar scrollbarThickness ].
	
	^ width ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/14/2019 17:10:34'!
           colorOf: entry

	^(completer isPossibleInvalidEntry: entry) 
		ifTrue: [ `Color blue` ] 
		ifFalse: [ Theme current text ]
	! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:23:08'!
                     drawContainingRectangle: aCanvas
	
	aCanvas frameAndFillRectangle: (`0@0` extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:55:46'!
              drawDownArrowOn: aCanvas thickness: scrollbarThickness
	
	aCanvas
		image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
		at: self downButtonPosition.
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:46:59'!
       drawItemOf: index on: aCanvas width: width top: itemTop

	| rectangle entry |
	
	rectangle _ 1@itemTop extent: width@self itemHeight.
	index = self selected ifTrue: [ aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].

	entry _ completer entries at: index.
	aCanvas
		drawString: entry asString
		at: rectangle topLeft
		font: self class listFont
		color: (self colorOf: entry).
	! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:51:54'!
                  drawItemsOn: aCanvas width: width

	| itemTop |
	
	itemTop _ 1.
	self firstVisible
		to: self lastVisible
		do: [ :index | 
			self drawItemOf: index on: aCanvas width: width top: itemTop.
			itemTop _ itemTop + self itemHeight ].! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/11/2019 00:03:34'!
           drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness
	
	| height top bottom |

	height _ extent y - (2 * scrollbarThickness).
	top _ (1.0 * self firstVisible-1 / completer entryCount * height) ceiling + 1 + scrollbarThickness-1.
	bottom _ (1.0 * self lastVisible / completer entryCount * height) floor + 1 + scrollbarThickness -1.
	aCanvas
		fillRectangle: (extent x - scrollbarThickness+2@top corner:  extent x-2 @ bottom)
		color: `Color veryLightGray` ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/11/2019 00:02:04'!
                             drawScrollBarOn: aCanvas
	
	| scrollbarThickness width |

	width _ extent x-2.
	completer entryCount > self class itemsPerPage  ifTrue: [
		scrollbarThickness _ ScrollBar scrollbarThickness.
		width _ width - scrollbarThickness.
		
		self drawScrollBarRectangleOn: aCanvas thickness: scrollbarThickness.
		self drawUpArrowOn: aCanvas thickness: scrollbarThickness.
		self drawDownArrowOn: aCanvas thickness: scrollbarThickness.
		self drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness ].
		
	^width 
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:57:30'!
             drawScrollBarRectangleOn: aCanvas thickness: scrollbarThickness
	
	aCanvas
		frameRectangle: (extent x - scrollbarThickness@0 extent: scrollbarThickness @ extent y)
		borderWidth: 1
		color: borderColor.
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:54:49'!
     drawUpArrowOn: aCanvas thickness: scrollbarThickness
	
	aCanvas
		image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
		at: self upButtonPosition.
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/14/2019 18:26:25'!
             setDefaultColors

	self color: self defaultColor.
	self borderColor: self defaultBorderColor ! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 17:15:51'!
      crPressedOnSelectorDocumentation
	
	self hideSelectorDocumentation. 
	self activeHand newKeyboardFocus: completer textMorph ! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 17:13:41'!
       hideSelectorDocumentation

	selectorDocumentation ifNotNil: [ selectorDocumentation hide ].
	self stillActive ! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 17:15:38'!
                     initializeSelectorDocumentation 
 
	selectorDocumentation := TextModelMorph withText: ''.
	selectorDocumentation textMorph
		acceptOnCR: false;
		crAction: [ self crPressedOnSelectorDocumentation ].

	selectorDocumentation
		wrapFlag: true;
		borderColor: Color black;
		borderWidth: 1;
		disableEditing;
		openInWorld 
	! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 17:14:01'!
  isShowingSelectorDocumentation

	^selectorDocumentation notNil and: [ selectorDocumentation visible ]! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 17:40:55'!
                              methodDocumentationSeparator
	
	^ Text 
		string: String newLineString, '------------------------------------------------------------------------------------------------', String newLineString 
		attribute: TextColor black.! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/11/2019 16:27:17'!
   selectorDefaultDocumentationLocation

	| relativeSelected |
	
	relativeSelected := (self selected - self firstVisible) min: self class itemsPerPage - 1 max: 0.
	 
	^location externalizePosition: extent x@(relativeSelected * self itemHeight + 1).

	! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 17:12:11'!
           selectorDocumentation

	selectorDocumentation ifNil: [ self initializeSelectorDocumentation ].
	^selectorDocumentation ! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/11/2019 16:18:05'!
           selectorDocumentationExtent

	^`600@250`! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 18:11:20'!
                           selectorDocumentationText

	| selectedEntry selectorsClasses |
	
	selectedEntry := completer selectedEntry.
	(completer isCategoryEntry: selectedEntry) ifTrue: [ ^'' ].
	selectedEntry := selectedEntry asSymbol.
	selectorsClasses := completer selectorsClasses.
	 
	^ selectorsClasses isEmpty 
		ifTrue: [ self selectorDocumentationTextForAllImplementorsOf: selectedEntry ]
		ifFalse: [ self selectorDocumentationTextOf: selectedEntry forAll: selectorsClasses ].
	! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/18/2019 18:31:56'!
                    selectorDocumentationTextForAllI: aMethodsCollection

	| selectorDocumentationText implementors methodDocumentationSeparator |
	
	selectorDocumentationText := Text new.
	methodDocumentationSeparator := self methodDocumentationSeparator.		
	implementors := aMethodsCollection asSortedCollection: [ :leftMethod :rightMethod | leftMethod methodClass classDepth <  rightMethod methodClass classDepth ].
	
	implementors 
		do: [ :implementor | selectorDocumentationText := selectorDocumentationText append: (completer documentationOf: implementor)]
		separatedBy: [ selectorDocumentationText := selectorDocumentationText append: methodDocumentationSeparator ].
		
	^ selectorDocumentationText! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/18/2019 18:16:04'!
                   selectorDocumentationTextForAllImplementorsOf: selectedEntry

	^ self selectorDocumentationTextForAllI: (Smalltalk allImplementorsOf: selectedEntry).

	! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/18/2019 18:25:34'!
          selectorDocumentationTextOf: selectedEntry forAll: selectorsClasses
	
	| methodsToShow |
	
	methodsToShow := selectorsClasses 
		inject: IdentitySet new
		into: [ :methods :aClass | 
			(aClass lookupSelector: selectedEntry) ifNotNil: [ :method | methods add: method ].
			methods ].
			
	^self selectorDocumentationTextForAllI: methodsToShow ! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/14/2019 18:27:16'!
           showSelectorDocumentation

	| selectorDocumentationLocation selectorDocumentationExtent |
	
	selectorDocumentationLocation := self selectorDefaultDocumentationLocation.
	selectorDocumentationExtent := self selectorDocumentationExtent.
	selectorDocumentationLocation := self adjust: selectorDocumentationLocation ifOutOfScreenWith: selectorDocumentationExtent xOffset: extent x yOffset: self itemHeight negated.
	
	self setDefaultColors.
	
	self selectorDocumentation 
		model: (TextModel withText: self selectorDocumentationText);
		morphPosition: selectorDocumentationLocation extent: selectorDocumentationExtent;
		wrapFlag: false;
		show.
		
	! !
!AutoCompleterMorph methodsFor: 'submorphs-add/remove' stamp: 'HAW 2/8/2019 17:11:23'!
                               delete

	selectorDocumentation ifNotNil: [ 
		selectorDocumentation delete.
		selectorDocumentation := nil ].
	
	^super delete ! !
!AutoCompleterMorph methodsFor: 'testing' stamp: 'HAW 2/11/2019 19:45:39'!
                  isXOutOfScreen: aLocation with: anExtent
	
	^aLocation x + anExtent x > DisplayScreen actualScreenSize x! !
!AutoCompleterMorph methodsFor: 'testing' stamp: 'HAW 2/11/2019 19:43:44'!
         isYOutOfScreen: aLocation with: anExtent
	
	^aLocation y + anExtent y > DisplayScreen actualScreenSize y! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'HAW 1/21/2019 00:53:00'!
           crAction: aBlock
	"Sets the action to perform when user presses <Return> key"
	^self setProperty: #crAction toValue: aBlock ! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:21:43'!
             computeMessageEntriesIn: anAutocompleter ofBlockArgNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:21:54'!
                    computeMessageEntriesIn: anAutocompleter ofBlockTempVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:22:00'!
                computeMessageEntriesIn: anAutocompleter ofInstVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 12:22:05'!
                     computeMessageEntriesIn: anAutocompleter ofTempVarNamed: aName

	anAutocompleter computeMessageEntriesForUnknowClass! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 1/19/2019 07:07:02'!
  isArrowLeft
	
	^keyValue = 28! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 1/18/2019 19:48:13'!
                         isArrowRight
	
	^keyValue = 29 ! !
!MethodReference methodsFor: 'auto complete' stamp: 'HAW 2/8/2019 18:28:00'!
                dynamicTypingAutoCompleterDocumentation

	^self compiledMethod dynamicTypingAutoCompleterDocumentation ! !
!MethodReference methodsFor: 'auto complete' stamp: 'HAW 2/18/2019 18:31:40'!
       methodClass

	^self actualClass ! !
!AutoCompleter methodsFor: 'accessing' stamp: 'HAW 1/21/2019 01:02:40'!
                    textMorph

	^textMorph! !
!AutoCompleter methodsFor: 'entries' stamp: 'HAW 1/19/2019 23:55:50' prior: 16781300!
                selectedEntry

	^self entries at: menuMorph selected! !
!AutoCompleter methodsFor: 'entries' stamp: 'HAW 2/6/2019 16:22:43'!
   selectedEntryFormatted

	^(self entries at: menuMorph selected), ' '! !
!AutoCompleter methodsFor: 'testing' stamp: 'HAW 2/8/2019 17:23:31'!
                   canSelect: anEntry

	^true! !
!AutoCompleter methodsFor: 'testing' stamp: 'HAW 2/10/2019 21:35:19'!
                            isPossibleInvalidEntry: anEntry

	^false! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'HAW 1/19/2019 23:55:29'!
         selectedEntryFormatted

	^(self entries at: menuMorph selected) separateKeywords! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 2/8/2019 17:09:54'!
                       selectorsClasses

	^selectorsClasses ! !
!SmalltalkCompleter methodsFor: 'testing' stamp: 'HAW 2/8/2019 17:29:12'!
             canSelect: anEntry

	^ (self isCategoryEntry: anEntry) not! !
!SmalltalkCompleter methodsFor: 'testing' stamp: 'HAW 2/8/2019 17:29:29'!
                        isCategoryEntry: anEntry

	^anEntry beginsWith: AutoCompleterSelectorsCollector categoryEntryHeader! !
!SmalltalkCompleter methodsFor: 'testing' stamp: 'HAW 2/10/2019 21:35:32'!
              isPossibleInvalidEntry: anEntry

	^possibleInvalidSelectors includes: anEntry ! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/8/2019 16:07:20'!
                  computeEntriesOfUnaryMessageReturnNamed: aSelector at: aRange 
	
	self subclassResponsibility ! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/8/2019 17:09:54'!
  computeMessageEntriesForClass: aClass

	selectorsClasses := Array with: aClass.
	
	entries := (AutoCompleterSelectorsCollector for: prefix) 
		addSelectorsOf: aClass;
		entriesToShow! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/8/2019 12:43:44'!
          computeMessageEntriesForClassOrNil: aClassOrNil

	aClassOrNil 
		ifNil: [ self computeMessageEntriesForUnknowClass ]
		ifNotNil: [ self computeMessageEntriesForClass: aClassOrNil ].
	
! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/8/2019 16:10:27'!
        computeMessageEntriesOfCascadeReceiverAt: aRange 
	
	self subclassResponsibility ! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/11/2019 00:21:12'!
              computeMessageEntriesOfEnclosedExpressionReturnAt: aRange 

	self subclassResponsibility ! !
!SmalltalkCompleter methodsFor: 'message entries for unknown class - private' stamp: 'HAW 2/15/2019 15:40:47'!
                    computeMessageEntriesForUnknowClass

	| selectorsToShow |
	
	selectorsClasses _ #().
	possibleInvalidSelectors _ IdentitySet new.
	selectorsToShow _ OrderedCollection new.
	
	self class protected: [
		Selectors forPrefix: prefix keysAndValuesDo: [ :selector :lastUsedTime |
				selectorsToShow := self add: selector and: lastUsedTime to: selectorsToShow.
				(Object canUnderstand: selector) ifFalse: [ possibleInvalidSelectors add: selector ]]].
				
	selectorsToShow size < EntriesLimit ifTrue: [ selectorsToShow _  self sortByLastUsedTime: selectorsToShow ].
	
	" To see the timestamps in the menu (need to tweak #insertCompletion: to activate. Right now, just for debugging)
	entries _ selectorsToShow collect: [ :ary | ary first, '(', ((DateAndTime fromString: '01/01/1996 00:00') + ary second minutes) printString,')' ]
	"
	entries _ selectorsToShow collect: [ :selectorAndTime | selectorAndTime first ]
	
! !
!SmalltalkCompleter methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 18:12:00'!
                   documentationOf: aMethod

	self subclassResponsibility ! !
!SmalltalkCompleter class methodsFor: 'instance creation' stamp: 'HAW 2/10/2019 17:44:10'!
          withModel: aStringHolder

	"Looks it its subclasses the right autocompleter depending on the Type System. If you do not have
	Live Typing installed you will see only one subclass but if Live Typing is intalled LiveTypeingSmalltalkCompleter
	subclass is added - Hernan"
	
	| smalltalkCompleterClass |
	
	smalltalkCompleterClass := self subclasses detect: [ :aSubclass | aSubclass isForCurrentTypeSystem ].
	
	^smalltalkCompleterClass new setModel: aStringHolder! !
!SmalltalkCompleter class methodsFor: 'testing' stamp: 'HAW 2/8/2019 15:57:29'!
isForCurrentTypeSystem

	self subclassResponsibility ! !
!SmalltalkCompleter class methodsFor: 'accessing' stamp: 'HAW 2/15/2019 15:27:22'!
                    entriesLimit
	
	^EntriesLimit ! !
!DynamicTypingSmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/8/2019 16:09:35'!
                     computeEntriesOfUnaryMessageReturnNamed: aSelector at: aRange 
	
	self computeMessageEntriesForUnknowClass 
	! !
!DynamicTypingSmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/8/2019 16:10:08'!
      computeMessageEntriesOfCascadeReceiverAt: aRange 
	
	self computeMessageEntriesForUnknowClass
	
! !
!DynamicTypingSmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/11/2019 00:21:13'!
                  computeMessageEntriesOfEnclosedExpressionReturnAt: aRange 

	self computeMessageEntriesForUnknowClass 
	
! !
!DynamicTypingSmalltalkCompleter methodsFor: 'selector documentation' stamp: 'HAW 2/8/2019 18:13:08'!
             documentationOf: aMethod

	^aMethod dynamicTypingAutoCompleterDocumentation! !
!DynamicTypingSmalltalkCompleter class methodsFor: 'testing' stamp: 'HAW 2/8/2019 18:35:09'!
                    isForCurrentTypeSystem

	^ Smalltalk isLiveTypingInstalled not! !
!AutoCompleterSelectorsCollector methodsFor: 'initialization' stamp: 'HAW 2/15/2019 15:32:49'!
                               initializeFor: aPrefix withSelectorsLimitedTo: aLimit 

	prefix := aPrefix.
	categoriesWithSelectors := OrderedDictionary new.
	addedSelectorsFastSet := IdentitySet new.
	possibleInvalidSelectors := IdentitySet new.
	selectorsLimit := aLimit ! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting' stamp: 'HAW 2/15/2019 15:03:00'!
               addSelectorsOf: aClass

	self addSelectorsOf: aClass upTo: nil! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting' stamp: 'HAW 2/15/2019 15:04:08'!
   addSelectorsOf: aClass upTo: aSuperclassToExclude

	self addSelectorsOfAll: (Array with: aClass) upTo: aSuperclassToExclude ! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting' stamp: 'HAW 2/15/2019 15:04:18'!
     addSelectorsOfAll: classes upTo: aSuperclass

	classes do: [ :aClass | 
		otherClasses := classes copyWithout: aClass.
		self addSelectorsMarkingPossibleInvalidOnesOf: aClass upTo: aSuperclass ]! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting' stamp: 'HAW 2/10/2019 21:54:59'!
                               addedSelectors: selectors

	addedSelectorsFastSet addAll: selectors ! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting' stamp: 'HAW 2/10/2019 21:32:17'!
                             possibleInvalidSelectors
	
	^possibleInvalidSelectors! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting - private' stamp: 'HAW 2/15/2019 15:34:27'!
  addCategoriesAndSelectorsOf: aClass

	| classOrganization |
	
	classOrganization := aClass organization.
	
	classOrganization categories do: [ :aCategory | | categorySelectors selectedSelectors | 
		self hasReachSelectorsLimit ifTrue: [ ^ self ].
		selectedSelectors := self prefixedSelectorsOf: aCategory in: classOrganization.
		selectedSelectors isEmpty ifFalse: [ 
			categorySelectors := categoriesWithSelectors at: aCategory ifAbsentPut: [ OrderedCollection new ].
			categorySelectors addAll: selectedSelectors.
			self addedSelectors: selectedSelectors.
			self addToPossibleInvalidIfCorrespond: selectedSelectors ]]! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting - private' stamp: 'HAW 2/15/2019 15:35:41'!
       addSelectorsMarkingPossibleInvalidOnesOf: aClass upTo: aSuperclassToExclude

	| currentClass |
	
	currentClass := aClass.
	
	[ currentClass ~= aSuperclassToExclude and: [ currentClass notNil ] and: [ self hasReachSelectorsLimit not ] ] whileTrue: [ 
		self addCategoriesAndSelectorsOf: currentClass.
		currentClass := currentClass superclass].
	 
! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting - private' stamp: 'HAW 2/15/2019 15:19:35'!
                            addToPossibleInvalidIfCorrespond: selectedSelectors

	selectedSelectors do: [ :aSelector |
		(otherClasses allSatisfy: [ :otherClass | otherClass canUnderstand: aSelector ]) ifFalse: [ possibleInvalidSelectors add: aSelector ]]! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting - private' stamp: 'HAW 2/7/2019 18:40:03'!
                     prefixedSelectorsOf: aCategory in: aClassOrganization
	
	^ (aClassOrganization listAtCategoryNamed: aCategory) 
		select: [ :aSelector |  (aSelector beginsWith: prefix) and: [ (addedSelectorsFastSet includes: aSelector) not ] ].
! !
!AutoCompleterSelectorsCollector methodsFor: 'entries to show' stamp: 'HAW 2/8/2019 16:25:25'!
                        entriesToShow
	
	self hasCollectedOnlyOneSelector
		ifTrue: [ entriesToShow := categoriesWithSelectors anyOne ]
		ifFalse: [ 
			entriesToShow := OrderedCollection new.
			self 
				addPrioritizedCategories;
				addLeftCategories ].
						  			
	^entriesToShow 
	
	   ! !
!AutoCompleterSelectorsCollector methodsFor: 'entries to show - private' stamp: 'HAW 2/18/2019 18:26:36'!
      addCategory: aCategory with: selectors 

	entriesToShow 
		add: (self categoryEntryFor: aCategory); 
		addAll: selectors
	   ! !
!AutoCompleterSelectorsCollector methodsFor: 'entries to show - private' stamp: 'HAW 2/7/2019 18:26:18'!
                      addLeftCategories
	
	categoriesWithSelectors keysAndValuesDo: [ :aCategory :selectors | self addCategory: aCategory with: selectors ].
	! !
!AutoCompleterSelectorsCollector methodsFor: 'entries to show - private' stamp: 'HAW 2/7/2019 18:27:10'!
           addPrioritizedCategories

	self prioritizedCategories do: [ :aCategory | self addPrioritizedCategory: aCategory ]! !
!AutoCompleterSelectorsCollector methodsFor: 'entries to show - private' stamp: 'HAW 2/7/2019 18:27:10'!
  addPrioritizedCategory: aCategory

	categoriesWithSelectors 
		at: aCategory 
		ifPresent: [ :selectors | 
			self addCategory: aCategory with: selectors.
			categoriesWithSelectors removeKey: aCategory ].
! !
!AutoCompleterSelectorsCollector methodsFor: 'entries to show - private' stamp: 'HAW 2/8/2019 17:24:26'!
     categoryEntryFor: aCategory
	
	^self class categoryEntryHeader, aCategory ! !
!AutoCompleterSelectorsCollector methodsFor: 'entries to show - private' stamp: 'HAW 2/7/2019 18:19:23'!
         prioritizedCategories 
	
	^#('instance creation')! !
!AutoCompleterSelectorsCollector methodsFor: 'testing' stamp: 'HAW 2/8/2019 16:26:00'!
                    hasCollectedOnlyOneSelector
	
	^ categoriesWithSelectors size = 1 and: [ categoriesWithSelectors anyOne size = 1 ]! !
!AutoCompleterSelectorsCollector methodsFor: 'testing' stamp: 'HAW 2/15/2019 15:34:27'!
                  hasReachSelectorsLimit
	
	^addedSelectorsFastSet size >= selectorsLimit! !
!AutoCompleterSelectorsCollector class methodsFor: 'instance creation' stamp: 'HAW 2/15/2019 15:33:47'!
             for: aPrefix

	^self for: aPrefix withSelectorsLimitedTo: SmalltalkCompleter entriesLimit! !
!AutoCompleterSelectorsCollector class methodsFor: 'instance creation' stamp: 'HAW 2/15/2019 15:33:36'!
                           for: aPrefix withSelectorsLimitedTo: aLimit

	^self new initializeFor: aPrefix withSelectorsLimitedTo: aLimit! !
!AutoCompleterSelectorsCollector class methodsFor: 'category entry' stamp: 'HAW 2/8/2019 17:24:43'!
           categoryEntryHeader

	^ '-- '! !
!SHParserST80 methodsFor: 'accessing' stamp: 'HAW 2/10/2019 18:35:50'!
                        allSource

	^allSource! !
!SHParserST80 methodsFor: 'accessing' stamp: 'HAW 2/10/2019 18:36:28'!
                               allSource: aSourceCode

	allSource _ aSourceCode! !
!TextModel methodsFor: 'auto complete' stamp: 'HAW 1/20/2019 18:47:22' prior: 50417091!
                    classOfThisContext

	^ MethodContext ! !
!TextProvider methodsFor: 'auto complete' stamp: 'HAW 1/20/2019 18:47:47' prior: 50417162!
                            classOfThisContext

	^ MethodContext ! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 2/19/2019 14:09:50'!
    with: otherCollection do: twoArgBlock separatedBy: separatorBlock

	| beforeFirst | 
	
	beforeFirst := true.
	self with: otherCollection do: [ :selfElement :otherCollectionElement |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		twoArgBlock value: selfElement value: otherCollectionElement ].
		
	
! !
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'HAW 1/19/2019 09:05:56' prior: 16781381!
              selected
	"Answer the value of selected"
	selected ifNil: [ self selected: self firstVisible ].
	^ selected! !
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'HAW 2/8/2019 17:14:24' prior: 16781387!
                     selected: aNumber 

	"Set the value of selected"

	((aNumber between: 1 and: completer entryCount) and: [ aNumber ~= selected ])
		ifTrue: [ 
			selected _ aNumber.
			self isShowingSelectorDocumentation ifTrue: [ self showSelectorDocumentation ]]! !
!AutoCompleterMorph methodsFor: 'activity tracking' stamp: 'HAW 2/14/2019 18:26:11' prior: 50432299!
updateColor

	| remaining alpha |

	remaining := (self timeout - self timeOfLastActivity).
	remaining < 1000 
		ifTrue: [
			alpha _ remaining / 1000.0.
			self color: (self color alpha: alpha).
			self borderColor: (borderColor alpha: alpha) ]
		ifFalse: [ self setDefaultColors ]
		
			! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:52:19' prior: 50385037!
 downButtonPosition

	^ `0@0` + (extent - ScrollBar scrollbarThickness)! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:39:30' prior: 50388245!
                           drawOn: aCanvas
	
	| width |
	
	self drawContainingRectangle: aCanvas.
	width _ self drawScrollBarOn: aCanvas.
	self drawItemsOn: aCanvas width: width 
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:52:14' prior: 16781539!
         upButtonPosition

	^extent x - ScrollBar scrollbarThickness@0! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'HAW 1/19/2019 06:12:38' prior: 50366908!
     mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	(self morphContainsPoint: localEventPosition)
		ifTrue: [
			((self upButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goUp ].
			((self downButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goDown ].
			self selected: (localEventPosition y // self itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'HAW 2/12/2019 18:22:48' prior: 16781585!
                             setCompleter: anAutoCompleter position: aPoint 

	completer _ anAutoCompleter.
	
	originalPosition := aPoint.
	
	self resetMenu.
	self openInWorld! !
!AutoCompleterMorph methodsFor: 'stepping' stamp: 'HAW 2/8/2019 17:14:01' prior: 16781617!
               stepAt: millisecondSinceLast

	self isShowingSelectorDocumentation ifTrue: [ ^self ].
	
	self timeOfLastActivity > self timeout
		ifTrue: [ self delete. completer menuClosed ]
		ifFalse: [self updateColor]! !
!AutoCompleterMorph class methodsFor: 'instance creation' stamp: 'HAW 2/12/2019 17:56:00' prior: 16781678!
    completer: anAutoCompleter position: aPoint 

	| newObject |

	newObject _ self new.
	newObject setCompleter: anAutoCompleter position: aPoint.

	^ newObject! !
!ClassNameRequestMorph methodsFor: 'auto complete' stamp: 'HAW 2/6/2019 20:30:26' prior: 50417225!
                            classOfThisContext

	^ MethodContext! !
!AutoCompleter methodsFor: 'menu morph' stamp: 'HAW 2/16/2019 08:33:04' prior: 16781134!
                               openCompletionMenu

	| theEditor |

	theEditor _ textMorph editor.
	position _ theEditor startIndex - 1.
	self closeMenu.
	self computeEntries.
	entries notEmpty
		ifTrue: [ | startIndex characterBlock cursorIndex |
			cursorIndex := theEditor pointIndex.
			startIndex := (theEditor text at: cursorIndex-1) = Character space 
				ifTrue: [ cursorIndex ]
				ifFalse: [ theEditor previousWordStart: (cursorIndex >  theEditor text size ifTrue: [ cursorIndex-1 ] ifFalse: [ cursorIndex ])].
			characterBlock := theEditor characterBlockForIndex: startIndex.
			menuMorph _  AutoCompleterMorph 
				completer: self
				position: characterBlock bottomLeft + textMorph morphPositionInWorld ].
! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'HAW 2/12/2019 18:22:55' prior: 16781156!
                     handleKeystrokeAfter: aKeyboardEvent
	| newPos |
	menuMorph ifNil: [^self].
	newPos _ textMorph editor startIndex-1.
	newPos = position ifTrue: [^self].
	newPos < position
		ifTrue: [
			prefix _ prefix copyFrom: 1 to: prefix size+(newPos-position).
			position _ newPos ]
		ifFalse: [
			position _ position + 1.
			prefix _ prefix copyWith: (model actualContents at: position) ].
	self computeEntries.
	entries notEmpty
		ifTrue: [ menuMorph resetMenu ]
		ifFalse: [ self closeMenu ]! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'HAW 2/8/2019 17:14:24' prior: 50415181!
 handleKeystrokeBefore: kbEvent
	
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	
	| shouldOpenMorph |
	  
	shouldOpenMorph _ self shouldOpenMorph.
	
	"Stuff to do if the menu is not open"
	menuMorph ifNil: [ ^ self openCompletionMenuFor: kbEvent if: shouldOpenMorph ].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	
	kbEvent isEsc ifTrue: [ self closeMenu. ^ true].
	kbEvent isBackspace ifTrue: [ shouldOpenMorph ifFalse: [ self closeMenu ]. ^ false].
	kbEvent isHome ifTrue: [ menuMorph goHome. ^ true ].
	kbEvent isEnd ifTrue: [ menuMorph goToEnd. ^ true].
	kbEvent isQuesitonMark ifTrue: [ menuMorph help. ^true].
	kbEvent isArrowUp ifTrue: [ menuMorph goUp. ^ true].
	kbEvent isArrowDown ifTrue: [ menuMorph goDown. ^ true].
	kbEvent isPageUp ifTrue: [ menuMorph goPageUp. ^ true].
	kbEvent isPageDown ifTrue: [ menuMorph goPageDown. ^ true].
	kbEvent isArrowRight ifTrue: [ menuMorph showSelectorDocumentation. ^ true ].
	kbEvent isArrowLeft ifTrue: [ menuMorph hideSelectorDocumentation. ^ true ].	
	(self shouldInsertSelected: kbEvent) ifTrue: [ self insertSelected ifTrue: [^ true]].
	(self shouldCloseMenu: kbEvent) ifTrue: [ self closeMenu ]. 
	 
	^false! !
!AutoCompleter methodsFor: 'entries' stamp: 'HAW 2/8/2019 17:27:05' prior: 16781274!
                               insertSelected
	
	| entry editor selEnd str |
	
	textMorph ifNil: [ ^false ].
	
	entry _ self selectedEntryFormatted.
	(self canSelect: entry) ifFalse: [ ^true ].
	
	editor _ textMorph editor.
	str _ model actualContents string.
	selEnd _ position.
	[selEnd < str size and: [ (str at: selEnd+1) tokenish ]] whileTrue: [ selEnd _ selEnd + 1 ].
	(selEnd < str size and: [ (str at: selEnd+1) = $ ]) ifTrue: [ selEnd _ selEnd + 1].
	editor selectFrom: position-prefix size+1 to: selEnd.
	editor
		replaceSelectionWith: entry;
		deselectAndPlaceCursorAt: position - prefix size + 1 + (self newCursorPosition: entry).
	textMorph redrawNeeded.
	menuMorph delete.
	menuMorph _ nil.
	
	^ true! !
!SmalltalkCompleter methodsFor: 'entries' stamp: 'HAW 2/10/2019 21:38:01' prior: 50417249!
                      computeEntries

	| allSource contextClass specificModel last3Ranges range |

	allSource _ model actualContents string.
	specificModel _ self textProviderOrModel.
	contextClass _ self selectedClassOrMetaClassIn: specificModel. 
	last3Ranges _ self parse: allSource in: contextClass and: specificModel.
	range _ last3Ranges third ifNil: [ ^entries _ #() ].
	possibleInvalidSelectors _ #().
	
	range end = position
		ifTrue: [ self computeEntriesOfMessageOrIdentifiersFor: allSource using: last3Ranges at: range in: contextClass and: specificModel ]
	 	ifFalse: [ self computeMessageEntriesWithEmptyPrefixFor: allSource at: range in: contextClass and: specificModel ].

	! !
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'HAW 2/10/2019 18:35:24' prior: 50415429!
                          parse: allSource in: contextClass and: specificModel
	
	parser _ SHParserST80 new.
	parser
		workspace: ((specificModel is: #providesBindings) ifTrue: [specificModel]);
		classOrMetaClass: contextClass;
		source: (allSource copyFrom: 1 to: position);
		allSource: allSource.
	parser parse: (specificModel is: #CodeProvider).
	
	^ parser last3Ranges.
! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/18/2019 18:13:38' prior: 50429707!
                 computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id rangeType |

	id _ allSource copyFrom: range start to: range end.
	rangeType _ range rangeType.

	rangeType == #globalVar  			ifTrue: [ ^self computeMessageEntriesForClass: (Smalltalk at: id asSymbol) class ].
	rangeType == #self  					ifTrue: [ ^self computeMessageEntriesForClass: contextClass ].
	rangeType == #super  				ifTrue: [ ^self computeMessageEntriesForClass: contextClass superclass ].
	rangeType == #true  					ifTrue: [ ^self computeMessageEntriesForClass: True ].
	rangeType == #false  				ifTrue: [ ^self computeMessageEntriesForClass: False ].
	rangeType == #nil  					ifTrue: [ ^self computeMessageEntriesForClass: UndefinedObject ].
	rangeType == #character  			ifTrue: [ ^self computeMessageEntriesForClass: id first class ].
	rangeType == #number  				ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #string  				ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #symbol  				ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #stringSymbol  		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #instVar  				ifTrue: [ ^specificModel computeMessageEntriesIn: self ofInstVarNamed: id ].
	rangeType == #methodArg  			ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #tempVar  				ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #blockArg  			ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockArgNamed: id ].
	rangeType == #blockTempVar  		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockTempVarNamed: id ].
	rangeType == #workspaceVar  		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (specificModel classOfWorkspaceVarNamed: id) ].
	rangeType == #thisContext  		ifTrue: [ ^self computeMessageEntriesForClass: (specificModel classOfThisContext) ]. 
	rangeType == #classVar  			ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #poolConstant  		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #blockEnd  			ifTrue: [ ^self computeMessageEntriesForClass: BlockClosure ].
	rangeType == #arrayEnd  			ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #rightBrace  			ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #unary  				ifTrue: [ ^self computeEntriesOfUnaryMessageReturnNamed: id at: range ].
	rangeType == #rightParenthesis  	ifTrue: [ ^self computeMessageEntriesOfEnclosedExpressionReturnAt: range ].
	rangeType == #cascadeSeparator  	ifTrue: [ ^self computeMessageEntriesOfCascadeReceiverAt: range ]. 

	self computeMessageEntriesForUnknowClass 
	
	! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/8/2019 12:18:59' prior: 50415017!
                           computeMessageEntriesWhenSendinMessageFor: allSource using: last3Ranges in: contextClass and: specificModel 
	
	| prevPrevRange prevRange |
	
	"If previous range is a constant or a well known identifier, we might filter messages"
	prevRange _ last3Ranges second.
	prevPrevRange _ last3Ranges first.
	
	"3 if -> ifNil: but not ifTrue:
	3=4 -> ifNil: or ifTrue:"
	^ (self canComputeMessageEntriesFor: prevRange and: prevPrevRange) 
		ifTrue: [ self computeMessageEntriesFor: allSource at: prevRange in: contextClass and: specificModel ]
		ifFalse: [ self computeMessageEntriesForUnknowClass ]
! !
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'HAW 2/15/2019 15:36:56' prior: 50424406!
                               initialize
	"
	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...
	[ SmalltalkCompleter initialize ]timeToRun
	Selectors inspect
	"
	| maxSortValue allImplemented |
	
	EntriesLimit _ 100.
	
	SystemChangeNotifier uniqueInstance
		removeActionsWithReceiver: self.	 "avoid double registration"

	SystemChangeNotifier uniqueInstance
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #methodAdded send: #methodAdded:selector:inClass:requestor: to: self;
		when: #methodAddedInProtocol send: #methodAdded:selector:inProtocol:class:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self.
	
	self protected: [
		allImplemented _ Smalltalk allImplementedMessages.
		Selectors _ Trie new.
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				Selectors at: sel ifAbsentPut: [ 0 ].
				method messages do: [ :sentMsg |
					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				self addSelector: sel method: method allImplemented: allImplemented]].
		""
	
		"The following might not be found in #messages. Give them maximum priority."
		maxSortValue _ SmallInteger maxVal.
		"From MessageNode>>#initialize"
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |
				Selectors at: sel put: maxSortValue ].
	
		maxSortValue _ SmallInteger maxVal-1.
		"From SystemDictionary >>#recreateSpecialObjectsArray"
		(1 to: Smalltalk specialSelectorSize) do:  [ :i |
				Selectors at: (Smalltalk specialSelectorAt: i) put: maxSortValue ]]! !

AutoCompleterSelectorsCollector class removeSelector: #for:limitingNumberOfSelectorsTo:!

AutoCompleterSelectorsCollector class removeSelector: #for:withALimitOf:!

AutoCompleterSelectorsCollector removeSelector: #addEntriesToShowTo:!

AutoCompleterSelectorsCollector removeSelector: #addPrioritzedCategory:!

AutoCompleterSelectorsCollector removeSelector: #addPrioritzedCategory:with:!

AutoCompleterSelectorsCollector removeSelector: #hasReachNumberOfSelectorsLimit!

AutoCompleterSelectorsCollector removeSelector: #initialize!

AutoCompleterSelectorsCollector removeSelector: #initializeFor:!

AutoCompleterSelectorsCollector removeSelector: #initializeFor:limitingNumberOfSelectorsTo:!

AutoCompleterSelectorsCollector removeSelector: #markAddedSelectorsAsPossibleInvalid!

AutoCompleterSelectorsCollector removeSelector: #priorizeCategories!

DynamicTypingSmalltalkCompleter removeSelector: #computeMessageEntriesOfOfEnclosedExpressionReturnAt:!

SmalltalkCompleter removeSelector: #computeMessageEntries:!

SmalltalkCompleter removeSelector: #computeMessageEntries:!

SmalltalkCompleter removeSelector: #computeMessageEntriesForSelectors:!

SmalltalkCompleter removeSelector: #computeMessageEntriesForSelectors:!

SmalltalkCompleter removeSelector: #returnTypeOfEnclosedExpressionAt:!

SmalltalkCompleter removeSelector: #returnTypeOfEnclosedExpressionAt:!

SmalltalkCompleter removeSelector: #returnTypeOfUnaryMessage:at:!

SmalltalkCompleter removeSelector: #returnTypeOfUnaryMessage:at:!

SmalltalkCompleter removeSelector: #selectedEntry!

SmalltalkCompleter removeSelector: #selectedEntry!

SmalltalkCompleter removeSelector: #typeOfCascadeReceiverAt:!

SmalltalkCompleter removeSelector: #typeOfCascadeReceiverAt:!

SmalltalkCompleter removeSelectorIfInBaseSystem: #withMethodNodeOf:do:ifError:!

SmalltalkCompleter removeSelector: #withMethodNodeOf:do:ifError:!

SmalltalkCompleter removeSelectorIfInBaseSystem: #withMethodNodeOfAllSourceCodeDo:ifError:!

SmalltalkCompleter removeSelector: #withMethodNodeOfAllSourceCodeDo:ifError:!

AutoCompleter removeSelector: #keyStroke:!

ClassNameRequestMorph removeSelector: #classOfBlockArgNamed:!

ClassNameRequestMorph removeSelector: #classOfBlockArgNamed:!

ClassNameRequestMorph removeSelector: #classOfBlockTempVarNamed:!

ClassNameRequestMorph removeSelector: #classOfBlockTempVarNamed:!

ClassNameRequestMorph removeSelector: #classOfInstVarNamed:!

ClassNameRequestMorph removeSelector: #classOfInstVarNamed:!

ClassNameRequestMorph removeSelector: #classOfTempVarNamed:!

ClassNameRequestMorph removeSelector: #classOfTempVarNamed:!

AutoCompleterMorph removeSelector: #adjust:ifOutOfScreenWith:!

AutoCompleterMorph removeSelector: #adjust:ifOutOfScreenWith:xOffset:!

AutoCompleterMorph removeSelector: #adjustPositionIfOutOfScreen!

AutoCompleterMorph removeSelector: #adjustPositionIfOutOfScreen:!

AutoCompleterMorph removeSelector: #adjustedIfOutOfScreen:!

AutoCompleterMorph removeSelector: #drawItemOn:width:!

AutoCompleterMorph removeSelector: #isOutOfScreen:with:!

AutoCompleterMorph removeSelector: #privateExtent:!

AutoCompleterMorph removeSelector: #resetMenu:!

AutoCompleterMorph removeSelector: #selectorDocumentationLocation!

AutoCompleterMorph removeSelector: #testxxx!

AutoCompleterMorph removeSelector: #testxxxxx!

Inspector removeSelector: #classOfInstVarNamed:!

Inspector removeSelector: #classOfInstVarNamed:!

Debugger removeSelector: #classOfBlockArgNamed:!

Debugger removeSelector: #classOfBlockArgNamed:!

Debugger removeSelector: #classOfBlockTempVarNamed:!

Debugger removeSelector: #classOfBlockTempVarNamed:!

Debugger removeSelector: #classOfInstVarNamed:!

Debugger removeSelector: #classOfInstVarNamed:!

Debugger removeSelector: #classOfTempVarNamed:!

Debugger removeSelector: #classOfTempVarNamed:!

TextProvider removeSelector: #classOfBlockArgNamed:!

TextProvider removeSelector: #classOfBlockArgNamed:!

TextProvider removeSelector: #classOfBlockTempVarNamed:!

TextProvider removeSelector: #classOfBlockTempVarNamed:!

TextProvider removeSelector: #classOfInstVarNamed:!

TextProvider removeSelector: #classOfInstVarNamed:!

TextProvider removeSelector: #classOfTempVarNamed:!

TextProvider removeSelector: #classOfTempVarNamed:!

Workspace removeSelector: #classOfTempVarNamed:!

Workspace removeSelector: #classOfTempVarNamed:!

PluggableTextModel removeSelector: #classOfBlockArgNamed:!

PluggableTextModel removeSelector: #classOfBlockArgNamed:!

PluggableTextModel removeSelector: #classOfBlockTempVarNamed:!

PluggableTextModel removeSelector: #classOfBlockTempVarNamed:!

PluggableTextModel removeSelector: #classOfInstVarNamed:!

PluggableTextModel removeSelector: #classOfInstVarNamed:!

PluggableTextModel removeSelector: #classOfTempVarNamed:!

PluggableTextModel removeSelector: #classOfTempVarNamed:!

TextModel removeSelector: #classOfBlockArgNamed:!

TextModel removeSelector: #classOfBlockArgNamed:!

TextModel removeSelector: #classOfBlockTempVarNamed:!

TextModel removeSelector: #classOfBlockTempVarNamed:!

TextModel removeSelector: #classOfInstVarNamed:!

TextModel removeSelector: #classOfInstVarNamed:!

TextModel removeSelector: #classOfTempVarNamed:!

TextModel removeSelector: #classOfTempVarNamed:!

BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #AutoCompleterMorph category: #'Tools-Autocompletion'!
BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser selectorsClasses possibleInvalidSelectors'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #SmalltalkCompleter category: #'Tools-Autocompletion'!
AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser selectorsClasses possibleInvalidSelectors'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

SmalltalkCompleter initialize!

Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepths blockDepthsStartIndexes allSource'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

!classDefinition: #SHParserST80 category: #'Tools-Syntax Highlighting'!
Object subclass: #SHParserST80
	instanceVariableNames: 'classOrMetaClass source workspace arguments sourcePosition currentToken currentTokenFirst temporaries instanceVariables errorBlock currentTokenSourcePosition blockDepth bracketDepth ranges blockDepths blockDepthsStartIndexes allSource'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Syntax Highlighting'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3616-AutoCompleterBigRefactor-HernanWilkinson-2019Jan18-00h58m-HAW.4.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3590] on 19 February 2019 at 2:19:45 pm'!
!MethodNode methodsFor: 'accessing' stamp: 'HAW 2/19/2019 14:19:05'!
               argumentNames
	
	^arguments collect: [ :anArgumentNode | anArgumentNode name ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3617-MethodNode-argumentNames-HernanWilkinson-2019Feb19-14h11m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3612] on 19 February 2019 at 12:26:57 pm'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'jmv 2/19/2019 12:26:00' prior: 50432869!
             computeIdentifierEntries
	"Use an aux Set to avoid duplicates, but keep the order given."
	| entriesSet lastTitle |
	
	entriesSet _ Set new.
	lastTitle _ nil.
	entries _ Array streamContents: [ :strm |
		parser namesBeginningWith: prefix do: [ :identifier :kindOfIdentifierTitle |
			(entriesSet includes: identifier) ifFalse: [
				kindOfIdentifierTitle = lastTitle ifFalse: [
					strm nextPut: kindOfIdentifierTitle.
					lastTitle _ kindOfIdentifierTitle ].
				entriesSet  add: identifier.
				strm nextPut: identifier ]]]! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:28' prior: 50432889!
             isBlockArgName: aString 
	"Answer true if aString is the name of a block argument, false otherwise"

	self blockArgNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:18' prior: 50432898!
       isBlockTempName: aString 
	"Answer true if aString is the name of a block temporary. false otherwise"

	self blockTempNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:31' prior: 50432907!
    isIncompleteBlockArgName: aString 
	"Answer true if aString is the start of the name of a block argument, false otherwise"

	self blockArgNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:21' prior: 50432917!
    isIncompleteBlockTempName: aString 
	"Answer true if aString is the start of the name of a block temporary. false otherwise"

	self blockTempNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:09:05' prior: 50432927!
 isIncompleteClassVarName: aString 
	"Answer true if aString is the start of the name of a class variable, false otherwise"

	self classVarNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:54' prior: 50432937!
    isIncompleteInstVarName: aString 
	"Answer true if aString is the start of the name of an instance variable, false otherwise"

	self instVarNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:42' prior: 50432947!
  isIncompleteMethodArgName: aString 
	"Answer true if aString is the start of the name of a method argument, false otherwise.
    Does not check whether aString is also a blockArgName"

	self methodArgNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:34' prior: 50432959!
      isIncompleteMethodTempName: aString 
	"Answer true if aString is the start of the name of a method temporary, false otherwise."

	self methodTempNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:07:49' prior: 50432970!
                             isIncompletePoolConstantName: aString 
	"Answer true if aString is the start of the name of a pool constant, false otherwise"

	self poolConstantNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:07:38' prior: 50432981!
                             isIncompleteWorkspaceVarName: aString 
	"Answer true if aString is the  start of the name of an workspace variable, false otherwise"

	self workspaceNamesDo: [ :arg :dummy | (arg beginsWith: aString) ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:58' prior: 50432992!
                         isInstVarName: aString 
	"Answer true if aString is the name of an instance variable, false otherwise"

	self instVarNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:45' prior: 50433001!
     isMethodArgName: aString 
	"Answer true if aString is the name of a method argument, false otherwise.
    Does not check whether aString is also a blockArgName"

	self methodArgNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'identifier testing' stamp: 'jmv 2/19/2019 12:08:28' prior: 50433012!
         isMethodTempName: aString 
	"Answer true if aString is the name of a method temporary, false otherwise.
    Does not check whether aString is also a block temporary
    or argument"

	self methodTempNamesDo: [ :arg :dummy | arg = aString ifTrue: [ ^true ]].
	^false! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:23:37' prior: 50433024!
                blockArgNamesDo: aBlock
	"Iterate over block argument names valid at current blockDepth"

	| title |
	title _ '-- Block Arguments'.
	blockDepth to: 1 by: -1 do: [ :level |
		arguments at: level ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:23:47' prior: 50433036!
           blockTempNamesDo: aBlock
	"Iterate over block temp names valid at current blockDepth"

	| title |
	title _ '-- Block Variables'.
	blockDepth to: 1 by: -1 do: [ :level |
		temporaries at: level ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:23:53' prior: 50433048!
            classVarNamesDo: aBlock

	| title |
	title _ '-- Class Variables'.
	classOrMetaClass isBehavior 
		ifTrue: [
			classOrMetaClass theNonMetaClass withAllSuperclasses do: [ :c |
				c classPool keysDo: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:00' prior: 50433060!
   instVarNamesDo: aBlock

	| title |
	title _ '-- Instance Variables'.
	instanceVariables do: [ :name | aBlock value: name value: title ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:05' prior: 50433068!
                  methodArgNamesDo: aBlock
	"Iterate over method argument names"

	| title |
	title _ '-- Method Arguments'.
	^arguments at: 0  ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:10' prior: 50433078!
                methodTempNamesDo: aBlock
	"Iterate over method temporary names"

	| title |
	title _ '-- Method Variables'.
	^temporaries at: 0 ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:20:50' prior: 50433088!
             namesBeginningWith: aString do: aBlock
	"Evaluate aBlock for all available names that start with aString"

	self nonGlobalNamesDo: [ :name :kindOfIdentifierTitle |
		(name beginsWith: aString) ifTrue: [ aBlock value: name value: kindOfIdentifierTitle ]].
	self namesBeginningWith: aString do: [ :name | aBlock value: name value: '-- Classes' ] in: Smalltalk classNames.
	self namesBeginningWith: aString do: [ :name | aBlock value: name value: '-- Globals' ] in: Smalltalk nonClassNames! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:43' prior: 50433107!
                   nonGlobalNamesDo: aBlock
	"Evaluate aBlock over all available names, except for globals"

	self
		blockArgNamesDo: aBlock;
		blockTempNamesDo: aBlock;
		methodArgNamesDo: aBlock;
		methodTempNamesDo: aBlock;
		instVarNamesDo: aBlock;
		classVarNamesDo: aBlock;
		poolConstantNamesDo: aBlock;
		workspaceNamesDo: aBlock.
	self
		reservedNames do: [ :name |
			aBlock value: name value: '-- Pseudovariables'  ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:24:53' prior: 50433124!
 poolConstantNamesDo: aBlock

	| title |
	title _ '-- Pool Variables'.
	classOrMetaClass isBehavior 
		ifTrue: [
			classOrMetaClass theNonMetaClass withAllSuperclasses do: [ :c |
				c sharedPools do: [ :pool |
					pool bindingsDo: [ :assoc | aBlock value: assoc key value: title ]]]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/19/2019 12:25:01' prior: 50433137!
                            workspaceNamesDo: aBlock

	| title |
	title _ '-- Workspace Variables'.
	workspace ifNotNil: [
		workspace bindingNamesDo: [ :name | aBlock value: name value: title ] ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3618-Autocompleter-GroupNamesByKind-JuanVuletich-2019Feb19-11h50m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3618] on 20 February 2019 at 6:32:54 pm'!
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:21:26'!
                              defaultFont11
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont11
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 11)
			(setListFontTo: 11)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 11)
			(setButtonFontTo: 11)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:21:31'!
      defaultFont14
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont14
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 14)
			(setListFontTo: 14)
			(setMenuFontTo: 14)
			(setWindowTitleFontTo: 17)
			(setCodeFontTo: 14)
			(setButtonFontTo: 14)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:21:37'!
      defaultFont17
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences defaultFont17
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 17)
			(setListFontTo: 17)
			(setMenuFontTo: 17)
			(setWindowTitleFontTo: 22)
			(setCodeFontTo: 17)
			(setButtonFontTo: 17)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:21:43'!
              defaultFont22
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences defaultFont22
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 22)
			(setListFontTo: 22)
			(setMenuFontTo: 22)
			(setWindowTitleFontTo: 28)
			(setCodeFontTo: 22)
			(setButtonFontTo: 22)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:15:18'!
              defaultFont28
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont28
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 28)
			(setListFontTo: 28)
			(setMenuFontTo: 28)
			(setWindowTitleFontTo: 36)
			(setCodeFontTo: 28)
			(setButtonFontTo: 28)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:16:03'!
    defaultFont36
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont36
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 36)
			(setListFontTo: 36)
			(setMenuFontTo: 36)
			(setWindowTitleFontTo: 46)
			(setCodeFontTo: 36)
			(setButtonFontTo: 36)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:17:21'!
    defaultFont46
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont46
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 46)
			(setListFontTo: 46)
			(setMenuFontTo: 46)
			(setWindowTitleFontTo: 60)
			(setCodeFontTo: 46)
			(setButtonFontTo: 46)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:17:47'!
    defaultFont60
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont60
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 60)
			(setListFontTo: 60)
			(setMenuFontTo: 60)
			(setWindowTitleFontTo: 80)
			(setCodeFontTo: 60)
			(setButtonFontTo: 60)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:11:33'!
    defaultFont8
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont8
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 8)
			(setMenuFontTo: 8)
			(setWindowTitleFontTo: 11)
			(setCodeFontTo: 8)
			(setButtonFontTo: 8)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:18:00'!
                     defaultFont80
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont80
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 80)
			(setListFontTo: 80)
			(setMenuFontTo: 80)
			(setWindowTitleFontTo: 80)
			(setCodeFontTo: 80)
			(setButtonFontTo: 80)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:20:55'!
    defaultFont9
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont9
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:12:32' prior: 50397731!
    standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	self defaultFont9! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/20/2019 18:21:06' prior: 50397787!
                           verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences verySmallFonts
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 7)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 2/20/2019 18:03:06' prior: 50372561!
                              install: aString
"
StrikeFont install: 'DejaVu'.

StrikeFont install: 'DejaVu Sans'.
StrikeFont buildLargerPunctuation: 'DejaVu Sans'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans'.
Preferences standardFonts.
Character initialize.
"
"
StrikeFont install: 'DejaVu Sans Mono'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans Mono'.
Preferences bigFonts.
Character initialize.
"
"
StrikeFont install: 'Inconsolata'
StrikeFont install: '#PilGi'
StrikeFont install: 'Optima'
StrikeFont install: 'Herculanum'
StrikeFont install: 'Papyrus'
StrikeFont install: 'Handwriting - Dakota'
StrikeFont install: 'Times New Roman'
StrikeFont install: 'Apple Chancery'
StrikeFont install: 'Cochin'
StrikeFont install: 'Cracked'
StrikeFont install: 'Zapfino'
StrikeFont install: 'Brush Script MT'
StrikeFont install: 'Chalkboard'
"
	| fontDict |
	fontDict _ AvailableFonts at: aString ifAbsentPut: Dictionary new.
	#(5 6 7 8 9 10 11 12 14 17 22 28 36 48 60 80) do: [ :s |
		(self create: aString size: s bold: true italic: true boldItalic: false) ifNotNil: [ :font |
			fontDict
				at: s
				put: font ]].
	Preferences restoreDefaultFonts! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/6/2018 16:21:32' prior: 50397858!
                              preferencesMenu
	"Build the preferences menu for the world."

	^ (self menu: 'Preferences...')
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Focus follows mouse'.
				#object 			-> 		Preferences.
				#selector 		-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#label 			-> 		'Click to focus'.
				#object 			-> 		Preferences.
				#selector 		-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#label 			-> 		'Font Sizes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 		-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 		-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Full screen on'.
				#selector 		-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#label 			-> 		'Full screen off'.
				#selector 		-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			nil.
			{
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 		-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#label 			-> 		'All preferences...'.
				#object 			-> 		Preferences.
				#selector 		-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 2/20/2019 18:32:44' prior: 50397951!
        changeFontSizes
	| availableSizes menu |
	availableSizes _ AbstractFont pointSizesFor: Preferences defaultFontFamily.
	menu _ (MenuMorph new defaultTarget: Preferences)
		addTitle: 'Choose a size';
		addStayUpIcons.
	(availableSizes includes: 80) ifTrue: [
		menu add: 'Very High Resolution / Big Fonts (80pix)' action: #defaultFont80 ].
	(availableSizes includes: 80) ifTrue: [
		menu add: 'Very High Resolution / Big Fonts (60pix)' action: #defaultFont60 ].
	(availableSizes includes: 60) ifTrue: [
		menu add: 'Very High Resolution / Reg Fonts (46pix)' action: #defaultFont46 ].
	(availableSizes includes: 46) ifTrue: [
		menu add: 'Very High Resolution / Reg Fonts (36pix)' action: #defaultFont36 ].
	(availableSizes includes: 36) ifTrue: [
		menu add: 'High Resolution / Big Fonts (28pix)' action: #defaultFont28 ].
	(availableSizes includes: 28) ifTrue: [
		menu add: 'High Resolution / Big Fonts (22pix)' action: #defaultFont22 ].
	menu
		add: 'High Resolution / Reg Fonts (17pix)' action: #defaultFont17;
		add: 'High Resolution / Reg Fonts  (14pix)' action: #defaultFont14;
		add: 'Standard Resolution (11pix)' action: #defaultFont11;
		add: 'Standard Resolution (9pix)' action: #defaultFont9;
		add: 'Small Fonts (8pix)' action: #defaultFont8;
		add: 'Very small Fonts'action: #verySmallFonts;
		add: 'Tiny Fonts'action: #tinyFonts;
		popUpInWorld: self runningWorld! !

Preferences class removeSelector: #bigFonts!

Preferences class removeSelector: #bigFonts!

Preferences class removeSelector: #hugeFonts!

Preferences class removeSelector: #hugeFonts!

Preferences class removeSelector: #smallFonts!

Preferences class removeSelector: #smallFonts!

Preferences class removeSelector: #veryBigFonts!

Preferences class removeSelector: #veryBigFonts!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3619-BiggerFontSizes-JuanVuletich-2019Feb20-18h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3590] on 20 February 2019 at 6:18:18 pm'!
!Behavior methodsFor: 'auto complete' stamp: 'HAW 2/19/2019 17:53:31'!
         typeName

	"If the class whishes to be shown in a different way in the selectors documentation. 
	For example, DenotativeObject does not show it self as a metaclass but as a class - Hernan"
	
	^self name! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting - private' stamp: 'HAW 2/19/2019 15:44:12'!
            addCategory: aCategory of: classOrganization

	| categorySelectors selectedSelectors |

	selectedSelectors := self prefixedSelectorsOf: aCategory in: classOrganization.
	selectedSelectors isEmpty ifFalse: [ 
		categorySelectors := categoriesWithSelectors at: aCategory ifAbsentPut: [ OrderedCollection new ].
		categorySelectors addAll: selectedSelectors.
		self addedSelectors: selectedSelectors.
		self addToPossibleInvalidIfCorrespond: selectedSelectors ]! !
!CompiledMethod methodsFor: 'auto complete' stamp: 'HAW 2/19/2019 17:53:31' prior: 50433442!
                     receiverTextAutoCompleterDocumentation
	
	| receiverString |
	
	receiverString := String streamContents: [ :stream |
		stream 
			nextPutAll: self methodClass typeName;
			nextPutAll: '>>' ].
	
	^Text string: receiverString attributes: (SHTextStylerST80 attributesFor: #patternKeyword).
		
	! !
!AutoCompleterSelectorsCollector methodsFor: 'collecting - private' stamp: 'HAW 2/19/2019 15:43:38' prior: 50434102!
    addCategoriesAndSelectorsOf: aClass

	| classOrganization |
	
	classOrganization := aClass organization.
	
	classOrganization categories do: [ :aCategory | 
		self hasReachSelectorsLimit ifTrue: [ ^ self ].
		self addCategory: aCategory of: classOrganization ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3620-Autocompleter-tweaks-HernanWilkinson-2019Feb19-14h19m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3620] on 20 February 2019 at 7:05:43 pm'!
!CodePackageList methodsFor: 'as yet unclassified' stamp: 'HAW 2/20/2019 19:05:23'!
              methodNodeOf: aSourceCode ifErrorsParsing: aParsingErrorBlock

	^aParsingErrorBlock value: nil! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3621-PackageListFix-HernanWilkinson-2019Feb20-19h04m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3621] on 20 February 2019 at 8:00:52 pm'!
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 2/20/2019 19:58:58' prior: 50435474!
           install: aString
"
StrikeFont install: 'DejaVu'.

StrikeFont install: 'DejaVu Sans'.
StrikeFont buildLargerPunctuation: 'DejaVu Sans'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans'.
Preferences standardFonts.
Character initialize.
"
"
StrikeFont install: 'DejaVu Sans Mono'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans Mono'.
Preferences bigFonts.
Character initialize.
"
"
StrikeFont install: 'Inconsolata'
StrikeFont install: '#PilGi'
StrikeFont install: 'Optima'
StrikeFont install: 'Herculanum'
StrikeFont install: 'Papyrus'
StrikeFont install: 'Handwriting - Dakota'
StrikeFont install: 'Times New Roman'
StrikeFont install: 'Apple Chancery'
StrikeFont install: 'Cochin'
StrikeFont install: 'Cracked'
StrikeFont install: 'Zapfino'
StrikeFont install: 'Brush Script MT'
StrikeFont install: 'Chalkboard'
"
	| fontDict |
	fontDict _ nil.
	#(5 6 7 8 9 10 11 12 14 17 22 28 36 46 60 80) do: [ :s |
		(self create: aString size: s bold: true italic: true boldItalic: false) ifNotNil: [ :font |
			fontDict ifNil: [ fontDict _ AvailableFonts at: aString ifAbsentPut: Dictionary new ].
			fontDict
				at: s
				put: font ]].
	Preferences restoreDefaultFonts! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3622-StrikeFontTweak-JuanVuletich-2019Feb20-20h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3622] on 22 February 2019 at 4:50:06 pm'!
!SmalltalkCompleter methodsFor: 'entries - private ' stamp: 'jmv 2/22/2019 16:49:15' prior: 50434965!
                            computeIdentifierEntries
	"Use an aux Set to avoid duplicates, but keep the order given."
	| entriesSet lastTitle |
	
	entriesSet _ Set new.
	lastTitle _ nil.
	entries _ Array streamContents: [ :strm |
		parser namesBeginningWith: prefix do: [ :identifier :kindOfIdentifierTitle |
			(entriesSet includes: identifier) ifFalse: [
				kindOfIdentifierTitle = lastTitle ifFalse: [
					strm nextPut: kindOfIdentifierTitle.
					lastTitle _ kindOfIdentifierTitle ].
				entriesSet  add: identifier.
				strm nextPut: identifier ]]].
	entriesSet size = 1 ifTrue: [
		entries _ Array with: entriesSet anyOne ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:41:34' prior: 50435120!
                              blockArgNamesDo: aBlock
	"Iterate over block argument names valid at current blockDepth"

	| title |
	title _ '-- block arguments'.
	blockDepth to: 1 by: -1 do: [ :level |
		arguments at: level ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:41:41' prior: 50435132!
           blockTempNamesDo: aBlock
	"Iterate over block temp names valid at current blockDepth"

	| title |
	title _ '-- block variables'.
	blockDepth to: 1 by: -1 do: [ :level |
		temporaries at: level ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:41:48' prior: 50435144!
            classVarNamesDo: aBlock

	| title |
	title _ '-- class variables'.
	classOrMetaClass isBehavior 
		ifTrue: [
			classOrMetaClass theNonMetaClass withAllSuperclasses do: [ :c |
				c classPool keysDo: [ :name | aBlock value: name value: title ] ]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:42:08' prior: 50435155!
   instVarNamesDo: aBlock

	| title |
	title _ '-- instance variables'.
	instanceVariables do: [ :name | aBlock value: name value: title ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:42:17' prior: 50435163!
                  methodArgNamesDo: aBlock
	"Iterate over method argument names"

	| title |
	title _ '-- method arguments'.
	^arguments at: 0  ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:42:24' prior: 50435173!
                methodTempNamesDo: aBlock
	"Iterate over method temporary names"

	| title |
	title _ '-- method variables'.
	^temporaries at: 0 ifPresent: [ :args | args do: [ :name | aBlock value: name value: title ] ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:42:33' prior: 50435183!
             namesBeginningWith: aString do: aBlock
	"Evaluate aBlock for all available names that start with aString"

	self nonGlobalNamesDo: [ :name :kindOfIdentifierTitle |
		(name beginsWith: aString) ifTrue: [ aBlock value: name value: kindOfIdentifierTitle ]].
	self namesBeginningWith: aString do: [ :name | aBlock value: name value: '-- classes' ] in: Smalltalk classNames.
	self namesBeginningWith: aString do: [ :name | aBlock value: name value: '-- globals' ] in: Smalltalk nonClassNames! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:43:00' prior: 50435202!
                   nonGlobalNamesDo: aBlock
	"Evaluate aBlock over all available names, except for globals"

	self
		blockArgNamesDo: aBlock;
		blockTempNamesDo: aBlock;
		methodArgNamesDo: aBlock;
		methodTempNamesDo: aBlock;
		instVarNamesDo: aBlock;
		classVarNamesDo: aBlock;
		poolConstantNamesDo: aBlock;
		workspaceNamesDo: aBlock.
	self
		reservedNames do: [ :name |
			aBlock value: name value: '-- pseudovariables'  ]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:43:31' prior: 50435218!
 poolConstantNamesDo: aBlock

	| title |
	title _ '-- pool variables'.
	classOrMetaClass isBehavior 
		ifTrue: [
			classOrMetaClass theNonMetaClass withAllSuperclasses do: [ :c |
				c sharedPools do: [ :pool |
					pool bindingsDo: [ :assoc | aBlock value: assoc key value: title ]]]]! !
!SHParserST80 methodsFor: 'indentifier iteration' stamp: 'jmv 2/22/2019 16:43:38' prior: 50435231!
                            workspaceNamesDo: aBlock

	| title |
	title _ '-- workspace variables'.
	workspace ifNotNil: [
		workspace bindingNamesDo: [ :name | aBlock value: name value: title ] ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3623-Autocompleter-NameGroupingTweaks-JuanVuletich-2019Feb22-16h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3623] on 22 February 2019 at 5:03:32 pm'!
!Preferences class methodsFor: 'fonts' stamp: 'jmv 2/22/2019 17:03:19' prior: 50372167!
                             setDefaultFont: fontFamilyName spec: defaultFontsSpec
		
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ AbstractFont familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [
			StrikeFont install: Preferences defaultFontFamily.
			font _ AbstractFont familyName: fontFamilyName pointSize: triplet second ].
		font ifNil: [ font _ AbstractFont default ]. 
		triplet size > 2 ifTrue: [
			font _ font emphasized: triplet third ].
		self
			perform: triplet first
			with: font]! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 2/22/2019 16:57:45' prior: 50372475!
          create: fontName size: pointSize bold: includeBold italic: includeItalic boldItalic: includeBoldItalic
	"
	self create: 'DejaVu Sans Mono' size: 12 bold: true italic: true boldItalic: true
	"
	| folder base bold oblique boldOblique point |
	folder _ DirectoryEntry smalltalkImageDirectory / 'AdditionalFontData'.
	point _ pointSize asString.
	base _ [ (StrikeFont new
		buildFromForm: ((Form fromFileEntry: folder // (fontName, '-0-', point, '.bmp')) asFormOfDepth: 16)
		data: (folder // (fontName, '-0-', point, '.txt')) fileContents substrings
		name: fontName, ' ', point)
			pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | nil ].
	includeBold ifTrue: [
		bold _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-1-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-1-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'B')
				emphasis: 1;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | nil ]].
	includeItalic ifTrue: [
		oblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-2-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-2-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'I')
				emphasis: 2;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | nil ]].
	includeBoldItalic ifTrue: [
		boldOblique _ [ (StrikeFont new
			buildFromForm: ((Form fromFileEntry: folder // (fontName, '-3-', point, '.bmp')) asFormOfDepth: 16)
			data: (folder // (fontName, '-3-', point, '.txt')) fileContents substrings
			name: fontName, ' ', point, 'BI')
				emphasis: 3;
				pointSize: pointSize ] on: FileDoesNotExistException do: [ : ex | nil ]].
	"We have a regular, base font. Make others derivatives of it"
	base ifNotNil: [
		bold ifNotNil: [
			base derivativeFont: bold at: 1 ].
		oblique ifNotNil: [
			base derivativeFont: oblique at: 2].
		boldOblique ifNotNil: [
			base derivativeFont: boldOblique at: 3 ].
		^base ].
	"We don't have a base, regular font."
	oblique ifNotNil: [
		oblique emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		bold ifNotNil: [
			oblique derivativeFont: bold at: 1 ].
		boldOblique ifNotNil: [
			oblique derivativeFont: boldOblique at: 3 ].
		^oblique ].
	bold ifNotNil: [
		bold emphasis: 0.	"Hacky. Non regular fonts can not have derivatives. Should change this?"
		boldOblique ifNotNil: [
			bold derivativeFont: boldOblique at: 3 ].
		^bold ].
	boldOblique ifNotNil: [
		^boldOblique ].
	^nil! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 2/22/2019 16:59:13' prior: 50435739!
install: aString
"
StrikeFont install: 'DejaVu'.
"
"
StrikeFont install: 'DejaVu Sans Mono'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans Mono'.
Preferences bigFonts.
Character initialize.
"
"
StrikeFont install: 'DejaVu Sans'.
StrikeFont buildLargerPunctuation: 'DejaVu Sans'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans'.
Preferences standardFonts.
Character initialize.
"
"
StrikeFont install: 'Inconsolata'
StrikeFont install: '#PilGi'
StrikeFont install: 'Optima'
StrikeFont install: 'Herculanum'
StrikeFont install: 'Papyrus'
StrikeFont install: 'Handwriting - Dakota'
StrikeFont install: 'Times New Roman'
StrikeFont install: 'Apple Chancery'
StrikeFont install: 'Cochin'
StrikeFont install: 'Cracked'
StrikeFont install: 'Zapfino'
StrikeFont install: 'Brush Script MT'
StrikeFont install: 'Chalkboard'
"
	| fontDict |
	fontDict _ nil.
	1 to: 200 do: [ :s |
		(self create: aString size: s bold: true italic: true boldItalic: false) ifNotNil: [ :font |
			font print.
			fontDict ifNil: [ fontDict _ AvailableFonts at: aString ifAbsentPut: Dictionary new ].
			fontDict
				at: s
				put: font ]].
	Preferences restoreDefaultFonts! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 2/22/2019 17:02:20' prior: 50435600!
       changeFontSizes

	(MenuMorph new defaultTarget: Preferences)
		addTitle: 'Choose a size';
		addStayUpIcons;
		add: 'Very High Resolution / Big Fonts (80pix)' action: #defaultFont80;
		add: 'Very High Resolution / Big Fonts (60pix)' action: #defaultFont60;
		add: 'Very High Resolution / Reg Fonts (46pix)' action: #defaultFont46;
		add: 'Very High Resolution / Reg Fonts (36pix)' action: #defaultFont36;
		add: 'High Resolution / Big Fonts (28pix)' action: #defaultFont28;
		add: 'High Resolution / Big Fonts (22pix)' action: #defaultFont22;
		add: 'High Resolution / Reg Fonts (17pix)' action: #defaultFont17;
		add: 'High Resolution / Reg Fonts  (14pix)' action: #defaultFont14;
		add: 'Standard Resolution (11pix)' action: #defaultFont11;
		add: 'Standard Resolution (9pix)' action: #defaultFont9;
		add: 'Small Fonts (8pix)' action: #defaultFont8;
		add: 'Very small Fonts'action: #verySmallFonts;
		add: 'Tiny Fonts'action: #tinyFonts;
		popUpInWorld: self runningWorld! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3624-AdditionalFontInstallingEnhancements-JuanVuletich-2019Feb22-16h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3622] on 21 February 2019 at 3:10:53 pm'!
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 11:51:45' prior: 50433490!
                resetMenu
	
	| width newExtent adjustedY |
	
	self hideSelectorDocumentation.
	firstVisible _ 1.
	self selected: 1.

	width _ self calculateWidth.
	newExtent _ width + 4 @ (self visibleItemsCount * self itemHeight+2).
	
	adjustedY := (self isYOutOfScreen: originalPosition with: newExtent) 
		ifTrue: [ originalPosition y - newExtent y - self itemHeight ]
		ifFalse: [ originalPosition y ].

	self morphPosition: originalPosition x @ adjustedY extent: newExtent.
	"redraw is needed even if position and extent haven't changed"
	self redrawNeeded ! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3625-AutoCompleterMorphRedraw-HernanWilkinson-2019Feb21-08h18m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3622] on 21 February 2019 at 5:09:48 pm'!

AutoCompleter subclass: #ClassNameCompleter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #ClassNameCompleter category: #'Tools-Autocompletion'!
AutoCompleter subclass: #ClassNameCompleter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser selectorsClasses possibleInvalidSelectors canShowSelectorDocumentation '
	classVariableNames: 'AccessLock EntriesLimit Selectors '
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #SmalltalkCompleter category: #'Tools-Autocompletion'!
AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser selectorsClasses possibleInvalidSelectors canShowSelectorDocumentation'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!
!AutoCompleter methodsFor: 'testing' stamp: 'HAW 2/21/2019 16:00:50'!
      canShowSelectorDocumentation

	self subclassResponsibility! !
!ClassNameCompleter methodsFor: 'testing' stamp: 'HAW 2/21/2019 16:01:01'!
                       canShowSelectorDocumentation

	^false! !
!ClassNameCompleter methodsFor: 'testing' stamp: 'HAW 2/21/2019 15:54:56'!
            opensWithTab

	^true! !
!ClassNameCompleter methodsFor: 'entries' stamp: 'HAW 2/21/2019 15:53:24'!
                             computeEntries

	prefix _ model actualContents string.
	entries _ (Smalltalk classNames select: [ :aClassName | aClassName beginsWith: prefix ]) sort.
	! !
!SmalltalkCompleter methodsFor: 'testing' stamp: 'HAW 2/21/2019 16:06:32'!
                         canShowSelectorDocumentation

	^canShowSelectorDocumentation ! !
!ClassNameRequestMorph methodsFor: 'user interface support' stamp: 'HAW 2/21/2019 15:53:49' prior: 16807427!
                  autoCompleterClassFor: textGetter
	
	^ClassNameCompleter ! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'HAW 2/21/2019 16:10:52' prior: 50434427!
            handleKeystrokeBefore: kbEvent
	
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."
	
	| shouldOpenMorph |
	  
	shouldOpenMorph _ self shouldOpenMorph.
	
	"Stuff to do if the menu is not open"
	menuMorph ifNil: [ ^ self openCompletionMenuFor: kbEvent if: shouldOpenMorph ].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.
	
	kbEvent isEsc ifTrue: [ self closeMenu. ^ true].
	kbEvent isBackspace ifTrue: [ shouldOpenMorph ifFalse: [ self closeMenu ]. ^ false].
	kbEvent isHome ifTrue: [ menuMorph goHome. ^ true ].
	kbEvent isEnd ifTrue: [ menuMorph goToEnd. ^ true].
	kbEvent isQuesitonMark ifTrue: [ menuMorph help. ^true].
	kbEvent isArrowUp ifTrue: [ menuMorph goUp. ^ true].
	kbEvent isArrowDown ifTrue: [ menuMorph goDown. ^ true].
	kbEvent isPageUp ifTrue: [ menuMorph goPageUp. ^ true].
	kbEvent isPageDown ifTrue: [ menuMorph goPageDown. ^ true].
	
	self canShowSelectorDocumentation 
		ifTrue: [ 
			kbEvent isArrowRight ifTrue: [ menuMorph showSelectorDocumentation. ^ true ].
			kbEvent isArrowLeft ifTrue: [ menuMorph hideSelectorDocumentation. ^ true ]]
		ifFalse: [
			"If it is showing identifiers I eat the right arrow key because the user is used to it when
			showing selectors,  so to avoid an unexpected behavior I do nothing with it -Hernan"
			kbEvent isArrowRight ifTrue: [ ^ true ]].
					
	(self shouldInsertSelected: kbEvent) ifTrue: [ self insertSelected ifTrue: [^ true]].
	(self shouldCloseMenu: kbEvent) ifTrue: [ self closeMenu ]. 
	 
	^false! !
!AutoCompleter methodsFor: 'testing' stamp: 'HAW 2/21/2019 15:55:35' prior: 16781305!
                 opensWithTab
	
	"Returns wheter should open the auto completer when pressing Tab or not"
	
	^false! !
!SmalltalkCompleter methodsFor: 'testing' stamp: 'HAW 2/21/2019 15:55:07' prior: 16909360!
                               opensWithTab

	^true! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/21/2019 16:05:59' prior: 50434535!
                           computeMessageEntriesFor: allSource at: range in: contextClass and: specificModel
	
	| id rangeType |

	canShowSelectorDocumentation _ true.
	id _ allSource copyFrom: range start to: range end.
	rangeType _ range rangeType.

	rangeType == #globalVar  			ifTrue: [ ^self computeMessageEntriesForClass: (Smalltalk at: id asSymbol) class ].
	rangeType == #self  					ifTrue: [ ^self computeMessageEntriesForClass: contextClass ].
	rangeType == #super  				ifTrue: [ ^self computeMessageEntriesForClass: contextClass superclass ].
	rangeType == #true  					ifTrue: [ ^self computeMessageEntriesForClass: True ].
	rangeType == #false  				ifTrue: [ ^self computeMessageEntriesForClass: False ].
	rangeType == #nil  					ifTrue: [ ^self computeMessageEntriesForClass: UndefinedObject ].
	rangeType == #character  			ifTrue: [ ^self computeMessageEntriesForClass: id first class ].
	rangeType == #number  				ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #string  				ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #symbol  				ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #stringSymbol  		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #instVar  				ifTrue: [ ^specificModel computeMessageEntriesIn: self ofInstVarNamed: id ].
	rangeType == #methodArg  			ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #tempVar  				ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #blockArg  			ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockArgNamed: id ].
	rangeType == #blockTempVar  		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockTempVarNamed: id ].
	rangeType == #workspaceVar  		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (specificModel classOfWorkspaceVarNamed: id) ].
	rangeType == #thisContext  		ifTrue: [ ^self computeMessageEntriesForClass: (specificModel classOfThisContext) ]. 
	rangeType == #classVar  			ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #poolConstant  		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #blockEnd  			ifTrue: [ ^self computeMessageEntriesForClass: BlockClosure ].
	rangeType == #arrayEnd  			ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #rightBrace  			ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #unary  				ifTrue: [ ^self computeEntriesOfUnaryMessageReturnNamed: id at: range ].
	rangeType == #rightParenthesis  	ifTrue: [ ^self computeMessageEntriesOfEnclosedExpressionReturnAt: range ].
	rangeType == #cascadeSeparator  	ifTrue: [ ^self computeMessageEntriesOfCascadeReceiverAt: range ]. 

	self computeMessageEntriesForUnknowClass 
	
	! !
!SmalltalkCompleter methodsFor: 'identifier entries - private' stamp: 'HAW 2/21/2019 16:03:28' prior: 50435787!
                 computeIdentifierEntries
	"Use an aux Set to avoid duplicates, but keep the order given."

	| entriesSet lastTitle |
	entriesSet _ Set new.
	lastTitle _ nil.
	canShowSelectorDocumentation _ false.
	
	entries _ Array streamContents: [ :strm |
		parser namesBeginningWith: prefix do: [ :identifier :kindOfIdentifierTitle |
			(entriesSet includes: identifier) ifFalse: [
				kindOfIdentifierTitle = lastTitle ifFalse: [
					strm nextPut: kindOfIdentifierTitle.
					lastTitle _ kindOfIdentifierTitle ].
				entriesSet  add: identifier.
				strm nextPut: identifier ]]].
	entriesSet size = 1 ifTrue: [
		entries _ Array with: entriesSet anyOne ]! !
!SmalltalkCompleter methodsFor: 'message entries for unknown class - private' stamp: 'HAW 2/21/2019 16:06:15' prior: 50433961!
                          computeMessageEntriesForUnknowClass

	| selectorsToShow |
	
	selectorsClasses _ #().
	possibleInvalidSelectors _ IdentitySet new.
	canShowSelectorDocumentation _ true.
	selectorsToShow _ OrderedCollection new.
	
	self class protected: [
		Selectors forPrefix: prefix keysAndValuesDo: [ :selector :lastUsedTime |
				selectorsToShow := self add: selector and: lastUsedTime to: selectorsToShow.
				(Object canUnderstand: selector) ifFalse: [ possibleInvalidSelectors add: selector ]]].
				
	selectorsToShow size < EntriesLimit ifTrue: [ selectorsToShow _  self sortByLastUsedTime: selectorsToShow ].
	
	" To see the timestamps in the menu (need to tweak #insertCompletion: to activate. Right now, just for debugging)
	entries _ selectorsToShow collect: [ :ary | ary first, '(', ((DateAndTime fromString: '01/01/1996 00:00') + ary second minutes) printString,')' ]
	"
	entries _ selectorsToShow collect: [ :selectorAndTime | selectorAndTime first ]
	
! !

AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser selectorsClasses possibleInvalidSelectors canShowSelectorDocumentation'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #SmalltalkCompleter category: #'Tools-Autocompletion'!
AutoCompleter subclass: #SmalltalkCompleter
	instanceVariableNames: 'parser selectorsClasses possibleInvalidSelectors canShowSelectorDocumentation'
	classVariableNames: 'AccessLock EntriesLimit Selectors'
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3626-ShowClassesOnlyInTheClassNameRequestMorph-HernanWilkinson-2019Feb21-15h10m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3622] on 21 February 2019 at 9:48:42 pm'!

BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp itemsPerPage '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #AutoCompleterMorph category: #'Tools-Autocompletion'!
BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp itemsPerPage'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/21/2019 21:38:59'!
                 calculateItemsPerPage

	| itemsThatCanFit |

	itemsThatCanFit _ (DisplayScreen actualScreenSize y - originalPosition y - 2) // self itemHeight.
	itemsPerPage _ (itemsThatCanFit min: self maxItemsPerPage) min: completer entryCount.

! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/21/2019 21:31:17'!
         maxItemsPerPage

	^13! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 21:40:47' prior: 50368540!
            goDown

	"Wrap around"
	self selected = completer entryCount ifTrue: [ ^ self goHome ].

	self selected: self selected + 1.
	(self selected > self lastVisible and: [self selected <= completer entryCount]) ifTrue: [firstVisible := firstVisible + 1].

	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 21:40:58' prior: 50366875!
                     goHome

	firstVisible := 1.
	self selected: firstVisible.

	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 21:42:25' prior: 50366880!
                    goPageDown

	(self gotoPage: self currentPage + 1) ifFalse: [ self goToEnd ].

	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 21:42:30' prior: 50366886!
goPageUp

	self gotoPage: self currentPage - 1.

	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 21:42:37' prior: 50366891!
                              goToEnd

	self selected: completer entryCount.
	firstVisible := selected - itemsPerPage + 1 max: 1.

	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 20:46:55' prior: 50368552!
          goUp

	(self selected = 0 and: [self firstVisible = 1]) ifTrue: [^ self].
	"Wrap around"
	self selected = 1 ifTrue: [ ^self goToEnd ].

	self selected: self selected - 1.
	self selected < self firstVisible ifTrue: [firstVisible := firstVisible - 1].

	self redrawNeeded! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 21:33:37' prior: 16781400!
                    help

	TextModel new contents: AutoCompleter helpText; openLabel: 'uCompletion Keyboard Help'! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'HAW 2/21/2019 21:41:36' prior: 50436122!
    resetMenu

	| width newExtent |

	self hideSelectorDocumentation.
	self goHome.

	self calculateItemsPerPage.
	width _ self calculateWidth.
	newExtent _ width + 4 @ (itemsPerPage * self itemHeight + 2).

	self morphPosition: originalPosition extent: newExtent.
	"redraw is needed even if position and extent haven't changed"
	self redrawNeeded ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/11/2019 20:13:14' prior: 50433507!
         adjust: aLocation ifOutOfScreenWith: anExtent xOffset: xOffset yOffset: yOffset

	| adjustedLocationX adjustedLocationY |

	adjustedLocationX := (self isXOutOfScreen: aLocation with: anExtent)
		ifTrue: [ aLocation x - anExtent x - xOffset ]
		ifFalse: [ aLocation x ].

	adjustedLocationX < 0 ifTrue: [ adjustedLocationX := aLocation x ].

	adjustedLocationY := (self isYOutOfScreen: aLocation with: anExtent)
		ifTrue: [ aLocation y - anExtent y - yOffset ]
		ifFalse: [ aLocation y ].

	^adjustedLocationX @ adjustedLocationY
	! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/21/2019 21:25:56' prior: 50433527!
               calculateWidth

	| width font |

	width _ 120.
	font _ self class listFont.

	1
		to: completer entryCount
		do: [ :index | width _ width max: (font widthOfString: (completer entries at: index) asString)].

	completer entryCount > itemsPerPage ifTrue: [ width _ width + ScrollBar scrollbarThickness ].

	^ width ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/10/2019 23:51:54' prior: 50433579!
         drawItemsOn: aCanvas width: width

	| itemTop |

	itemTop _ 1.
	self firstVisible
		to: self lastVisible
		do: [ :index |
			self drawItemOf: index on: aCanvas width: width top: itemTop.
			itemTop _ itemTop + self itemHeight ].! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'HAW 2/21/2019 21:26:22' prior: 50433607!
                             drawScrollBarOn: aCanvas

	| scrollbarThickness width |

	width _ extent x-2.
	completer entryCount > itemsPerPage  ifTrue: [
		scrollbarThickness _ ScrollBar scrollbarThickness.
		width _ width - scrollbarThickness.

		self drawScrollBarRectangleOn: aCanvas thickness: scrollbarThickness.
		self drawUpArrowOn: aCanvas thickness: scrollbarThickness.
		self drawDownArrowOn: aCanvas thickness: scrollbarThickness.
		self drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness ].

	^width
! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'HAW 2/21/2019 21:45:16' prior: 50434330!
               mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition

	(self morphContainsPoint: localEventPosition)
		ifTrue: [
			((self upButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goUp ].
			((self downButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ ^self stillActive; goDown ].
			self selected: (localEventPosition y // self itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!AutoCompleterMorph methodsFor: 'paging' stamp: 'HAW 2/21/2019 21:26:13' prior: 16781592!
    currentPage

	^(self selected - 1 // itemsPerPage ) + 1.! !
!AutoCompleterMorph methodsFor: 'paging' stamp: 'HAW 2/21/2019 21:45:37' prior: 50366929!
          gotoPage: anInteger

	| item |

	item := ((anInteger - 1) * itemsPerPage) + 1.
	item >= completer entryCount ifTrue: [^false].

	item < 1 ifTrue: [item := 1].
	firstVisible := item.
	self selected: firstVisible.

	^ true! !
!AutoCompleterMorph methodsFor: 'paging' stamp: 'HAW 2/21/2019 21:28:22' prior: 16781607!
      pageCount

	| count |

	completer entryCount = itemsPerPage ifTrue: [^ 1].

	count _ completer entryCount // itemsPerPage.
	(completer entryCount \\ itemsPerPage) > 0 ifTrue: [ count _ count + 1].

	^count! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'HAW 2/21/2019 21:45:53' prior: 16781639!
                    firstVisible

	^firstVisible min: completer entryCount! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'HAW 2/21/2019 21:25:00' prior: 16781644!
           lastVisible

	^ (self firstVisible + itemsPerPage - 1)  min: completer entryCount! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/21/2019 21:28:49' prior: 50433693!
 selectorDefaultDocumentationLocation

	| relativeSelected |

	relativeSelected := (self selected - self firstVisible) min: itemsPerPage - 1 max: 0.

	^location externalizePosition: extent x@(relativeSelected * self itemHeight + 1).

	! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'HAW 2/11/2019 16:18:05' prior: 50433711!
        selectorDocumentationExtent

	^`600@250`! !

AutoCompleterMorph class removeSelector: #itemsPerPage!

AutoCompleterMorph class removeSelector: #itemsPerPage!

AutoCompleterMorph class removeSelector: #maxItemsPerPage!

AutoCompleterMorph removeSelector: #visibleItemsCount!

AutoCompleterMorph removeSelector: #visibleItemsCount!

BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp itemsPerPage'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

!classDefinition: #AutoCompleterMorph category: #'Tools-Autocompletion'!
BorderedRectMorph subclass: #AutoCompleterMorph
	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity selectorDocumentation originalPosition showUp itemsPerPage'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Autocompletion'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3627-AutoCompleterMorphItemsPerPage-HernanWilkinson-2019Feb21-17h09m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3622] on 21 February 2019 at 10:08:10 pm'!
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/21/2019 22:00:30'!
                 ifEmptyEntriesShowAllPrefixedSelectors

	entries isEmpty ifTrue: [ self computeMessageEntriesForUnknowClass ] ! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 2/21/2019 21:59:30' prior: 50433930!
 computeMessageEntriesForClass: aClass

	selectorsClasses := Array with: aClass.
	
	entries := (AutoCompleterSelectorsCollector for: prefix) 
		addSelectorsOf: aClass;
		entriesToShow.
		
	self ifEmptyEntriesShowAllPrefixedSelectors! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3628-ShowsAllPrefixedSelectors-HernanWilkinson-2019Feb21-21h48m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3620] on 21 February 2019 at 12:30:15 am'!
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/21/2019 00:29:45' prior: 50401397!
                           messageCatListKey: aChar from: view

	aChar == $o ifTrue: [^ model fileOutMessageCategories ].
	aChar == $t ifTrue: [^ model runMessageCategoryTests ].
	aChar == $x ifTrue: [^ model removeMessageCategory ].
	aChar == $R ifTrue: [ ^model renameCategory ].
	aChar == $n ifTrue: [^model addCategory ].
	aChar == $e ifTrue: [^model removeEmptyCategories ].
	aChar == $c ifTrue: [^model categorizeAllUncategorizedMethods ].! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'HAW 2/21/2019 00:29:34' prior: 50411439!
                       messageCategoryMenuOptions

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutMessageCategories.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editMessageCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'alphabetize'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeMessageCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove empty categories (e)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeEmptyCategories.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'categorize all uncategorized (c)'.
				#object 			-> 		#model.
				#selector 		-> 		#categorizeAllUncategorizedMethods.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		50.
				#label 			-> 		'new category... (n)'.
				#object 			-> 		#model.
				#selector 		-> 		#addCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeMessageCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runMessageCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3629-AdditionalShortcutsInMsgCatList-HernanWilkinson-2019Feb20-21h50m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3622] on 21 February 2019 at 8:18:20 am'!
!BrowserWindow class methodsFor: 'instance creation' stamp: 'HAW 2/21/2019 08:14:05'!
                  openNoSysCat: model label: aString

	self new
		model: model;
		buildNoSysCatMorphicWindow;
		setLabel: aString;
		openInWorld! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'HAW 2/21/2019 08:16:48' prior: 16793163!
   buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: self buildMorphicClassColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: Preferences standardCodeFont height + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

CodeWindow class removeSelector: #openNoSysCat:label:!

CodeWindow class removeSelector: #openNoSysCat:label:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3630-MessageDnDInHierarchyBrowser-HernanWilkinson-2019Feb21-08h00m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3610] on 23 February 2019 at 8:07:26 pm'!
!Object methodsFor: 'debugging-haltOnce' stamp: 'GC 2/23/2019 20:05:35'!
                         clearHaltOnce
	"Turn on the halt once flag."
	
	Smalltalk at: #HaltOnce put: false! !
!Object methodsFor: 'debugging-haltOnce' stamp: 'GC 2/23/2019 20:05:43'!
 haltOnce
	"Halt unless we have already done it once."
	
	self haltOnceEnabled ifTrue: [
		self clearHaltOnce.
		^ self halt
	]! !
!Object methodsFor: 'debugging-haltOnce' stamp: 'GC 2/23/2019 20:05:48'!
                     haltOnceEnabled

	^ Smalltalk
		at: #HaltOnce
		ifAbsent: [false]! !
!Object methodsFor: 'debugging-haltOnce' stamp: 'GC 2/23/2019 20:05:52'!
                  setHaltOnce
	"Turn on the halt once flag."
	
	Smalltalk at: #HaltOnce put: true! !
!Object methodsFor: 'debugging-haltOnce' stamp: 'GC 2/23/2019 20:00:03'!
    toggleHaltOnce
	self haltOnceEnabled
		ifTrue: [self clearHaltOnce]
		ifFalse: [self setHaltOnce]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3631-haltOnce-GastonCaruso-2019Feb23-19h57m-GC.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3631] on 25 February 2019 at 2:34:25 pm'!
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 2/25/2019 14:33:42' prior: 50434656!
       initialize
	"
	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...
	[ SmalltalkCompleter initialize ]timeToRun
	Selectors inspect
	"
	| maxSortValue allImplemented |
	
	EntriesLimit _ 100.
	
	SystemChangeNotifier uniqueInstance
		removeActionsWithReceiver: self.	 "avoid double registration"

	SystemChangeNotifier uniqueInstance
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #methodAdded send: #methodAdded:selector:inClass:requestor: to: self;
		when: #methodAddedInProtocol send: #methodAdded:selector:inProtocol:class:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self.
	
	self protected: [
		allImplemented _ Smalltalk allImplementedMessages.
		Selectors _ Trie new.
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				Selectors at: sel ifAbsentPut: [ 0 ].
				method messages do: [ :sentMsg |
					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				self addSelector: sel method: method allImplemented: allImplemented]].
		""
	
		"The following might not be found in #messages. Give them maximum priority."
		maxSortValue _ SmallInteger maxVal.
		"From MessageNode>>#initialize"
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |
				Selectors at: sel put: maxSortValue ].
	
		maxSortValue _ SmallInteger maxVal-1.
		"From SystemDictionary >>#recreateSpecialObjectsArray"
		(1 to: Smalltalk specialSelectorSize) do:  [ :i | | sym |
			sym _ Smalltalk specialSelectorAt: i.
			(Selectors includesKey: sym)
				ifTrue: [ Selectors at: sym put: maxSortValue ]]]! !

SmalltalkCompleter initialize!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3632-SmalltalkCompleterFix-JuanVuletich-2019Feb25-14h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3632] on 25 February 2019 at 3:37:56 pm'!
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 2/25/2019 15:21:30' prior: 50426382!
       dragEvent: aMouseEvent localPosition: localEventPosition

	| row dragged listItem |
	self listMorph highlightedRow: nil.
	row _ self rowAtLocation: localEventPosition ifNone: [ ^self ].
	listItem _ self getListItem: row.

	dragged _ DraggingGuideMorph new.
	dragged addMorph: (StringMorph contents: listItem).
	dragged setProperty: #dragSource toValue: self.
	dragged setProperty: #dropSelectorArgument toValue: listItem.
	
	aMouseEvent hand attachMorphBeside: dragged.! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3633-PluggableListMorphFix-JuanVuletich-2019Feb25-15h37m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3633] on 27 February 2019 at 1:27:51 pm'!
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:20:35'!
                          bigFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences bigFonts
	"

	self defaultFont17! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:03:25'!
                    defaultFont05
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont05
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 7)
			(setListFontTo: 5)
			(setMenuFontTo: 5)
			(setWindowTitleFontTo: 7)
			(setCodeFontTo: 5)
			(setButtonFontTo: 5)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:06:29'!
          defaultFont06
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont06
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 7)
			(setListFontTo: 6)
			(setMenuFontTo: 6)
			(setWindowTitleFontTo: 8)
			(setCodeFontTo: 6)
			(setButtonFontTo: 6)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:04:07'!
          defaultFont07
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont07
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 7)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:02:21'!
          defaultFont08
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont08
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 8)
			(setListFontTo: 8)
			(setMenuFontTo: 8)
			(setWindowTitleFontTo: 11)
			(setCodeFontTo: 8)
			(setButtonFontTo: 8)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:02:38'!
                   defaultFont09
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont09
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 9)
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:05:56'!
                  defaultFont10
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont10
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 10)
			(setListFontTo: 10)
			(setMenuFontTo: 11)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 10)
			(setButtonFontTo: 10)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:07:19'!
     defaultFont12
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont12
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 12)
			(setListFontTo: 12)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 12)
			(setButtonFontTo: 12)).
	Preferences enable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:20:12'!
      hugeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences hugeFonts
	"

	self defaultFont46! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:21:58'!
                  smallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences smallFonts
	"
	
	self defaultFont09! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:20:22'!
         veryBigFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences veryBigFonts
	"

	self defaultFont28! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:20:44' prior: 50435446!
                            standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	self defaultFont12! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:03:47' prior: 50397750!
                          tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	self defaultFont05! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/27/2019 13:04:24' prior: 50435455!
                            verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences verySmallFonts
	"
	
	self defaultFont07! !
!StrikeFont class methodsFor: 'instance creation' stamp: 'jmv 2/27/2019 13:16:39' prior: 50436041!
                       install: aString
"
StrikeFont install: 'DejaVu'.
"
"
StrikeFont install: 'DejaVu Sans Mono'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans Mono'.
Preferences bigFonts.
Character initialize.
"
"
StrikeFont install: 'DejaVu Sans'.
StrikeFont buildLargerPunctuation: 'DejaVu Sans'.
Preferences setDefaultFontFamilyTo: 'DejaVu Sans'.
Preferences standardFonts.
Character initialize.
"
"
StrikeFont install: 'Inconsolata'
StrikeFont install: '#PilGi'
StrikeFont install: 'Optima'
StrikeFont install: 'Herculanum'
StrikeFont install: 'Papyrus'
StrikeFont install: 'Handwriting - Dakota'
StrikeFont install: 'Times New Roman'
StrikeFont install: 'Apple Chancery'
StrikeFont install: 'Cochin'
StrikeFont install: 'Cracked'
StrikeFont install: 'Zapfino'
StrikeFont install: 'Brush Script MT'
StrikeFont install: 'Chalkboard'
"
	| fontDict |
	fontDict _ nil.
	1 to: 200 do: [ :s |
		(self create: aString size: s bold: true italic: true boldItalic: false) ifNotNil: [ :font |
			font print.
			fontDict ifNil: [ fontDict _ AvailableFonts at: aString ifAbsentPut: Dictionary new ].
			fontDict
				at: s
				put: font ]]! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 5/6/2018 16:42:00' prior: 50436080!
          changeFontSizes

	(MenuMorph new defaultTarget: Preferences)
		addTitle: 'Choose a size';
		addStayUpIcons;
		add: 'Huge Fonts' action: #hugeFonts;
		add: 'Very big Fonts' action: #veryBigFonts;
		add: 'Big Fonts' action: #bigFonts;
		add: 'Standard Fonts' action: #standardFonts;
		add: 'Small Fonts' action: #smallFonts;
		add: 'Very small Fonts'action: #verySmallFonts;
		add: 'Tiny Fonts'action: #tinyFonts;
		popUpInWorld: self runningWorld! !

Preferences class removeSelector: #defaultFont8!

Preferences class removeSelector: #defaultFont8!

Preferences class removeSelector: #defaultFont9!

Preferences class removeSelector: #defaultFont9!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences standardFonts!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3634-BetterFontSizeOptions-JuanVuletich-2019Feb27-13h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3634] on 1 March 2019 at 1:52:22 pm'!
!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 3/1/2019 00:34:30' prior: 16855878!
                         fontPreferenceChanged

	super fontPreferenceChanged.
	hasUnacceptedEdits ifFalse: [
		model refetch ].
	self updateFromTextComposition.! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3635-CodePaneFontChangesOnFontSelection-JuanVuletich-2019Mar01-13h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3634] on 28 February 2019 at 8:31:40 pm'!

Smalltalk renameClassNamed: #ProgessiveTestRunner as: #ProgressiveTestRunner!
!Browser methodsFor: 'tdd' stamp: 'HAW 2/28/2019 20:30:14' prior: 50338014!
                         runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		(ProgressiveTestRunner for: (TestSuite forClass: selectedClass)) value ]! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/28/2019 20:30:14' prior: 50338023!
                              runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass _ Smalltalk classNamed: selectedClassName.
		suite _ TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgressiveTestRunner for: suite) value ]
	
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/28/2019 20:30:14' prior: 50338035!
                      runMethodTest
	
	| suite |
	
	suite _ TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgressiveTestRunner for: suite) value 
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/28/2019 20:30:14' prior: 50338042!
          runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite _ TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgressiveTestRunner for: suite) value ]
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/28/2019 20:30:14' prior: 50338454!
                      runTestSuite: aTestSuite

	(ProgressiveTestRunner for: aTestSuite) value
	
	! !
!TestResultWindow methodsFor: 'actions' stamp: 'HAW 2/28/2019 20:30:14' prior: 50343802!
                       runSuite

	| suite |
	 
	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(ProgressiveTestRunner for: suite) value.
	! !
!ProgressiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 2/28/2019 20:30:59' prior: 50343886!
  showDeffects
	
	 | defects |
			
	defects _ testResult defects.
	defects size = 1
		ifTrue: [ defects anyOne debug ] 
		ifFalse: [ self openTestResultWindow]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3636-ProgressiveTestRunnerRenamed-HernanWilkinson-2019Feb28-20h30m-HAW.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3636] on 1 March 2019 at 1:54:06 pm'!

MethodNode removeSelector: #rangesForInstanceVariable:ifAbsent:!

MethodNode removeSelector: #rangesForInstanceVariable:ifAbsent:!

MethodNode removeSelector: #rangesForTemporaryVariable:ifAbsent:!

MethodNode removeSelector: #rangesForTemporaryVariable:ifAbsent:!

Encoder removeSelector: #rangesForInstanceVariable:ifAbsent:!

Encoder removeSelector: #rangesForInstanceVariable:ifAbsent:!

Encoder removeSelector: #rangesForTemporaryVariable:ifAbsent:!

Encoder removeSelector: #rangesForTemporaryVariable:ifAbsent:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3637-RemovedUnnecesaryMethodsFromMethodNodeAndEncoder-HernanWilkinson-2019Mar01-12h31m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3637] on 7 March 2019 at 9:40:58 am'!

Error subclass: #RefactoringError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RefactoringError category: #'Tools-Refactoring'!
Error subclass: #RefactoringError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringError subclass: #CanNotRefactorDueToReferencesError
	instanceVariableNames: 'references referencee'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #CanNotRefactorDueToReferencesError category: #'Tools-Refactoring'!
RefactoringError subclass: #CanNotRefactorDueToReferencesError
	instanceVariableNames: 'references referencee'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Warning subclass: #RefactoringWarning
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RefactoringWarning category: #'Tools-Refactoring'!
Warning subclass: #RefactoringWarning
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ParseNodeVisitor subclass: #ExtractToTemporaryRewriter
	instanceVariableNames: 'refactoring finder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractToTemporaryRewriter category: #'Tools-Refactoring'!
ParseNodeVisitor subclass: #ExtractToTemporaryRewriter
	instanceVariableNames: 'refactoring finder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ParseNodeVisitor subclass: #ParseNodeToReplaceFinder
	instanceVariableNames: 'refactoring currentBlock nodesToReplace blockContainingFirstNodeToReplace firstNodeToReplaceIndex currentStatementIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ParseNodeToReplaceFinder category: #'Tools-Refactoring'!
ParseNodeVisitor subclass: #ParseNodeToReplaceFinder
	instanceVariableNames: 'refactoring currentBlock nodesToReplace blockContainingFirstNodeToReplace firstNodeToReplaceIndex currentStatementIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MessageSetWindow subclass: #ChangeSelectorWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorWizardStepWindow category: #'Tools-Refactoring'!
MessageSetWindow subclass: #ChangeSelectorWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorWizardStepWindow subclass: #ChangeSelectorImplementorsStepWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorImplementorsStepWindow category: #'Tools-Refactoring'!
ChangeSelectorWizardStepWindow subclass: #ChangeSelectorImplementorsStepWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorWizardStepWindow subclass: #ChangeSelectorSendersStepWindow
	instanceVariableNames: 'changedMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorSendersStepWindow category: #'Tools-Refactoring'!
ChangeSelectorWizardStepWindow subclass: #ChangeSelectorSendersStepWindow
	instanceVariableNames: 'changedMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #Refactoring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #Refactoring category: #'Tools-Refactoring'!
Object subclass: #Refactoring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #AddInstanceVariable
	instanceVariableNames: 'newVariable classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #AddInstanceVariable category: #'Tools-Refactoring'!
Refactoring subclass: #AddInstanceVariable
	instanceVariableNames: 'newVariable classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ChangeSelector
	instanceVariableNames: 'oldSelector newSelector implementors senders changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelector category: #'Tools-Refactoring'!
Refactoring subclass: #ChangeSelector
	instanceVariableNames: 'oldSelector newSelector implementors senders changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelector subclass: #AddParameter
	instanceVariableNames: 'newParameter newParameterValue implementorTrailingString senderTrailingString index isAddingLast'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #AddParameter category: #'Tools-Refactoring'!
ChangeSelector subclass: #AddParameter
	instanceVariableNames: 'newParameter newParameterValue implementorTrailingString senderTrailingString index isAddingLast'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelector subclass: #RemoveParameter
	instanceVariableNames: 'parameterToRemove parameterIndex senderReplacementString isLastParameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveParameter category: #'Tools-Refactoring'!
ChangeSelector subclass: #RemoveParameter
	instanceVariableNames: 'parameterToRemove parameterIndex senderReplacementString isLastParameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelector subclass: #RenameSelector
	instanceVariableNames: 'newSelectorKeywords'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameSelector category: #'Tools-Refactoring'!
ChangeSelector subclass: #RenameSelector
	instanceVariableNames: 'newSelectorKeywords'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ExtractToTemporary
	instanceVariableNames: 'newVariable parseNodeToExtract methodNodeToRefactor newTemporary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractToTemporary category: #'Tools-Refactoring'!
Refactoring subclass: #ExtractToTemporary
	instanceVariableNames: 'newVariable parseNodeToExtract methodNodeToRefactor newTemporary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #InsertSuperclass
	instanceVariableNames: 'classToRefactor superclassName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InsertSuperclass category: #'Tools-Refactoring'!
Refactoring subclass: #InsertSuperclass
	instanceVariableNames: 'classToRefactor superclassName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #PushUpMethod
	instanceVariableNames: 'method'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethod category: #'Tools-Refactoring'!
Refactoring subclass: #PushUpMethod
	instanceVariableNames: 'method'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #RemoveAllUnreferencedInstanceVariables
	instanceVariableNames: 'classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveAllUnreferencedInstanceVariables category: #'Tools-Refactoring'!
Refactoring subclass: #RemoveAllUnreferencedInstanceVariables
	instanceVariableNames: 'classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #RemoveInstanceVariable
	instanceVariableNames: 'variableToRemove classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveInstanceVariable category: #'Tools-Refactoring'!
Refactoring subclass: #RemoveInstanceVariable
	instanceVariableNames: 'variableToRemove classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #RenameClass
	instanceVariableNames: 'classToRename newClassName system undeclared classToRenameOriginalName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameClass category: #'Tools-Refactoring'!
Refactoring subclass: #RenameClass
	instanceVariableNames: 'classToRename newClassName system undeclared classToRenameOriginalName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable addInstanceVariable rewriter renamedReferences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameInstanceVariable category: #'Tools-Refactoring'!
Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable addInstanceVariable rewriter renamedReferences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #RenameTemporary
	instanceVariableNames: 'oldVariable newVariable methodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameTemporary category: #'Tools-Refactoring'!
Refactoring subclass: #RenameTemporary
	instanceVariableNames: 'oldVariable newVariable methodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #SafelyRemoveClass
	instanceVariableNames: 'classToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #SafelyRemoveClass category: #'Tools-Refactoring'!
Refactoring subclass: #SafelyRemoveClass
	instanceVariableNames: 'classToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #RefactoringApplier
	instanceVariableNames: 'requestExitBlock refactoring changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RefactoringApplier category: #'Tools-Refactoring'!
Object subclass: #RefactoringApplier
	instanceVariableNames: 'requestExitBlock refactoring changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #AddInstanceVariableApplier
	instanceVariableNames: 'classToRefactor oldInstanceVariable newInstanceVariable browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #AddInstanceVariableApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #AddInstanceVariableApplier
	instanceVariableNames: 'classToRefactor oldInstanceVariable newInstanceVariable browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #ChangeSelectorApplier
	instanceVariableNames: 'oldSelector scopeChoice implementors senders implementingClass wizardStepWindow shouldShowChanges browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #ChangeSelectorApplier
	instanceVariableNames: 'oldSelector scopeChoice implementors senders implementingClass wizardStepWindow shouldShowChanges browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorApplier subclass: #AddParameterApplier
	instanceVariableNames: 'newParameter newParameterValue newKeyword parameterIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #AddParameterApplier category: #'Tools-Refactoring'!
ChangeSelectorApplier subclass: #AddParameterApplier
	instanceVariableNames: 'newParameter newParameterValue newKeyword parameterIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorApplier subclass: #RemoveParameterApplier
	instanceVariableNames: 'newParameter newParameterValue newKeyword originalMethod parameterToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveParameterApplier category: #'Tools-Refactoring'!
ChangeSelectorApplier subclass: #RemoveParameterApplier
	instanceVariableNames: 'newParameter newParameterValue newKeyword originalMethod parameterToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorApplier subclass: #RenameSelectorApplier
	instanceVariableNames: 'newSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameSelectorApplier category: #'Tools-Refactoring'!
ChangeSelectorApplier subclass: #RenameSelectorApplier
	instanceVariableNames: 'newSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #InsertSuperclassApplier
	instanceVariableNames: 'browser newSuperclassName classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InsertSuperclassApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #InsertSuperclassApplier
	instanceVariableNames: 'browser newSuperclassName classToRefactor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #RemoveAllUnreferencedInstanceVariablesApplier
	instanceVariableNames: 'classToRefactor browser variableToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveAllUnreferencedInstanceVariablesApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #RemoveAllUnreferencedInstanceVariablesApplier
	instanceVariableNames: 'classToRefactor browser variableToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #RemoveInstanceVariableApplier
	instanceVariableNames: 'classToRefactor browser variableToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveInstanceVariableApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #RemoveInstanceVariableApplier
	instanceVariableNames: 'classToRefactor browser variableToRemove'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #RenameClassApplier
	instanceVariableNames: 'browser classToRename newClassName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameClassApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #RenameClassApplier
	instanceVariableNames: 'browser classToRename newClassName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #RenameInstanceVariableApplier
	instanceVariableNames: 'classToRefactor oldInstanceVariable newInstanceVariable browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameInstanceVariableApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #RenameInstanceVariableApplier
	instanceVariableNames: 'classToRefactor oldInstanceVariable newInstanceVariable browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #RenameTemporaryApplier
	instanceVariableNames: 'classToRefactor oldVariable newVariable smalltalkEditor methodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameTemporaryApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #RenameTemporaryApplier
	instanceVariableNames: 'classToRefactor oldVariable newVariable smalltalkEditor methodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #SafelyRemoveClassApplier
	instanceVariableNames: 'classToRemove browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #SafelyRemoveClassApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #SafelyRemoveClassApplier
	instanceVariableNames: 'classToRemove browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #RefactoringMenues
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RefactoringMenues category: #'Tools-Refactoring'!
Object subclass: #RefactoringMenues
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #RefactoringPrecondition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RefactoringPrecondition category: #'Tools-Refactoring'!
Object subclass: #RefactoringPrecondition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringPrecondition subclass: #NewClassPrecondition
	instanceVariableNames: 'newClassName system undeclared'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #NewClassPrecondition category: #'Tools-Refactoring'!
RefactoringPrecondition subclass: #NewClassPrecondition
	instanceVariableNames: 'newClassName system undeclared'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringPrecondition subclass: #NewInstanceVariablePrecondition
	instanceVariableNames: 'classToAddInstVar instVarName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #NewInstanceVariablePrecondition category: #'Tools-Refactoring'!
RefactoringPrecondition subclass: #NewInstanceVariablePrecondition
	instanceVariableNames: 'classToAddInstVar instVarName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!CanNotRefactorDueToReferencesError methodsFor: 'references' stamp: 'HAW 7/11/2018 16:56:20'!
        anyReference
	
	^references anyOne ! !
!CanNotRefactorDueToReferencesError methodsFor: 'references' stamp: 'HAW 7/11/2018 16:54:54'!
                           numberOfReferences
	
	^references size! !
!CanNotRefactorDueToReferencesError methodsFor: 'references' stamp: 'HAW 8/1/2018 17:26:49'!
                         references

	^references copy! !
!CanNotRefactorDueToReferencesError methodsFor: 'initialization' stamp: 'HAW 8/1/2018 17:32:33'!
                              initialize: aMessageText references: aCollectionOfReferences to: aReferencee

	self messageText: aMessageText.
	references := aCollectionOfReferences.
	referencee := aReferencee ! !
!CanNotRefactorDueToReferencesError methodsFor: 'referencee' stamp: 'HAW 8/1/2018 17:32:46'!
             referencee

	^referencee ! !
!CanNotRefactorDueToReferencesError class methodsFor: 'signaling' stamp: 'HAW 8/1/2018 17:32:15'!
 signal: aMessageText references: references to: aReferencee

	self new 
		initialize: aMessageText references: references to: aReferencee;
		signal! !
!ExtractToTemporaryRewriter methodsFor: 'initialization' stamp: 'HAW 10/18/2017 18:21:40'!
              initializeOf: anExtractToTemporary on: aParseNodeToReplaceFinder 
	
	refactoring := anExtractToTemporary.
	finder := aParseNodeToReplaceFinder ! !
!ExtractToTemporaryRewriter methodsFor: 'visiting' stamp: 'HAW 10/18/2017 18:26:27'!
                        visitBlockNode: aBlockNode

	| statements |
	
	statements := aBlockNode statements.
	statements withIndexDo: [ :statement :index |
		(finder shouldReplace: statement)
			ifTrue: [ statements at: index put: refactoring newTemporary ]
			ifFalse: [ statement accept: self]]! !
!ExtractToTemporaryRewriter methodsFor: 'visiting' stamp: 'HAW 10/19/2017 06:24:35'!
                        visitMessageNode: aMessageNode

	aMessageNode receiver accept: self.
	aMessageNode selector accept: self.
	aMessageNode argumentsInEvaluationOrder withIndexDo: [:argument :index | 
		(finder shouldReplace: argument)
			ifTrue: [ aMessageNode arguments at: index put: refactoring newTemporary ]
			ifFalse: [ argument accept: self]]! !
!ExtractToTemporaryRewriter methodsFor: 'visiting' stamp: 'HAW 10/19/2017 06:06:05'!
                            visitReturnNode: aReturnNode

	(finder shouldReplace: aReturnNode expr)
		ifTrue: [ aReturnNode expr: refactoring newTemporary ]
		ifFalse: [ super visitReturnNode: aReturnNode ]! !
!ExtractToTemporaryRewriter class methodsFor: 'instance creation' stamp: 'HAW 10/18/2017 18:21:16'!
      of: anExtractToTemporary on: aParseNodeToReplaceFinder 
	
	^self new initializeOf: anExtractToTemporary on: aParseNodeToReplaceFinder 
	! !
!ParseNodeToReplaceFinder methodsFor: 'as yet unclassified' stamp: 'HAW 10/19/2017 06:03:12'!
                      addNodeToReplace: aParseNode

	nodesToReplace isEmpty ifTrue: [ 
		blockContainingFirstNodeToReplace := currentBlock.
		firstNodeToReplaceIndex := currentStatementIndex ].
	
	nodesToReplace add: aParseNode.! !
!ParseNodeToReplaceFinder methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2017 18:30:44'!
                blockContainingFirstNodeToReplace
	
	^blockContainingFirstNodeToReplace! !
!ParseNodeToReplaceFinder methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2017 18:31:00'!
                       firstNodeToReplace
	
	^nodesToReplace first! !
!ParseNodeToReplaceFinder methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2017 18:39:56'!
                   firstNodeToReplaceIndex
	
	^firstNodeToReplaceIndex! !
!ParseNodeToReplaceFinder methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2017 18:12:47'!
           keepCurrentBlockIfFirstNodeToReplace
	
	nodesToReplace isEmpty ifTrue: [ blockContainingFirstNodeToReplace := currentBlock ].
! !
!ParseNodeToReplaceFinder methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2017 18:26:50'!
shouldReplace: aParseNode

	^nodesToReplace includes: aParseNode ! !
!ParseNodeToReplaceFinder methodsFor: 'initialization' stamp: 'HAW 10/18/2017 18:12:47'!
  initializeOf: anExtractToTemporary

	refactoring := anExtractToTemporary.
	nodesToReplace := OrderedCollection new.! !
!ParseNodeToReplaceFinder methodsFor: 'visiting' stamp: 'HAW 10/19/2017 06:02:34'!
                      visitBlockNode: aBlockNode

	| previousBlock |
	
	previousBlock := currentBlock.
	currentBlock := aBlockNode.
	
	aBlockNode statements withIndexDo: [:statement :index | 
		currentStatementIndex := index.
		statement accept: self].
	
	currentBlock := previousBlock ! !
!ParseNodeToReplaceFinder methodsFor: 'visiting' stamp: 'HAW 10/18/2017 18:12:47'!
 visitLiteralNode: aLiteralNode

	(refactoring shouldExtract: aLiteralNode) ifTrue: [ self addNodeToReplace: aLiteralNode ]! !
!ParseNodeToReplaceFinder methodsFor: 'visiting' stamp: 'HAW 10/19/2017 06:20:02'!
               visitMessageNode: aMessageNode

	super visitMessageNode: aMessageNode! !
!ParseNodeToReplaceFinder class methodsFor: 'instance creation' stamp: 'HAW 10/18/2017 18:12:47'!
                     of: anExtractToTemporary
	
	^self new initializeOf: anExtractToTemporary ! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 5/31/2017 17:26:05'!
                            add

	self subclassResponsibility ! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 5/31/2017 17:36:12'!
   addToList: aMethod

	model addMethodReference: aMethod methodReference ifIncluded: [ self inform: 'Method already in list' ]! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 10/9/2018 20:57:59'!
         do: aBlock withEnteredClassLabeled: aLabel
		
	| className |
	
	className := ClassNameRequestMorph request: aLabel onCancel: [ ^self ].
	^self withClassNamed: className do: aBlock! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 5/31/2017 18:17:19'!
                  inform: aClass doesNotImplement: aSelector

 	self inform: aClass name, ' does not implement #', aSelector ! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 1/7/2019 11:02:43'!
                           justRefactor
	
	applier doNotShowChanges.
	self refactor.! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 1/7/2019 11:16:36'!
             refactor
	
	applier wizardStepWindow: self. 	
	applier wizardEnded.
	! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 5/31/2017 17:07:19'!
remove
	
	model removeMessageFromBrowserKeepingLabel! !
!ChangeSelectorWizardStepWindow methodsFor: 'actions' stamp: 'HAW 10/10/2018 05:46:24'!
                withClassNamed: aName do: aBlock

	| trimmedNamed |
	
	trimmedNamed := aName withBlanksTrimmed.
	
	(Smalltalk classNamed: trimmedNamed asSymbol)
		ifNotNil: aBlock
		ifNil: [ self inform: 'Class ', trimmedNamed , ' does not exist' ].
! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'HAW 5/31/2017 17:22:39'!
                      addButton: button to: row color: buttonColor

	button color: buttonColor.
	row addMorph: button proportionalWidth: 10! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'HAW 5/31/2017 17:18:46'!
           addButtonsTo: row color: buttonColor
	
	self subclassResponsibility ! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'HAW 5/31/2017 17:26:55'!
                            buildLowerPanes

	| codeAndButtons  |
	
	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'HAW 5/31/2017 17:27:25'!
                  buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!ChangeSelectorWizardStepWindow methodsFor: 'compile methods' stamp: 'HAW 5/31/2017 17:08:14'!
                  compiledMethodsFrom: methodReferences

	^ methodReferences collect: [:aMethodReference | aMethodReference compiledMethod ]! !
!ChangeSelectorWizardStepWindow methodsFor: 'button creation' stamp: 'HAW 5/31/2017 17:21:11'!
   createAddButton
	
	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #add
		label: 'Add'.
! !
!ChangeSelectorWizardStepWindow methodsFor: 'button creation' stamp: 'HAW 5/31/2017 17:21:19'!
                   createCancelButton
	
	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #delete
		label: 'Cancel'.
! !
!ChangeSelectorWizardStepWindow methodsFor: 'button creation' stamp: 'HAW 10/10/2018 19:47:37'!
         createJustRefactorButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #justRefactor
		label: 'Just Refactor!!'! !
!ChangeSelectorWizardStepWindow methodsFor: 'button creation' stamp: 'HAW 10/10/2018 19:47:43'!
                       createRefactorButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #refactor
		label: 'Refactor'! !
!ChangeSelectorWizardStepWindow methodsFor: 'button creation' stamp: 'HAW 5/31/2017 17:16:37'!
       createRemoveButton
	
	^PluggableButtonMorph 
		model: self
		stateGetter: #isMessageSelected
		action: #remove
		label: 'Remove'.
! !
!ChangeSelectorWizardStepWindow methodsFor: 'initialization' stamp: 'HAW 1/7/2019 11:04:02'!
                             initializeFrom: aChangeSelectorApplier

	applier := aChangeSelectorApplier ! !
!ChangeSelectorWizardStepWindow methodsFor: 'testing' stamp: 'HAW 6/5/2017 17:40:16'!
                           isMessageSelected

	^model isNil ifTrue: [ false ] ifFalse: [ model selection notNil ]! !
!ChangeSelectorWizardStepWindow methodsFor: 'accessing' stamp: 'HAW 1/7/2019 11:02:43'!
              oldSelector
	
	^applier oldSelector ! !
!ChangeSelectorWizardStepWindow class methodsFor: 'instance creation' stamp: 'HAW 5/31/2017 16:59:25'!
                 methodReferencesOf: methods

	^methods asOrderedCollection collect: [:aCompiledMethod | aCompiledMethod methodReference ].
! !
!ChangeSelectorWizardStepWindow class methodsFor: 'instance creation' stamp: 'HAW 1/7/2019 11:03:50'!
                           openFrom: aChangeSelectorApplier methods: methods label: aLabel

	| window |
	
	window := self openMessageList: (self methodReferencesOf: methods) label: aLabel autoSelect: aChangeSelectorApplier oldSelector.
	window initializeFrom: aChangeSelectorApplier.
	
	^window 

! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'actions' stamp: 'HAW 6/5/2017 17:33:16'!
                  add
		
	self 
		do: [ :classOfImplementorToAdd | self addImplementorIn: classOfImplementorToAdd ]
		withEnteredClassLabeled:  'Class that implements ', self oldSelector ! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'actions' stamp: 'HAW 6/5/2017 17:33:26'!
                       addImplementorIn: classOfImplementorToAdd 

	| implementorToAdd |
	
	implementorToAdd := classOfImplementorToAdd 
		compiledMethodAt: self oldSelector 
		ifAbsent: [ ^self inform: classOfImplementorToAdd doesNotImplement: self oldSelector ].
		
	self addToList: implementorToAdd! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'actions' stamp: 'HAW 1/7/2019 11:02:43'!
          changeImplementors
	
	applier implementors: (self compiledMethodsFrom: model messageList).
	! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'actions' stamp: 'HAW 10/10/2018 18:07:57'!
  refactor

	self changeImplementors.
	super refactor ! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'actions' stamp: 'HAW 1/7/2019 11:17:47'!
            seeSenders

	self changeImplementors.
	self delete.	
	
	ChangeSelectorSendersStepWindow openFrom: applier ! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'GUI building' stamp: 'HAW 10/10/2018 19:55:34'!
               addButtonsTo: row color: buttonColor

	self addButton: self createRemoveButton to: row color: buttonColor.
	self addButton: self createAddButton to: row color: buttonColor.
	self addButton: self createSeeSendersButton to: row color: buttonColor.
	self addButton: self createRefactorButton to: row color: buttonColor.
	self addButton: self createJustRefactorButton to: row color: buttonColor.
	self addButton: self createCancelButton to: row color: buttonColor.
! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'button creation' stamp: 'HAW 10/10/2018 19:55:52'!
         createSeeSendersButton
	
	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #seeSenders
		label: 'See Senders'.

! !
!ChangeSelectorImplementorsStepWindow class methodsFor: 'instance creation' stamp: 'HAW 8/18/2018 17:26:33'!
              openFrom: aChangeSelectorRequest

	^self 
		openFrom: aChangeSelectorRequest 
		methods: aChangeSelectorRequest implementors 
		label: 'Implementors of #', aChangeSelectorRequest oldSelector, ' to Refactor'  
! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'HAW 6/5/2017 17:36:00'!
                    add
	
	self 
		do: [ :classOfSenderToAdd | self askAndAddSenderOf: classOfSenderToAdd ]
		withEnteredClassLabeled: 'Class that sends #', self oldSelector
		! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'HAW 11/8/2018 15:25:57'!
        askAndAddSenderOf: classOfSenderToAdd 
		
	| senderSelector senderToAdd |
	
	senderSelector := FillInTheBlankMorph request: 'Selector of sender of #', self oldSelector onCancel: [^self ].
	senderToAdd := classOfSenderToAdd 
		compiledMethodAt: senderSelector asSymbol
		ifAbsent: [ ^self inform: classOfSenderToAdd doesNotImplement: senderSelector asSymbol].
		
	(senderToAdd sendsOrRefersTo: self oldSelector) ifFalse: [ ^self inform: senderToAdd classAndSelector, ' does not refer to #', self oldSelector ].
	
	self addToList: senderToAdd ! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'HAW 1/7/2019 11:02:43'!
        changeRequestSenders
	
	applier senders: (self compiledMethodsFrom: model messageList).
	! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'HAW 10/10/2018 18:09:18'!
          refactor
	
	self changeRequestSenders.
	super refactor ! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'HAW 1/7/2019 11:17:34'!
              seeImplementors
	
	self changeRequestSenders.
	self delete.
	
	ChangeSelectorImplementorsStepWindow openFrom: applier! !
!ChangeSelectorSendersStepWindow methodsFor: 'GUI building' stamp: 'HAW 10/10/2018 19:56:45'!
         addButtonsTo: row color: buttonColor
	
	self addButton: self createRemoveButton to: row color: buttonColor.
	self addButton: self createAddButton to: row color: buttonColor.
	self addButton: self createSeeImplementorsButton to: row color: buttonColor.
	self addButton: self createRefactorButton to: row color: buttonColor.
	self addButton: self createJustRefactorButton to: row color: buttonColor.
	self addButton: self createCancelButton to: row color: buttonColor.
! !
!ChangeSelectorSendersStepWindow methodsFor: 'button creation' stamp: 'HAW 10/10/2018 19:56:51'!
        createSeeImplementorsButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #seeImplementors
		label: 'See Implementors'.
! !
!ChangeSelectorSendersStepWindow class methodsFor: 'instance creation' stamp: 'HAW 8/18/2018 17:26:18'!
      openFrom: aChangeSelectorRequest

	^self 
		openFrom: aChangeSelectorRequest 
		methods: aChangeSelectorRequest senders 
		label: 'Senders of #', aChangeSelectorRequest oldSelector, ' to Refactor' ! !
!Refactoring methodsFor: 'applying' stamp: 'HAW 5/24/2017 21:08:11'!
                  apply

	self subclassResponsibility ! !
!Refactoring class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 16:34:16'!
           canNotRefactorDueToReferencesError: aMessageText references: references to: referencee 
	
	^self canNotRefactorDueToReferencesErrorClass
		signal: aMessageText 
		references: references 
		to: referencee ! !
!Refactoring class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 16:32:42'!
   canNotRefactorDueToReferencesErrorClass
	
	^CanNotRefactorDueToReferencesError! !
!Refactoring class methodsFor: 'exceptions' stamp: 'HAW 6/3/2017 11:58:07'!
  refactoringError: aMessage

	self refactoringErrorClass signal: aMessage.! !
!Refactoring class methodsFor: 'exceptions' stamp: 'HAW 6/3/2017 11:58:21'!
       refactoringErrorClass

	^ RefactoringError.! !
!Refactoring class methodsFor: 'warnings' stamp: 'HAW 6/11/2017 18:49:41'!
      refactoringWarning: aMessageText

	^ self refactoringWarningClass signal: aMessageText.! !
!Refactoring class methodsFor: 'warnings' stamp: 'HAW 6/3/2017 12:05:48'!
                           refactoringWarningClass

	^ RefactoringWarning.! !
!AddInstanceVariable methodsFor: 'applying' stamp: 'HAW 6/11/2017 18:27:26'!
apply
	
	classToRefactor addInstVarName: newVariable.
	! !
!AddInstanceVariable methodsFor: 'accessing' stamp: 'HAW 6/11/2017 19:09:54'!
                    classToRefactor

	^classToRefactor ! !
!AddInstanceVariable methodsFor: 'accessing' stamp: 'HAW 6/6/2017 10:10:40'!
          newVariable
	
	^newVariable ! !
!AddInstanceVariable methodsFor: 'initialization' stamp: 'HAW 6/6/2017 10:10:26'!
            initializeNamed: aNewVariable to: aClassToRefactor 
	
	newVariable := aNewVariable.
	classToRefactor := aClassToRefactor ! !
!AddInstanceVariable class methodsFor: 'instance creation' stamp: 'HAW 3/4/2019 11:43:12'!
     named: aVariable to: aClassToRefactor

	| trimmedVariable |
	
	trimmedVariable := aVariable withBlanksTrimmed.
	NewInstanceVariablePrecondition valueOf: trimmedVariable for: aClassToRefactor.	
	^self new initializeNamed: trimmedVariable to: aClassToRefactor 
	! !
!ChangeSelector methodsFor: 'applying' stamp: 'HAW 11/29/2018 15:19:19'!
               apply
	
	self 
		createNewImplementors;
		renameSenders;
		removeOldImplementors.
		
	^changes
! !
!ChangeSelector methodsFor: 'remove old implementors - private' stamp: 'HAW 8/18/2018 12:02:34'!
                            removeOldImplementor: anImplementor 

	anImplementor methodClass removeSelector: anImplementor selector.
	changes add: anImplementor methodReference! !
!ChangeSelector methodsFor: 'remove old implementors - private' stamp: 'HAW 8/18/2018 12:01:49'!
       removeOldImplementors
	
	implementors do: [:anImplementor | self removeOldImplementor: anImplementor ]! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'HAW 11/8/2018 15:24:06'!
                     addToSendersIfOldSelectorIsSentIn: newImplementor
	
	(newImplementor sendsOrRefersTo: oldSelector) ifTrue: [ senders add: newImplementor ]. 
	! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'HAW 3/4/2019 15:24:22'!
              compileNewImplementorOf: anImplementor
		
	| implementorClassification newSourceCode |
	
	newSourceCode := self implementorNewSourceCodeOf: anImplementor.
	implementorClassification := anImplementor methodClass organization categoryOfElement: oldSelector.
	
	anImplementor methodClass 
		compile: newSourceCode  
		classified: implementorClassification.
! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'HAW 8/18/2018 12:02:25'!
                         createNewImplementorOf: anImplementor

	| newImplementor |

	self compileNewImplementorOf: anImplementor.
	newImplementor := anImplementor methodClass compiledMethodAt: newSelector.
	self addToSendersIfOldSelectorIsSentIn: newImplementor.
	
	changes add: newImplementor methodReference 
	
	! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'HAW 8/18/2018 12:02:52'!
                         createNewImplementors
	
	implementors do: [:anImplementor | self createNewImplementorOf: anImplementor ]
	! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'HAW 8/18/2018 12:06:01'!
                 implementorNewSourceCodeOf: anImplementor

	self subclassResponsibility ! !
!ChangeSelector methodsFor: 'rename senders - private' stamp: 'HAW 11/29/2018 15:28:39'!
                           add: oldSelectorLiteralRanges to: rangesToKeywords

	oldSelectorLiteralRanges do: [ :oldSelectorLiteralRange | 
		rangesToKeywords add: (oldSelectorLiteralRange first + 1 to: oldSelectorLiteralRange last) -> newSelector ].
	

	! !
!ChangeSelector methodsFor: 'rename senders - private' stamp: 'HAW 8/18/2018 12:05:39'!
 addMessageSendSelectorKeywordRangesOf: aMethodNode to: rangesToKeywords

	self subclassResponsibility ! !
!ChangeSelector methodsFor: 'rename senders - private' stamp: 'HAW 11/29/2018 15:29:06'!
                             addRangesForLiteralInLiteralArrayOf: methodNode to: rangesToKeywords

	| oldSelectorLiteralRanges |
	
	oldSelectorLiteralRanges := methodNode positionsInLiteralArrayOf: oldSelector.
	self add: oldSelectorLiteralRanges to: rangesToKeywords ! !
!ChangeSelector methodsFor: 'rename senders - private' stamp: 'HAW 11/29/2018 15:28:27'!
                    addRangesForLiteralOf: methodNode to: rangesToKeywords
	
	| oldSelectorLiteralRanges |
	
	oldSelectorLiteralRanges := methodNode positionsForLiteralNode: oldSelector ifAbsent: [ ^#() ].
	self add: oldSelectorLiteralRanges to: rangesToKeywords.
	! !
!ChangeSelector methodsFor: 'rename senders - private' stamp: 'HAW 11/29/2018 14:16:42'!
              rangesToKeywordsOf: aMethod
	
	| methodNode rangesToKeywords |
	
	methodNode := aMethod methodNode.
	rangesToKeywords := SortedCollection sortBlock: [ :left :right | left key first < right key first ].
	
	self addMessageSendSelectorKeywordRangesOf: methodNode to: rangesToKeywords.
	self addRangesForLiteralOf: methodNode to: rangesToKeywords.
	self addRangesForLiteralInLiteralArrayOf: methodNode to: rangesToKeywords.
	
	^rangesToKeywords	! !
!ChangeSelector methodsFor: 'rename senders - private' stamp: 'HAW 8/18/2018 12:03:19'!
           renameSenders
	
	senders do: [ :aSender | self renameSendersIn: aSender ].
	! !
!ChangeSelector methodsFor: 'rename senders - private' stamp: 'HAW 9/4/2018 19:25:20'!
                         renameSendersIn: aMethod

	| newSource rangesToNewStrings |
	
	rangesToNewStrings := self rangesToKeywordsOf: aMethod.
	newSource := aMethod sourceCode copyReplacing: rangesToNewStrings.
	aMethod methodClass compile: newSource.
	
	changes add: (MethodReference class: aMethod methodClass selector: aMethod selector)! !
!ChangeSelector methodsFor: 'implementors/senders' stamp: 'HAW 8/18/2018 12:04:37'!
             implementorsSize
	
	^implementors size! !
!ChangeSelector methodsFor: 'implementors/senders' stamp: 'HAW 8/18/2018 12:03:31'!
  sendersSize
	
	^senders size! !
!ChangeSelector methodsFor: 'initialization' stamp: 'HAW 9/3/2018 17:17:19'!
                   initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders
	
	oldSelector := anOldSelector.
	newSelector := aNewSelector.
	implementors := aCollectionOfImplementors.
	"I have to make a copy of senders because it can change with recursive implementors - Hernan"
	senders := aCollectionOfSenders asOrderedCollection.
	
	changes := Set new
	! !
!ChangeSelector methodsFor: 'selectors' stamp: 'HAW 1/7/2019 13:59:37'!
        newSelector
	
	^newSelector ! !
!ChangeSelector class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 12:39:40'!
            assertAllImplementors: implementors haveSame: aSelector

	| invalidImplementors |
	
	invalidImplementors := implementors reject: [ :anImplementor | anImplementor selector = aSelector ].
	invalidImplementors notEmpty ifTrue: [ self signalInvalidImplementors: invalidImplementors ].! !
!ChangeSelector class methodsFor: 'pre-conditions' stamp: 'HAW 11/29/2018 12:04:20'!
               assertAllSenders: senders send: aSelector

	| invalidSenders |
	
	invalidSenders := senders reject: [ :aSender | aSender sendsOrRefersTo: aSelector ].
	invalidSenders notEmpty ifTrue: [ self signalInvalidSenders: invalidSenders of: aSelector ]! !
!ChangeSelector class methodsFor: 'exceptions' stamp: 'HAW 1/7/2019 10:51:35'!
                          errorMessageForInvalidImplementors: aCollectionOfInvalidImplementors

	^String streamContents: [ :stream |
		stream 
			nextPutAll: (aCollectionOfInvalidImplementors size = 1 ifTrue: [ 'This method' ] ifFalse: [ 'These methods']);
		 	nextPutAll: ' do not have same the same selector to rename: '.
		aCollectionOfInvalidImplementors asCommaSeparated: [:anImplementor | anImplementor printClassAndSelectorOn: stream ] on: stream ] ! !
!ChangeSelector class methodsFor: 'exceptions' stamp: 'HAW 1/7/2019 10:51:35'!
                               errorMessageForInvalidSenders: aCollectionOfInvalidSenders of: anOldSelector

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'Message #';
			nextPutAll: anOldSelector;
			nextPutAll: ' is not send by: '.
		aCollectionOfInvalidSenders asCommaSeparated: [:aSender | aSender printClassAndSelectorOn: stream ] on: stream ] ! !
!ChangeSelector class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 12:43:59'!
                              signalInvalidImplementors: invalidImplementors

	self refactoringError: (self errorMessageForInvalidImplementors: invalidImplementors).! !
!ChangeSelector class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 15:49:58'!
     signalInvalidSenders: invalidSender of: aSelector

	self refactoringError: (self errorMessageForInvalidSenders: invalidSender of: aSelector).! !
!ChangeSelector class methodsFor: 'implementors and senders' stamp: 'HAW 8/18/2018 17:19:35'!
                 addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aPotentialClassToRefactor
	
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor theNonMetaClass.
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor theMetaClass.

! !
!ChangeSelector class methodsFor: 'implementors and senders' stamp: 'HAW 8/18/2018 17:19:39'!
               addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	| categories |
	
	categories := Set new.

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass doingPerClass: [:aClassInHierarchy | categories add: aClassInHierarchy category ].
	categories do: [:aCategory | self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aCategory organizedBy: anOrganization ].
! !
!ChangeSelector class methodsFor: 'implementors and senders' stamp: 'HAW 8/18/2018 17:19:42'!
                    addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aCategory organizedBy: anOrganization

	| classesInCategory |
	
	classesInCategory := anOrganization classesAt: aCategory.
	classesInCategory do: [ :aPotentialClassToRefactor | self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aPotentialClassToRefactor ].
! !
!ChangeSelector class methodsFor: 'implementors and senders' stamp: 'HAW 8/18/2018 17:19:45'!
                            addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass doingPerClass: [ :aClassInHierarchy | ]
		
	! !
!ChangeSelector class methodsFor: 'implementors and senders' stamp: 'HAW 8/18/2018 17:19:49'!
               addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass doingPerClass: aBlock

	aClass theNonMetaClass withAllSubAndSuperclassesDo: [ :aPotentialClassToRefactor |
		aPotentialClassToRefactor isMeta ifFalse: [ 
			self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aPotentialClassToRefactor.
			aBlock value: aPotentialClassToRefactor ]]
	! !
!ChangeSelector class methodsFor: 'implementors and senders' stamp: 'HAW 8/18/2018 17:19:52'!
                         addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inSystem: aSystem

	aSystem allBehaviorsDo: [ :aPotentialClassToRefactor | 
		self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor ].
! !
!ChangeSelector class methodsFor: 'implementors and senders' stamp: 'HAW 10/15/2018 20:53:23'!
                         addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor
	
	| potentialImplementor |
	
	potentialImplementor := aPotentialClassToRefactor compiledMethodAt: anOldSelector ifAbsent: [ nil ].
	potentialImplementor ifNotNil: [ implementors add: potentialImplementor ].
	
	(aPotentialClassToRefactor whichSelectorsReferTo: anOldSelector) do: [ :aSelector | senders add: (aPotentialClassToRefactor compiledMethodAt: aSelector) ].
	! !
!AddParameter methodsFor: 'initialization' stamp: 'HAW 9/4/2018 19:00:42'!
                           initializedNamed: aNewParameter 
	at: anIndex
	addingLast: anIsAddingLast
	initializedWith: aNewParameterValue 
	to: anOldSelector 
	implementing: aNewSelector  
	addingToImplementors: anImplementorTrailingString 
	addingToSenders: aSenderTrailingString
	implementors: implementorsCollection 
	senders: sendersCollection

	super initializeFrom: anOldSelector to: aNewSelector implementors: implementorsCollection senders: sendersCollection.
	
	newParameter := aNewParameter.
	newParameterValue := aNewParameterValue.
	implementorTrailingString := anImplementorTrailingString.
	senderTrailingString := aSenderTrailingString.
	
	index := anIndex.
	isAddingLast := anIsAddingLast ! !
!AddParameter methodsFor: 'rename senders - private' stamp: 'HAW 3/4/2019 10:21:05'!
  addMessageSendSelectorKeywordRangesOf: aMethodNode to: rangesToKeywords
	
	| insertionPoints senderSourceCode |
	
	senderSourceCode := aMethodNode sourceText.
	isAddingLast 
		ifTrue: [ 
			insertionPoints := aMethodNode messageSendLastPositionsOf: oldSelector ifAbsent: [ #() ].
			insertionPoints do: [ :aPosition | | newPosition |
			newPosition := self firstNoSeparatorIndexIn: senderSourceCode startingFrom: aPosition.
			rangesToKeywords add: ((newPosition+1) to: newPosition) -> senderTrailingString ]]
		ifFalse: [ 
			insertionPoints := aMethodNode messageSendKeywordPositionsAt: index of: oldSelector ifAbsent: [ #()].
			insertionPoints do: [ :aPosition | 
			rangesToKeywords add: (aPosition to: aPosition-1) -> senderTrailingString ]]
	! !
!AddParameter methodsFor: 'rename senders - private' stamp: 'HAW 11/11/2018 14:07:23'!
                        firstNoLineSeparatorIndexIn: sourceCode startingFrom: aStartingPosition
	
	^self firstNot: [ :aChar | aChar isLineSeparator ] indexIn: sourceCode startingFrom: aStartingPosition ! !
!AddParameter methodsFor: 'rename senders - private' stamp: 'HAW 11/11/2018 14:06:46'!
                   firstNoSeparatorIndexIn: sourceCode startingFrom: aStartingPosition

	"Looks going back for the first no separator char. See #test24AddingParameterToSendersTakeCaresOfSeparators
	It assumes that there is always going to be a no separator wich holds due to how aStartPosition is obtained - Hernan"
	
	^self firstNot: [ :aChar | aChar isSeparator ] indexIn: sourceCode startingFrom: aStartingPosition ! !
!AddParameter methodsFor: 'rename senders - private' stamp: 'HAW 1/7/2019 13:43:36'!
                        firstNot: aBlock indexIn: sourceCode startingFrom: aStartingPosition
	
	| noSeparatorIndex |
	
	noSeparatorIndex := aStartingPosition.
	[ noSeparatorIndex > 0 and: [ aBlock value: (sourceCode at: noSeparatorIndex) ]] whileTrue: [ noSeparatorIndex := noSeparatorIndex - 1 ].
	
	^noSeparatorIndex 
		! !
!AddParameter methodsFor: 'create new implementors - private' stamp: 'HAW 11/11/2018 14:07:55'!
                  implementorNewSourceCodeOf: anImplementor

	| implementorMethodNode newSource originalSource insertionPoint |

	implementorMethodNode := anImplementor methodNode.
	insertionPoint := isAddingLast 
		ifTrue: [ implementorMethodNode selectorLastPosition ]
		ifFalse: [ (implementorMethodNode selectorKeywordPositionAt: index) first - 1].

	originalSource := anImplementor sourceCode.
	insertionPoint := self firstNoLineSeparatorIndexIn: originalSource startingFrom: insertionPoint.
	
	newSource := String streamContents: [ :newSourceStream |
		newSourceStream 
			nextPutAll: (originalSource copyFrom: 1 to: insertionPoint);
			nextPutAll: implementorTrailingString;
			nextPutAll: (originalSource copyFrom: insertionPoint+1 to: originalSource size) ].
		
	^newSource! !
!AddParameter class methodsFor: 'instance creation' stamp: 'HAW 9/4/2018 19:59:06'!
            named: aNewParameter
	at: anIndex 
	initializedWith: aNewParameterValue
	using: aNewKeyword 
	toKeywordSelector: anOldSelector  
	implementors: implementorsCollection 
	senders: sendersCollection

	| validNewParameterValue isAddingLast numberOfParameters |
	
	self assertIsKeyword: anOldSelector.
	self assertIsValidKeywordForNewParameter: aNewKeyword.
	validNewParameterValue := self assertNewParameterValueIsValid: aNewParameterValue.
	numberOfParameters := anOldSelector numArgs.
	self assert: anIndex isValidIndexFor: numberOfParameters.
	isAddingLast := anIndex > numberOfParameters.
	
	^self 
		named: aNewParameter 
		at: anIndex
		addingLast: isAddingLast 
		initializedWith: aNewParameterValue 
		to: anOldSelector 
		implementing: (self newSelectorAdding: aNewKeyword at: anIndex to: anOldSelector) 
		addingToImplementors: (self keywordImplementorTrailingFor: aNewKeyword and: aNewParameter addingLast: isAddingLast) 
		addingToSenders: (self keywordSenderTrailingFor: aNewKeyword and: validNewParameterValue addingLast: isAddingLast)
		implementors: implementorsCollection 
		senders: sendersCollection
! !
!AddParameter class methodsFor: 'instance creation' stamp: 'HAW 9/4/2018 19:32:45'!
             named: aNewParameter 
	initializedWith: aNewParameterValue 
	toUnarySelector: anOldSelector  
	implementors: implementorsCollection 
	senders: sendersCollection

	| validNewParameterValue |
	
	self assertIsUnary: anOldSelector.
	validNewParameterValue := self assertNewParameterValueIsValid: aNewParameterValue.

	^self 
		named: aNewParameter 
		at: 1
		addingLast: true
		initializedWith: aNewParameterValue 
		to: anOldSelector 
		implementing: (self newSelectorFromUnary: anOldSelector)
		addingToImplementors: (self unaryImplementorTrailingFor: aNewParameter)
		addingToSenders: (self unarySenderTrailingFor: validNewParameterValue)
		implementors: implementorsCollection 
		senders: sendersCollection
! !
!AddParameter class methodsFor: 'instance creation' stamp: 'HAW 9/4/2018 17:26:10'!
     named: aNewParameter 
	initializedWith: aNewParameterValue
	using: aNewKeyword 
	toKeywordSelector: anOldSelector  
	implementors: implementorsCollection 
	senders: sendersCollection

	^self 
		named: aNewParameter 
		at: anOldSelector numArgs + 1
		initializedWith: aNewParameterValue
		using: aNewKeyword 
		toKeywordSelector: anOldSelector  
		implementors: implementorsCollection 
		senders: sendersCollection
! !
!AddParameter class methodsFor: 'instance creation - private' stamp: 'HAW 9/4/2018 19:05:41'!
keywordImplementorTrailingFor: aNewKeyword and: aNewParameter addingLast: isAddingLast

	^String streamContents: [ :stream |
		isAddingLast ifTrue: [ stream space ].
		stream
			nextPutAll: aNewKeyword;
			space;
			nextPutAll: aNewParameter;
			space ]! !
!AddParameter class methodsFor: 'instance creation - private' stamp: 'HAW 9/4/2018 19:23:31'!
 keywordSenderTrailingFor: aNewKeyword and: aNewParameterValue addingLast: isAddingLast

	^String streamContents: [ :stream |
		isAddingLast ifTrue: [ stream space ].
		stream
			nextPutAll: aNewKeyword;
			space;
			nextPutAll: aNewParameterValue.
		isAddingLast ifFalse: [ stream space ] ]

	! !
!AddParameter class methodsFor: 'instance creation - private' stamp: 'HAW 9/4/2018 19:00:16'!
                         named: aNewParameter 
	at: anIndex
	addingLast: isAddingLast
	initializedWith: aNewParameterValue 
	to: anOldSelector 
	implementing: aNewSelector
	addingToImplementors: implementorTrailingString 
	addingToSenders: senderTrailingString
	implementors: implementorsCollection 
	senders: sendersCollection

	| trimmedNewParameter |
	
	trimmedNewParameter := aNewParameter withBlanksTrimmed.
	
	self assertCanAddParameterTo: anOldSelector.
	self assertIsValidParameterName: trimmedNewParameter.
	self assertNewParameter: trimmedNewParameter isNotDefinedAsInstanceVariableInAny: implementorsCollection.
	self assertNewParameter: trimmedNewParameter isNotDefinedAsLocalInAny: implementorsCollection.
	self assertAllImplementors: implementorsCollection haveSame: anOldSelector.
	self assertAllSenders: sendersCollection send: anOldSelector.
	
	^ self new 
		initializedNamed: trimmedNewParameter
		at: anIndex 
		addingLast: isAddingLast
		initializedWith: aNewParameterValue 
		to: anOldSelector 
		implementing: aNewSelector
		addingToImplementors: implementorTrailingString 
		addingToSenders: senderTrailingString
		implementors: implementorsCollection 
		senders: sendersCollection
! !
!AddParameter class methodsFor: 'instance creation - private' stamp: 'HAW 9/4/2018 21:32:44'!
  newSelectorAdding: aNewKeyword at: anIndex to: anOldSelector

	| keywords |
	
	keywords := anOldSelector keywords asOrderedCollection. 
	keywords add: aNewKeyword beforeIndex: anIndex.
	
	^Symbol fromCollectionOfStrings: keywords.
	
	! !
!AddParameter class methodsFor: 'instance creation - private' stamp: 'HAW 8/18/2018 12:14:00'!
                   newSelectorFromUnary: anOldSelector

	^(anOldSelector, ':') asSymbol! !
!AddParameter class methodsFor: 'instance creation - private' stamp: 'HAW 8/18/2018 12:15:49'!
                         unaryImplementorTrailingFor: aNewParameter

	^ ': ', aNewParameter! !
!AddParameter class methodsFor: 'instance creation - private' stamp: 'HAW 8/18/2018 12:16:32'!
                           unarySenderTrailingFor: aNewParameterValue

	^ ': ', aNewParameterValue! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/25/2018 11:34:59'!
   addParenthesisTo: trimmedNewParameterValue ifNewParameterValueIsKeywordMessage: newParameterValueMethodNode

	| newParameterNode |
	
	newParameterNode := newParameterValueMethodNode block statements first expr.
		
	^ (self hasToAddParenthesisBasedOn: newParameterNode)
		ifTrue: [ '(', trimmedNewParameterValue, ')' ]
		ifFalse: [ trimmedNewParameterValue ]
	! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/4/2018 20:08:37'!
    assert: anIndex isValidIndexFor: aNumberOfParameters

	(anIndex isInteger and: [ (anIndex between: 1 and: aNumberOfParameters + 1)]) ifFalse: [ self signalInvalidParameterIndex: anIndex for: aNumberOfParameters ]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 16:02:12'!
                      assertCanAddParameterTo: aSelector

	aSelector isInfix ifTrue: [ self signalSelectorCanNotBeBinary]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 12:29:54'!
       assertIsKeyword: aSelector

	aSelector isKeyword ifFalse: [ self signalSelectorMustBeKeyword]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 12:23:04'!
             assertIsUnary: aSelector

	aSelector isUnary ifFalse: [ self signalSelectorMustBeUnary]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 16:30:01'!
                   assertIsValidKeywordForNewParameter: aNewKeyword

	(aNewKeyword isKeyword and: [aNewKeyword numArgs = 1 ]) ifFalse: [ self signalNotValidKeywordForNewParameter]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/17/2018 12:30:40'!
          assertIsValidParameterName: aName

	| scannedNames |

	scannedNames _ Scanner new scanFieldNames: aName.
	scannedNames size = 1 ifFalse: [ self signalInvalidParameterName: aName ].
	scannedNames first = aName ifFalse: [ self signalInvalidParameterName: aName ].
! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/17/2018 16:59:29'!
    assertNewParameter: aNewParameter isNotDefinedAsInstanceVariableInAny: implementors

	| classesDefiningInsVars |
	
	classesDefiningInsVars := self classesDefiningInstanceVariable: aNewParameter inAny: implementors.
	classesDefiningInsVars notEmpty ifTrue: [ self signalNewParameter: aNewParameter definedAsInstanceVariableIn: classesDefiningInsVars ]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/17/2018 16:59:47'!
            assertNewParameter: aNewParameter isNotDefinedAsLocalInAny: implementors

	| implementorsDefiningNewParameterAsLocal |
	
	implementorsDefiningNewParameterAsLocal := implementors select: [ :implementor | implementor methodNode hasLocalNamed: aNewParameter ].
	implementorsDefiningNewParameterAsLocal notEmpty ifTrue: [ 
		self signalNewParameter: aNewParameter isDefinedAsLocalIn: implementorsDefiningNewParameterAsLocal ]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/25/2018 11:30:18'!
     assertNewParameterValueCompiles: trimmedNewParameterValue

	^ [ Parser new parse: trimmedNewParameterValue readStream class: self noPattern: true notifying: nil ifFail: [nil] ]
		on: SyntaxErrorNotification 
		do: [ :error | self signalNewParameterValueDoesNotCompile ].! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/25/2018 11:31:42'!
                            assertNewParameterValueDoesNotHaveMoreThanOneStatement: newParameterValueMethodNode

	newParameterValueMethodNode block statements size = 1 ifFalse: [ self signalNewParameterValueCanNotHaveMoreThanOneStatement ].
	! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/17/2018 12:21:40'!
                    assertNewParameterValueIsNotEmpty: aNewParameterValue

	aNewParameterValue withBlanksTrimmed isEmpty ifTrue: [ self signalNewParameterValueCanNotBeEmpty]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/25/2018 11:33:38'!
                 assertNewParameterValueIsValid: aNewParameterValue

	| newParameterValueMethodNode trimmedNewParameterValue |
	
	trimmedNewParameterValue := aNewParameterValue withBlanksTrimmed.
	self assertNewParameterValueIsNotEmpty: trimmedNewParameterValue.

	newParameterValueMethodNode := self assertNewParameterValueCompiles: trimmedNewParameterValue.
	self assertNewParameterValueDoesNotHaveMoreThanOneStatement: newParameterValueMethodNode.
	
	^self addParenthesisTo: trimmedNewParameterValue ifNewParameterValueIsKeywordMessage: newParameterValueMethodNode.
	! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'HAW 8/25/2018 11:35:10'!
 hasToAddParenthesisBasedOn: newParameterNode
	
	^ newParameterNode isMessageNode and: [  newParameterNode selector key isKeyword ]! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 15:05:29'!
            classesDefiningInstanceVariable: aName inAny: implementors
 
	^ implementors 
		inject: Set new
		into: [ :classesDefiningInstVar :implementor | 
			(implementor methodClass whichClassDefinesInstanceVariable: aName ifNone: [ nil ]) ifNotNil: [ :classDefiningInstVar |
				classesDefiningInstVar add: classDefiningInstVar ].
			classesDefiningInstVar ]
! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 9/4/2018 20:03:25'!
               errorMessageForInvalidParameterIndex: anIndex for: aNumberOfParameters

	^anIndex printString, ' is an invalid insertion index. It has to be between 1 and ', (aNumberOfParameters + 1) printString! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 12:31:35'!
           errorMessageForInvalidParameterName: aName

	^ '''' , aName , ''' is not a valid parameter name'.! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 15:18:46'!
             errorMessageForNewParameter: aNewParameter definedAsInstanceVariableIn: definingClasses

	^ String streamContents: [ :messageStream |
		messageStream 
			nextPutAll: definingClasses asCommaStringAnd;
			space;
			nextPutAll: (definingClasses size = 1 ifTrue: [ 'defines' ] ifFalse: [ 'define' ]);
			space;
			nextPutAll: aNewParameter;
			nextPutAll: ' as instance variable' ]! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 9/2/2018 19:59:27'!
                      errorMessageForNewParameterDefinedAsLocal: aNewParameter

	^ aNewParameter, ' is already defined as parameter or temporary'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 12:22:31'!
                   newParameterValueCanNotBeEmptyErrorMessage
	
	^'New parameter value can not be empty'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/25/2018 11:26:54'!
                         newParameterValueCanNotHaveMoreThanOneStatementErrorMessage
	
	^'New parameter value can not have more than one statement'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 12:24:53'!
                    newParameterValueDoesNotCompileErrorMessage
	
	^'New parameter value code does not compile'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 16:31:03'!
                   notValidKeywordForNewParameterErrorMessage
	
	^'New keyword must be of keyword type with one parameter'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 12/13/2018 17:46:33'!
      selectorCanNotBeBinaryErrorMessage
	
	^'Can not add parameter to a binary selector.
Rename it to a keyword message first.'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 12:26:46'!
                    selectorMustBeKeywordErrorMessage
	
	^'Selector must be of keyword type'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 12:23:47'!
      selectorMustBeUnaryErrorMessage
	
	^'Selector must be unary'! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 9/4/2018 20:02:24'!
                   signalInvalidParameterIndex: anIndex for: aNumberOfParameters

	self refactoringError: (self errorMessageForInvalidParameterIndex: anIndex for: aNumberOfParameters)! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 12:31:15'!
          signalInvalidParameterName: aName

	self refactoringError: (self errorMessageForInvalidParameterName: aName)

! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 15:11:03'!
signalNewParameter: aNewParameter definedAsInstanceVariableIn: definingClasses

	self refactoringError: (self errorMessageForNewParameter: aNewParameter definedAsInstanceVariableIn: definingClasses)! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 9/2/2018 19:59:27'!
         signalNewParameter: aNewParameter isDefinedAsLocalIn: implementors

	self 
		canNotRefactorDueToReferencesError: (self errorMessageForNewParameterDefinedAsLocal: aNewParameter)
		references: (implementors collect: [ :implementor | MethodReference method: implementor ])
		to: aNewParameter 
	 ! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 12:22:07'!
         signalNewParameterValueCanNotBeEmpty
	
	self refactoringError: self newParameterValueCanNotBeEmptyErrorMessage! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/25/2018 11:27:05'!
signalNewParameterValueCanNotHaveMoreThanOneStatement
	
	self refactoringError: self newParameterValueCanNotHaveMoreThanOneStatementErrorMessage! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 12:24:53'!
                              signalNewParameterValueDoesNotCompile
	
	self refactoringError: self newParameterValueDoesNotCompileErrorMessage! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 16:25:55'!
                              signalNotValidKeywordForNewParameter
	
	self refactoringError: self notValidKeywordForNewParameterErrorMessage! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 12:35:05'!
signalSelectorCanNotBeBinary
	
	self refactoringError: self selectorCanNotBeBinaryErrorMessage! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 12:29:54'!
                signalSelectorMustBeKeyword
	
	self refactoringError: self selectorMustBeKeywordErrorMessage! !
!AddParameter class methodsFor: 'exceptions' stamp: 'HAW 8/18/2018 12:23:26'!
                  signalSelectorMustBeUnary
	
	self refactoringError: self selectorMustBeUnaryErrorMessage! !
!RemoveParameter methodsFor: 'initialization' stamp: 'HAW 9/4/2018 14:31:23'!
                      initializeNamed: aParameterToRemove
	ofKeywordAtIndex: aParameterIndex
	from: anOldSelector 
	creating: aNewSelector 
	implementors: implementorsCollection 
	senders: sendersCollection
	
	super initializeFrom: anOldSelector to: aNewSelector implementors: implementorsCollection senders: sendersCollection.

	parameterToRemove := aParameterToRemove.
	parameterIndex := aParameterIndex.
	senderReplacementString := newSelector isUnary ifTrue: [ newSelector asString ] ifFalse: [ '' ].
	isLastParameter := oldSelector numArgs = parameterIndex 
	! !
!RemoveParameter methodsFor: 'create new implementors - private' stamp: 'HAW 9/4/2018 14:42:51'!
                             implementorNewSourceCodeOf: anImplementor

	| implementorMethodNode newSource originalSource parameterToRemovePosition selectorToRemovePosition |
	
	implementorMethodNode := anImplementor methodNode.
	selectorToRemovePosition := implementorMethodNode selectorKeywordPositionAt: parameterIndex.
	parameterToRemovePosition := implementorMethodNode parameterDefinitionPositionAt: parameterIndex.

	originalSource := anImplementor sourceCode.
	newSource := String streamContents: [ :newSourceStream | 
		self writeBeforeKeywordIn: newSourceStream from: originalSource removing: selectorToRemovePosition.
		self writeAfterParameterIn: newSourceStream from: originalSource removing: parameterToRemovePosition ].
		
	^newSource! !
!RemoveParameter methodsFor: 'create new implementors - private' stamp: 'HAW 9/4/2018 14:42:51'!
           writeAfterParameterIn: newSourceStream from: originalSource removing: parameterToRemovePosition
	
	| afterParameterPosition |
	
	afterParameterPosition := parameterToRemovePosition last.
	isLastParameter ifFalse: [ afterParameterPosition := self lastSeparatorIndexIn: originalSource startingFrom: afterParameterPosition ].
	
	newSourceStream nextPutAll: (originalSource copyFrom: afterParameterPosition + 1 to: originalSource size) 	! !
!RemoveParameter methodsFor: 'create new implementors - private' stamp: 'HAW 9/4/2018 14:35:27'!
          writeBeforeKeywordIn: newSourceStream from: originalSource removing: selectorToRemovePosition

	newSelector isUnary 
		ifTrue: [ newSourceStream nextPutAll: newSelector ]
		ifFalse: [ newSourceStream nextPutAll: (originalSource copyFrom: 1 to: selectorToRemovePosition first - 1) ].
! !
!RemoveParameter methodsFor: 'rename senders - private' stamp: 'HAW 9/4/2018 17:42:53'!
         addMessageSendSelectorKeywordRangesOf: aMethodNode to: rangesToKeywords
	
	| keywordAndParameterPositions senderSourceCode |
	
	senderSourceCode := aMethodNode sourceText.
	keywordAndParameterPositions := aMethodNode messageSendKeywordAndParameterPositionsAt: parameterIndex of: oldSelector ifAbsent: [ #() ].
	keywordAndParameterPositions do: [ :aKeywordAndParameterPosition | | lastPosition |
		lastPosition := self lastSeparatorIndexIn: senderSourceCode startingFrom: aKeywordAndParameterPosition last.
		rangesToKeywords add: (aKeywordAndParameterPosition first to: lastPosition) -> senderReplacementString ]
	! !
!RemoveParameter methodsFor: 'rename senders - private' stamp: 'HAW 9/4/2018 12:10:34'!
                              lastSeparatorIndexIn: senderSourceCode startingFrom: aPosition

	| lastPosition senderSourceCodeSize |
	
	lastPosition := aPosition.
	senderSourceCodeSize := senderSourceCode size.
	[ lastPosition := lastPosition + 1.
	lastPosition <= senderSourceCodeSize and: [ (senderSourceCode at: lastPosition) isSeparator ]] whileTrue. 

	^lastPosition - 1! !
!RemoveParameter class methodsFor: 'instance creation' stamp: 'HAW 9/4/2018 15:17:51'!
            named: aParameterToRemove from: aMethod implementors: implementorsCollection senders: sendersCollection
	
	| oldSelector methodNode parameterIndex newSelector |
	
	oldSelector := aMethod selector.
	self assertCanRemoveParameterFrom: oldSelector.
	
	methodNode := aMethod methodNode.
	parameterIndex := self assert: aParameterToRemove isDefinedIn: methodNode.
	self assertAllImplementors: implementorsCollection haveSame: oldSelector.
	self assertAllSenders: sendersCollection send: oldSelector.
	self assertNoImplementorFrom: implementorsCollection reference: aParameterToRemove definedAt: parameterIndex.
	
	newSelector := self newSelectorFrom: oldSelector removingParameterAt: parameterIndex.
	
	^self new 
		initializeNamed: aParameterToRemove
		ofKeywordAtIndex: parameterIndex
		from: oldSelector 
		creating: newSelector 
		implementors: implementorsCollection 
		senders: sendersCollection
! !
!RemoveParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/2/2018 20:07:30'!
       assert: aParamerterToRemove isDefinedIn: methodNode

	| parameterIndex |
	
	parameterIndex := methodNode arguments findFirst: [ :aParameterNode | aParameterNode name = aParamerterToRemove ].
	parameterIndex = 0 ifTrue: [ self signalParameterNotInMessage: aParamerterToRemove ].
	
	^parameterIndex 
		! !
!RemoveParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/4/2018 15:18:13'!
                            assertCanRemoveParameterFrom: oldSelector

	self assertIsNotUnary: oldSelector.
	self assertIsNotBinary: oldSelector.! !
!RemoveParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/1/2018 12:34:26'!
                   assertIsNotBinary: aSelector

	aSelector isInfix ifTrue: [ self signalCanNotRemoveParameterFromBinaryMessages]! !
!RemoveParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/1/2018 12:37:00'!
                          assertIsNotUnary: aSelector

	aSelector isUnary ifTrue: [ self signalCanNotRemoveParameterFromUnaryMessages]! !
!RemoveParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/4/2018 15:41:24'!
                            assertNoImplementorFrom: implementorsCollection reference: aParamerterToRemove definedAt: parameterIndex

	| implementorsReferencingParameter |
	
	implementorsReferencingParameter := implementorsCollection select: [:anImplementor | anImplementor referencesParameterAt: parameterIndex ].
	
	implementorsReferencingParameter isEmpty ifFalse: [ self signalCanNotRemove: aParamerterToRemove dueToReferencesIn: implementorsReferencingParameter ].! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 1/7/2019 15:31:35'!
                   canNotRemoveParameterFromBinaryMessagesErrorMessage
	
	^'Can not remove parameter from binary messages.
Rename message to a keyword one first'! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 9/1/2018 12:36:43'!
                              canNotRemoveParameterFromUnaryMessagesErrorMessage
	
	^'There is no parameter to remove in unary messages'! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 9/2/2018 19:40:52'!
  errorMessageForParameterNotInMessage: aParameterToRemove

	^aParameterToRemove, ' is not define as parameter'! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 9/3/2018 16:27:21'!
                               errorMessageForParameterToRemoveIsReferenced: aParameterToRemove

	^aParameterToRemove, ' is being referenced in implementors'! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 9/2/2018 20:21:43'!
              signalCanNotRemove: aParameterToRemove dueToReferencesIn: implementorsReferencingParameterToRemove

	self 
		canNotRefactorDueToReferencesError: (self errorMessageForParameterToRemoveIsReferenced: aParameterToRemove)
		references: (implementorsReferencingParameterToRemove collect: [ :implementor | MethodReference method: implementor ])
		to: aParameterToRemove 
	 ! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 9/1/2018 12:34:45'!
                              signalCanNotRemoveParameterFromBinaryMessages
	
	self refactoringError: self canNotRemoveParameterFromBinaryMessagesErrorMessage! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 9/1/2018 12:37:00'!
            signalCanNotRemoveParameterFromUnaryMessages
	
	self refactoringError: self canNotRemoveParameterFromUnaryMessagesErrorMessage! !
!RemoveParameter class methodsFor: 'exceptions' stamp: 'HAW 9/2/2018 19:40:22'!
              signalParameterNotInMessage: aParameterToRemove

	self refactoringError: (self errorMessageForParameterNotInMessage: aParameterToRemove)! !
!RemoveParameter class methodsFor: 'instance creation - private' stamp: 'HAW 9/4/2018 21:22:36'!
                   newSelectorConcatenating: oldSelectorKeywords removingAt: anIndex
	
	| keywords |
	
	keywords := oldSelectorKeywords asOrderedCollection.
	keywords removeIndex: anIndex.
	
	^Symbol fromCollectionOfStrings: keywords.! !
!RemoveParameter class methodsFor: 'instance creation - private' stamp: 'HAW 9/4/2018 21:30:47'!
    newSelectorFrom: oldSelector removingParameterAt: parameterIndex

	| oldSelectorKeywords newSelector |
	
	oldSelectorKeywords := oldSelector keywords.
	
	newSelector := oldSelectorKeywords size = 1 
		ifTrue: [ oldSelector allButLast asSymbol ]
		ifFalse: [ self newSelectorConcatenating: oldSelectorKeywords removingAt: parameterIndex ].
	
	^newSelector! !
!RenameSelector methodsFor: 'create new implementors - private' stamp: 'HAW 9/3/2018 19:49:44'!
                          implementorNewSourceCodeOf: anImplementor

	|  newSource rangesToNewKeywords |
	
	rangesToNewKeywords := OrderedCollection new.
	anImplementor methodNode selectorKeywordsPositions withIndexDo: [ :aKeywordRange :index | 
		rangesToNewKeywords add: aKeywordRange -> (newSelectorKeywords at: index) ].
		
	newSource := anImplementor sourceCode copyReplacing: rangesToNewKeywords.	
	^newSource! !
!RenameSelector methodsFor: 'rename senders - private' stamp: 'HAW 9/3/2018 19:47:38'!
addMessageSendSelectorKeywordRangesOf: aMethodNode to: rangesToKeywords
	
	| oldSelectorKeywordsRanges |
	
	oldSelectorKeywordsRanges := aMethodNode messageSendSelectorKeywordPositionsOf: oldSelector ifAbsent: [ #() ].
	oldSelectorKeywordsRanges do: [ :aMessageSendSelectorRanges | 
		aMessageSendSelectorRanges withIndexDo: [ :aRange :index | rangesToKeywords add: aRange -> (newSelectorKeywords at: index) ]].
	! !
!RenameSelector methodsFor: 'initialization' stamp: 'HAW 9/3/2018 17:14:47'!
                  initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders
	
	super initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders.
	
	newSelectorKeywords := newSelector keywords.	
	! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 5/25/2017 20:02:05'!
  assert: aNewSelector hasTheSameNumberOfArgumentsAs: anOldSelector

	aNewSelector numArgs ~= anOldSelector numArgs ifTrue: [ self signalNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector ]! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2017 00:41:25'!
                    assert: aNewSelector isNotEqualTo: anOldSelector

	 aNewSelector = anOldSelector ifTrue: [ self signalNewSelectorEqualToOldSelector]! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 12/13/2018 18:53:51'!
   assert: aNewSelector isOfSameTypeAs: anOldSelector

	(self isRenamigBetweenBinary: anOldSelector andKeywordOfOneParameter: aNewSelector) ifTrue: [ ^self ].
	(self isRenamigBetweenBinary: aNewSelector andKeywordOfOneParameter: anOldSelector) ifTrue: [ ^self ].

	aNewSelector precedence ~= anOldSelector precedence ifTrue: [ 
		self signalNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector ]! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 6/3/2017 11:54:48'!
                           assertIsNotEmpty: aCollection signalMessageText: errorMessageText

	aCollection isEmpty ifTrue: [ self refactoringError: errorMessageText ].! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2017 00:44:37'!
                            assertIsValidToRenameFrom: anOldSelector to: aNewSelector
	
	self assertIsNotEmpty: anOldSelector signalMessageText: self oldSelectorCanNotBeEmptyErrorMessage.
	self assertIsNotEmpty: aNewSelector signalMessageText: self newSelectorCanNotBeEmptyErrorMessage.
	self assert: aNewSelector isNotEqualTo: anOldSelector.
	self assert: aNewSelector isOfSameTypeAs: anOldSelector.
	self assert: aNewSelector hasTheSameNumberOfArgumentsAs: anOldSelector.
	! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 5/31/2017 19:38:12'!
         assertNoImplementorClassIn: implementorsCollection implements: aNewSelector

	| classesImplementingNewSelector |
	
	classesImplementingNewSelector := implementorsCollection 
		select: [ :anImplementor | anImplementor methodClass includesSelector: aNewSelector ]
		thenCollect: [ :anImplementor | anImplementor methodClass ].
		
	classesImplementingNewSelector notEmpty ifTrue: [ self signalNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector ]! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 12/13/2018 18:52:19'!
                     isRenamigBetweenBinary: aPotentiallyBinarySelector andKeywordOfOneParameter: aPotentiallyKeywordSelector

	^aPotentiallyBinarySelector isInfix 
		and: [ aPotentiallyKeywordSelector isKeyword
		and: [ aPotentiallyKeywordSelector numArgs = 1 ]]
! !
!RenameSelector class methodsFor: 'pre-conditions' stamp: 'HAW 5/31/2017 20:56:22'!
                     warnIfImplementionsOf: aNewSelector overridesImplementationInSuperclassesOf: implementorsCollection

	implementorsCollection do: [:anImplementor |
		anImplementor methodClass 
			withSuperclassThatIncludesSelector: aNewSelector 
			do: [ :aSuperclass | self warnImplementionOf: aNewSelector in: anImplementor methodClass willOverrideImplementationIn: aSuperclass ]
			ifNone: []]! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 5/25/2017 19:59:44'!
                 errorMessageForNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector

	^'New selector #', aNewSelector, ' does not have the same number of arguments as #', anOldSelector ! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 5/31/2017 19:41:36'!
            errorMessageForNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector

	^'Can not rename because #', aNewSelector, ' is implemented in: ', classesImplementingNewSelector asCommaStringAnd ! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 5/25/2017 19:54:05'!
                             errorMessageForNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector

	^'New selector #', aNewSelector, ' is not of same type as #', anOldSelector ! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 5/25/2017 18:51:46'!
                    implementorsCanNotBeEmptyErrorMessage
	
	^'There are no methods to rename'! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 5/25/2017 18:49:15'!
  newSelectorCanNotBeEmptyErrorMessage
	
	^'New selector can not be empty'! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 5/26/2017 00:40:01'!
    newSelectorEqualToOldSelectorErrorMessage
	
	^'There is nothing to rename when new selector is equals to old selector'! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 5/25/2017 18:49:07'!
                      oldSelectorCanNotBeEmptyErrorMessage
	
	^'Old selector can not be empty'! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 6/3/2017 11:55:23'!
     signalNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector
	
	self refactoringError: (self errorMessageForNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector).! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 6/3/2017 11:55:38'!
                               signalNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector
	
	self refactoringError: (self errorMessageForNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector).! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 6/3/2017 11:55:54'!
 signalNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector

	self refactoringError: (self errorMessageForNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector).! !
!RenameSelector class methodsFor: 'exceptions' stamp: 'HAW 6/3/2017 11:55:58'!
  signalNewSelectorEqualToOldSelector

	self refactoringError: self newSelectorEqualToOldSelectorErrorMessage.! !
!RenameSelector class methodsFor: 'instance creation' stamp: 'HAW 5/31/2017 19:58:50'!
                         from: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders

	self assertIsValidToRenameFrom: anOldSelector to: aNewSelector.
	self assertIsNotEmpty: aCollectionOfImplementors signalMessageText: self implementorsCanNotBeEmptyErrorMessage.
	self assertAllImplementors: aCollectionOfImplementors haveSame: anOldSelector.
	self assertNoImplementorClassIn: aCollectionOfImplementors implements: aNewSelector.
	self assertAllSenders: aCollectionOfSenders send: anOldSelector.
	
	self warnIfImplementionsOf: aNewSelector overridesImplementationInSuperclassesOf: aCollectionOfImplementors.
	
	^self new initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders
	! !
!RenameSelector class methodsFor: 'instance creation' stamp: 'HAW 5/26/2017 00:04:36'!
            from: anOldSelector to: aNewSelector in: aClassToRefactor

	| implementors senders |
	
	implementors := OrderedCollection new.
	senders := OrderedCollection new.
	
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aClassToRefactor theNonMetaClass.
	
	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders ! !
!RenameSelector class methodsFor: 'instance creation' stamp: 'HAW 5/30/2017 17:45:16'!
    from: anOldSelector to: aNewSelector inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	| implementors senders |
	
	implementors := IdentitySet new.
	senders := IdentitySet new.

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization.
	
	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders 
! !
!RenameSelector class methodsFor: 'instance creation' stamp: 'HAW 5/25/2017 23:59:19'!
                           from: anOldSelector to: aNewSelector inCategoryOf: aClass organizedBy: anOrganization

	| implementors senders |
	
	implementors := OrderedCollection new.
	senders := OrderedCollection new.

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aClass category organizedBy: anOrganization.
	
	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders 
! !
!RenameSelector class methodsFor: 'instance creation' stamp: 'HAW 5/25/2017 23:53:57'!
    from: anOldSelector to: aNewSelector inHierarchyOf: aClass 
	
	| implementors senders |
	
	implementors := OrderedCollection new.
	senders := OrderedCollection new.
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass.
	
	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders 
	
	! !
!RenameSelector class methodsFor: 'instance creation' stamp: 'HAW 5/30/2017 17:47:27'!
                             from: anOldSelector to: aNewSelector inSystem: aSystem

	| implementors senders |
	
	implementors := OrderedCollection new.
	senders := OrderedCollection new.
	
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inSystem: aSystem.
		
	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders 
	! !
!RenameSelector class methodsFor: 'warnings' stamp: 'HAW 6/3/2017 12:01:34'!
                warnImplementionOf: aNewSelector in: aClass willOverrideImplementationIn: aSuperclass
	
	self refactoringWarning: (self warningMessageForImplementationOf: aNewSelector in: aClass willOverrideImplementationIn: aSuperclass).! !
!RenameSelector class methodsFor: 'warnings' stamp: 'HAW 8/1/2018 18:15:01'!
                 warningMessageForImplementationOf: aNewSelector in: aClass willOverrideImplementationIn: aSuperclass

	^'Implemention of #', aNewSelector, ' in ', aClass name, ' will override implementation in ', aSuperclass name! !
!ExtractToTemporary methodsFor: 'applying' stamp: 'HAW 10/18/2017 18:39:22'!
                          apply
	
	| temporaries finder rewriter |
	
	newTemporary := methodNodeToRefactor encoder bindTemp: newVariable.
	temporaries := methodNodeToRefactor temporaries asOrderedCollection.
	temporaries add: newTemporary.
	
	methodNodeToRefactor temporaries: temporaries.
	finder := ParseNodeToReplaceFinder of: self.
	methodNodeToRefactor accept: finder.
	rewriter := ExtractToTemporaryRewriter of: self on: finder.
	methodNodeToRefactor accept: rewriter.
	finder blockContainingFirstNodeToReplace statements 
		add: (AssignmentNode new variable: newTemporary value: parseNodeToExtract) 
		beforeIndex: finder firstNodeToReplaceIndex. 
	
	^methodNodeToRefactor ! !
!ExtractToTemporary methodsFor: 'initialization' stamp: 'HAW 10/4/2017 17:43:11'!
                            initializeNamed: aNewVariable with: aParseNodeToExtract in: aMethodNodeToRefactor
 
	newVariable := aNewVariable.
	parseNodeToExtract := aParseNodeToExtract.
	methodNodeToRefactor := aMethodNodeToRefactor ! !
!ExtractToTemporary methodsFor: 'accessing' stamp: 'HAW 10/4/2017 18:45:19'!
  newTemporary
	
	^newTemporary ! !
!ExtractToTemporary methodsFor: 'accessing' stamp: 'HAW 10/4/2017 18:38:13'!
                 parseNodeToExtract
	
	^parseNodeToExtract! !
!ExtractToTemporary methodsFor: 'testing' stamp: 'HAW 10/18/2017 18:08:31'!
       shouldExtract: aParseNode

	^parseNodeToExtract = aParseNode ! !
!ExtractToTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 9/11/2018 15:52:26'!
        research

"
TextEditor>>selectionInterval
hasSelection
selection
"! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/30/2017 06:25:21'!
  assert: aSourceCodeToExtract isIncludedIn: aMethodNodeToRefactor

	(aMethodNodeToRefactor sourceText includesSubString: aSourceCodeToExtract) ifFalse:  [
		self signalMethodNodeToRefactorDoesNotInclude: aSourceCodeToExtract ]
	
! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/26/2017 16:30:52'!
assert: aNewVariable isNotDefinedIn: aMethodNode 
	
	(aMethodNode tempNames includes: aNewVariable) ifTrue: [ self signalNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode ]
	! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/26/2017 16:23:25'!
     assertIsNotEmpty: aNewVariable

	aNewVariable isEmpty ifTrue: [ self signalNewVariableCanNotBeEmpty ]! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 3/6/2018 16:01:34'!
assertIsNotReturn: aSourceCodeToExtract

	"I have to use the source code to check this because parsing it returns the same methodNode for
	1 and ^1, that is, using methodNode does not help to distigished if there was or not a return - Hernan"
	
	aSourceCodeToExtract withBlanksTrimmed first = $^ ifTrue: [ self signalSourceCodeToExtractCanNotIncludeReturn ]! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/27/2017 17:52:29'!
                               assertIsOneStatement: aMethodNodeToExtract

	aMethodNodeToExtract block statements size ~= 1 ifTrue: [ self signalColaborationToExtractHasToBeOneStatement]! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/26/2017 16:27:32'!
         assertIsValidVariableName: aName

	| scannedNames |

	scannedNames _ Scanner new scanFieldNames: aName.
	scannedNames size = 1 ifFalse: [ self signalInvalidTemporaryVariable: aName ].
	scannedNames first = aName ifFalse: [ self signalInvalidTemporaryVariable: aName ].! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/30/2017 06:21:22'!
                        assertSourceCodeIsNotEmpty: aSourceCodeToExtract

	aSourceCodeToExtract isEmpty ifTrue: [ self signalSourceCodeToExtractCanNotBeEmpty]! !
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/26/2017 16:33:25'!
                              warnIf: aNewVariable isDefinedAsInstanceVariableInHierarchyOf: aClass 
	
	| classDefiningNewVariable |
	
	classDefiningNewVariable := aClass whichClassDefinesInstanceVariable: aNewVariable ifNone: [ ^self ].
	self warn: aNewVariable willHideInstanceVariableDefinedIn: classDefiningNewVariable ! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/26/2017 16:28:07'!
   errorMessageForInvalidTemporaryVariable: aName

	^ '''' , aName , ''' is not a valid temporary variable name'.! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/26/2017 16:31:23'!
                          errorMessageForNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode

	^aNewVariable, ' is already defined in ', aMethodNode classAndSelector ! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:34:01'!
             errorMessageForSourceCodeToExtractHasSyntaxError: anErrorDescription

	^'Can not extract a source code with syntax error: ', anErrorDescription ! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:26:23'!
                        errorMessageMethodNodeToRefactorDoesNotInclude: aSourceCodeToExtract

	^'The source code {', aSourceCodeToExtract, '} is not included in the method to refactor'! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/26/2017 16:24:10'!
        newVariableCanNotBeEmptyErrorMessage
	
	^'New variable can not be empty'! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:34:15'!
signalColaborationToExtractHasSyntaxError: aSyntaxErrorNotification 
	
	self refactoringError: (self errorMessageForSourceCodeToExtractHasSyntaxError: aSyntaxErrorNotification messageText)! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:32:50'!
            signalColaborationToExtractHasToBeOneStatement
	
	self refactoringError: self sourceCodeToExtractHasToBeOneStatementErrorMessage ! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/26/2017 16:27:51'!
       signalInvalidTemporaryVariable: aName

	^ self refactoringError: (self errorMessageForInvalidTemporaryVariable: aName).! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/27/2017 17:23:04'!
                 signalMethodNodeToRefactorDoesNotInclude: aColaborationToExtract

	^self refactoringError: (self errorMessageMethodNodeToRefactorDoesNotInclude: aColaborationToExtract)! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/26/2017 16:31:08'!
signalNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode

	self refactoringError: (self errorMessageForNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode )! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/26/2017 16:23:49'!
             signalNewVariableCanNotBeEmpty
	
	self refactoringError: self newVariableCanNotBeEmptyErrorMessage! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:20:49'!
      signalSourceCodeToExtractCanNotBeEmpty
	
	self refactoringError: self sourceCodeToExtractCanNotBeEmptyErrorMessage! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:24:37'!
                      signalSourceCodeToExtractCanNotIncludeReturn
	
	self refactoringError: self sourceCodeToExtractCanNotIncludeReturnErrorMessage ! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:20:21'!
         sourceCodeToExtractCanNotBeEmptyErrorMessage
	
	^'Source code to extract can not be empty'! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:24:02'!
              sourceCodeToExtractCanNotIncludeReturnErrorMessage
	
	^'A return can not be extracted'! !
!ExtractToTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/30/2017 06:32:22'!
                  sourceCodeToExtractHasToBeOneStatementErrorMessage
	
	^'Can not extract more than one statement'! !
!ExtractToTemporary class methodsFor: 'instance creation' stamp: 'HAW 9/11/2018 16:13:23'!
 named: aNewVariable at: anIntervalToExtract from: aMethodSourceCode in: aClass

	|  trimmedNewVariable parseNodeToExtract trimmedSourceCodeToExtract methodNodeToExtract methodNodeToRefactor sourceCodeToExtract |
	
	trimmedNewVariable := aNewVariable withBlanksTrimmed.
	methodNodeToRefactor := aClass methodNodeFor: aMethodSourceCode.
	
	self assertIsNotEmpty: trimmedNewVariable.
	self assertIsValidVariableName: trimmedNewVariable.
	self assert: trimmedNewVariable isNotDefinedIn: methodNodeToRefactor.
	
	sourceCodeToExtract := aMethodSourceCode copyFrom: anIntervalToExtract first to: anIntervalToExtract last.
	trimmedSourceCodeToExtract := sourceCodeToExtract withBlanksTrimmed.
	self assertSourceCodeIsNotEmpty: trimmedSourceCodeToExtract.
	self assertIsNotReturn: trimmedSourceCodeToExtract. 
	self assert: trimmedSourceCodeToExtract isIncludedIn: methodNodeToRefactor.

	[ methodNodeToExtract := Parser parse: trimmedSourceCodeToExtract class: methodNodeToRefactor methodClass noPattern: true ]
		on: SyntaxErrorNotification 
		do: [ :anError | self signalColaborationToExtractHasSyntaxError: anError ].
	
	parseNodeToExtract := self paseNodeToExtractFrom: methodNodeToExtract. 

	self warnIf: trimmedNewVariable isDefinedAsInstanceVariableInHierarchyOf: methodNodeToRefactor methodClass.

	^self new initializeNamed: trimmedNewVariable with: parseNodeToExtract in: methodNodeToRefactor
 
	! !
!ExtractToTemporary class methodsFor: 'instance creation' stamp: 'HAW 10/4/2017 17:41:59'!
          named: aNewVariable with: aSourceCodeToExtract in: aMethodNodeToRefactor

	|  trimmedNewVariable parseNodeToExtract trimmedSourceCodeToExtract methodNodeToExtract |
	
	trimmedNewVariable := aNewVariable withBlanksTrimmed.
	
	self assertIsNotEmpty: trimmedNewVariable.
	self assertIsValidVariableName: trimmedNewVariable.
	self assert: trimmedNewVariable isNotDefinedIn: aMethodNodeToRefactor.
	
	trimmedSourceCodeToExtract := aSourceCodeToExtract withBlanksTrimmed.
	self assertSourceCodeIsNotEmpty: trimmedSourceCodeToExtract.
	self assertIsNotReturn: trimmedSourceCodeToExtract. 
	self assert: trimmedSourceCodeToExtract isIncludedIn: aMethodNodeToRefactor.

	[ methodNodeToExtract := Parser parse: trimmedSourceCodeToExtract class: aMethodNodeToRefactor methodClass noPattern: true ]
		on: SyntaxErrorNotification 
		do: [ :anError | self signalColaborationToExtractHasSyntaxError: anError ].
	
	parseNodeToExtract := self paseNodeToExtractFrom: methodNodeToExtract. 

	self warnIf: trimmedNewVariable isDefinedAsInstanceVariableInHierarchyOf: aMethodNodeToRefactor methodClass.

	^self new initializeNamed: trimmedNewVariable with: parseNodeToExtract in: aMethodNodeToRefactor
 
	! !
!ExtractToTemporary class methodsFor: 'method node to extract' stamp: 'HAW 6/27/2017 17:58:04'!
                            paseNodeToExtractFrom: aMethodNodeToExtract

	self assertIsOneStatement: aMethodNodeToExtract. 
	
	^aMethodNodeToExtract block statements first expr.
	! !
!ExtractToTemporary class methodsFor: 'warnings' stamp: 'HAW 6/26/2017 16:34:44'!
                   warn: aNewVariable willHideInstanceVariableDefinedIn: aClass 

	self refactoringWarning: (self warningMessageFor: aNewVariable willHideInstanceVariableDefinedIn: aClass)! !
!ExtractToTemporary class methodsFor: 'warnings' stamp: 'HAW 6/26/2017 16:35:04'!
 warningMessageFor: aNewVariable willHideInstanceVariableDefinedIn: aClass

	^aNewVariable, ' will hide instance variable defined in ', aClass name! !
!InsertSuperclass methodsFor: 'applying' stamp: 'HAW 8/13/2018 18:31:33'!
apply

	| newSuperclass |
	
	newSuperclass := self createSuperclass.
	self changeSuperclassOf: classToRefactor to: newSuperclass.

	^newSuperclass ! !
!InsertSuperclass methodsFor: 'applying - private' stamp: 'HAW 8/13/2018 18:31:43'!
                     changeSuperclassOf: classToRefactor to: newSuperclass
	
	newSuperclass subclass: classToRefactor name
		instanceVariableNames: classToRefactor instanceVariablesString 
		classVariableNames: classToRefactor classVariablesString 
		poolDictionaries: classToRefactor sharedPoolsString
		category: classToRefactor category.! !
!InsertSuperclass methodsFor: 'applying - private' stamp: 'HAW 8/13/2018 18:31:06'!
         createSuperclass
	
	^classToRefactor superclass subclass: superclassName
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: classToRefactor category.! !
!InsertSuperclass methodsFor: 'initialization' stamp: 'HAW 8/13/2018 17:36:34'!
                  initializeTo: aClass named: aSuperclassName 

	classToRefactor := aClass.
	superclassName := aSuperclassName.! !
!InsertSuperclass class methodsFor: 'instance creation' stamp: 'HAW 3/3/2019 09:11:36'!
                       newClassPreconditionClass

	^NewClassPrecondition ! !
!InsertSuperclass class methodsFor: 'instance creation' stamp: 'HAW 8/13/2018 17:34:37'!
                 to: aClass named: aSuperclassName
	
	^self to: aClass named: aSuperclassName in: Smalltalk undeclared: Undeclared! !
!InsertSuperclass class methodsFor: 'instance creation' stamp: 'HAW 3/3/2019 09:11:31'!
                   to: aClass named: aSuperclassName in: aSystem undeclared: anUndeclared

	self newClassPreconditionClass valueFor: aSuperclassName in: aSystem undeclared: anUndeclared.
	
	^self new initializeTo: aClass theNonMetaClass named: aSuperclassName ! !
!PushUpMethod methodsFor: 'initialization' stamp: 'HAW 8/18/2018 11:44:09'!
                               initializeFor: aMethodToPushup

	method := aMethodToPushup ! !
!PushUpMethod methodsFor: 'applying' stamp: 'HAW 3/4/2019 15:23:40'!
                            apply

	| methodCategory |
	
	methodCategory := method methodClass organization categoryOfElement: method selector.
	method methodClass superclass
		compile: method sourceCode 
		classified: methodCategory.
		
	method methodClass removeSelector: method selector.
 ! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'HAW 8/18/2018 11:43:53'!
                               for: aMethodToPushUp

	^self new initializeFor: aMethodToPushUp ! !
!RemoveAllUnreferencedInstanceVariables methodsFor: 'initialization' stamp: 'HAW 8/2/2018 16:14:57'!
                       initializeFrom: aClassToRefactor

	classToRefactor := aClassToRefactor ! !
!RemoveAllUnreferencedInstanceVariables methodsFor: 'applying' stamp: 'HAW 8/2/2018 16:05:05'!
                      apply
	
	| variableNamesToRemove |
	
	variableNamesToRemove := classToRefactor unreferencedInstanceVariables.
	variableNamesToRemove do: [ :aVariableName | classToRefactor removeInstVarName: aVariableName ].
	
	^variableNamesToRemove! !
!RemoveAllUnreferencedInstanceVariables class methodsFor: 'instance creation' stamp: 'HAW 8/2/2018 16:14:45'!
     from: aClassToRefactor

	^self new initializeFrom: aClassToRefactor ! !
!RemoveInstanceVariable methodsFor: 'applying' stamp: 'HAW 6/17/2017 19:46:45'!
        apply
	
	classToRefactor removeInstVarName: variableToRemove ! !
!RemoveInstanceVariable methodsFor: 'initialization' stamp: 'HAW 6/17/2017 19:45:18'!
         initializeNamed: aVariable from: aClassToRefactor 

	variableToRemove := aVariable.
	classToRefactor := aClassToRefactor ! !
!RemoveInstanceVariable class methodsFor: 'pre-conditions' stamp: 'HAW 6/12/2017 19:11:50'!
       assert: aClass defines: anInstanceVariable

	(aClass definesInstanceVariableNamed: anInstanceVariable) ifFalse: [ self signalInstanceVariable: anInstanceVariable notDefinedIn: aClass ].! !
!RemoveInstanceVariable class methodsFor: 'pre-conditions' stamp: 'HAW 8/1/2018 19:36:10'!
        assert: aVaraible isNotReferencedInHierarchyOf: aClassToRefactor

	| references |
	
	references := OrderedCollection new.
	aClassToRefactor withAllSubclassesDo: [ :aClass | 
		(aClass whichSelectorsAccess: aVaraible) do: [ :aSelector | references add: (MethodReference class: aClass selector: aSelector) ]].
	
	references notEmpty ifTrue: [ self signalInstanceVariable: aVaraible isReferencedInAll: references ]! !
!RemoveInstanceVariable class methodsFor: 'exceptions' stamp: 'HAW 8/1/2018 19:38:57'!
          errorMessageForInstanceVariable: aVariable isReferencedInAll: methods

	^aVariable, ' can not be removed because it has references'.
		! !
!RemoveInstanceVariable class methodsFor: 'exceptions' stamp: 'HAW 6/12/2017 19:12:41'!
                             errorMessageForInstanceVariable: aName notDefinedIn: aClass

	^ 'Instance variable ''' , aName , ''' is not defined in ' , aClass name.! !
!RemoveInstanceVariable class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 16:34:16'!
                             signalInstanceVariable: aVariable isReferencedInAll: methods

	self 
		canNotRefactorDueToReferencesError: (self errorMessageForInstanceVariable: aVariable isReferencedInAll: methods)
		 references: methods
		 to: aVariable! !
!RemoveInstanceVariable class methodsFor: 'exceptions' stamp: 'HAW 6/12/2017 19:12:12'!
     signalInstanceVariable: aName notDefinedIn: aClass

	^ self refactoringError: (self errorMessageForInstanceVariable: aName notDefinedIn: aClass).! !
!RemoveInstanceVariable class methodsFor: 'instance creation' stamp: 'HAW 6/17/2017 19:44:39'!
            named: aVariable from: aClassToRefactor 
	
	self assert: aClassToRefactor defines: aVariable.
	self assert: aVariable isNotReferencedInHierarchyOf: aClassToRefactor.
	
	^self new initializeNamed: aVariable from: aClassToRefactor 
! !
!RenameClass methodsFor: 'applying' stamp: 'HAW 6/4/2017 18:09:21'!
                  apply
	
	classToRename safeRenameTo: newClassName.
	^self renameReferences.
	
	! !
!RenameClass methodsFor: 'initialization' stamp: 'HAW 8/9/2018 15:40:00'!
   initializeFrom: aClass to: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	classToRename := aClass.
	classToRenameOriginalName := aClass name.
	newClassName := aNewClassName.
	system := aSystem.
	undeclared := anUndeclaredDictionary.
	
	! !
!RenameClass methodsFor: 'accessing' stamp: 'HAW 6/4/2017 18:16:33'!
                          newClassName
	
	^newClassName ! !
!RenameClass methodsFor: 'accessing' stamp: 'HAW 6/4/2017 18:24:56'!
                         referencesToOldClass
	
	^system allCallsOn: newClassName! !
!RenameClass methodsFor: 'accessing' stamp: 'HAW 6/4/2017 18:25:56'!
                               referencesToOldClassName
	
	^system allCallsOn: classToRenameOriginalName! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/13/2018 15:27:46'!
    newSourceCodeOf: aCompiledMethod 
	
	| newSource |
	
	newSource := aCompiledMethod sourceCode copyReplacing: (self rangesToReplaceOf: aCompiledMethod) with: newClassName.

	^newSource! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 9/3/2018 19:48:30'!
                       rangesForLiteralOf: methodNode
	
	| literalRanges |
	
	literalRanges := methodNode positionsForLiteralNode: classToRenameOriginalName ifAbsent: [ #() ].
	literalRanges := literalRanges collect: [ :aRange | aRange first + 1 to: aRange last ].
	
	^literalRanges ! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 9/3/2018 19:48:49'!
          rangesForLiteralVariableOf: methodNode
	
	^methodNode positionsForLiteralVariableNode: classToRenameOriginalName ifAbsent: [ #() ]
	! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/13/2018 15:20:40'!
         rangesToReplaceOf: aCompiledMethod 
	
	| methodNode ranges |
	
	methodNode := aCompiledMethod methodNode.
	ranges := SortedCollection sortBlock: [ :leftRange :rightRange | leftRange first < rightRange first ].
	
	ranges addAll: (self rangesForLiteralVariableOf: methodNode).
	ranges addAll: (self rangesForLiteralOf: methodNode).
	
	^ranges ! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/9/2018 14:50:34'!
                         references: aMethodReference classVarNamed: aName

	^aMethodReference actualClass definesClassVariableNamedInHierarchy: aName ! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/9/2018 14:50:52'!
                referencesNewClassName: aMethodReference

	^self references: aMethodReference classVarNamed: newClassName ! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/9/2018 14:51:07'!
    referencesOldClassName: aMethodReference

	^self references: aMethodReference classVarNamed: classToRenameOriginalName! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/9/2018 14:49:43'!
                        rejectReferencesToClassVariablesFrom: references
	
	^references reject: [ :aMethodReference | (self referencesOldClassName: aMethodReference) or: [ self referencesNewClassName: aMethodReference ] ].! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/13/2018 15:18:43'!
       renameReference: aReferencingMethod 
	
	| newSource |
	
	newSource := self newSourceCodeOf: aReferencingMethod.
	aReferencingMethod methodClass compile: newSource ! !
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 8/13/2018 15:17:56'!
          renameReferences
	
	| references |
	
	references := (self referencesToOldClass asSet, self referencesToOldClassName asSet) asOrderedCollection.
	references := self rejectReferencesToClassVariablesFrom: references.
	references do: [ :aReference | self renameReference: aReference compiledMethod ].
	
	^references! !
!RenameClass class methodsFor: 'pre-conditions' stamp: 'HAW 6/1/2017 19:06:21'!
                     assert: aClass isNotNamed: aNewName

	aClass name = aNewName ifTrue: [ self signalNewNameEqualsOldName]! !
!RenameClass class methodsFor: 'pre-conditions' stamp: 'HAW 6/4/2017 18:49:54'!
     assertIsNotMeta: aBehavior

	aBehavior isMeta ifTrue: [ self signalClassToRenameCanNotBeMetaclass]! !
!RenameClass class methodsFor: 'pre-conditions' stamp: 'HAW 8/13/2018 18:45:26'!
         newClassPreconditionClass

	^NewClassPrecondition ! !
!RenameClass class methodsFor: 'exceptions' stamp: 'HAW 6/4/2017 18:50:36'!
                              classToRenameCanNotBeMetaclassErrorMessage
	
	^'Class to rename can not be a metaclass'! !
!RenameClass class methodsFor: 'exceptions' stamp: 'HAW 6/1/2017 19:07:08'!
                         newNameEqualsOldNameErrorMessage
	
	^'New class name equals old one'! !
!RenameClass class methodsFor: 'exceptions' stamp: 'HAW 6/4/2017 18:50:56'!
            signalClassToRenameCanNotBeMetaclass
	
	self refactoringError: self classToRenameCanNotBeMetaclassErrorMessage! !
!RenameClass class methodsFor: 'exceptions' stamp: 'HAW 8/13/2018 18:39:00'!
 signalNewNameEqualsOldName

	self refactoringError: self newNameEqualsOldNameErrorMessage.! !
!RenameClass class methodsFor: 'instance creation' stamp: 'HAW 6/2/2017 11:43:48'!
               from: aClass to: aNewClassName

	^self from: aClass to: aNewClassName in: Smalltalk
	! !
!RenameClass class methodsFor: 'instance creation' stamp: 'HAW 6/2/2017 11:55:32'!
                    from: aClass to: aNewClassName in: aSystem

	^self from: aClass to: aNewClassName in: aSystem undeclared: Undeclared 
	
	! !
!RenameClass class methodsFor: 'instance creation' stamp: 'HAW 8/13/2018 18:45:15'!
               from: aClass to: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	self assertIsNotMeta: aClass.
	self assert: aClass isNotNamed: aNewClassName.
	self newClassPreconditionClass valueFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary.
	
	^self new initializeFrom: aClass to: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 
! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'HAW 6/11/2017 19:06:35'!
                     addNewInstanceVariable

	addInstanceVariable apply! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'HAW 6/11/2017 19:07:49'!
                copyOldInstanceVariableToNewOne

	| oldVariableIndex newVariableIndex |
	
	oldVariableIndex := self classToRefactor indexOfInstanceVariable: oldVariable.	
	newVariableIndex := self classToRefactor indexOfInstanceVariable: self newVariable.
	self classToRefactor allSubInstancesDo: [ :anInstance | anInstance instVarAt: newVariableIndex put: (anInstance instVarAt: oldVariableIndex) ].
	
! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'HAW 9/3/2018 19:48:09'!
newSourceOf: aCompiledMethod 
	
	| newSource ranges |
	
	ranges := aCompiledMethod methodNode positionsForInstanceVariable: oldVariable ifAbsent: [ #() ].
	newSource := aCompiledMethod sourceCode copyReplacing: ranges with: self newVariable.
	
	^newSource
	! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'HAW 6/11/2017 19:07:20'!
 removeOldInstanceVariable

	self classToRefactor removeInstVarName: oldVariable.! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'HAW 6/11/2017 19:07:10'!
                  renameReferencesToOldVariable
	
	renamedReferences := OrderedCollection new.
	self classToRefactor withAllSubclassesDo: [ :aClass | self renameReferencesToOldVariableInClass: aClass ]! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'HAW 6/17/2017 19:17:33'!
           renameReferencesToOldVariableInClass: aClass 

	| referencingMethodNames |
	
	referencingMethodNames := aClass whichSelectorsAccess: oldVariable.
	referencingMethodNames do: [ :referencingMethodName | self renameReferencesToOldVariableInMethod: (aClass compiledMethodAt: referencingMethodName) ]
	! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'HAW 8/13/2018 14:53:56'!
                         renameReferencesToOldVariableInMethod: aCompiledMethod 
	
	aCompiledMethod methodClass compile: (self newSourceOf: aCompiledMethod).
	renamedReferences add: aCompiledMethod methodReference ! !
!RenameInstanceVariable methodsFor: 'applying' stamp: 'HAW 6/5/2017 16:53:57'!
                apply

	self 
		addNewInstanceVariable;
		copyOldInstanceVariableToNewOne;
		renameReferencesToOldVariable;
		removeOldInstanceVariable.
		
	^renamedReferences 
		! !
!RenameInstanceVariable methodsFor: 'accessing' stamp: 'HAW 6/11/2017 19:09:35'!
        classToRefactor

	^addInstanceVariable classToRefactor! !
!RenameInstanceVariable methodsFor: 'accessing' stamp: 'HAW 6/11/2017 19:07:37'!
                     newVariable

	^ addInstanceVariable newVariable! !
!RenameInstanceVariable methodsFor: 'initialization' stamp: 'HAW 8/9/2018 17:20:55'!
                        initializeFrom: anOldvariable addingWith: anAddInstanceVariable 

	oldVariable := anOldvariable.
	addInstanceVariable := anAddInstanceVariable.
! !
!RenameInstanceVariable class methodsFor: 'pre-conditions' stamp: 'HAW 5/24/2017 21:49:18'!
                assert: aClass defines: anInstanceVariable

	(aClass definesInstanceVariableNamed: anInstanceVariable) ifFalse: [ self signalInstanceVariable: anInstanceVariable notDefinedIn: aClass ].! !
!RenameInstanceVariable class methodsFor: 'exceptions' stamp: 'HAW 5/24/2017 21:56:02'!
           errorMessageForInstanceVariable: aName notDefinedIn: aClass

	^ 'Instance variable ''' , aName , ''' is not defined in ' , aClass name.! !
!RenameInstanceVariable class methodsFor: 'exceptions' stamp: 'HAW 6/3/2017 11:54:22'!
                              signalInstanceVariable: aName notDefinedIn: aClass

	^ self refactoringError: (self errorMessageForInstanceVariable: aName notDefinedIn: aClass).! !
!RenameInstanceVariable class methodsFor: 'instance creation' stamp: 'HAW 6/11/2017 19:04:59'!
            from: anOldvariable to: aNewVariable in: aClassToRefactor 
	
	| addInstanceVariable |
	
	self assert: aClassToRefactor defines: anOldvariable.
	addInstanceVariable := AddInstanceVariable named: aNewVariable to: aClassToRefactor.
	
	^self new initializeFrom: anOldvariable addingWith: addInstanceVariable ! !
!RenameTemporary methodsFor: 'applying' stamp: 'HAW 9/3/2018 19:49:06'!
    apply
	
	| newSource ranges |
	
	ranges := methodNode positionsForTemporaryVariable: oldVariable ifAbsent: [ #() ].
	newSource := methodNode sourceText copyReplacing: ranges with: newVariable.
	
	^ newSource! !
!RenameTemporary methodsFor: 'applying' stamp: 'HAW 8/9/2018 19:34:51'!
     methodNodeAfterApply
	
	^methodNode methodClass methodNodeFor: self apply.
	
	! !
!RenameTemporary methodsFor: 'initialization' stamp: 'HAW 6/25/2017 21:53:31'!
                               initializeFrom: anOldVariable to: aNewVariable in: aMethodNode 
	
	oldVariable := anOldVariable.
	newVariable := aNewVariable.
	methodNode := aMethodNode ! !
!RenameTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/25/2017 21:53:31'!
             assert: aVariable isDefinedIn: aMethodNode 
	
	(aMethodNode tempNames includes: aVariable) ifFalse: [ self signalTemporaryVariable: aVariable notDefinedIn: aMethodNode ]! !
!RenameTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/25/2017 21:53:31'!
                              assert: aNewVariable isNotDefinedIn: aMethodNode 
	
	(aMethodNode tempNames includes: aNewVariable) ifTrue: [ self signalNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode ]
	! !
!RenameTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/25/2017 21:53:31'!
        assertIsNotEmpty: aNewVariable

	aNewVariable isEmpty ifTrue: [ self signalNewVariableCanNotBeEmpty ]! !
!RenameTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/25/2017 21:53:31'!
  assertIsValidVariableName: aName

	| scannedNames |

	scannedNames _ Scanner new scanFieldNames: aName.
	scannedNames size = 1 ifFalse: [ self signalInvalidTemporaryVariable: aName ].
	scannedNames first = aName ifFalse: [ self signalInvalidTemporaryVariable: aName ].! !
!RenameTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 6/25/2017 21:53:31'!
                           warnIf: aNewVariable isDefinedAsInstanceVariableInHierarchyOf: aClass 
	
	| classDefiningNewVariable |
	
	classDefiningNewVariable := aClass whichClassDefinesInstanceVariable: aNewVariable ifNone: [ ^self ].
	self warn: aNewVariable willHideInstanceVariableDefinedIn: classDefiningNewVariable ! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/25/2017 21:53:31'!
      errorMessageForInvalidTemporaryVariable: aName

	^ '''' , aName , ''' is not a valid temporary variable name'.! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/25/2017 21:53:31'!
                             errorMessageForNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode

	^aNewVariable, ' is already defined in ', aMethodNode classAndSelector ! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 10/4/2017 17:04:37'!
                errorMessageForTemporaryVariable: aVariable notDefinedIn: aMethodNode

	^'Temporary variable ', aVariable, ' is not defined in ', aMethodNode classAndSelector ! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/25/2017 21:53:31'!
            newVariableCanNotBeEmptyErrorMessage
	
	^'New variable can not be empty'! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/25/2017 21:53:31'!
   signalInvalidTemporaryVariable: aName

	^ self refactoringError: (self errorMessageForInvalidTemporaryVariable: aName).! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/25/2017 21:53:31'!
                    signalNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode

	self refactoringError: (self errorMessageForNewTemporaryVariable: aNewVariable isAlreadyDefinedIn: aMethodNode )! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 6/25/2017 21:53:31'!
                signalNewVariableCanNotBeEmpty
	
	self refactoringError: self newVariableCanNotBeEmptyErrorMessage! !
!RenameTemporary class methodsFor: 'exceptions' stamp: 'HAW 10/4/2017 17:04:27'!
         signalTemporaryVariable: aVariable notDefinedIn: aMethodNode

	self refactoringError: (self errorMessageForTemporaryVariable: aVariable notDefinedIn: aMethodNode)! !
!RenameTemporary class methodsFor: 'instance creation' stamp: 'HAW 6/25/2017 21:53:31'!
  from: anOldVariable to: aNewVariable in: aMethodNode

	|  trimmedNewVariable |
	
	trimmedNewVariable := aNewVariable withBlanksTrimmed.
	
	self assert: anOldVariable isDefinedIn: aMethodNode.
	self assertIsNotEmpty: trimmedNewVariable.
	self assertIsValidVariableName: trimmedNewVariable.
	self assert: trimmedNewVariable isNotDefinedIn: aMethodNode.
	
	self warnIf: trimmedNewVariable isDefinedAsInstanceVariableInHierarchyOf: aMethodNode methodClass.
	
	^self new initializeFrom: anOldVariable to: trimmedNewVariable in: aMethodNode
! !
!RenameTemporary class methodsFor: 'warnings' stamp: 'HAW 6/25/2017 21:53:31'!
                      warn: aNewVariable willHideInstanceVariableDefinedIn: aClass 

	self refactoringWarning: (self warningMessageFor: aNewVariable willHideInstanceVariableDefinedIn: aClass)! !
!RenameTemporary class methodsFor: 'warnings' stamp: 'HAW 6/25/2017 21:53:31'!
    warningMessageFor: aNewVariable willHideInstanceVariableDefinedIn: aClass

	^aNewVariable, ' will hide instance variable defined in ', aClass name! !
!SafelyRemoveClass methodsFor: 'applying' stamp: 'HAW 8/1/2018 16:42:17'!
apply
	
	self removeWithAllSubclasses: classToRemove.
	! !
!SafelyRemoveClass methodsFor: 'applying - private' stamp: 'HAW 8/1/2018 16:42:17'!
                 removeWithAllSubclasses: aClassToRemove

	"I have to do 'subclasses do:' and not 'subclassesDo:' because removing a class modifies parent's subclasses collection.
	#subclasses returns a copy of superclass' subclasses collection -Hernan"
	aClassToRemove subclasses do: [ :aSubclassToRemove | self removeWithAllSubclasses: aSubclassToRemove ].
	aClassToRemove removeFromSystem.
	! !
!SafelyRemoveClass methodsFor: 'initialization' stamp: 'HAW 8/1/2018 16:42:17'!
                   initializeOf: aClassToSafetelyRemove 
	
	classToRemove := aClassToSafetelyRemove ! !
!SafelyRemoveClass class methodsFor: 'instance creation' stamp: 'HAW 8/1/2018 16:42:17'!
                  of: aClassToSafelyRemove

	| theNonMetaclassToRemove |
	
	theNonMetaclassToRemove := aClassToSafelyRemove theNonMetaClass.	
	self assertNoReferencesTo: theNonMetaclassToRemove.	
	self warnIfHasSubclasses: theNonMetaclassToRemove.
	
	^self new initializeOf: theNonMetaclassToRemove ! !
!SafelyRemoveClass class methodsFor: 'pre-conditions' stamp: 'HAW 8/1/2018 16:42:17'!
             assertNoReferencesTo: aClassToSafelyRemove

	| references withAllSubclasses withAllSubclassesNames referenced |
	
	withAllSubclasses := aClassToSafelyRemove withAllSubclasses.
	withAllSubclassesNames := withAllSubclasses collect: [:aClass | aClass name ].
	references :=OrderedCollection new.
	referenced := OrderedCollection new.
	
	withAllSubclasses do: [ :aClass | | allReferences referencesOutsideHierarchy |
		allReferences := aClass allCallsOn.
		referencesOutsideHierarchy := allReferences reject: [ :aReference | withAllSubclassesNames includes: aReference classSymbol ].
		referencesOutsideHierarchy notEmpty ifTrue: [
			referenced add: aClass.
			references addAll: referencesOutsideHierarchy ]].
		
	references notEmpty ifTrue: [ self signalCanNotRemove: aClassToSafelyRemove dueToReferences: references toAll: referenced ]! !
!SafelyRemoveClass class methodsFor: 'pre-conditions' stamp: 'HAW 8/1/2018 16:42:17'!
   warnIfHasSubclasses: aClassToSafelyRemove

	| allSubclasses |
	
	allSubclasses := aClassToSafelyRemove allSubclasses.
	allSubclasses isEmpty ifFalse: [ self warn: aClassToSafelyRemove hasSubclasses: allSubclasses ]! !
!SafelyRemoveClass class methodsFor: 'exceptions' stamp: 'HAW 8/1/2018 18:10:36'!
                    errorMessageForCanNotRemove: aClassToSafelyRemove dueToReferencesToAll: referenced

	^String streamContents: [ :stream |
		stream 
			nextPutAll: aClassToSafelyRemove name asString;
			nextPutAll: ' can not be removed '.
	
		referenced size = 1 
			ifTrue: [ (referenced includes: aClassToSafelyRemove) 
				ifTrue: [ stream nextPutAll: 'because it has references' ]
				ifFalse: [ stream 
					nextPutAll: 'because it subclass, ';
					nextPutAll: referenced anyOne name asString;
					nextPutAll: ', has references' ]]
			ifFalse: [ (referenced includes: aClassToSafelyRemove)
				ifTrue: [ stream 
					nextPutAll: 'due to references to: ';
					nextPutAll: referenced asCommaStringAnd ]
				ifFalse: [ stream
					nextPutAll: 'due to references to its subclasses: ';
					nextPutAll: referenced asCommaStringAnd ]]]! !
!SafelyRemoveClass class methodsFor: 'exceptions' stamp: 'HAW 8/17/2018 16:34:16'!
                      signalCanNotRemove: aClassToSafelyRemove dueToReferences: references toAll: allReferenced

	self 
		canNotRefactorDueToReferencesError: (self errorMessageForCanNotRemove: aClassToSafelyRemove dueToReferencesToAll: allReferenced)
		references: references 
		to: aClassToSafelyRemove 
	! !
!SafelyRemoveClass class methodsFor: 'warnings' stamp: 'HAW 8/1/2018 16:42:17'!
                warn: aClassToSafelyRemove hasSubclasses: allSubclasses

	self refactoringWarning: (self warningMessageFor: aClassToSafelyRemove hasSubclasses: allSubclasses)! !
!SafelyRemoveClass class methodsFor: 'warnings' stamp: 'HAW 8/1/2018 18:24:31'!
              warningMessageFor: aClassToSafelyRemove hasSubclasses: allSubclasses

	^String streamContents: [ :stream |
		stream nextPutAll: aClassToSafelyRemove name asString.
		allSubclasses size = 1
			ifTrue: [ stream nextPutAll: ' has a subclass' ]
			ifFalse: [ stream 
					nextPutAll: ' has ';
					print:  allSubclasses size;
					nextPutAll: ' subclasses' ].
		stream nextPutAll: ' that will be removed'].
		
	! !
!RefactoringApplier methodsFor: 'refactoring - applying' stamp: 'HAW 6/5/2017 18:06:39'!
            applyRefactoring

	changes := refactoring apply! !
!RefactoringApplier methodsFor: 'refactoring - creation' stamp: 'HAW 6/5/2017 18:05:46'!
                    createRefactoring

	self subclassResponsibility ! !
!RefactoringApplier methodsFor: 'refactoring - creation' stamp: 'HAW 6/5/2017 18:05:20'!
                   createRefactoringHandlingRefactoringExceptions

	self valueHandlingRefactoringExceptions: [ refactoring := self createRefactoring ]
	! !
!RefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 14:24:04'!
                    endRequest

	^requestExitBlock value! !
!RefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 19:04:16'!
                     requestRefactoringParameters

	self subclassResponsibility ! !
!RefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 19:05:35'!
                              requestRefactoringParametersHandlingRefactoringExceptions

	self valueHandlingRefactoringExceptions: [ self requestRefactoringParameters ]
	! !
!RefactoringApplier methodsFor: 'exception handling' stamp: 'HAW 8/17/2018 16:37:38'!
                          browseReferencesOn: aCanNotRefactorDueToReferencesError
	
	Smalltalk 
		browseMessageList: aCanNotRefactorDueToReferencesError references 
		name: (self referencesBrowserTitleOn: aCanNotRefactorDueToReferencesError)
		autoSelect: true
! !
!RefactoringApplier methodsFor: 'exception handling' stamp: 'HAW 8/17/2018 16:37:55'!
                           handleCanNotRefactorDueToReferencesError: aCanNotRefactorDueToReferencesError
	
	| options answer question |
	
	options := 
'Browse references
Cancel'.

	question := PopUpMenu labels: options icons: #(mailForwardIcon cancelIcon).
	answer := question startUpWithCaption: aCanNotRefactorDueToReferencesError messageText.
	
	answer = 1 ifTrue: [ self browseReferencesOn: aCanNotRefactorDueToReferencesError ].
	self endRequest.! !
!RefactoringApplier methodsFor: 'exception handling' stamp: 'HAW 6/5/2017 18:47:40'!
                               handleRefactoringError: aRefactoringError 

	self inform: aRefactoringError messageText.
	self endRequest ! !
!RefactoringApplier methodsFor: 'exception handling' stamp: 'HAW 8/1/2018 18:15:21'!
                             handleRefactoringWarning: aRefactoringWarning
	
	(self confirm: aRefactoringWarning messageText, '. Continue?')
		ifTrue: [ aRefactoringWarning resume ]
		ifFalse: [ self endRequest]! !
!RefactoringApplier methodsFor: 'exception handling' stamp: 'HAW 8/17/2018 16:38:07'!
                referencesBrowserTitleOn: aCanNotRefactorDueToReferencesError

	^'References to ', aCanNotRefactorDueToReferencesError referencee asString! !
!RefactoringApplier methodsFor: 'exception handling' stamp: 'HAW 8/17/2018 16:35:47'!
                            valueHandlingRefactoringExceptions: aBlock

	^[[aBlock
		on: Refactoring refactoringWarningClass 
		do: [ :aRefactoringWarning | self handleRefactoringWarning: aRefactoringWarning ]]
		on: Refactoring canNotRefactorDueToReferencesErrorClass
		do: [ :aCanNotRefactorDueToReferencesError | self handleCanNotRefactorDueToReferencesError: aCanNotRefactorDueToReferencesError ]]
		on: Refactoring refactoringErrorClass 
		do: [ :aRefactoringError | self handleRefactoringError: aRefactoringError ]
	! !
!RefactoringApplier methodsFor: 'request information' stamp: 'HAW 6/11/2017 19:22:50'!
                       request: aLabel
 
	^self request: aLabel initialAnswer: ''
! !
!RefactoringApplier methodsFor: 'request information' stamp: 'HAW 6/5/2017 16:03:04'!
           request: aLabel initialAnswer: anAnswer

	^self request: aLabel initialAnswer: anAnswer onCancel: requestExitBlock ! !
!RefactoringApplier methodsFor: 'request information' stamp: 'HAW 6/5/2017 16:03:30'!
                   request: aLabel initialAnswer: anAnswer onCancel: cancelBlock

	^FillInTheBlankMorph request: aLabel initialAnswer: anAnswer onCancel: cancelBlock ! !
!RefactoringApplier methodsFor: 'refactoring - changes' stamp: 'HAW 6/5/2017 18:06:53'!
                 showChanges

	self subclassResponsibility 	
	! !
!RefactoringApplier methodsFor: 'evaluating' stamp: 'HAW 6/5/2017 19:05:50'!
  value

	requestExitBlock := [ ^self ].
	
	self 
		requestRefactoringParametersHandlingRefactoringExceptions;
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		showChanges
	
	! !
!RefactoringApplier class methodsFor: 'value handling exceptions' stamp: 'HAW 1/7/2019 15:28:18'!
                      createAndValueHandlingExceptions: creationBlock

	| refactoring |
	
	refactoring := creationBlock 
		on: Refactoring refactoringErrorClass 
		do: [ :refactoringError | ^self inform: refactoringError messageText ].

	refactoring value ! !
!AddInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/30/2017 18:12:33'!
      askNewVariableName
		
	newInstanceVariable := self request: self newVariableNameLabel. 
	newInstanceVariable := newInstanceVariable withBlanksTrimmed ! !
!AddInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/30/2017 18:12:47'!
                          newVariableNameLabel
	
	^'Enter new variable name:'! !
!AddInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/11/2017 19:18:00'!
                             requestRefactoringParameters

	self askNewVariableName! !
!AddInstanceVariableApplier methodsFor: 'refactoring - creation' stamp: 'HAW 6/11/2017 19:19:25'!
    createRefactoring
		
	^AddInstanceVariable named: newInstanceVariable to: classToRefactor.
	! !
!AddInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 1/7/2019 14:41:01'!
informChangesToBrowser
		
	browser acceptedContentsChanged! !
!AddInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 6/11/2017 19:20:03'!
 showChanges

	self informChangesToBrowser! !
!AddInstanceVariableApplier methodsFor: 'initialization' stamp: 'HAW 1/7/2019 14:40:44'!
                          initializeOn: aBrowser for: aClassToRefactor 
	
	browser := aBrowser.
	classToRefactor := aClassToRefactor ! !
!AddInstanceVariableApplier class methodsFor: 'instance creation' stamp: 'HAW 1/7/2019 14:40:37'!
               on: aBrowser for: aClassToRefactor
	
	^self new initializeOn: aBrowser for: aClassToRefactor 
! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/3/2019 07:57:24'!
                        askForImplementosAndSenders

	self 
		askScope;
		calculateImplementorsAndSenders;
		startWizard ! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:21:12'!
                    askScope

	| scopeMenu |
	
	scopeMenu := PopUpMenu labelArray: self scopeOptionLabels.
	scopeChoice := scopeMenu startUpWithCaption: 'Select Refactoring Scope'.
	scopeChoice = 0 ifTrue: [ self endRequest ].
	! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 12/13/2018 17:41:06'!
    calculateImplementorsAndSenders
		
	implementors := IdentitySet new.
	senders := IdentitySet new.
	
	scopeChoice = 1 ifTrue: [ ^self implementorsAndSendersForClass ].
	scopeChoice = 2 ifTrue: [ ^self implementorsAndSendersForHierarchy ].
	scopeChoice = 3 ifTrue: [ ^self implementorsAndSendersInCategory ].
	scopeChoice = 4 ifTrue: [ ^self implementorsAndSendersInCategoryAndHierarchy ].
	scopeChoice = 5 ifTrue: [ ^self implementorsAndSendersInSystem ].
	
	self error: 'Unknown scope option' 
		
		! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:00:51'!
  implementorsAndSendersForClass

	^self refactoringClass addImplementorsOf: oldSelector to: implementors andSendersTo: senders forClassAndMetaOf: implementingClass! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:00:56'!
                   implementorsAndSendersForHierarchy 
		
	^self refactoringClass addImplementorsOf: oldSelector to: implementors andSendersTo: senders inHierarchyOf: implementingClass! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:01:01'!
                implementorsAndSendersInCategory 

	^self refactoringClass 
		addImplementorsOf: oldSelector 
		to: implementors 
		andSendersTo: senders 
		inCategory: implementingClass category 
		organizedBy: SystemOrganization! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:01:05'!
                               implementorsAndSendersInCategoryAndHierarchy 

	^self refactoringClass 
		addImplementorsOf: oldSelector 
		to: implementors 
		andSendersTo: senders 
		inCategoriesAndHierarchyOf: implementingClass 
		organizedBy: SystemOrganization ! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:01:15'!
           implementorsAndSendersInSystem
		
	^self refactoringClass addImplementorsOf: oldSelector to: implementors andSendersTo: senders inSystem: Smalltalk ! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 12/13/2018 17:41:33'!
scopeOptionLabels
	
	^{'In Class'. 'In Hierarchy'. 'In Category'. 'In Hierarchy and its Categories'. 'In System'}.! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/7/2019 11:17:34'!
    startWizard
		
	ChangeSelectorImplementorsStepWindow openFrom: self! !
!ChangeSelectorApplier methodsFor: 'accessing' stamp: 'HAW 8/18/2018 17:02:26'!
         implementors
	
	^implementors ! !
!ChangeSelectorApplier methodsFor: 'accessing' stamp: 'HAW 8/18/2018 17:02:29'!
              implementors: implementorsCollection

	implementors := implementorsCollection ! !
!ChangeSelectorApplier methodsFor: 'accessing' stamp: 'HAW 8/18/2018 17:02:33'!
                              oldSelector
	
	^oldSelector ! !
!ChangeSelectorApplier methodsFor: 'accessing' stamp: 'HAW 8/18/2018 17:02:37'!
                senders
	
	^senders ! !
!ChangeSelectorApplier methodsFor: 'accessing' stamp: 'HAW 8/18/2018 17:02:41'!
                        senders: sendersCollection
 
	senders := sendersCollection ! !
!ChangeSelectorApplier methodsFor: 'accessing' stamp: 'HAW 1/7/2019 11:16:36'!
                  wizardStepWindow: aWizarStepWindow 
	
	wizardStepWindow := aWizarStepWindow ! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'HAW 1/7/2019 11:08:33'!
                     closeBrowser
	
	wizardStepWindow delete.
	! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'HAW 10/10/2018 19:50:39'!
                     doNotShowChanges

	shouldShowChanges := false! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'HAW 1/7/2019 14:09:10'!
                    informChangesToBrowser

	"If the selected message is not the same as the oldSelector, that is the selector being renamed, 
	then it implies that we are renaming a selector sent in the source code of the selected message then
	I don't have to change the selected message in the browser - Hernan"
	browser selectedMessageName = oldSelector ifTrue: [ 
		browser setSelector: refactoring newSelector ]! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'HAW 8/18/2018 17:02:52'!
                   messageSetWindowClass
		
	^MessageSetWindow 
	! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'HAW 10/10/2018 19:52:08'!
                 showChanges
		
	self showChangesInMessageSetWindow! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'HAW 8/18/2018 17:28:30'!
              showChangesInMessageSetWindow

	self messageSetWindowClass openMessageList: changes asSortedCollection label: 'Changed methods' ! !
!ChangeSelectorApplier methodsFor: 'refactoring - creation' stamp: 'HAW 1/7/2019 13:51:04'!
createAndApplyRefactoring

	self 
		createRefactoringHandlingRefactoringExceptions;
		applyRefactoring;
		informChangesToBrowser.
			
	shouldShowChanges ifTrue: [ self showChanges ]
	
			! !
!ChangeSelectorApplier methodsFor: 'refactoring - creation' stamp: 'HAW 1/3/2019 08:46:41'!
     createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor 
		
	implementors := Array with: anImplementor.
	senders := #().
	shouldShowChanges := false.
	
	self createAndApplyRefactoring ! !
!ChangeSelectorApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/18/2018 17:03:58'!
                        refactoringClass

	self subclassResponsibility ! !
!ChangeSelectorApplier methodsFor: 'initialization' stamp: 'HAW 1/7/2019 13:47:34'!
                         initializeOn: aBrowser for: aSelector in: aClass
	
	oldSelector := aSelector.
	implementingClass := aClass.
	browser := aBrowser.
	shouldShowChanges := true.! !
!ChangeSelectorApplier methodsFor: 'evaluation' stamp: 'HAW 1/7/2019 14:59:52'!
               ifHasNoSendersAndOneImplementor: trueBlock ifNot: falseBlock

	| allImplementors |
	
	allImplementors := Smalltalk allImplementorsOf: oldSelector.
	
	"I could try to see if there is one sender and that that sender is in the same method beeing renamed. That could
	mean that it is a recursive call but I should also see if the receiver is self to be sure because if it is other 'type' of 
	object the rename could not be safe. To complex for a small posibility - Hernan"
	(allImplementors size = 1 and: [ (Smalltalk allCallsOn: oldSelector) isEmpty ]) 
		ifTrue: [ trueBlock value: allImplementors anyOne compiledMethod ]
		ifFalse: falseBlock! !
!ChangeSelectorApplier methodsFor: 'evaluation' stamp: 'HAW 1/3/2019 08:41:27'!
          value

	requestExitBlock := [ ^self ].
		
	self requestRefactoringParametersHandlingRefactoringExceptions.
	
	self 
		ifHasNoSendersAndOneImplementor: [ :anImplementor | self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor ]
		ifNot: [ self askForImplementosAndSenders ]! !
!ChangeSelectorApplier methodsFor: 'evaluation' stamp: 'HAW 1/3/2019 08:46:11'!
       wizardEnded

	requestExitBlock := [ ^self ].
	
	self 
		closeBrowser;
		createAndApplyRefactoring.! !
!ChangeSelectorApplier class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 17:17:52'!
                               assertCanApplyRefactoringFor: aSelector in: aClass

	self subclassResponsibility ! !
!ChangeSelectorApplier class methodsFor: 'instance creation' stamp: 'HAW 1/7/2019 13:47:54'!
              on: aBrowser for: aSelector in: aClass 
	
	self assertCanApplyRefactoringFor: aSelector in: aClass.
	
	^self new initializeOn: aBrowser for: aSelector in: aClass
	! !
!AddParameterApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/18/2018 16:46:49'!
                              createRefactoring
	
	oldSelector isUnary ifTrue: [ ^self createRefactoringForUnarySelector].
	oldSelector isKeyword ifTrue: [ ^self createRefactoringForKeywordSelector ].
	
	self error: 'oldSelector should be unary or keyword!!'! !
!AddParameterApplier methodsFor: 'refactoring - creation' stamp: 'HAW 9/4/2018 20:24:53'!
                              createRefactoringForKeywordSelector
	
	^self refactoringClass 
		named: newParameter
		at: parameterIndex 
		initializedWith: newParameterValue 
		using: newKeyword 
		toKeywordSelector: oldSelector 
		implementors: implementors 
		senders: senders ! !
!AddParameterApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/18/2018 16:56:55'!
        createRefactoringForUnarySelector
	
	^self refactoringClass 
		named: newParameter
		initializedWith: newParameterValue 
		toUnarySelector: oldSelector 
		implementors: implementors 
		senders: senders ! !
!AddParameterApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/18/2018 16:56:55'!
                       refactoringClass

	^AddParameter! !
!AddParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 9/4/2018 20:33:41'!
                        askInsertionIndex

	| methodNode originalMethod parameterNames |
	
	originalMethod := implementingClass compiledMethodAt: oldSelector.
	methodNode := originalMethod methodNode.
	parameterNames := methodNode argumentNames.
	parameterNames add: 'Add as last parameter'.

	parameterIndex := (PopUpMenu labelArray: parameterNames) startUpWithCaption: 'Add Before?'.
	parameterIndex = 0 ifTrue: [self endRequest ].
	
	! !
!AddParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 9/4/2018 20:33:37'!
                           askInsertionIndexIfNecessary

	oldSelector isKeyword ifTrue: [ self askInsertionIndex ].
	! !
!AddParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:06:28'!
                             askNewKeyword

 	| enteredString |
	
	enteredString := self request: 'Enter keyword for new parameter'.
	newKeyword := enteredString withBlanksTrimmed asSymbol.
	self refactoringClass assertIsValidKeywordForNewParameter: newKeyword! !
!AddParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 17:06:28'!
                askNewKeywordIfNecessary
		
	oldSelector isKeyword ifTrue: [self askNewKeyword]! !
!AddParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 16:56:55'!
        askNewParameter
		
	| enteredString |
	
	enteredString := self request: 'Enter new parameter name'.
	newParameter := enteredString withBlanksTrimmed.
	self refactoringClass assertIsValidParameterName: newParameter
! !
!AddParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/25/2018 11:28:58'!
 askNewParameterValue
		
	| enteredString |
	
	enteredString := self request: 'Enter parameter value for senders'.
	newParameterValue := enteredString withBlanksTrimmed.
	self refactoringClass assertNewParameterValueIsNotEmpty: newParameterValue.
	self refactoringClass assertNewParameterValueIsValid: newParameterValue.
! !
!AddParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/3/2019 08:01:40'!
                        requestRefactoringParameters

	self
		askNewParameter;
		askNewParameterValue;
		askInsertionIndexIfNecessary;
		askNewKeywordIfNecessary
		! !
!AddParameterApplier class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 17:18:06'!
                       assertCanApplyRefactoringFor: aSelector in: aClass

	AddParameter assertCanAddParameterTo: aSelector.
	

	! !
!RemoveParameterApplier methodsFor: 'refactoring - creation' stamp: 'HAW 9/4/2018 15:15:48'!
                     createRefactoring
	
	^self refactoringClass named: parameterToRemove from: originalMethod implementors: implementors senders: senders ! !
!RemoveParameterApplier methodsFor: 'refactoring - creation' stamp: 'HAW 9/4/2018 15:15:00'!
                         refactoringClass

	^RemoveParameter! !
!RemoveParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 9/4/2018 15:30:50'!
                  askParameterToRemove
		
	| methodNode parameterNames |
	
	originalMethod := implementingClass compiledMethodAt: oldSelector.
	methodNode := originalMethod methodNode.
	parameterNames := methodNode argumentNames.
	
	parameterNames size = 1 
		ifTrue: [ parameterToRemove := parameterNames first ]
		ifFalse: [ parameterToRemove := self selectParameterToRemoveForm: parameterNames ].
	
	! !
!RemoveParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/3/2019 08:01:51'!
                    requestRefactoringParameters

	self askParameterToRemove
		
		! !
!RemoveParameterApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 9/4/2018 15:36:30'!
                       selectParameterToRemoveForm: parameterNames
	
	| parameterIndex |
	
	parameterIndex := (PopUpMenu labelArray: parameterNames) startUpWithCaption: 'Select parameter to remove'.
	parameterIndex = 0 ifTrue: [self endRequest ].
	
	^parameterNames at: parameterIndex.! !
!RemoveParameterApplier class methodsFor: 'pre-conditions' stamp: 'HAW 9/4/2018 15:17:09'!
                           assertCanApplyRefactoringFor: aSelector in: aClass

	RemoveParameter assertCanRemoveParameterFrom: aSelector.
	

	! !
!RenameSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 17:02:06'!
    askNewSelector

	| enteredString |
	
	enteredString := self request: 'Enter new selector:' initialAnswer: oldSelector.
	newSelector := enteredString withBlanksTrimmed asSymbol.
		
! !
!RenameSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/18/2018 16:56:24'!
 assertCanRenameSelector
		
	self refactoringClass assertIsValidToRenameFrom: oldSelector to: newSelector.
	! !
!RenameSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/3/2019 08:02:00'!
           requestRefactoringParameters

	self
		askNewSelector;
		assertCanRenameSelector
		! !
!RenameSelectorApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/18/2018 16:56:24'!
             createRefactoring
	
	^self refactoringClass from: oldSelector to: newSelector implementors: implementors senders: senders.
	! !
!RenameSelectorApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/18/2018 17:04:02'!
   refactoringClass

	^RenameSelector ! !
!RenameSelectorApplier class methodsFor: 'pre-conditions' stamp: 'HAW 8/18/2018 17:24:18'!
                              assertCanApplyRefactoringFor: aSelector in: aClass 
	
	! !
!InsertSuperclassApplier methodsFor: 'initialization' stamp: 'FJG 8/5/2018 22:31:03'!
               initializeOn: aBrowser for: aClass
	browser _ aBrowser.
	classToRefactor _ aClass.! !
!InsertSuperclassApplier methodsFor: 'refactoring - parameters request' stamp: 'FJG 8/5/2018 22:31:31'!
  askNewSuperclassName
	newSuperclassName _ self
		request: 'Enter new superclass name:'.
	newSuperclassName _ newSuperclassName withBlanksTrimmed asSymbol.! !
!InsertSuperclassApplier methodsFor: 'refactoring - parameters request' stamp: 'FJG 8/5/2018 22:29:07'!
                          requestRefactoringParameters

	self askNewSuperclassName! !
!InsertSuperclassApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/13/2018 15:55:10'!
     createRefactoring

	^InsertSuperclass to: classToRefactor named: newSuperclassName! !
!InsertSuperclassApplier methodsFor: 'refactoring - changes' stamp: 'FJG 8/5/2018 22:33:49'!
             showChanges
	
	browser changed: #classList.
! !
!InsertSuperclassApplier class methodsFor: 'instance creation' stamp: 'FJG 8/5/2018 22:27:02'!
                 on: aBrowser for: aClass

	^self new initializeOn: aBrowser for: aClass! !
!RemoveAllUnreferencedInstanceVariablesApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/2/2018 16:11:13'!
                       requestRefactoringParameters

	! !
!RemoveAllUnreferencedInstanceVariablesApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/2/2018 16:15:05'!
         createRefactoring
		
	^RemoveAllUnreferencedInstanceVariables from: classToRefactor ! !
!RemoveAllUnreferencedInstanceVariablesApplier methodsFor: 'refactoring - changes' stamp: 'HAW 1/7/2019 14:42:50'!
                     informChangesToBrowser
		
	browser acceptedContentsChanged! !
!RemoveAllUnreferencedInstanceVariablesApplier methodsFor: 'refactoring - changes' stamp: 'HAW 8/2/2018 16:20:16'!
               showChanges

	| removedInstanceVariablesMessage |
	
	self informChangesToBrowser.
	removedInstanceVariablesMessage := changes isEmpty 
		ifTrue: [ 'No instance variable was removed' ]
		ifFalse: [ changes size = 1
			ifTrue: [ changes first, ' was removed' ]
			ifFalse: [ changes asCommaStringAnd, ' were removed' ]].
			
	self inform: removedInstanceVariablesMessage! !
!RemoveAllUnreferencedInstanceVariablesApplier methodsFor: 'initialization' stamp: 'HAW 1/7/2019 14:42:41'!
initializeOn: aBrowser for: aClassToRefactor 
	
	browser := aBrowser.
	classToRefactor := aClassToRefactor ! !
!RemoveAllUnreferencedInstanceVariablesApplier class methodsFor: 'instance creation' stamp: 'HAW 1/7/2019 14:42:34'!
                            on: aBrowser for: aClassToRefactor
	
	^self new initializeOn: aBrowser for: aClassToRefactor 
! !
!RemoveInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/30/2017 18:22:28'!
               chooseInstanceVariable

	classToRefactor 
		chooseDefiningInstanceVariableAlphabeticallyWith: self selectVariableLabel
		thenDo: [ :aVariableToRemove | ^variableToRemove := aVariableToRemove ].
	self endRequest 

	! !
!RemoveInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/17/2017 19:51:21'!
                       requestRefactoringParameters

	self chooseInstanceVariable.

	! !
!RemoveInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/30/2017 18:22:41'!
               selectVariableLabel
	
	^'Select instance variable to remove'! !
!RemoveInstanceVariableApplier methodsFor: 'refactoring - creation' stamp: 'HAW 6/17/2017 19:50:03'!
                           createRefactoring
		
	^RemoveInstanceVariable named: variableToRemove from: classToRefactor ! !
!RemoveInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 1/7/2019 14:43:43'!
                             informChangesToBrowser
		
	browser acceptedContentsChanged! !
!RemoveInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 6/17/2017 19:50:31'!
                              showChanges

	self informChangesToBrowser! !
!RemoveInstanceVariableApplier methodsFor: 'initialization' stamp: 'HAW 1/7/2019 14:43:37'!
                       initializeOn: aBrowser for: aClassToRefactor 
	
	browser := aBrowser.
	classToRefactor := aClassToRefactor ! !
!RemoveInstanceVariableApplier class methodsFor: 'instance creation' stamp: 'HAW 1/7/2019 14:43:28'!
            on: aBrowser for: aClassToRefactor
	
	^self new initializeOn: aBrowser for: aClassToRefactor 
! !
!RenameClassApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 16:02:13'!
                           askNewClassName

	newClassName := self request: 'Enter new name:' initialAnswer: classToRename name.
	newClassName := newClassName withBlanksTrimmed asSymbol.
	! !
!RenameClassApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 19:05:08'!
                         requestRefactoringParameters

	self askNewClassName! !
!RenameClassApplier methodsFor: 'refactoring - creation' stamp: 'HAW 6/5/2017 18:07:28'!
                createRefactoring

	^RenameClass from: classToRename to: newClassName in: Smalltalk undeclared: Undeclared.
	
! !
!RenameClassApplier methodsFor: 'refactoring - changes' stamp: 'HAW 6/5/2017 16:05:00'!
                      informChangesToBrowser
	
	browser changed: #classList.
	browser selectClass: classToRename.
! !
!RenameClassApplier methodsFor: 'refactoring - changes' stamp: 'HAW 6/5/2017 18:08:13'!
        openChangedMethods

	changes ifNotEmpty: [ 
		MessageSetWindow openMessageList: changes label: 'Renamed references' autoSelect: newClassName ]
! !
!RenameClassApplier methodsFor: 'refactoring - changes' stamp: 'HAW 6/5/2017 18:07:55'!
                     showChanges

	self 
		informChangesToBrowser;
		openChangedMethods
! !
!RenameClassApplier methodsFor: 'initialization' stamp: 'HAW 6/5/2017 16:55:57'!
        initializeOn: aBrowser for: aClass

	browser := aBrowser.
	classToRename := aClass.
	! !
!RenameClassApplier class methodsFor: 'instance creation' stamp: 'HAW 6/5/2017 12:27:45'!
             on: aBrowser for: aClass

	^self new initializeOn: aBrowser for: aClass! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 16:49:50'!
       askNewVariableName
		
	newInstanceVariable := self request: 'Enter new name:' initialAnswer: oldInstanceVariable. 
	newInstanceVariable := newInstanceVariable withBlanksTrimmed ! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 11/28/2018 19:37:54'!
                           chooseInstanceVariable
	
	oldInstanceVariable ifNotNil: [ ^self ].
		
	classToRefactor 
		chooseDefiningInstanceVariableAlphabeticallyWith: self selectVariableLabel
		thenDo: [ :anOldInstanceVariable | ^oldInstanceVariable := anOldInstanceVariable ].
	self endRequest ! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/5/2017 19:05:16'!
  requestRefactoringParameters

	self 
		chooseInstanceVariable;
		askNewVariableName! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/30/2017 17:27:22'!
                          selectVariableLabel
	
	^'Select instance variable to rename'! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - creation' stamp: 'HAW 6/5/2017 18:09:13'!
                            createRefactoring
		
	^RenameInstanceVariable from: oldInstanceVariable to: newInstanceVariable in: classToRefactor.
	! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 11/28/2018 19:38:47'!
 informChangesToBrowser
		
	browser acceptedContentsChanged! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 8/30/2017 17:30:22'!
                              openChangedMethods 

	changes ifNotEmpty: [ self openChangedMethodsWhenChangesNotEmpty ]! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 8/30/2017 17:30:13'!
openChangedMethodsWhenChangesNotEmpty 

	MessageSetWindow openMessageList: changes label: 'Renamed references' autoSelect: newInstanceVariable ! !
!RenameInstanceVariableApplier methodsFor: 'refactoring - changes' stamp: 'HAW 6/5/2017 18:09:30'!
          showChanges

	self 
		informChangesToBrowser;
		openChangedMethods ! !
!RenameInstanceVariableApplier methodsFor: 'initialization' stamp: 'HAW 11/28/2018 19:40:02'!
                           initializeOn: aBrowserWindow for: anOldInstanceVariable at: aClassToRefactor 
	
	browser := aBrowserWindow.
	classToRefactor := aClassToRefactor.
	oldInstanceVariable := anOldInstanceVariable ! !
!RenameInstanceVariableApplier class methodsFor: 'instance creation' stamp: 'HAW 11/29/2018 20:19:06'!
                     on: aBrowser at: aClassToRefactor
	
	^self new initializeOn: aBrowser for: nil at: aClassToRefactor 
! !
!RenameInstanceVariableApplier class methodsFor: 'instance creation' stamp: 'HAW 11/29/2018 20:18:59'!
                on: aBrowser for: anInstanceVariableName at:  aClassToRefactor 
	
	^self new initializeOn: aBrowser for: anInstanceVariableName at: aClassToRefactor ! !
!RenameTemporaryApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/25/2017 21:37:58'!
                               askNewVariableName
		
	newVariable := (self request: 'Enter new name:' initialAnswer: oldVariable) withBlanksTrimmed ! !
!RenameTemporaryApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 11/28/2018 19:42:45'!
                              chooseTemporaryVariable
	
	| variables |
	
	oldVariable ifNotNil: [ ^self ].
	
	variables := methodNode tempNames.
	variables isEmpty 
		ifTrue: [ self noTemporaryToRename ]
		ifFalse: [ self chooseTemporaryVariableFrom: variables ]
	
	! !
!RenameTemporaryApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 10/4/2017 17:15:17'!
        chooseTemporaryVariableFrom: variables
	
	 | selection |
			
	selection :=  smalltalkEditor selection string withBlanksTrimmed.
	oldVariable := (self is: selection temporaryVariableFrom: variables) 
		ifTrue: [ selection ]
		ifFalse: [ self selectTemporaryVariableFrom: variables]! !
!RenameTemporaryApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 10/4/2017 17:13:25'!
                            is: selection temporaryVariableFrom: variables
		
	^smalltalkEditor hasSelection and: [variables includes: selection]! !
!RenameTemporaryApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 10/4/2017 17:09:43'!
                               noTemporaryToRename
	
	self inform: 'There are no temporary to rename'.
	self endRequest ! !
!RenameTemporaryApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 6/25/2017 21:29:58'!
                           requestRefactoringParameters

	self 
		chooseTemporaryVariable;
		askNewVariableName! !
!RenameTemporaryApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 10/4/2017 17:16:25'!
selectTemporaryVariableFrom: variables

	| selectionIndex |
	
	selectionIndex := (PopUpMenu labelArray: variables lines: #()) startUpWithCaption: 'Select temporary to rename'.
	
	^selectionIndex = 0 
		ifTrue: [ self endRequest ]
		ifFalse: [ variables at: selectionIndex ]! !
!RenameTemporaryApplier methodsFor: 'refactoring - creation' stamp: 'HAW 6/25/2017 21:54:40'!
             createRefactoring
		
	^RenameTemporary from: oldVariable to: newVariable in: methodNode 
	! !
!RenameTemporaryApplier methodsFor: 'initialization' stamp: 'HAW 11/28/2018 19:43:15'!
           initializeOn: aSmalltalkEditor for: aTemporary

	smalltalkEditor := aSmalltalkEditor.
	classToRefactor := smalltalkEditor codeProvider selectedClassOrMetaClass.
	methodNode := classToRefactor methodNodeFor: smalltalkEditor actualContents string.
	oldVariable := aTemporary 
	! !
!RenameTemporaryApplier methodsFor: 'refactoring - changes' stamp: 'HAW 8/9/2018 19:43:41'!
             showChanges

	smalltalkEditor actualContents: changes.
	smalltalkEditor hasUnacceptedEdits ifFalse: [
		smalltalkEditor 
			hasUnacceptedEdits: true;
			acceptContents ]
	! !
!RenameTemporaryApplier class methodsFor: 'exceptions' stamp: 'HAW 10/4/2017 17:05:53'!
                         errorMessageForCanNotParseMethod: anError

	^ String streamContents: [ :stream |
		stream
			nextPutAll: 'Method can not be parsed due to:';
			newLine;
			nextPutAll: anError messageText ]! !
!RenameTemporaryApplier class methodsFor: 'instance creation' stamp: 'HAW 11/28/2018 19:44:13'!
                               on: aSmalltalkEditor for: aTemporary
	
	^self new initializeOn: aSmalltalkEditor for: aTemporary! !
!SafelyRemoveClassApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/1/2018 16:54:40'!
                   confirmationMessageText
	
	^'Are you sure you want to remove ', classToRemove name asString, '?'! !
!SafelyRemoveClassApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 8/1/2018 16:52:57'!
                   requestRefactoringParameters

	(self confirm: self confirmationMessageText) ifFalse: [ self endRequest ].

	! !
!SafelyRemoveClassApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/1/2018 16:54:33'!
                 createRefactoring
		
	^SafelyRemoveClass of: classToRemove ! !
!SafelyRemoveClassApplier methodsFor: 'refactoring - changes' stamp: 'HAW 9/14/2018 13:48:37'!
  informChangesToBrowser

	browser classListIndex: 0! !
!SafelyRemoveClassApplier methodsFor: 'refactoring - changes' stamp: 'HAW 9/14/2018 13:47:58'!
           showChanges

	self informChangesToBrowser! !
!SafelyRemoveClassApplier methodsFor: 'initialization' stamp: 'HAW 9/14/2018 13:47:41'!
                           initializeOn: aBrowser of: aClassToRemove 
	
	browser := aBrowser.
	classToRemove := aClassToRemove ! !
!SafelyRemoveClassApplier class methodsFor: 'instance creation' stamp: 'HAW 9/14/2018 13:47:16'!
                       on: aBrowser of: aClassToRemove
	
	^self new initializeOn: aBrowser of: aClassToRemove ! !
!RefactoringMenues class methodsFor: 'editor menus' stamp: 'HAW 11/28/2018 20:23:45'!
               smalltalkEditorMenuOptions

	^`{
		{
				#itemGroup 	-> 		35.
				#itemOrder 		-> 		10.
				#label 			-> 		'Rename... (R)'.
				#selector 		-> 		#contextualRename.
				#icon 			-> 		#saveAsIcon
		} asDictionary 
	}`! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 19:25:26'!
               classListMenuOptions

	^ `{
			{
				#itemGroup 	-> 		5.
				#itemOrder 		-> 		10.
				#label 			-> 		'refactorings...'.
				#selector 		-> 		#openClassRefactoringMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 8/17/2018 17:50:40'!
   classRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class ...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'insert superclass ...'.
				#object 			-> 		#model.
				#selector 		-> 		#insertSuperclass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'safely remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#safelyRemoveClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'add inst var...'.
				#selector 		-> 		#addInstVar.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename inst var...'.
				#selector 		-> 		#renameInstVar.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove inst var...'.
				#selector 		-> 		#removeInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove all unreferenced inst var...'.
				#selector 		-> 		#removeAllUnreferencedInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
	}`.
	! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 7/7/2018 19:38:01'!
  messageListMenuOptions

	^ `{
			{
				#itemGroup 	-> 		5.
				#itemOrder 		-> 		10.
				#label 			-> 		'refactorings...'.
				#selector 		-> 		#openMessageRefactoringMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 3/6/2019 15:05:24'!
messsageRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename...'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
	}`.
	
	! !
!RefactoringMenues class methodsFor: 'initialization' stamp: 'HAW 12/28/2018 12:51:56'!
        initialize 

	Editor initialize! !
!RefactoringMenues class methodsFor: 'shortcuts' stamp: 'HAW 2/4/2019 16:43:23'!
            smalltalkEditorCmdShortcutsSpec

	^#(
		#(		$R	#contextualRename:		'Renames what is under cursor'))
! !
!RefactoringPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:48:22'!
      refactoringError: aMessage

	Refactoring refactoringError: aMessage.! !
!RefactoringPrecondition methodsFor: 'warnings' stamp: 'HAW 3/4/2019 13:30:01'!
        refactoringWarning: aMessageText

	^ Refactoring refactoringWarning: aMessageText ! !
!NewClassPrecondition methodsFor: 'evaluating' stamp: 'HAW 3/3/2019 09:18:10'!
                           value

	self assertNewClassNameIsNotEmpty.
	self assertNewClassNameSymbol.
	self assertNewClassNameStartsWithUppercaseLetter.
	self assertNewClassNameHasNoSeparators.
	self assertNewClassNameDoesNotExistInSystem.
	self assertNewClassNameIsNotUndeclaredInUndeclared.

! !
!NewClassPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/4/2019 11:55:05'!
                        assertNewClassNameDoesNotExistInSystem

	system at: newClassName ifPresent: [ :value | 
		value isBehavior 
			ifTrue: [ self signalClassAlreadyExists]
			ifFalse: [  self signalGlobalAlreadyExists]].! !
!NewClassPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/4/2019 11:50:39'!
                           assertNewClassNameHasNoSeparators

	(newClassName anySatisfy: [:aChar | aChar isSeparator]) 
		ifTrue: [ self signalNewClassNameCanNotHaveSeparators]! !
!NewClassPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/4/2019 11:50:43'!
              assertNewClassNameIsNotEmpty

	newClassName withBlanksTrimmed isEmpty ifTrue: [ self signalNewClassNameCanNotBeEmpty]! !
!NewClassPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/4/2019 11:55:23'!
              assertNewClassNameIsNotUndeclaredInUndeclared

	(undeclared includesKey: newClassName) ifTrue: [ self signalNewClassIsUndeclared]! !
!NewClassPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/4/2019 11:50:51'!
  assertNewClassNameStartsWithUppercaseLetter

	newClassName first isUppercase ifFalse: [ self signalNewNameMustStartWithUppercaseLetter]! !
!NewClassPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/4/2019 11:50:55'!
                            assertNewClassNameSymbol

	newClassName isSymbol ifFalse: [ self signalNewNameMustBeSymbol]! !
!NewClassPrecondition methodsFor: 'initialization' stamp: 'HAW 8/13/2018 16:00:19'!
             initializeFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	newClassName := aNewClassName.
	system := aSystem.
	undeclared := anUndeclaredDictionary ! !
!NewClassPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:54:34'!
     signalClassAlreadyExists

	self refactoringError: (self class errorMessageForAlreadyExistClassNamed: newClassName).! !
!NewClassPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:55:05'!
                          signalGlobalAlreadyExists

	self refactoringError: (self class errorMessageForAlreadyExistGlobalNamed: newClassName)! !
!NewClassPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:55:23'!
                         signalNewClassIsUndeclared

	self refactoringError: (self class errorMessageForNewClassIsUndeclared: newClassName).! !
!NewClassPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:52:08'!
                          signalNewClassNameCanNotBeEmpty
	
	self refactoringError: self class newClassNameCanNotBeEmptyErrorMessage! !
!NewClassPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:52:13'!
   signalNewClassNameCanNotHaveSeparators
	
	self refactoringError: self class newClassNameCanNotHaveSeparatorsErrorMessage ! !
!NewClassPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:52:17'!
                    signalNewNameMustBeSymbol

	self refactoringError: self class newNameMustBeSymbolErrorMessage.! !
!NewClassPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/4/2019 11:52:22'!
               signalNewNameMustStartWithUppercaseLetter

	self refactoringError: self class newNameMustStartWithUppercaseLetterErrorMessage.! !
!NewClassPrecondition class methodsFor: 'error messages' stamp: 'HAW 12/13/2018 17:56:51'!
   errorMessageForAlreadyExistClassNamed: aNewClassName

	^'Class named ', aNewClassName, ' already exist'! !
!NewClassPrecondition class methodsFor: 'error messages' stamp: 'HAW 12/13/2018 17:59:02'!
                          errorMessageForAlreadyExistGlobalNamed: aNewClassName

	^'There is already a global variable named ', aNewClassName ! !
!NewClassPrecondition class methodsFor: 'error messages' stamp: 'HAW 8/13/2018 15:58:18'!
              errorMessageForNewClassIsUndeclared: aNewClassName

	^aNewClassName, ' is undeclared'! !
!NewClassPrecondition class methodsFor: 'error messages' stamp: 'HAW 8/13/2018 15:58:18'!
             newClassNameCanNotBeEmptyErrorMessage
	
	^'New class name can not be empty'! !
!NewClassPrecondition class methodsFor: 'error messages' stamp: 'HAW 3/3/2019 09:20:59'!
                        newClassNameCanNotHaveSeparatorsErrorMessage
	
	^'New class name can not have separators'! !
!NewClassPrecondition class methodsFor: 'error messages' stamp: 'HAW 8/13/2018 15:58:18'!
         newNameMustBeSymbolErrorMessage
	
	^'New class name must be a symbol'! !
!NewClassPrecondition class methodsFor: 'error messages' stamp: 'HAW 8/13/2018 15:58:18'!
                             newNameMustStartWithUppercaseLetterErrorMessage

	^'New class name must start with an uppercase letter'! !
!NewClassPrecondition class methodsFor: 'instance creation' stamp: 'HAW 8/13/2018 17:31:51'!
                        for: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	^self new initializeFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 
! !
!NewClassPrecondition class methodsFor: 'evaluation' stamp: 'HAW 8/13/2018 17:37:20'!
          valueFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	^(self for: aNewClassName in: aSystem undeclared: anUndeclaredDictionary) value! !
!NewInstanceVariablePrecondition methodsFor: 'initialization' stamp: 'HAW 3/3/2019 08:10:58'!
     initializeOf: anInstanceVariableName for: aClass

	instVarName := anInstanceVariableName withBlanksTrimmed.
	classToAddInstVar := aClass.! !
!NewInstanceVariablePrecondition methodsFor: 'evaluating' stamp: 'HAW 3/3/2019 08:30:12'!
                         value
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self warnIfIsDefinedInMethods.! !
!NewInstanceVariablePrecondition methodsFor: 'pre-conditions' stamp: 'HAW 3/3/2019 08:36:05'!
                    assertIsNotAReservedName
	
	(ClassBuilder reservedNames includes: instVarName) ifTrue: [ self signalNewInstanceVariableCanNotBeAReservedName ]! !
!NewInstanceVariablePrecondition methodsFor: 'pre-conditions' stamp: 'HAW 3/3/2019 08:35:12'!
                assertIsNotAlreadyDefined
	
	^ classToAddInstVar 
		withClassesThatDefineInHierarchyInstanceVariable: instVarName 
		do: [ :definingClasses | self signalAlreadyDefinedInAll: definingClasses ]
		ifNone: [ ].! !
!NewInstanceVariablePrecondition methodsFor: 'pre-conditions' stamp: 'FGJ 12/17/2018 15:29:44'!
              assertIsNotEmpty

	instVarName isEmpty ifTrue: [ self signalNewVariableCanNotBeEmpty]! !
!NewInstanceVariablePrecondition methodsFor: 'pre-conditions' stamp: 'HAW 3/3/2019 08:34:17'!
         assertIsValidInstanceVariableName

	| scannedNames |

	scannedNames := Scanner new scanFieldNames: instVarName .
	scannedNames size = 1 ifFalse: [ self signalInvalidInstanceVariable ].
	scannedNames first = instVarName ifFalse: [ self signalInvalidInstanceVariable ].! !
!NewInstanceVariablePrecondition methodsFor: 'exceptions' stamp: 'HAW 3/3/2019 08:35:12'!
                       signalAlreadyDefinedInAll: classes

	^ self refactoringError: (self class errorMessageForNewInstanceVariable: instVarName alreadyDefinedInAll: classes).! !
!NewInstanceVariablePrecondition methodsFor: 'exceptions' stamp: 'HAW 3/3/2019 08:34:09'!
          signalInvalidInstanceVariable

	^ self refactoringError: (self class errorMessageForInvalidInstanceVariable: instVarName).! !
!NewInstanceVariablePrecondition methodsFor: 'exceptions' stamp: 'HAW 3/3/2019 08:36:00'!
        signalNewInstanceVariableCanNotBeAReservedName

	self refactoringError: (self class errorMessageForNewInstanceVariableCanNotBeAReservedName: instVarName)! !
!NewInstanceVariablePrecondition methodsFor: 'exceptions' stamp: 'FGJ 12/17/2018 16:27:50'!
       signalNewVariableCanNotBeEmpty
	
	self refactoringError: self class newVariableCanNotBeEmptyErrorMessage! !
!NewInstanceVariablePrecondition methodsFor: 'warnings' stamp: 'HAW 3/3/2019 08:19:24'!
                            methodsDefiningNewVariable
	
	| methodsDefiningNewVariableInHierarchy |
	
	methodsDefiningNewVariableInHierarchy := OrderedCollection new.
	
	classToAddInstVar withAllSubclassesDo: [ :class | 
		methodsDefiningNewVariableInHierarchy addAll: (class methodsWithArgumentOrTemporaryNamed: instVarName) ].

	^methodsDefiningNewVariableInHierarchy 
		
	! !
!NewInstanceVariablePrecondition methodsFor: 'warnings' stamp: 'HAW 3/3/2019 08:13:49'!
         warnIfIsDefinedInMethods
	
	| methodsDefiningNewVariable |
	
	methodsDefiningNewVariable := self methodsDefiningNewVariable.
	
	methodsDefiningNewVariable notEmpty ifTrue: [ self warnNewVariable: instVarName willBeHiddenAtAll: methodsDefiningNewVariable ].! !
!NewInstanceVariablePrecondition methodsFor: 'warnings' stamp: 'FGJ 12/17/2018 16:29:18'!
  warnNewVariable: newVariable willBeHiddenAtAll: methods

	^ self refactoringWarning: (self class warningMessageForNewVariable: newVariable willBeHiddenAtAll: methods).! !
!NewInstanceVariablePrecondition class methodsFor: 'instance creation' stamp: 'HAW 3/3/2019 08:10:58'!
              of: anInstanceVariableName for: aClass

	^self new initializeOf: anInstanceVariableName for: aClass ! !
!NewInstanceVariablePrecondition class methodsFor: 'error messages' stamp: 'FGJ 12/17/2018 16:27:09'!
                  errorMessageForInvalidInstanceVariable: aName

	^ '''' , aName , ''' is not a valid instance variable name'.! !
!NewInstanceVariablePrecondition class methodsFor: 'error messages' stamp: 'FGJ 12/17/2018 16:28:18'!
          errorMessageForNewInstanceVariable: aName alreadyDefinedInAll: classes

	^ 'Instance variable ''' , aName , ''' is already defined in ' , classes asCommaStringAnd.! !
!NewInstanceVariablePrecondition class methodsFor: 'error messages' stamp: 'HAW 3/3/2019 08:32:29'!
                     errorMessageForNewInstanceVariableCanNotBeAReservedName: aName

	^'''', aName, ''' can not be used as instance variable name because it is a reserved name'! !
!NewInstanceVariablePrecondition class methodsFor: 'error messages' stamp: 'FGJ 12/17/2018 16:05:38'!
                           newVariableCanNotBeEmptyErrorMessage
	
	^'New variable can not be empty'! !
!NewInstanceVariablePrecondition class methodsFor: 'warning messages' stamp: 'HAW 3/3/2019 08:27:30'!
              warningMessageForNewVariable: newVariable willBeHiddenAtAll: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: newVariable;
			nextPutAll: ' will be hidden at '.
		methods asCommaSeparated: [:aMethod | aMethod printClassAndSelectorOn: stream ] on: stream ]! !
!NewInstanceVariablePrecondition class methodsFor: 'evaluating' stamp: 'HAW 3/3/2019 10:06:23'!
       valueOf: anInstanceVariableName for: aClass

	^(self of: anInstanceVariableName for: aClass) value! !

RefactoringMenues initialize!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3638-Refactorings-HernanWilkinson-2019Mar07-09h40m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3639] on 4 March 2019 at 4:23:49 pm'!
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:56:13'!
        withParseNodeIncluding: aPosition do: aBlock ifAbsent: anAbsentBlock

	| nodeAndPosition |

	nodeAndPosition :=self parseNodeIncluding: aPosition ifAbsent: [ ^ anAbsentBlock value ].
	^aBlock value: nodeAndPosition key.! !
!CodeProvider methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:52:13'!
                             isEditingMethod

	^false! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:02:28'!
insertSuperclass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(InsertSuperclassApplier on: self for: aBehavior theNonMetaClass) value ].! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:02:36' prior: 16791771!
                  removeClass

	self safelyRemoveClass ! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:02:38' prior: 16791778!
   renameClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(RenameClassApplier on: self for: aBehavior theNonMetaClass) value ].! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:02:41'!
            safelyRemoveClass

	self selectedClassOrMetaClass ifNotNil: [ :aBehavior |
		(SafelyRemoveClassApplier on: self of: aBehavior theNonMetaClass) value ].! !
!Browser methodsFor: 'testing' stamp: 'HAW 3/4/2019 16:02:31'!
      isEditingMethod

	^editSelection = #editMessage or: [ editSelection = #newMessage ]
! !
!MessageSet methodsFor: 'message list' stamp: 'HAW 3/4/2019 16:11:56'!
 addMethodReference: aMethodReferenceToAdd ifIncluded: aBlockClosure

	(messageList includes: aMethodReferenceToAdd)
		ifTrue: aBlockClosure
		ifFalse: [ self addMethodReference: aMethodReferenceToAdd ]! !
!MessageSet methodsFor: 'message list' stamp: 'HAW 3/4/2019 16:11:51' prior: 16869941!
                            removeMessageFromBrowser
	"Remove the selected message from the browser."

	self removeMessageFromBrowserKeepingLabel.
	self changed: #relabel! !
!MessageSet methodsFor: 'message list' stamp: 'HAW 3/4/2019 16:11:48'!
       removeMessageFromBrowserKeepingLabel

	selectedMessage ifNil: [ ^nil ].
	self deleteFromMessageList: self selection.
	self reformulateList.
! !
!Debugger methodsFor: 'testing' stamp: 'HAW 3/4/2019 16:05:01'!
                isEditingMethod

	^true! !
!UndefinedObject methodsFor: 'accessing instances and variables' stamp: 'HAW 3/4/2019 15:18:06'!
    whichClassDefinesInstanceVariable: aVariable ifNone: aNoneBlock

	^aNoneBlock value! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'HAW 3/4/2019 15:19:49'!
                     methodsSelect: aCondition

	^ self methodDict valuesSelect: aCondition! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'HAW 3/4/2019 15:20:07'!
  methodsWithArgumentOrTemporaryNamed: instVarName

	^self methodsSelect: [:aMethod | aMethod hasArgumentOrTemporary: instVarName ]! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'HAW 3/4/2019 15:20:45'!
       withSuperclassThatIncludesSelector: aSelector do: aFoundClosure ifNone: aNoneClosure

	^superclass
		ifNil: aNoneClosure
		ifNotNil: [
			(superclass whichClassIncludesSelector: aSelector)
				ifNil: aNoneClosure
				ifNotNil: aFoundClosure ]! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 3/4/2019 15:18:50'!
                definesClassVariableNamedInHierarchy: aClassVariableName

	^self allClassVarNames includes: aClassVariableName ! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 3/4/2019 15:19:06'!
                   definesInstanceVariableNamed: anInstanceVariableName

	^self instVarNames includes: anInstanceVariableName! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 3/4/2019 15:19:30'!
                        indexOfInstanceVariable: aName

	^self allInstVarNames indexOf: aName! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'HAW 3/4/2019 15:20:24'!
                             whichClassDefinesInstanceVariable: aVariable ifNone: aNoneBlock

	(self definesInstanceVariableNamed: aVariable) ifTrue: [ ^self ].

	^superclass whichClassDefinesInstanceVariable: aVariable ifNone: aNoneBlock! !
!ClassDescription methodsFor: 'instance variables' stamp: 'HAW 3/4/2019 15:21:47'!
                        chooseDefiningInstanceVariableAlphabeticallyWith: aCaption thenDo: aBlock

	^self
		chooseDefiningInstanceVariableAlphabeticallyWith: aCaption
		thenDo: aBlock
		ifNone: [ ^ self inform: 'There are no instance variables defined in ', self name ] ! !
!ClassDescription methodsFor: 'instance variables' stamp: 'HAW 3/4/2019 15:21:57'!
                   chooseDefiningInstanceVariableAlphabeticallyWith: aCaption thenDo: aBlock ifNone: noneBlock

	| vars index |
	"Put up a menu of the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."

	vars _ self instVarNames sorted.
	vars isEmpty ifTrue: [^ noneBlock value ].

	index _ (PopUpMenu labelArray: vars lines: #()) startUpWithCaption: aCaption.
	index = 0 ifTrue: [^ self].
	aBlock value: (vars at: index)! !
!ClassDescription methodsFor: 'instance variables' stamp: 'HAW 3/4/2019 15:26:00'!
          withClassesThatDefineInHierarchyInstanceVariable: aName do: foundBlock ifNone: noneBlock

	^(self classThatDefinesInstanceVariable: aName)
		ifNil: [ self withSubclassesThatDefineInstanceVariable: aName do: foundBlock ifNone: noneBlock ]
		ifNotNil: [ :definingClass | foundBlock value: (Array with: definingClass) ]! !
!ClassDescription methodsFor: 'instance variables' stamp: 'HAW 3/4/2019 15:26:16'!
             withSubclassesThatDefineInstanceVariable: aName do: foundBlock ifNone: noneBlock

	| definingSubclasses |

	definingSubclasses := self allSubclasses select: [ :aSubclass | aSubclass definesInstanceVariableNamed: aName ].

	^definingSubclasses isEmpty
		ifTrue: noneBlock
		ifFalse: [ foundBlock value: definingSubclasses ]! !
!Class methodsFor: 'class name' stamp: 'HAW 3/4/2019 15:27:49' prior: 16802364!
          rename: aString
	"The new name of the receiver is the argument, aString."

	| newName |
	(newName _ aString asSymbol) ~= self name
		ifFalse: [^ self].
	(Smalltalk includesKey: newName)
		ifTrue: [^ self error: newName , ' already exists'].
	(Undeclared includesKey: newName)
		ifTrue: [self inform: 'There are references to, ' , aString printString , '
from Undeclared. Check them after this change.'].

	self safeRenameTo: newName.! !
!Class methodsFor: 'class name' stamp: 'HAW 3/4/2019 15:27:53'!
           safeRenameTo: newName

	Smalltalk renameClass: self as: newName.
	name _ newName! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 3/4/2019 15:58:45'!
  hasCategory: aCategory

	^self categories includes: aCategory ! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 3/4/2019 15:58:48'!
                    removeSystemCategories: categories

	(self superclassOrderInAll: categories) reverseDo: [ :class | class removeFromSystem].

	categories do: [ :aCategory | self removeCategory: aCategory].
! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 3/4/2019 15:58:52'!
                     superclassOrderInAll: categories

	| classes |

	classes := OrderedCollection new.
	categories do: [ :aCategory | classes addAll: (self classesAt: aCategory)].

	^Array streamContents: [ :stream | Smalltalk hierarchySorted: classes do: [ :aClass | stream nextPut: aClass ]].! !
!Number methodsFor: 'intervals' stamp: 'HAW 3/4/2019 15:29:17'!
          toSelfPlus: aDelta

	^self to: self + aDelta! !
!Collection methodsFor: 'converting' stamp: 'HAW 3/4/2019 15:36:16'!
           as: aPrintingBlock on: aStream delimiter: delimiter last: lastDelimiter

	| position selfSize |

	position := 1.
	selfSize := self size.

	self
		do: [:elem |
			position := position + 1.
			aPrintingBlock value: elem ]
		separatedBy: [
			aStream nextPutAll: (position = selfSize ifTrue: [lastDelimiter] ifFalse: [delimiter])]! !
!Collection methodsFor: 'converting' stamp: 'HAW 3/4/2019 15:36:31'!
                asCommaSeparated: aPrintingBlock on: aStream

	^self as: aPrintingBlock on: aStream delimiter: ', ' last: ' and '! !
!Collection methodsFor: 'converting' stamp: 'HAW 3/4/2019 15:37:03'!
      asCommaStringAnd

	^String streamContents: [:stream | self asStringOn: stream delimiter: ', ' last: ' and ']! !
!Collection methodsFor: 'converting' stamp: 'HAW 3/4/2019 15:37:18'!
           asStringOn: aStream delimiter: delimString last: lastDelimString

	self as: [ :elem | aStream nextPutAll: elem asString ] on: aStream delimiter: delimString last: lastDelimString! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 3/4/2019 15:38:35'!
                        intervalOfSubCollection: aSubCollectionToFind

	| startingIndex |

	startingIndex := self indexOfSubCollection: aSubCollectionToFind startingAt: 1.

	^startingIndex toSelfPlus: aSubCollectionToFind size! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 3/4/2019 15:37:58' prior: 50434267!
                with: otherCollection do: twoArgBlock separatedBy: separatorBlock

	| beforeFirst |

	beforeFirst := true.
	self with: otherCollection do: [ :selfElement :otherCollectionElement |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		twoArgBlock value: selfElement value: otherCollectionElement ].


! !
!String methodsFor: 'copying' stamp: 'HAW 3/4/2019 15:30:11'!
                  copyReplacing: rangesToNewStrings

	^self class streamContents: [ :replacementStream | self copyReplacing: rangesToNewStrings into: replacementStream ].! !
!String methodsFor: 'copying' stamp: 'HAW 3/4/2019 15:30:14'!
      copyReplacing: rangesToNewStrings into: replacementStream

	| lastFrom |

	lastFrom := rangesToNewStrings inject: 1 into: [ :from :aRangeToNewString |
		self
			newFromAfterAppending: aRangeToNewString value
			into: replacementStream
			keepingFrom: from
			skipping: aRangeToNewString key ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).
! !
!String methodsFor: 'copying' stamp: 'HAW 3/4/2019 15:30:18'!
               copyReplacing: ranges with: newString

	"Ranges must be in order, with first ranges first. If not, result is unexpected - Hernan"

	^ self class streamContents: [ :replacementStream | self copyReplacing: ranges with: newString into: replacementStream ]
		! !
!String methodsFor: 'copying' stamp: 'HAW 3/4/2019 15:30:22'!
                               copyReplacing: ranges with: newString into: replacementStream

	| lastFrom |

	lastFrom := ranges
		inject: 1
		into: [ :from :aRange |
			self newFromAfterAppending: newString into: replacementStream keepingFrom: from skipping: aRange ].

	replacementStream nextPutAll: (self copyFrom: lastFrom to: self size).! !
!String methodsFor: 'copying' stamp: 'HAW 3/4/2019 15:30:28'!
       newFromAfterAppending: aNewString into: replacementStream keepingFrom: from skipping: aRange

	replacementStream
		nextPutAll: (self copyFrom: from to: aRange first - 1);
		nextPutAll: aNewString.

	^ aRange last + 1! !
!Symbol class methodsFor: 'instance creation' stamp: 'HAW 3/4/2019 15:31:05'!
                      fromCollectionOfStrings: aCollectionOfStrings

	^self newFrom: aCollectionOfStrings concatenation ! !
!CompiledMethod methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:32:05'!
                    hasArgumentOrTemporary: aVariable

	| methodNode |

	methodNode := self methodNode.

	^methodNode tempNames includes: aVariable ! !
!CompiledMethod methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:33:16'!
                      readsInstanceVariable: aName

	^self readsField: (self methodClass indexOfInstanceVariable: aName) ! !
!CompiledMethod methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:33:41'!
                   referencesParameterAt: parameterIndex

	| methodNode implementorParameterNodeToRemove parameterRanges |

	methodNode := self methodNode.
	implementorParameterNodeToRemove := methodNode arguments at: parameterIndex.
	parameterRanges := methodNode positionsForTemporaryVariable: implementorParameterNodeToRemove name ifAbsent: [#()].

	^parameterRanges size ~= 1! !
!CompiledMethod methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:33:58'!
              sendsOrRefersTo: aSelector

	^ (self hasLiteralThorough: aSelector) or: [ self sendsSelector: aSelector ]! !
!CompiledMethod methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:34:45'!
             writesInstanceVariable: aName

	^self writesField: (self methodClass indexOfInstanceVariable: aName)! !
!CompiledMethod methodsFor: 'printing' stamp: 'HAW 3/4/2019 15:31:47'!
                 classAndSelector

	^String streamContents: [:stream | self printClassAndSelectorOn: stream ]! !
!CompiledMethod methodsFor: 'printing' stamp: 'HAW 3/4/2019 15:32:47'!
                         printClassAndSelectorOn: aStream

	aStream
		print: self methodClass;
		nextPutAll: '>>';
		nextPutAll: self selector storeString! !
!CompiledMethod methodsFor: 'printing' stamp: 'HAW 3/4/2019 15:32:51' prior: 16819891!
    printOn: aStream
	"Overrides method inherited from the byte arrayed collection."

	aStream nextPut: $(.
	self printClassAndSelectorOn: aStream.
	aStream space; nextPut: $".
	self printNameOn: aStream.
	aStream nextPut: $(; print: self identityHash; nextPut: $); nextPut: $"; nextPut: $)! !
!CompiledMethod methodsFor: 'source code management' stamp: 'HAW 3/4/2019 15:34:32'!
         sourceCode

	"This method is implemented because getSource is not so intuitive - Hernan"
	^self getSource! !
!MethodDictionary methodsFor: 'enumeration' stamp: 'HAW 3/4/2019 15:35:17'!
       valuesSelect: aCondition

	| selected |

	selected := OrderedCollection new.
	self valuesDo: [ :aValue | (aCondition value: aValue) ifTrue: [ selected add: aValue ]].

	^selected! !
!Parser class methodsFor: 'parsing' stamp: 'HAW 3/4/2019 15:41:47'!
      parse: sourceCode class: aClass

	^self parse: sourceCode class: aClass noPattern: false! !
!Parser class methodsFor: 'parsing' stamp: 'HAW 3/4/2019 15:41:50'!
parse: sourceCode class: aClass noPattern: aBoolean

	^(self new
		encoderClass: EncoderForV3PlusClosures;
		parse: sourceCode class: aClass noPattern: aBoolean)
			sourceText: sourceCode;
			yourself! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:43:27' prior: 50408653!
   isInstanceVariableNode

	^false! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:43:38' prior: 50408657!
            isMessageNamed: aSelector

	^false! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:43:50'!
                         isReturn

	^false! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:43:53'!
          isTempOrArg

	^false! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:39:58'!
  messageSendKeywordAndParameterPositionsAt: anIndex of: aSelector ifAbsent: aBlock

	| positions |

	positions := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordAndParameterPositionAt: anIndex encodedWith: self].

	^ positions isEmpty
		ifTrue: aBlock
		ifFalse: [ positions ]
	! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:02'!
messageSendKeywordPositionsAt: anIndex of: aSelector ifAbsent: aBlock

	| positions sortedPositions |

	positions := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: [ :aMessageSendNode | (aMessageSendNode keywordPositionAt: anIndex) first ].

	positions isEmpty ifTrue: [ ^aBlock value ].
	sortedPositions := positions asSortedCollection.

	^sortedPositions ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:05'!
                              messageSendLastPositionsOf: aSelector ifAbsent: aBlock

	| positions sortedPositions |

	positions := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: [ :aMessageSendNode | (sourceRanges at: aMessageSendNode) last ].

	positions isEmpty ifTrue: [ ^aBlock value ].
	sortedPositions := positions asSortedCollection.

	^sortedPositions ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:08'!
                        messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock

	| ranges sortedRanges |

	ranges := sourceRanges keys
		select: [ :aParseNode | aParseNode isMessageNamed: aSelector ]
		thenCollect: [ :aMessageSendNode | aMessageSendNode keywordRanges ].

	ranges isEmpty ifTrue: [ ^aBlock value ].
	sortedRanges := ranges asSortedCollection: [ :left :right | left first first < right first first ].

	^sortedRanges ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:12'!
                   parameterDefinitionPositionFor: aParameterNode

	^ (self sourceRangeFor: aParameterNode) first! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:15'!
                        positionsForInstanceVariable: aName ifAbsent: aBlock

	^ self
		rangesForVariable: aName
		checkingType: [ :variableNode | variableNode isInstanceVariableNode ]
		ifAbsent: aBlock ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:19'!
  positionsForLiteralNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litSet at: aName ifAbsent: [ ^aBlock value ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:23'!
  positionsForLiteralVariableNode: aName ifAbsent: aBlock

	| variableNode |

	variableNode := litIndSet values detect: [ :aLiteralVariableNode | aLiteralVariableNode name = aName ] ifNone: [ ^aBlock value ].

	^sourceRanges at: variableNode ifAbsent: aBlock! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:25'!
                      positionsForTemporaryVariable: aName ifAbsent: aBlock

	^ self
		rangesForVariable: aName
		checkingType: [ :variableNode | variableNode isTemp ]
		ifAbsent: aBlock ! !
!Encoder methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:40:29'!
                 positionsOfLiteralArraysContaining: aSymbol

	| positions |

	positions := OrderedCollection new.
	litSet keysAndValuesDo: [ :aLiteral :aLiteralNode |
		(aLiteral isArray and: [ aLiteral hasLiteral: aSymbol ]) ifTrue: [ positions addAll: (sourceRanges at: aLiteralNode) ]].

	^positions ! !
!EncoderForV3PlusClosures methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:41:15'!
             hasLocalNamed: aName

	^ scopeTable includesKey: aName ! !
!LeafNode methodsFor: 'accessing' stamp: 'HAW 3/4/2019 15:44:23'!
   key: aKey

	key := aKey ! !
!VariableNode methodsFor: 'initialization' stamp: 'HAW 3/4/2019 15:51:10'!
                         nameAndKey: aName

	name := key := aName ! !
!InstanceVariableNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:51:26' prior: 50408735!
                       isInstanceVariableNode

	^true! !
!TempVariableNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:51:43'!
                      isTempOrArg

	^self isTemp or: [ self isArg ]! !
!MessageNode methodsFor: 'source ranges' stamp: 'HAW 3/4/2019 15:45:16'!
      keywordAndParameterPositionAt: anIndex encodedWith: anEncoder

	| keywordPosition parameterLastPosition |

	keywordPosition := keywordRanges at: anIndex.
	parameterLastPosition := anIndex = arguments size
		ifTrue: [ (anEncoder sourceRangeFor: self) last ]
		ifFalse: [ (keywordRanges at: anIndex + 1) first - 1].

	^keywordPosition first to: parameterLastPosition! !
!MessageNode methodsFor: 'source ranges' stamp: 'HAW 3/4/2019 15:45:19'!
       keywordPositionAt: anIndex

	^keywordRanges at: anIndex ! !
!MessageNode methodsFor: 'source ranges' stamp: 'HAW 3/4/2019 15:45:22' prior: 50408739!
           keywordRanges

	^keywordRanges! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:44:44' prior: 50408743!
           isMessageNamed: aSelector

	^aSelector == self selectorSymbol ! !
!MessageNode methodsFor: 'accessing' stamp: 'HAW 3/4/2019 16:23:43'!
                         selectorSymbol

	^selector key! !
!MethodNode methodsFor: 'accessing' stamp: 'HAW 3/4/2019 15:46:33' prior: 50434951!
          argumentNames

	^arguments collect: [ :anArgumentNode | anArgumentNode name ]! !
!MethodNode methodsFor: 'accessing' stamp: 'HAW 3/4/2019 15:48:55'!
           tempNodes

	^encoder tempNodes! !
!MethodNode methodsFor: 'printing' stamp: 'HAW 3/4/2019 15:47:01'!
                           classAndSelector

	^self methodClass name, '>>', self selector storeString! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:46:24'!
         addPositionTo: symbolPositions of: symbolString inside: literalArrayPosition

	| insidePosition |

	insidePosition := literalArrayPosition first.
	[ insidePosition < literalArrayPosition last ] whileTrue: [
		insidePosition := self nextPositionAfterAddPositionTo: symbolPositions of: symbolString startingAt: insidePosition ].
	! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:09'!
           messageSendKeywordAndParameterPositionsAt: anIndex of: aSelector ifAbsent: aClosure

	^encoder messageSendKeywordAndParameterPositionsAt: anIndex of: aSelector ifAbsent: aClosure! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:12'!
 messageSendKeywordPositionsAt: anIndex of: aSelector ifAbsent: aBlock

	^encoder messageSendKeywordPositionsAt: anIndex of: aSelector ifAbsent: aBlock
	! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:16'!
                           messageSendLastPositionsOf: aSelector ifAbsent: aBlock

	^encoder messageSendLastPositionsOf: aSelector ifAbsent: aBlock! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:19'!
                           messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock

	^encoder messageSendSelectorKeywordPositionsOf: aSelector ifAbsent: aBlock! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:23'!
     nextPositionAfterAddPositionTo: symbolPositions of: symbolString startingAt: insidePosition

	| symbolStartPosition nextPosition |

	symbolStartPosition := sourceText indexOfSubCollection: symbolString startingAt: insidePosition.

	symbolStartPosition = 0
		ifTrue: [ nextPosition := SmallInteger maxVal ]
		ifFalse: [
			nextPosition := symbolStartPosition + symbolString size.
			(sourceText at: nextPosition) tokenish ifFalse: [ symbolPositions add: (symbolStartPosition to: nextPosition - 1) ]].

	^nextPosition

	! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:27'!
             parameterDefinitionPositionAt: anIndex

	^encoder parameterDefinitionPositionFor: (arguments at: anIndex)! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:30'!
          positionsForInstanceVariable: aName ifAbsent: aBlock

	^encoder positionsForInstanceVariable: aName ifAbsent: aBlock
! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:33'!
                              positionsForLiteralNode: aName ifAbsent: aBlock

	^encoder positionsForLiteralNode: aName ifAbsent: aBlock
! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:36'!
        positionsForLiteralVariableNode: aName ifAbsent: aBlock

	^encoder positionsForLiteralVariableNode: aName ifAbsent: aBlock! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:39'!
                         positionsForTemporaryVariable: aName ifAbsent: aBlock

	^encoder positionsForTemporaryVariable: aName ifAbsent: aBlock! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:42'!
                             positionsInLiteralArrayOf: aSymbol

	| literalArrayPositions |

	literalArrayPositions := encoder positionsOfLiteralArraysContaining: aSymbol.

	^self positionsOf: aSymbol printString containedIn: literalArrayPositions.

! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:45'!
                      positionsOf: symbolString containedIn: literalArrayPositions

	| symbolPositions |

	symbolPositions := OrderedCollection new.

	literalArrayPositions do: [ :literalArrayPosition | self addPositionTo: symbolPositions of: symbolString inside: literalArrayPosition ].

	^symbolPositions




! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:48'!
                  selectorKeywordPositionAt: anIndex

	^selectorKeywordsRanges at: anIndex! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 3/4/2019 15:48:52'!
           selectorKeywordsPositions

	^selectorKeywordsRanges! !
!MethodNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:47:33'!
       hasArgumentOrTemporary: aVariable

	^self tempNames includes: aVariable! !
!MethodNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 16:13:33'!
                   hasLocalNamed: aName

	^ encoder hasLocalNamed: aName ! !
!ReturnNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:50:43'!
    isImplicitSelfReturnIn: aMethodNode

	^self isReturnSelf and: [ (aMethodNode encoder rawSourceRanges includesKey: expr) not ]! !
!ReturnNode methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:50:48'!
                             isReturn

	^true! !
!TextEditor methodsFor: 'accessing' stamp: 'HAW 3/4/2019 15:52:45'!
        actualContents

	^model actualContents ! !
!TextEditor methodsFor: 'accessing' stamp: 'HAW 3/4/2019 15:52:48'!
                 actualContents: aString

	model actualContents: aString ! !
!TextEditor methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:53:18'!
  hasUnacceptedEdits

	^morph hasUnacceptedEdits ! !
!TextEditor methodsFor: 'testing' stamp: 'HAW 3/4/2019 15:53:29'!
           hasUnacceptedEdits: aBoolean

	^morph hasUnacceptedEdits: aBoolean ! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:20'!
        contextualRename

	self
		withMethodNodeAndClassDo: [ :methodNode :classToRefactor | self contextualRenameOf: methodNode in: classToRefactor]
		ifErrorsParsing: [ :anError | morph flash ].

		! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:23'!
           contextualRename: aKeyboardEvent

	self contextualRename.
	^true! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:26'!
           contextualRenameOf: aMethodNode in: aClassToRefactor

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self rename: nodeUnderCursor in: aClassToRefactor ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifTrue: [ self ifRenameCanBeAppliedDo: [ self renameSelectorFor: aMethodNode selector in: aClassToRefactor ]]
				ifFalse: [ morph flash ]]


! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:30'!
                        ifRenameCanBeAppliedDo: aBlock

	^(self hasUnacceptedEdits or: [morph hasEditingConflicts ])
		ifTrue: [ self inform: 'Rename can not be applied becuase there are unsaved changes' ]
		ifFalse: aBlock! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:35'!
    rename: aNodeUnderCursor in: aClassToRefactor

	aNodeUnderCursor isTempOrArg ifTrue: [ ^self renameTemporary: aNodeUnderCursor name ].

	self ifRenameCanBeAppliedDo: [
		aNodeUnderCursor isMessageNode ifTrue: [ ^ self renameSelectorFor: aNodeUnderCursor selector key in: aClassToRefactor ].
		aNodeUnderCursor isInstanceVariableNode ifTrue: [ ^ self renameInstanceVariableOn: self codeProvider for: aNodeUnderCursor name at: aClassToRefactor ].
		aNodeUnderCursor isLiteralVariableNode ifTrue: [ | posibleBehavior |
			posibleBehavior := aNodeUnderCursor key value.
			posibleBehavior isBehavior ifTrue: [ ^self renameClassOn: self codeProvider for: posibleBehavior theNonMetaClass ]].

		^morph flash ]! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:38'!
            renameClassOn: aBrowser for: aClassToRefactor

	(RenameClassApplier on: aBrowser for: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:41'!
                              renameInstanceVariableOn: aBrowser for: anInstanceVariableName at: aClassToRefactor

	(RenameInstanceVariableApplier on: aBrowser for: anInstanceVariableName at: aClassToRefactor) value! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:45'!
                  renameSelectorFor: aSelector in: aClassToRefactor

	RenameSelectorApplier createAndValueHandlingExceptions: [ RenameSelectorApplier on: model textProvider for: aSelector in: aClassToRefactor ]! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:49'!
           renameTemporary: aTemporaryName

	self codeProvider isEditingMethod ifTrue: [ | applier |
		[ applier := RenameTemporaryApplier on: self for: aTemporaryName ]
			on: SyntaxErrorNotification
			do: [:anError | ^self inform: (RenameTemporaryApplier errorMessageForCanNotParseMethod: anError) ].
		applier value ].
! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/4/2019 15:57:52'!
                   withMethodNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| class methodNode |

	class := self codeProvider selectedClassOrMetaClass.
	methodNode := [ class methodNodeFor: model actualContents ] on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: class.! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 15:59:35'!
  addInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(AddInstanceVariableApplier on: model for: aClass) value ].! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 15:59:38'!
                   addParameter

	model selectedMessageName ifNotNil: [ :oldSelector |
		AddParameterApplier createAndValueHandlingExceptions: [ AddParameterApplier on: model for: oldSelector in: model selectedClassOrMetaClass ]]! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 15:59:41'!
classRefactoringMenu

	^DynamicMenuBuilder buildTitled: 'Refactorings' targeting: self collectingMenuOptionsWith: #classRefactoringMenuOptions.! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 15:59:47'!
   messageRefactoringMenu

	^DynamicMenuBuilder buildTitled: 'Refactorings' targeting: self collectingMenuOptionsWith: #messsageRefactoringMenuOptions.! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 15:59:50'!
                              openClassRefactoringMenu

	^self classRefactoringMenu popUpInWorld! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 15:59:53'!
                openMessageRefactoringMenu

	^self messageRefactoringMenu popUpInWorld! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:00:10'!
            pushUpSelector

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(PushUpMethod for: model selectedClassOrMetaClass>>selectedSelector) apply.
		model messageListIndex: 0.
		model changed: #messageList.
		model setClassOrganizer ].! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:00:13'!
 removeAllUnreferencedInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveAllUnreferencedInstanceVariablesApplier on: model for: aClass) value ].! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:00:16'!
              removeInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RemoveInstanceVariableApplier on: model for: aClass) value ].! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:00:23'!
             removeParameter

	model selectedMessageName ifNotNil: [ :oldSelector |
		RemoveParameterApplier createAndValueHandlingExceptions: [
			RemoveParameterApplier on: model for: oldSelector in: model selectedClassOrMetaClass ]]! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:00:26'!
                    renameInstVar

	model selectedClassOrMetaClass ifNotNil: [ :aClass |
		(RenameInstanceVariableApplier on: model at: aClass) value ].! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/4/2019 16:00:30'!
              renameSelector

	model selectedMessageName ifNotNil: [ :oldSelector |
		RenameSelectorApplier createAndValueHandlingExceptions: [ RenameSelectorApplier on: model for: oldSelector in: model selectedClassOrMetaClass ]].! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'HAW 3/4/2019 16:01:36' prior: 16870560!
     openFullProtocolForClass: aClass
	"Create and schedule a browser for the entire protocol of the class."
	"ProtocolBrowser openFullProtocolForClass: ProtocolBrowser."

	| aPBrowser label |

	aPBrowser _ ProtocolBrowser new on: aClass.
	label _ 'Entire protocol of: ', aClass name.

	^self open: aPBrowser label: label! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'HAW 3/4/2019 16:01:39' prior: 50343735!
  openMessageList: anArray label: aString
	"Create a standard system view for the message set on the list, anArray.
	The label of the view is aString."

	^self open: (MessageSet messageList: anArray) label: aString! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'HAW 3/4/2019 16:01:42' prior: 16870583!
          openMessageList: messageList label: labelString autoSelect: autoSelectString
	"Open a system view for a MessageSet on messageList.
	 1/24/96 sw: the there-are-no msg now supplied by my sender"

	| messageSet |

	messageSet _ MessageSet messageList: messageList.
	messageSet autoSelectString: autoSelectString.

	^self open: messageSet label: labelString ! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'HAW 3/4/2019 16:01:46' prior: 16870597!
                            openSubProtocolForClass: aClass
	"Create and schedule a browser for the entire protocol of the class."
	"ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."

	| aPBrowser label |

	aPBrowser _ ProtocolBrowser new onSubProtocolOf: aClass.
	label _ 'Sub-protocol of: ', aClass name.

	^self open: aPBrowser label: label! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'HAW 3/4/2019 15:24:22' prior: 50438583!
        compileNewImplementorOf: anImplementor

	| implementorClassification newSourceCode |

	newSourceCode := self implementorNewSourceCodeOf: anImplementor.
	implementorClassification := anImplementor methodClass organization categoryOfElement: oldSelector.

	anImplementor methodClass
		compile: newSourceCode
		classified: implementorClassification.
! !
!PushUpMethod methodsFor: 'applying' stamp: 'HAW 3/4/2019 15:23:40' prior: 50440570!
            apply

	| methodCategory |

	methodCategory := method methodClass organization categoryOfElement: method selector.
	method methodClass superclass
		compile: method sourceCode
		classified: methodCategory.

	method methodClass removeSelector: method selector.
 ! !

MethodNode removeSelector: #selectorKeywordsRanges!

MethodNode removeSelector: #selectorKeywordsRanges!

ClassDescription removeSelector: #compile:classifyUnder:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3639-Refactorings-part2-HernanWilkinson-2019Mar03-08h04m-HAW.4xx.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3641] on 6 March 2019 at 4:12:06 pm'!
!ProgressiveTestRunner methodsFor: 'evaluating' stamp: 'HAW 3/6/2019 15:35:58' prior: 50338120!
 value

	Utilities authorInitials.
	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3640-ProgressiveTestRunner-HernanWilkinson-2019Mar06-15h06m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3637] on 6 March 2019 at 12:20:34 pm'!

Encoder removeSelector: #bindTemp:in:!

Encoder removeSelector: #bindTemp:in:!

Parser removeSelector: #bindTemp:in:!

Parser removeSelector: #bindTemp:in:!

Parser removeSelector: #temporariesIn:!

Parser removeSelector: #temporariesIn:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3641-Cleanup-JuanVuletich-2019Mar06-12h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3637] on 6 March 2019 at 12:21:07 pm'!
!Encoder methodsFor: 'encoding' stamp: 'jmv 3/6/2019 12:06:54' prior: 16837538!
                 undeclared: name
	| sym |
	requestor interactive ifTrue: [
		 ^self notify: 'Undeclared'].
	"Allow knowlegeable clients to squash the undeclared warning if they want (e.g.
	 Diffing pretty printers that are simply formatting text).  As this breaks
	 compilation it should only be used by clients that want to discard the result
	 of the compilation.  To squash the warning use e.g.
		[Compiler format: code in: class notifying: nil decorated: false]
			on: UndeclaredVariableWarning
			do: [:ex| ex resume: false]"
	sym := name asSymbol.
	^(UndeclaredVariableWarning new name: name selector: selector class: class) signal
		ifTrue:
			[Undeclared at: sym put: nil.
			self global: (Undeclared associationAt: sym) name: sym]
		ifFalse:
			[self global: (Association key: sym) name: sym]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3642-Cleanup-JuanVuletich-2019Mar06-12h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3639] on 6 March 2019 at 1:08:21 pm'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 3/6/2019 13:07:59' prior: 16806925!
              printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asString printString]
		ifFalse: [preamble _ ''].
	method _ self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR  -  THIS METHOD IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos _ method filePosition) = 0])
	ifTrue: [
		"The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [ outStream newLine; nextPut: $!!; nextChunkPut: preamble; newLine].
		outStream nextChunkPut: method decompileString]
	ifFalse: [
		sourceFile _ SourceFiles at: method fileIndex.
		preamble size > 0
			ifTrue:    "Copy the preamble"
				[outStream copyPreamble: preamble from: sourceFile at: oldPos]
			ifFalse:
				[sourceFile position: oldPos].
		"Copy the method chunk"
		fileIndex = 0 ifFalse: [
			outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
		newPos _ outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		moveSource ifTrue: [    "Set the new method source pointer"
			endPos _ outStream position.
			method checkOKToAdd: endPos - newPos at: newPos in: method fileIndex.
			method setSourcePosition: newPos inFile: fileIndex]].
	preamble size > 0 ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream newLine! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3643-BetterMissingMethodText-JuanVuletich-2019Mar06-13h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3640] on 7 March 2019 at 12:04:56 pm'!

Error subclass: #RecompilationFailure
	instanceVariableNames: 'class selector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #RecompilationFailure category: #'Exceptions Kernel'!
Error subclass: #RecompilationFailure
	instanceVariableNames: 'class selector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!RecompilationFailure commentStamp: 'jmv 3/7/2019 11:39:10' prior: 0!
       Recompilation of some existing method failed.

The usual handling of this exception should be to cancel the action that triggered recompilation. If not handled, a debugger will open.!
!RecompilationFailure methodsFor: 'accessing' stamp: 'jmv 3/7/2019 12:02:40'!
                          messageText
	^ 'In method ', class name,'>>', selector asString,' ', messageText! !
!RecompilationFailure methodsFor: 'private' stamp: 'jmv 3/7/2019 11:28:08'!
class: aClass selector: aSymbol messageText: aString
	class _ aClass.
	selector _ aSymbol.
	messageText _ aString! !
!RecompilationFailure class methodsFor: 'instance creation' stamp: 'jmv 3/7/2019 11:28:18'!
               class: aClass selector: aSymbol messageText: aString
	^ self new class: aClass selector: aSymbol messageText: aString! !
!Browser methodsFor: '*LiveTyping' stamp: 'jmv 3/7/2019 12:03:38' prior: 16791377!
                    contents: input notifying: aRequestor
	"The retrieved information has changed and its source must now be
	 updated. The information can be a variety of things, depending on
	 the list selections (such as templates for class or message definition,
	 methods) or the user menu commands (such as definition, comment,
	 hierarchy).  Answer the result of updating the source."

	| aString aText theClass |
	aString _ input asString.
	aText _ input asText.
	editSelection == #editSystemCategories ifTrue: [ ^ self changeSystemCategories: aString ].
	editSelection == #editClass | (editSelection == #newClass) ifTrue: [
		[
			self defineClass: aString notifying: aRequestor 
		] on: RecompilationFailure do: [ :ex |
			self inform: ex messageText.
			^ false].
		^ true].
	editSelection == #editComment
		ifTrue: [
			theClass _ self selectedClass.
			theClass
				ifNil: [
					self inform: 'You must select a class
before giving it a comment.'.
					^ false].
			theClass comment: aText stamp: Utilities changeStamp.
			self changed: #classCommentText.
			^ true].
	editSelection == #hierarchy ifTrue: [ ^ true ].
	editSelection == #editMessageCategories ifTrue: [ ^ self changeMessageCategories: aString ].
	editSelection == #editMessage | (editSelection == #newMessage)
		ifTrue: [
			^ self okayToAccept
				ifFalse:[ false ]
				ifTrue: [
					(self compileMessage: aText notifying: aRequestor)
						ifTrue: [ self triggerEvent: #annotationChanged ];
						yourself ]].
	editSelection == #none
		ifTrue: [
			self inform: 'This text cannot be accepted
in this part of the browser.'.
			^ false].
	self error: 'unacceptable accept'! !
!Encoder methodsFor: 'private' stamp: 'jmv 3/7/2019 12:02:44' prior: 16837633!
              warnAboutShadowed: name
	| msg fullMsg |
	msg _ 'There already exists a variable named ', name, ' '.
	fullMsg _ class name,'>>', selector asString, ' ', msg.
	requestor addWarning: fullMsg.
	Transcript newLine; show: fullMsg.
	InMidstOfFileinNotification signal
		ifFalse: [
			requestor interactive
				ifTrue: [
					self notify: msg]
				ifFalse: [
					(RecompilationFailure
						class: class
						selector: selector
						messageText: msg, String newLineString, 'Please use a different name') signal ]]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3644-DontAllowVariableShadowing-JuanVuletich-2019Mar07-11h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3645] on 7 March 2019 at 2:53:00 pm'!

"Change Set:		3645-CuisCore-AuthorName-2019Mar07-13h02m
Date:			7 March 2019
Author:			Hernan Wilkinson
Removes empty categories and recategorized methods
"
MethodReference organization
	classify: #printOn: under: 'printing'.
Browser organization
	classify: #classDefinitionText under: 'class functions';
	classify: #contents:notifying: under: 'accessing';
	classify: #selectedMessage under: 'message list'.
MessageSet organization
	classify: #contents:notifying: under: 'accessing';
	classify: #selectedMessage under: 'message list'.
Debugger organization
	classify: #askForSuperclassOf:toImplement:ifCancel: under: 'method creation'.
CompiledMethod organization
	classify: #printOn: under: 'printing'.
CodeProvider organization
	classify: #isModeStyleable under: 'shout styling';
	classify: #contentsSymbolQuints under: 'controls'.
ProtoObject withAllSubclassesDo: [ :class | class organization removeEmptyCategories ].
!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3645-MethodRecategorization-HernanWilkinson-2019Mar07-13h02m-HAW.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3645] on 7 March 2019 at 4:30:23 pm'!
!Browser methodsFor: 'class functions' stamp: 'HAW 3/7/2019 16:29:51' prior: 16791532!
  classDefinitionText
	"return the text to display for the definition of the currently selected class"
	
	^self selectedClassOrMetaClass 
		ifNil: [''] 
 		ifNotNil: [ :theClass | theClass definition]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3646-classDefinition-HernanWilkinson-2019Mar07-14h53m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3645] on 7 March 2019 at 4:44:03 pm'!
!MethodReference methodsFor: 'printing' stamp: 'HAW 3/7/2019 16:41:54'!
 printClassAndSelectorOn: aStream
		
	aStream nextPutAll: classSymbol.
	classIsMeta ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: '>>#';
		nextPutAll: methodSymbol! !
!MethodReference methodsFor: 'printing' stamp: 'HAW 3/7/2019 16:43:30' prior: 50364601!
               printOn: aStream
	"Print the receiver on a stream"

	super printOn: aStream.
	aStream space.
	self printClassAndSelectorOn: aStream! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3647-MethodReferencePrintOn-HernanWilkinson-2019Mar07-16h30m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3647] on 7 March 2019 at 5:16:10 pm'!
!TestSuite class methodsFor: 'instance creation - private' stamp: 'HAW 3/7/2019 17:15:17' prior: 50338298!
                          forClasses: classes named: aName

	| suite |
	
	suite _ classes
		inject: (self named: aName)
		into: [ :partialSuite :aClass | partialSuite addTests: (self forClass: aClass) tests ].
		
	^suite
		
! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3648-TestSuiteVarShadowing-HernanWilkinson-2019Mar07-17h04m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3647] on 7 March 2019 at 5:29:58 pm'!
!InsertSuperclass methodsFor: 'applying - private' stamp: 'HAW 3/7/2019 17:28:52'!
                changeSuperclassTo: newSuperclass
	
	newSuperclass subclass: classToRefactor name
		instanceVariableNames: classToRefactor instanceVariablesString 
		classVariableNames: classToRefactor classVariablesString 
		poolDictionaries: classToRefactor sharedPoolsString
		category: classToRefactor category.! !
!FileList methodsFor: 'volume list and pattern' stamp: 'HAW 3/7/2019 17:27:14' prior: 16842796!
                 doesPattern: aPattern allow: entry 

	^(aPattern = '*' or: [ aPattern match: entry name ]) and: [
		"Hide Mac resurce forks and folder service stores"
		(entry name = '.DS_Store') not and: [
		('._*' match: entry name) not ]]! !
!InsertSuperclass methodsFor: 'applying' stamp: 'HAW 3/7/2019 17:29:03' prior: 50440505!
  apply

	| newSuperclass |
	
	newSuperclass := self createSuperclass.
	self changeSuperclassTo: newSuperclass.

	^newSuperclass ! !

InsertSuperclass removeSelector: #changeSuperclassOf:to:!

InsertSuperclass removeSelector: #changeSuperclassOf:to:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3649-MoreVariablesShadowingFixes-HernanWilkinson-2019Mar07-17h16m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3649] on 8 March 2019 at 11:29:51 am'!
!DummyStream methodsFor: 'as yet unclassified' stamp: 'jmv 3/8/2019 10:17:33'!
                              padToEndIfCantTruncate
	"Only makes sense for file streams with existing content."! !
!Morph methodsFor: 'as yet unclassified' stamp: 'jmv 3/8/2019 11:24:08'!
 whenUIinSafeState: evaluableObject
	self world
		ifNotNil: [ :w | w whenUIinSafeState: evaluableObject ]
		ifNil: evaluableObject! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 3/8/2019 11:29:08'!
                    updatePositionAndExtent
	| h w newExtent |
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: 200) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	newExtent _ w@h.
	self world
		ifNotNil: [ :world | self morphPosition: world morphExtent - newExtent // 2 extent: newExtent ]
		ifNil: [ self morphExtent: newExtent ]! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 3/8/2019 11:27:03' prior: 16896249!
    label: aString subLabel: otherString
	self whenUIinSafeState: [
		labelMorph contents: aString.
		subLabelMorph contents: otherString.
		self updatePositionAndExtent. ]! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 3/8/2019 11:24:39' prior: 16896255!
                             subLabel: aString
	self whenUIinSafeState: [
		subLabelMorph contents: aString.
		self updatePositionAndExtent. ]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 3/8/2019 11:18:58' prior: 16896278!
               openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self updatePositionAndExtent.
	labelMorph fitContents.
	subLabelMorph fitContents.
	layoutNeeded _ true.! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3650-CenterProgressMorph-JuanVuletich-2019Mar08-11h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3649] on 7 March 2019 at 11:05:12 pm'!
!ExtractToTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 3/7/2019 22:52:44'!
                          assert: aNewVariable isNotDefinedAsInstanceVariableInHierarchyOf: aClass 
	
	| classDefiningNewVariable |
	
	classDefiningNewVariable := aClass whichClassDefinesInstanceVariable: aNewVariable ifNone: [ ^self ].
	self signal: aNewVariable canNotHideInstanceVariableDefinedIn: classDefiningNewVariable ! !
!ExtractToTemporary class methodsFor: 'warnings' stamp: 'HAW 3/7/2019 22:54:39'!
                               errorMessageFor: aNewVariable canNotBeNamedAsInstanceVariableDefinedIn: aClass

	^aNewVariable, ' can not be named as instance variable defined in ', aClass name! !
!ExtractToTemporary class methodsFor: 'warnings' stamp: 'HAW 3/7/2019 22:54:39'!
          signal: aNewVariable canNotHideInstanceVariableDefinedIn: aClass 

	self refactoringError: (self errorMessageFor: aNewVariable canNotBeNamedAsInstanceVariableDefinedIn: aClass)! !
!RenameTemporary class methodsFor: 'pre-conditions' stamp: 'HAW 3/7/2019 22:52:44'!
                        assert: aNewVariable isNotDefinedAsInstanceVariableInHierarchyOf: aClass 
	
	| classDefiningNewVariable |
	
	classDefiningNewVariable := aClass whichClassDefinesInstanceVariable: aNewVariable ifNone: [ ^self ].
	self signal: aNewVariable canNotHideInstanceVariableDefinedIn: classDefiningNewVariable ! !
!RenameTemporary class methodsFor: 'warnings' stamp: 'HAW 3/7/2019 22:54:39'!
  errorMessageFor: aNewVariable canNotBeNamedAsInstanceVariableDefinedIn: aClass

	^aNewVariable, ' can not be named as instance variable defined in ', aClass name! !
!RenameTemporary class methodsFor: 'warnings' stamp: 'HAW 3/7/2019 22:54:39'!
             signal: aNewVariable canNotHideInstanceVariableDefinedIn: aClass 

	self refactoringError: (self errorMessageFor: aNewVariable canNotBeNamedAsInstanceVariableDefinedIn: aClass)! !
!NewInstanceVariablePrecondition methodsFor: 'warnings' stamp: 'HAW 3/7/2019 22:29:07'!
                    assertIsDefinedInMethods
	
	| methodsDefiningNewVariable |
	
	methodsDefiningNewVariable := self methodsDefiningNewVariable.
	
	methodsDefiningNewVariable notEmpty ifTrue: [ self signalNewVariable: instVarName willBeHiddenAtAll: methodsDefiningNewVariable ].! !
!NewInstanceVariablePrecondition methodsFor: 'warnings' stamp: 'HAW 3/7/2019 22:29:57'!
  signalNewVariable: newVariable willBeHiddenAtAll: methods

	^ self refactoringError: (self class errorMessageForNewVariable: newVariable willBeHiddenAtAll: methods).! !
!NewInstanceVariablePrecondition class methodsFor: 'warning messages' stamp: 'HAW 3/7/2019 23:02:55'!
                 errorMessageForNewVariable: newVariable willBeHiddenAtAll: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: newVariable;
			nextPutAll: ' can not be named as temporary/parameter in '.
		methods asCommaSeparated: [:aMethod | aMethod printClassAndSelectorOn: stream ] on: stream ]! !
!ExtractToTemporary class methodsFor: 'instance creation' stamp: 'HAW 3/7/2019 22:51:29' prior: 50440394!
      named: aNewVariable at: anIntervalToExtract from: aMethodSourceCode in: aClass

	|  trimmedNewVariable parseNodeToExtract trimmedSourceCodeToExtract methodNodeToExtract methodNodeToRefactor sourceCodeToExtract |
	
	trimmedNewVariable := aNewVariable withBlanksTrimmed.
	methodNodeToRefactor := aClass methodNodeFor: aMethodSourceCode.
	
	self assertIsNotEmpty: trimmedNewVariable.
	self assertIsValidVariableName: trimmedNewVariable.
	self assert: trimmedNewVariable isNotDefinedIn: methodNodeToRefactor.
	
	sourceCodeToExtract := aMethodSourceCode copyFrom: anIntervalToExtract first to: anIntervalToExtract last.
	trimmedSourceCodeToExtract := sourceCodeToExtract withBlanksTrimmed.
	self assertSourceCodeIsNotEmpty: trimmedSourceCodeToExtract.
	self assertIsNotReturn: trimmedSourceCodeToExtract. 
	self assert: trimmedSourceCodeToExtract isIncludedIn: methodNodeToRefactor.

	[ methodNodeToExtract := Parser parse: trimmedSourceCodeToExtract class: methodNodeToRefactor methodClass noPattern: true ]
		on: SyntaxErrorNotification 
		do: [ :anError | self signalColaborationToExtractHasSyntaxError: anError ].
	
	parseNodeToExtract := self paseNodeToExtractFrom: methodNodeToExtract. 

	self assert: trimmedNewVariable isNotDefinedAsInstanceVariableInHierarchyOf: methodNodeToRefactor methodClass.

	^self new initializeNamed: trimmedNewVariable with: parseNodeToExtract in: methodNodeToRefactor
 
	! !
!ExtractToTemporary class methodsFor: 'instance creation' stamp: 'HAW 3/7/2019 22:51:29' prior: 50440441!
                        named: aNewVariable with: aSourceCodeToExtract in: aMethodNodeToRefactor

	|  trimmedNewVariable parseNodeToExtract trimmedSourceCodeToExtract methodNodeToExtract |
	
	trimmedNewVariable := aNewVariable withBlanksTrimmed.
	
	self assertIsNotEmpty: trimmedNewVariable.
	self assertIsValidVariableName: trimmedNewVariable.
	self assert: trimmedNewVariable isNotDefinedIn: aMethodNodeToRefactor.
	
	trimmedSourceCodeToExtract := aSourceCodeToExtract withBlanksTrimmed.
	self assertSourceCodeIsNotEmpty: trimmedSourceCodeToExtract.
	self assertIsNotReturn: trimmedSourceCodeToExtract. 
	self assert: trimmedSourceCodeToExtract isIncludedIn: aMethodNodeToRefactor.

	[ methodNodeToExtract := Parser parse: trimmedSourceCodeToExtract class: aMethodNodeToRefactor methodClass noPattern: true ]
		on: SyntaxErrorNotification 
		do: [ :anError | self signalColaborationToExtractHasSyntaxError: anError ].
	
	parseNodeToExtract := self paseNodeToExtractFrom: methodNodeToExtract. 

	self assert: trimmedNewVariable isNotDefinedAsInstanceVariableInHierarchyOf: aMethodNodeToRefactor methodClass.

	^self new initializeNamed: trimmedNewVariable with: parseNodeToExtract in: aMethodNodeToRefactor
 
	! !
!RenameTemporary class methodsFor: 'instance creation' stamp: 'HAW 3/7/2019 22:51:29' prior: 50441140!
                  from: anOldVariable to: aNewVariable in: aMethodNode

	|  trimmedNewVariable |
	
	trimmedNewVariable := aNewVariable withBlanksTrimmed.
	
	self assert: anOldVariable isDefinedIn: aMethodNode.
	self assertIsNotEmpty: trimmedNewVariable.
	self assertIsValidVariableName: trimmedNewVariable.
	self assert: trimmedNewVariable isNotDefinedIn: aMethodNode.
	
	self assert: trimmedNewVariable isNotDefinedAsInstanceVariableInHierarchyOf: aMethodNode methodClass.
	
	^self new initializeFrom: anOldVariable to: trimmedNewVariable in: aMethodNode
! !
!NewInstanceVariablePrecondition methodsFor: 'evaluating' stamp: 'HAW 3/7/2019 22:28:38' prior: 50442733!
                        value
	
	self assertIsNotEmpty.
	self assertIsNotAReservedName.
	self assertIsValidInstanceVariableName.
	self assertIsNotAlreadyDefined.

	self assertIsDefinedInMethods.! !

NewInstanceVariablePrecondition class removeSelector: #warningMessageForNewVariable:willBeHiddenAtAll:!

NewInstanceVariablePrecondition class removeSelector: #warningMessageForNewVariable:willBeHiddenAtAll:!

NewInstanceVariablePrecondition removeSelector: #warnIfIsDefinedInMethods!

NewInstanceVariablePrecondition removeSelector: #warnIfIsDefinedInMethods!

NewInstanceVariablePrecondition removeSelector: #warnNewVariable:willBeHiddenAtAll:!

NewInstanceVariablePrecondition removeSelector: #warnNewVariable:willBeHiddenAtAll:!

RenameTemporary class removeSelector: #errorMessageFor:canNotHideInstanceVariableDefinedIn:!

RenameTemporary class removeSelector: #warn:willHideInstanceVariableDefinedIn:!

RenameTemporary class removeSelector: #warn:willHideInstanceVariableDefinedIn:!

RenameTemporary class removeSelector: #warnIf:isDefinedAsInstanceVariableInHierarchyOf:!

RenameTemporary class removeSelector: #warnIf:isDefinedAsInstanceVariableInHierarchyOf:!

RenameTemporary class removeSelector: #warningMessageFor:willHideInstanceVariableDefinedIn:!

RenameTemporary class removeSelector: #warningMessageFor:willHideInstanceVariableDefinedIn:!

ExtractToTemporary class removeSelector: #errorMessageFor:canNotHideInstanceVariableDefinedIn:!

ExtractToTemporary class removeSelector: #warn:willHideInstanceVariableDefinedIn:!

ExtractToTemporary class removeSelector: #warn:willHideInstanceVariableDefinedIn:!

ExtractToTemporary class removeSelector: #warnIf:isDefinedAsInstanceVariableInHierarchyOf:!

ExtractToTemporary class removeSelector: #warnIf:isDefinedAsInstanceVariableInHierarchyOf:!

ExtractToTemporary class removeSelector: #warningMessageFor:willHideInstanceVariableDefinedIn:!

ExtractToTemporary class removeSelector: #warningMessageFor:willHideInstanceVariableDefinedIn:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3651-RefactoringFailsWhenHiddingVariable-HernanWilkinson-2019Mar07-22h09m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3651] on 10 March 2019 at 2:42:17 pm'!
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 3/10/2019 14:41:35' prior: 50444407!
             updatePositionAndExtent
	| w newExtent |
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: 200) + 8.
	newExtent _ w > extent x
		ifTrue: [ w+10@(labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10) ]
		ifFalse: [ extent ].
	self world
		ifNotNil: [ :world | self morphPosition: world morphExtent - newExtent // 2 extent: newExtent ]
		ifNil: [ self morphExtent: newExtent ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3652-CenterProgressMorphTweak-JuanVuletich-2019Mar10-14h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3652] on 11 March 2019 at 3:12:20 pm'!
!TestCase methodsFor: 'assertions' stamp: 'jmv 3/11/2019 15:05:47'!
                       shouldFix: aBlock
	"Currently disable execution on a Block.
	The test fails, but it is an expected failure.
	Still, the failure should eventually be fixed."! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3653-TestCase-shouldFix-JuanVuletich-2019Mar11-14h59m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3652] on 11 March 2019 at 9:09:24 am'!
!Compiler methodsFor: 'public access' stamp: 'HAW 3/11/2019 09:04:53'!
           compileDoIt: textOrStream in: aClass context: aContext notifying: aRequestor ifFail: failBlock
	"Similar to #compile:in:notifying:ifFail:, but the compiled code is
	expected to be a do-it expression, with no message pattern."

	self from: textOrStream
		class: aClass
		context: aContext
		notifying: aRequestor.
	^self
		translate: sourceStream
		noPattern: false
		doIt: true
		ifFail: failBlock! !
!Compiler methodsFor: 'private' stamp: 'HAW 3/11/2019 09:04:33'!
              translate: aStream noPattern: noPattern doIt: doIt ifFail: failBlock

	^self parser
		sourceStreamGetter: sourceStreamGetter;			"Cuis specific. Do not remove!!"
		ignoreBacktick: false;
		parse: aStream
		class: class
		category: category
		noPattern: noPattern
		doIt: doIt
		context: context
		notifying: requestor
		ifFail: [^failBlock value]! !
!Scanner class methodsFor: 'doIt selectors' stamp: 'HAW 3/11/2019 09:00:46'!
                      doItInSelector

	^#DoItIn:! !
!Scanner class methodsFor: 'doIt selectors' stamp: 'HAW 3/11/2019 09:00:54'!
                     doItSelector

	^#DoIt! !
!Parser methodsFor: 'expression types' stamp: 'HAW 3/11/2019 09:01:34'!
                               method: noPattern doIt: doIt context: ctxt 
	" pattern [ | temporaries ] block => MethodNode."

	| sap block primitives temporaries messageComment methodNode |
	
	sap := self pattern: noPattern inContext: ctxt.
	"sap={selector, arguments, precedence}"
	self properties selector: (sap at: 1).
	encoder selector: (sap at: 1).
	(sap at: 2) do: [:argNode | argNode beMethodArg].
	
	doIt ifFalse: [self pragmaSequence].
	temporaries := self temporaries.
	messageComment := currentComment.
	currentComment := nil.
	doIt ifFalse: [self pragmaSequence].
	primitives := self pragmaPrimitives.
	
	self statements: #() innerBlock: doIt.
	block := parseNode.
	doIt 
		ifTrue: [block returnLast]
		ifFalse: [block returnSelfIfNoOther: encoder].
	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].
	
	methodNode := self newMethodNode comment: messageComment.
	methodNode
		selector: (sap at: 1)
		arguments: (sap at: 2)
		precedence: (sap at: 3)
		temporaries: temporaries
		block: block
		encoder: encoder
		primitive: primitives
		properties: properties
		selectorKeywordsRanges: (sap at: 4).
		
	self interactive ifTrue: [ self performInteractiveChecks: methodNode ].
	
	^methodNode! !
!Parser methodsFor: 'public access' stamp: 'HAW 3/11/2019 09:02:15'!
                          parse: sourceStream class: class category: aCategory noPattern: noPattern doIt: doIt context: aContext notifying: aRequestor ifFail: aBlock

	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	
	| methNode repeatNeeded myStream sourceCode startPosition |
	
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		startPosition _ myStream position.
		sourceCode _ myStream upToEnd.
		myStream position: startPosition.
		self encoder init: class context: aContext notifying: self.
		self init: myStream notifying: aRequestor failBlock: [^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern doIt: doIt context: aContext ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ sourceStreamGetter notNil 	"Cuis specific. Do not remove!!"
					ifTrue: [ requestor perform: sourceStreamGetter ]
					ifFalse: [ ReadStream on: requestor text string ]].
		repeatNeeded
	] whileTrue: [ encoder _ self encoder class new ].

	methNode sourceText: sourceCode.
	"See #xBacktick"
	sentInLiterals do: [ :sym | encoder noteOptimizedSelector: sym ].

	^ methNode! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3654-DebugginSourceCode1-HernanWilkinson-2019Mar11-09h00m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3651] on 11 March 2019 at 9:12:47 am'!
!CompiledMethod methodsFor: 'decompiling' stamp: 'HAW 3/11/2019 08:53:25'!
            createMethodNode

	"Creates the parse tree that represents self"
	
	| aClass source |
	
	aClass := self methodClass.
	source := self
		getSourceFor: (self selector ifNil: [self defaultSelector])
		in: aClass.
				
	^ aClass methodNodeFor: source
	! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'HAW 3/9/2019 02:52:10'!
                   methodNode: aMethodNode

	self propertyValueAt: #methodNode put: aMethodNode! !
!Compiler methodsFor: 'public access' stamp: 'HAW 3/11/2019 06:35:05'!
         evaluateMethod: method to: receiver logged: doLog profiled: doProfile
	
	"See evaluate:in:to:notifying:ifFail:logged:profiled:
	It does the same but without compiling because it recevies the result of the compilation 
	as the parameter method. 
	self should have compile method"

	| value toLog itsSelection itsSelectionString |
	
	"(jmv) Log before evaluating. This way, if the evaluation is halted by whatever reason, it is logged anyway"
	doLog ifTrue: [
		toLog _ ((requestor respondsTo: #selection)  
			and: [ (itsSelection _ requestor selection) notNil
			and: [ (itsSelectionString _ itsSelection asString) isEmptyOrNil not ]])
				ifTrue: [ itsSelectionString ]
				ifFalse: [ sourceStream contents ].
		SystemChangeNotifier uniqueInstance evaluated: toLog context: context ].

	"Evaluate now."
	doProfile
		ifTrue: [
			AndreasSystemProfiler spyOn: [
				value _ receiver
					withArgs: (context ifNil: [#()] ifNotNil: [{context}])
					executeMethod: method ]]
		ifFalse: [
			value _ receiver
				withArgs: (context ifNil: [#()] ifNotNil: [{context}])
				executeMethod: method ].

	^ value! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'HAW 3/11/2019 08:34:11'!
       compileSelectionFor: anObject in: evalContext ifFail: failBlock

	| methodNode method sourceCode compiler |

	sourceCode := self selectionDoItSourceCodeIn: evalContext.
	
	methodNode _ [
		compiler _ Compiler new.
		compiler
			sourceStreamGetter: #selectionAsStream;		"Cuis specific. Do not remove!!"		
			compileDoIt: sourceCode
			in: anObject class
			context: evalContext
			notifying: self
			ifFail: [ ^ failBlock value ]]
		on: OutOfScopeNotification
		do: [ :ex | ex resume: true ].

	methodNode block returnLast.
	method _ methodNode generate.
	method methodNode: methodNode.

	^{ #method -> method. #compiler -> compiler } asDictionary 
! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'HAW 3/11/2019 08:57:46'!
             selectionDoItSourceCodeIn: evalContext

	^String streamContents: [ :stream |
		"I use previousContext and not ThisContext as in the parser to avoid
		name collision. Also, previousContext is more intention revealing - Hernan"
		stream
			nextPutAll: (evalContext ifNil: [ Scanner doItSelector ] ifNotNil: [ Scanner doItInSelector, ' previousContext' ]);
			newLine;
			newLine;
			nextPutAll: self selectionAsStream upToEnd ]! !
!CompiledMethod methodsFor: 'accessing' stamp: 'HAW 3/11/2019 08:35:51' prior: 16819362!
                          defaultSelector 
	
	"Invent and answer an appropriate message selector (a Symbol) for me, 
	that is, one that will parse with the correct number of arguments."
	
	^Scanner doItSelector numArgs: self numArgs! !
!CompiledMethod methodsFor: 'source code management' stamp: 'HAW 3/11/2019 08:47:47' prior: 16820444!
        getSourceFor: selector in: class
	"Retrieve or reconstruct the source code for this method."

	| flagByte source |

	flagByte := self last.
	
	"If no source pointer..."
	source := flagByte < 252 
		ifTrue: [ nil ]
		ifFalse: [ 
			"Situation normal; read the sourceCode from the file
			An error can happen here if, for example, the changes file has been truncated by an aborted download.  
			The present solution is to ignore the error and fall back on the decompiler.  
			A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  
			Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling 
			into this error case, random source code will get returned."
			[self getSourceFromFile]
				on: Error
				do: [ :ex | ex return: nil]].
		
	"If source code not available, use DoIt source code or if absent decompile blind (no temps)"
	^source ifNil: [ (class decompilerClass new decompile: selector in: class method: self) decompileString ]! !
!CompiledMethod methodsFor: 'decompiling' stamp: 'HAW 3/11/2019 08:55:04' prior: 50408791!
                             methodNode

	"Return the parse tree that represents self"
	
	"I do not save the method node in the #methodNode property if it does not
	exist to avoid keeping the method node in memory. 
	The methodNode is saved in the property #methodNode to avoid loosing the source
	code when debugging - Hernan"
	^self propertyValueAt: #methodNode ifAbsent: [ self createMethodNode ]! !
!Compiler methodsFor: 'public access' stamp: 'HAW 3/9/2019 00:01:13' prior: 16821912!
                    evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock

	^ self evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: false profiled: false! !
!Compiler methodsFor: 'public access' stamp: 'HAW 3/11/2019 08:45:50' prior: 50382473!
             evaluate: textOrStream in: aContext to: aReceiver notifying: aRequestor ifFail: failBlock logged: doLog profiled: doProfile
	"Compiles the sourceStream into a parse tree, then generates code into
	 a method. If aContext is not nil, the text can refer to temporaries in that
	 context (the Debugger uses this). If aRequestor is not nil, then it will receive
	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 
	 compiled method is invoked from here via withArgs:executeMethod:, hence
	 the system no longer creates Doit method litter on errors."

	| methodNode method |
	
	class _ (aContext ifNil: [ aReceiver ] ifNotNil: [ aContext receiver ]) class.
	methodNode _ self compileNoPattern: textOrStream in: class context: aContext notifying: aRequestor ifFail: [^failBlock value].
	method _ methodNode generate.
	"I'm not keeping the source nor the methodNode for back compabibility. 
	The SmalltalkEditor sends the message #evaluateMethod:... which already keep the method node
	 for the debugger to show the right source code - Hernan"

	^self evaluateMethod: method to: aReceiver logged: doLog profiled: doProfile! !
!Compiler methodsFor: 'private' stamp: 'HAW 3/11/2019 07:07:06' prior: 50409901!
                     translate: aStream noPattern: noPattern ifFail: failBlock

	^self translate: aStream noPattern: noPattern doIt: noPattern ifFail: failBlock ! !
!Compiler class methodsFor: 'evaluating' stamp: 'HAW 3/9/2019 00:01:04' prior: 16822139!
                       evaluate: textOrString for: anObject notifying: aRequestor logged: logFlag
	"Compile and execute the argument, textOrString with respect to the class 
	of anObject. If a compilation error occurs, notify aRequestor. If both 
	compilation and execution are successful then, if logFlag is true, log 
	(write) the text onto a system changes file so that it can be replayed if 
	necessary."

	^ self new
		evaluate: textOrString
		in: nil
		to: anObject
		notifying: aRequestor
		ifFail: [^nil]
		logged: logFlag
		profiled: false! !
!Scanner methodsFor: 'xBacktick processing - private' stamp: 'HAW 3/11/2019 08:36:29' prior: 50409922!
        compileBacktickCode

	| compiler method methodNode |
	
	compiler _ Compiler new.
	methodNode _ compiler compileNoPattern: buffer contents in: UndefinedObject context: nil notifying: nil ifFail: [].
	method _ methodNode generate.
	
	"Grab all messages sent while evaluating literal, so the main method will be shown as senders of them"
	sentInLiterals addAll: method messages.
	method literalsDo: [ :literal | literal isSymbol ifTrue: [ literal = self class doItSelector ifFalse: [sentInLiterals add: literal ]]].
		
	"Evaluate now."
	token _ nil withArgs: #() executeMethod: method ! !
!Parser methodsFor: 'expression types' stamp: 'HAW 3/11/2019 06:42:49' prior: 50409275!
                              doitPatternInContext: context

	^context 
		ifNil: [{self class doItSelector. {}. 1. nil }]
		ifNotNil: [{self class doItInSelector. {encoder encodeVariable: encoder doItInContextName}. 3. nil}]! !
!Parser methodsFor: 'public access' stamp: 'HAW 3/11/2019 08:31:06' prior: 16886850!
     parse: sourceStream class: class noPattern: noPattern context: aContext notifying: aRequestor ifFail: aBlock 

	^self parse: sourceStream class: class category: nil noPattern: noPattern doIt: noPattern context: aContext notifying: aRequestor ifFail: aBlock ! !
!AssignmentNode methodsFor: 'initialization' stamp: 'HAW 3/10/2019 12:37:09' prior: 16780831!
                             variable: aVariable value: expression from: encoder

	"Case of remote temp vars"
	(aVariable isMemberOf: MessageAsTempNode) ifTrue: [ ^aVariable store: expression from: encoder].
	
	variable := aVariable.
	value := expression.
	
	^self
	
! !
!AssignmentNode methodsFor: 'initialization' stamp: 'HAW 3/9/2019 20:03:46' prior: 16780841!
                 variable: aVariable value: expression from: encoder sourceRange: range

	| realNode |
	
	realNode := self variable: aVariable value: expression from: encoder.
	encoder noteSourceRange: range forNode: realNode.
	
	^realNode! !
!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'HAW 3/11/2019 08:56:15' prior: 16867539!
                     store: expr from: encoder 
	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).
	For assigning into temps of a context being debugged."

	selector key ~= #namedTempAt: ifTrue: [^self error: 'cant transform this message'].
	
	^ MessageAsTempNode new
		receiver: receiver
		selector: #namedTempAt:put:
		arguments: (arguments copyWith: expr)
		precedence: precedence
		from: encoder! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'HAW 3/11/2019 06:25:51' prior: 16909636!
                               compileSelectionFor: anObject in: evalContext

	^(self compileSelectionFor: anObject in: evalContext ifFail: [ ^ nil ]) at: #method
! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'HAW 3/11/2019 08:57:10' prior: 16909670!
 debugIt

	| provider method receiver context |

	self lineSelectAndEmptyCheck: [^self].

	provider _ self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver _ provider doItReceiver.
			context _ provider doItContext]
		ifFalse: [
			receiver _ context _ nil].

	method _ self compileSelectionFor: receiver in: context.
	method ifNotNil: [ self debug: method receiver: receiver in: context ]! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'HAW 3/11/2019 08:42:34' prior: 16909696!
     evaluateSelectionAndDo: aBlock ifFail: failBlock profiled: doProfile
	"Treat the current selection as an expression; evaluate it and return the result
	3 +4
	"
	| provider result receiver context methodAndCompiler |

	self lineSelectAndEmptyCheck: [^ ''].

	provider _ self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver _ provider doItReceiver.
			context _ provider doItContext]
		ifFalse: [receiver _ context _ nil].

	methodAndCompiler _ self compileSelectionFor: receiver in: context ifFail: [^ failBlock value].

	result _ (methodAndCompiler at: #compiler)
		evaluateMethod: (methodAndCompiler at: #method)
		to: receiver
		logged: true
		profiled: doProfile.
		
	morph formatAndStyleIfNeeded.		"Needed to re-shout workspaces, that might have new variables binded."
	
	^ aBlock value: result! !
!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'HAW 3/11/2019 08:39:26' prior: 16830789!
abstractSourceMap
	"Answer with a Dictionary of abstractPC <Integer> to sourceRange <Interval>."

	| theMethodToScan rawSourceRanges concreteSourceRanges abstractPC scanner client |

	abstractSourceRanges ifNotNil: [ ^abstractSourceRanges].

	methodNode encoder hasGeneratedMethod
		ifTrue: [
			rawSourceRanges := methodNode encoder rawSourceRanges.
		 	theMethodToScan := self method ]
		ifFalse: [
			"If the methodNode hasn't had a method generated it doesn't have pcs set in its
			 nodes so we must generate a new method and might as well use it for scanning."
			 [methodNode rawSourceRangesAndMethodDo: [ :ranges :method |
				rawSourceRanges := ranges.
			 	theMethodToScan := method ]]
			on: UndeclaredVariableWarning
			do: [ :ex | ex resume ]].

	concreteSourceRanges := Dictionary new.
	rawSourceRanges keysAndValuesDo: [ :node :range |
		node pc ~= 0 ifTrue: [ | realRange |
			realRange := (range isKindOf: OrderedCollection) ifTrue: [ range last ] ifFalse: [ range ].
			concreteSourceRanges at: node pc put: realRange ]].

	abstractPC := 1.
	abstractSourceRanges := Dictionary new.
	scanner := InstructionStream on: theMethodToScan.
	client := InstructionClient new.
	[
		(concreteSourceRanges includesKey: scanner pc) ifTrue: [
			abstractSourceRanges at: abstractPC put: (concreteSourceRanges at: scanner pc)].
		 abstractPC := abstractPC + 1.
		 scanner interpretNextInstructionFor: client.
		 scanner atEnd ] whileFalse.
	
	^abstractSourceRanges! !
!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'HAW 3/9/2019 03:26:53' prior: 16830892!
 sourceText

	^methodNode sourceText! !
!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'HAW 3/11/2019 08:55:37' prior: 16830911!
               forMethod: aMethod "<CompiledMethod>"
	"Answer a DebuggerMethodMap suitable for debugging activations of aMethod.
	 Answer an existing instance from the cache if it exists, cacheing a new one if required."
	
	| methodNode |
	
	^self protected: [ 
		MapCache
			at: aMethod
			ifAbsent: [
				[ methodNode _ aMethod methodNode ]
					on: UndeclaredVariableWarning
					do: [ :ex | ex resume ].
				self
					cacheDebugMap: (self
								forMethod: aMethod
								methodNode: methodNode)
					forMethod: aMethod] ]! !
!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'HAW 3/9/2019 03:16:29' prior: 16830930!
                  forMethod: aMethod "<CompiledMethod>" methodNode: methodNode "<MethodNode>"
	"Uncached instance creation method for private use or for tests.
	 Please consider using forMethod: instead."
	^self new
		forMethod: aMethod
		methodNode: methodNode! !

Parser removeSelector: #method:context:!

Parser removeSelector: #method:context:!

Parser removeSelector: #parse:class:category:noPattern:context:notifying:ifFail:!

Parser removeSelector: #parse:class:category:noPattern:context:notifying:ifFail:!

Compiler removeSelector: #evaluateMethod:in:to:logged:profiled:!

Compiler removeSelector: #evaluateMethod:in:to:notifying:ifFail:logged:profiled:!

Compiler removeSelector: #evaluateMethod:in:to:notifying:logged:profiled:!

CompiledMethod removeSelector: #doItSourceCodeIfAbsent:!

CompiledMethod removeSelector: #generateDoItSourceCodeWith:!

CompiledMethod removeSelector: #keepDoItSourceCodeWith:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3655-DebuggingSourceCode2-HernanWilkinson-2019Mar08-22h34m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3655] on 12 March 2019 at 2:14:59 pm'!
!Date methodsFor: 'squeak protocol' stamp: 'jmv 3/12/2019 13:50:59'!
    > aDate

	self assert: aDate class == Date.
	^ self start > aDate start! !
!Time class methodsFor: 'general inquiries' stamp: 'jmv 3/12/2019 14:02:51' prior: 16937263!
                        localMicrosecondClock
	"Answer the number of microseconds since the Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, in the local host time zone.
	In other words, the number of microseconds since it was that time in this time zone.
	Answer might be a LargePositiveInteger (very likely on 32-bit images, very unlikely on 64-bit images).
	
	{ Time localMicrosecondClock . Time localMicrosecondClock // 1000000 . Time localSecondClock } print
	
	Note 1: Never rolls over. Can be used with confidence. Joins primMillisecondClock
	rollover control and sync with seconds clock. Uses existing offset if any, and validates result.
	Resynchs if needed. Resynch is very robust. No problems if clocks go out of synch for unknown reasons.

	Note 2: This is in local time, i.e. the time the system shows to the user. UTC would be better,
	but older VMs don't know about the current time zone"
	
	"If our VM supports the new primitive, just use it."
	self primLocalMicrosecondClock ifNotNil: [ :microSecs | ^microSecs ].
	
	"Otherwise we'll have just millisecond precision"
	^self localMillisecondClock * 1000! !
!Time class methodsFor: 'general inquiries' stamp: 'jmv 3/12/2019 14:02:55' prior: 16937299!
        localMillisecondClock
	"Answer the number of milliseconds since the Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, in the local host time zone.
	In other words, the number of milliseconds since it was that time in this time zone.
	Answer might be a LargePositiveInteger (very likely on 32-bit images, very unlikely on 64-bit images).
	
	{ Time localMillisecondClock . Time localMillisecondClock // 1000 . Time localSecondClock } print
	
	Note 1: Never rolls over. Can be used with confidence. Joins primMillisecondClock
	rollover control and sync with seconds clock. Uses existing offset if any, and validates result.
	Resynchs if needed. Resynch is very robust. No problems if clocks go out of synch for unknown reasons.

	Note 2: This is in local time, i.e. the time the system shows to the user. UTC would be better,
	but older VMs don't know about the current time zone"
	
	| millisecsSinceStartupOrRollover nowMillisecs nowSecs delay lastSecond |
	
	"If our VM supports the new primitive, just use it."
	self primLocalMicrosecondClock ifNotNil: [ :microSecs | ^microSecs // 1000 ].

	"Otherwise use millisecond clock and offset from second clock"
	MillisecondClockOffset ifNil: [ MillisecondClockOffset _ 0 ].	"Fix it below."
	millisecsSinceStartupOrRollover _ self primMillisecondClock.
	nowMillisecs _ millisecsSinceStartupOrRollover + MillisecondClockOffset.

	"Do expensive resync (delay 1 second) only on primMillisecondClock rollover, or if for whatever reason offset is wrong."
	nowSecs _ self primLocalSecondsClock.
	nowMillisecs // 1000 = nowSecs ifFalse: [
		delay _ Delay forMilliseconds: 1.
		lastSecond _ self primLocalSecondsClock.
		[ lastSecond = self primLocalSecondsClock ] whileTrue: [ delay wait ].
		millisecsSinceStartupOrRollover _ self primMillisecondClock.
 		nowSecs _ lastSecond + 1.
		MillisecondClockOffset _ nowSecs * 1000 - millisecsSinceStartupOrRollover ].

	nowMillisecs _ MillisecondClockOffset + millisecsSinceStartupOrRollover.
	^nowMillisecs! !
!Time class methodsFor: 'general inquiries' stamp: 'jmv 3/12/2019 14:03:05' prior: 16937363!
             localSecondClock
	"Answer the number of milliseconds since the Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, in the local host time zone.
	In other words, the number of milliseconds since it was that time in this time zone.
	This is in local time, i.e. the time the system shows to the user.
	Answer might be a LargePositiveInteger (very likely on 32-bit images, very unlikely on 64-bit images).

	{ Time localMillisecondClock . Time localMillisecondClock // 1000 . Time localSecondClock } print
	"
	^self localMillisecondClock // 1000! !
!Time class methodsFor: 'primitives' stamp: 'jmv 3/12/2019 14:03:29' prior: 50378285!
                            primHighResClock	
	"Primitive. Answer the value of the high resolution clock if this computer has one.
	Usually, this should be the highest resolution value available, for example on Intel
	it will be the value of the time stamp counter register.
	Answer might be a LargePositiveInteger (very likely on 32-bit images, very unlikely on 64-bit images).
	Implemented on Cog, but not in standard interpreter VMs."
	"
	Time primHighResClock
	On Cog on Linux, OS-X and Windows, this gives sub nano second ticks!!

	Time highResTimerTicksPerMillisecond
	"
	"Not really a clock, but a timer or ticker"

	<primitive: 'primitiveHighResClock'>
	^0! !
!Time class methodsFor: 'primitives' stamp: 'jmv 3/12/2019 14:03:33' prior: 16937585!
          primLocalMicrosecondClock
	"Answer the number of microseconds since the local time zone Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, in local time.
	Answer might be a LargePositiveInteger (very likely on 32-bit images, very unlikely on 64-bit images).
	Cog VMs implement this. Interpreters might not."
	"
	Time primLocalMicrosecondClock
	Time primLocalMicrosecondClock/ 1000 / 1000 / 60 / 60 / 24 / 365.25
	"
	<primitive: 241>
	^nil! !
!Time class methodsFor: 'primitives' stamp: 'jmv 3/12/2019 14:05:35' prior: 16937600!
  primLocalSecondsClock
	"Answer the number of seconds since the Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, in the local host time zone.
	In other words, the number of seconds since it was that time in this time zone.
	Answer is a 32-bit unsigned number.
	Answer might be a LargePositiveInteger on 32-bit images.
	Note: This is in local time, i.e. the time the system shows to the user.
	Essential. See Object documentation whatIsAPrimitive. 

	Time primLocalSecondsClock
	Time primLocalSecondsClock / 60 / 60 / 24 / 365.25
	
	Warning: Will overflow in year 2037
	"

	<primitive: 137>
	self primitiveFailed! !
!Time class methodsFor: 'primitives' stamp: 'jmv 3/12/2019 14:05:48' prior: 50340954!
                    primUtcMicrosecondClock
	"Answer the number of microseconds since the UTC Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, the start of the 20th century, in UTC time.
	 The value is derived from the Posix epoch with a constant offset corresponding to elapsed microseconds
	 between the two epochs according to RFC 868.
	Answer might be a LargePositiveInteger (very likely on 32-bit images, very unlikely on 64-bit images).
	Cog VMs implement this. Interpreters might not."
	"
	Time primUtcMicrosecondClock
	Time primUtcMicrosecondClock/ 1000 / 1000 / 60 / 60 / 24 / 365.25

	(Time primUtcMicrosecondClock / 1000 / 1000 + Time primUtcWithOffset second) / 60 / 60 / 24 / 365.25
	(DateAndTime now - (DateAndTime year: 1901 month: 1 day: 1)) totalSeconds / 60 / 60 / 24 / 365.25
	"
	<primitive: 240>
	^nil! !
!Time class methodsFor: 'primitives' stamp: 'jmv 3/12/2019 14:07:31' prior: 16937663!
                     primUtcWithOffset
	"Answer a two element array.

	First element is the number of microseconds since the UTC Posix (Unix) epoch, 
	i.e. 00:00 on the morning of January 1, 1970, in UTC time.
	It might be a LargePositiveInteger (very likely on 32-bit images, very unlikely on 64-bit images).
	
	Second element is the current seconds offset from GMT in the local time zone.

	Recent VMs implement this. Older Interpreters might not.
	"
	"
	Time primUtcWithOffset
	Time primUtcWithOffset first / 1000 / 1000 / 60 / 60 / 24 / 365.25
	Time primUtcWithOffset second / 60 / 60.0
		
	(Time primUtcWithOffset first / 1000 / 1000 + Time primUtcWithOffset second) / 60 / 60 / 24 / 365.25
	(DateAndTime now - (DateAndTime year: 1970 month: 1 day: 1)) totalSeconds / 60 / 60 / 24 / 365.25
	"
	<primitive: 'primitiveUtcWithOffset'>
	^nil
	
	"
	Evaluate on various platforms and record the results
{ 
	Smalltalk vmVersion .
	Smalltalk platformName .
	Smalltalk platformSubtype  .
	Smalltalk osVersion .
	Time primLocalMicrosecondClock/ 1000 / 1000 / 60 / 60 / 24 / 365.25 .
	Time primLocalSecondsClock / 60 / 60 / 24 / 365.25 . 
	Time primUtcMicrosecondClock / 1000 / 1000 / 60 / 60 / 24 / 365.25 . 
	Time primUtcWithOffset first / 1000 / 1000 / 60 / 60 / 24 / 365.25 . 
	Time primUtcWithOffset second / 60 / 60.0
}
	"! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3656-SomeMethodCommentTweaks-JuanVuletich-2019Mar11-17h23m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3652] on 11 March 2019 at 3:33:12 pm'!

"Change Set:		3653-CuisCore-AuthorName-2019Mar11-14h53m
Date:			11 March 2019
Author:			Nahuel Garbezza

Categorize a bunch of uncategorized methods"!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3657-MethodsCategorization-NahuelGarbezza-2019Mar11-14h53m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3652] on 11 March 2019 at 4:34:52 pm'!

"Change Set:		3653-CuisCore-AuthorName-2019Mar11-15h56m
Date:			11 March 2019
Author:			Nahuel Garbezza

Add (R) as a shortcut to rename packages, classes, categories and methods"!
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'RNG 3/11/2019 16:33:24' prior: 50338607!
                     messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	aChar == $D ifTrue: [^ model toggleDiffing].

	sel _ model selectedMessageName.
	aChar == $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar == $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	"The following require a class selection"
	(class _ model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar == $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar == $N ifTrue: [^ self browseClassRefs].
	aChar == $i ifTrue: [^ self methodHierarchy].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $p ifTrue: [^ self browseFullProtocol].

	sel
		ifNotNil: [
			"The following require a method selection"
			aChar == $o ifTrue: [^ model fileOutMessage].
			aChar == $c ifTrue: [^ model copySelector].
			aChar == $v ifTrue: [^ self browseVersions].
			aChar == $O ifTrue: [^ self openSingleMessageBrowser].
			aChar == $x ifTrue: [^ model removeMessage].
			aChar == $t ifTrue: [^ model runMethodTest].
			aChar == $r ifTrue: [^ model debugMethodTest].
			aChar == $R ifTrue: [^ self renameSelector]]
		ifNil: [
			aChar == $R ifTrue: [^ model renameClass]]! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'RNG 3/1/2019 21:49:28' prior: 50419679!
                               systemCatListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."

	aChar == $f ifTrue: [ ^ self findClass ].
	aChar == $x ifTrue: [ ^ model removeSystemCategory ].
	aChar == $t ifTrue: [ ^ model runSystemCategoryTests ].
	aChar == $a ifTrue: [ ^ model addSystemCategory ].
	aChar == $A ifTrue: [ ^ model alphabetizeSystemCategories ].
	aChar == $b ifTrue: [ ^ self openSystemCategoryBrowser ].
	aChar == $B ifTrue: [ ^ self browseAllClasses ].
	aChar == $o ifTrue: [ ^ model fileOutSystemCategory ].
	aChar == $u ifTrue: [ ^ model updateSystemCategories ].
	aChar == $R ifTrue: [ ^ model renameSystemCategory ].
	
	^ self classListKey: aChar from: view! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'RNG 3/1/2019 21:50:23' prior: 50411315!
     classListMenuOptions

	^ `{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 		-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 		-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'browse protocol (p)'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutClass.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		5.
				#label 			-> 		'show classes hierarchically'.
				#object 			-> 		#model.
				#selector 		-> 		#enableListClassesHierarchically.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		6.
				#label 			-> 		'show classes alphabetically'.
				#object 			-> 		#model.
				#selector 		-> 		#enableListClassesAlphabetically.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'show hierarchy'.
				#object 			-> 		#model.
				#selector 		-> 		#hierarchy.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'show definition'.
				#object 			-> 		#model.
				#selector 		-> 		#editClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'show comment'.
				#object 			-> 		#model.
				#selector 		-> 		#editComment.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 		-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 		-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'class var refs...'.
				#selector 		-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'class vars'.
				#selector 		-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'class refs (N)'.
				#selector 		-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'copy class...'.
				#object 			-> 		#model.
				#selector 		-> 		#copyClass.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runClassTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		20.
				#label 			-> 		'more...'.
				#selector 		-> 		#offerClassListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'RNG 3/1/2019 21:48:16' prior: 50411726!
                         systemCatSingletonMenuOptions

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse all (B)'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse (b)'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'update (u)'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'RNG 3/1/2019 21:48:09' prior: 50419706!
             systemCategoryMenuOptions

	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 		-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'recent classes... (r)'.
				#object 			-> 		#model.
				#selector 		-> 		#recent.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'browse all (B)'.
				#selector 		-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'browse (b)'.
				#selector 		-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 		-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 		-> 		#editSystemCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'alphabetize (A)'.
				#object 			-> 		#model.
				#selector 		-> 		#alphabetizeSystemCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'update (u)'.
				#object 			-> 		#model.
				#selector 		-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		20.
				#label 			-> 		'add item... (a)'.
				#object 			-> 		#model.
				#selector 		-> 		#addSystemCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		30.
				#label 			-> 		'rename... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 			-> 		'move to top'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryTop.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		20.
				#label 			-> 		'move up'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryUp.
				#icon 			-> 		#goUpIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		30.
				#label 			-> 		'move down'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryDown.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		40.
				#label 			-> 		'move to bottom'.
				#object 			-> 		#model.
				#selector 		-> 		#moveSystemCategoryBottom.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 		-> 		70.
				#itemOrder 		-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 		-> 		#runSystemCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'RNG 3/11/2019 15:58:36' prior: 50442445!
                         classRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'insert superclass...'.
				#object 			-> 		#model.
				#selector 		-> 		#insertSuperclass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'safely remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#safelyRemoveClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'add inst var...'.
				#selector 		-> 		#addInstVar.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename inst var...'.
				#selector 		-> 		#renameInstVar.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove inst var...'.
				#selector 		-> 		#removeInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove all unreferenced inst var...'.
				#selector 		-> 		#removeAllUnreferencedInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
	}`.
	! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'RNG 3/11/2019 15:58:48' prior: 50442503!
               messsageRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
	}`.
	
	! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3658-Shortcuts-NahuelGarbezza-2019Mar11-15h56m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3656] on 12 March 2019 at 3:09:32 pm'!
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 3/12/2019 15:07:50' prior: 50436548!
                          resetMenu

	| width newExtent |
	self hideSelectorDocumentation.

	firstVisible := 1.
	self selected: ((completer canSelect: (completer entries at: firstVisible)) ifTrue: [firstVisible] ifFalse: [firstVisible+1]).

	self calculateItemsPerPage.
	width _ self calculateWidth.
	newExtent _ width + 4 @ (itemsPerPage * self itemHeight + 2).

	self morphPosition: originalPosition extent: newExtent.
	"redraw is needed even if position and extent haven't changed"
	self redrawNeeded ! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3659-skipCategoryTitleInAutocompleter-JuanVuletich-2019Mar12-15h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3659] on 12 March 2019 at 10:00:35 pm'!

"Change Set:		3660-CuisCore-AuthorName-2019Mar12-21h45m
Date:			12 March 2019
Author:			Nahuel Garbezza

Add some shortcuts to file list"!
!FileListWindow methodsFor: 'keyboard shortcuts' stamp: 'RNG 3/12/2019 21:55:43'!
   fileListKey: aChar from: aView

	aChar == $x ifTrue: [ ^ aView model deleteFile ].
	aChar == $R ifTrue: [ ^ aView model renameFile ].
	aChar == $n ifTrue: [ ^ aView model addNewFile ].
	aChar == $N ifTrue: [ ^ aView model addNewDirectory ].! !
!FileList methodsFor: 'own services' stamp: 'RNG 3/12/2019 21:57:34' prior: 50427096!
                      serviceAddNewDirectory
	"Answer a service entry characterizing the 'add new directory' command"

	^ SimpleServiceEntry
		provider: self
		label: 'add new directory (N)'
		selector: #addNewDirectory
		description: 'adds a new, empty directory (folder)'
		icon: #listAddIcon! !
!FileList methodsFor: 'own services' stamp: 'RNG 3/12/2019 21:56:19' prior: 50427108!
                      serviceAddNewFile
	"Answer a service entry characterizing the 'add new file' command"

	^ SimpleServiceEntry 
		provider: self 
		label: 'add new file (n)' 
		selector: #addNewFile 
		description: 'create a new,. empty file, and add it to the current directory.'
		icon: #newIcon! !
!FileList methodsFor: 'own services' stamp: 'RNG 3/12/2019 21:58:57' prior: 50427129!
               serviceDeleteFile

	^ SimpleServiceEntry
		provider: self
		label: 'delete (x)'
		selector: #deleteFile
		description: 'delete the seleted item'
		icon: #deleteIcon! !
!FileList methodsFor: 'own services' stamp: 'RNG 3/12/2019 21:59:33' prior: 50427158!
  serviceRenameFile

	^ SimpleServiceEntry
		provider: self
		label: 'rename (R)'
		selector: #renameFile
		description: 'rename file'
		icon: #saveAsIcon! !
!FileListWindow methodsFor: 'GUI building' stamp: 'RNG 3/12/2019 21:47:48' prior: 16843344!
        morphicFileListPane

	^PluggableListMorph
		model: model 
		listGetter: #fileList 
		indexGetter: #fileListIndex
		indexSetter: #fileListIndex: 
		mainView: self
		menuGetter: #fileListMenu
		keystrokeAction: #fileListKey:from:! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3660-FileListShortcuts-NahuelGarbezza-2019Mar12-21h45m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3660] on 13 March 2019 at 11:31:28 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 3/13/2019 11:30:42' prior: 50406067!
                      parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	| continue prevSourcePosition |
	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth := 0.
	blockDepths _ OrderedCollection with: blockDepth.
	blockDepthsStartIndexes _ OrderedCollection with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollection new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		"Iterate once for methods, but pontentially several times for workspaces
		(to recover after errors, for possible good next lines or chunks)"
		continue _ true.
		[ continue ] whileTrue: [
			prevSourcePosition _ sourcePosition.
			self parseStatementList.
			continue _ sourcePosition > prevSourcePosition.
			isAMethod
				ifTrue: [
					"Only if we are parsing a method, consider everything after this point as error."
					currentToken ifNotNil: [ self error ].
					continue _ false]
				ifFalse: [
					sourcePosition > source size ifTrue: [continue _ false]]].
	] ensure: [errorBlock _ nil].
	^true! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3661-SyntaxHighlighterFix-JuanVuletich-2019Mar13-11h12m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3661] on 14 March 2019 at 1:15:33 pm'!
!Number methodsFor: 'mathematical functions' stamp: 'jmv 3/14/2019 13:04:03' prior: 16880199!
  raisedToInteger: anInteger

	"The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must
	be handled as an indeterminate form.
	I take the first context because that's the way that was previously handled.
	Maybe further discussion is required on this topic."
	
	| bitProbe result firstTry exponent exponent1 exponent2 |

	anInteger negative ifTrue: [
		exponent := anInteger negated.
		firstTry := self raisedToInteger: exponent.
		^firstTry isInfinite
			ifFalse: [firstTry reciprocal]
			ifTrue: [
				exponent1 _ exponent // 2.
				exponent2 _ exponent - exponent1.
				(self raisedToInteger: exponent1) reciprocal * (self raisedToInteger: exponent2) reciprocal ]].
	bitProbe := 1 bitShift: anInteger highBit - 1.
 	result := self class one.
  	[
		(anInteger bitAnd: bitProbe) = 0 ifFalse: [result := result * self].
       bitProbe := bitProbe bitShift: -1.
		bitProbe > 0 ]
	whileTrue: [result := result * result].
	
	^result! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3662-fix-raisedToInteger-edgeCases-JuanVuletich-2019Mar14-13h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3610] on 14 March 2019 at 4:34:14 pm'!
!Editor methodsFor: 'private' stamp: 'AY 3/14/2019 16:25:09'!
  nextWordEndFrom: aPosition goingForwards: goingForwardsBoolean
	
	"Answer the position of the end of the next word on the current line going
	forwards (or backwards).
	If the given position is the end (or beginning) of the line then answer the
	beginning (or end) of the next (or previous) line."
	
	| string beginningOfLine endOfLine step offset index newPosition |
	
	string _ self privateCurrentString.
	beginningOfLine _ self beginningOfLine: aPosition.
	endOfLine _ self endOfLine: aPosition.
	step _ goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	offset _ goingForwardsBoolean ifTrue: [0] ifFalse: [-1].
	
	index _ aPosition.
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers not]]
			whileTrue: [index _ index + step].
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers]]
			whileTrue: [index _ index + step].
	
	newPosition _ index = aPosition ifTrue: [index + step] ifFalse: [index].
	^newPosition min: string size + 1 max: 1! !
!Editor methodsFor: 'private' stamp: 'AY 3/14/2019 16:29:31'!
                       nextWordStartFrom: aPosition goingForwards: goingForwardsBoolean
	
	"Answer the position of the start of the next word on the current line going
	forwards (or backwards).
	If the given position is the end (or beginning) of the line then answer the
	beginning (or end) of the next (or previous) line."
	
	| string beginningOfLine endOfLine step offset index newPosition |
	
	string _ self privateCurrentString.
	beginningOfLine _ self beginningOfLine: aPosition.
	endOfLine _ self endOfLine: aPosition.
	step _ goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	offset _ goingForwardsBoolean ifTrue: [0] ifFalse: [-1].
	
	index _ aPosition.
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers]]
			whileTrue: [index _ index + step].
	[(index + step between: beginningOfLine and: endOfLine)
		and: [(string at: index + offset) isValidInIdentifiers not]]
			whileTrue: [index _ index + step].
	
	newPosition _ index = aPosition ifTrue: [index + step] ifFalse: [index].
	^newPosition min: string size + 1 max: 1! !
!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'AY 3/14/2019 01:24:07' prior: 16836563!
                 cursorLeft: aKeyboardEvent
	"Private - Move cursor left one character if nothing selected, otherwise move cursor to beginning of selection. If the shift key is down, start selecting or extending current selection.
	Don't allow cursor past beginning of text"

	self
		moveCursor: [ :position | | newPos |
			newPos _ position - 1.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ newPos _ self previousWordStart: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos _ self beginningOfLine: position ].
			newPos ]
		forward: false
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'AY 3/14/2019 16:26:36' prior: 16836609!
cursorRight: aKeyboardEvent 
	"Private - Move cursor right one character if nothing selected, otherwise move cursor to end of selection. If the shift key is down, start selecting characters or extending already selected characters. 
	Don't allow cursor past end of text"

	self
		moveCursor: [ :position | | newPos |
			newPos _ position + 1.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [ newPos _ self nextWordEnd: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos _ self endOfLine: position ].
			newPos ]
		forward: true
		event: aKeyboardEvent.
	^ true! !
!Editor methodsFor: 'private' stamp: 'AY 3/14/2019 16:30:31' prior: 16836804!
                  nextWordEnd: aPosition
	
	^self nextWordEndFrom: aPosition goingForwards: true! !
!Editor methodsFor: 'private' stamp: 'AY 3/14/2019 16:30:13' prior: 16836818!
nextWordStart: aPosition
	
	^self nextWordStartFrom: aPosition goingForwards: true! !
!Editor methodsFor: 'private' stamp: 'AY 3/14/2019 16:31:46' prior: 16836832!
                            previousWordStart: aPosition
	
	^self nextWordEndFrom: aPosition goingForwards: false! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3663-NextWord-PreviousWord-tweaks-AngelYan-2019Mar13-22h56m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3661] on 15 March 2019 at 2:26:59 pm'!
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'AY 3/15/2019 11:51:58'!
        entryCount
	
	^completer entryCount! !
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'AY 3/15/2019 13:26:28'!
             itemsPerPage

	^itemsPerPage! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 13:04:51'!
                      firstSelectableEntryIndex
	
	^self nextSelectableEntryIndexFrom: 0! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 14:01:03'!
                firstVisible: anIndex
	
	firstVisible _ anIndex
		min: self entryCount - self itemsPerPage + 1
		max: 1.! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 14:10:19'!
          lastSelectableEntryIndex
	
	^self previousSelectableEntryIndexFrom: 1! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 14:01:42'!
             lastVisible: anIndex
	
	self firstVisible: anIndex - self itemsPerPage + 1.! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 13:31:48'!
       nextSelectableEntryIndexFrom: anIndex
	
	^self nextSelectableEntryIndexFrom: anIndex goingForwards: true! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 13:31:31'!
          nextSelectableEntryIndexFrom: anIndex goingForwards: goingForwardsBoolean
	
	| direction indicesFromAnIndex |
	
	direction _ goingForwardsBoolean ifTrue: [1] ifFalse: [-1].
	indicesFromAnIndex _ (1 to: self entryCount)
		collect: [ :offset | self wrapIndex: anIndex + (offset*direction) by: self entryCount ].
	
	^indicesFromAnIndex
		detect: [ :index | self canSelectEntryAt: index ]
		ifNone: [self error: 'there are no selectable entries']! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 14:18:28'!
                        nextSelectableEntryIndexFromAndIncluding: anIndex
	
	^self nextSelectableEntryIndexFrom: anIndex - 1! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 13:32:02'!
              previousSelectableEntryIndexFrom: anIndex
	
	^self nextSelectableEntryIndexFrom: anIndex goingForwards: false! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 13:25:42'!
     wrapIndex: anIndex by: aSize
	
	^anIndex - 1 \\ aSize + 1! !
!AutoCompleterMorph methodsFor: 'testing' stamp: 'AY 3/15/2019 11:55:29'!
                         canSelectEntryAt: anIndex
	
	^completer canSelectEntryAt: anIndex! !
!AutoCompleter methodsFor: 'entries' stamp: 'AY 3/15/2019 11:47:28'!
                      entryAt: anIndex
	
	^self entries at: anIndex! !
!AutoCompleter methodsFor: 'testing' stamp: 'AY 3/15/2019 11:47:48'!
          canSelectEntryAt: anIndex

	^self canSelect: (self entryAt: anIndex)! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 14:10:45' prior: 50436493!
                              goDown
	
	self selected: (self nextSelectableEntryIndexFrom: self selected).
	(self selected between: self firstVisible and: self lastVisible)
		ifFalse: [self lastVisible: self selected].
	
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 14:03:40' prior: 50436505!
                goHome

	self selected: self firstSelectableEntryIndex.
	self firstVisible: 1.
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 14:03:32' prior: 50436523!
goToEnd
	
	self selected: self lastSelectableEntryIndex.
	self lastVisible: self selected.
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 14:00:18' prior: 50436530!
                    goUp

	(self selected = 0 and: [self firstVisible = 1]) ifTrue: [^ self].
	
	self selected: (self previousSelectableEntryIndexFrom: self selected).
	(self selected between: self firstVisible and: self lastVisible)
		ifFalse: [self firstVisible: self selected].
		
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 14:25:49' prior: 50446123!
       resetMenu

	| width newExtent |
	self hideSelectorDocumentation.

	self calculateItemsPerPage.
	
	self firstVisible: 1.
	self selected: self firstSelectableEntryIndex.
	
	width _ self calculateWidth.
	newExtent _ width + 4 @ (itemsPerPage * self itemHeight + 2).

	self morphPosition: originalPosition extent: newExtent.
	"redraw is needed even if position and extent haven't changed"
	self redrawNeeded ! !
!AutoCompleterMorph methodsFor: 'paging' stamp: 'AY 3/15/2019 14:18:47' prior: 50436651!
               gotoPage: anInteger

	| item |

	item := ((anInteger - 1) * itemsPerPage) + 1.
	item >= completer entryCount ifTrue: [^false].

	item < 1 ifTrue: [item := 1].
	firstVisible _ item.
	self selected: (self nextSelectableEntryIndexFromAndIncluding: item).

	^ true! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3664-Autocompleter-skipTitles-AngelYan-2019Mar15-14h07m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3662] on 15 March 2019 at 5:14:44 pm'!
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 17:13:20' prior: 50436511!
               goPageDown
	
	| oldEntry newEntry nextEntry |
	
	oldEntry _ self selected.
	newEntry _ oldEntry.
	[nextEntry _ self nextSelectableEntryIndexFrom: newEntry.
	nextEntry > oldEntry and: [nextEntry - oldEntry <= self itemsPerPage]]
		whileTrue: [newEntry _ nextEntry].
	
	self selected: newEntry.
	self firstVisible: newEntry.
	
	self redrawNeeded.! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 17:09:51' prior: 50436517!
          goPageUp
	
	| oldEntry newEntry nextEntry |
	
	oldEntry _ self selected.
	newEntry _ oldEntry.
	[nextEntry _ self previousSelectableEntryIndexFrom: newEntry.
	oldEntry > nextEntry and: [oldEntry - nextEntry <= self itemsPerPage]]
		whileTrue: [newEntry _ nextEntry].
	
	self selected: newEntry.
	self firstVisible: newEntry.
	
	self redrawNeeded.! !

AutoCompleterMorph removeSelector: #currentPage!

AutoCompleterMorph removeSelector: #currentPage!

AutoCompleterMorph removeSelector: #gotoPage:!

AutoCompleterMorph removeSelector: #gotoPage:!

AutoCompleterMorph removeSelector: #pageCount!

AutoCompleterMorph removeSelector: #pageCount!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3665-AutoCompleterPageUpDown-AngelYan-2019Mar15-17h08m-AY.1.cs.st----!

----SNAPSHOT----(15 March 2019 17:36:06) Cuis5.0-3665-v3.image priorSource: 3233715!

----QUIT----(15 March 2019 17:43:20) Cuis5.0-3665-v3.image priorSource: 3680276!

----STARTUP---- (23 April 2019 09:06:02) as /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/Cuis5.0-3665-v3.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3665] on 15 March 2019 at 10:06:54 pm'!
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'AY 3/15/2019 21:55:46' prior: 50434288!
                         selected: aNumber 

	"Set the value of selected"

	((aNumber between: 1 and: self entryCount) and: [ aNumber ~= selected ])
		ifTrue: [ 
			selected _ aNumber.
			self isShowingSelectorDocumentation ifTrue: [ self showSelectorDocumentation ]]! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'AY 3/15/2019 21:54:52' prior: 50446583!
                resetMenu

	| width newExtent |
	self hideSelectorDocumentation.

	self calculateItemsPerPage.
	
	self firstVisible: 1.
	self selected: self firstSelectableEntryIndex.
	
	width _ self calculateWidth.
	newExtent _ width + 4 @ (self itemsPerPage * self itemHeight + 2).

	self morphPosition: originalPosition extent: newExtent.
	"redraw is needed even if position and extent haven't changed"
	self redrawNeeded ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'AY 3/15/2019 21:56:00' prior: 50436479!
         calculateItemsPerPage

	| itemsThatCanFit |

	itemsThatCanFit _ (DisplayScreen actualScreenSize y - originalPosition y - 2) // self itemHeight.
	itemsPerPage _ (itemsThatCanFit min: self maxItemsPerPage) min: self entryCount.

! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'AY 3/15/2019 21:56:10' prior: 50436582!
                               calculateWidth

	| width font |

	width _ 120.
	font _ self class listFont.

	1
		to: self entryCount
		do: [ :index | width _ width max: (font widthOfString: (completer entries at: index) asString)].

	self entryCount > self itemsPerPage ifTrue: [ width _ width + ScrollBar scrollbarThickness ].

	^ width ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'AY 3/15/2019 21:55:40' prior: 50433589!
               drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness
	
	| height top bottom |

	height _ extent y - (2 * scrollbarThickness).
	top _ (1.0 * self firstVisible-1 / self entryCount * height) ceiling + 1 + scrollbarThickness-1.
	bottom _ (1.0 * self lastVisible / self entryCount * height) floor + 1 + scrollbarThickness -1.
	aCanvas
		fillRectangle: (extent x - scrollbarThickness+2@top corner:  extent x-2 @ bottom)
		color: `Color veryLightGray` ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'AY 3/15/2019 21:54:24' prior: 50436606!
                        drawScrollBarOn: aCanvas

	| scrollbarThickness width |

	width _ extent x-2.
	self entryCount > self itemsPerPage  ifTrue: [
		scrollbarThickness _ ScrollBar scrollbarThickness.
		width _ width - scrollbarThickness.

		self drawScrollBarRectangleOn: aCanvas thickness: scrollbarThickness.
		self drawUpArrowOn: aCanvas thickness: scrollbarThickness.
		self drawDownArrowOn: aCanvas thickness: scrollbarThickness.
		self drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness ].

	^width
! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 22:05:12' prior: 50436671!
               firstVisible

	^firstVisible min: self entryCount! !
!AutoCompleterMorph methodsFor: 'private' stamp: 'AY 3/15/2019 22:02:14' prior: 50436676!
                 lastVisible
	
	^self firstVisible + self itemsPerPage - 1 min: self entryCount! !
!AutoCompleterMorph methodsFor: 'selector documentation' stamp: 'AY 3/15/2019 21:54:35' prior: 50436682!
     selectorDefaultDocumentationLocation

	| relativeSelected |

	relativeSelected := (self selected - self firstVisible) min: self itemsPerPage - 1 max: 0.

	^location externalizePosition: extent x@(relativeSelected * self itemHeight + 1).

	! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3666-AutoCompleterInstVarEncapsulation-AngelYan-2019Mar15-21h54m-AY.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3665] on 17 March 2019 at 9:14:29 am'!
!PasteUpMorph methodsFor: 'accessing' stamp: 'GC 3/17/2019 08:16:08'!
               handlesKeyboard

	^ true ! !
!BrowserWindow class methodsFor: 'GUI building' stamp: 'GC 3/17/2019 08:13:13'!
                   findClass

	| allClassNames |
	
	allClassNames _ Smalltalk classNames asOrderedCollection.
	
	self findClassFrom: allClassNames ifFound: [:foundClass | self fullOnClass: foundClass ]
 	
	! !
!BrowserWindow class methodsFor: 'GUI building' stamp: 'GC 3/17/2019 08:15:15'!
                 findClassFrom: potentialClassNames ifFound: aBlock

	| classNames exactMatch foundClass index pattern toMatch |
	
	pattern _ ClassNameRequestMorph request: 'Class name or fragment?'.
	pattern isEmpty ifTrue: [^ self flash].
	toMatch _ (pattern copyWithout: $.) asLowercase withBlanksTrimmed.
	classNames _ (pattern last = $. or: [pattern last = $ ])
		ifTrue: [potentialClassNames select: [:nm |  nm asLowercase = toMatch]]
		ifFalse: [potentialClassNames select: [:n | n includesSubstring: toMatch caseSensitive: false]].
	classNames isEmpty ifTrue: [^ self flash].
	exactMatch _ classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.

	index _ classNames size = 1
		ifTrue: [ 1 ]
		ifFalse: [ exactMatch
			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUpMenu]
			ifNotNil: [classNames addFirst: exactMatch.
				(PopUpMenu labelArray: classNames lines: #(1)) startUpMenu]].

	index = 0 ifTrue: [^ self flash].
	foundClass _ Smalltalk at: (classNames at: index) asSymbol.
 	
	aBlock value: foundClass.! !
!BrowserWindow class methodsFor: 'GUI building' stamp: 'GC 3/17/2019 08:15:28'!
      fullOnClass: aClass

	self fullOnClass: aClass selector: nil! !
!Theme methodsFor: 'keyboard shortcuts' stamp: 'HAW 3/17/2019 08:37:46'!
                       findClassIn: aWindow

	| isBrowserWindow |
	
	isBrowserWindow _ (aWindow class = BrowserWindow) or: [ aWindow class = HierarchyBrowserWindow ].
	isBrowserWindow
		ifTrue: [ aWindow findClass ] 
		ifFalse: [ BrowserWindow findClass ]! !
!TextEditor methodsFor: 'menu' stamp: 'HAW 3/17/2019 08:53:17' prior: 50396370!
    getMenu
	
	^(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find...(F)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#label 			-> 		'Set Alignment...'.
				#selector 		-> 		#chooseAlignment.
				#icon 			-> 		#formatJustifyLeftIcon
			} asDictionary.
		}`! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/17/2019 08:58:33' prior: 50423644!
             basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$F 	#find:						'Find')
		#(		$g 	#findAgain:					'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:			'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R		#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y		#makeUppercase:			'Force selection to uppercase')
		#(		$U		#changeLineEndsToLf:		'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H		#cursorTopHome:			'Move cursor to start of text')
		#(		$L		#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z		#redo:						'Redo (multiple levels)')
		#(		$X		#makeLowercase:			'Force selection to lowercase')
		#(		$C		#compareToClipboard:		'Compare argument to clipboard')

		#(		$ 		#selectWord:				'Select the current word as with double clicking')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/17/2019 09:00:30' prior: 50412517!
                    cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$Q	#argPrev:							'Previous argument')
		#(		$A	#argNext:							'Next argument')
		#(		$D	#debugIt:							'Debug it')
"		#(		$F	#displayIfFalse:					'Insert #ifFalse:')"
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 3/17/2019 08:53:38' prior: 50410993!
                         smalltalkEditorMenu2Options
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Find...(F)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`
! !
!BrowserWindow methodsFor: 'commands' stamp: 'GC 3/17/2019 08:13:00' prior: 16793460!
       findClass

	| scopedClassNames |
	
	scopedClassNames _ model potentialClassNames asOrderedCollection.
	
	self class findClassFrom: scopedClassNames ifFound: [:foundClass |
		model selectCategoryForClass: foundClass.
		model selectClass: foundClass ]! !
!HandMorph methodsFor: 'events-processing' stamp: 'GC 3/17/2019 08:15:50' prior: 16851808!
        startKeyboardDispatch: aKeyboardEvent

	| focusedElement |
	
	focusedElement _ self keyboardFocus ifNil: [ self world ].
	focusedElement handleFocusEvent: aKeyboardEvent.
	
	self mouseOverHandler processMouseOver: self lastMouseEvent! !
!Theme methodsFor: 'keyboard shortcuts' stamp: 'HAW 3/17/2019 08:59:01' prior: 50381783!
                          keyStroke: aKeyboardEvent morph: aMorph

	aKeyboardEvent commandAltKeyPressed | aKeyboardEvent controlKeyPressed
		ifFalse: [ ^ false ].

	aKeyboardEvent keyValue = $w numericValue ifTrue: [
		aMorph owningWindow ifNotNil: [ :w |
			(w morphContainsPoint: (w internalizeFromWorld: aKeyboardEvent eventPosition)) ifTrue: [
				w delete. 
				^ true ]]].
	
	aKeyboardEvent keyValue = $f numericValue ifTrue: [ 
		self findClassIn: aMorph owningWindow.
		^ true].

	^ false! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Editor initialize.
!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3667-GlobalFindClass-GastonCaruso-2019Mar17-08h12m-GC.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3667] on 18 March 2019 at 9:47:50 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 3/18/2019 09:47:05' prior: 50431505!
                 knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('GC' 						'Gastn Caruso')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 						'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse'	 	'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3668-AddBorisAndMarianoAsKnownAuthors-JuanVuletich-2019Mar18-09h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3668] on 18 March 2019 at 1:14:24 pm'!
!WriteStream methodsFor: 'character writing' stamp: 'jmv 3/18/2019 12:14:37'!
                     cr
	"Append a cr character to the receiver.
	Use this method when you specifically need a cr character.
	In many cases, it is advisable to call #newLine"

	self nextPut: Character cr! !
!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'jmv 3/18/2019 12:12:55'!
        cr
	"Old Squeak Transcript protocol. Still used for some doIt examples.
	In the older TranscriptStream, it added a CR character.
	Now, finish the current incomplete entry."

	self finishEntry! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 3/18/2019 12:52:32' prior: 16842041!
    fileSize: fileEntry

	| pathName f size |
	pathName _ fileEntry pathName.
	"At least on Linux 64 Cog, opening a directory as a stream and asking #size answers some absurd number: 9223372036854775807"
	(self basicDirectoryExists: pathName) ifTrue: [^ nil ].
	f _ self concreteStreamClass new open: pathName forWrite: false.
	f ifNil: [^ nil].
	size _ f size.
	f close.
	^ size! !
!FileIOAccessor methodsFor: 'file stream creation' stamp: 'jmv 3/18/2019 13:00:59' prior: 16842134!
 privateReadOnlyFile: fileEntry
	"Open the existing file with the given name in this directory for read-only access."

	| pathName |
	pathName _ fileEntry pathName.
	(self basicDirectoryExists: pathName) ifTrue: [
		"If it is a directory, the it is not a file, and the requested file does not exist."
		^ ((FileDoesNotExistException fileName: pathName) readOnly: true) signal ].
	^(self concreteStreamClass new open: pathName forWrite: false)
		ifNil: [
			"File does not exist..."
			((FileDoesNotExistException fileName: pathName) readOnly: true) signal ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3669-FileAccessorFixes-JuanVuletich-2019Mar18-13h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3665] on 17 March 2019 at 7:32:51 am'!
!TestCase methodsFor: 'assertions' stamp: 'HAW 3/17/2019 07:08:22'!
                               shouldFail: aBlock
	
	self should: aBlock raise: Exception ! !

TestCase removeSelector: #shouldFix:!

TestCase removeSelector: #shouldFix:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3670-ShouldFail-HernanWilkinson-2019Mar17-06h57m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3665] on 17 March 2019 at 6:57:41 am'!

ChangeSelector subclass: #ChangeSelectorKeepingParameters
	instanceVariableNames: 'newSelectorKeywords currentImplementorMethodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorKeepingParameters category: #'Tools-Refactoring'!
ChangeSelector subclass: #ChangeSelectorKeepingParameters
	instanceVariableNames: 'newSelectorKeywords currentImplementorMethodNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorKeepingParameters subclass: #ChangeKeywordsSelectorOrder
	instanceVariableNames: 'changedOrder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeKeywordsSelectorOrder category: #'Tools-Refactoring'!
ChangeSelectorKeepingParameters subclass: #ChangeKeywordsSelectorOrder
	instanceVariableNames: 'changedOrder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorKeepingParameters subclass: #RenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameSelector category: #'Tools-Refactoring'!
ChangeSelectorKeepingParameters subclass: #RenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorApplier subclass: #ChangeSelectorKeepingParametersApplier
	instanceVariableNames: 'newSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorKeepingParametersApplier category: #'Tools-Refactoring'!
ChangeSelectorApplier subclass: #ChangeSelectorKeepingParametersApplier
	instanceVariableNames: 'newSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorKeepingParametersApplier subclass: #ChangeKeywordsSelectorOrderApplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeKeywordsSelectorOrderApplier category: #'Tools-Refactoring'!
ChangeSelectorKeepingParametersApplier subclass: #ChangeKeywordsSelectorOrderApplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorKeepingParametersApplier subclass: #RenameSelectorApplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameSelectorApplier category: #'Tools-Refactoring'!
ChangeSelectorKeepingParametersApplier subclass: #RenameSelectorApplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 3/17/2019 05:43:39'!
                    withIndexDo: elementAndIndexBlock separatedBy: separatorBlock
	"Evaluate the elementAndIndexBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	1 to: self size do: [:index |
		index = 1 ifFalse: [separatorBlock value].
		elementAndIndexBlock value: (self at: index) value: index]! !
!CodeWindow methodsFor: 'as yet unclassified' stamp: 'HAW 3/16/2019 17:58:08'!
                     changeKeywordOrder

	model selectedMessageName ifNotNil: [ :oldSelector |
		ChangeKeywordsSelectorOrderApplier createAndValueHandlingExceptions: [
			ChangeKeywordsSelectorOrderApplier on: model for: oldSelector in: model selectedClassOrMetaClass ]].! !
!TestCase methodsFor: 'assertions' stamp: 'HAW 3/17/2019 06:29:53'!
                              shouldntFail: aBlock

	self shouldnt: aBlock raise: Error! !
!ChangeSelectorKeepingParameters methodsFor: 'create new implementors - private' stamp: 'HAW 3/17/2019 06:24:07'!
                 addImplementorSelectorRanges: aKeywordRange at: index to: rangesToNewKeywords

	self subclassResponsibility ! !
!ChangeSelectorKeepingParameters methodsFor: 'create new implementors - private' stamp: 'HAW 3/17/2019 06:24:07'!
                              implementorNewSourceCodeOf: anImplementor

	|  newSource rangesToNewKeywords |

	rangesToNewKeywords := OrderedCollection new.
	currentImplementorMethodNode := anImplementor methodNode.

	currentImplementorMethodNode selectorKeywordsPositions withIndexDo: [ :aKeywordRange :index |
		self addImplementorSelectorRanges: aKeywordRange at: index to: rangesToNewKeywords ].

	newSource := anImplementor sourceCode copyReplacing: rangesToNewKeywords.
	^newSource! !
!ChangeSelectorKeepingParameters methodsFor: 'rename senders - private' stamp: 'HAW 3/17/2019 06:02:54'!
          addMessageSendSelectorKeywordRangesOf: aMethodNode to: rangesToKeywords

	| oldSelectorKeywordsRanges |

	oldSelectorKeywordsRanges := aMethodNode messageSendSelectorKeywordPositionsOf: oldSelector ifAbsent: [ #() ].
	oldSelectorKeywordsRanges do: [ :aMessageSendSelectorRanges |
		aMessageSendSelectorRanges withIndexDo: [ :aRange :index | rangesToKeywords add: aRange -> (newSelectorKeywords at: index) ]].
	! !
!ChangeSelectorKeepingParameters methodsFor: 'initialization' stamp: 'HAW 3/17/2019 06:03:03'!
   initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders

	super initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders.

	newSelectorKeywords := newSelector keywords.
	! !
!ChangeSelectorKeepingParameters class methodsFor: 'instance creation' stamp: 'HAW 3/17/2019 05:58:22'!
                 from: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders

	self assertIsValidToRenameFrom: anOldSelector to: aNewSelector.
	self assertIsNotEmpty: aCollectionOfImplementors signalMessageText: self implementorsCanNotBeEmptyErrorMessage.
	self assertAllImplementors: aCollectionOfImplementors haveSame: anOldSelector.
	self assertNoImplementorClassIn: aCollectionOfImplementors implements: aNewSelector.
	self assertAllSenders: aCollectionOfSenders send: anOldSelector.

	self warnIfImplementionsOf: aNewSelector overridesImplementationInSuperclassesOf: aCollectionOfImplementors.

	^self new initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders
	! !
!ChangeSelectorKeepingParameters class methodsFor: 'instance creation' stamp: 'HAW 3/17/2019 05:58:34'!
                             from: anOldSelector to: aNewSelector in: aClassToRefactor

	| implementors senders |

	implementors := OrderedCollection new.
	senders := OrderedCollection new.

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aClassToRefactor theNonMetaClass.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders ! !
!ChangeSelectorKeepingParameters class methodsFor: 'instance creation' stamp: 'HAW 3/17/2019 05:58:38'!
                      from: anOldSelector to: aNewSelector inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	| implementors senders |

	implementors := IdentitySet new.
	senders := IdentitySet new.

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders
! !
!ChangeSelectorKeepingParameters class methodsFor: 'instance creation' stamp: 'HAW 3/17/2019 05:58:43'!
             from: anOldSelector to: aNewSelector inCategoryOf: aClass organizedBy: anOrganization

	| implementors senders |

	implementors := OrderedCollection new.
	senders := OrderedCollection new.

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aClass category organizedBy: anOrganization.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders
! !
!ChangeSelectorKeepingParameters class methodsFor: 'instance creation' stamp: 'HAW 3/17/2019 05:58:47'!
                      from: anOldSelector to: aNewSelector inHierarchyOf: aClass

	| implementors senders |

	implementors := OrderedCollection new.
	senders := OrderedCollection new.
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders

	! !
!ChangeSelectorKeepingParameters class methodsFor: 'instance creation' stamp: 'HAW 3/17/2019 05:58:52'!
                  from: anOldSelector to: aNewSelector inSystem: aSystem

	| implementors senders |

	implementors := OrderedCollection new.
	senders := OrderedCollection new.

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inSystem: aSystem.

	^self from: anOldSelector to: aNewSelector implementors: implementors senders: senders
	! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:02'!
                             assert: aNewSelector hasTheSameNumberOfArgumentsAs: anOldSelector

	aNewSelector numArgs ~= anOldSelector numArgs ifTrue: [ self signalNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector ]! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:07'!
   assert: aNewSelector isNotEqualTo: anOldSelector

	 aNewSelector = anOldSelector ifTrue: [ self signalNewSelectorEqualToOldSelector]! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:44'!
                   assert: aNewSelector isOfSameTypeAs: anOldSelector

	(self isRenamingBetweenBinary: anOldSelector andKeywordOfOneParameter: aNewSelector) ifTrue: [ ^self ].
	(self isRenamingBetweenBinary: aNewSelector andKeywordOfOneParameter: anOldSelector) ifTrue: [ ^self ].

	aNewSelector precedence ~= anOldSelector precedence ifTrue: [
		self signalNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector ]! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:14'!
        assertIsNotEmpty: aCollection signalMessageText: errorMessageText

	aCollection isEmpty ifTrue: [ self refactoringError: errorMessageText ].! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:19'!
           assertIsValidToRenameFrom: anOldSelector to: aNewSelector

	self assertIsNotEmpty: anOldSelector signalMessageText: self oldSelectorCanNotBeEmptyErrorMessage.
	self assertIsNotEmpty: aNewSelector signalMessageText: self newSelectorCanNotBeEmptyErrorMessage.
	self assert: aNewSelector isNotEqualTo: anOldSelector.
	self assert: aNewSelector isOfSameTypeAs: anOldSelector.
	self assert: aNewSelector hasTheSameNumberOfArgumentsAs: anOldSelector.
	! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:23'!
                         assertNoImplementorClassIn: implementorsCollection implements: aNewSelector

	| classesImplementingNewSelector |

	classesImplementingNewSelector := implementorsCollection
		select: [ :anImplementor | anImplementor methodClass includesSelector: aNewSelector ]
		thenCollect: [ :anImplementor | anImplementor methodClass ].

	classesImplementingNewSelector notEmpty ifTrue: [ self signalNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector ]! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:50'!
         isRenamingBetweenBinary: aPotentiallyBinarySelector andKeywordOfOneParameter: aPotentiallyKeywordSelector

	^aPotentiallyBinarySelector isInfix
		and: [ aPotentiallyKeywordSelector isKeyword
		and: [ aPotentiallyKeywordSelector numArgs = 1 ]]
! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 05:59:54'!
    warnIfImplementionsOf: aNewSelector overridesImplementationInSuperclassesOf: implementorsCollection

	implementorsCollection do: [:anImplementor |
		anImplementor methodClass
			withSuperclassThatIncludesSelector: aNewSelector
			do: [ :aSuperclass | self warnImplementionOf: aNewSelector in: anImplementor methodClass willOverrideImplementationIn: aSuperclass ]
			ifNone: []]! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:00'!
  errorMessageForNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector

	^'New selector #', aNewSelector, ' does not have the same number of arguments as #', anOldSelector ! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:04'!
                           errorMessageForNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector

	^'Can not rename because #', aNewSelector, ' is implemented in: ', classesImplementingNewSelector asCommaStringAnd ! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:07'!
            errorMessageForNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector

	^'New selector #', aNewSelector, ' is not of same type as #', anOldSelector ! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:11'!
   implementorsCanNotBeEmptyErrorMessage

	^'There are no methods to rename'! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:16'!
                  newSelectorCanNotBeEmptyErrorMessage

	^'New selector can not be empty'! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:19'!
                    newSelectorEqualToOldSelectorErrorMessage

	^'There is nothing to rename when new selector is equals to old selector'! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:23'!
      oldSelectorCanNotBeEmptyErrorMessage

	^'Old selector can not be empty'! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:27'!
                    signalNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector

	self refactoringError: (self errorMessageForNewSelector: aNewSelector doesNotHaveSameNumberOfArgumentsAs: anOldSelector).! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:30'!
              signalNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector

	self refactoringError: (self errorMessageForNewSelector: aNewSelector implementedInAll: classesImplementingNewSelector).! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:33'!
                signalNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector

	self refactoringError: (self errorMessageForNewSelector: aNewSelector isNotOfSameTypeAs: anOldSelector).! !
!ChangeSelectorKeepingParameters class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:00:37'!
                signalNewSelectorEqualToOldSelector

	self refactoringError: self newSelectorEqualToOldSelectorErrorMessage.! !
!ChangeSelectorKeepingParameters class methodsFor: 'warnings' stamp: 'HAW 3/17/2019 06:00:42'!
                 warnImplementionOf: aNewSelector in: aClass willOverrideImplementationIn: aSuperclass

	self refactoringWarning: (self warningMessageForImplementationOf: aNewSelector in: aClass willOverrideImplementationIn: aSuperclass).! !
!ChangeSelectorKeepingParameters class methodsFor: 'warnings' stamp: 'HAW 3/17/2019 06:00:46'!
warningMessageForImplementationOf: aNewSelector in: aClass willOverrideImplementationIn: aSuperclass

	^'Implemention of #', aNewSelector, ' in ', aClass name, ' will override implementation in ', aSuperclass name! !
!ChangeKeywordsSelectorOrder methodsFor: 'initialization' stamp: 'HAW 3/17/2019 06:14:09'!
            initializeChangedOrder: aChangeOrder

	changedOrder := aChangeOrder ! !
!ChangeKeywordsSelectorOrder methodsFor: 'create new implementors - private' stamp: 'HAW 3/17/2019 06:24:07'!
          addImplementorSelectorRanges: aKeywordRange at: index to: rangesToNewKeywords

	rangesToNewKeywords add: aKeywordRange -> (newSelectorKeywords at: index).
	rangesToNewKeywords add:
		(currentImplementorMethodNode parameterDefinitionPositionAt: index) ->
		(currentImplementorMethodNode argumentNames at: (changedOrder at: index))! !
!ChangeKeywordsSelectorOrder class methodsFor: 'instance creation' stamp: 'HAW 3/17/2019 06:11:48'!
               from: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders

	| changedOrder |

	self assertIsKeywordWithMoreThanOneParameter: anOldSelector.
	changedOrder := self changedOrderFrom: anOldSelector to: aNewSelector.

	^ (super from: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders)
		initializeChangedOrder: changedOrder
! !
!ChangeKeywordsSelectorOrder class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 06:18:21'!
                        assertIsKeywordWithMoreThanOneParameter: anOldSelector

	(anOldSelector isKeyword and: [ anOldSelector numArgs > 1 ]) ifFalse: [ self signalSelectorToChangeIsNotKeywordWithMoreThanOneParameter ]! !
!ChangeKeywordsSelectorOrder class methodsFor: 'exceptions' stamp: 'HAW 3/16/2019 17:45:39'!
                             newSelectorDoesNotIncludeOldSelectorKeywordsErrorMessage

	^'New selector keywords do not include old selector keywords'! !
!ChangeKeywordsSelectorOrder class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:18:58'!
       selectorToChangeIsNotKeywordWithMoreThanOneParameterErrorMessage

	^'Can only change a selector order for keyword messages with more that one parameter'! !
!ChangeKeywordsSelectorOrder class methodsFor: 'exceptions' stamp: 'HAW 3/16/2019 17:45:39'!
       signalNewSelectorDoesNotIncludeOldSelectorKeywords

	self refactoringError: self newSelectorDoesNotIncludeOldSelectorKeywordsErrorMessage! !
!ChangeKeywordsSelectorOrder class methodsFor: 'exceptions' stamp: 'HAW 3/17/2019 06:18:58'!
                      signalSelectorToChangeIsNotKeywordWithMoreThanOneParameter

	self refactoringError: self selectorToChangeIsNotKeywordWithMoreThanOneParameterErrorMessage! !
!ChangeKeywordsSelectorOrder class methodsFor: 'changed order' stamp: 'HAW 3/17/2019 06:13:43'!
   changedOrderFrom: anOldSelector to: aNewSelector

	| changedOrder newSelectorKeywords |

	changedOrder := Dictionary new.
	newSelectorKeywords := aNewSelector keywords.
	anOldSelector keywords withIndexDo: [ :keyword :index |
		changedOrder
			at: (newSelectorKeywords indexOf: keyword ifAbsent: [ self signalNewSelectorDoesNotIncludeOldSelectorKeywords ])
			put: index ].

	^changedOrder ! !
!RenameSelector methodsFor: 'create new implementors - private' stamp: 'HAW 3/17/2019 06:24:07'!
                     addImplementorSelectorRanges: aKeywordRange at: index to: rangesToNewKeywords

	rangesToNewKeywords add: aKeywordRange -> (newSelectorKeywords at: index) 	! !
!ChangeSelectorKeepingParametersApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/17/2019 06:52:15'!
         askNewSelector

	| enteredString |

	enteredString := self request: 'Enter new selector:' initialAnswer: oldSelector.
	newSelector := enteredString withBlanksTrimmed asSymbol.

! !
!ChangeSelectorKeepingParametersApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/17/2019 06:52:23'!
                   assertCanRenameSelector

	self refactoringClass assertIsValidToRenameFrom: oldSelector to: newSelector.
	! !
!ChangeSelectorKeepingParametersApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/17/2019 06:52:38'!
                           requestRefactoringParameters

	self
		askNewSelector;
		assertCanRenameSelector
		! !
!ChangeSelectorKeepingParametersApplier methodsFor: 'refactoring - creation' stamp: 'HAW 3/17/2019 06:52:28'!
                            createRefactoring

	^self refactoringClass from: oldSelector to: newSelector implementors: implementors senders: senders.
	! !
!ChangeKeywordsSelectorOrderApplier methodsFor: 'refactoring - creation' stamp: 'HAW 3/16/2019 17:55:35'!
                       refactoringClass

	^ChangeKeywordsSelectorOrder ! !
!ChangeKeywordsSelectorOrderApplier class methodsFor: 'pre-conditions' stamp: 'HAW 3/17/2019 06:50:17'!
    assertCanApplyRefactoringFor: aSelector in: aClass

	ChangeKeywordsSelectorOrder assertIsKeywordWithMoreThanOneParameter: aSelector ! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 3/17/2019 06:46:00' prior: 50446088!
                 messsageRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename... (R)'.
				#selector 		-> 		#renameSelector.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		15.
				#label 			-> 		'change keyword order...'.
				#selector 		-> 		#changeKeywordOrder.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'add parameter...'.
				#selector 		-> 		#addParameter.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove parameter...'.
				#selector 		-> 		#removeParameter.
				#icon 			-> 		#listRemoveIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'push up'.
				#selector 		-> 		#pushUpSelector.
				#icon 			-> 		#goTopIcon
			} asDictionary.
	}`.

	! !

RenameSelectorApplier removeSelector: #askNewSelector!

RenameSelectorApplier removeSelector: #askNewSelector!

RenameSelectorApplier removeSelector: #assertCanRenameSelector!

RenameSelectorApplier removeSelector: #assertCanRenameSelector!

RenameSelectorApplier removeSelector: #createRefactoring!

RenameSelectorApplier removeSelector: #createRefactoring!

RenameSelectorApplier removeSelector: #requestRefactoringParameters!

RenameSelectorApplier removeSelector: #requestRefactoringParameters!

ChangeKeywordsSelectorOrderApplier class removeSelector: #m1!

RenameSelector class removeSelector: #assert:hasTheSameNumberOfArgumentsAs:!

RenameSelector class removeSelector: #assert:hasTheSameNumberOfArgumentsAs:!

RenameSelector class removeSelector: #assert:isNotEqualTo:!

RenameSelector class removeSelector: #assert:isNotEqualTo:!

RenameSelector class removeSelector: #assert:isOfSameTypeAs:!

RenameSelector class removeSelector: #assert:isOfSameTypeAs:!

RenameSelector class removeSelector: #assertIsNotEmpty:signalMessageText:!

RenameSelector class removeSelector: #assertIsNotEmpty:signalMessageText:!

RenameSelector class removeSelector: #assertIsValidToRenameFrom:to:!

RenameSelector class removeSelector: #assertIsValidToRenameFrom:to:!

RenameSelector class removeSelector: #assertNoImplementorClassIn:implements:!

RenameSelector class removeSelector: #assertNoImplementorClassIn:implements:!

RenameSelector class removeSelector: #errorMessageForNewSelector:doesNotHaveSameNumberOfArgumentsAs:!

RenameSelector class removeSelector: #errorMessageForNewSelector:doesNotHaveSameNumberOfArgumentsAs:!

RenameSelector class removeSelector: #errorMessageForNewSelector:implementedInAll:!

RenameSelector class removeSelector: #errorMessageForNewSelector:implementedInAll:!

RenameSelector class removeSelector: #errorMessageForNewSelector:isNotOfSameTypeAs:!

RenameSelector class removeSelector: #errorMessageForNewSelector:isNotOfSameTypeAs:!

RenameSelector class removeSelector: #from:to:implementors:senders:!

RenameSelector class removeSelector: #from:to:implementors:senders:!

RenameSelector class removeSelector: #from:to:in:!

RenameSelector class removeSelector: #from:to:in:!

RenameSelector class removeSelector: #from:to:inCategoriesAndHierarchyOf:organizedBy:!

RenameSelector class removeSelector: #from:to:inCategoriesAndHierarchyOf:organizedBy:!

RenameSelector class removeSelector: #from:to:inCategoryOf:organizedBy:!

RenameSelector class removeSelector: #from:to:inCategoryOf:organizedBy:!

RenameSelector class removeSelector: #from:to:inHierarchyOf:!

RenameSelector class removeSelector: #from:to:inHierarchyOf:!

RenameSelector class removeSelector: #from:to:inSystem:!

RenameSelector class removeSelector: #from:to:inSystem:!

RenameSelector class removeSelector: #implementorsCanNotBeEmptyErrorMessage!

RenameSelector class removeSelector: #implementorsCanNotBeEmptyErrorMessage!

RenameSelector class removeSelector: #isRenamigBetweenBinary:andKeywordOfOneParameter:!

RenameSelector class removeSelector: #isRenamigBetweenBinary:andKeywordOfOneParameter:!

RenameSelector class removeSelector: #isRenamingBetweenBinary:andKeywordOfOneParameter:!

RenameSelector class removeSelector: #newSelectorCanNotBeEmptyErrorMessage!

RenameSelector class removeSelector: #newSelectorCanNotBeEmptyErrorMessage!

RenameSelector class removeSelector: #newSelectorEqualToOldSelectorErrorMessage!

RenameSelector class removeSelector: #newSelectorEqualToOldSelectorErrorMessage!

RenameSelector class removeSelector: #oldSelectorCanNotBeEmptyErrorMessage!

RenameSelector class removeSelector: #oldSelectorCanNotBeEmptyErrorMessage!

RenameSelector class removeSelector: #signalNewSelector:doesNotHaveSameNumberOfArgumentsAs:!

RenameSelector class removeSelector: #signalNewSelector:doesNotHaveSameNumberOfArgumentsAs:!

RenameSelector class removeSelector: #signalNewSelector:implementedInAll:!

RenameSelector class removeSelector: #signalNewSelector:implementedInAll:!

RenameSelector class removeSelector: #signalNewSelector:isNotOfSameTypeAs:!

RenameSelector class removeSelector: #signalNewSelector:isNotOfSameTypeAs:!

RenameSelector class removeSelector: #signalNewSelectorEqualToOldSelector!

RenameSelector class removeSelector: #signalNewSelectorEqualToOldSelector!

RenameSelector class removeSelector: #warnIfImplementionsOf:overridesImplementationInSuperclassesOf:!

RenameSelector class removeSelector: #warnIfImplementionsOf:overridesImplementationInSuperclassesOf:!

RenameSelector class removeSelector: #warnImplementionOf:in:willOverrideImplementationIn:!

RenameSelector class removeSelector: #warnImplementionOf:in:willOverrideImplementationIn:!

RenameSelector class removeSelector: #warningMessageForImplementationOf:in:willOverrideImplementationIn:!

RenameSelector class removeSelector: #warningMessageForImplementationOf:in:willOverrideImplementationIn:!

RenameSelector removeSelector: #addMessageSendSelectorKeywordRangesOf:to:!

RenameSelector removeSelector: #addMessageSendSelectorKeywordRangesOf:to:!

RenameSelector removeSelector: #addRanges:at:to:!

RenameSelector removeSelector: #implementorNewSourceCodeOf:!

RenameSelector removeSelector: #implementorNewSourceCodeOf:!

RenameSelector removeSelector: #initializeFrom:to:implementors:senders:!

RenameSelector removeSelector: #initializeFrom:to:implementors:senders:!

ChangeKeywordsSelectorOrder class removeSelector: #assertIsNotUnary:!

ChangeKeywordsSelectorOrder class removeSelector: #assertIsValidToRenameFrom:to:!

ChangeKeywordsSelectorOrder class removeSelector: #canChangeOrderOfKeywordsInKeywordMessagesErrorDescription!

ChangeKeywordsSelectorOrder class removeSelector: #canOnlyChangeSelectorOrderForKeywordMessagesWithMoreThanOneParameterErrorDescription!

ChangeKeywordsSelectorOrder class removeSelector: #cannotChangeSelectorOrderForAUnaryMessage!

ChangeKeywordsSelectorOrder class removeSelector: #cannotChangeSelectorOrderForAnUnaryMessage!

ChangeKeywordsSelectorOrder class removeSelector: #newSelectorDoesNotIncludeOldSelectorKeywords!

ChangeKeywordsSelectorOrder class removeSelector: #signalCanChangeOrderOfKeywordsInKeywordMessages!

ChangeKeywordsSelectorOrder class removeSelector: #signalCannotChangeSelectorOrderForAUnaryMessage!

ChangeKeywordsSelectorOrder class removeSelector: #signalCannotChangeSelectorOrderForAnUnaryMessage!

ChangeKeywordsSelectorOrder removeSelector: #addRanges:at:to:!

ChangeKeywordsSelectorOrder removeSelector: #apply!

ChangeKeywordsSelectorOrder removeSelector: #implementorNewSourceCodeOf:!

ChangeKeywordsSelectorOrder removeSelector: #initializeChangeOrder:!

ChangeKeywordsSelectorOrder removeSelector: #initializeRenameRefactoring:!

ChangeSelectorKeepingParameters removeSelector: #addRanges:at:to:!

ChangeSelectorKeepingParameters subclass: #RenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameSelector category: #'Tools-Refactoring'!
ChangeSelectorKeepingParameters subclass: #RenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ChangeSelectorKeepingParametersApplier subclass: #RenameSelectorApplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameSelectorApplier category: #'Tools-Refactoring'!
ChangeSelectorKeepingParametersApplier subclass: #RenameSelectorApplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3671-ChangeKeywordsSelectorOrder-HernanWilkinson-2019Mar16-16h37m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3610] on 17 March 2019 at 6:14:00 pm'!
!TextModel methodsFor: 'as yet unclassified' stamp: 'jpb 3/17/2019 18:09:39'!
          saveOn: stream as: format
	"Saves the model to the given stream"
	stream binary.
	stream nextPutAll: self actualContents asString.! !
!SystemWindow methodsFor: 'user interface' stamp: 'jpb 3/17/2019 18:12:16'!
              saveContents
	"Prompts the user for a file name and saves the contents to the file"
	| fileName |
	self hasSaveAs ifFalse: [^self].
	
	fileName _ FillInTheBlankMorph request: 'Filename'.
	
	fileName isEmptyOrNil
		ifTrue: [ self notifyUserWith: 'Contents not saved']
		ifFalse: [ self saveContentsTo: fileName ].! !
!SystemWindow methodsFor: 'user interface' stamp: 'jpb 3/17/2019 18:12:28'!
                        saveContentsTo: fileName
	"Saves the contents to the given filename"
	| stream |
	self hasSaveAs ifFalse: [^self].
	
	stream _ StandardFileStream new.
	stream open: fileName forWrite: true.
	
	model saveOn: stream as: 'text/plain'.
	
	stream closed ifFalse: [stream close].
	self notifyUserWith: 'Contents saved'.! !
!SystemWindow methodsFor: 'menu' stamp: 'jpb 3/16/2019 17:00:59'!
 addTileResizerMenuTo: aMenu
	"We can look at preferences here to decide what too do"
	(Preferences tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 		action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 				action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 		action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 	action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].
	^aMenu.! !
!SystemWindow methodsFor: 'user interface' stamp: 'jpb 3/17/2019 17:49:20'!
                   hasSaveAs
	"Returns true if the window has a model which can be saved to a file"
	^model respondsTo: #saveOn:as:! !
!SystemWindow methodsFor: 'user interface' stamp: 'jpb 3/17/2019 17:30:24'!
notifyUserWith: message
	"Notifies the user with a message and an 'ok' button"
	| morph |
	morph _ MenuMorph new.
	morph addTitle: message.
	morph add: 'Ok' action: nil.
	morph openInWorld.! !
!SystemWindow methodsFor: 'menu' stamp: 'jpb 3/16/2019 17:13:12'!
                             addWindowControlTo: aMenu

	aMenu
		add: 'send to back' 				action: #sendToBack 				icon: #goBottomIcon;
		add: 'make next-to-topmost' 	action: #makeSecondTopmost 	icon: #goUpIcon;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ])
											action: #toggleStickiness 			icon: (self isSticky ifFalse: [#pushPinIcon]);
		addLine;
		add: 'close' 						action: #delete 						icon: #closeIcon;
		add: 'collapse' 					action: #collapse 					icon: #collapseIcon;
		add: 'expand / contract' 		action: #expandBoxHit 				icon: #expandIcon;
		addLine;
		add: 'resize...' 					action: #resize.
		
	^aMenu! !
!SystemWindow methodsFor: 'menu' stamp: 'jpb 3/17/2019 17:42:09' prior: 50413252!
            buildWindowMenu

	| aMenu |

	aMenu _ MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' 			action: #relabel 						icon: #saveAsIcon;
		add: 'window color...' 			action: #setWindowColor 			icon: #graphicsIcon.
	
	self hasSaveAs
		ifTrue: [ aMenu add: 'Save as ...' action: #saveContents icon: #saveAsIcon ].
		
	aMenu
		addLine.
		
	self addWindowControlTo: aMenu.
	self addTileResizerMenuTo: aMenu.

	^ aMenu! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3672-text-saveAs-JosefPhilipBernhart-2019Mar17-18h07m-jpb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3672] on 19 March 2019 at 12:25:43 am'!

"Change Set:		3673-CuisCore-AuthorName-2019Mar19-00h10m
Date:			19 March 2019
Author:			Nahuel Garbezza

Support navigation between PluggableListMorph using left and right arrows. Refactored the key events handler"!

PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView leftSibling rightSibling '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #PluggableListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView leftSibling rightSibling'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!PluggableListMorph methodsFor: 'events' stamp: 'RNG 3/19/2019 00:18:17'!
                  gainFocusFrom: aHand

	aHand newKeyboardFocus: self.
	self getCurrentSelectionIndex = 0 ifTrue: [ self selectionIndex: 1 ].! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/16/2019 14:24:13'!
          navigateDown
	"move down, wrapping to top if needed"

	| nextSelection |
	nextSelection _ self getCurrentSelectionIndex + 1.
	nextSelection > self maximumSelection ifTrue: [ nextSelection _ 1 ].
	
	self changeSelectionTo: nextSelection! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/19/2019 00:16:46'!
                          navigateLeft

	leftSibling ifNotNil: [ leftSibling gainFocusFrom: self activeHand ]! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/16/2019 14:21:05'!
                  navigateOnePageDown

	| nextSelection |
	nextSelection _ self getCurrentSelectionIndex + self numSelectionsInView min: self maximumSelection.
	
	self getCurrentSelectionIndex ~= nextSelection
		ifTrue: [ self changeSelectionTo: nextSelection ]! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/16/2019 14:23:27'!
                  navigateOnePageUp

	self changeSelectionTo: (self minimumSelection max: self getCurrentSelectionIndex - self numSelectionsInView)! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/19/2019 00:16:35'!
    navigateRight

	rightSibling ifNotNil: [ rightSibling gainFocusFrom: self activeHand ]! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/16/2019 14:23:47'!
               navigateToBottom
	
	self changeSelectionTo: self maximumSelection! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/16/2019 14:23:57'!
    navigateToTop
	
	self changeSelectionTo: 1! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/16/2019 14:24:07'!
                           navigateUp
	"move up, wrapping to bottom if needed"

	| nextSelection |
	nextSelection _ self getCurrentSelectionIndex - 1.
	nextSelection < 1 ifTrue: [ nextSelection _ self maximumSelection ].
	
	self changeSelectionTo: nextSelection! !
!PluggableListMorph methodsFor: 'private' stamp: 'RNG 3/16/2019 14:22:49'!
       changeSelectionTo: nextSelection

	self getCurrentSelectionIndex ~= nextSelection ifTrue: [
		| window |
		window _ self owningWindow.
		(window isNil or: [ window okToChangeDueTo: self ]) ifTrue: [
			"No change if model is locked"
			"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
			self listMorph highlightedRow: nextSelection.
			"Update the model in next world cycle, so user gets the immediate feedback."
			UISupervisor whenUIinSafeState: [ self setSelectionIndex: nextSelection ].
		]
	]! !
!PluggableListMorph methodsFor: 'siblings' stamp: 'RNG 3/16/2019 14:08:59'!
                           leftSibling: aListMorphToTheLeft

	leftSibling _ aListMorphToTheLeft! !
!PluggableListMorph methodsFor: 'siblings' stamp: 'RNG 3/16/2019 14:08:42'!
            leftSibling: aListMorphToTheLeft rightSibling: aListMorphToTheRight

	self leftSibling: aListMorphToTheLeft.
	self rightSibling: aListMorphToTheRight.! !
!PluggableListMorph methodsFor: 'siblings' stamp: 'RNG 3/16/2019 14:08:55'!
                          rightSibling: aListMorphToTheRight

	rightSibling _ aListMorphToTheRight! !
!PluggableListMorph methodsFor: 'events' stamp: 'RNG 3/16/2019 14:27:45' prior: 50374041!
                          keyStroke: aKeyboardEvent 
	"Process keys"
	
	| aCharacter |
	(Theme current keyStroke: aKeyboardEvent morph: self)
		ifTrue: [^ self].
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self arrowKey: aKeyboardEvent) ifNotNil: [ ^ self ].
	aCharacter _ aKeyboardEvent keyCharacter.
	aCharacter numericValue = 27 ifTrue: [	" escape key"
		^ self mouseButton2Activity].
	aKeyboardEvent anyModifierKeyPressed
		ifTrue: [
			(self keystrokeAction: aCharacter)
				ifTrue: [ ^self ]].
	^ self keyboardSearch: aCharacter! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'RNG 3/19/2019 00:12:56' prior: 50391355!
    arrowKey: aKeyboardEvent

	aKeyboardEvent isArrowUp ifTrue: [ ^ self navigateUp ].
	aKeyboardEvent isArrowDown ifTrue: [ ^ self navigateDown ].
	aKeyboardEvent isArrowLeft ifTrue: [ ^ self navigateLeft ].
	aKeyboardEvent isArrowRight ifTrue: [ ^ self navigateRight ].
	aKeyboardEvent isHome ifTrue: [ ^ self navigateToTop ].
	aKeyboardEvent isEnd ifTrue: [ ^ self navigateToBottom ].
	aKeyboardEvent isPageUp ifTrue: [ ^ self navigateOnePageUp ].
	aKeyboardEvent isPageDown ifTrue: [ ^ self navigateOnePageDown ].
	^ nil! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'RNG 3/16/2019 14:29:57' prior: 50426624!
                         buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCatList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	systemCatList rightSibling: classList.
	classList leftSibling: systemCatList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	classList makeItemsDraggable.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategoryAt:class:
		whenOutsideList: #categorizeUnderNewCategoryClass:.
		
	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'RNG 3/19/2019 00:24:39' prior: 50436859!
                      buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	classColumn _ self buildMorphicClassColumn.
	classList _ classColumn submorphs third.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: Preferences standardCodeFont height + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

PluggableListMorph removeSelector: #leftKeyPressed!

PluggableListMorph removeSelector: #rightKeyPressed!

PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView leftSibling rightSibling'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #PluggableListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #PluggableListMorph
	instanceVariableNames: 'list getListSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector menuGetter mainView leftSibling rightSibling'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3673-BrowserNavegationWithArrowKeys-NahuelGarbezza-2019Mar19-00h10m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3672] on 19 March 2019 at 2:19:53 am'!

"Change Set:		3673-CuisCore-AuthorName-2019Mar19-02h18m
Date:			19 March 2019
Author:			Nahuel Garbezza

add #isLiteralVariableNode which was needed when renaming contextually in the editor."!
!ParseNode methodsFor: 'testing' stamp: 'RNG 3/19/2019 02:18:54'!
      isLiteralVariableNode

	^ false! !
!LiteralVariableNode methodsFor: 'testing' stamp: 'RNG 3/19/2019 02:18:42'!
                 isLiteralVariableNode

	^ true! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3674-isLiteralVariableNode-NahuelGarbezza-2019Mar19-02h18m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3672] on 18 March 2019 at 6:45:12 pm'!
!TextModel methodsFor: 'testing' stamp: 'jmv 3/18/2019 18:43:10'!
         is: aSymbol
	^ aSymbol == #canSaveContents or: [ super is: aSymbol ]! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 3/18/2019 18:43:17' prior: 50448473!
                            hasSaveAs
	"Returns true if the window has a model which can be saved to a file"
	^model is: #canSaveContents! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3675-saveAs-cleanup-JuanVuletich-2019Mar18-18h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3671] on 18 March 2019 at 6:13:27 pm'!
!PasteUpMorph methodsFor: 'events' stamp: 'jmv 3/18/2019 17:56:22'!
 keyStroke: aKeyboardEvent
	"Handle a keystroke event."
	(aKeyboardEvent commandAltKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifTrue: [
			aKeyboardEvent keyCharacter = $b ifTrue: [ BrowserWindow openBrowser ].
			aKeyboardEvent keyCharacter = $f ifTrue: [ BrowserWindow findClass ]].
	"aKeyboardEvent keyCharacter print."
	^ super keyStroke: aKeyboardEvent! !
!TextEditor methodsFor: 'menu' stamp: 'jmv 5/6/2018 10:32:42' prior: 50446852!
                             getMenu
	
	^(MenuMorph new defaultTarget: self)
		addTitle: self class name;
		addStayUpIcons;
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'Help...'.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#label 			-> 		'Set Alignment...'.
				#selector 		-> 		#chooseAlignment.
				#icon 			-> 		#formatJustifyLeftIcon
			} asDictionary.
		}`! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 12/21/2018 08:09:38' prior: 50446928!
            basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:					'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:			'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R		#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y		#makeUppercase:			'Force selection to uppercase')
		#(		$U		#changeLineEndsToLf:		'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H		#cursorTopHome:			'Move cursor to start of text')
		#(		$L		#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z		#redo:						'Redo (multiple levels)')
		#(		$X		#makeLowercase:			'Force selection to lowercase')
		#(		$C		#compareToClipboard:		'Compare argument to clipboard')

		#(		$ 		#selectWord:				'Select the current word as with double clicking')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 9/6/2018 17:50:48' prior: 50446987!
                     cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$Q	#argPrev:							'Previous argument')
		#(		$A	#argNext:							'Next argument')
		#(		$D	#debugIt:							'Debug it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'HAW 7/10/2018 19:03:02' prior: 50447042!
                           smalltalkEditorMenu2Options
	
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Find...(f)'.
				#selector 		-> 		#find.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Find Again (g)'.
				#selector 		-> 		#findAgain.
				#icon 			-> 		#systemIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Use Selection for Find (j)'.
				#selector 		-> 		#setSearchString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Undo - multiple (z)'.
				#selector 		-> 		#undo.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Redo - multiple (Z)'.
				#selector 		-> 		#redo.
				#icon 			-> 		#redoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'Undo / Redo history'.
				#selector 		-> 		#offerUndoHistory.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Copy (c)'.
				#selector 		-> 		#copySelection.
				#icon 			-> 		#copyIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Cut (x)'.
				#selector 		-> 		#cut.
				#icon 			-> 		#cutIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 			-> 		'Paste (v)'.
				#selector 		-> 		#paste.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 			-> 		'Paste without Format'.
				#selector 		-> 		#pasteString.
				#icon 			-> 		#pasteIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 			-> 		'Paste...'.
				#selector 		-> 		#pasteRecent.
				#icon 			-> 		#worldIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Toggle WordWrap'.
				#selector 		-> 		#wrapOnOff.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'Set Font... (k)'.
				#selector 		-> 		#offerFontMenu.
				#icon 			-> 		#preferencesDesktopFontIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'Clear Font'.
				#selector 		-> 		#clearFont.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'Set Default Font...'.
				#selector 		-> 		#offerDefaultFontMenu.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'More...'.
				#selector 		-> 		#openMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`
! !
!Morph methodsFor: 'events' stamp: 'jmv 3/18/2019 17:39:33' prior: 16874640!
                mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed."
	evt hand releaseKeyboardFocus: self.
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: evt ].! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 3/18/2019 17:58:51' prior: 16851989!
           releaseKeyboardFocus: aMorph
	"If the given morph had the keyboard focus before, release it"
	keyboardFocus ifNotNil: [
		keyboardFocus withAllOwnersDo: [ :outerOwner |
			outerOwner == aMorph ifTrue: [self releaseKeyboardFocus]]]! !
!Theme methodsFor: 'keyboard shortcuts' stamp: 'jmv 2/23/2018 15:42:17' prior: 50447157!
                             keyStroke: aKeyboardEvent morph: aMorph

	(aKeyboardEvent commandAltKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifFalse: [ ^ false ].

	aKeyboardEvent keyValue = $w numericValue ifTrue: [
		aMorph owningWindow ifNotNil: [ :w |
			(w morphContainsPoint: (w internalizeFromWorld: aKeyboardEvent eventPosition)) ifTrue: [
				w delete. 
				^true ]	]].
"	aKeyboardEvent keyValue = $f numericValue
		ifTrue: [aMorph owningWindow ifNotNil: [ :w | w fullScreen. ^true ]].
"
	^ false! !

Theme removeSelector: #findClassIn:!

Theme removeSelector: #findClassIn:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3676-GlobalFindOnlyIfFocusOnWorld-JuanVuletich-2019Mar18-18h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3671] on 18 March 2019 at 6:16:32 pm'!
!Morph methodsFor: 'events' stamp: 'jmv 3/18/2019 18:03:59' prior: 16874517!
    keyStroke: aKeyboardEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
		
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #'keyStroke:'
		ifPresentDo: [ :handler | handler value: aKeyboardEvent ]! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 3/18/2019 18:04:07' prior: 50374006!
                       keyStroke: aKeyboardEvent

	( self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	super keyStroke: aKeyboardEvent.
	scroller keyStroke: aKeyboardEvent! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 3/18/2019 18:03:49' prior: 50374017!
                               keyStroke: aKeyboardEvent 
	"Process potential command keys"

	| args aCharacter |
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	aCharacter _ aKeyboardEvent keyCharacter.
	(self arrowKey: aCharacter)
		ifTrue: [ ^self ].
	keystrokeActionSelector ifNil: [^self].
	(args _ keystrokeActionSelector numArgs) = 1 
		ifTrue: [^mainView perform: keystrokeActionSelector with: aCharacter].
	args = 2 
		ifTrue: [
			^mainView 
				perform: keystrokeActionSelector
				with: aCharacter
				with: self].
	^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 3/18/2019 18:04:03' prior: 50448673!
                      keyStroke: aKeyboardEvent 
	"Process keys"
	
	| aCharacter |
	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	(self arrowKey: aKeyboardEvent) ifNotNil: [ ^ self ].
	aCharacter _ aKeyboardEvent keyCharacter.
	aCharacter numericValue = 27 ifTrue: [	" escape key"
		^ self mouseButton2Activity].
	aKeyboardEvent anyModifierKeyPressed
		ifTrue: [
			(self keystrokeAction: aCharacter)
				ifTrue: [ ^self ]].
	^ self keyboardSearch: aCharacter! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 3/18/2019 18:04:10' prior: 16934057!
keyStroke: aKeyboardEvent
	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].
	self textMorph keyStroke: aKeyboardEvent! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 3/18/2019 18:03:54' prior: 50374176!
                        keyStroke: aKeyboardEvent

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].

	autoCompleter 
		ifNil: [ self processKeyStroke: aKeyboardEvent ]
		ifNotNil: [
			autoCompleter
				autoCompletionAround: [ self processKeyStroke: aKeyboardEvent ]
				keyStroke: aKeyboardEvent ]! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 3/18/2019 18:03:20' prior: 16861811!
  sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		(self commandAltKeyPressed or: [ self controlKeyPressed ])
			ifTrue: [
				self keyValue = $w numericValue ifTrue: [
					aMorph owningWindow ifNotNil: [ :w |
						(w morphContainsPoint: (w internalizeFromWorld: self eventPosition)) ifTrue: [
							w delete. 
							^self ]]]].
		^ aMorph
			processKeystroke: self
			localPosition: positionInAMorph ].
	type == #keyDown ifTrue: [
		^ aMorph
			processKeyDown: self
			localPosition: positionInAMorph ].
	type == #keyUp ifTrue: [ 
		^ aMorph
			processKeyUp: self
			localPosition: positionInAMorph ].
	^ super
		sentTo: aMorph
		localPosition: positionInAMorph.! !

Theme removeSelector: #keyStroke:morph:!

Theme removeSelector: #keyStroke:morph:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Editor initialize!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3677-ThemeCleanup-JuanVuletich-2019Mar18-18h13m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3677] on 19 March 2019 at 5:25:59 pm'!
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 3/19/2019 17:25:05'!
              mouseEnter: evt
	self activeHand newKeyboardFocus: completer textMorph.
	^ super mouseEnter: evt! !
!AutoCompleterMorph methodsFor: 'event handling testing' stamp: 'jmv 3/19/2019 17:25:18'!
  handlesMouseOver: evt
	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?" 
	^true! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3678-AutoCompleterMorphFix-JuanVuletich-2019Mar19-17h25m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3678] on 19 March 2019 at 5:34:42 pm'!
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 3/19/2019 17:34:09' prior: 50449320!
                   sentTo: aMorph localPosition: positionInAMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		(self shiftPressed and: [self keyValue = 13 ]) ifTrue: [
			^BrowserWindow findClass].
		(self commandAltKeyPressed or: [ self controlKeyPressed ])
			ifTrue: [
				self keyValue = $w numericValue ifTrue: [
					aMorph owningWindow ifNotNil: [ :w |
						(w morphContainsPoint: (w internalizeFromWorld: self eventPosition)) ifTrue: [
							w delete. 
							^self ]]]].
		^ aMorph
			processKeystroke: self
			localPosition: positionInAMorph ].
	type == #keyDown ifTrue: [
		^ aMorph
			processKeyDown: self
			localPosition: positionInAMorph ].
	type == #keyUp ifTrue: [ 
		^ aMorph
			processKeyUp: self
			localPosition: positionInAMorph ].
	^ super
		sentTo: aMorph
		localPosition: positionInAMorph.! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3679-ShiftEnter-GlobalFindClass-JuanVuletich-2019Mar19-17h30m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3674] on 19 March 2019 at 6:57:48 am'!
!MessageSet methodsFor: 'message list' stamp: 'HAW 3/19/2019 06:56:35' prior: 16870002!
                       selectedMessage
	"Answer the source method for the currently selected message."

	| class selector |
	selectedMessage ifNil: [^ 'Class vanished'].
	
	class _ selectedMessage actualClass.
	selector _ selectedMessage methodSymbol.
	selector ifNil: [ ^'prims'].
	(class notNil and: [ class includesSelector: selector]) ifFalse: [
		currentCompiledMethod _ nil.
		^ 'Missing'].

	selector first isUppercase ifTrue: [
		selector == #Comment ifTrue: [
			currentCompiledMethod _ class organization commentRemoteStr.
			^ class comment].
		selector == #Definition ifTrue: [
			^ class definition].
		selector == #Hierarchy ifTrue: [^ class printHierarchy]].

	self showingDecompile ifTrue: [
		^ self decompiledSource ].

	currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: nil.
	self showingDocumentation ifTrue: [
		^ self commentContents ].

	^self sourceStringPrettifiedAndDiffed! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3680-DeletingAClassWhenSeeingImplementorsOrSenders-HernanWilkinson-2019Mar19-06h52m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3680] on 19 March 2019 at 6:37:26 pm'!
!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'HAW 3/19/2019 18:36:48' prior: 50380225!
          arrowKey: aChar
	"Handle a keyboard navigation character. Answer true if handled, false if not."
	| keyEvent answer nextSelection oldSelection |
	answer := false.
	keyEvent := aChar numericValue.
	oldSelection := self visualSelectionIndex.
	nextSelection := oldSelection.
	keyEvent = 31 ifTrue: [
		"down"
		nextSelection := oldSelection + 1.
		nextSelection > self maximumSelection ifTrue: [ nextSelection := self minimumSelection ]].
	keyEvent = 30 ifTrue: [
		"up"
		nextSelection := oldSelection - 1.
		nextSelection < self minimumSelection ifTrue: [ nextSelection := self maximumSelection ]].
	keyEvent = 1 ifTrue: [ "home"
		nextSelection := 1 ].
	keyEvent = 4 ifTrue: [ "end"
		nextSelection := scroller submorphs size ].
	keyEvent = 11 ifTrue: [ "page up"
		nextSelection := oldSelection - self numSelectionsInView max: 1 ].
	keyEvent = 12 ifTrue: [ "page down"
		nextSelection := oldSelection + self numSelectionsInView ].
	keyEvent = 29 ifTrue: [
		"right"
		selectedMorph ifNotNil: [
			(selectedMorph canExpand and: [ selectedMorph isExpanded not ])
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [ nextSelection := oldSelection + 1 ]]].
	keyEvent = 28 ifTrue: [
		"left"
		selectedMorph ifNotNil: [
			selectedMorph isExpanded
				ifTrue: [
					self toggleExpandedState: selectedMorph.
					self scrollSelectionIntoView.
					answer := true ]
				ifFalse: [
					oldSelection > self minimumSelection ifTrue: [
						nextSelection _ (oldSelection-1 to: 1 by: -1) 
							detect: [ :i | ( scroller submorphs at: i) indentLevel < selectedMorph indentLevel ] 
							ifNone: [ oldSelection ]].
					]]].
	nextSelection = oldSelection ifFalse: [
		"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
		self highlightedMorph: (self listMorphAt: nextSelection).
		"Update the model in next world cycle, so user gets the immediate feedback."
		UISupervisor whenUIinSafeState: [ self setSelectionIndex: nextSelection ].
		answer := true ].
	^ answer.! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3681-HierarchicalListMorphLeftKey-HernanWilkinson-2019Mar16-16h37m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3681] on 20 March 2019 at 7:47:50 am'!
!Stream methodsFor: 'accessing' stamp: 'HAW 3/20/2019 06:54:02'!
          nextPut: anObject when: aCondition 

	aCondition ifTrue: [ self nextPut: anObject ].! !
!Stream methodsFor: 'accessing' stamp: 'HAW 3/20/2019 06:54:23'!
       nextPutAll: aCollection when: aCondition

	aCondition ifTrue: [ self nextPutAll: aCollection ].
	! !
!Stream methodsFor: 'printing' stamp: 'HAW 3/20/2019 06:54:30'!
                           print: anObject when: aCondition 

	aCondition ifTrue: [self print: anObject].! !
!WriteStream methodsFor: 'character writing' stamp: 'HAW 3/20/2019 07:28:29'!
newLineTab: times when: aCondition

	aCondition ifTrue: [ self newLineTab: times ]

	! !
!WriteStream methodsFor: 'character writing' stamp: 'HAW 3/20/2019 07:22:21'!
                         newLineWhen: aCondition

	aCondition ifTrue: [ self newLine ]! !
!WriteStream methodsFor: 'character writing' stamp: 'HAW 3/20/2019 07:43:22'!
                 space: times when: aCondition

	aCondition ifTrue: [ self space: times ]
	
	! !
!WriteStream methodsFor: 'character writing' stamp: 'HAW 3/20/2019 07:20:05'!
  spaceWhen: aCondition
 
	aCondition ifTrue: [ self space ]! !
!WriteStream methodsFor: 'character writing' stamp: 'HAW 3/20/2019 07:26:09'!
                    tab: times when: aCondition

	aCondition ifTrue: [ self tab: times ]
	
	! !
!WriteStream methodsFor: 'character writing' stamp: 'HAW 3/20/2019 07:23:42'!
      tabWhen: aCondition

	aCondition ifTrue: [ self tab ]! !
!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'HAW 3/20/2019 07:30:29'!
         newLineWhen: aCondition

	aCondition ifTrue: [ self newLine ]
	
	! !
!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'HAW 3/20/2019 07:12:13'!
                             nextPut: anObject when: aCondition 

	aCondition ifTrue: [ self nextPut: anObject ].! !
!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'HAW 3/20/2019 07:11:01'!
          nextPutAll: aCollection when: aCondition

	aCondition ifTrue: [ self nextPutAll: aCollection ].
! !
!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'HAW 3/20/2019 07:12:56'!
                              print: anObject when: aCondition 

	aCondition ifTrue: [self print: anObject].! !
!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'HAW 3/20/2019 07:39:41'!
                spaceWhen: aCondition
 
	aCondition ifTrue: [ self space ]! !
!Transcript class methodsFor: 'old Transcript compatibility' stamp: 'HAW 3/20/2019 07:40:59'!
    tabWhen: aCondition

	aCondition ifTrue: [ self tab ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3682-nextPutWhen-HernanModrow-2019Mar20-06h53m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3682] on 20 March 2019 at 3:52:35 pm'!
!Preferences class methodsFor: 'standard queries' stamp: 'GC 3/19/2019 21:00:04' prior: 0!
     biggerCursors
	^ self
		valueOfFlag: #biggerCursors
		ifAbsent: [ false ].! !
!Preferences class methodsFor: 'themes' stamp: 'GC 3/19/2019 21:02:02' prior: 50391964!
                          cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(biggerCursors false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe false)
		(syntaxHighlightingAsYouType true)
		(tapAndHoldEmulatesButton2 true)
		(clickGrabsMorphs false)

		(syntaxHighlightingAsYouTypeAnsiAssignment false)
		(syntaxHighlightingAsYouTypeLeftArrowAssignment false)
	).
	self useMenuIcons
	".
	Theme beCurrent.
	Taskbar showTaskbar
	"! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/20/2019 15:49:29' prior: 50435248!
                  defaultFont11
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont11
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 11)
			(setListFontTo: 11)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 11)
			(setButtonFontTo: 11)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/20/2019 15:49:26' prior: 50437162!
                     defaultFont12
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont12
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 12)
			(setListFontTo: 12)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 12)
			(setButtonFontTo: 12)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/20/2019 15:49:22' prior: 50435266!
                     defaultFont14
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont14
	"

	Preferences
		setDefaultFont: Preferences defaultFontFamily
		spec: #(
			(setSystemFontTo: 14)
			(setListFontTo: 14)
			(setMenuFontTo: 14)
			(setWindowTitleFontTo: 17)
			(setCodeFontTo: 14)
			(setButtonFontTo: 14)).
	Preferences disable: #biggerCursors.
	DisplayScreen runningWorld ifNotNil: [ :world | world fontPreferenceChanged ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences standardCodeFont pointSize < 14 ifTrue: [Preferences disable: #biggerCursors]!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3683-DisableBiggerCursorsByDefault-GastonCaruso-JuanVuletich-2019Mar20-15h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3683] on 20 March 2019 at 4:37:35 pm'!
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 3/20/2019 16:36:14' prior: 50430078!
           placesToLookForPackagesDo: aBlock

	| base myDir |

	"Look inside my own folder"
	pathName ifNotNil: [
		myDir _ pathName asFileEntry parent.
		aBlock value: myDir ].

	"Look in Cuis image folder and reasonable subfolders"
	base _ DirectoryEntry smalltalkImageDirectory.
	base allDirectoriesDo: aBlock.
	
	"Look in parent directory and reasonable subfolders. 
	Useful when image is stored in a subdirectory of the main app directory.
	This could be the case when the package comes from a 'main' git repo, and image is copied from gitHub.
	First try directories including the word Cuis in the name. Then try others."
	base parent directoriesDo: [ :dir |
		('*Cuis*' match: dir name)
			ifTrue: [aBlock value: dir. dir allDirectoriesDo: aBlock]].
	base parent directoriesDo: [ :dir |
		('*Cuis*' match: dir name)
			ifFalse: [aBlock value: dir. dir allDirectoriesDo: aBlock]].

	"Also look in host OS current directory"
	(base ~= DirectoryEntry currentDirectory and: [base parent ~= DirectoryEntry currentDirectory])
		ifTrue: [
			base _ DirectoryEntry currentDirectory.
			base allDirectoriesDo: aBlock ]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3684-PreferCuisFoldersForSearchingPackages-JuanVuletich-2019Mar20-16h25m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3684] on 21 March 2019 at 11:39:19 am'!
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 3/21/2019 11:38:24' prior: 16878048!
                  placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					topLeft.
			anchoredFormOrMorph show.
			canvas fullDraw: anchoredFormOrMorph ]
		ifFalse: [
			destY _ lineY.
			canvas
				image: anchoredFormOrMorph
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height) ].
	^ true! !
!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 3/21/2019 11:37:52' prior: 16856099!
    possiblyChanged
	| embeddedMorphs |
	embeddedMorphs _ model actualContents embeddedMorphs.
	self submorphsDo: [:each| 
		(embeddedMorphs includes: each) ifFalse: [
			self privateRemove: each.
			each privateOwner: nil ]].
	embeddedMorphs do: [ :each|
		each owner == self ifFalse: [
			self addMorphFront: each.
			each hide "Show it only when properly located"]].
	owner possiblyChanged! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3685-MorphsInText-fix-JuanVuletich-2019Mar21-11h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3685] on 25 March 2019 at 4:08:19 pm'!
!Editor class methodsFor: 'class initialization' stamp: 'HAW 3/25/2019 16:06:05'!
                          collectCmdShortcutsSpecUsing: anInitializationMessage

	| shortcutsSpec dynamicInitializationMessage |
	
	shortcutsSpec := self perform: anInitializationMessage.

	dynamicInitializationMessage := (self name asString uncapitalized, anInitializationMessage asString capitalized) asSymbol.
	(Smalltalk allClassesImplementing: dynamicInitializationMessage) do: [ :aClass | 
		shortcutsSpec := shortcutsSpec, (aClass soleInstance perform: dynamicInitializationMessage) ].

	^shortcutsSpec

! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 16:02:43'!
 allCmdShortcutsSpec

	^ (self collectCmdShortcutsSpecUsing: #basicCmdShortcutsSpec), (self collectCmdShortcutsSpecUsing: #cmdShortcutsSpec)! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 15:57:24'!
                           allShiftShortcutsSpec

	^ self shiftShortcutsSpec! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 15:57:38'!
                     shiftShortcutsSpec

	^#(
		#(		'Enter' 	#globalFindClass: 'Global Find class name or fragment')
	)! !
!Editor class methodsFor: 'help' stamp: 'HAW 3/25/2019 15:33:02'!
                        formatShortcutsUsingModifierKey: aModifierKey andSpecs: aSpecs
	"Format shortcuts specs with a modifier key"
	^ String streamContents: [ :strm |
		aSpecs do: [ :triplet | | c |
			c _ triplet first = Character space
				ifFalse: [ triplet first asString, '   	' ]
				ifTrue: [ 'Space'].
			strm nextPutAll: (aModifierKey, '-', c, String tab, String tab, triplet third).
			strm newLine ]]! !
!Editor class methodsFor: 'class initialization' stamp: 'HAW 3/25/2019 15:59:28' prior: 16836902!
                     basicInitialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c initializeShortcuts; initializeCmdShortcuts ]! !
!Editor class methodsFor: 'class initialization' stamp: 'HAW 3/25/2019 15:59:22' prior: 50334906!
initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c basicInitialize ]! !
!Editor class methodsFor: 'class initialization' stamp: 'HAW 3/25/2019 16:04:41' prior: 50432189!
 initializeCmdShortcuts
	"Initialize the (unshifted) command-key (or alt-key if not on Mac) shortcut table.
	If you want to add a new shortcut for an specific editor, for example SmalltalkEditor, you should
	define the message #smalltalkEditorCmdShortcutsSpec in a class of your category and it will
	be dynamically send"

	"NOTE: if you don't know what your keyboard generates, use Sensor test"

	"
	Editor initialize
	"

	cmdShortcuts _ Array new: 256 withAll: #noop:.

	self putIntoCmdShortcuts: self allCmdShortcutsSpec
! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 15:57:29' prior: 16836973!
           basicCmdShortcutsSpec

	^#()! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 15:57:18' prior: 16836977!
                          cmdShortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	
	cmdShortcuts ifNil: [self initializeCmdShortcuts ].
	
	^cmdShortcuts! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 15:57:33' prior: 16836986!
                       cmdShortcutsSpec

	^#()! !
!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 15:58:00' prior: 16836990!
                               shortcuts
	"Same for all instances.
	A subclass could handle specific keyboard shortcuts for each instance, though."
	
	shortcuts ifNil: [ self initializeShortcuts ].
	
	^shortcuts! !
!Editor class methodsFor: 'help' stamp: 'HAW 3/25/2019 15:33:02' prior: 50423146!
                      help
	"
	TextEditor help edit
	SmalltalkEditor help edit
	"
	^ (self formatShortcutsUsingModifierKey: 'Shift' andSpecs: self allShiftShortcutsSpec) ,
		(self formatShortcutsUsingModifierKey: 'Cmd' andSpecs: self allCmdShortcutsSpec).
! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/25/2019 16:00:48' prior: 50448975!
        basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< 	#enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:					'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:			'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$Y		#makeUppercase:			'Force selection to uppercase')
		#(		$U		#changeLineEndsToLf:		'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H		#cursorTopHome:			'Move cursor to start of text')
		#(		$L		#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z		#redo:						'Redo (multiple levels)')
		#(		$X		#makeLowercase:			'Force selection to lowercase')
		#(		$C		#compareToClipboard:		'Compare argument to clipboard')

		#(		$ 		#selectWord:				'Select the current word as with double clicking')
	)! !

Editor class removeSelector: #collectCmdShortcutsSpecsUsing:!

Editor class removeSelector: #collectCmdShortcutsUsing:!

Editor class removeSelector: #formatShortcutsUsingModifierKey:AndSpecs:!

Editor class removeSelector: #initializeCmdShortcutsUsing:!

Editor class removeSelector: #initializeCmdShortcutsUsing:!

Editor initialize!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3686-EditorHelp-Mash-2019Mar25-15h30m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3659] on 18 March 2019 at 2:46:24 pm'!

Object subclass: #RefactoringApplier
	instanceVariableNames: 'requestExitBlock refactoring changes '
	classVariableNames: 'Appliers '
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RefactoringApplier category: #'Tools-Refactoring'!
Object subclass: #RefactoringApplier
	instanceVariableNames: 'requestExitBlock refactoring changes'
	classVariableNames: 'Appliers'
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!ClassDescription methodsFor: 'compiling' stamp: 'HAW 3/12/2019 22:09:16'!
                 localBindingOf: varNameSymbol

	self subclassResponsibility ! !
!Metaclass methodsFor: 'compiling' stamp: 'HAW 3/12/2019 22:08:40'!
                            localBindingOf: varNameSymbol

	^thisClass localBindingOf: varNameSymbol ! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 3/13/2019 18:05:09'!
         browseMessageList: messageList ofSize: messageListSize name: labelString autoSelect: autoSelectString

	| title |

	"Create and schedule a MessageSet browser on the message list."

	messageListSize = 0 ifTrue: [^ PopUpMenu inform: ('There are no\' , labelString) withNewLines ].

	title _ messageListSize > 1
		ifFalse: [ labelString ]
		ifTrue: [ '[', messageListSize printString, '] ', labelString].

	MessageSetWindow
		openMessageList: messageList
		label: title
		autoSelect: autoSelectString! !
!Stream methodsFor: 'accessing' stamp: 'HAW 3/13/2019 20:09:02'!
          nextPutAll: aCollection asCommaSeparated: aPrintBlock

	aCollection asCommaSeparated: aPrintBlock on: self! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/15/2019 14:38:44'!
rename: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector

	aNodeUnderCursor isTempOrArg ifTrue: [ ^self renameTemporary: aNodeUnderCursor name ].

	self ifRenameCanBeAppliedDo: [
		aNodeUnderCursor isMessageNode ifTrue: [ ^ self renameSelectorOf: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector ].
		aNodeUnderCursor isInstanceVariableNode ifTrue: [ ^ self renameInstanceVariableOn: self codeProvider for: aNodeUnderCursor name at: aSelectedClass ].
		aNodeUnderCursor isLiteralVariableNode ifTrue: [ | potentialBehavior |
			potentialBehavior := aNodeUnderCursor key value.
			potentialBehavior isBehavior ifTrue: [ ^self renameClassOn: self codeProvider for: potentialBehavior theNonMetaClass ]].

		^morph flash ]! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/15/2019 14:41:17'!
           renameSelectorOf: aMessageNode in: aSelectedClass at: aSelectedSelector
	
	RefactoringApplier renameSelectorApplier createAndValueHandlingExceptionsOn: model textProvider of: aMessageNode in: aSelectedClass at: aSelectedSelector! !
!RefactoringApplier class methodsFor: 'initialization' stamp: 'HAW 3/12/2019 22:04:08'!
initialize

	Appliers := IdentityDictionary new.! !
!RefactoringApplier class methodsFor: 'appliers' stamp: 'HAW 3/12/2019 22:03:31'!
                          registerRenameSelectorApplier: aRenameSelectorApplierClass

	Appliers at: #renameSelectorApplier put: aRenameSelectorApplierClass name! !
!RefactoringApplier class methodsFor: 'appliers' stamp: 'HAW 3/12/2019 22:05:45'!
    renameSelectorApplier
	
	^Appliers 
		at: #renameSelectorApplier 
		ifPresent: [ :anApplierName | Smalltalk classNamed: anApplierName ]
		ifAbsent: [ RenameSelectorApplier ]! !
!RefactoringApplier class methodsFor: 'appliers' stamp: 'HAW 3/12/2019 22:12:54'!
                             resetRenameSelectorApplier
	
	Appliers removeKey: #renameSelectorApplier ifAbsent: []! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/12/2019 22:26:11'!
initializeImplementorsAndSenders

	implementors := IdentitySet new.
	senders := IdentitySet new.
! !
!RenameSelectorApplier methodsFor: 'as yet unclassified' stamp: 'HAW 3/14/2019 18:08:53'!
 sendersFrom: methodReferences

	^ methodReferences collect: [:aMethodReference | aMethodReference compiledMethod ]! !
!RenameSelectorApplier class methodsFor: 'instance creation' stamp: 'HAW 3/12/2019 22:20:18'!
            createAndValueHandlingExceptionsOn: aModel for: anOldSelector in: aClassToRefactor

	self createAndValueHandlingExceptions: [ self on: aModel for: anOldSelector in: aClassToRefactor ]! !
!RenameSelectorApplier class methodsFor: 'instance creation' stamp: 'HAW 3/15/2019 13:54:21'!
       createAndValueHandlingExceptionsOn: aModel of: aMessageNode in: aSelectedClass 
	
	^self createAndValueHandlingExceptionsOn: aModel for: aMessageNode selector key in: aSelectedClass ! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 3/13/2019 18:05:40' prior: 50402397!
            browseMessageList: messageList name: labelString autoSelect: autoSelectString
	
	^self browseMessageList: messageList ofSize: messageList size name: labelString autoSelect: autoSelectString! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/15/2019 13:47:38' prior: 50443709!
                             contextualRename

	self
		withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualRenameOf: methodNode in: selectedClass]
		ifErrorsParsing: [ :anError | morph flash ].

		! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/15/2019 14:36:50' prior: 50443723!
                              contextualRenameOf: aMethodNode in: aSelectedClass

	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self rename: nodeUnderCursor in: aSelectedClass at: aMethodNode selector ]
		ifAbsent: [
			self startIndex <= aMethodNode selectorLastPosition
				ifTrue: [ self ifRenameCanBeAppliedDo: [ self renameSelectorFor: aMethodNode selector in: aSelectedClass ]]
				ifFalse: [ morph flash ]]


! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/12/2019 22:15:38' prior: 50443789!
                    renameSelectorFor: aSelector in: aClassToRefactor

	RefactoringApplier renameSelectorApplier createAndValueHandlingExceptionsOn: model textProvider for: aSelector in: aClassToRefactor ! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/15/2019 13:47:20' prior: 50443811!
  withMethodNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| selectedClass methodNode |

	selectedClass := self codeProvider selectedClassOrMetaClass.
	methodNode := [ selectedClass methodNodeFor: model actualContents ] on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: selectedClass.! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'HAW 3/12/2019 22:15:54' prior: 50443906!
                 renameSelector

	model selectedMessageName ifNotNil: [ :oldSelector |
		RefactoringApplier renameSelectorApplier createAndValueHandlingExceptionsOn: model for: oldSelector in: model selectedClassOrMetaClass ]! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'HAW 3/14/2019 18:08:17' prior: 50438432!
    changeRequestSenders
	
	applier sendersFrom: model messageList
	! !
!AddInstanceVariable methodsFor: 'accessing' stamp: 'HAW 3/14/2019 09:11:51' prior: 50438527!
                              classToRefactor

	^classToRefactor ! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/12/2019 22:25:49' prior: 50441520!
  askForImplementosAndSenders

	self 
		askScope;
		initializeImplementorsAndSenders;
		calculateImplementorsAndSenders;
		startWizard ! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/12/2019 22:25:29' prior: 50441537!
calculateImplementorsAndSenders
		
	scopeChoice = 1 ifTrue: [ ^self implementorsAndSendersForClass ].
	scopeChoice = 2 ifTrue: [ ^self implementorsAndSendersForHierarchy ].
	scopeChoice = 3 ifTrue: [ ^self implementorsAndSendersInCategory ].
	scopeChoice = 4 ifTrue: [ ^self implementorsAndSendersInCategoryAndHierarchy ].
	scopeChoice = 5 ifTrue: [ ^self implementorsAndSendersInSystem ].
	
	self error: 'Unknown scope option' 
		
		! !
!ChangeSelectorApplier class methodsFor: 'instance creation' stamp: 'HAW 3/15/2019 15:02:08' prior: 50441768!
                            on: aBrowser for: aSelector in: aClass
	
	self assertCanApplyRefactoringFor: aSelector in: aClass.
	
	^self new initializeOn: aBrowser for: aSelector in: aClass
	! !
!RenameSelectorApplier methodsFor: 'refactoring - creation' stamp: 'HAW 8/18/2018 16:56:24'!
                             createRefactoring
	
	^self refactoringClass from: oldSelector to: newSelector implementors: implementors senders: senders.
	! !

RenameSelector class removeSelector: #addActualImplementorsOf:in:to:andActualSendersTo:inSystem:!

ChangeSelector class removeSelectorIfInBaseSystem: #addActualImplementorsOf:in:to:andActualSendersTo:inSystem:!

SmalltalkEditor removeSelector: #rename:in:!

SmalltalkEditor removeSelector: #rename:in:!

SmalltalkEditor removeSelector: #renameSelectorOf:in:!

Object subclass: #RefactoringApplier
	instanceVariableNames: 'requestExitBlock refactoring changes'
	classVariableNames: 'Appliers'
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RefactoringApplier category: #'Tools-Refactoring'!
Object subclass: #RefactoringApplier
	instanceVariableNames: 'requestExitBlock refactoring changes'
	classVariableNames: 'Appliers'
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier initialize!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3687-LiveTypingRefactoringSupport-HernanWilkinson-2019Mar12-21h51m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3685] on 26 March 2019 at 7:58:13 pm'!

Refactoring subclass: #RenameGlobal
	instanceVariableNames: 'system oldName newName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameGlobal category: #'Tools-Refactoring'!
Refactoring subclass: #RenameGlobal
	instanceVariableNames: 'system oldName newName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #RenameGlobalApplier
	instanceVariableNames: 'browser newName oldName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameGlobalApplier category: #'Tools-Refactoring'!
RefactoringApplier subclass: #RenameGlobalApplier
	instanceVariableNames: 'browser newName oldName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringPrecondition subclass: #NewGlobalPrecondition
	instanceVariableNames: 'system newName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #NewGlobalPrecondition category: #'Tools-Refactoring'!
RefactoringPrecondition subclass: #NewGlobalPrecondition
	instanceVariableNames: 'system newName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/26/2019 19:11:22'!
                            renameGlobal
	
	(RenameGlobalApplier on: self for: '') value! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/26/2019 18:42:51'!
              renameGlobalOn: aBrowser for: anOldName

	(RenameGlobalApplier on: aBrowser for: anOldName) value! !
!RenameGlobal methodsFor: 'applying' stamp: 'HAW 3/26/2019 18:34:07'!
                     apply
	
	| renamedReferences |
	
	system at: newName put: (system at: oldName).
	renamedReferences := self renameReferences.
	system removeKey: oldName.
	
	^renamedReferences 
	! !
!RenameGlobal methodsFor: 'initialization' stamp: 'HAW 3/26/2019 17:55:21'!
                               initializeFrom: anOldName to: aNewName in: aSystem  

	oldName := anOldName.
	newName := aNewName.
	system := aSystem.
	
	! !
!RenameGlobal methodsFor: 'accessing' stamp: 'HAW 3/26/2019 17:56:01'!
                           newName
	
	^newName ! !
!RenameGlobal methodsFor: 'accessing' stamp: 'HAW 3/26/2019 18:03:41'!
 referencesToOldName
	
	^system allCallsOn: oldName! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 17:55:21'!
                          newSourceCodeOf: aCompiledMethod 
	
	| newSource |
	
	newSource := aCompiledMethod sourceCode copyReplacing: (self rangesToReplaceOf: aCompiledMethod) with: newName.

	^newSource! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 18:12:45'!
                          rangesForLiteralOf: methodNode
	
	| literalRanges |
	
	literalRanges := methodNode positionsForLiteralNode: oldName ifAbsent: [ #() ].
	literalRanges := literalRanges collect: [ :aRange | aRange first + 1 to: aRange last ].
	
	^literalRanges ! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 18:12:31'!
                          rangesForLiteralVariableOf: methodNode
	
	^methodNode positionsForLiteralVariableNode: oldName ifAbsent: [ #() ]
	! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 17:14:05'!
                          rangesToReplaceOf: aCompiledMethod 
	
	| methodNode ranges |
	
	methodNode := aCompiledMethod methodNode.
	ranges := SortedCollection sortBlock: [ :leftRange :rightRange | leftRange first < rightRange first ].
	
	ranges addAll: (self rangesForLiteralVariableOf: methodNode).
	ranges addAll: (self rangesForLiteralOf: methodNode).
	
	^ranges ! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 19:36:06'!
                       references: aMethodReference classVarNamed: aName

	^aMethodReference actualClass theNonMetaClass definesClassVariableNamedInHierarchy: aName ! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 18:25:27'!
                              referencesOldName: aMethodReference

	^self references: aMethodReference classVarNamed: oldName ! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 18:34:48'!
            rejectReferencesToClassVariablesFrom: references
	
	^references reject: [ :aMethodReference | self referencesOldName: aMethodReference ].! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 17:14:05'!
   renameReference: aReferencingMethod 
	
	| newSource |
	
	newSource := self newSourceCodeOf: aReferencingMethod.
	aReferencingMethod methodClass compile: newSource ! !
!RenameGlobal methodsFor: 'applying - private' stamp: 'HAW 3/26/2019 18:51:20'!
         renameReferences
	
	| references |
	
	references := self referencesToOldName.
	references := self rejectReferencesToClassVariablesFrom: references.
	references do: [ :aReference | self renameReference: aReference compiledMethod ].
	
	^references! !
!RenameGlobal class methodsFor: 'pre-conditions' stamp: 'HAW 3/26/2019 19:17:48'!
                     assert: anOldName isDefinedIn: aSystem
	
	(aSystem bindingOf: anOldName) ifNil: [ self signalGlobalNotDefined: anOldName ]! !
!RenameGlobal class methodsFor: 'pre-conditions' stamp: 'HAW 3/26/2019 17:20:18'!
                assert: anOldName isNotEqualTo: aNewName

	anOldName = aNewName ifTrue: [ self signalNewNameEqualsOldName]! !
!RenameGlobal class methodsFor: 'pre-conditions' stamp: 'HAW 3/26/2019 17:18:11'!
assertIsNotClass: anOldName

	(Smalltalk classNamed: anOldName) ifNotNil: [ self signalGlobalToRenameCanNotBeClass]! !
!RenameGlobal class methodsFor: 'pre-conditions' stamp: 'HAW 3/26/2019 19:50:14'!
                       assertIsNotEmpty: anOldName

	anOldName isEmpty ifTrue: [ self signalOldNameIsEmpty ]! !
!RenameGlobal class methodsFor: 'pre-conditions' stamp: 'HAW 3/26/2019 17:39:50'!
                     newGlobalPreconditionClass

	^NewGlobalPrecondition ! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 19:18:54'!
                          errorMessageForGlobalNotDefined: anOldName

	^ anOldName asString, ' is not defined as global variable'! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:18:56'!
       globalCanNotBeClassErrorMessage
	
	^'Global to rename can not be a class'! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 18:56:16'!
     newNameEqualsOldNameErrorMessage
	
	^'New name is equal to the old one'! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 19:51:21'!
       oldNameCanNotBeEmptyErrorMessage
	
	^'Global variable name to rename can not be empty'! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 19:18:19'!
                        signalGlobalNotDefined: anOldName

	self refactoringError: (self errorMessageForGlobalNotDefined: anOldName)! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:18:37'!
  signalGlobalToRenameCanNotBeClass
	
	self refactoringError: self globalCanNotBeClassErrorMessage! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:14:05'!
              signalNewNameEqualsOldName

	self refactoringError: self newNameEqualsOldNameErrorMessage.! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 19:50:54'!
                    signalOldNameIsEmpty
	
	self refactoringError: self oldNameCanNotBeEmptyErrorMessage! !
!RenameGlobal class methodsFor: 'instance creation' stamp: 'HAW 3/26/2019 17:15:55'!
                   from: anOldName to: aNewName

	^self from: anOldName to: aNewName in: Smalltalk
	! !
!RenameGlobal class methodsFor: 'instance creation' stamp: 'HAW 3/26/2019 19:48:41'!
                      from: anOldName to: aNewName in: aSystem

	self assertIsNotEmpty: anOldName.
	self assert: anOldName isDefinedIn: aSystem.
	self assertIsNotClass: anOldName.
	self assert: anOldName isNotEqualTo: aNewName.
	self newGlobalPreconditionClass valueFor: aNewName in: aSystem.
	
	^self new initializeFrom: anOldName to: aNewName in: aSystem ! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/26/2019 17:36:48'!
      sendersFrom: methodReferences

	^ methodReferences collect: [:aMethodReference | aMethodReference compiledMethod ]! !
!RenameSelectorApplier class methodsFor: 'instance creation' stamp: 'HAW 3/26/2019 19:56:53'!
            createAndValueHandlingExceptionsOn: aModel of: aMessageNode in: aSelectedClass at: aSelectedSelector
	
	^self createAndValueHandlingExceptionsOn: aModel for: aMessageNode selector key in: aSelectedClass 
! !
!RenameGlobalApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/26/2019 18:53:42'!
           askNewName

	newName := self request: 'Enter new name:' initialAnswer: oldName asString.
	newName := newName withBlanksTrimmed asSymbol.
	! !
!RenameGlobalApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/26/2019 19:13:49'!
             askOldName

	oldName := self request: 'Enter global name to rename:' initialAnswer: oldName.
	oldName := oldName withBlanksTrimmed asSymbol.
	! !
!RenameGlobalApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/26/2019 19:13:00'!
         requestRefactoringParameters

	oldName isEmpty ifTrue: [ self askOldName ].
	self askNewName! !
!RenameGlobalApplier methodsFor: 'refactoring - creation' stamp: 'HAW 3/26/2019 18:36:05'!
     createRefactoring

	^RenameGlobal from: oldName to: newName in: Smalltalk ! !
!RenameGlobalApplier methodsFor: 'refactoring - changes' stamp: 'HAW 3/26/2019 18:35:42'!
                        openChangedMethods

	changes ifNotEmpty: [ 
		MessageSetWindow openMessageList: changes label: 'Renamed references' autoSelect: newName ]
! !
!RenameGlobalApplier methodsFor: 'refactoring - changes' stamp: 'HAW 3/26/2019 18:36:56'!
                        showChanges

	self openChangedMethods
! !
!RenameGlobalApplier methodsFor: 'initialization' stamp: 'HAW 3/26/2019 18:37:12'!
   initializeOn: aBrowser for: anOldName

	browser := aBrowser.
	oldName := anOldName.
	! !
!RenameGlobalApplier class methodsFor: 'instance creation' stamp: 'HAW 3/26/2019 19:12:35'!
           on: aBrowser 

	^self on: aBrowser for: ''! !
!RenameGlobalApplier class methodsFor: 'instance creation' stamp: 'HAW 3/26/2019 18:37:50'!
                      on: aBrowser for: anOldName

	^self new initializeOn: aBrowser for: anOldName! !
!NewGlobalPrecondition methodsFor: 'evaluating' stamp: 'HAW 3/26/2019 17:29:43'!
                              value

	self 
		assertNewNameIsNotEmpty;
		assertNewNameIsSymbol;
		assertNewNameHasNoSeparators;
		assertNewNameDoesNotExistInSystem.

! !
!NewGlobalPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/26/2019 17:26:43'!
                         assertNewNameDoesNotExistInSystem

	system at: newName ifPresent: [ :value | 
		value isBehavior 
			ifTrue: [ self signalClassAlreadyExists ]
			ifFalse: [ self signalGlobalAlreadyExists ]].! !
!NewGlobalPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/26/2019 17:27:22'!
  assertNewNameHasNoSeparators

	(newName anySatisfy: [:aChar | aChar isSeparator]) 
		ifTrue: [ self signalNewNameCanNotHaveSeparators ]! !
!NewGlobalPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/26/2019 17:28:35'!
                          assertNewNameIsNotEmpty

	newName withBlanksTrimmed isEmpty ifTrue: [ self signalNewNameCanNotBeEmpty]! !
!NewGlobalPrecondition methodsFor: 'evaluating - private' stamp: 'HAW 3/26/2019 17:29:43'!
                           assertNewNameIsSymbol

	newName isSymbol ifFalse: [ self signalNewNameMustBeSymbol]! !
!NewGlobalPrecondition methodsFor: 'initialization' stamp: 'HAW 3/26/2019 17:37:17'!
                    initializeFor: aNewName in: aSystem  

	newName := aNewName.
	system := aSystem.
! !
!NewGlobalPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:26:07'!
                          signalClassAlreadyExists

	self refactoringError: (self class errorMessageForAlreadyExistClassNamed: newName).! !
!NewGlobalPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:26:07'!
                             signalGlobalAlreadyExists

	self refactoringError: (self class errorMessageForAlreadyExistGlobalNamed: newName)! !
!NewGlobalPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:28:54'!
                            signalNewNameCanNotBeEmpty
	
	self refactoringError: self class newNameCanNotBeEmptyErrorMessage! !
!NewGlobalPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:27:57'!
           signalNewNameCanNotHaveSeparators
	
	self refactoringError: self class newNameCanNotHaveSeparatorsErrorMessage ! !
!NewGlobalPrecondition methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 17:22:52'!
                            signalNewNameMustBeSymbol

	self refactoringError: self class newNameMustBeSymbolErrorMessage.! !
!NewGlobalPrecondition class methodsFor: 'error messages' stamp: 'HAW 3/26/2019 17:26:34'!
   errorMessageForAlreadyExistClassNamed: aNewName

	^'Class named ', aNewName, ' already exist'! !
!NewGlobalPrecondition class methodsFor: 'error messages' stamp: 'HAW 3/26/2019 17:26:21'!
    errorMessageForAlreadyExistGlobalNamed: aNewName

	^'There is already a global variable named ', aNewName ! !
!NewGlobalPrecondition class methodsFor: 'error messages' stamp: 'HAW 3/26/2019 17:29:00'!
                       newNameCanNotBeEmptyErrorMessage
	
	^'New name can not be empty'! !
!NewGlobalPrecondition class methodsFor: 'error messages' stamp: 'HAW 3/26/2019 17:28:07'!
 newNameCanNotHaveSeparatorsErrorMessage
	
	^'New name can not have separators'! !
!NewGlobalPrecondition class methodsFor: 'error messages' stamp: 'HAW 3/26/2019 17:30:05'!
                   newNameMustBeSymbolErrorMessage
	
	^'New name must be a symbol'! !
!NewGlobalPrecondition class methodsFor: 'instance creation' stamp: 'HAW 3/26/2019 17:38:25'!
                               for: aNewName in: aSystem  

	^self new initializeFor: aNewName in: aSystem ! !
!NewGlobalPrecondition class methodsFor: 'evaluation' stamp: 'HAW 3/26/2019 17:40:04'!
                         valueFor: aNewName in: aSystem  

	^(self for: aNewName in: aSystem) value! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'HAW 3/26/2019 18:57:11' prior: 50450074!
                rename: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector

	aNodeUnderCursor isTempOrArg ifTrue: [ ^self renameTemporary: aNodeUnderCursor name ].

	self ifRenameCanBeAppliedDo: [
		aNodeUnderCursor isMessageNode ifTrue: [ ^ self renameSelectorOf: aNodeUnderCursor in: aSelectedClass at: aSelectedSelector ].
		aNodeUnderCursor isInstanceVariableNode ifTrue: [ ^ self renameInstanceVariableOn: self codeProvider for: aNodeUnderCursor name at: aSelectedClass ].
		aNodeUnderCursor isLiteralVariableNode ifTrue: [ | variableName |
			variableName := aNodeUnderCursor key key.
			(Smalltalk classNamed: variableName) ifNotNil: [ :classToRename | ^self renameClassOn: self codeProvider for: classToRename ].
			(Smalltalk bindingOf: variableName) ifNotNil: [ ^self renameGlobalOn: self codeProvider for: variableName ] ].

		^morph flash ]! !
!InsertSuperclass class methodsFor: 'instance creation' stamp: 'HAW 3/3/2019 09:11:31' prior: 50440554!
         to: aClass named: aSuperclassName in: aSystem undeclared: anUndeclared

	self newClassPreconditionClass valueFor: aSuperclassName in: aSystem undeclared: anUndeclared.
	
	^self new initializeTo: aClass theNonMetaClass named: aSuperclassName ! !
!RenameClass class methodsFor: 'exceptions' stamp: 'HAW 3/26/2019 18:56:37' prior: 50440835!
              newNameEqualsOldNameErrorMessage
	
	^'New class name is equal to the old one'! !
!RenameClass class methodsFor: 'instance creation' stamp: 'HAW 8/13/2018 18:45:15' prior: 50440865!
           from: aClass to: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	self assertIsNotMeta: aClass.
	self assert: aClass isNotNamed: aNewClassName.
	self newClassPreconditionClass valueFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary.
	
	^self new initializeFrom: aClass to: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 
! !
!RefactoringMenues class methodsFor: 'browser menues' stamp: 'HAW 3/26/2019 19:09:35' prior: 50446039!
        classRefactoringMenuOptions

	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename class... (R)'.
				#object 			-> 		#model.
				#selector 		-> 		#renameClass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'insert superclass...'.
				#object 			-> 		#model.
				#selector 		-> 		#insertSuperclass.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'safely remove class (x)'.
				#object 			-> 		#model.
				#selector 		-> 		#safelyRemoveClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'add inst var...'.
				#selector 		-> 		#addInstVar.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'rename inst var...'.
				#selector 		-> 		#renameInstVar.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		30.
				#label 			-> 		'remove inst var...'.
				#selector 		-> 		#removeInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		40.
				#label 			-> 		'remove all unreferenced inst var...'.
				#selector 		-> 		#removeAllUnreferencedInstVar.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 	-> 			30.
				#itemOrder 		-> 		10.
				#label 			-> 		'rename global...'.
				#object 			-> 		#model.
				#selector 		-> 		#renameGlobal.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
	}`.
	! !
!NewClassPrecondition class methodsFor: 'evaluation' stamp: 'HAW 8/13/2018 17:37:20' prior: 50442717!
                               valueFor: aNewClassName in: aSystem undeclared: anUndeclaredDictionary 

	^(self for: aNewClassName in: aSystem undeclared: anUndeclaredDictionary) value! !

NewGlobalPrecondition class removeSelector: #errorMessageForNewClassIsUndeclared:!

NewGlobalPrecondition class removeSelector: #for:in:undeclared:!

NewGlobalPrecondition class removeSelector: #newClassCanNotHaveSeparatorsErrorMessage!

NewGlobalPrecondition class removeSelector: #newClassNameCanNotBeEmptyErrorMessage!

NewGlobalPrecondition class removeSelector: #newClassNameCanNotHaveSeparatorsErrorMessage!

NewGlobalPrecondition class removeSelector: #newNameMustStartWithUppercaseLetterErrorMessage!

NewGlobalPrecondition class removeSelector: #valueFor:in:undeclared:!

NewGlobalPrecondition removeSelector: #assertNewClassNameDoesNotExistInSystem!

NewGlobalPrecondition removeSelector: #assertNewClassNameHasNoSeparators!

NewGlobalPrecondition removeSelector: #assertNewClassNameIsNotEmpty!

NewGlobalPrecondition removeSelector: #assertNewClassNameIsNotUndeclaredInUndeclared!

NewGlobalPrecondition removeSelector: #assertNewClassNameStartsWithUppercaseLetter!

NewGlobalPrecondition removeSelector: #assertNewClassNameSymbol!

NewGlobalPrecondition removeSelector: #assertNewNameSymbol!

NewGlobalPrecondition removeSelector: #initializeFor:in:undeclared:!

NewGlobalPrecondition removeSelector: #signalNewClassIsUndeclared!

NewGlobalPrecondition removeSelector: #signalNewClassNameCanNotBeEmpty!

NewGlobalPrecondition removeSelector: #signalNewClassNameCanNotHaveSeparators!

NewGlobalPrecondition removeSelector: #signalNewNameMustStartWithUppercaseLetter!

RenameGlobalApplier removeSelector: #askNewClassName!

RenameGlobalApplier removeSelector: #informChangesToBrowser!

RenameSelectorApplier class removeSelector: #createAndValueHandlingExceptionsOn:of:in:!

RenameSelectorApplier class removeSelector: #createAndValueHandlingExceptionsOn:of:in:!

RenameSelectorApplier removeSelector: #sendersFrom:!

RenameSelectorApplier removeSelector: #sendersFrom:!

RenameGlobal class removeSelector: #assert:isNotNamed:!

RenameGlobal class removeSelector: #assertIsNotMeta:!

RenameGlobal class removeSelector: #classToRenameCanNotBeMetaclassErrorMessage!

RenameGlobal class removeSelector: #from:to:in:undeclared:!

RenameGlobal class removeSelector: #newClassPreconditionClass!

RenameGlobal class removeSelector: #signalClassToRenameCanNotBeMetaclass!

RenameGlobal removeSelector: #initializeFrom:to:in:undeclared:!

RenameGlobal removeSelector: #newClassName!

RenameGlobal removeSelector: #referencesNewClassName:!

RenameGlobal removeSelector: #referencesOldClassName:!

RenameGlobal removeSelector: #referencesToOldClass!

RenameGlobal removeSelector: #referencesToOldClassName!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3688-RenameGlobalRefactoring-HernanWilkinson-2019Mar24-20h01m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3688] on 27 March 2019 at 10:21:01 am'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 3/26/2019 12:03:11' prior: 16844595!
arcTan: denominator
	"Answer the angle in radians.
	Implementation note: use sign in order to catch cases of negativeZero"

	^self = 0.0
		ifTrue: [denominator sign >= 0
			ifTrue: [ 0.0 ]
			ifFalse: [ self sign >= 0
				ifTrue: [ Pi ]
				ifFalse: [ Pi negated ]]]
		ifFalse: [denominator = 0.0
			ifTrue: [self > 0.0
				ifTrue: [ Halfpi ]
				ifFalse: [ Halfpi negated ]]
			ifFalse: [denominator > 0.0
				ifTrue: [ (self / denominator) arcTan ]
				ifFalse: [self > 0.0
					ifTrue: [ ((self / denominator) arcTan) + Pi ]
					ifFalse: [ ((self / denominator) arcTan) - Pi ]]]]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3689-ArcTanTweak-JuanVuletich-2019Mar27-10h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3689] on 28 March 2019 at 8:56:04 am'!
!Morph methodsFor: 'events' stamp: 'jmv 3/28/2019 08:54:29' prior: 50449182!
 mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed."
	Preferences focusFollowsMouse
		ifTrue: [evt hand releaseKeyboardFocus: self].
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: evt ].! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3690-FixFocusHandlingIfClickToFocusIsOn-JuanVuletich-2019Mar28-08h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3690] on 5 April 2019 at 5:29:12 pm'!
!Float commentStamp: 'jmv 4/5/2019 17:21:41' prior: 50425181!
                               A note About Floating Point numbers and Floating Point Arithmetic.

The following is not specific to Cuis or Smalltalk at all. This is about the properties of Float numbers in any computer implementation.

If you haven't done so already, read https://en.wikipedia.org/wiki/Floating-point_arithmetic

But if you find the Wikipedia article too detailed, or hard to read, then try http://fabiensanglard.net/floating_point_visually_explained/ (get past "How Floating Point are usually explained" and read "A different way to explain...").

Other great reads are:
	"Why don't my numbers add up?":
		http://floating-point-gui.de/
and
	"What Every Computer Scientist Should Know About Floating-Point Arithmetic":
		http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
and also maybe
	"Comparing floating point numbers"
		https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

Now that you read them, and we are on the same boat, some further comments (from jmv):

Floats are (conceptually) approximate real numbers. That's why trig and other trascendental functions always answer Floats. That's why it is ok to round the result of operations. That's why Float is considered more general than Fraction in ST-80 and most Smalltalks. So, when we have a Float value, we must not think about it as a Rational but as a Real (actually as some unknown Real that could hopefully be close to the Rational we can actually represent). Keep this in mind when dealing with Floats, and especially avoid comparing them for equality.

When doing mixed operations with Floats and Fractions, Cuis, as most other Smalltalks, converts all values to Floats. Some other systems, including Pharo Smalltalk, Scheme and Lisp have two rules: when the answer is a Number, they convert to Float. But when the answer is a boolean (#<, #=, #<=, etc.) they convert to Fraction. We think this is a mistake. There should never be implicit conversions from Float to Fraction. Fractions are to hold exact values, and people expect Fractions to be exact. On the other hand, Floats are to hold approximations (and people should be aware of that!!). But an implicit conversion from Float to Fraction would give a Fraction that should not be considered an exact value (the value comes from an inexact Float), but that knowledge is lost, as it is an instance of Fraction.

If you want exact arithmetic, usual mathematical properties (like transitivity of equality), can live in the limited world of Rational numbers, and can afford a slight performance penalty, use Fraction instead. Avoid trascendental functions and never convert to Float.

In any case, most numeric computation is done on Float numbers. There are good reasons for that. One is that in most cases we don't need an exact answer. And in many cases we can't really have it: the inputs to algorithms already have a limited precision, or they use trascendental functions. And even when exact arithmetic possible, if we are doing sound synthesis, 24 bits of resolution is enough. For image processing and graphics, the result is never more than 16 bits per channel. So, these fields don't really need 64 bit Doubles. 32 bit Floats are enough. Other fields do need 64 bit Doubles, like physics simulations and geometry. Games usually prefer special, faster 32 bit Float operations in GPUs that have greater errors but are faster.

There are some things that can be done to increase the confidence you can have on Float results. One is to do an error propagation analysis on the code you are running. This is not easy, but it is done for any widely used numerical method. Then, you can know real bounds and/or estimates of the errors made. So, understanding your inputs and your algorithms (for example error propagation, condition number, numeric stability), and using Float number if appropriate, is the usual advice.

Perhaps you have heard about "interval arithmetic". It is a bit better than simple Float, but doesn't really fix the problems.

The ultimate solution is to do Monte Carlo analysis, with random perturbation of inputs. After the Monte Carlo run, it is needed to do statistical analysis of possible correlations between the distributions of the random noise added to imputs and the result of the algorithm.

Additional food for thought: http://www.cs.berkeley.edu/~wkahan/Mindless.pdf . According to this, doing Monte Carlo as described above attacks a slightly different problem. This might be yet another reason (besides performance) to try something like the next paragraph. I (jmv) came up with it, and I don't really know if it has been described and or tried before or not. Mhhh. Maybe a defensive publication is in order.

A possibility that could be a practical solution, being much cheaper than Monte Carlo, but better than interval arithmetic, is to represent each value by 2 Floats: an estimation of the real value (i.e. an estimation of the mean value of the distribution of the corresponding Monte Carlo result), and an estimation of the error (i.e. an estimation of the standard deviation of the corresponding Monte Carlo result). Or perhaps even 3 of them. In addition to the estimation of the real value and an estimation of the error, we could add a hard bound on the error. In many cases it will be useless, because the error can not really be bound. But in those cases where it is possible to bound it, applications could really know about the quality of computed values.

=======================================================================

My instances represent IEEE 754 floating-point double-precision numbers. They have about 16 decimal digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:
	
	8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12

Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point. It is actually possible to specify a radix for Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:

	3r20.2 --> 6.66666666666667
	8r20.2 --> 16.25

If you don't have access to the definition of IEEE754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...
	sign		1 bit
	exponent	11 bits with bias of 1023 (16r3FF), substracted to produce an actual exponent in the range -1022 .. +1023
				- 16r000:
					significand = 0: Float zero
					significand ~= 0: Denormal number (actual exponent is -1022, not -1023. No implicit leading '1' bit in mantissa)
				- 16r7FF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE 754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.

The single-precision format is...
	sign		1 bit
	exponent	8 bits with bias of 127 (16r7F, substracted to produce an actual exponent in the range -126 .. +127
				- 16r00:
					significand = 0: Float zero
					significand ~= 0: Denormal number (actual exponent is -126, not -127. No implicit leading '1' bit in mantissa)
				- 16rFF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	24 bits, but only 23 are stored
This format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.

You might also check https://en.wikipedia.org/wiki/IEEE_754_revision

Other great reads (covering broader but interesting issues):
https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
http://www.ima.umn.edu/2010-2011/W1.10-14.11/activities/Leeser-Miriam/Leeser-GPU-IMA-Jan2011.pdf!
!Number methodsFor: 'testing' stamp: 'jmv 4/5/2019 10:02:36'!
                          isFinite
	^ true! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 09:09:44'!
          complexConjugate
	"Return the complex conjugate of this complex number."

	^self class real: real imaginary: imaginary negated! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 4/5/2019 16:19:44' prior: 50421758!
predecessor
	"Answer the largest Float smaller than self"

	self isFinite ifFalse: [
		(self isNaN or: [self negative]) ifTrue: [^self].
		^Float fmax].
	self signBit = 1 ifTrue: [ "Negative or -0.0"
		^ self nextAwayFromZero ].
	self = 0.0 ifTrue: [
		^ -0.0 ].
	^ self nextTowardsZero.! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 4/5/2019 16:11:39' prior: 50425707!
                               signBit
	"
	Actual sigh bit part of the floating point representation.
	0 means positive number or 0.0
	1 means negative number or -0.0
	Just extract the bit. Do not correct denormals. Do not subtract bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0. 0.0. -0.0} do: [ :f |
		{ f. f signBit. f signPart. f sign } print ].
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits | signBit ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 4/5/2019 16:14:21' prior: 50414515!
                   signPart
	"The sign of the mantissa.
	1 means positive number or 0.0
	-1 means negative number or -0.0
	See #mantissaPart and #exponentPart"
	"
	| f |
	f := -2.0.
	(f signPart * f mantissaPart * (2 raisedToInteger: f exponentPart-52)) asFloat.
	"
	^self partValues: [ :sign :exponent :mantissa | sign ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 4/5/2019 16:18:03' prior: 50421772!
                successor
	"Answer the smallest Float greater than self"

	self isFinite ifFalse: [
		(self isNaN or: [self positive]) ifTrue: [^self].
		^Float fmax negated].
	self signBit = 0 ifTrue: [
		^ self nextAwayFromZero ].
	self = -0.0 ifTrue: [
		^ 0.0 ].
	^ self nextTowardsZero.! !
!Float methodsFor: 'testing' stamp: 'jmv 4/5/2019 16:14:46' prior: 50425428!
                            sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.
	Handle IEEE754 negative-zero by reporting a sign of -1
	Warning!! This makes Float negativeZero the only number in the system such that
		x sign negated = x negated sign
	evaluates to false!!
	This precludes the simpler implementation in #signPart
	0.0 sign  ->  0
	0.0 signPart   ->  1
	-0.0 sign   ->  -1
	-0.0 signPart   ->  -1
	"

	"Negative number or -0.0"
	self signBit = 1 ifTrue: [ ^ -1 ].

	"Zero"
	self = 0.0 ifTrue: [ ^ 0 ].

	"Positive number otherwise"
	^ 1! !
!Float class methodsFor: 'instance creation' stamp: 'jmv 4/5/2019 17:23:54' prior: 16845757!
                          fromIEEE32Bit: word
  	"Convert the given 32 bit word (which is supposed to be a positive 32bit value) from
	a 32bit IEEE floating point representation into an actual Float object (being
	64bit wide). Should only be used for conversion in FloatArrays or likewise objects."
  	
 	| sign exponent mantissa exponentBits fractionBits answerFractionBits delta signBit answerExponent |
  	word negative ifTrue: [ ^ self error: 'Cannot deal with negative numbers' ].
  	word = 0 ifTrue: [ ^ Float zero ].
 	word = 16r80000000 ifTrue: [ ^Float negativeZero ].
  	
	signBit _ word bitAnd: 16r80000000.
	sign _ (word bitShift: -31) = 0 ifTrue: [1] ifFalse: [-1].
  	exponentBits _ (word bitShift: -23) bitAnd: 16rFF.
  	fractionBits _ word bitAnd: 16r7FFFFF.
  
	" Special cases: infinites and NaN"
	exponentBits = 16rFF ifTrue: [
  		fractionBits = 0 ifFalse: [ ^ Float nan ].
  		^ sign positive
  			ifTrue: [ Float infinity ]
  			ifFalse: [ Float negativeInfinity ]].

	" Unbias exponent: 16r3FF is bias"
	exponent _ exponentBits - 16r7F.

"Older version."
false ifTrue: [
	" Replace omitted leading 1 in fraction if appropriate"
	"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa"
 	exponentBits = 0
 		ifTrue: [
 			"gradual underflow (denormalized number)
 			There is no implied one, but the exponent is -126"
			mantissa _ fractionBits.
			answerExponent _ exponent + 1 ]
 		ifFalse: [
			mantissa _ fractionBits + 16r800000.
			answerExponent _ exponent ].
		^ (sign * mantissa) asFloat timesTwoPower: answerExponent - 23 ].

	"Newer version"
 	exponentBits = 0
		ifTrue: [
			"gradual underflow (denormalized number)
			 Remove first bit of mantissa and adjust exponent"
			delta := fractionBits highBit.
			answerFractionBits := (fractionBits bitAnd: (1 bitShift: delta - 1) - 1) bitShift: 24 - delta.
			answerExponent := exponent + delta - 23]
		ifFalse: [
			answerFractionBits _ fractionBits.
			answerExponent _ exponent ].
  
  	"Create new float"
	^ (self basicNew: 2)
		basicAt: 1 put: ((signBit bitOr: (1023 + answerExponent bitShift: 20)) bitOr: (answerFractionBits bitShift: -3));
		basicAt: 2 put: ((answerFractionBits bitAnd: 7) bitShift: 29);
		* 1.0. "reduce to SmallFloat64 if possible"

"
Float fromIEEE32Bit: Float pi asIEEE32BitWord 
(Float fromIEEE32Bit: Float pi asIEEE32BitWord ) = Float pi
(Float fromIEEE32Bit: Float pi asIEEE32BitWord ) - Float pi

Float fromIEEE32Bit: (Float pi / 1e40) asIEEE32BitWord
(Float fromIEEE32Bit: (Float pi / 1e40) asIEEE32BitWord)  = (Float pi / 1e40)
(Float fromIEEE32Bit: (Float pi / 1e40) asIEEE32BitWord)  - (Float pi / 1e40)
"! !
!Float class methodsFor: 'constants' stamp: 'jmv 4/5/2019 17:28:20' prior: 16845859!
                      denormalized
	"Answer whether implementation supports denormalized numbers.
	Denormalized numbers guarantees that the result x - y is non-zero when x !!= y."
	
	^true! !
!Float class methodsFor: 'constants' stamp: 'jmv 4/5/2019 17:28:36' prior: 16845897!
 fminDenormalized
	"Answer the minimum denormalized value representable.
	Denormalized numbers guarantees that the result x - y is non-zero when x !!= y.
	"
	
	^1.0 timesTwoPower: MinValLogBase2! !
!Float class methodsFor: 'constants' stamp: 'jmv 4/5/2019 16:58:02' prior: 16845942!
      negativeZero
	"Negative Zero is a very special number
	-0.0 = 0.0  	evaluates to true
	Any function evaluated in -0.0 gives the same result as evaluated in 0.0.
	Exceptions are:
		0.0 sign  		->		0
		-0.0 sign  		->		-1 

		0.0 negated  	->		-0.0
		-0.0 negated  	->		0.0

		0.0 sqrt  		->		0.0
		-0.0 sqrt  		->		-0.0 
	The behavior of negative zero is specified in IEEE 754
	"

	^ NegativeZero! !
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 4/5/2019 16:32:47' prior: 50400391!
              primSqrt
	"Answer the square root of the receiver. 
	 Optional. See Object documentation whatIsAPrimitive.
	Note: 
	-0.0 primSqrt 
	-0.0 sqrt
	both evaluate to -0.0
	"

	<primitive: 55>
	^Float nan! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 09:48:03' prior: 16822321!
     * aNumber
	"Answer the result of multiplying the receiver by aNumber."
	| c d newReal newImaginary |
	aNumber isComplex
		ifTrue: [
			c _ aNumber real.
			d _ aNumber imaginary.
			newReal _ (real * c) - (imaginary * d).
			newImaginary _ (real * d) + (imaginary * c) ]
		ifFalse: [
			newReal _ real * aNumber.
			newImaginary _ imaginary * aNumber ].
	^ Complex real: newReal imaginary: newImaginary! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 09:48:36' prior: 16822337!
                        + aNumber
	"Answer the sum of the receiver and aNumber."
	^ Complex
		real: real + aNumber real
		imaginary: imaginary + aNumber imaginary.! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 09:48:52' prior: 16822351!
                               - aNumber
	"Answer the difference between the receiver and aNumber."
	^ Complex
		real: real - aNumber real
		imaginary: imaginary - aNumber imaginary.! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 10:34:02' prior: 16822366!
                   / aNumber
	"Answer the result of dividing receiver by aNumber"
	| c d newReal newImaginary s e f |
	aNumber isComplex
		ifTrue: [
			c _ aNumber real.
			d _ aNumber imaginary.
			e _ (real * c) + (imaginary * d).
			e isFinite ifFalse: [ ^ self divideFastAndSecureBy: aNumber ].
			f _ (imaginary * c) - (real * d).
			s _ (c * c) + (d * d).
			(e isFloat and: [ s  = 0.0 ]) ifTrue: [ ^ self divideFastAndSecureBy: aNumber ].
			newReal _ e / s.
			newImaginary _ f / s ]
		ifFalse: [
			newReal _ real / aNumber.
			newImaginary _ imaginary / aNumber ].
	^ Complex real: newReal imaginary: newImaginary! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 09:58:22' prior: 16822414!
              divideFastAndSecureBy: aComplex
	"Answer the result of dividing receiver by aNumber"
	" Both operands are scaled to avoid arithmetic overflow. 
	  This algorithm works for a wide range of values, and it needs only three divisions."
	| r d newReal newImaginary |
	aComplex real abs > aComplex imaginary abs
		ifTrue: [
			r _ aComplex imaginary / aComplex real.
			d _ r * aComplex imaginary + aComplex real.
			newReal _ r * imaginary + real / d.
			newImaginary _ r negated * real + imaginary / d ]
		ifFalse: [
			r _ aComplex real / aComplex imaginary.
			d _ r * aComplex real + aComplex imaginary.
			newReal _ r * real + imaginary / d.
			newImaginary _ r * imaginary - real / d ].
	^ Complex
		real: newReal
		imaginary: newImaginary.! !
!Complex methodsFor: 'comparing' stamp: 'jmv 4/5/2019 08:37:31' prior: 16822502!
      = anObject
	self == anObject ifTrue: [ ^ true ].
	anObject isNumber ifFalse: [^false].
	^real = anObject real and: [ imaginary = anObject imaginary ]! !
!Transcript class methodsFor: 'private' stamp: 'jmv 4/5/2019 16:11:01' prior: 50431463!
               finishEntry
	| newEntry |
	self unfinishedEntrySize > 0 ifTrue: [
		newEntry _ unfinishedEntry contents.
		unfinishedEntry reset.
		lastDisplayPosition _ 0.
		self addEntry: newEntry.
		self display ].! !

Complex removeSelector: #conjugated!

Complex removeSelector: #conjugated!

Complex removeSelector: #divideSecureBy:!

Complex removeSelector: #divideSecureBy:!

Number removeSelector: #adaptToComplex:andSend:!

Number removeSelector: #adaptToComplex:andSend:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3691-FloatAndComplexFixes-JuanVuletich-2019Apr05-08h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3690] on 5 April 2019 at 1:21:24 am'!

"Change Set:		3691-CuisCore-AuthorName-2019Apr05-01h16m
Date:			5 April 2019
Author:			Nahuel Garbezza

replace calls to messageListIndex: 0 by reformulateList which does that"!
!Browser methodsFor: 'message functions' stamp: 'RNG 4/5/2019 01:19:29' prior: 16792332!
                  removeMessage
	"If a message is selected, create a Confirmer so the user can verify that  
	the currently selected message should be removed from the system. If 
	so,  
	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 
	confirmer is bypassed."
	| messageName confirmation |
	selectedMessage ifNil: [ ^self ].
	messageName _ self selectedMessageName.
	confirmation _ Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.
	confirmation = 3
		ifTrue: [^ self].
	self selectedClassOrMetaClass removeSelector: self selectedMessageName.
	self reformulateList.
	self changed: #messageList.
	self setClassOrganizer.
	"In case organization not cached"
	confirmation = 2
		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !
!Browser methodsFor: 'initialization' stamp: 'RNG 4/5/2019 01:19:09' prior: 16792851!
                methodCategoryChanged
	self changed: #messageCategoryList.
	self changed: #messageList.
	self triggerEvent: #annotationChanged.
	self reformulateList! !
!CodeFileBrowser methodsFor: 'removing' stamp: 'RNG 4/5/2019 01:19:43' prior: 16809136!
               removeMessage
	| messageName |
	selectedMessage ifNil: [ ^self ].
	messageName _ self selectedMessageName.
	(self selectedClass confirmRemovalOf: messageName)
		ifFalse: [^ false].
	self selectedClassOrMetaClass removeMethod: self selectedMessageName.
	self reformulateList.
	self setClassOrganizer.
	"In case organization not cached"
	self changed: #messageList! !
!CodeFileBrowser methodsFor: 'removing' stamp: 'RNG 4/5/2019 01:20:08' prior: 16809194!
                          removeUnmodifiedMethods
	| theClass cat |
	theClass := self selectedClassOrMetaClass.
	theClass ifNil: [ ^self].
	cat := self selectedMessageCategoryName.
	cat ifNil: [ ^self].
	theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).
	self reformulateList.
	self changed: #messageList.! !
!BrowserWindow methodsFor: 'refactorings' stamp: 'RNG 4/5/2019 01:18:54' prior: 50443864!
         pushUpSelector

	model selectedMessageName ifNotNil: [ :selectedSelector |
		(PushUpMethod for: model selectedClassOrMetaClass>>selectedSelector) apply.
		model reformulateList.
		model changed: #messageList.
		model setClassOrganizer ].! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3692-Cleanup-NahuelGarbezza-2019Apr05-01h16m-RNG.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3692] on 5 April 2019 at 5:52:57 pm'!
!CodeFileBrowser methodsFor: 'infoView' stamp: 'KenD 3/30/2019 02:10:13' prior: 16809357!
                 extraInfo
	^ (self
		methodDiffFor: (self selectedClassOrMetaClass sourceCodeAt: self selectedMessageName)
		class: self selectedClass
		selector: self selectedMessageName
		meta: self metaClassIndicated) hasAnyAttribute
			ifTrue: [' - **MODIFIED**']
			ifFalse: [' - identical']! !
!CodeFileBrowser methodsFor: 'infoView' stamp: 'KenD 3/30/2019 02:11:17' prior: 16809368!
          infoViewContents
	| theClass |
	editSelection == #newClass ifTrue: [
		^codeFile
			ifNil: [ 'No file selected' ]
			ifNotNil: [ codeFile summary ]].
	self selectedClass ifNil: [^ ''].
	theClass _ Smalltalk at: self selectedClass name asSymbol ifAbsent: nil.
	editSelection == #editClass ifTrue: [
		^ theClass
			ifNotNil: ['Class exists already in the system']
			ifNil: ['Class not in the system']].
	editSelection == #editMessage ifFalse: [^ ''].
	(theClass notNil and: [self metaClassIndicated])
		ifTrue: [theClass _ theClass class].
	^ (theClass notNil and: [theClass includesSelector: self selectedMessageName])
		ifTrue: ['Method already exists' , self extraInfo]
		ifFalse: ['**NEW** Method not in the system']! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3693-CodeFileBrowserEnhancement-KenDickey-2019Apr05-17h52m-KenD.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3693] on 8 April 2019 at 9:47:04 am'!
!Float methodsFor: 'testing' stamp: 'jmv 4/8/2019 09:43:05'!
                            isDenormalized
	"Denormalized numbers are only represented as BoxedFloat64"

	^ false! !
!BoxedFloat64 methodsFor: 'testing' stamp: 'jmv 4/8/2019 09:43:27'!
   isDenormalized
	"Denormalized numbers are only represented as BoxedFloat64"

	^ self partBits: [ :signBit :exponentBits :mantissaBits |
		exponentBits = 0 and: [mantissaBits ~=0]]! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 19:37:44'!
       safeAbs
	"Answer the distance of the receiver from zero (0 + 0 i).
	Try avoiding overflow and/or underflow"

	| scale a b |
	scale _ real abs max: imaginary abs.
	scale = 0.0 
		ifTrue: [^0.0].
	a _ real / scale.
	b _ imaginary / scale.
	^((a * a) + (b * b)) sqrt * scale! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/8/2019 09:44:54'!
           safeDivideBy: aComplex
	"Answer the result of dividing receiver by aNumber"
	" Both operands are scaled to avoid arithmetic overflow. 
	  This algorithm works for a wide range of values, and it needs only three divisions."
	| r d newReal newImaginary |
	aComplex real abs > aComplex imaginary abs
		ifTrue: [
			r _ aComplex imaginary / aComplex real.
			d _ r * aComplex imaginary + aComplex real.
			newReal _ r * imaginary + real / d.
			newImaginary _ r negated * real + imaginary / d ]
		ifFalse: [
			r _ aComplex real / aComplex imaginary.
			d _ r * aComplex real + aComplex imaginary.
			newReal _ r * real + imaginary / d.
			newImaginary _ r * imaginary - real / d ].
	^ Complex
		real: newReal
		imaginary: newImaginary.! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/8/2019 09:45:16' prior: 50451534!
              / aNumber
	"Answer the result of dividing receiver by aNumber"
	| c d newReal newImaginary s e f |
	aNumber isComplex
		ifTrue: [
			c _ aNumber real.
			d _ aNumber imaginary.
			e _ (real * c) + (imaginary * d).
			e isFinite ifFalse: [ ^ self safeDivideBy: aNumber ].
			f _ (imaginary * c) - (real * d).
			s _ (c * c) + (d * d).
			(e isFloat and: [ s  = 0.0 ]) ifTrue: [ ^ self safeDivideBy: aNumber ].
			newReal _ e / s.
			newImaginary _ f / s ]
		ifFalse: [
			newReal _ real / aNumber.
			newImaginary _ imaginary / aNumber ].
	^ Complex real: newReal imaginary: newImaginary! !
!Complex methodsFor: 'arithmetic' stamp: 'jmv 4/5/2019 19:56:25' prior: 16822382!
abs
	"Answer the distance of the receiver from zero (0 + 0 i)."

	| absSquared |
	absSquared _ (real * real) + (imaginary * imaginary).
	absSquared isFloat ifTrue: [
		absSquared < Float fminNormalized ifTrue: [
			^ self safeAbs ].
		absSquared isFinite ifFalse: [
			^ self safeAbs ]].
	^absSquared sqrt! !

Complex removeSelector: #absSecure!

Complex removeSelector: #absSecure!

Complex removeSelector: #divideFastAndSecureBy:!

Complex removeSelector: #divideFastAndSecureBy:!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3694-FloatAndComplexTweaks-JuanVuletich-2019Apr08-09h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3694] on 8 April 2019 at 2:43:51 pm'!
!Character methodsFor: 'accessing' stamp: 'jmv 4/8/2019 14:19:18'!
          leadingChar
	"See Squeak if curious."
	^ 0! !
!AffineTransformation class methodsFor: 'instance creation' stamp: 'jmv 4/8/2019 14:39:23' prior: 16778911!
      transformFrom: originalBounds to: resultBounds
	"Answer a Transform to translate coordinates inside originalBounds into coordinates inside resultBounds.
	Parameters are instances of Rectangle. Therefore, there's no rotation involved, just scale and offset."

	^((self withTranslation: (resultBounds topLeft + resultBounds bottomRight / 2.0)) composedWith:
		(self withPointScale: (resultBounds extent / originalBounds extent) asFloatPoint)) composedWith:
			(self withTranslation: (originalBounds topLeft + originalBounds bottomRight / 2.0) negated)! !

StrikeFont removeSelector: #maxAscii!

StrikeFont removeSelector: #maxAscii!

StrikeFont removeSelector: #minAscii!

StrikeFont removeSelector: #minAscii!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3695-Tweaks-JuanVuletich-2019Apr08-14h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3695] on 16 April 2019 at 10:34:27 am'!
!IndentingListItemMorph methodsFor: 'initialization' stamp: 'KenD 4/14/2019 16:46:00' prior: 16854720!
                 initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel

	| o |
	container _ hostList.
	complexContents _ anObject.
	self initWithContents: anObject asString font: Preferences standardListFont emphasis: nil.
	indentLevel _ 0.
	isExpanded _ false.
 	nextSibling _ firstChild _ nil.
	priorMorph ifNotNil: [
		priorMorph nextSibling: self.
	].
	o _ anObject withoutListWrapper.
	icon _ o ifNotNil: [ (o respondsTo: #icon) ifTrue: [ o icon ] ].
	indentLevel _ newLevel.
! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3696-IndentingListItemMorph-fix-KenDickey-2019Apr16-10h33m-KenD.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3696] on 17 April 2019 at 2:14:28 pm'!
!PasteUpMorph methodsFor: 'events' stamp: 'jmv 4/17/2019 14:13:14' prior: 16887164!
     click: aMouseButtonEvent localPosition: localEventPosition
	^self whenUIinSafeState: [self mouseButton2Activity]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3697-WorldMenuFix-JuanVuletich-2019Apr17-14h14m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3697] on 17 April 2019 at 3:05:02 pm'!
!Parser methodsFor: 'error correction' stamp: 'jmv 4/17/2019 15:01:56' prior: 16886442!
            correctSelector: proposedKeyword wordIntervals: aSpots exprInterval: expInt ifAbort: abortAction
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| correctSelector userSelection delta spots |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [^proposedKeyword asSymbol].
	
	"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"
	"
	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])
		ifFalse: [ ^ proposedKeyword asSymbol ].
	"

	userSelection _ requestor selectionInterval.
	delta _ userSelection last - aSpots last last.
	spots _ aSpots collect: [ :interval | interval first + delta to: interval last + delta ].
	requestor selectFrom: spots first first to: spots last last.

	correctSelector _ UnknownSelector name: proposedKeyword.
	correctSelector ifNil: [^abortAction value].

	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	self substituteSelector: correctSelector keywords wordIntervals: spots.
	^(proposedKeyword last ~~ $:
	   and: [correctSelector last == $:])
		ifTrue: [abortAction value]
		ifFalse: [correctSelector]! !

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3698-SelectorCorrectionFix-JuanVuletich-2019Apr17-15h04m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3698] on 17 April 2019 at 3:18:04 pm'!

Object subclass: #Compiler
	instanceVariableNames: 'sourceStream requestor class category context parser sourceStreamGetter '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Compiler category: #'Compiler-Kernel'!
Object subclass: #Compiler
	instanceVariableNames: 'sourceStream requestor class category context parser sourceStreamGetter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

Scanner subclass: #Parser
	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties category sourceStreamGetter '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Parser category: #'Compiler-Kernel'!
Scanner subclass: #Parser
	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties category sourceStreamGetter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!Compiler methodsFor: 'private' stamp: 'jmv 4/17/2019 15:15:58' prior: 50444785!
                           translate: aStream noPattern: noPattern doIt: doIt ifFail: failBlock

	^self parser
		ignoreBacktick: false;
		parse: aStream
		class: class
		category: category
		noPattern: noPattern
		doIt: doIt
		context: context
		notifying: requestor
		ifFail: [^failBlock value]! !
!Parser methodsFor: 'public access' stamp: 'jmv 4/17/2019 15:17:07' prior: 50444847!
                           parse: sourceStream class: class category: aCategory noPattern: noPattern doIt: doIt context: aContext notifying: aRequestor ifFail: aBlock

	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	
	| methNode repeatNeeded myStream sourceCode startPosition |
	
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		startPosition _ myStream position.
		sourceCode _ myStream upToEnd.
		myStream position: startPosition.
		self encoder init: class context: aContext notifying: self.
		self init: myStream notifying: aRequestor failBlock: [^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern doIt: doIt context: aContext ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ ReadStream on: requestor text string ].
		repeatNeeded
	] whileTrue: [ encoder _ self encoder class new ].

	methNode sourceText: sourceCode.
	"See #xBacktick"
	sentInLiterals do: [ :sym | encoder noteOptimizedSelector: sym ].

	^ methNode! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/17/2019 15:15:33' prior: 50444960!
                      compileSelectionFor: anObject in: evalContext ifFail: failBlock

	| methodNode method sourceCode compiler |

	sourceCode := self selectionDoItSourceCodeIn: evalContext.
	
	methodNode _ [
		compiler _ Compiler new.
		compiler		
			compileDoIt: sourceCode
			in: anObject class
			context: evalContext
			notifying: self
			ifFail: [ ^ failBlock value ]]
		on: OutOfScopeNotification
		do: [ :ex | ex resume: true ].

	methodNode block returnLast.
	method _ methodNode generate.
	method methodNode: methodNode.

	^{ #method -> method. #compiler -> compiler } asDictionary 
! !

Parser removeSelector: #sourceStreamGetter:!

Parser removeSelector: #sourceStreamGetter:!

Compiler removeSelector: #sourceStreamGetter:!

Compiler removeSelector: #sourceStreamGetter:!

Object subclass: #Compiler
	instanceVariableNames: 'sourceStream requestor class category context parser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Compiler category: #'Compiler-Kernel'!
Object subclass: #Compiler
	instanceVariableNames: 'sourceStream requestor class category context parser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

Scanner subclass: #Parser
	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties category'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Parser category: #'Compiler-Kernel'!
Scanner subclass: #Parser
	instanceVariableNames: 'here hereType hereMark hereEnd prevMark prevEnd encoder requestor parseNode failBlock requestorOffset tempsMark doitFlag properties category'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

----End fileIn of /home/juan/Cuis-Smalltalk/Cuis-Smalltalk-Dev/CoreUpdates/3699-CompilerCleanup-JuanVuletich-2019Apr17-15h15m-jmv.1.cs.st----!

----SNAPSHOT----(23 April 2019 09:06:11) Cuis5.0-3699-v3.image priorSource: 3680362!

----QUIT----(23 April 2019 09:06:33) Cuis5.0-3699-v3.image priorSource: 3855526!