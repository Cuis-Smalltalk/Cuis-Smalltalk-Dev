'From Cuis7.2 [latest update: #6895] on 6 December 2024 at 11:02:12 am'!


----SNAPSHOT----(6 December 2024 11:02:12) Cuis7.2.image priorSource: 0!

Preferences at: #saveReleaseOptionsInWorldMenu put: true!

----QUIT----(6 December 2024 11:04:53) Cuis7.3-6895.image priorSource: 73!

----STARTUP---- (2 January 2025 10:23:05) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-6895.image!


'From Cuis7.3 [latest update: #6895] on 6 December 2024 at 4:45:00 pm'!
!MorphicCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:24:28'!
          drawSquareCloseIcon
	"For Window control buttons"

	self subclassResponsibility.! !
!MorphicCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:36'!
drawSquareExpandIcon
	"For Window control buttons"

	self subclassResponsibility.! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 12/6/2024 16:33:50' overrides: 50331666!
  drawSquareCloseIcon
"make all colors be parameters!!!!!!!!!!"

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.996 g: 0.329 b: 0.329`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.996 g: 0.329 b: 0.329) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/20.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowSquareButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonClosePathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 12/6/2024 16:38:27' overrides: 50331671!
                    drawSquareExpandIcon

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.337 g: 0.604 b: 0.161`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.337 g: 0.604 b: 0.161) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/20.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowSquareButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonExpandPathData: size) ].! !
!AbstractVectorCanvas class methodsFor: 'literal path data' stamp: 'jmv 12/6/2024 16:33:29'!
        windowSquareButtonPathData: aSize
	| scale |
	(IconPathData at: #windowButtonSize ifAbsent: nil) = aSize ifTrue: [
		IconPathData at: #windowSquareButton ifPresent: [ :found | ^found ]].
	IconPathData at: #windowButtonSize put: aSize.
	scale := aSize / 22.0.
	^IconPathData at: #windowSquareButton put: (
		self scalePathData: `#[
			0.0 0 0
			1    0 20
			1    20 20
			1    20 0
			1    0 0
		] asFloat32Array` scale: scale)! !
!BitBltCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:25:24' overrides: 50331666!
                  drawSquareCloseIcon
	| icon |
	icon := self class windowButtonIcon: #squareCloseIcon size: currentMorph morphWidth.
	self pvtDrawButtonFaceForm: icon.! !
!BitBltCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:48' overrides: 50331671!
       drawSquareExpandIcon
	| icon |
	icon := self class windowButtonIcon: #squareExpandIcon size: currentMorph morphWidth.
	self pvtDrawButtonFaceForm: icon.! !
!HybridCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:24:35' overrides: 50331738!
     drawSquareCloseIcon
	vectorCanvas  drawSquareCloseIcon! !
!HybridCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:54' overrides: 50331746!
       drawSquareExpandIcon
	vectorCanvas  drawSquareExpandIcon! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6896-SquareWindowIcons-JuanVuletich-2024Dec06-16h44m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6896] on 6 December 2024 at 7:45:28 pm'!
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/6/2024 19:44:09' prior: 16910500!
   displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos tabBackColor |

	topLeft := textTopLeft.
	line := textLine.
	lineY := line top + textTopLeft y.
	rightMargin := line rightMargin + textTopLeft x.
	lastIndex := line first.
	tabCount := 0.
	leftInRun <= 0 ifTrue:
		[
			self setFont.
			self setStopConditions ].
	leftMargin := (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX := leftMargin.
	destY := lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: 
			[ :ps |
			ps = paragraphStyle ifFalse: 
				[
					foregroundColor := defaultColor.
					self setActualFont: ps font.
					ps color ifNotNil: [ :color | self textColor: color ].
					alignment := ps alignment.
					paragraphStyle := ps.
					spaceWidth := font widthOf: Character space.
					self setStopConditions.
					text ifNotNil: [ destY := lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun := leftInRun].
	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount := 0.
	string := text string asUnicodeString.

	self placeEmbeddedObject.
	[
		startIndex := lastIndex.
		lastPos := destX@destY.
	
		stopCondition := self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions.
		backgroundColor ifNotNil: [
			"If this is not a #tab, update block nesting information. It it is a #tab, use it to draw background."
			stopCondition = #tab
				ifFalse:
				[ | indexForThisColor |
					
					(text hasShoutBackgroundColorAt: startIndex) ifTrue: [
						indexForThisColor := blockNestingStartX findFirst: [ :pair | pair second = backgroundColor ].
						indexForThisColor > 0
							ifTrue: [
								blockNestingStartX := blockNestingStartX first: indexForThisColor.
								(blockNestingStartX at: indexForThisColor) at: 1 put: (((blockNestingStartX at: indexForThisColor) at: 1) min: lastPos x)]
							ifFalse: [blockNestingStartX add: { lastPos x. backgroundColor }]]]
				ifTrue:
				[
					| indexForThisX |
					indexForThisX := blockNestingStartX findLast: [ :pair | pair first <= destX ].
					indexForThisX > 0 ifTrue: [ tabBackColor := (blockNestingStartX at: indexForThisX) second ].
					tabBackColor ifNotNil: [
						canvas
							fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
							color: tabBackColor ]].
			canvas
				fillRectangle: (lastPos corner: (startIndex > line last ifFalse: [ destX ] ifTrue: [ rightMargin ]) @ (line bottom + textTopLeft y))
				color: backgroundColor ].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6897-RectangularBlockHighlightFix-JuanVuletich-2024Dec06-19h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6897] on 8 December 2024 at 10:35:01 am'!
!Parser methodsFor: 'primitives' stamp: 'eem 12/8/2024 10:30:17' prior: 16921396!
                  externalType: descriptorClass
	"Parse an return an external type"
	| xType |
	(here == #'.' and: [hereType == #period and: [tokenType == #period]]) ifTrue:
		[[here == #'.'] whileTrue: [self advance].
		 ^descriptorClass punctuatorNamed: #'...'].
	xType := descriptorClass atomicTypeNamed: here.
	xType ifNil: "Look up from class scope"
		[Symbol
			hasInterned: here
			ifTrue:[:sym| xType := descriptorClass structTypeNamed: sym]].
	xType ifNil:
		["Raise an error if user is there"
		self interactive ifTrue:[^nil].
		"otherwise go over it silently"
		xType := descriptorClass forceTypeNamed: here].
	self advance.
	^(self matchToken: #*)
		ifTrue:[xType asPointerType]
		ifFalse:[xType]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6898-CuisCore-EliotEmilioMiranda-2024Dec08-09h56m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6898] on 9 December 2024 at 11:05:58 am'!
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/9/2024 11:04:30' overrides: 16864656!
                           cos
	"Answer the cosine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 150>
	^ super cos! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/9/2024 11:01:37' overrides: 16864656!
                       cos
	"Answer the cosine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 560>
	^ super cos! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6899-UseNew-cos-primitives-JuanVuletich-2024Dec09-10h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:04:11 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 10/29/2024 16:34:13'!
                              with: otherCollection allSatisfy: twoArgConditionBlock  
	
	self with: otherCollection do: [ :left :right | (twoArgConditionBlock value: left value: right) ifFalse: [ ^false ]].
	^true! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 10/30/2024 08:11:29'!
                with: otherCollection anySatisfy: twoArgConditionBlock 
	
	self with: otherCollection do: [ :left :right | (twoArgConditionBlock value: left value: right) ifTrue: [ ^true ]].
	^false! !
!SequenceableCollection class methodsFor: 'stream creation' stamp: 'HAW 10/28/2024 13:41:05'!
        writeStream
	
	^WriteStream on: self new! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6900-SequenceableCollection-enh-HernanWilkinson-2024Dec09-13h03m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:05:57 pm'!
!WeakMessageSend methodsFor: 'private' stamp: 'HAW 10/30/2024 08:25:06' prior: 17007109!
      isAnyArgumentGarbage
	"Make sure that my arguments haven't gone away"
	
	^arguments notNil and: [ arguments with: shouldBeNil anySatisfy: [ :arg :flag | flag not and: [arg isNil]]].
	
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6901-tweak-HernanWilkinson-2024Dec09-13h04m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:07:59 pm'!
!Interval methodsFor: 'testing' stamp: 'HAW 11/2/2024 10:50:17'!
   intersectsRange: rightRange
 
	^(self includes: rightRange first) 
		or: [ (self includes: rightRange last)
		or: [ rightRange includes: self first ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6902-Interval-enh-HernanWilkinson-2024Dec09-13h05m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:09:02 pm'!
!FileSystemEntry methodsFor: 'comparing' stamp: 'HAW 10/29/2024 16:40:50' prior: 16863764 overrides: 16915345!
                = aFileEntry
	| isCaseSensitive myDrive otherDrive theirs mine |

	self == aFileEntry ifTrue: [ ^ true ].
	self class == aFileEntry class ifFalse: [ ^false ].

	isCaseSensitive := self fileAccessor isCaseSensitive.

	"Check for drive nil or same."
	myDrive := self drive.
	otherDrive := aFileEntry drive.
	isCaseSensitive
		ifTrue: [ self drive = aFileEntry drive ifFalse: [ ^false ]]
		ifFalse: [
			myDrive isNil = otherDrive isNil ifFalse: [ ^false ].		"only one of them is nil"
			myDrive ifNotNil: [											"none is nil"
				(myDrive sameAs: otherDrive) ifFalse: [ ^false ]]].

	"Check for all path components same."
	mine := self pathComponents.
	theirs := aFileEntry pathComponents.

	isCaseSensitive ifTrue: [
		^mine = theirs ].

	mine size = theirs size ifFalse: [
		^false ].

	^mine 
		with: theirs 
		allSatisfy: [ :m :t | m sameAs: t ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6903-tweak-HernanWilkinson-2024Dec09-13h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:17:25 pm'!

ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #EquivalentNodesFinder category: #'Compiler-Support' stamp: 'Install-6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st 1/2/2025 10:23:06'!
ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 10:19:17'!
         methodNodeForLookingEquivalentNodes

	^ self methodNodeWithoutImplicitSelfReturn movingTemporariesDeclarationToBlock! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 10/30/2024 09:30:26'!
                            methodNodeWithoutImplicitSelfReturn
	
	^self methodNode withoutImplicitSelfReturn ! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 10:12:37'!
                               sourceRangesOfNodesEquivalentTo: nodesToLookFor 
	
	^self sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: EquivalentNodesFinder noSelection! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 19:25:36'!
                    sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep
	
	^self methodNodeForLookingEquivalentNodes sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep ! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:02:23'!
      areNodesOf: leftNodes equivalentTo: rightNodes

	^leftNodes size = rightNodes size and: [ 
		leftNodes with: rightNodes allSatisfy: [ :leftNode :rightNode | leftNode equivalentTo: rightNode ]]! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 09:27:03'!
                         isImplicitSelfReturnIn: aMethodNode

	^false! !
!BlockNode methodsFor: 'initialization' stamp: 'HAW 10/30/2024 09:27:45'!
      removeImplicitSelfReturnWhenIn: aMethodNode 
	
	| potentiaImplicitSelfReturn |
	
	potentiaImplicitSelfReturn := statements lastIfEmpty: [ ^self ].
	(potentiaImplicitSelfReturn isImplicitSelfReturnIn: aMethodNode) ifTrue: [ statements removeLast ]
	! !
!BlockNode methodsFor: 'testing' stamp: 'HAW 10/31/2024 16:15:24'!
 declaresAnyVariable
	
	^temporariesDeclaration notNil and: [ temporariesDeclaration declaresAnyVariable]! !
!MethodNode methodsFor: 'converting' stamp: 'HAW 10/30/2024 09:22:34'!
             withoutImplicitSelfReturn
	
	block removeImplicitSelfReturnWhenIn: self.
	^self! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 10/29/2024 22:57:09'!
  calculateCompleteSourceRangesOf: nodes	
	
	| sourcesRanges firstNode lastNode interval |
	
	sourcesRanges := nodes collect: [:node | 	self completeSourceRanges at: node ifAbsent: [#()]].
	
	sourcesRanges size = 1 ifTrue: [ ^sourcesRanges first ].
	
	firstNode := sourcesRanges first.
	lastNode := sourcesRanges last.
	
	interval := SourceCodeInterval from: firstNode first first to: lastNode first last.
	
	^OrderedCollection with: interval

! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 11/2/2024 19:56:44'!
                        sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep
	
	| finder |
	
	finder := EquivalentNodesFinder for: nodesToLookFor in: self keepingSelection: aSelectionToKeep.
	self accept: finder.

	^finder equivalentNodesRanges! !
!MethodNode methodsFor: 'initialization' stamp: 'HAW 11/2/2024 10:13:43'!
                        movingTemporariesDeclarationToBlock
	
	block temporariesDeclaration: temporariesDeclaration.
	self temporariesDeclaration: TemporariesDeclarationNode empty.
	
	^self ! !
!TemporariesDeclarationNode methodsFor: 'initialization' stamp: 'HAW 10/31/2024 18:34:37'!
                           withOutDeclarations: aTemporariesDeclarationToRemove

	tempDeclarationNodes := tempDeclarationNodes reject: [ :aTempDeclarationNode | 
		aTemporariesDeclarationToRemove declaresVariable: aTempDeclarationNode variableNode ]! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/31/2024 20:45:33'!
    addEquivalentNodesOf: blockStatements 

	| start stop |
	
	start := 1.
	
	[ stop := start + nodesToLookForSize - 1.
	stop <= blockStatements size ] whileTrue: [ 
		start := self 
			nextStartAfterAddingEquivalentNodesOf: blockStatements 
			from: start 
			to: stop ].
		
	! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 19:57:35'!
                  addToEquivalentsIfOneStatementEquivalentTo: aNode

	(self hasOneNodeToLookForAndEquivalentTo: aNode)
		ifTrue: [ equivalentNodesRanges add: (self completeSourceRangeOf: aNode) ].! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 20:04:10'!
                 areNodesToLookForEquivalentTo: nodesToCompareWith
 
	| equivalent |
	
	equivalent := nodesToLookFor 
		with: nodesToCompareWith 
		allSatisfy: [:leftNode :rightNode | leftNode equivalentTo: rightNode ].
		
	^equivalent and: [ self shouldKeepSelection not or: [ self selectionToKeepIsEqualOrHasNoIntersectionWith: nodesToCompareWith ]]	! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/4/2024 18:42:07'!
                    completeSourceRangeOf: aNode

	| sourceRangeIndex completeSourceRanges completeRange trimmedRange |
	
	sourceRangeIndex := nodeVisitedCounter occurrencesOf: aNode.
	sourceRangeIndex = 0 ifTrue: [ sourceRangeIndex := 1 ].
	
	"It should always find the completeSourceRanges of aNode and a range at the sourceRangeIndex - Hernan"
	completeSourceRanges := methodNode completeSourceRanges at: aNode.
	completeRange := completeSourceRanges at: sourceRangeIndex.
	
	"See ExtractMethodFinderTest>>test27FindsInsideParentesis - Hernan"
	trimmedRange := nodesToLookForSize = 1 
		ifTrue: [ completeRange trimToMatchExpressionOn: methodNode sourceText ]
		ifFalse: [ completeRange ].
	
	^trimmedRange! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/31/2024 21:14:49'!
                 completeSourceRangesOfAll: aCollectionOfNodes

	| firstRange lastRange |
	
	firstRange := self completeSourceRangeOf: aCollectionOfNodes first.
	lastRange := self completeSourceRangeOf: aCollectionOfNodes last.
	
	^SourceCodeInterval from: firstRange first to: lastRange last! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/29/2024 16:26:31'!
               hasOneNodeToLookForAndEquivalentTo: aNode

	^ nodesToLookForSize = 1 and: [ nodesToLookFor first equivalentTo: aNode ]! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 19:57:54'!
             nextStartAfterAddingEquivalentNodesOf: blockStatements from: start to: stop 
	
	| nodesToCompareWith nextStart |
	
	nodesToCompareWith := blockStatements copyFrom: start to: stop.
	
	nextStart := (self areNodesToLookForEquivalentTo: nodesToCompareWith) 
		ifTrue: [ 
			equivalentNodesRanges add: (self completeSourceRangesOfAll: nodesToCompareWith).
			stop + 1 ]
		ifFalse: [ 
			start + 1].
		
	^nextStart! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 20:04:10'!
           selectionToKeepIsEqualOrHasNoIntersectionWith: nodesToCompareWith 

	 | equivalentNodesSourceRanges | 

	equivalentNodesSourceRanges := self completeSourceRangesOfAll: nodesToCompareWith.
		
	^(selectionToKeep = equivalentNodesSourceRanges or: [ (selectionToKeep intersectsRange: equivalentNodesSourceRanges) not ])! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 10:19:08'!
        shouldKeepSelection

	^selectionToKeep ~= self class noSelection ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 11/2/2024 20:12:04' overrides: 16920720!
                        visitBlockNode: blockNode

	| blockStatements |

	super visitBlockNode: blockNode.
	
	nodesToLookForSize > 1 ifTrue: [ 
		blockStatements := blockNode statements. 
		"I need to add temp declaration to statements becuase user could have selected the temp declaration
		See ExtractMethodFinderTest>>test22FindsTemporaryWhenSelectingDefinitionInInnerClosure - Hernan"
		blockNode declaresAnyVariable ifTrue: [ blockStatements addFirst: blockNode temporariesDeclaration ].
		self addEquivalentNodesOf: blockStatements ]
		! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:10' overrides: 16920728!
                  visitBraceNode: aBraceNode 
	
	nodeVisitedCounter add: aBraceNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aBraceNode.
	
	^super visitBraceNode: aBraceNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:22' overrides: 16920734!
                visitCascadeNode: aCascadeNode 

	self addToEquivalentsIfOneStatementEquivalentTo: aCascadeNode.

	 ^super visitCascadeNode: aCascadeNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:34' overrides: 16920741!
              visitInstanceVariableNode: anInstanceVariableNode 

	nodeVisitedCounter add: anInstanceVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: anInstanceVariableNode.

	^super visitInstanceVariableNode: anInstanceVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:43' overrides: 16920745!
            visitLiteralNode: aLiteralNode

	nodeVisitedCounter add: aLiteralNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralNode.

	^super visitLiteralNode: aLiteralNode! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:50' overrides: 16920749!
        visitLiteralVariableNode: aLiteralVariableNode 
	
	nodeVisitedCounter add: aLiteralVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralVariableNode.
	
	^super visitLiteralVariableNode: aLiteralVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/28/2024 15:46:23' overrides: 16920753!
                    visitMessageNode: aMessageNode

	self addToEquivalentsIfOneStatementEquivalentTo: aMessageNode.

	 ^super visitMessageNode: aMessageNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:59' overrides: 16920795!
               visitTempVariableNode: aTempVariableNode 
	
	nodeVisitedCounter add: aTempVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aTempVariableNode.
	
	^super visitTempVariableNode: aTempVariableNode ! !
!EquivalentNodesFinder methodsFor: 'initialization' stamp: 'HAW 11/2/2024 19:55:28'!
                     initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	nodesToLookFor := aNodesToLookFor.
	methodNode := aMethodNode.
	selectionToKeep := aSelectionToKeep.
	
	nodesToLookForSize := nodesToLookFor size.
	nodeVisitedCounter := IdentityBag new.
	equivalentNodesRanges := OrderedCollection new.
	! !
!EquivalentNodesFinder methodsFor: 'ranges' stamp: 'HAW 11/2/2024 19:58:52'!
              equivalentNodesRanges
	
	^equivalentNodesRanges! !
!EquivalentNodesFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 19:56:18'!
               for: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	^ self new initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep! !
!EquivalentNodesFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 10:17:37'!
                        noSelection
	
	^`0 to: 0`! !
!Behavior methodsFor: 'methods' stamp: 'HAW 10/30/2024 09:19:58'!
 methodNodeWithoutImplicitSelfReturnFor: aSourceCode

	^(self methodNodeFor: aSourceCode) withoutImplicitSelfReturn! !
!BraceNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:02:55' prior: 16797237!
                       hasEquivalentElementsTo: aBraceNode

	^self areNodesOf: elements equivalentTo: aBraceNode elements ! !
!CascadeNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:03:14' prior: 16802900!
    hasEquivalentMessagesWith: aCascadeNode

	^self areNodesOf: messages equivalentTo: aCascadeNode messages! !
!CodeNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:03:35' prior: 16823662!
  hasEquivalentArgumentsWith: aCodeNode

	^self areNodesOf: self arguments equivalentTo: aCodeNode arguments! !
!BlockNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:04:17' prior: 16795473!
                               hasEquivalentStatementsWith: aBlockNode

	^self areNodesOf: statements equivalentTo: aBlockNode statements! !
!MessageNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:05:44' prior: 16897480!
                             hasEquivalentArgumentsWith: aMessageNode

	^ self isCascade
		ifTrue: [ self areNodesOf: originalArguments equivalentTo: aMessageNode originalArguments ]
		ifFalse: [ self areNodesOf: arguments equivalentTo: aMessageNode arguments ]! !
!TemporariesDeclarationNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:06:50' prior: 16976434!
                declaresSameVariablesThan: aTemporariesDeclarationNode

	^self areNodesOf: tempDeclarationNodes equivalentTo: aTemporariesDeclarationNode temporaryDeclarationNodes ! !
!TemporariesDeclarationNode methodsFor: 'testing' stamp: 'HAW 10/31/2024 18:35:34' prior: 16976449!
                    declaresVariable: aVariableNode

	^ tempDeclarationNodes anySatisfy: [ :tempDeclaration | tempDeclaration declaresVariable: aVariableNode ]! !
!ParseNodeVisitor methodsFor: 'visiting' stamp: 'HAW 10/31/2024 19:39:57' prior: 16920808!
                      visitTemporaryDeclarationNode: aTemporaryDeclarationNode

	^aTemporaryDeclarationNode variableNode accept: self! !

MessageNode removeSelector: #compare:with:!

!methodRemoval: MessageNode #compare:with: stamp: 'Install-6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st 1/2/2025 10:23:06'!
compare: myArguments with: othersArguments

	myArguments size ~= othersArguments size ifTrue: [ ^ false ].

	myArguments with: othersArguments do: [ :myArgument :otherArgument |
		(myArgument equivalentTo: otherArgument) ifFalse: [ ^ false ] ].
	^ true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6904] on 9 December 2024 at 2:04:51 pm'!

Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract sizeToExtract findingStrategy nodesToExtract '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract sizeToExtract findingStrategy nodesToExtract'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #NodesInRangeFinder
	instanceVariableNames: 'range sourceMethod sourceMethodNode statements sourceRangeIndexByNode firstNodeFound lastNodeRange sourceCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #NodesInRangeFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #NodesInRangeFinder
	instanceVariableNames: 'range sourceMethod sourceMethodNode statements sourceRangeIndexByNode firstNodeFound lastNodeRange sourceCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom callingExpression sendCollaboration '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacement category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom callingExpression sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:12:58'!
                 defineFindingStrategy
	
	| useStringEquality |
	
	"Sadly, finding the right ranges when extracting literal nodes is almost imposible becuase literal nodes can have many
	ranges. An alternative algorithm could be to create an 'expanded AST' without reused nodes and each node with its own
	source range. Nodes of that AST could be a polimorphic proxy of the real node, adding only the source range, something
	to try ...
	For the moment, if the selection to extract has only literal nodes, uses string comparison - Hernan"
	useStringEquality := nodesToExtract allSatisfy: [ :aNode | aNode isLiteralNode ].
	
	^useStringEquality 
		ifTrue: [ [ :aMethod | self findReplacementsUsingStringEqualityIn: aMethod ]]
		ifFalse: [ [ :aMethod | self findReplacementsUsingNodeEquivalenceIn: aMethod ]]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:09:42'!
                           findReplacementInHierarchy

	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/2/2024 20:15:03'!
                         findReplacementsUsingNodeEquivalenceIn: aMethod

	| rangesToExtract |
		
	rangesToExtract := sourceMethod compiledMethod = aMethod
		ifTrue: [  aMethod sourceRangesOfNodesEquivalentTo: nodesToExtract keepingSelection: intervalToExtract ]	
		ifFalse: [ aMethod sourceRangesOfNodesEquivalentTo: nodesToExtract ].
		
	rangesToExtract do: [ :sourceRangeToExtract | self addReplacementAt: sourceRangeToExtract in: aMethod ].! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/1/2024 15:58:34'!
             findReplacementsUsingStringEqualityIn: aMethod

	| sourceCode foundIntervalToExtract sourceCodeToExtractStart theSizeToExtract |
	
	sourceCode := aMethod sourceCode.
	theSizeToExtract := intervalToExtract size - 1.
	sourceCodeToExtractStart := 1.
	
	[ sourceCodeToExtractStart := sourceCode indexOfSubCollection: sourceCodeToExtract startingAt: sourceCodeToExtractStart.
	sourceCodeToExtractStart ~= 0 ] whileTrue: [ 
		foundIntervalToExtract := sourceCodeToExtractStart to: sourceCodeToExtractStart + theSizeToExtract.
		self addReplacementAt: foundIntervalToExtract in: aMethod.
		sourceCodeToExtractStart := foundIntervalToExtract last + 1 ] 
		
	 ! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/3/2024 17:36:58'!
     nodesToExtract

	^(NodesInRangeFinder in: sourceMethod for: intervalToExtract) value! !
!NodesInRangeFinder methodsFor: 'initialization' stamp: 'HAW 11/2/2024 20:33:48'!
                      initializeIn: aSourceMethod for: anIntervalToExtract 

	range := anIntervalToExtract.
	sourceMethod := aSourceMethod.
	! !
!NodesInRangeFinder methodsFor: 'evaluating' stamp: 'HAW 11/3/2024 23:48:20' overrides: 16915777!
   value
	
	| nodeAtLastPositionFound |

	"Because some nodes have many ranges, like the literal nodes, we count the time we pass by a node that is equivalent
	to the index in the source ranges collection. sourceRangeIndexByNode is used to count per node - Hernan"
	sourceMethodNode := sourceMethod methodNode.
	sourceCode := sourceMethod sourceCode.
	statements := OrderedCollection new.
	sourceRangeIndexByNode := IdentityBag new.
	firstNodeFound := false.

	sourceMethodNode nodesDo: [ :aNode | | nodeRange |
		sourceRangeIndexByNode add: aNode.
		nodeRange := self completeSourceRangeOf: aNode.
		nodeAtLastPositionFound := self ifInsideRangeAddToStatements: aNode locatedAt: nodeRange.
		nodeAtLastPositionFound ifTrue: [ ^statements ]].
			
	self error: 'nodes not found'
	! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:31:50'!
                            addToStatementsIf: aNode isAtStartingPositionWhenLocatedAt: nodeRange

	(self isFirstInRange: aNode locatedAt: nodeRange)
		ifTrue: [
			firstNodeFound := true.
			statements add: aNode.
			range last <= nodeRange last ifTrue: [ ^true ].
			lastNodeRange := nodeRange ].

	^false! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:35:32'!
             addToStatementsIf: aNode isInsideExtractionWhenLoacatedAt: nodeRange

	(self notSubNodeOfLastNode: nodeRange) ifTrue: [
		statements add: aNode.
		(self isAtEndPosition: nodeRange) ifTrue: [ ^true ].
		lastNodeRange := nodeRange.].
	
	^false! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 23:32:33'!
                   completeSourceRangeOf: aNode

	| nodeRange nodeRanges |
	
	"Some nodes do not have ranges at all like BlockNode - Hernan"
	nodeRanges := sourceMethodNode completeSourceRanges at: aNode ifAbsent: [ #() ].
	nodeRange := nodeRanges at: (sourceRangeIndexByNode occurrencesOf: aNode) ifAbsent: [ `0 to: 0` ].
	nodeRange := nodeRange asSourceCodeInterval trimToMatchExpressionOn: sourceCode.
	
	^nodeRange
		! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:31:50'!
                  ifInsideRangeAddToStatements: aNode locatedAt: nodeRange

	^ firstNodeFound
		ifTrue: [ self addToStatementsIf: aNode isInsideExtractionWhenLoacatedAt: nodeRange]
		ifFalse: [ self addToStatementsIf: aNode isAtStartingPositionWhenLocatedAt: nodeRange]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:35:32'!
         isAtEndPosition: nodeRange

	^ range last = nodeRange last! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 23:55:29'!
          isAtStartPosition: nodeRange

	^ range first <= nodeRange first! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:40:38'!
     isCascadeMessage: aNode insideRange: nodeRange

	^ aNode isCascadeNode and: [ range last + 2 = nodeRange last ]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:34:59'!
                     isFirstInRange: aNode locatedAt: nodeRange

	^(self isAtStartPosition: nodeRange) and: [ self isInsideRange: aNode locatedAt: nodeRange ]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:34:49'!
                           isInsideRange: aNode locatedAt: nodeRange

	^ range last >= nodeRange last or: [self isCascadeMessage: aNode insideRange: nodeRange]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:34:53'!
notSubNodeOfLastNode: nodeRange
	
	^lastNodeRange last < nodeRange first! !
!NodesInRangeFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 20:34:06'!
                         in: aSourceMethod for: anIntervalToExtract 

	^self new initializeIn: aSourceMethod for: anIntervalToExtract ! !
!ExtractMethodReplacement methodsFor: 'initialization' stamp: 'HAW 11/4/2024 00:17:27'!
                       initializeSendCollaboration

	sendCollaboration := 'self ', self newMessageString.
	self shouldBeEnclosedWithParens ifTrue: [ sendCollaboration := '(' , sendCollaboration , ')' ]
		! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 11/1/2024 16:21:07' prior: 16958184!
        trimNoParentesisStartingWith: initialChar endingWith: endingChar on: aSourceCode

	| startOffset endOffset |

	startOffset := self trimmedOffsetFor: initialChar.
	endOffset := self trimmedOffsetFor: endingChar.
	^(startOffset = 1 or: [ endOffset = 1])
		ifTrue: [ (self trimLeft: startOffset right: endOffset) trimToMatchExpressionOn: aSourceCode ]
		ifFalse: [ self ]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:18:06' prior: 16859277!
                createReplacementAt: foundIntervalToExtract in: aMethod
	
	^ExtractMethodReplacement 
		fromInterval: foundIntervalToExtract asSourceCodeInterval 
		of: aMethod asMethodReference 
		to: newMessage
		! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 18:47:14' prior: 16859287!
                         findReplacementsAt: aClass

	"I live this implementationt instead of 
	
	aClass methodsDo: findingStrategy
	
	for debugging porpouses. We can do Through with this one - Hernan"
	aClass methodsDo: [ :aMethod | findingStrategy value: aMethod ]
	! !
!ExtractMethodReplacementsFinder methodsFor: 'evaluating' stamp: 'HAW 11/4/2024 00:08:21' prior: 16859363 overrides: 16915777!
          value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	nodesToExtract := self nodesToExtract.
	replacements := OrderedCollection new.
	findingStrategy := self defineFindingStrategy.
	
	self findReplacementInHierarchy.! !
!ExtractMethodReplacement methodsFor: 'initialization' stamp: 'HAW 11/4/2024 00:16:58' prior: 16859106!
                            initializeFrom: anIntervalToExtract of: aMethodToExtractCodeFrom to: aNewMessage

	intervalToExtract := anIntervalToExtract.
	methodToExtractFrom := aMethodToExtractCodeFrom.
	newMessage := 	aNewMessage.
	self initializeSendCollaboration ! !
!ExtractMethodReplacement methodsFor: 'private - source code' stamp: 'HAW 11/4/2024 00:17:27' prior: 16859167!
                               updatedSourceCodeOfExistingMethod

	^ methodToExtractFrom sourceCode
		copyReplaceFrom: intervalToExtract first  
		to: intervalToExtract last 
		with: sendCollaboration! !
!ExtractMethodReplacement methodsFor: 'adjustment' stamp: 'HAW 11/4/2024 00:17:27' prior: 16859206!
               adjustmentForNextReplacement
	
	^sendCollaboration size - intervalToExtract size! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'private' stamp: 'HAW 11/2/2024 02:27:22' prior: 16958621!
                        initializeParseNodesMatchingSelectionInterval

	initialNodeAncestors := methodNode parseNodesPathAt: intervalToExtract first ifAbsent: [ self signalSourceCodeContainsAnInvalidExpressionError ].
	finalNodeAncestors := methodNode parseNodesPathAt: intervalToExtract last ifAbsent: [ self signalSourceCodeContainsAnInvalidExpressionError ].
	initialNode := initialNodeAncestors detect: [ :aNodeRange | aNodeRange key isCascadeNode ] ifNone: [ initialNodeAncestors first ].
	finalNode := finalNodeAncestors first! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'private' stamp: 'HAW 11/4/2024 00:30:46' prior: 16958638!
            intervalCoversCompleteAstNodes 

	^ (self trimmed: (SourceCodeInterval from: initialNode value first to: finalNode value last)) = intervalToExtract
		or: [ (initialNode value first to: (self trimmed: finalNode value) last) = intervalToExtract ]! !

ExtractMethodReplacement removeSelector: #initializeCallingExpression!

!methodRemoval: ExtractMethodReplacement #initializeCallingExpression stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
initializeCallingExpression

	callingExpression := 'self ', self newMessageString.
	self shouldBeEnclosedWithParens ifTrue: [ callingExpression := '(' , callingExpression , ')' ]
		!

ExtractMethodReplacementsFinder removeSelector: #findReplacementsIn:!

!methodRemoval: ExtractMethodReplacementsFinder #findReplacementsIn: stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
findReplacementsIn: aMethod

	| sourceCode foundIntervalToExtract sourceCodeToExtractStart |
	
	sourceCode := aMethod sourceCode.
	sourceCodeToExtractStart := 1.
	
	[ sourceCodeToExtractStart := sourceCode indexOfSubCollection: sourceCodeToExtract startingAt: sourceCodeToExtractStart.
	sourceCodeToExtractStart ~= 0 ] whileTrue: [ 
		foundIntervalToExtract := sourceCodeToExtractStart to: sourceCodeToExtractStart + sizeToExtract.
		self addReplacementAt: foundIntervalToExtract in: aMethod.
		sourceCodeToExtractStart := foundIntervalToExtract last + 1 ] 
		
	 !

Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract nodesToExtract findingStrategy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract nodesToExtract findingStrategy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacement category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6905] on 9 December 2024 at 3:08:13 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6906-Interval-recategorize-HernanWilkinson-2024Dec09-15h03m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6906] on 9 December 2024 at 5:42:11 pm'!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/9/2024 17:41:40' prior: 16965270!
       getCurrentWorkingDirectory
	"Answer the path from which Cuis was started.
	Smalltalk getCurrentWorkingDirectory
	(Note: Windows VM used to give a bogus answer. This was fixed in 2024.)
	"

	(self primGetCurrentWorkingDirectoryUnix ifNil: [ self primGetCurrentWorkingDirectoryWindows ]) ifNotNil:
		[ :utf8BytesInAStringInstance | | answer |
			"It seems on Mac, when dropping image on VM, we get '/', that is not really meaningful"
			(utf8BytesInAStringInstance = '/' and: [ self platformName = 'Mac OS' ]) ifFalse: [
				
				"Primitive answers an instance of String containing the UTF-8 bytes. If not pure ASCII,
				contents are invalid!! Convert it ASAP into a reasonable ByteArray + UnicodeString."
				answer := utf8BytesInAStringInstance.
				(String isAscii: answer) ifFalse: [
					ByteArray adoptInstance: answer.
					answer := UnicodeString fromUtf8Bytes: answer ].
				
				^ answer ]].

	"If we don't know better, answer nil. If appropriate, senders do:
		Smalltalk getCurrentWorkingDirectory ifNil: [ Smalltalk imagePath ]
	to have, at least, some valid directory
	"
	^ nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6907-getCurrentWorkingDirectory-primitiveFixedOnWindows-JuanVuletich-2024Dec09-17h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6907] on 10 December 2024 at 1:36:04 pm'!

Dictionary removeSelector: #valueAtNewKey:put:atIndex:declareFrom:!

!methodRemoval: Dictionary #valueAtNewKey:put:atIndex:declareFrom: stamp: 'Install-6908-Cleanup-JuanVuletich-2024Dec10-13h35m-jmv.001.cs.st 1/2/2025 10:23:06'!
valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary 
	"Support for coordinating class variable and global declarations
	with variables that have been put in Undeclared so as to
	redirect all references to the undeclared variable."

	(aDictionary includesKey: aKey)
		ifTrue: 
			[self atNewIndex: index 
				put: ((aDictionary associationAt: aKey) value: anObject).
			aDictionary removeKey: aKey]
		ifFalse: 
			[self atNewIndex: index put: (Association key: aKey value: anObject)]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6908-Cleanup-JuanVuletich-2024Dec10-13h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6908] on 11 December 2024 at 10:54:30 am'!
!PluggableScrollPane methodsFor: 'access options' stamp: 'jmv 12/10/2024 17:36:50'!
                           alwaysHideHorizontalScrollbar

	hideScrollBars := #alwaysHideHorizontal.
	self hHideScrollBar.! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/11/2024 10:43:12' prior: 16926795!
                               hIsScrollbarNeeded
	"Return whether the horz scrollbar is needed"

	self mightNeedHorizontalScrollBar ifFalse: [ ^false ].
	
	"Don't show it if we were told not to."
	hideScrollBars = #hide ifTrue: [ ^false ].
	
	hideScrollBars = #alwaysHideHorizontal  ifTrue: [ ^false ].

	^self hLeftoverScrollRange > 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6909-PluggableScrollPane-hideHorizontalScrollbar-JuanVuletich-2024Dec11-10h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6908] on 11 December 2024 at 11:12:08 am'!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!
!FileListWindow methodsFor: 'updating' stamp: 'jmv 12/11/2024 11:11:04' overrides: 16972685!
               layoutSubmorphs
	super layoutSubmorphs.
	"We are acting as the model of fileListPane,
	and need it to update, as its items are custom built to available width."
	self changed: #fileList! !
!FileListWindow methodsFor: 'updating' stamp: 'jmv 12/11/2024 11:00:46' overrides: 16972660!
      update: aSymbol
	super update: aSymbol.
	aSymbol = #fileList ifTrue: [
		"We are acting as the model of fileListPane"
		self changed: #fileList ].! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:50:33'!
                     dateTimeStringFor: aFileEntry

	^(aFileEntry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			aFileEntry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:35:13'!
fileList
	"Answer the list of display strings for the files in the current volume."

	| list font maxDateWidth maxSizeWidth totalWidth |
	list := model fileList.
	totalWidth := fileListPane ifNotNil: [ :l | l viewableWidth ] ifNil: [200]. "Only during pane creation."
	font := Preferences at: #standardListFont.
	maxDateWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: (self dateTimeStringFor: fileEntry))].
	maxSizeWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: fileEntry fileSize printStringWithCommas)].
	^list collect:
		[ :fileEntry |
			self fileNameFormattedFor: fileEntry
				nameWidth: totalWidth - maxDateWidth - maxSizeWidth
				sizeWidth: maxSizeWidth ].! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:13:30'!
                   fileListIndex
	^model fileListIndex! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:13:38'!
    fileListIndex: i
	^model fileListIndex: i! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:06:59'!
                              fileNameFormattedFor: fileEntry nameWidth: nameWidth sizeWidth: sizeWidth

	| font dateTimeString nameString sizeString w columnSeparator columnSeparatorsWidth space spaceWidth c hairSpace hairSpaceWidth |
	font := Preferences at: #standardListFont.
	columnSeparator := '   '.
	columnSeparatorsWidth := (font widthOfString: columnSeparator) * 2.
	space := Character space asString.
	spaceWidth := font widthOfString: space.
	hairSpace := (Character codePoint: 16r200A) asString.
	hairSpaceWidth := font widthOfString: hairSpace.

	"Adjust file name string"
	nameString := fileEntry name.
	nameString := nameString.
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	"Truncate if too long"
	w > nameWidth ifTrue: [
		w := (font widthOfString: nameString, '...') + columnSeparatorsWidth.
		[ w > nameWidth and: [nameString notEmpty]] whileTrue: [
			nameString := nameString first: nameString size -1.
			w := (font widthOfString: nameString, '...') + columnSeparatorsWidth ].
		nameString := nameString, '...' ].
	"Pad with spaces and hairSpaces if too short"
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	w < (nameWidth-spaceWidth) ifTrue: [
		c := nameWidth-w // spaceWidth.
		c timesRepeat: [ nameString := nameString, space ]].
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	[ w < (nameWidth-hairSpaceWidth) ] whileTrue: [
		nameString := nameString, hairSpace.
		w := (font widthOfString: nameString) + columnSeparatorsWidth ].

	dateTimeString := self dateTimeStringFor: fileEntry.

	sizeString := fileEntry fileSize printStringWithCommas.
	"Pad with spaces and hairSpaces if too short"
	w := font widthOfString: sizeString.
	w < (sizeWidth-spaceWidth) ifTrue: [
		c := sizeWidth-w // spaceWidth.
		c timesRepeat: [ sizeString := space, sizeString ]].
	w := font widthOfString: sizeString.
	[ w < (sizeWidth-hairSpaceWidth) ] whileTrue: [
		sizeString := hairSpace, sizeString.
		w := font widthOfString: sizeString ].

	^nameString, columnSeparator, dateTimeString, columnSeparator, sizeString! !
!FileList methodsFor: 'file list' stamp: 'jmv 12/11/2024 10:32:14' prior: 16862394!
      fileList
	"Answer the list of files in the current volume."
	^list! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 12/11/2024 10:55:35' prior: 16863509!
                             morphicFileListPane

	^ fileListPane := (PluggableListMorph
		withModel: self
		listGetter: #fileList 
		indexGetter: #fileListIndex
		indexSetter: #fileListIndex: )
			menuNshortcutsKey: #fileListMenuSpec;
			alwaysHideHorizontalScrollbar.! !

FileList removeSelector: #fileNameFormattedFrom:namePad:sizePad:sizeWithCommasPad:!

!methodRemoval: FileList #fileNameFormattedFrom:namePad:sizePad:sizeWithCommasPad: stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font := Preferences at: #standardListFont.
	spaceWidth := font widthOf: $ .
	nameStr := entry isDirectoryEntry
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd := namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr := nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr := (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits := entry fileSize printString size.
	sizeStr := entry fileSize printStringWithCommas.
	sizeDigitsAndCommas := sizeStr size.
	spacesToAdd := sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd := spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr := (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces := String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 2:05:26 pm'!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!
!FileList methodsFor: 'as yet unclassified' stamp: 'jmv 10/10/2024 11:34:24'!
                        fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font := Preferences at: #standardListFont.
	spaceWidth := font widthOf: $ .
	nameStr := entry isDirectoryEntry
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd := namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr := nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr := (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits := entry fileSize printString size.
	sizeStr := entry fileSize printStringWithCommas.
	sizeDigitsAndCommas := sizeStr size.
	spacesToAdd := sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd := spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr := (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces := String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .! !
!FileList methodsFor: 'file list' stamp: 'jmv 11/21/2024 12:33:58' prior: 50333254!
              fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 6/4/2024 13:33:43' prior: 50333260!
    morphicFileListPane

	^(PluggableListMorph
		withModel: model 
		listGetter: #fileList 
		indexGetter: #fileListIndex
		indexSetter: #fileListIndex: )
			menuNshortcutsKey: #fileListMenuSpec.! !

FileListWindow removeSelector: #fileList!

!methodRemoval: FileListWindow #fileList stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileList
	"Answer the list of display strings for the files in the current volume."

	| list font maxDateWidth maxSizeWidth totalWidth |
	list := model fileList.
	totalWidth := fileListPane ifNotNil: [ :l | l viewableWidth ] ifNil: [200]. "Only during pane creation."
	font := Preferences at: #standardListFont.
	maxDateWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: (self dateTimeStringFor: fileEntry))].
	maxSizeWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: fileEntry fileSize printStringWithCommas)].
	^list collect:
		[ :fileEntry |
			self fileNameFormattedFor: fileEntry
				nameWidth: totalWidth - maxDateWidth - maxSizeWidth
				sizeWidth: maxSizeWidth ].!

FileListWindow removeSelector: #fileListIndex!

!methodRemoval: FileListWindow #fileListIndex stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileListIndex
	^model fileListIndex!

FileListWindow removeSelector: #fileListIndex:!

!methodRemoval: FileListWindow #fileListIndex: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileListIndex: i
	^model fileListIndex: i!

FileListWindow removeSelector: #update:!

!methodRemoval: FileListWindow #update: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
update: aSymbol
	super update: aSymbol.
	aSymbol = #fileList ifTrue: [
		"We are acting as the model of fileListPane"
		self changed: #fileList ].!

FileListWindow removeSelector: #layoutSubmorphs!

!methodRemoval: FileListWindow #layoutSubmorphs stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
layoutSubmorphs
	super layoutSubmorphs.
	"We are acting as the model of fileListPane,
	and need it to update, as its items are custom built to available width."
	self changed: #fileList!

FileListWindow removeSelector: #dateTimeStringFor:!

!methodRemoval: FileListWindow #dateTimeStringFor: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
dateTimeStringFor: aFileEntry

	^(aFileEntry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			aFileEntry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).!

FileListWindow removeSelector: #fileNameFormattedFor:nameWidth:sizeWidth:!

!methodRemoval: FileListWindow #fileNameFormattedFor:nameWidth:sizeWidth: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileNameFormattedFor: fileEntry nameWidth: nameWidth sizeWidth: sizeWidth

	| font dateTimeString nameString sizeString w columnSeparator columnSeparatorsWidth space spaceWidth c hairSpace hairSpaceWidth |
	font := Preferences at: #standardListFont.
	columnSeparator := '   '.
	columnSeparatorsWidth := (font widthOfString: columnSeparator) * 2.
	space := Character space asString.
	spaceWidth := font widthOfString: space.
	hairSpace := (Character codePoint: 16r200A) asString.
	hairSpaceWidth := font widthOfString: hairSpace.

	"Adjust file name string"
	nameString := fileEntry name.
	nameString := nameString.
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	"Truncate if too long"
	w > nameWidth ifTrue: [
		w := (font widthOfString: nameString, '...') + columnSeparatorsWidth.
		[ w > nameWidth and: [nameString notEmpty]] whileTrue: [
			nameString := nameString first: nameString size -1.
			w := (font widthOfString: nameString, '...') + columnSeparatorsWidth ].
		nameString := nameString, '...' ].
	"Pad with spaces and hairSpaces if too short"
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	w < (nameWidth-spaceWidth) ifTrue: [
		c := nameWidth-w // spaceWidth.
		c timesRepeat: [ nameString := nameString, space ]].
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	[ w < (nameWidth-hairSpaceWidth) ] whileTrue: [
		nameString := nameString, hairSpace.
		w := (font widthOfString: nameString) + columnSeparatorsWidth ].

	dateTimeString := self dateTimeStringFor: fileEntry.

	sizeString := fileEntry fileSize printStringWithCommas.
	"Pad with spaces and hairSpaces if too short"
	w := font widthOfString: sizeString.
	w < (sizeWidth-spaceWidth) ifTrue: [
		c := sizeWidth-w // spaceWidth.
		c timesRepeat: [ sizeString := space, sizeString ]].
	w := font widthOfString: sizeString.
	[ w < (sizeWidth-hairSpaceWidth) ] whileTrue: [
		sizeString := hairSpace, sizeString.
		w := font widthOfString: sizeString ].

	^nameString, columnSeparator, dateTimeString, columnSeparator, sizeString!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6911] on 12 December 2024 at 3:49:02 pm'!
!Rectangle methodsFor: 'transforming' stamp: 'jmv 12/12/2024 15:46:55'!
                   newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect := newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 3/25/2024 11:43:34' prior: 16937717!
                           newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect := newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 12/12/2024 15:47:53' prior: 17008207 overrides: 16890633!
    adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(Preferences at: #cheapWindowReframe) or: [millisecondSinceLast > 100]]) ifTrue: [
			owner displayBounds newRect2From: [ :f |
				self stopStepping.
				hand := nil.
				Cursor defaultCursor activateCursor.
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner extentInWorld ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6912-WindowResizeTweak-JuanVuletich-2024Dec12-15h38m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6912] on 15 December 2024 at 7:04:31 pm'!
!HierarchyBrowserWindow class methodsFor: 'GUI building' stamp: 'KLG 12/12/2024 16:04:08' prior: 16875757!
                         onClass: aClass selector: aSymbol
	"Open a new full browser set to class.
	HierarchyBrowserWindow onClass: Morph selector: #submorphs
	HierarchyBrowserWindow onClass: Morph selector: nil
	"

	| newBrowser newBrowserWindow |
	newBrowser := HierarchyBrowser for: aClass selector: aSymbol.
	newBrowserWindow := self openNoSysCat: newBrowser label: newBrowser labelString.
	newBrowser assureSelectionsShow.
	^ newBrowserWindow! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6913-AnswerNewWindowInOnClassSelector-GeraldKlix-2024Dec15-19h03m-KLG.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 17 December 2024 at 9:26:21 am'!
!Object methodsFor: 'finalization' stamp: 'jmv 12/17/2024 09:12:41'!
                          toFinalizeSend: aSelector to: aFinalizer
	"When I am finalized (e.g., garbage collected) send aSelector to the appropriate finalizer (the guy who knows how to do any needed cleanup).
	WARNING: The finalizer is not allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."
	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].
	^self finalizationRegistry add: self executor:
		(ObjectFinalizer new
			receiver: aFinalizer
			selector: aSelector)! !
!ObjectFinalizer methodsFor: 'initialization' stamp: 'jmv 12/13/2024 14:36:37'!
      receiver: aReceiver selector: aSelector
	receiver := aReceiver.
	selector := aSelector.
	arguments := #()! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6914-Finalization-Convenience-JuanVuletich-2024Dec17-09h24m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:22:43 pm'!
!WeakRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 12:05:32' prior: 17007232 overrides: 16827586!
                        add: anObject
	"Add anObject to the receiver. Store the object as well as the associated executor."
	| executor |
	executor := anObject shallowCopy actAsExecutor.
	self protected:[
		valueDictionary at: anObject put: executor.
	].
	^anObject! !

UniFileStream removeSelector: #actAsExecutor!

!methodRemoval: UniFileStream #actAsExecutor stamp: 'Install-6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st 1/2/2025 10:23:06'!
actAsExecutor
	super actAsExecutor.
	name := nil.!

Object removeSelector: #executor!

!methodRemoval: Object #executor stamp: 'Install-6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st 1/2/2025 10:23:06'!
executor
	"Return an object which can act as executor for finalization of the receiver"
	^self shallowCopy actAsExecutor!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 9:23:17 am'!
!Dictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:05'!
            associationClass

	^Association! !
!WeakKeyDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:24' overrides: 50333842!
                            associationClass

	^WeakKeyAssociation! !
!WeakValueDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:43' overrides: 50333842!
                   associationClass

	^WeakValueAssociation! !
!Dictionary methodsFor: 'accessing' stamp: 'JMM 12/2/2024 09:54:17' prior: 16847449 overrides: 16915102!
           at: key put: anObject
	"Set the value at key to be anObject. 
	If key is not found, create a new entry for key and set is value to anObject.
	If key is found, update the existing association.
	Answer anObject."

	| index assoc |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc
		ifNil: [ self atNewIndex: index put: (self associationClass key: key value: anObject) ]
		ifNotNil: [ assoc value: anObject ].
	^ anObject! !
!WeakKeyDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:08:53' prior: 17006854 overrides: 50333857!
                  at: key put: anObject 
	"Set the value at key to be anObject.  If key is not found, create a new
	entry for key and set is value to anObject. Answer anObject."
	
	key ifNil: [ ^anObject ].
	^super at: key put: anObject! !

WeakValueDictionary removeSelector: #at:put:!

!methodRemoval: WeakValueDictionary #at:put: stamp: 'Install-6916-Dictionary-Refactor-JohnMcIntosh-2024Dec12-09h22m-JMM.001.cs.st 1/2/2025 10:23:06'!
at: key put: anObject 
	"Set the value at key to be anObject.  If key is not found, create a new
	entry for key and set is value to anObject. Answer anObject."
	| index element |
	index := self findElementOrNil: key.
	element := array at: index.
	element
		ifNil: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]
		ifNotNil: [element value: anObject].
	^ anObject!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6916-Dictionary-Refactor-JohnMcIntosh-2024Dec12-09h22m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 8:58:48 am'!
!Class methodsFor: 'subclass creation' stamp: 'eem 8/25/2015 16:37'!
 ephemeronSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have ephemeron semantics, i.e. where the object will be queued for
	finalization when the key (first) inst var is not reachable other than through
	the other fields of ephemerons with unreachable keys."

	| answer |
	answer := ClassBuilder new
			superclass: self
			ephemeronSubclass: t
			instanceVariableNames: f
			classVariableNames: d
			poolDictionaries: s
			category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6917-Ephemeron-ClassCreationSupport-JohnMcIntosh-2024Dec12-08h57m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:16:10 pm'!

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st 1/2/2025 10:23:06'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronIdentityDictionary commentStamp: '<historical>' prior: 0!
              I am an identity dictionary holding only weakly on my keys.
When one of my keys is garbage collected, the key->value association is removed from the dictionary.

Internally I use Ephemeron objects that know myself as their container.
Ephemeron are implemented as ephemerons and get mourned when their key is only known from itself.
On mourn, the association asks the container to remove itself.!

Association ephemeronSubclass: #Ephemeron
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #Ephemeron category: #'System-Finalization' stamp: 'Install-6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st 1/2/2025 10:23:06'!
Association ephemeronSubclass: #Ephemeron
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!Ephemeron commentStamp: '<historical>' prior: 0!
           An Ephemeron is an association known to the garbage collection system, allowing it to function as a pre-mortem finalizer.

An Ephemeron is intended for uses such as associating an object's dependents with an object without preventing garbage collection.

Consider a traditional implementation of dependents in non-Model classes.  There is a Dictionary in Object, DependentsFields, into which objects wishing to have dependents are entered as keys, with the value being the sequence of their dependents.  Since a key's dependents (if they are like views/morphs, etc in MVC) will refer directly back to the key (e.g. in their model inst var etc), the key remains srongly referenced; there is no way to use weak collections in DependentsFields to allow the cycle of an object and its dependents to be collected.  If DependentsFields were to use a WeakArray to hold the associations from objects to their dependents then those associations, and the dependencies they record, would simply be lost since the only reference to the associations is from DependentsFields.

Ephemeron differs from a normal association in that it is known to the garbage collector and it is involved in tracing.  First, note that an Ephemeron is a *strong* referrer.  The objects it refers to cannot be garbage collected.  It is not weak.  But it is able to discover when it is the *only* reference to an object.  To be accurate, an Ephemeron is notified by the collector when its key is only referenced from the transitive closure of references from ephemerons.  i.e. when an ephemeron is notified we know that there are no reference paths to the ephemeron's key other than through ephemerons; the ephemeron's key is not otherwise reachable from the roots.

Ephemerons are notified by the garage collector placing them in a queue and signalling a semaphore for each element in the queue.  An image level process (the extended finalization process) extracts them from the queue and sends mourn to each ephemeron (since their keys are effectively dead).  What an Ephemeron does in response to the notification is programmable (one can add subclasses of Ephemeron).  But the default behaviour is to send finalize to the key, and then to remove itself from the dictionary it is in, allowing it and the transitive closure of objects reachable from it, to be collected in a subsequent garbage collection.

Implementation: both in scavenging, and in scan-mark, if an ephemeron is encountered its key is examined.  If the key is reachable from the roots (has already been scavenged, or is already marked), then the ephemeron marked and treated as an ordinary object. If the key is not yet known to be reachable the ephemeron is held in an internal queue of maybe triggerable ephemerons, and its objects are not traced.

At the end of the initial scavenge or scan-mark phase, this queue of triggerable ephemerons is examined.  All ephemerons in the list whose key is reachable are traced, and removed from the list.  i.e. what has happened was that their key was found reachable form the roots after they were added in the list (the garbage collector traces the object graph in an arbitrary order, typically breadth first in the scavenger, depth-dirst in teh scan-mark).  This then leaves the list populated only with ephemerons whose keys are as yet untraced, and hence only referenced from the ephemerons in the triggerable ephemeron queue, which now becomes the triggered ephemeron queue.  All these ephemerons are placed in the finalization queue for processing in the image above, and all objects reachable from these ephemerons are traced (scavenged, marked).  This tracing phase may encounter new potentially triggerable ephemerons which will be added to the triggerable ephemeron queue (not likely in practice, but essential for sound semantics).  So the triggering phase continues until the system reaches a fixed point with an empty triggerable ephemeron queue.

Implications and advantages:
Because ephemerons do not allow their object to be collected, they can be, and are, used to implement pre-mortem finalization.  So e.g. a file can flush its buffers and then close its file descriptor before being collected (which may also imply that the system runs the garbage collector *before* snapshotting, not as part of the snapshot primitive).  Ephemerons are conceptually more simple than WeakKeyDictionary et al, since they are about reference paths, not merely the existence of strong references.  They accurately identify when an object is no longer reachable from the roots, no matter how many ephemerons are attached to a specific object for whatever purpose.  Note that the back reference from a dependent to an object renders a weak key dictionary useless in enabling an isolated cycle to be collected since the back reference is string, and keeps the reference from the weak key alive.

History: Ephemerons are like guardians.  They were invented by George Bosworth in the early '90's, to provide pre-mortem finalization and to solve the problem of DependentsFields retaining garbage.

Instance Variables
	container 	<Dictionary|Set> - the container in which the Ephemeron resides.
!
!EphemeronIdentityDictionary methodsFor: 'accessing' stamp: 'JMM 12/6/2024 10:37:01' overrides: 50333842!
        associationClass
	^Ephemeron! !
!EphemeronIdentityDictionary methodsFor: 'adding' stamp: 'JMM 12/12/2024 10:05:22' overrides: 16847595!
                        add: anAssociation
	
	"Installs a copy of the association in myself.
	I cannot add the association because they are not shareable between weak key dictionaries, it needs myself as container.
	Moreover, I can only contain Ephemerons, and not other kinds of Association."
	self at: anAssociation key put: anAssociation value.

	^ anAssociation! !
!EphemeronIdentityDictionary methodsFor: 'private' stamp: 'JMM 12/2/2024 14:47:36' overrides: 16950510!
                               atNewIndex: index put: anEphemeron

	anEphemeron container: self.
	^super atNewIndex: index put: anEphemeron! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'JMM 12/12/2024 10:02:44' overrides: 16847844!
       postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	array := array collect: [ :assoc |
		         assoc ifNotNil: [
			         assoc copy
				         container: self ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'JMM 12/2/2024 15:19:05'!
                 finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"
	
	self removeKey: anEphemeron key ifAbsent: [].
! !
!Ephemeron methodsFor: 'accessing' stamp: 'eem 10/1/2020 12:31'!
                             container
	"Answer the Dictionary containing the receiver, if any."
	^container! !
!Ephemeron methodsFor: 'accessing' stamp: 'eem 10/1/2020 12:33'!
            container: aDictionarySetOrNil
	"Set the Dictionary containing the receiver, or nil it."
	container := aDictionarySetOrNil! !
!Ephemeron methodsFor: 'testing' stamp: 'eem 9/1/2015 10:12'!
    isEphemeron
	^true! !
!Ephemeron methodsFor: 'mourning' stamp: 'JMM 12/9/2024 10:28:28'!
       mourn
	"Triggered ephemerons get sent mourn by EphemeronsFinalizationProcess class's finalizationProcess
	 (via mournLoopWith:) when the only reference(s) to an ephemeron's key is through
	 one or more ephemerons. i.e. the key is not reachable from the roots of the system,
	 only through ephemerons.  So ephemerons get sent mourn when their key would
	 otherwise have been garbage collected.  Respond to the information that the key
	 would have been garbage collected other than through ephemeron references by
	 sending finalize to the key."
	container finalizeEphemeron: self.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6917] on 12 December 2024 at 4:26:01 pm'!
!Object methodsFor: 'finalization' stamp: 'JMM 11/20/2024 17:29:59'!
                     mourn
	"Sent by the new Finalization mechanism.
	All weak objects (instances of weak classes) and Ephemerons may be mourned if they point to an object that needs to be collected.

	This default implementation does nothing. To override in specific subclasses."! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6919-Object-mourn-JohnMcIntosh-2024Dec12-16h24m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:43:01 pm'!

Object subclass: #EphemeronFinalizationProcess
	instanceVariableNames: ''
	classVariableNames: 'FinalizationSemaphore TheFinalizationProcess'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronFinalizationProcess category: #'System-Finalization' stamp: 'Install-6920-EphemeronFinalizationProcess-JohnMcIntosh-2024Dec12-12h16m-JMM.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #EphemeronFinalizationProcess
	instanceVariableNames: ''
	classVariableNames: 'FinalizationSemaphore TheFinalizationProcess'
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronFinalizationProcess commentStamp: 'jmv 12/12/2024 12:21:40' prior: 0!
                  I represent the finalization process that waits for finalization of objects and sends the #mourn message to then. I am registered to the startup to stop/start myself on each start.!
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 12/6/2024 12:16:29'!
                             doWeakFinalizationWork
	"Process the weak registries, in the old finalization style.  Hopefully this will
	 eventually go away when all clients have adopted the new finalization scheme."
	FinalizationLock
		critical:
			[FinalizationDependents do:
				[ :weakDependent |
				weakDependent ifNotNil:
					[weakDependent finalizeValues]]]
		ifError:
			[:msg :rcvr | rcvr error: msg]! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'jmv 12/12/2024 12:25:03'!
 finalizationProcess
	"The finalization process arranges to send mourn to each element of the VM's finalization queue,
	 which is accessed via primitiveFetchMourner.  The VM signals FinalizationSemaphore whenever
	 the queue is non-empty.  This process loops, waiting on the semaphore, fetches the first element
	 of the queue and then spawns a process at a higher priority to actually send the mourn messages.
	 If an error occurs in the higher priority mourn loop process then this process will simply spawn
	 another process, hence ensuring that errors in finalization methods don't break finalization.

	 In addition this process also runs the old finalization scheme, supporting clients of the older,
	 WeakRegistry based scheme.  Hopefully this will go away when all clients have moved over."
	| throttle firstMourner |
	throttle := Semaphore new.
	[true] whileTrue:
		[FinalizationSemaphore wait; initSignals.
		 "Support the old scheme until things have changed over..."
		 self doWeakFinalizationWork.
		
		 [firstMourner := self primitiveFetchMourner.
		  firstMourner notNil] whileTrue:
			[[throttle signal.
			  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1  named: '[system] Ephemeron Mourn processing'.
			  throttle wait]]! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: '9/24/2024 06:44'!
                        runningFinalizationProcess
	"Answer the FinalizationProcessNewEra I am running, if any"
	^TheFinalizationProcess! !
!EphemeronFinalizationProcess class methodsFor: 'class initialization' stamp: 'jmv 12/12/2024 12:38:36' overrides: 16917943!
               initialize
	"
	SystemDictionary initialize.
	WeakArray restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.
	"

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.! !
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: 'JMM 12/12/2024 10:46:41'!
                     mournLoopWith: firstMourner
	"Send mourn to all the objects available in the mourn queue, starting
	 with firstMourner which the sender has already extracted for us.  If
	 an error occurs here, it will break this loop but the sender will spawn
	 another mournLoopWith: so that finalization is not broken by errors in
	 individual cases."
	| mourner |
	mourner := firstMourner.
	[mourner mourn.
	 (mourner := self primitiveFetchMourner) notNil] whileTrue! !
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: '9/24/2024 06:44'!
                        primitiveFetchMourner
	"Answer the next mourner in the VM's queue of objects to be finalized.
	 The queue contains weak arrays and ephemerons.  If the primitive is
	 not implemented, raise an error telling people to upgrade the VM.  If
	 implemented, the primitive fails if the queue is empty, with the error
	 code #'not found'. Primitive.  Essential."

	<primitive: 172 error: ec>
	ec ifNil: [^self error: 'The primitiveFetchMourner primitive is missing.\Please upgrade your virtual machine to one that has the primitive.' withCRs].
	^nil! !
!EphemeronFinalizationProcess class methodsFor: 'system startup' stamp: '9/24/2024 06:44' overrides: 16789354!
                 startUp: resuming
	resuming ifFalse: [ ^self ].
	self restartFinalizationProcess! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 12/11/2024 12:38:56'!
               doWeakFinalizationWork
	" Fork off the old weak array processing logic" 
	
	[WeakArray doWeakFinalizationWork] forkAt: Processor activePriority + 2 named: '[system] Ephemeron WeakArray processing'! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/27/2024 09:48:11'!
                           restartFinalizationProcess
	"kill any old process, just in case"
	TheFinalizationProcess
		ifNotNil: [TheFinalizationProcess terminate.
			TheFinalizationProcess := nil].

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.
	TheFinalizationProcess := [ self finalizationProcess ] newProcess.
	TheFinalizationProcess priority: Processor userInterruptPriority.
	TheFinalizationProcess name: '[system] Ephemeron finalization'.
	TheFinalizationProcess resume! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/20/2024 17:21:58'!
             stopFinalizationProcess
	"kill any old process, just in case"
	TheFinalizationProcess
		ifNotNil: [TheFinalizationProcess terminate.
			TheFinalizationProcess := nil].! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/20/2024 17:24:21'!
                        theFinalizationProcess
	^TheFinalizationProcess! !
!WeakArray class methodsFor: 'services' stamp: 'JMM 11/29/2024 14:30:48' prior: 17006624!
                   ensureFinalizationComplete

	Smalltalk garbageCollect.
	Processor activePriority >= self finalizationProcess priority ifTrue: [
		"Not needed if the default priorities are used. Just in case."
		Processor activeProcess priority: self finalizationProcess priority-1.
		Processor yield ].! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/29/2024 14:30:21' prior: 17006579!
finalizationProcess
	"nothing here, moved to EphemeronFinalizationProcess class"
	^EphemeronFinalizationProcess theFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'jmv 12/12/2024 12:39:21' prior: 17006597!
                        restartFinalizationProcess

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess
		ifNotNil: [ 
			FinalizationProcess terminate.
			FinalizationProcess := nil ].
	FinalizationSemaphore := nil.
	EphemeronFinalizationProcess restartFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/27/2024 09:22:05' prior: 17006560!
   runningFinalizationProcess
	"Answer the FinalizationProcess I am running, if any"
	^EphemeronFinalizationProcess theFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/27/2024 09:22:05' prior: 17006616!
                       stopFinalizationProcess
	"kill old process"
	EphemeronFinalizationProcess stopFinalizationProcess! !
!SystemDictionary class methodsFor: 'initialization' stamp: 'jmv 12/12/2024 12:36:48' prior: 16971714 overrides: 16917943!
initialize
	"
	SystemDictionary initialize
	"

	StartUpList := OrderedCollection new.
	"These get processed from the top down..."
	#(
		#Delay
		#DisplayScreen
		#Cursor
		#InputSensor
		#ProcessorScheduler 	"Starts low space watcher and bkground."
		#EphemeronFinalizationProcess)
			do: [ :clsName | 	
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToStartUpList: cls]].
			
	ShutDownList := OrderedCollection new.
	"These get processed from the bottom up..."
	#(
		#Delay
		#DisplayScreen
		#InputSensor
		#ProcessBrowser
		#CPUWatcher)
			do: [ :clsName | 
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToShutDownList: cls]]! !

WeakArray class removeSelector: #cleanupForEphemeronFinalizationProcess!

SystemDictionary initialize!

EphemeronFinalizationProcess initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	SystemDictionary initialize.
	WeakArray restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6920-EphemeronFinalizationProcess-JohnMcIntosh-2024Dec12-12h16m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:57:17 pm'!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore '
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore'
	poolDictionaries: ''
	category: 'Collections-Weak'!
!WeakArray class methodsFor: 'class initialization' stamp: 'jmv 12/12/2024 12:50:09' prior: 17006567 overrides: 16917943!
                  initialize
	"
	WeakArray initialize.
	"

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.! !

WeakArray class removeSelector: #startUp!

!methodRemoval: WeakArray class #startUp stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
startUp
	"Do it even if just continuing after image snapshot"
	self restartFinalizationProcess!

WeakArray class removeSelector: #restartFinalizationProcess!

!methodRemoval: WeakArray class #restartFinalizationProcess stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
restartFinalizationProcess

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess
		ifNotNil: [ 
			FinalizationProcess terminate.
			FinalizationProcess := nil ].
	FinalizationSemaphore := nil.
	EphemeronFinalizationProcess restartFinalizationProcess!

WeakArray class removeSelector: #pvtCreateTemporaryObjectIn:!

!methodRemoval: WeakArray class #pvtCreateTemporaryObjectIn: stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
pvtCreateTemporaryObjectIn: tempObject
	"We have to create the temporary object in a separate stack frame"
	tempObject at: 1 put: Object new!

WeakArray class removeSelector: #isFinalizationSupported!

!methodRemoval: WeakArray class #isFinalizationSupported stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
isFinalizationSupported
	"This method is only here for backwards compatibility, all closure VMs support finalization"
	
	^true!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock'
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock'
	poolDictionaries: ''
	category: 'Collections-Weak'!

WeakArray initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:18:56 pm'!

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st 1/2/2025 10:23:06'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronIdentityDictionary commentStamp: 'eem 10/1/2020 16:31' prior: 50333960!
                               An EphemeronIdentityDictionary is an identity dictionary that uses ephemerons for its associations, and hence is able to arrange that its keys are finalizable.  See Ephemeron's class comment.

Instance Variables
	mutex:		<Mutex>

mutex
	- an access protect that prevents the receiver getting corrupted as finalization occurs while lower priority processes are adding and/or rremoving ephemerons.
!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:45:00' overrides: 16847372!
                       associationAt: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super associationAt: key ifAbsent: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:27:37' overrides: 16847399!
        at: key ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key ifAbsent: absentBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:25:34' overrides: 16847430!
                    at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key ifPresent: presentBlock ifAbsent: absentBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:25:23' overrides: 50333857!
    at: key put: anObject
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key put: anObject ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:30:42' overrides: 16847741!
    collect: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super collect: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:30:32' overrides: 16847755!
                do: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super do: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:49:11' overrides: 16847515!
                          keys
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keys ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:31:01' overrides: 16847760!
      keysAndValuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysAndValuesDo: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:26:43' overrides: 16847651!
keysAndValuesRemove: keyValueBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysAndValuesRemove: keyValueBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:31:25' overrides: 16847766!
          keysDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysDo: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:45:40' overrides: 16847851!
                   rehash
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super rehash ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:51:39' overrides: 16950658!
  removeAll
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super removeAll ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:26:30' overrides: 16847692!
                            removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super removeKey: key ifAbsent: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:32:05' overrides: 16847773!
                select: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super select: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:46:02' overrides: 16950444!
                   size
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super size ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:32:16' overrides: 16847786!
      valuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super valuesDo: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:52:37'!
                finalizeValues
	"legacy systems might invoke this as it's an api on the old WeakRegistry"
	Smalltalk garbageCollect! !
!EphemeronIdentityDictionary methodsFor: 'initialize-release' stamp: 'eem 10/1/2020 10:50' overrides: 16950576!
                         init: n
	mutex := Mutex new.
	super init: n! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'jmv 12/13/2024 11:15:20' prior: 50334182 overrides: 16847844!
                        postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	mutex critical:
	[
		array := array collect: 
		[ :assoc |
		         assoc ifNotNil:
				[
				        assoc copy container: self ] ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:15:43' prior: 50334192!
               finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical: [
		self removeKey: anEphemeron key ifAbsent: []].
! !

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st 1/2/2025 10:23:06'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:20:51 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6923-FinalizationRegistry-JohnMcIntosh-JuanVuletich-2024Dec13-12h18m-jmv.001.cs.st 1/2/2025 10:23:06'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry commentStamp: '<historical>' prior: 0!
     The default FinalizationRegistry holds objects that need finalization.

Objects added with the #add: message will simply be send #finalize before being collected.
For Objects added with the #add:executor: message, #finalize will be sent to the executor (an instance of ObjectFinalizer) instead.!
!FinalizationRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 10:12:24' overrides: 50334160!
                       add: anObject
	"Add an object to be finalized."

	self at: anObject put: nil.! !
!FinalizationRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 10:34:51'!
  add: anObject executor: anObjectFinalizer
	"Add an object to be finalized."

	self at: anObject put: anObjectFinalizer.! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:16:28' overrides: 50334875!
                              finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical: [

		self removeKey: anEphemeron key ifAbsent: [].

		"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
		Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value."
		(anEphemeron value ifNil: [ anEphemeron key ])
			finalize ].! !
!FinalizationRegistry class methodsFor: 'accessing' stamp: 'jmv 12/13/2024 11:37:31'!
          default
	^Default ifNil:[Default := self new]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6923-FinalizationRegistry-JohnMcIntosh-JuanVuletich-2024Dec13-12h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6924] on 16 December 2024 at 7:10:37 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st 1/2/2025 10:23:06'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry methodsFor: 'nil' stamp: 'JMM 12/13/2024 15:34:09' overrides: 50334858!
                  init: n
	super init: n.
	errorHandler := self.! !
!FinalizationRegistry methodsFor: 'accessing' stamp: 'JMM 12/13/2024 15:38:57'!
                              errorHandler: anErrorHandler 
	errorHandler := anErrorHandler! !
!FinalizationRegistry methodsFor: 'private - synchronization' stamp: 'jmv 12/16/2024 19:10:09'!
                               handleErrorsDuring: aBlock

	aBlock on: Error do:[:ex| ex return].! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'JMM 12/16/2024 08:49:42' prior: 50334954 overrides: 50334875!
   finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical:
	[
	
		self removeKey: anEphemeron key ifAbsent: [].
		errorHandler handleErrorsDuring:
		[ 
			
			"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
			Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value."
			
			(anEphemeron value ifNil: [ anEphemeron key ])
				finalize ]].! !
!ObjectFinalizer methodsFor: 'finalization' stamp: 'JMM 12/16/2024 18:29:01' prior: 16918530 overrides: 16916076!
                        finalize
	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO guarantee that the resource associated with the receiver hasn't been freed already, so take care that you don't run into trouble - this all may happen with interrupt priority."

	receiver perform: selector withArguments: arguments! !

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st 1/2/2025 10:23:06'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6925] on 16 December 2024 at 7:33:40 pm'!
!BlockClosure methodsFor: 'exceptions' stamp: 'jmv 12/16/2024 19:28:54'!
                      on: exception fork: handlerAction
	"Activate the receiver. In case of exception, fork a new process, which will handle an error.
	An original process will continue running as if receiver evaluation finished and answered nil,
	i.e., an expression like:

	[ self error: 'some error'] on: Error fork: [ :ex |  ex pass ]

	will always answer nil for original process, regardless of the forked block.

	The context stack , starting from context which sent this message to receiver and
	up to the top of the stack will be transferred to forked process, with handlerAction on top.
	(so when the forked process will be resuming, it will enter the handlerAction)
	 "

	^ self
		  on: exception
		  do: [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction valueWithPossibleArgument: ex ] ].

			  bottom := [ Processor activeProcess terminate ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction valueWithPossibleArgument: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ]! !
!FinalizationRegistry methodsFor: 'private - synchronization' stamp: 'jmv 12/16/2024 19:33:35' prior: 50335015!
    handleErrorsDuring: aBlock

	"The following code would silently swallow any errors during finalization.
	This was the behavior in Cuis WeakRegistry prior to December 2024.
	Such errors would likely remain unnoticed.
	At least, printing some warning to Transcript would be better."
	"aBlock on: Error do:[:ex| ex return]."

	"The following code will resume the finalization process, but would a debugger will open
	in a forked process, so finalization is not paused or stopped."
	aBlock on: Error fork: [ :e | e pass ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6925-ForkFinalizationErrors-DebuggingAid-JohnMcIntosh-JuanVuletich-2024Dec16-19h27m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6925] on 17 December 2024 at 10:39:08 am'!

"Change Set:		6926-CuisCore-AuthorName-2024Dec17-10h27m
Date:			17 December 2024
Author:			Juan Vuletich

<your descriptive text goes here>"
WeakRegistry default notEmpty ifTrue: [ self error: 'WeakRegistry default needs to be empty  to install further updates' ].!

Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakRegistry category: #'Collections-Weak' stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:23:06'!
Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Collections-Weak'!
!Object methodsFor: 'finalization' stamp: 'jmv 12/13/2024 12:04:39' prior: 16916070!
                             finalizationRegistry
	"Answer the finalization registry associated with the receiver."
	^FinalizationRegistry default! !

WeakRegistry class removeSelector: #default!

!methodRemoval: WeakRegistry class #default stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:23:06'!
default
	^Default ifNil:[Default := self new]!

Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakRegistry category: #'Collections-Weak' stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:23:06'!
Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6926] on 18 December 2024 at 9:17:49 am'!
!FileList methodsFor: 'file list' stamp: 'eem 12/18/2024 09:15:55' prior: 50333436!
                             fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | entry fileSize ifNil: [mx] ifNotNil: [:fs| mx max: fs]]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6927-FileList-fix-EliotEmilioMiranda-2024Dec18-09h15m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:23:02 pm'!
!SystemWindow methodsFor: 'open/close' stamp: 'eem 12/18/2024 11:22:52' prior: 16972922 overrides: 16923980!
       openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect := self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse).
	 For strange circumstances such as tests provoking errors, only activate windows that are still in world
	 by the time the action is actually ready to evaluate. "
	UISupervisor whenUIinSafeState:
		[ self isInWorld ifTrue:
			[ self activate ] ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6928-AllowDeletingJustCreatedWindows-EliotEmilioMiranda-2024Dec18-20h22m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:18:48 pm'!
!DebuggerWindow class methodsFor: 'services' stamp: 'eem 12/18/2024 11:12:07'!
                              closeAllDebuggersSuchThat: aBlock
	"DebuggerWindow closeAllDebuggers"

	UISupervisor ui ifNotNil:
		[ :world |
		world submorphsDo:
			[ :morph |
			((morph class == DebuggerWindow or: [morph class == PreDebugWindow ])
			 and: [aBlock value: morph])
				ifTrue: [morph delete ]]]! !
!DebuggerWindow class methodsFor: 'services' stamp: 'eem 12/18/2024 11:12:22' prior: 16845344!
     closeAllDebuggers
	"DebuggerWindow closeAllDebuggers"

	self closeAllDebuggersSuchThat: [:ign| true]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6929-closeDebuggersSuchThar-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6929] on 18 December 2024 at 8:29:42 pm'!
!Ephemeron methodsFor: 'mourning' stamp: 'eem 12/18/2024 11:54:12' prior: 50334216 overrides: 50334245!
                           mourn
	"Triggered ephemerons get sent mourn by EphemeronsFinalizationProcess class's finalizationProcess
	 (via mournLoopWith:) when the only reference(s) to an ephemeron's key is through
	 one or more ephemerons. i.e. the key is not reachable from the roots of the system,
	 only through ephemerons.  So ephemerons get sent mourn when their key would
	 otherwise have been garbage collected.  Respond to the information that the key
	 would have been garbage collected other than through ephemeron references by
	 sending finalize to the key.

	 N.B. read #finalizeEphemeron: to understand why #finalize is not sent here."
	container finalizeEphemeron: self.! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'eem 12/18/2024 09:52:15' prior: 50334306!
                           finalizationProcess
	"The finalization process arranges to send mourn to each element of the VM's finalization queue,
	 which is accessed via primitiveFetchMourner.  The mourn queue contains Ephemerons whose
	 keys should be finalized. The VM signals FinalizationSemaphore whenever the queue is non-empty.
	 This process loops, waiting on the semaphore, fetches the first element of the queue and then
	 spawns a process at a higher priority to actually send the mourn messages. If an error occurs in
	 the higher priority mourn loop process then this process will simply spawn another process, hence
	 ensuring that errors in finalization methods don't break finalization.

	 In addition this process also runs the old finalization scheme, supporting clients of the older,
	 WeakRegistry based scheme.  This may go away if and when all clients have moved over."
	| throttle firstMourner |
	throttle := Semaphore new.
	[true] whileTrue:
		[FinalizationSemaphore wait; initSignals.
		 "Support the old scheme until things have changed over..."
		 self doWeakFinalizationWork.
		
		 [firstMourner := self primitiveFetchMourner.
		  firstMourner notNil] whileTrue:
			[[throttle signal.
			  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1  named: '[system] Ephemeron Mourning'.
			  throttle wait]]! !
!EphemeronFinalizationProcess class methodsFor: 'class initialization' stamp: 'eem 12/18/2024 11:08:48' prior: 50334357 overrides: 16917943!
        initialize
	"
	SystemDictionary initialize.
	EphemeronFinalizationProcess restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.
	"

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.! !

EphemeronFinalizationProcess initialize.
EphemeronFinalizationProcess restartFinalizationProcess!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6930-BetterCommentsAndProcessName-EliotEmilioMiranda-2024Dec18-20h29m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:18:11 pm'!
!Ephemeron commentStamp: 'eem 12/18/2024 10:26:19' prior: 50333990!
       An Ephemeron is an association known to the garbage collection system, allowing it to function as a "pre-mortem" finalizer, as opposed to "post-mortem" finalization.

Weak array based finalization schemes work by having a WeakArray of objects whose collection will be observed by a weak array element being nilled, and a parallel array of corresponding copies of the collectable objects. The corresponding object copy is finalized some time after the weakly referenced object is collected. This is known as post-mortem finalization and suffers the problem that the copy is finalized, not the original object. This requires effort to synchronize the original and the copy while avoiding strong references to the original, preventing its collection.

Unlike the weak scheme, ephemerons notice when their key is only referenced through ephemerons, consequenctly they can send #finalize to their key before their key is collected but when it is found to be collectable. So this finalizes the actual object with no need to maintain a copy, and is known as pre-mortem finalization.

Details:

An Ephemeron is intended for uses such as associating an object's dependents with an object without preventing garbage collection.

Consider a traditional implementation of a property table (for example, dependents in MVC).  There is a Dictionary in ActiveModel, ActionMaps, into which objects wishing to have dependents are entered as keys, with the value being the sequence of their dependents.  Since a key's dependents (if they are like views/morphs, etc in MVC) will refer directly back to the key (e.g. in their model inst var etc), the key remains srongly referenced; there is no way to use weak collections in DependentsFields to allow the cycle of an object and its dependents to be collected.  If ActionMaps were to use a WeakArray to hold the associations from objects to their dependents then those associations, and the dependencies they record, would simply be lost since the only reference to the associations is from ActionMaps.

Ephemeron differs from a normal association in that it is known to the garbage collector and it is involved in tracing.  First, note that an Ephemeron is a *strong* referrer.  The objects it refers to cannot be garbage collected.  It is not weak.  But it is able to discover when it is the *only* reference to an object.  To be accurate, an Ephemeron is notified by the collector when its key is only referenced from the transitive closure of references from ephemerons.  i.e. when an ephemeron is notified we know that there are no reference paths to the ephemeron's key other than through ephemerons; the ephemeron's key is not otherwise reachable from the roots.

Ephemerons are notified by the garage collector placing them in a queue and signalling a semaphore for each element in the queue.  An image level process (the extended finalization process) extracts them from the queue and sends mourn to each ephemeron (since their keys are effectively dead).  What an Ephemeron does in response to the notification is programmable (one can add subclasses of Ephemeron).  But the default behaviour is to send #finalize to the key, and then to remove itself from the dictionary it is in, allowing it and the transitive closure of objects reachable from it, to be collected in a subsequent garbage collection.

Implementation:

Both in scavenging, and in mark-sweep, if an ephemeron is encountered its key is examined.  If the key is reachable from the roots (has already been scavenged, or is already marked), then the ephemeron marked and treated as an ordinary object. If the key is not yet known to be reachable the ephemeron is held in an internal set of maybe triggerable ephemerons, and its objects are not traced.

At the end of the initial scavenge or mark-sweep phase, this set of triggerable ephemerons is examined.  All ephemerons in the set whose key is reachable are traced, and removed from the set.  i.e. what has happened was that their key was found reachable from the roots after they were added in set list (the garbage collector traces the object graph in an arbitrary order, typically breadth first in scavenging, depth-first in mark-sweep).  The set is then populated only with ephemerons whose keys are as yet untraced, and hence only referenced from the ephemerons in the set..  All these ephemerons are added to the finalization queue for processing in the image above, and all objects reachable from these ephemerons are traced (scavenged or marked).  This tracing phase may encounter new potentially triggerable ephemerons which will be added to the set (not likely in practice, but essential for sound semantics).  So the triggering phase continues until the system reaches a fixed point with an empty triggerable ephemeron set.

Implications and advantages:

Because ephemerons do not allow their object to be collected, they can be, and are, used to implement pre-mortem finalization.  So e.g. a file can flush its buffers and then close its file descriptor before being collected (which may also imply that the system runs the garbage collector *before* snapshotting, not as part of the snapshot primitive).  Ephemerons are conceptually more simple than WeakKeyDictionary et al, since they are about reference paths, not merely the existence of strong references.  They accurately identify when an object is no longer reachable from the roots, no matter how many ephemerons are attached to a specific object for whatever purpose.  Note that the back reference from a dependent to an object renders a weak key dictionary useless in enabling an isolated cycle to be collected since the back reference is string, and keeps the reference from the weak key alive.

History:

Ephemerons are like guardians.  They were invented by George Bosworth in the early '90's, to provide pre-mortem finalization and to solve the problem of DependentsFields retaining garbage in MVC.

Instance Variables
	container 	<Dictionary|Set> - the container in which the Ephemeron resides.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6931-Ephemeron-classComment-EliotEmilioMiranda-2024Dec18-20h15m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:22:43 pm'!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:47:15' prior: 50334688 overrides: 16847372!
                    associationAt: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super associationAt: key ifAbsent: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:26:40' prior: 50334699 overrides: 16847399!
                            at: key ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key ifAbsent: absentBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:09' prior: 50334710 overrides: 16847430!
        at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key ifPresent: presentBlock ifAbsent: absentBlock ]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:26' prior: 50334722 overrides: 50333857!
                       at: key put: anObject
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key put: anObject]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:41' prior: 50334732 overrides: 16847741!
                        collect: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super collect: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:53' prior: 50334742 overrides: 16847755!
    do: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super do: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:30:09' prior: 50334752 overrides: 16847515!
              keys
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keys]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:30:50' prior: 50334761 overrides: 16847760!
                          keysAndValuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysAndValuesDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:31:05' prior: 50334771 overrides: 16847651!
                    keysAndValuesRemove: keyValueBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysAndValuesRemove: keyValueBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:31:51' prior: 50334782 overrides: 16847766!
                              keysDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:32:07' prior: 50334792 overrides: 16847851!
      rehash
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super rehash]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:32:49' prior: 50334801 overrides: 16950658!
                      removeAll
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super removeAll]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:39:36' prior: 50334811 overrides: 16847692!
                removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super removeKey: key ifAbsent: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:44:56' prior: 50334822 overrides: 16847773!
    select: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super select: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:46:26' prior: 50334841 overrides: 16847786!
      valuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super valuesDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'eem 12/18/2024 12:07:19' prior: 50334864 overrides: 16847844!
                    postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	mutex := Mutex new.
	mutex critical:
		[array := array collect: 
			[ :assoc |
			assoc ifNotNil:
				[assoc copy container: self ] ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'eem 12/18/2024 11:55:20' prior: 50334875!
                finalizeEphemeron: anEphemeron

	"Remove the ephemeron from myself.  Note that no finalization of the ephemeron's key is done.
	 Here we are using ephemerons to clean up property tables."

	mutex critical:
		[self removeKey: anEphemeron key ifAbsent: []]! !

EphemeronIdentityDictionary removeSelector: #size!

!methodRemoval: EphemeronIdentityDictionary #size stamp: 'Install-6932-EphemeronIdentityDictionary-fixes-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st 1/2/2025 10:23:07'!
size
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super size ].
	^ answer!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6932-EphemeronIdentityDictionary-fixes-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:25:45 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry methodsFor: 'finalization' stamp: 'eem 12/18/2024 12:02:18' prior: 50335021 overrides: 50335766!
                            finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the phemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: [].
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron value ifNil: [anEphemeron key]) finalize! !

BlockClosure removeSelector: #on:fork:!

!methodRemoval: BlockClosure #on:fork: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
on: exception fork: handlerAction
	"Activate the receiver. In case of exception, fork a new process, which will handle an error.
	An original process will continue running as if receiver evaluation finished and answered nil,
	i.e., an expression like:

	[ self error: 'some error'] on: Error fork: [ :ex |  ex pass ]

	will always answer nil for original process, regardless of the forked block.

	The context stack , starting from context which sent this message to receiver and
	up to the top of the stack will be transferred to forked process, with handlerAction on top.
	(so when the forked process will be resuming, it will enter the handlerAction)
	 "

	^ self
		  on: exception
		  do: [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction valueWithPossibleArgument: ex ] ].

			  bottom := [ Processor activeProcess terminate ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction valueWithPossibleArgument: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ]!

FinalizationRegistry removeSelector: #handleErrorsDuring:!

!methodRemoval: FinalizationRegistry #handleErrorsDuring: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
handleErrorsDuring: aBlock

	"The following code would silently swallow any errors during finalization.
	This was the behavior in Cuis WeakRegistry prior to December 2024.
	Such errors would likely remain unnoticed.
	At least, printing some warning to Transcript would be better."
	"aBlock on: Error do:[:ex| ex return]."

	"The following code will resume the finalization process, but would a debugger will open
	in a forked process, so finalization is not paused or stopped."
	aBlock on: Error fork: [ :e | e pass ].!

FinalizationRegistry removeSelector: #errorHandler:!

!methodRemoval: FinalizationRegistry #errorHandler: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
errorHandler: anErrorHandler 
	errorHandler := anErrorHandler!

FinalizationRegistry removeSelector: #init:!

!methodRemoval: FinalizationRegistry #init: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
init: n
	super init: n.
	errorHandler := self.!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6933] on 19 December 2024 at 9:31:22 am'!
!ChangeSorterWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 12/19/2024 09:30:56' prior: 16810086!
changeSetListMenuSpec
	"Spec for the menu and shortcut keys for the changesets list.
	See coment at Morph >> #getMenu
	"
	| answer |
	answer := #(
			#(0 		'Change Set' 						true)
			#(10 		'File out, start a new cs (o)' 			$o 	model 		fileOutAndRemove 				fileOutIcon)
			#(20 		'File out, keep current cs (k)' 			$k 	model 		fileOutAndKeep 				fileOutIcon)
			#(30 		'-----')
			#(40 		'Rename change set (R)' 				$R 	model 		rename 						saveAsIcon)
			#(50 		'Destroy change set (x)' 			 	$x 	model 		remove 						warningIcon)
	).
	model currentCanHavePreambleAndPostscript ifTrue: [
		model currentHasPreamble
			ifTrue: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Edit preamble (p)' 					$p 	model 		addPreamble 					textEditorIcon)
				#(80 	'Remove preamble' 					nil 	model 		removePreamble 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Add preamble (p)' 					$p 	model 		addPreamble 					listAddIcon) )].
		model currentHasPostscript
			ifTrue: [ answer  := answer, #(
				#(90 	'Edit postscript...' 					nil 	model 		editPostscript 					textEditorIcon)
				#(100 	'Remove postscript' 					nil 	model 		removePostscript 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(90 	'Add postscript...' 					nil 	model 		editPostscript 					listAddIcon) )].
	].

	answer  := answer, #(
		#(110 			'-----')
		#(120 			'Conflicts with other change sets' 		nil 	window		browseMethodConflicts 		emblemImportantIcon
			'Browse all methods that occur both in this change set and in at least one other change set.')
		#(130 			'-----')
		#(140 			'Trim history' 						nil 	model		trimHistory 					clockIcon
			'Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.
 NOTE: can cause confusion if later filed in over an earlier version of these changes.')
		#(150 			'View affected class categories' 		nil 	model 		viewAffectedClassCategories	packageIcon
			'Show class categories affected by any contained change')
	).
	model csIsForBase ifFalse: [ "Maybe disable a few: Copy them the same as above, but without selector."
		answer := answer, #(
			#(40 		'Rename change set (R)' 				$R 	model 		nil 								saveAsIcon)
			#(50 		'Destroy change set (x)' 		 		$x 	model 		nil 								warningIcon)
			#(140 		'Trim history' 						nil 	model		nil 								clockIcon)) ].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6934-twoHopefullyBetterMenuItemLabels-JuanVuletich-2024Dec19-09h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6933] on 19 December 2024 at 9:49:36 am'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PreferenceSet installMiscPreferences!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6935-installMiscPreferences-JuanVuletich-2024Dec19-09h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6935] on 19 December 2024 at 1:45:57 pm'!
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:42:07' prior: 16933901!
   become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				| contextReceiver |
				contextReceiver := context receiver.
				(self == contextReceiver or: [ otherObject == contextReceiver ]) ifTrue: [
					| selector selfMethod otherObjectMethod |
					selector := context method selector.
					selfMethod := self class lookupSelector: selector.
					otherObjectMethod := otherObject class lookupSelector: selector.
					selfMethod = otherObjectMethod ifFalse: [
						| errorMessage |
						errorMessage := contextReceiver class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#become: aborted.' print.
							Error signal: errorMessage, ' #become: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsExchangeIdentityWith: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:41:42' prior: 16916752!
     becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:
	"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				self == context receiver ifTrue: [
					| selector oldMethod newMethod |
					selector := context method selector.
					oldMethod := self class lookupSelector: selector.
					newMethod := otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						| errorMessage |
						errorMessage := self class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#becomeForward: aborted.' print.
							Error signal: errorMessage, ' #becomeForward: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:41:53' prior: 16916790!
                      becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:copyHash:
	"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :proces :context |
				self == context receiver ifTrue: [
					| selector oldMethod newMethod |
					selector := context method selector.
					oldMethod := self class lookupSelector: selector.
					newMethod := otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						| errorMessage |
						errorMessage := self class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#becomeForward:copyHash: aborted.' print.
							Error signal: errorMessage, ' #becomeForward:copyHash: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self }
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:42:25' prior: 16827934!
                        collect: aBlock andFold: aTwoArgBlock ifEmpty: emptyBlockOrValue
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each  size] andFold: [:a :b | a + b] ifEmpty: nil
	#() collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	"

	| first answer |
	first := true.
	self do: [ :each |
		| eachValue |
		eachValue :=  aBlock value: each.
		first
			ifTrue: [
				first := false.
				answer := eachValue ]
			ifFalse: [
				answer := aTwoArgBlock
					value: answer
					value: eachValue ]].
	first ifTrue: [ answer := emptyBlockOrValue valueWithPossibleArgument: self ].
	^ answer! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:43:03' prior: 16828017!
                          detectMax: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the element for which aBlock evaluates to the highest magnitude.
	If collection empty, return nil.  This method might also be called elect:."

	| maxElement maxValue |
	self do: [ :each | 
		maxValue
			ifNil: ["first element"
				maxElement := each.
				maxValue := aBlock value: each]
				"Note that there is no way to get the first element that works 
				for all kinds of Collections.  Must test every one."
			ifNotNil: [
				| val |
				(val := aBlock value: each) > maxValue ifTrue: [
					maxElement := each.
					maxValue := val]]].
	^ maxElement! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:43:55' prior: 16828040!
                      detectMin: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the element for which aBlock evaluates to the lowest number.
	If collection empty, return nil."

	| minElement minValue |
	self do: [:each | 
		minValue
			ifNil: ["first element"
				minElement := each.
				minValue := aBlock value: each]
				"Note that there is no way to get the first element that works 
				for all kinds of Collections.  Must test every one."
			ifNotNil: [
				| val |
				(val := aBlock value: each) < minValue ifTrue: [
					minElement := each.
					minValue := val]]].
	^ minElement! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:44:32' prior: 16949353!
                         groupsOf: n atATimeDo: aBlock 
	"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.
	Allows use of a flattened 
	array for things that naturally group into groups of n.
	If aBlock has a single argument, pass it an array of n items,
	otherwise, pass the items as separate arguments.
	See also pairsDo:"
	| passArray |
	passArray := (aBlock numArgs = 1).
	n
		to: self size
		by: n
		do: [:index | 
			| args |
			args := (self copyFrom: index - n + 1 to: index) asArray.
			passArray ifTrue: [ aBlock value: args ]
				ifFalse: [ aBlock valueWithArguments: args ]].! !
!Array methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:44:46' prior: 16782585 overrides: 16827969!
                               collect: collectBlock thenSelect: selectBlock
	"Evaluate collectBlock with each my elements as the argument. Collect the 
	resulting values into a collection that is like me, but only those elements for which
	selectBlock evaluates to true. Answer the new collection.
	Overriden for performance."

	^ self species streamContents: [ :strm |
		1 to: self size do: [ :index |
			| newElement |
			newElement := collectBlock value: (self at: index).
			(selectBlock value: newElement)
				ifTrue: [ strm nextPut: newElement ]]]! !
!Array methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:45:00' prior: 16782604 overrides: 16828235!
          select: selectBlock thenCollect: collectBlock
	"Evaluate selectBlock with each my elements as the argument. For those who evaluate to true,
	collect the result of evaluating collectBlock on them into a collection that is like me.
	Answer the new collection.
	Overriden for performance."

	^ self species streamContents: [ :strm |
		1 to: self size do: [ :index |
			| each |
			each := self at: index.
			(selectBlock value: each) ifTrue: [
				strm nextPut: (collectBlock value: each) ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6936-MoveTempsToInnerBlocks-JuanVuletich-2024Dec19-13h34m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6935] on 19 December 2024 at 2:05:04 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:47:41' prior: 16812435!
       findAnySubStr: delimiters startingAt: start
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min |
	min := self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		| ind |
		ind := delim isCharacter
			ifTrue: [self indexOfSubCollection: (String with: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
		min := min min: ind].
	^ min! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:01' prior: 16812663!
             skipAnySubStr: delimiters startingAt: start 
	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."
	| ii |
	ii := start-1.
	[(ii := ii + 1) <= self size] whileTrue: [ "look for char that does not match"
		| any |
		any := false.
		delimiters do: [ :delim |
			delim isCharacter
				ifTrue: [ (self at: ii) = delim ifTrue: [any := true]]
				ifFalse: ["a substring"
					delim size > (self size - ii + 1) ifFalse: [
						| ind this |
						ind := 0.
						this := true.
						delim do: [ :dd | 
							dd = (self at: ii+ind) ifFalse: [this := false].
							ind := ind + 1].
						this ifTrue: [ii := ii + delim size - 1.  any := true]]
							ifTrue: [any := false] "if the delim is too big, it can't match"]].
		any ifFalse: [^ ii]].
	^ self size + 1! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:31' prior: 16812718!
                    subStrings: separators 
	"Answer an array containing the substrings in the receiver separated 
	by any of the elements of separators.
	Answer will not include empty strings
	'Hello World' subStrings: ' '
	'1Hello12World1This1211Are31Words1' subStrings: '123'
	'1Hello12World1This1211Are31Words1' subStrings: #($1 $2 $3)
	"

	| delimiterCharacters |
	delimiterCharacters := separators asArray.
	^Array streamContents: [ :answer |
		| out |
		out := self species writeStream.
		self do: [ :char |
			(delimiterCharacters identityIncludes: char)
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					out isEmpty ifFalse: [
						answer nextPut: out contents.
						out := self species writeStream ]]].
		out isEmpty ifFalse: [
			answer nextPut: out contents ]].! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:42' prior: 16812745!
        substringsSeparatedBy: delimiterCharacter
	"Find substrings delimited by aCharacter.
	Answer may include empty strings
	'0063;LATIN SMALL LETTER C;Ll;0;L;;;;;N;;;0043;;0043' substringsSeparatedBy: $;
	"

	^Array streamContents: [ :answer |
		| out |
		out := self species writeStream.
		self do: [ :char |
			char = delimiterCharacter
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					answer nextPut: out contents.
					out := self species writeStream ]].
		answer nextPut: out contents.
		out := nil ].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:50:36' prior: 16813289!
   asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [
					| char |
					(char := in next) = $&
					ifTrue: [
						| rest did |
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $¡].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:11' prior: 16813625!
    keywords
	"Answer an array of the keywords that compose the receiver."
	| keywords |
	keywords := Array streamContents: [ :kwds |
		| kwd isAllValidInIdentifiers |
		kwd := self species writeStream.
		isAllValidInIdentifiers := true.
		1
			to: self size
			do: [ :i |
				| char |
				char := self at: i.
				kwd nextPut: char.
				char = $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers := true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers := false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:31' prior: 16813768!
                            withBlanksCondensed
	"Return a copy of the receiver with leading/trailing blanks removed
	 and consecutive white spaces condensed as a single space."

	| trimmed |
	trimmed := self withBlanksTrimmed.
	^self species streamContents: [ :stream |
		| lastWasBlank |
		lastWasBlank := false.
		trimmed do: [ :c |
			c isSeparator
				ifTrue: [ lastWasBlank ifFalse: [ stream space ]]
				ifFalse: [ stream nextPut: c ].
			lastWasBlank := c isSeparator ]].

	"
	' abc  d   ' withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' withBlanksCondensed
	"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:42' prior: 16813831!
                               withDoubleColonsUndoubled
	"Do the inverse of #withDoubleColonsDoubled"

	^self species streamContents: [ :stream |
		| lastWasDoubleColon |
		lastWasDoubleColon := false.
		self do: [ :c |
			c = $"
				ifTrue: [
					lastWasDoubleColon
						ifFalse: [
							stream nextPut: c.
							lastWasDoubleColon := true ]
						ifTrue: [
							lastWasDoubleColon := false]]
				ifFalse: [
					stream nextPut: c.
					lastWasDoubleColon := false ]]].! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 12/19/2024 13:52:05' prior: 16814513!
   correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results maxChoices |
	scoreMin := self size // 2 min: 3.
	maxChoices := 10.
	choices := oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results := OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				| score |
				(score := self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].
			results := choices ].
	^ results! !
!CharacterSequence methodsFor: 'formatting' stamp: 'jmv 12/19/2024 13:52:18' prior: 16814573!
                      format: aCollection
	"format the receiver with aCollection  
	 
	simplest example:
	'foo {1} bar' format: {Date today}.
	 
	complete example:
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}..
	"
	^self species streamContents: [ :out |
		| stream |
		stream := self readStream.
		[stream atEnd]
			whileFalse: [| currentChar | 
				currentChar := stream next.
				currentChar = ${
					ifTrue: [| expression | 
						expression := self getEnclosedExpressionFrom: stream.
						out nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
					ifFalse: [
						currentChar = $\
							ifTrue: [stream atEnd ifFalse: [out nextPut: stream next]]
							ifFalse: [out nextPut: currentChar]]]].! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 13:52:49' prior: 16814861 overrides: 16917720!
                        readFrom: inStream
	"Answer a new String that is determined by reading the stream, inStream.  Embedded
	double quotes become the quote Character."

	^self streamContents: [ :outStream |
		| done |
		"go to first quote"
		inStream skipTo: $'.
		done := false.
		[done or: [inStream atEnd]]
			whileFalse: 
				[ |char|
				char := inStream next.
				char = $'
					ifTrue: 
						[char := inStream next.
						char = $'
							ifTrue: [outStream nextPut: char]
							ifFalse: [done := true]]
					ifFalse: [outStream nextPut: char]]].! !
!Symbol methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:54:20' prior: 16962598!
                   numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs |
	(numArgs := self numArgs) >= n ifTrue: [ ^self ].	
	^ (self species streamContents: [ :strm |
		| offs |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs := 0 ] ifFalse: [offs := 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol! !
!UnicodeString methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:57:10' prior: 16995179 overrides: 16949345!
        from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex cpIndex |
	byteIndex := self byteIndexAt: startIndex.
	cpIndex := startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		| n |
		n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (Character codePoint: codePoint).
			cpIndex := cpIndex + 1 ].
		byteIndex := byteIndex + n ].! !
!UnicodeString methodsFor: 'private' stamp: 'jmv 12/19/2024 13:57:44' prior: 16995410!
                            computeCountAndIndexFull
	| strideIndexClass |
	count := 0.
	strideIndexClass := bytes size < 256
		ifTrue: [ ByteArray ]
		ifFalse: [ bytes size < 65536
			ifTrue: [ DoubleByteArray ]
			ifFalse: [ bytes size < 4294967296
				ifTrue: [ WordArray ]
				ifFalse: [DoubleWordArray ]]].
	strideIndex := strideIndexClass streamContents: [ :out |
		| byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 13:59:07' prior: 16995576!
               basicCanonicalComposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalComposition.
	(UnicodeString fromCodePoints: #(119128 119141)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119135 119151)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119128 119141 119151)) basicCanonicalComposition asCodePoints
	"
	| byteIndex stopByteIndex combining |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				(Character combiningClass: codePoint) = 0 ifTrue: [
					self basicCompose: combining on: strm.
					combining := OrderedCollection new ].
				combining add: codePoint ].
			byteIndex := byteIndex + n ].
		self basicCompose: combining on: strm ].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 13:59:22' prior: 16995612!
                          basicCanonicalDecomposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalDecomposition.
	(Character codePoint: 119135) asString basicCanonicalDecomposition asCodePoints
	(Character codePoint: 119137) asString basicCanonicalDecomposition asCodePoints
	"
	| byteIndex stopByteIndex |
	byteIndex := 1.
	stopByteIndex := bytes size.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				Character canonicalDecomposition: codePoint on: strm ].
			byteIndex := byteIndex + n ]].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 14:00:26' prior: 16995637!
                  basicCanonicallyOrdered
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	(UnicodeString fromCodePoints: #(16r61  16r0300 16r0315 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0300 16r031B 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r031B 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r0300 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0300 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0315 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	"
	| byteIndex stopByteIndex combining |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				| cls |
				cls := Character combiningClass: codePoint.
				cls = 0
					ifTrue: [
						combining notEmpty ifTrue: [
							combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
							combining do: [ :e | strm nextPutCodePoint: e third ]].
						strm nextPutCodePoint: codePoint.
						combining := OrderedCollection new ]
					ifFalse: [
						| element |
						element := { cls. combining size+1. codePoint }.
						combining add: element ]].
			byteIndex := byteIndex + n ].
		combining notEmpty ifTrue: [
			combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
			combining do: [ :e | strm nextPutCodePoint: e third ] ]].! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 14:02:07' prior: 16995863!
            fromBytesStream: aByteStream
	"Handle UTF-8 bytes, but convert invalid UTF-8 assuming it means ISO-8859-1.
	Argument can be, for example, a InflateStream."

	| utf8 codePointCount buffer readBytes leftover byteIndex |
	buffer := ByteArray new: 10000.
	leftover := nil.
	codePointCount := 0.
	utf8 := ByteArray streamContents: [ :utf8Stream |
		[aByteStream atEnd] whileFalse: [ 
			readBytes := aByteStream nextInto: buffer.
			leftover ifNotNil: [
				readBytes := leftover, readBytes.
				leftover := nil ].
			byteIndex := 1.
			[ byteIndex <= (aByteStream atEnd
						ifFalse: [readBytes size-3] "To be sure we don't break a possible partially read multibyte code point."
						ifTrue: [readBytes size])   						"But do taks _all_ the bytes if they are the last ones."
			] whileTrue: [
				| n |
				n := Character utf8BytesAndCodePointAt: byteIndex in: readBytes
					into: [ :byte1 :byte2 :byte3 :byte4 |
						utf8Stream nextPut: byte1.
						byte2 ifNotNil: [
							utf8Stream nextPut: byte2.
							byte3 ifNotNil: [
								utf8Stream nextPut: byte3.
								byte4 ifNotNil: [
									utf8Stream nextPut: byte4 ]]].
						codePointCount := codePointCount + 1]
					into: nil.
				byteIndex := byteIndex + n ].
			leftover := byteIndex > readBytes size ifFalse: [
				readBytes copyFrom: byteIndex to: readBytes size ].
		].
	].
	^self fromUtf8Bytes: utf8 codePointCount: codePointCount.! !
!UnicodeSymbol methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:54:35' prior: 16996633!
           numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs |
	(numArgs := self numArgs) >= n ifTrue: [ ^self ].	
	^ (self species streamContents: [ :strm |
		| offs |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs := 0 ] ifFalse: [offs := 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol.! !
!Text methodsFor: 'emphasis' stamp: 'jmv 12/19/2024 14:04:15' prior: 16979735!
       fontIfApplying: textAttributes default: defaultFont
	"Answer the font for characters as specified by the argument."

	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		| font |
		font := defaultFont ifNil: [FontFamily defaultFamilyAndPointSize].
		familyName notNil | pointSize notNil ifTrue: [
			| fn ps |
			fn := familyName ifNil: [ defaultFont familyName ].
			ps := pointSize ifNil: [ defaultFont pointSize ].
			(FontFamily familyName: fn pointSize: ps) ifNotNil: [ :f |
				font := f emphasized: defaultFont emphasis]].
		^font emphasized: (defaultFont emphasis bitOr: emphasis) ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6937-MoveTempsToInnerBlocks-JuanVuletich-2024Dec19-13h45m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6937] on 19 December 2024 at 3:56:36 pm'!
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: 'jmv 12/19/2024 15:54:10' prior: 16939242!
                restoreFromFile: aFileEntry
"
 Note about importing String objects from Squeak: 
	
To make sure Strings can be moved from Squeak use 
           aString utf8Encoded 
to convert the strings to ByteArrays in Squeak before you export the object collection.

In Cuis you need to do then
           UnicodeString fromUtf8Bytes: aByteArray
to get them back.
"
	^aFileEntry readStreamDo: [ :stream |
		(self on: stream) next ].! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 15:50:09' prior: 16870499!
                          fromFileEntry: aFileEntry
	"Read a Form or ColorForm from the given file."

	^aFileEntry readStreamDo: [ :stream |
		self fromBinaryStream: stream binary ]! !
!ChangeList class methodsFor: 'public access' stamp: 'jmv 12/19/2024 15:54:48' prior: 16804880!
 browsePackageContents: aFileEntry
	"Opens a changeList on a fileStream"
	| changeList packageFile |
	packageFile := CodePackageFile onFileEntry: aFileEntry.
	changeList := aFileEntry readStreamDo: [ :stream |
		self new scanFile: stream from: 0 to: stream size ].
	"Add deletions of methods and classes that are in the CodePackage (i.e., active in the system)
	but are no longer in the CodePackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)
			text: 'method no longer in package: ', methodReference stringVersion ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new className: clsName)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aFileEntry name! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 12/19/2024 15:47:13' prior: 16861116!
   binaryContents
	^self readStreamDo: [ :stream |
		stream binary contents ].! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 12/19/2024 15:48:35' prior: 16861179!
                         textContents
	^self readStreamDo: [ :stream |
		stream contents ].! !
!FileEntry methodsFor: 'accessing-stream' stamp: 'jmv 12/19/2024 15:51:26' prior: 16861214!
                              readStreamDo: blockWithArg 
	"Raise FileDoesNotExistException if not found."
	| stream |
	stream := self readStream.
	^ [ blockWithArg value: stream ]
		ensure: [
			stream
				ifNotNil: [ :s | s close ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6938-readStreamDo-andSenders-Optimize-JuanVuletich-2024Dec19-15h47m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:29:46 pm'!
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 12/20/2024 16:13:32' prior: 16827162!
                             methodInheritance
	"Create and schedule a method browser on the inheritance of implementors."

	| list aClassNonMeta isMeta aClass sel |
	aClass := model selectedClassOrMetaClass.
	sel := model selectedMessageName.
	aClass ifNil: [ ^ nil ].
	sel ifNil: [ ^ nil ].
	aClassNonMeta := aClass theNonMetaClass.
	isMeta := aClassNonMeta ~~ aClass.
	list := OrderedCollection new.
	aClass allSuperclasses reverseDo: [ :cl |
		(cl includesSelector: sel) ifTrue: [
			list addLast: (MethodReference class: cl selector: sel) ]].
	aClassNonMeta
		allSubclassesWithLevelDo: [ :cl :level |
			| theClassOrMeta |
			theClassOrMeta := isMeta
				ifTrue: [ cl class ]
				ifFalse: [ cl ].
			(theClassOrMeta includesSelector: sel) ifTrue: [
				list addLast: (MethodReference class: theClassOrMeta selector: sel) ]]
		startingLevel: 0.
	^ Smalltalk
		browseMessageList: list
		name: 'Implementors of ' , sel, ' in ', aClass name, ' and super / sub classes'.! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 12/20/2024 16:15:07' prior: 16932554!
           changePriority
	| rule |
	rule := (model class rulesFor: model selectedProcess) second.
	rule
		ifFalse: [self inform: 'Nope, won''t change priority of ' , model selectedProcess name.
			^ self].
	self request: 'New priority'
		initialAnswer: model selectedProcess priority printString
		verifying: [:aString| ([aString asNumber asInteger] on: Error do: []) isInteger]
		do: [ :aString |
			| newPriority |
			newPriority := aString asNumber asInteger.
			(newPriority between: 1 and: Processor highestPriority)
			ifTrue:
				[model class setProcess: model selectedProcess toPriority: newPriority.
				model updateProcessList]
			ifFalse: [self inform: 'Bad priority']]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/20/2024 16:16:27' prior: 16881190 overrides: 16923705!
     adjustExtent
	"And reposition submorphs"
	| w y |
	"make all items wide, so selection indicator is wide too"
	w := self desiredWidth.
	y := 0.
	self submorphsDo: [ :m | | h |
		h := m morphHeight.
		m position: 0@y extent: w@h.
		y := y + h ].
	self morphExtent: w@y! !
!MorphicCanvas methodsFor: 'morphic world' stamp: 'jmv 12/20/2024 16:17:49' prior: 16909896!
                     drawRoots: rootMorphs rootsDamage: rootsDamage backgroundDamage: backgroundDamage
	"Redraw the damaged areas.
	Draw each morph just once, merging rectanges to be repaired as needed."
	"Iterate from back to front."

	| allDamage newDamageFromMorphsBelow |
	"Don't need a copy just because nobody will use it afterwards"
	newDamageFromMorphsBelow := backgroundDamage.
	allDamage := Rectangle merging: newDamageFromMorphsBelow.
	rootMorphs size to: 1 by: -1 do: [ :i | | morph morphDamage |
		morph := rootMorphs at: i.
		morphDamage := rootsDamage at: i.
		morph displayFullBounds ifNotNil: [ :morphFullBounds |
			newDamageFromMorphsBelow do: [ :r | | intersection |
				intersection := r intersect: morphFullBounds.
				intersection hasPositiveExtent ifTrue: [
					morphDamage
						ifNil: [ morphDamage :=  intersection ]
						ifNotNil: [ morphDamage updateMerging: intersection ]]]].
		morphDamage ifNotNil: [
			self newClipRect: morphDamage.
			self fullDraw: morph.
			newDamageFromMorphsBelow add: morphDamage.
			allDamage
				ifNil: [ allDamage := morphDamage copy ]
				ifNotNil: [ allDamage updateMerging: morphDamage ]]].
	^allDamage! !
!MorphicCanvas methodsFor: 'morphic world' stamp: 'jmv 12/20/2024 16:18:28' prior: 16910119!
     updateAllDamage: allDamage roots: rootMorphs rootsDamage: rootsDamage backgroundDamage: backgroundDamage
	"Detect any morph whose damage would grow because of morphs beneath it.
	If one found, add the new larger damage to allDamage and exit.
	See sender."
	"Iterate from back to front."

	| newDamageFromMorphsBelow |
	newDamageFromMorphsBelow := backgroundDamage copy.
	rootMorphs size to: 1 by: -1 do: [ :i |
		| morph morphPreviousDamage morphDamage |
		morph := rootMorphs at: i.
		morphPreviousDamage := rootsDamage at: i.
		morphDamage := morphPreviousDamage copy.
		morph displayFullBounds ifNotNil: [ :morphFullBounds |
			newDamageFromMorphsBelow do: [ :r | | intersection |
				intersection := r intersect: morphFullBounds.
				intersection hasPositiveExtent ifTrue: [
					morphDamage
						ifNil: [ morphDamage :=  intersection ]
						ifNotNil: [ morphDamage updateMerging: intersection ]]]].
		morphDamage ifNotNil: [
			newDamageFromMorphsBelow add: morphDamage ].
		morphDamage = morphPreviousDamage ifFalse: [
			allDamage add: morphDamage.
			^true 	]].
	^false! !
!AbstractVectorCanvas class methodsFor: 'private' stamp: 'jmv 12/20/2024 16:19:33' prior: 16779308!
 scalePathData: aFloat32Array scale: scale
	"aFloatArray is a #pathSequence: argument. It encodes a sequence of path commands in a Float32Array.
	See #pathSequence:"

	^Float32Array streamContents: [ :scaledStrm | | unscaledStrm kind |
		unscaledStrm := aFloat32Array readStream.
		[ unscaledStrm atEnd ] whileFalse: [
			kind := unscaledStrm next.
			scaledStrm nextPut: kind.
			(kind asInteger *2 max: 2) timesRepeat: [
				scaledStrm nextPut: unscaledStrm next * scale ]]
		].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 12/19/2024 12:41:19' prior: 16999569!
              image: aForm multipliedBy: aColor at: aPoint
	"Multiply aForm and aColor, then blend over destination.
	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel

	(BitBltCanvas onForm: Display) image: ((Form dotOfSize: 50) asFormOfDepth: 32) multipliedBy: Color red at: 20@20. Display forceToScreen
	"
	aColor isTransparent ifFalse: [
		BitBltCanvas accessProtect critical: [ | f |
			f := BitBltCanvas buildAuxWith: aForm multipliedWith: aColor.
			self image: f at: aPoint sourceRect: aForm boundingBox ]]! !
!VectorEngineBoundsFinder methodsFor: 'primitive algorithms' stamp: 'jmv 12/20/2024 16:25:41' prior: 17001354!
                       arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	| dx dy trx try tcx tcy center angle d hops |
	dx := geometryTransformation externalizeDelta: rx@0.
	dy := geometryTransformation externalizeDelta: 0@ry.
	trx := dx r.
	try := dy r.
	hops := ((trx max: try) * sweepAngle abs / hop) truncated + 2.
	d := sweepAngle / hops.
	center := geometryTransformation externalizePosition: cx@cy.
	tcx := center x.
	tcy := center y.
	(trx = try and: [
		d * hops > 6.28]) ifTrue: [ 	"If a circle, not an ellipse, and a complete circle, or pretty close"
			spanLeft := spanLeft min: tcx - trx.
			spanRight := spanRight max: tcx + trx.
			spanTop := spanTop min: tcy - trx.
			spanBottom := spanBottom max: tcy + trx ]

		ifFalse: [						"Else go the more expensive way"
			angle := startAngle.
			hops := hops+1.
			hops timesRepeat: [
				| x xp y yp |
				xp := angle cos * trx.
				yp := angle sin * try.
				x := thetaCos * xp - (thetaSin * yp) + tcx.
				y := thetaSin * xp + (thetaCos * yp) + tcy.
				spanLeft := spanLeft min: x.
				spanRight := spanRight max: x.
				spanTop := spanTop min: y.
				spanBottom := spanBottom max: y.
				angle := angle + d. ]].! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 9/15/2021 14:47:40' prior: 17002101!
                             arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	| dx dy trx try tcx tcy center angle xp yp x y d hops |
	dx := geometryTransformation externalizeDelta: rx@0.
	dy := geometryTransformation externalizeDelta: 0@ry.
	trx := dx r.
	try := dy r.
	hops := ((trx max: try) * sweepAngle abs / hop) truncated + 2.
	d := hops asFloat.
	center := geometryTransformation externalizePosition: cx@cy.
	tcx := center x.
	tcy := center y.
	0 to: hops do: [ :h |
		angle := h / d * sweepAngle + startAngle.
		xp := angle cos * trx.
		yp := angle sin * try.
		x := thetaCos * xp - (thetaSin * yp) + tcx.
		y := thetaSin * xp + (thetaCos * yp) + tcy.
		spanLeft := spanLeft min: x.
		spanTop := spanTop min: y.
		spanRight := spanRight max: x.
		spanBottom := spanBottom max: y.
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y. ].! !
!VectorEngineWithPluginSubPixel methodsFor: 'hacky dashed strokes' stamp: 'jmv 12/19/2024 12:43:08' prior: 17004922!
                   dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineSubPixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
! !
!VectorEngineWithPluginWholePixel methodsFor: 'hacky dashed strokes' stamp: 'jmv 12/19/2024 12:43:13' prior: 17005116!
                         dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineWholePixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6939-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h13m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:50:15 pm'!
!PathLineToCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:44:34' prior: 16923435 overrides: 16923291!
               buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	points := Array streamContents: [ :strm | | px py |
		[px := aStream nextNumber.
		py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: px@py ]]! !
!PathLineToHCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:44:43' prior: 16923468 overrides: 16923291!
                  buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	xs := Array streamContents: [ :strm | | px |
		[px := aStream nextNumber.
		px notNil ] whileTrue:
			[ strm nextPut: px ]]! !
!PathLineToVCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:45:11' prior: 16923500 overrides: 16923291!
                        buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	ys := Array streamContents: [ :strm | | py |
		[py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: py ]]! !
!PathMoveToCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:45:17' prior: 16923532 overrides: 16923291!
                         buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	points := Array streamContents: [ :strm | | px py |
		[px := aStream nextNumber.
		py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: px@py ]]! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 12/20/2024 16:37:37' prior: 16812270!
        scanCharactersFrom: startIndex to: stopIndex in: anUnicodeString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	lastIndex := startIndex.
	anUnicodeString from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		| nextDestX |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX := destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX := nextDestX.
			lastIndex := lastIndex + 1 ].
	lastIndex := stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!TTContourConstruction methodsFor: 'primitive format' stamp: 'jmv 12/20/2024 16:38:48' prior: 16973767!
                   addContourDataTo: stream tx: aGeometryTransformationOrNil
	| bezierCount firstPoint prevEndPoint |
	self isEmpty ifTrue: [
		^self ].

	"This bogus iteration could perhaps be avoided at the cost of extra memory."
	bezierCount := 0.
	self
		startPointDo: [ :firstBezierStart | ]
		quadraticBeziersDo: [ :controlPoint :endPoint | bezierCount := bezierCount + 1 ].
	stream nextPut: bezierCount.

	self
		startPointDo: [ :firstBezierStart |
			firstPoint := firstBezierStart.
			aGeometryTransformationOrNil notNil ifTrue: [
				firstPoint := aGeometryTransformationOrNil transform: firstPoint ].
			stream nextPut: firstPoint x; nextPut: firstPoint y.
			prevEndPoint := firstPoint ]
		quadraticBeziersDo: [ :controlPoint :endPoint |
			| cp ep cpr epr |
			cp := controlPoint.
			ep := endPoint.
			aGeometryTransformationOrNil notNil ifTrue: [
				cp := aGeometryTransformationOrNil transform: cp.
				ep := aGeometryTransformationOrNil transform: ep ].
			cpr := cp - prevEndPoint.
			epr := ep - prevEndPoint.
			"Make control point distict from start and end points for the benefit of VectorEnginePlugin"
			(cpr = `0.0@0.0` or: [ cpr = epr ]) ifTrue: [
				cpr := epr * 0.5 ].
			stream nextPut: epr x; nextPut: epr y.
			stream nextPut: cpr x; nextPut: cpr y.
			prevEndPoint := ep ].! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 12/19/2024 11:51:50' prior: 16918072 overrides: 16916986!
     stepAt: millisecondSinceLast

	"If there's anything in my monitor list, see if the strings have changed."
	| changes |
	changes := false.
	self monitorList keysAndValuesDo: [ :k :v |
		k ifNotNil: [ | string |
			k refresh.
			(string := k asString) ~= v ifTrue: [
				self monitorList at: k put: string. changes := true ]]].
	changes ifTrue: [ | sel |
		sel := currentSelection.
		self changed: #getList.
		self noteNewSelection: sel ]! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 12/19/2024 11:52:50' prior: 16842184!
             dayOfYear
	"This code was contributed by Dan Ingalls. It is equivalent to the terser
		^ jdn - (Year year: self year) start julianDayNumber + 1 but much quicker."

	^ self dayMonthYearDo:
		[ :d :m :y | | monthStart |
			monthStart := #(1 32 60 91 121 152 182 213 244 274 305 335) at: m.
			(m > 2 and: [ Year isLeapYear: y ])
				ifTrue: [ monthStart + d ]
				ifFalse: [ monthStart + d - 1 ]]! !
!Float methodsFor: 'converting' stamp: 'jmv 12/20/2024 16:41:27' prior: 16865214!
partValues: aThreeArgumentBlock ifInfinite: infinityBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits |
		| sign exponent mantissa |

		"Extract the sign"
		sign := signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infinityBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent := exponentBits - 16r3FF.
	
		exponentBits ~= 0
			ifTrue: [
				"Add back implicit leading 1 in fraction."
				mantissa := 16r0010000000000000 bitOr: mantissaBits ]
			ifFalse: [
				"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa."
				mantissa := mantissaBits.
				exponent := exponent + 1 ].

		"Evaluate the block"
		aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/19/2024 11:54:47' prior: 16865329!
            floatsAwayFrom: aFloat

	| count2 count1 |
	(self isNaN or: [ aFloat isNaN ]) ifTrue: [ ^ Float nan ].
	count2 := self partBits: [:s :e :m | (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	count1 := aFloat partBits: [:s :e :m | (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	^count2 - count1! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/20/2024 16:44:16' prior: 16865383!
                              nextAwayFromZero
	"Answer the Float with smallest magnitude but larger than ours, with the same sign
	Only for finite numbers."

	^ self partValues: [ :sign :myExponent :myMantissa |
		| exponent mantissa |
		myMantissa = 16r1FFFFFFFFFFFFF
			ifTrue: [
				mantissa := 16r10000000000000.
				exponent := myExponent +1 ]
			ifFalse: [
				mantissa := myMantissa+1.
				exponent := myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/20/2024 16:45:10' prior: 16865401!
           nextTowardsZero
	"Answer the Float with largest magnitude but smaller than ours, with the same sign.
	Only for finite, non zero numbers."

	^ self partValues: [ :sign :myExponent :myMantissa |
		| exponent mantissa |
		myMantissa isZero ifTrue: [ self error: 'Not for zero values' ].
		(myMantissa = 16r10000000000000 and: [myExponent > Float emin])
			ifTrue: [
				mantissa := 16r1FFFFFFFFFFFFF.
				exponent := myExponent -1 ]
			ifFalse: [
				mantissa := myMantissa-1.
				exponent := myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Fraction methodsFor: 'printing' stamp: 'jmv 12/20/2024 16:46:07' prior: 16871379 overrides: 16914567!
                      storeOn: aStream
	
	"If possible, store as a literal of the form 9999e-99
	If denominator's prime factors are just 2 and 5, then we can be printed as a literal
	of the form 999999e-99"
	"
	123e-12 storeString
	123e-12 printString
	123e-12000 storeString
	123e-12000 printString
	(3/4) storeString
	(3/4) printString
	(-3/4) storeString
	(-3/4) printString
	(1/3) storeString
	(1/3) printString
	"
	denominator
		ifMultipleOf2And5Do: [ :exponent2 :exponent5 |
			| e f |
			exponent2 > exponent5
				ifTrue: [
					e := exponent2.
					f := 5 raisedToInteger: e-exponent5 ]
				ifFalse: [
					e := exponent5.
					f := 2 bitShift: e-exponent2-1 ].
			numerator*f storeOn: aStream base: 10.
			aStream nextPut: $e; nextPut: $-.
			e storeOn: aStream base: 10 ]
		otherwise: [
			super storeOn: aStream ]
! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/20/2024 16:48:50' prior: 16891336!
     layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * self axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/20/2024 16:49:11' prior: 16891373!
                   layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * self axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!TextComposition methodsFor: 'editing' stamp: 'jmv 12/20/2024 16:31:46' prior: 16981562!
            clickAt: clickPoint
	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."
	| action startBlock t |
	action := false.
	startBlock := self characterBlockAtPoint: clickPoint.
	t := model actualContents.
	(t attributesAt: startBlock stringIndex) do: [ :att | 
		att mayActOnClick ifTrue: [ | target range boxes box |
				(target := model) ifNil: [ target := editor morph].
				range := t rangeOf: att startingAt: startBlock stringIndex.
				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 
							to: (self characterBlockForIndex: range last+1).
				box := boxes detect: [ :each | each containsPoint: clickPoint] ifNone: nil.
				box ifNotNil: [
					box := editor morph displayBounds.
					editor morph allOwnersDo: [ :m | box := box intersect: (m displayBounds) ].
					Utilities
						awaitMouseUpIn: box
						repeating: nil
						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action := true]].
				]]].
	^ action! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 12/20/2024 16:32:24' prior: 16862013!
            splitNameVersionExtensionFor: fileName
	" answer an array with the root name, version # and extension.
	See comment in senders for more details"

	self baseNameAndExtensionFor: fileName do: [ :b :extension |
		| baseName version i j |
		baseName := b.
		i := j := baseName findLast: [:c | c isDigit not].
		i = 0
			ifTrue: [version := 0]
			ifFalse: [
				(baseName at: i) = $.
					ifTrue: [
						version := (baseName copyFrom: i+1 to: baseName size) asNumber.
						j := j - 1]
					ifFalse: [version := 0].
				baseName := baseName copyFrom: 1 to: j ].
		^ Array with: baseName with: version with: extension ]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 12/19/2024 12:47:06' prior: 16823886!
 sortedExtensionMethodsDo: aBlock displayingProgress: aString
	"Include both class and instance methods we define, for classes we don't define."
	| externalClasses |
	externalClasses := self externalClasses.
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: externalClasses size
		during: [ :barBlock |
			externalClasses withIndexDo: [ :classOrMetaClass :i | | methods |
				barBlock value: i.
				methods := Array streamContents: [ :stream |
					(self extensionCategoriesForClass: classOrMetaClass) do: [ :cat |
						self methodsInCategory: cat ofClass: classOrMetaClass do: [ :m |
							stream nextPut: m ]]].
				methods sort: [ :a :b |
					a methodSymbol < b methodSymbol ].
				methods do: aBlock.
				]
			]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 12/19/2024 12:46:23' prior: 16824420!
named: aString createIfAbsent: neverAnswerNil registerIfNew: doRegisterIfJustCreated
	"Answer the instance with name aString.
	If there's no package named aString, answer nil or a new instance as requested.
	If a new instance is created, register it or not as requested.
	CodePackage named: 'Morphic' createIfAbsent: false registerIfNew: false
	CodePackage named: 'Morphic' createIfAbsent: true registerIfNew: false
	CodePackage named: 'XXXXXTest' createIfAbsent: true registerIfNew: true
	"

	| newInstance |
	^self installedPackages
		at: aString
		ifAbsent: [
			neverAnswerNil ifTrue: [ 
				newInstance := self new packageName: aString.
				doRegisterIfJustCreated ifTrue: [ self register: newInstance ].
				newInstance ]].! !
!FeatureRequirement methodsFor: 'requires' stamp: 'jmv 12/19/2024 12:47:11' prior: 16860502!
      findPackageFileAsReqOf: mainFeatureOrNil
	"Look in known places for packages providing required feature.
	Answer wether search was successful."
	| packageFileName |
	pathName ifNotNil: [
		pathName asFullFileEntry exists ifTrue: [ ^ true ]].
	packageFileName := self packageFileName.
	(mainFeatureOrNil ifNil: [ self ]) placesToLookForPackagesDo: [ :directory | | entry |
		entry := directory // packageFileName.
		entry exists ifTrue: [
			"Try this one. If success, keep it."
			self pathName: entry pathName.
			self checkRequirement ifTrue: [ ^true ].
			"Nope. Don't keep it."
			self pathName: nil ]].
	^ false! !
!Clipboard methodsFor: 'private' stamp: 'jmv 12/19/2024 12:47:24' prior: 16821332!
 extendedClipboardInterface
	"Answer a subinstance of ExtendedClipboardInterface, if present and operational.
	Clipboard default extendedClipboardInterface
	"
	Smalltalk at: #ExtendedClipboardInterface ifPresent: [ :clipboardInterface |
		| interface |
		interface := clipboardInterface current.
		interface isOperational ifTrue: [
			^ interface ]].
	"No operational extended clipboard."
	^nil! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 12/19/2024 12:47:33' prior: 16930271!
               installHaloPreferencesWith: anArray
	^ self sysPreferences 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each | | aColor |
			aColor := Color.
			each fourth do: [ :sel | aColor := aColor perform: sel].
			HaloSpec new 
				horizontalPlacement: each second
				verticalPlacement: each third 
				color: aColor
				iconSymbol: each fifth
				addHandleSelector: each first
				hoverHelp: each sixth])! !
!PreferenceSet class methodsFor: 'sys fonts' stamp: 'jmv 12/19/2024 12:47:47' prior: 16930381!
                        setDefaultFont: fontFamilyName spec: defaultFontsSpec

	defaultFontsSpec do: [ :triplet | | font |
		font := FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font := FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font := font emphasized: triplet third ].
		self sysPreferences at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceSet class methodsFor: 'services' stamp: 'jmv 12/19/2024 12:47:39' prior: 16930474!
                 readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [ | line parts |
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[ | pref value |
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first = $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefts.txt Error' print.
						error print.
						line print ].
				]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6940-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:58:56 pm'!
!WeakActionSequence methodsFor: 'evaluating' stamp: 'jmv 8/2/2016 16:38:32' prior: 17006443!
    valueStartingFrom: startIndex
	"Do the same as my parent, but make sure that all actions that do not 
	give errors are evaluated before resignaling the ones that gave errors 
	(giving the chance to clients to handle them)."

	| each answer |
	startIndex to: self size do: [:index |
		each := self at: index.
		[ answer := each value ]
			on: UnhandledError
			do: [:exc | 
				self valueStartingFrom: index + 1.
				exc pass]].
	^ answer! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/20/2024 16:53:35' prior: 16832933!
             selector: aSelector
	"Set a method's selector.  This is either the penultimate literal,
	 or, if the method has any properties or pragmas, the selector of
	 the MethodProperties stored in the penultimate literal."
	
	self 
		withPropertiesDo: [ :properties | properties selector: aSelector ] 
		ifSelector: [ :selector | | numberOfLiterals |
			(numberOfLiterals := self numLiterals) < 2 ifTrue: [self error: 'insufficient literals to hold selector'].
			self literalAt: numberOfLiterals - 1 put: aSelector]! !
!CompiledMethod methodsFor: 'printing' stamp: 'jmv 12/20/2024 16:54:39' prior: 16833428!
        symbolicLinesDo: aBlock
	"Evaluate aBlock with each of the lines in the symbolic output."

	| aStream pc |
	aStream := ReadWriteStream on: (String new: 64).
	self isQuick ifTrue:
		[self longPrintOn: aStream.
		 aBlock value: 0 value: aStream contents.
		 ^self].

	self primitive ~= 0 ifTrue:
		[self printPrimitiveOn: aStream.
		 aBlock value: 1 value: aStream contents.
		 aStream resetContents].

	pc := self initialPC.
	(InstructionPrinter on: self)
		indent: 0;
		printPC: false; "explorer provides pc anyway"
		printInstructionsOn: aStream
		do:	[:printer :scanner :stream| | line firstLine index |
			line := stream contents allButLast.
			firstLine := line lines first.
			firstLine size < line size ifTrue: [
				line := firstLine, '...'' (continues)'].
			(index := line indexOf: $>) > 0 ifTrue:
				[[(line at: index + 1) isSeparator] whileTrue: [index := index + 1].
				 line := ((line copyFrom: 1 to: index) copyReplaceAll: (String with: Character tab) with: (String new: 8 withAll: Character space)),
						(line copyFrom: index + 1 to: line size)].
			aBlock value: pc value: line.
			pc := scanner pc.
			stream resetContents]! !
!CompiledMethod class methodsFor: 'services' stamp: 'jmv 9/8/2023 17:26:55' prior: 16835350!
       remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true 	].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 						"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !
!RunArray methodsFor: 'enumerating' stamp: 'jmv 12/20/2024 16:57:27' prior: 16942665!
                 runsFrom: start to: stop do: aBlock
	"Evaluate aBlock with all existing runs in the range from start to stop"
	start > stop ifTrue:[^self].
	self at: start setRunOffsetAndValue: [ :firstRun :offset :firstValue|
		| run value index |
		run := firstRun.
		value := firstValue.
		index := start + (runs at: run) - offset.
		[aBlock value: value.
		index <= stop] whileTrue:[
			run := run + 1.
			value := values at: run.
			index := index + (runs at: run)]].
! !
!Set class methodsFor: 'initialization' stamp: 'jmv 12/20/2024 16:58:24' prior: 16950729!
                         quickRehashAllSets  "Set rehashAllSets"
	self withAllSubclassesDo:
		[:c |
			| insts |
			insts := c allInstances.
			(insts isEmpty or: [c = MethodDictionary]) ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock | 1 to: insts size do: [:x | barBlock value: x. (insts at: x) rehash]]]]! !
!Set class methodsFor: 'initialization' stamp: 'jmv 12/20/2024 16:58:13' prior: 16950744!
            rehashAllSets  "Set rehashAllSets"
	self withAllSubclassesDo:
		[:c |
			| insts |
			insts := c allInstances.
			insts isEmpty ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock |
				1 to: insts size do:
					[ :x | barBlock value: x.
					(insts at: x) rehash]]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6941-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h50m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 5:04:02 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 16928604!
            untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:51' prior: 16928625!
   upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream | | element |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 16928685!
                           upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 16928867!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 16929037!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6942-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6942] on 20 December 2024 at 5:34:45 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/20/2024 17:33:07' prior: 50338136!
     untilAnySatisfying: aBlock
1 print.
	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 10/25/2021 11:18:50' prior: 50338145!
                           upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition element answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/20/2024 17:33:18' prior: 50338182!
                               upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
3 print.
	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:33:24' prior: 50338203!
   backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
4 print.
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:33:30' prior: 50338241!
nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
5 print.
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6943-FixNeverendingTestInCI-testUpToTerminator6TerminatedLongRecords-JuanVuletich-2024Dec20-17h33m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6895] on 22 December 2024 at 7:24:31 pm'!
!CompiledMethod commentStamp: 'eem 12/22/2024 19:23:15' prior: 16832642!
        My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields. The pointer fields are used for literals and metadata, and the bytes are used for bytecodes and a variety of encoded informaton such as source code, source code position, etc.  The first part of a CompiledMethod object is pointers, the second part is bytes.  CompiledMethod inherits from ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is a ByteArray.

Instance variables: *indexed* (no named inst vars)

Class variables:
SmallFrame							- the number of stack slots in a small frame Context
LargeFrame							- the number of stack slots in a large frame Context
PrimaryBytecodeSetEncoderClass		- the encoder class that defines the primary instruction set
SecondaryBytecodeSetEncoderClass	- the encoder class that defines the secondary instruction set
	
TThe current format of a CompiledMethod is as follows:

	header (4 or 8 bytes, SmallInteger)
	literals (4 or 8 bytes each, Object, see "The last literal..." below)
	bytecodes  (variable, bytes)
	trailer (variable, bytes)

The header is a SmallInteger (which in the 32-bit system has 31 bits, and in the 64-bit system, 61 bits) in the following format:

	(index 0)		15 bits:	number of literals (#numLiterals)
	(index 15)		  1 bit:	jit without counters - reserved for methods that have been optimized by Sista
	(index 16)		  1 bit:	has primitive
	(index 17)		  1 bit:	whether a large frame size is needed (#frameSize => either SmallFrame or LargeFrame)
	(index 18)		  6 bits:	number of temporary variables (#numTemps)
	(index 24)		  4 bits:	number of arguments to the method (#numArgs)
	(index 28)		  2 bits:	reserved for an access modifier (00-unused, 01-private, 10-protected, 11-public), although accessors for bit 29 exist (see #flag).
	sign bit:			  1 bit:	selects the instruction set, >= 0 Primary, < 0 Secondary (#signFlag)

If the method has a primitive then the first bytecode of the method must be a callPrimitive: bytecode that encodes the primitive index.  This bytecode can encode a primitive index from 0 to 65535.

The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.

While there are disadvantages to this "flat" representation (it is impossible to add named instance variables to CompiledMethodor its subclasses, but it is possible indirectly; see AdditionalMethodState) it is effective for interpreters.  It means that both bytecodes and literals can be fetched directly from a single method object, and that only one object, the method, must be saved and restored on activation and return.  A more natural representation, in which there are searate instance variables for the bytecode, and (conveniently) the literals, requires either much more work on activation and return setting up references to the literals and bytecodes, or slower access to bytecodes and literals, indirecting on each access.

The last literal of a CompiledMethod is reserved for special use by the kernel and/or the virtual machine.  It must either be the methodClassAssociation, used to implement super sends, or nil, if the method is anonymous.

By convention, the penultimate literal is reserved for special use by the kernel. In CompiledMethod instances it must either be the method selector, or an instance of AdditionalMethodState which holds the selector and any pragmas or properties in the method.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6944-CompiledMethodComment-EliotMiranda-2024Dec22-19h23m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6942] on 23 December 2024 at 10:56:59 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 50338271!
          untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 50338318!
   upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 50338339!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 50338377!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6945-6943-again-JuanVuletich-2024Dec23-10h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6945] on 23 December 2024 at 11:04:32 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/22/2022 21:13:39' prior: 50338549!
                 upToAny: aCollection 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
	| element prevPos |
	^self collectionSpecies streamContents: [ :strm |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6946-6943-tweak-JuanVuletich-2024Dec23-11h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6946] on 23 December 2024 at 11:11:28 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:18:25' prior: 50338540!
        untilAnySatisfying: aBlock
	| c |
	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				c := self peek.
				(aBlock value: c) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/19/2022 11:57:58' prior: 50338570!
                 backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		prevCh := $$.
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/23/2022 17:47:39' prior: 50338608!
                          nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator ch done |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6947-Undo6942-JuanVuletich-2024Dec23-11h10m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6947] on 23 December 2024 at 3:20:03 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/23/2024 15:19:46' prior: 16964933!
                        knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !
!Morph methodsFor: 'events-processing' stamp: 'JEC 12/23/2024 09:53:40' prior: 16905820!
         processDropMorph: aDropEvent
	"Handle a dropping morph."
	| aMorph |
	
	aDropEvent wasHandled ifTrue: [ ^self ]. "Do it just once, for one drop destination"
	
	aMorph := aDropEvent contents.
	aDropEvent wasHandled: true.
	aMorph justDroppedInto: self event: aDropEvent.
	self acceptDroppingMorph: aMorph event: aDropEvent.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6948-AddJoelAsKnownAuthor-JuanVuletich-2024Dec23-15h15m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6944] on 23 December 2024 at 10:24:59 am'!
!Morph methodsFor: 'events-processing' stamp: 'JEC 12/23/2024 09:53:40' prior: 50338997!
                 processDropMorph: aDropEvent
	"Handle a dropping morph."
	| aMorph |
	
	aDropEvent wasHandled ifTrue: [ ^self ]. "Do it just once, for one drop destination"
	
	aMorph := aDropEvent contents.
	aDropEvent wasHandled: true.
	aMorph justDroppedInto: self event: aDropEvent.
	self acceptDroppingMorph: aMorph event: aDropEvent.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6949-DropMethodOnNoCategoryFix-JoelEstebanCamera-2024Dec23-09h53m-JEC.001.cs.st----!

'From Cuis7.3 [latest update: #6949] on 24 December 2024 at 10:34:31 am'!
!CodeWindow methodsFor: 'misc' stamp: 'eem 12/24/2024 10:33:48' prior: 16827299!
               getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs
	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"

	| strm array |
	strm := WriteStream on: (array := Array new: queryArgs size + 1).
	strm nextPut: nil.
	strm nextPutAll: queryArgs.

	model selectedMessageName
		ifNotNil:
			[:messageName|
			querySelector numArgs = 1 ifTrue:
				[Symbol
					hasInterned: messageName
					ifTrue:
						[:messageSymbol|
						^queryPerformer perform: querySelector with: messageSymbol]]]
		ifNil:
			[ | selector |
			selector := self request: 'Type selector:' initialAnswer: 'flag:'.
			^ selector isEmpty ifFalse: [
				(Symbol hasInterned: selector
					ifTrue: [ :aSymbol |
						array at: 1 put: aSymbol.
						queryPerformer perform: querySelector withArguments: array])
					ifFalse: [ self inform: 'no such selector']
			]
		].

	self selectMessageAndEvaluate: [:selector |
		array at: 1 put: selector.
		queryPerformer perform: querySelector withArguments: array
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6950-HaveMessageNamesFindSymbolReferences-EliotMiranda-2024Dec24-10h21m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 5:04:02 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 50338666!
untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:51' prior: 50338281!
   upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream | | element |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 50338638!
                           upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 50338676!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 50338715!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6951-6942-AGAIN-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6951] on 27 December 2024 at 9:59:33 am'!
!CompiledMethod methodsFor: 'source code management' stamp: 'eem 12/27/2024 09:55:57' prior: 16834012!
                 messageSendsCount
	"Number of message sends in code.
	A measure of the complexity of code. Alternative to #linesOfCode"

	| count scanner |
	count := 0.
	scanner := InstructionStream on: self.
	scanner scanFor:
		[:x | | selectorOrSelf |
		(selectorOrSelf := scanner selectorToSendOrSelf) == scanner ifFalse:
			[count := count + 1].
		false	"keep scanning"].
	^count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6952-muchFaster-messageSendsCount-EliotEmilioMiranda-2024Dec27-09h55m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6952] on 27 December 2024 at 10:12:34 am'!
!Delay methodsFor: 'private' stamp: 'jmv 12/27/2024 10:11:02' prior: 16846848!
  setDelay: millisecondCount 
	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."

	delayDuration := millisecondCount asInteger! !
!Delay methodsFor: 'private' stamp: 'jmv 12/27/2024 10:11:39' prior: 16846856!
                           setDelay: millisecondCount forSemaphore: aSemaphore
	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."

	delayDuration := millisecondCount asInteger.
	delaySemaphore := aSemaphore.
	beingWaitedOn := false.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6953-delayDuration-mustBeAnInteger-JuanVuletich-2024Dec27-10h08m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6953] on 27 December 2024 at 10:58:19 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/27/2024 10:57:47' prior: 50338745!
  knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6954-AddWeslleymbergAsKnownContributor-JuanVuletich-2024Dec27-10h57m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6947] on 23 December 2024 at 6:47:53 pm'!
!EphemeronFinalizationProcess class methodsFor: 'system startup' stamp: 'wbsl 12/23/2024 18:10:14' prior: 50334406 overrides: 16789354!
                         startUp: resuming
	"resuming ifFalse: [ ^self ]."
	"Must restart even if just continuing after a snapshot"
	self restartFinalizationProcess! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6955-EphemeronProcessRestart-afterSnapshot-WeslleymbergLisboa-2024Dec23-12h24m-wbsl.001.cs.st----!

'From Cuis7.3 [latest update: #6955] on 27 December 2024 at 11:28:57 am'!
!Morph methodsFor: 'geometry testing' stamp: 'RMV 12/27/2024 11:28:39' prior: 16906827!
                   clipsSubmorphsReally
	"Currently only one level of clipping is supported.
	This means that if a morph clipsSubmorphs, then no submorph in its tree can do it.
	This is a current limitation of VectorCanvas"

	self clipsSubmorphs ifFalse: [ ^false ].
	self allOwnersDo: [ :o | o clipsSubmorphs ifTrue: [ ^false ]].
	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6956-typoFix-R.MarkVolkmann-2024Dec27-11h28m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #6950] on 27 December 2024 at 8:51:10 am'!
!CodeWindow methodsFor: 'misc' stamp: 'len 5/20/2020 08:09:08' prior: 50339039!
            getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs
	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"

	| strm array |
	strm := WriteStream on: (array := Array new: queryArgs size + 1).
	strm nextPut: nil.
	strm nextPutAll: queryArgs.

	model selectedMessageName ifNil: [ | selector |
		selector := self request: 'Type selector:' initialAnswer: 'flag:'.
		^ selector isEmpty ifFalse: [
			(Symbol hasInterned: selector
				ifTrue: [ :aSymbol |
					array at: 1 put: aSymbol.
					queryPerformer perform: querySelector withArguments: array])
				ifFalse: [ self inform: 'no such selector']
		]
	].

	self selectMessageAndEvaluate: [:selector |
		array at: 1 put: selector.
		queryPerformer perform: querySelector withArguments: array
	]! !
!CodeWindow methodsFor: 'misc' stamp: 'jmv 12/27/2024 08:50:01' prior: 16827332!
             selectMessageAndEvaluate: aBlock
	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"

	| selector method messages |
	(selector := model selectedMessageName) ifNil: [^ self].
	method := (model selectedClassOrMetaClass ifNil: [^ aBlock value: selector])
		compiledMethodAt: selector
		ifAbsent: nil.
	(method isNil or: [(messages := method messages) isEmpty])
		 ifTrue: [^ aBlock value: selector].
	(messages size = 1 and: [messages includes: selector])
		ifTrue:
			[^ aBlock value: selector].  "If only one item, there is no choice"

	Smalltalk
		showMenuOf: messages
		withFirstItem: selector
		ifChosenDo: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6957-Better-6950-WorkWithOrWithoutRealMethod-JuanVuletich-2024Dec27-08h36m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6957] on 30 December 2024 at 1:04:30 pm'!
!MethodSet methodsFor: 'testing' stamp: 'jmv 12/30/2024 13:04:04' prior: 16902849 overrides: 16826346!
                  isEditingMethod

	^selectedMessage notNil and: [ selectedMessage selector ~~ #Comment ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6958-isEditingMethod-fix-JuanVuletich-2024Dec30-13h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6957] on 30 December 2024 at 1:06:16 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'hlsf 12/30/2024 12:55:18'!
             browseMethodsWithSourceString: aString in: aPackage
	" Browse all methods in aPackage whose source code contains aString as a substring."

	| matchingMethods |
	matchingMethods := Set new.
	aPackage classesDo: [ :aPackageClass |
		(aPackageClass organization classComment
			findString: aString
			startingAt: 1
			caseSensitive: false) > 0 ifTrue: [
				matchingMethods add: (MethodReference class: aPackageClass selector: #Comment) ]].
	aPackage methods do: [ :methodReference |
		(methodReference sourceCode 
			findString: aString
			startingAt: 1
			caseSensitive: false) > 0 ifTrue: [
				matchingMethods add: methodReference ]].
		
	^ self 
		browseMessageList: matchingMethods asArray sort
		name: 'Methods containing ' , aString printString, ' in package: ', aPackage packageName
		autoHighlight: aString
		allOccurrences: true.! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'hlsf 12/30/2024 12:57:55' prior: 16956254!
                findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |
	
	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self codeProvider selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6959-findWithScope-PackageScope-HilaireFernandes-2024Dec30-13h04m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #6959] on 30 December 2024 at 9:56:55 pm'!
!CodeProvider methodsFor: 'testing' stamp: 'jmv 12/30/2024 21:54:06'!
        isEditingExistingMethod

	^self isEditingMethod! !
!Browser methodsFor: 'testing' stamp: 'jmv 12/30/2024 21:54:13' overrides: 50339763!
                        isEditingExistingMethod

	^editSelection = #editMessage! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/30/2024 21:56:51' prior: 50339690!
                               findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |
	
	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self codeProvider selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingExistingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6960-FindWithScope-fix-HernanWilkinson-2024Dec30-21h54m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6960] on 31 December 2024 at 7:01:56 pm'!
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 19:00:05' prior: 16799999!
             classListMenuSpec
	"Spec for the menu and shortcut keys for the class list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Class List' 					false)
		#(10	'New Subclass' 				nil 	model 		makeNewSubclass 					classIcon 		'put a template into the code pane for defining of a subclass of this class')
		#(20	'Copy Class...' 				nil 	model 		copyClass 							copyIcon)
		#(30	'Delete (x)' 					$x 	model 		removeClass 						deleteIcon)
		#(40 	'-----')
		#(50	'Browse Hierarchy (h)' 		$h 	window 	browseHierarchy 					goTopIcon)
		#(60	'Full Browse (b)' 				$b 	window 	browseMethodFull 					editFindReplaceIcon)
		#(70	'Browse Protocol (p)' 			$p 	window 	browseFullProtocol 				spreadsheetIcon)
		#(80	'Browse Package' 			nil 	window 	browsePackage 					packageIcon)
		#(90 	'-----')
		#(100	'File Out' 					nil 	model 		fileOutClass 						fileOutIcon)
		#(110	'File Out (alphabetically)' 		nil 	model 		fileOutClassAlphabetically 			fileOutIcon)
		#(120	'Run Tests (t)' 				$t 	model 		runClassTests 						weatherFewCloudsIcon)
		#(130 	'-----')
		#(140	'Refactorings' 				nil 	nil 			1000 								listAddIcon)
		#(150 	'-----')
		#(160	'Show classes Hierarchically' 	nil model 		enableListClassesHierarchically 	goTopIcon)
		#(170	'Show classes Alphabetically' 	nil model 		enableListClassesAlphabetically 	sendReceiveIcon)
		#(180	'Show Definition' 				nil 	model 		editClass 							editFindReplaceIcon)
		#(190	'Show Comment' 			nil 	model 		editComment 						editFindReplaceIcon)
		#(200 	'-----')
		#(210	'Class References (N)' 		$N 	window 	browseClassRefs 					classIcon)
		#(220 	'-----')
		#(230	'More...' 					nil 	nil 			2000 								listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 							$r 	model 		recent)

		" 'refactorings' SubMenu"
		#(1010	'Rename Class... (R)' 			$R 	model 		renameClass 						saveAsIcon)
		#(1020	'Insert Superclass...' 			nil 	model 		insertSuperclass 					saveAsIcon)
		#(1030 	'-----')
		#(1040	'Add Inst Var...' 				nil 	model 		addInstVar 							listAddIcon)
		#(1050	'Rename Inst Var...' 			nil 	model 		renameInstVar 						saveAsIcon)
		#(1060	'Remove Inst Var...' 			nil 	model 		removeInstVar 						deleteIcon)
		#(1070	'Remove all Unreferenced Inst Var...' nil model 	removeAllUnreferencedInstVar 	deleteIcon)
		#(1080	'Push Up Inst Var...' 			nil 	model 		pushUpInstanceVariable 			goTopIcon)
		#(1090	'Push Down Inst Var...' 		nil 	model 		pushDownInstanceVariable 		goBottomIcon)
		#(1100 	'-----')
		#(1110	'Rename Global...' 			nil 	model 		renameGlobal 						saveAsIcon)

		" 'more' SubMenu"
		#(2010	'Unsent Methods' 			nil 	window 	browseUnusedMethods 			junkIcon 			'browse all methods defined by this class that have no senders')
		#(2020	'Unreferenced inst Vars' 		nil 	window 	showUnreferencedInstVars 		junkIcon 			'show a list of all instance variables that are not referenced in methods')
		#(2030	'Unreferenced class Vars' 		nil 	window 	showUnreferencedClassVars 		junkIcon 			'show a list of all class variables that are not referenced in methods')
		#(2040 	'-----')
		#(2050	'Sample instance' 			nil 	window 	makeSampleInstance 				instanceIcon 		'give me a sample instance of this class, if possible')
		#(2060	'Inspect instances' 			nil 	window 	inspectInstances 					inspectIcon 		'open an inspector on all the extant instances of this class')
		#(2070	'Inspect subinstances' 		nil 	window 	inspectSubInstances 				inspectIcon 		'open an inspector on all the extant instances of this class and of all of its subclasses')
		#(2080 	'-----')
		#(2090	'Create inst var accessors' 	nil 	model 		createInstVarAccessors 			sendReceiveIcon 	'compile instance-variable access methods for any instance variables that do not yet have them')
	)! !
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 18:52:17' prior: 16800118!
                    messageCatListMenuSpec
	"Spec for the menu and shortcut keys for the method categories list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message Categories' 			false)
		#(5		'Browse Package (p)' 				$p 	window 	browsePackage 						packageIcon)
		#(6		'-----')
		#(10	'File Out (o)' 						$o 	model 		fileOutMessageCategories 				fileOutIcon)
		#(20 	'-----')
		#(30	'Reorganize (r)' 					$r 	model 		editMessageCategories 				sendReceiveIcon)
		#(40	'Alphabetize (a)' 					$a 	model 		alphabetizeMessageCategories 		fontXGenericIcon)
		#(50	'Remove empty Categories (e)' 	$e 	model 		removeEmptyCategories 				listRemoveIcon)
		#(60	'Categorize all Uncategorized (c)' 	$c 	model 		categorizeAllUncategorizedMethods 	packageIcon)
		#(70	'New Category... (n)' 				$n 	model 		addCategory 							newIcon)
		#(80	'New extension Category... (N)' 	$N 	model 		addExtensionCategory 					listAddIcon)
		#(90 	'-----')
		#(100	'Refactorings' 					nil 	nil 			1000 									listAddIcon)
		#(110	'Rename... (R)' 					$R 	model 		renameCategory 						saveAsIcon)
		#(120	'Remove (x)' 					$x 	model 		removeMessageCategory 				deleteIcon)
		#(130 	'-----')
		#(140	'Run Tests (t)' 					$t 	model 		runMessageCategoryTests 			weatherFewCloudsIcon)

		" 'Refactorings' SubMenu"
		#(1010	'Push Up' 									nil 	model 	pushUpCategorySelectors 							goTopIcon)
		#(1020	'Add in Superclass as subclassResponsibility' 	nil	model 	addCategoryAsSubclassResponsibilitySelectors 	goTopIcon)
		#(1030	'Push Down to Subclasses' 					nil 	model 	pushDownCategorySelectorsToSubclasses 		goBottomIcon)
		#(1040	'Push Down to one Subclass' 					nil 	model 	pushDownCategorySelectorsToOneSubclass 		goBottomIcon)
	)! !
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 19:00:12' prior: 16800174!
                           messageListMenuSpec
	"Spec for the menu and shortcut keys for the messages list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message List' 						false)
		#(10	'Browse Full (b)' 							$b 	window 	browseMethodFull 							editFindReplaceIcon)
		#(20	'Browse Hierarchy (h)' 					$h 	window 	browseHierarchy 							goTopIcon)
		#(30	'Browse Method (O)' 						$O 	window 	openSingleMessageBrowser 				scriptIcon)
		#(35	'Browse Package (p)' 						$p 	window 	browsePackage 							packageIcon)
		#(40 	'-----')
		#(50	'File Out' 								nil 	model 		fileOutMessage 							fileOutIcon)
		#(60	'Run Test (t)' 							$t 	model 		runMethodTest 							weatherFewCloudsIcon)
		#(70	'Debug Test (r)' 							$r 	model 		debugMethodTest 							weatherFewCloudsIcon)
		#(80	'Inspect CompiledMethod' 				nil 	model 		inspectCompiledMethod 					exploreIcon)
		#(90 	'-----')
		#(100	'Refactorings' 							nil 	nil 			1000 										listAddIcon)
		#(110	'Senders of... (n)' 						nil 	window 	browseSendersOfMessages 				mailForwardIcon)
		#(120	'Implementors of... (m)' 					nil 	window 	browseImplementorsOfMessages 			developmentIcon)
		#(130	'Inheritance (i)' 							$i 	window 	methodInheritance 						goDownIcon)
		#(140	'Versions (v)' 							$v 	window 	browseVersions 							clockIcon)
		#(150 	'-----')
		#(160	'Remove Method (x)' 						$x 	model 		removeMessage 							deleteIcon)
		#(170	'Remove Method in Hierarchy' 			nil 	model 		removeMessageInHierarchy 				deleteIcon)
		#(180	'More...' 								nil 	nil 			2000 										listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 										$m 	window 	browseImplementors)
		#(992	nil 										$n 	window 	browseSenders)
		#(993	nil 										$c 	model 		copySelector)

		" 'refactorings' SubMenu"
		#(1010	'Rename... (R)' 							$R 	model 		renameSelector 							saveAsIcon)
		#(1020	'Change keyword Order...' 				nil 	model 		changeKeywordOrder 						sendReceiveIcon)
		#(1030	'Add Parameter... (A)' 					$A 	model 		addParameter 								listAddIcon)
		#(1040	'Remove Parameter... (S)' 				$S 	model 		removeParameter 							listRemoveIcon)
		#(1050 	'-----')
		#(1060	'Inline Method... (F)' 						$F 	model 		inlineMethod 								saveAsIcon)
		#(1070	'Move to Instance/Class Method' 			nil 	model 		moveToInstanceOrClassMethod 			changesIcon)
		#(1080	'Push Up' 								nil 	model 		pushUpSelector 							goTopIcon)
		#(1090	'Add in Superclass as subclassResponsibility' nil model 		addAsSubclassResponsibilitySelector 		goTopIcon)
		#(1100	'Push Down to Subclasses' 				nil 	model 		pushDownSelectorToSubclasses 			goBottomIcon)
		#(1110	'Push Down to One Subclass' 				nil 	model 		pushDownSelectorToOneSubclass 			goBottomIcon)

		" 'more' SubMenu"
		#(2010	'Local Senders of...' 						nil 	window 	browseLocalSendersOfMessages 			mailForwardIcon)
		#(2020	'Local Implementors of...' 					nil 	window 	browseLocalImplementorsOfMessages 	classIcon)
		#(2030 	'-----')
		#(2040	'Sample Instance' 						nil 	window 	makeSampleInstance 						instanceIcon)
		#(2050	'Inspect Instances' 						nil 	window 	inspectInstances 							inspectIcon)
		#(2060	'Inspect Subinstances' 					nil 	window 	inspectSubInstances 						inspectIcon)
		#(2070 	'-----')
		#(2080	'Change Category...' 						nil 	model 		changeCategory 							saveAsIcon)
		#(2090	'Select method Category (C)' 				$C 	model 		showHomeCategory 						editFindReplaceIcon)
		#(2100	'Change sets with this Method' 			nil 	window 	findMethodInChangeSets 					changesIcon)
		#(2110	'Revert to previous Version' 				nil 	model 		revertToPreviousVersion 					undoIcon)
	)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6961-MenuCaseConsistency-HernanWilkinson-2024Dec31-18h44m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6961] on 1 January 2025 at 10:28:41 am'!
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 1/1/2025 10:27:43' prior: 16971764!
                  copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak project. 1997-2025.
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2025.'.! !
!Utilities class methodsFor: 'default desktop' stamp: 'jmv 1/1/2025 10:28:19' prior: 16997398!
 defaultTextEditorContents
	^ ('
', 
('Cuis Smalltalk

' centered blue pointSize: FontFamily defaultPointSize * 3),
('
"Yay, Juan.  You GO, guy!! ...a great example of malleable software (and a clever mind) at work."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Dan Ingalls
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I like it... It''s nice and clean and simple and pretty. Nice stuff!!"
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Alan Kay
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I think you have a very elegant design aesthetic."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('John Maloney
'italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
'

',
'Cuis is a modern, Open Source, multiplatform, Smalltalk-80 system.


',
'Cuis is:

' bold,
'    - Small
    - Clean
    - Appropriable
' blue,
'

Additionally, Cuis is:

' bold, 
'    - Open Source
    - Multiplatform
' blue,
'
 
Like other Smalltalk systems, Cuis is also:

' bold, 
'    - A complete development environment written in itself
    - A pure, dynamic Object Oriented language
' blue,
'

Cuis assumes very little on the underlying platform, and this lets it run out-of-the-box on Windows, macOS, Linux, ChromeOS and WebBrowsers. Cuis shares the [OpenSmalltalk Virtual Machine] (http://www.opensmalltalk.org) with Squeak, Pharo and Newspeak.

What sets Cuis apart from the other members of the Squeak family is the focus on Smalltalk-80 and an active attitude towards system complexity:

Unbound complexity growth, together with development strategies focused only in the short term, are the worst long term enemies of all software systems. As systems grow older, they usually become more complex. New features are added as layers on top of whatever is below, sometimes without really understanding it, and almost always without modifying it. Complexity and size grow without control. Evolution slows down. Understanding the system becomes harder every day. Bugs are harder to fix. Codebases become huge for no clear reason. At some point, the system can''t evolve anymore and becomes "legacy code".

Complexity puts a limit to the level of understanding of the system a person might reach, and therefore limits the things that can be done with it. Dan Ingalls says all this in ["Design Principles Behind Smalltalk"] (http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html). Even if you have already done so, please go and read it again!!

Cuis Smalltalk is our attempt at this challenge. Furthermore, we believe we are doing something else that no other Smalltalk, commercial or open source, does. We attempt to give the true Smalltalk-80 experience, and keep Smalltalk-80 not as legacy software of historic significance, but as a live, evolving system. We feel we are the keepers of the Smalltalk-80 heritage, and enablers of the Dynabook experience.

As Cuis evolves, we keep on these values. Every update, be it a bug fix or a feature enhancement, is reviewed carefully to avoid adding unneeded complexity to the system. Every opportunity to remove unneeded complexity is followed. As we go, features are enhanced, and any reported bugs fixed. We also adopt selected enhancements from Squeak and Pharo, and share our work with the wider Smalltalk community.


' justified,
'License
' bold,
'
Cuis is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . Any contribution submitted for incorporation into or for distribution with Cuis shall be presumed subject to the same license.

Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982
Copyright (c) Apple Computer, Inc. 1985-1996
Copyright (c) Contributors to Squeak project. 1997-2025
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2025')! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6962-UpdateCopyrightNotice-JuanVuletich-2025Jan01-10h27m-jmv.001.cs.st----!

----QUIT----(2 January 2025 10:23:12) Cuis7.3-6962.image priorSource: 206!

----STARTUP---- (17 January 2025 10:30:48) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-6962.image!


'From Cuis7.3 [latest update: #6962] on 2 January 2025 at 4:01:10 pm'!

Random subclass: #XorShiftRandom
	instanceVariableNames: 'a b c mask last'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!classDefinition: #XorShiftRandom category: #'Kernel-Numbers' stamp: 'Install-6963-XorShiftRandom-JuanVuletich-2025Jan02-16h00m-jmv.001.cs.st 1/17/2025 10:30:48'!
Random subclass: #XorShiftRandom
	instanceVariableNames: 'a b c mask last'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!
!XorShiftRandom commentStamp: '<historical>' prior: 0!
          I implement XorShift pseudo random number generators invented by George Marsaglia.
See https://en.wikipedia.org/wiki/Xorshift . Paper at https://www.jstatsoft.org/article/view/v008i14/916
Most implementations hardcode the a, b, c parameters, and work either on 32 or 64 bit space.
This one allows chosing them. Still, a and c are right shifts and b is a left shift.!
!XorShiftRandom methodsFor: 'accessing' stamp: 'jmv 1/2/2025 14:51:42'!
         nextInteger
	last := last bitXor: (last bitShift: a).
	last := last bitXor: ((last bitShift: b) bitAnd: mask).
	last := last bitXor: (last bitShift: c).
	^last! !
!XorShiftRandom methodsFor: 'initialization' stamp: 'jmv 1/2/2025 14:58:45'!
                a: firstShift b: secondShift c: thirdShift bits: bitsSize

	(firstShift < 0 and: [ secondShift > 0 and: [ thirdShift < 0 ]]) ifFalse: [
		self error: 'Invalid XorShift parameters' ].

	a := firstShift.
	b := secondShift.
	c := thirdShift.
	mask := (2 raisedToInteger: bitsSize) - 1.
	last := 1 bitAnd: mask. "If any other value is used, ensure it is not larger than mask"! !
!XorShiftRandom methodsFor: 'initialization' stamp: 'jmv 1/2/2025 14:58:05' overrides: 16936573!
        seed: aNumber
	last := aNumber.
	mask ifNotNil: [ last := last bitAnd: mask ].! !
!XorShiftRandom methodsFor: 'private' stamp: 'jmv 1/2/2025 15:48:40' overrides: 16936565!
                    nextChunkBits
	^self nextInteger! !
!XorShiftRandom methodsFor: 'private' stamp: 'jmv 1/2/2025 15:49:55' overrides: 16936569!
  nextChunkSize
	^(mask + 1) log2! !
!XorShiftRandom class methodsFor: 'instance creation' stamp: 'jmv 1/2/2025 15:45:18'!
       a: firstShift b: secondShift c: thirdShift bits: bitsSize
	^self basicNew a: firstShift b: secondShift c: thirdShift bits: bitsSize! !
!XorShiftRandom class methodsFor: 'instance creation' stamp: 'jmv 1/2/2025 15:51:58' overrides: 16936587!
               seed: anInteger
	| answer |
	answer := self a: -2 b: 7 c: -3 bits: 22.
	answer seed: anInteger.
	^answer! !
!XorShiftRandom class methodsFor: 'visualizations' stamp: 'jmv 1/2/2025 15:01:01'!
 display22BitsBlackWhite
	"
	self display22BitsBlackWhite
	"
	| bits f generator h w |
	generator := XorShiftRandom a: -2 b: 7 c: -3 bits: 22.
	w := 2048.
	h := 2048.
	bits := ByteArray new: w*h // 8.
	f := Form extent: w@h depth: 1 bits: bits.
	bits atAllPut: 0.
	(2 raisedTo: 22)-1 timesRepeat: [
		bits bitAt: generator nextInteger put: 1.
		Random next > 0.9999 ifTrue: [
			f display. Display forceToScreen ]].
	f display. Display forceToScreen.! !
!XorShiftRandom class methodsFor: 'visualizations' stamp: 'jmv 1/2/2025 15:02:23'!
        display22BitsColor
	"
	self display22BitsColor
	"
	| bits f generator h w |
	generator := XorShiftRandom a: -2 b: 7 c: -3 bits: 22.
	w := 512.
	h := 512.
	bits := ByteArray new: w*h *16 // 8.
	f := Form extent: w@h depth: 16 bits: bits.
	f fillColor: Color black.
	(2 raisedTo: 22)-1 timesRepeat: [
		bits bitAt: generator nextInteger put: 1.
		Random next > 0.9999 ifTrue: [
			f display. Display forceToScreen ]].
	f display. Display forceToScreen.! !
!XorShiftRandom class methodsFor: 'parameter search' stamp: 'jmv 1/2/2025 15:07:58'!
     lookFor22BitCandidateParameters
	"XorShift pseudo Random Number Generator. See https://en.wikipedia.org/wiki/Xorshift
	IdentityHash is a 22 bit number. It is easy to find documented parameters for XorShift covering the whole 32 and 64 bit spaces.
	1. But we need to cover the 22 bit space. The following script lists a set of such parameters.
	Explore parameter space to find (a, b, c) parameters that generate all possible hashes (implying a period = hashMask).
	self lookFor22BitCandidateParameters
	"
	| generator value differentValues expectedDifferentValues |
	expectedDifferentValues := (2 raisedTo: 22) - 1.
	-9 to: -1 do: [ :a |
		1 to: 8 do: [ :b |
			-7 to: -1 do: [ :c |
				generator := XorShiftRandom a: a b: b c: c bits: 22.
				differentValues := Set new.
				[
					value := generator nextInteger.
					differentValues includes: value ]
				whileFalse: [
					differentValues add: value ].
				differentValues size = expectedDifferentValues ifTrue: [
					{a. b. c} print ]]]].! !
!XorShiftRandom class methodsFor: 'parameter search' stamp: 'jmv 1/2/2025 15:39:29'!
      pickBest22BitHashParameters
	"When using this RNG for generating hashes, the next problem we face is that generally we'll not be using the full hash.
	For smaller collections, only the rest of the division by the collection size is actually used.
	For each of the candidates found in #lookFor22BitCandidateParameters, try the rest of the division by 2^k (i.e. take AND with a smaller 'evaluatedMask' and see how many distinct hashes of this size can be generated.
	List those than yield at least half of the full k bits space.
	self pickBest22BitHashParameters
	"
	| candidates |
	candidates := {
		#(-9 5 -7).
		#(-9 5 -3).
		#(-7 7 -3).
		#(-5 3 -2).
		#(-3 7 -7).
		#(-3 7 -2).
		#(-2 3 -5).
		#(-2 7 -3).
	}.
	candidates do: [ :abc |
		| fractions |
		fractions := OrderedCollection new.
		1 to: 21 do: [ :usedMaskSize |
				| evaluatedMask generator hash hashes |
				evaluatedMask := (2 raisedTo: usedMaskSize) - 1.
				generator := XorShiftRandom a: abc first b: abc second c: abc third bits: 22.
				hashes := Set new.
				evaluatedMask timesRepeat: [
					hash := generator nextInteger bitAnd: evaluatedMask.
					hashes add: hash ].
				fractions add: (hashes size / evaluatedMask asFloat) ].
			(fractions min > 0.5 ) ifTrue: [
				{abc. fractions min. fractions average} print ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6963-XorShiftRandom-JuanVuletich-2025Jan02-16h00m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:22:57 pm'!
!WorldMorph methodsFor: 'canvas' stamp: 'jmv 1/3/2025 16:22:52' prior: 17008987!
                          recordDamagedRect: damageRect for: aMorph

	damageRect hasPositiveExtent ifFalse: [ ^self ].

	damageRecorder ifNotNil: [
		damageRecorder recordInvalidRect: damageRect for: aMorph ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6964-recordDamageRect-tweak-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:40:41 pm'!
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:39:08' overrides: 16906216!
                               extentChanged: oldExtent
	"Our extent changed.
	- Reposition adjusters
	- Resize our layoutMorph"

	| h thickness w cornerExtent wh ww pos halfThickness |
	thickness := self borderWidth.
	halfThickness := thickness * 0.5.
	cornerExtent := thickness * 5.
	ww := extent x.
	wh := extent y.
	w := ww - cornerExtent - cornerExtent.
	h := wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) position: cornerExtent@halfThickness extent: w@0.
	(adjusters at: #bottomAdjuster) position: cornerExtent@(wh-halfThickness) extent: w@0.
	(adjusters at: #leftAdjuster) position: halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #rightAdjuster) position: ww-halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #topLeftAdjuster) position: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) position: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) position: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) position: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos := borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			position: pos
			extent: extent - pos - borderWidth ].! !

SystemWindow removeSelector: #layoutSubmorphs!

!methodRemoval: SystemWindow #layoutSubmorphs stamp: 'Install-6965-SystemWindows-dontLayoutButAdjustOnExtentChange-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st 1/17/2025 10:30:48'!
layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww pos halfThickness |
	thickness := self borderWidth.
	halfThickness := thickness * 0.5.
	cornerExtent := thickness * 5.
	ww := extent x.
	wh := extent y.
	w := ww - cornerExtent - cornerExtent.
	h := wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) position: cornerExtent@halfThickness extent: w@0.
	(adjusters at: #bottomAdjuster) position: cornerExtent@(wh-halfThickness) extent: w@0.
	(adjusters at: #leftAdjuster) position: halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #rightAdjuster) position: ww-halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #topLeftAdjuster) position: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) position: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) position: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) position: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos := borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			position: pos
			extent: extent - pos - borderWidth ].

	self layoutNeeded: false.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6965-SystemWindows-dontLayoutButAdjustOnExtentChange-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:53:24 pm'!
!BoxMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:50:57' overrides: 16906216!
                   extentChanged: oldExtent
	"Our extent changed. oldExtent is provided in case it is useful."! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:49:14' overrides: 50340611!
         extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:42:25' overrides: 16907322!
                               layoutSubmorphsIfNeeded
	"Recompute the layout if necessary."

	self isLayoutNeeded ifTrue: [
		self layoutSubmorphs ].! !
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:42:37' prior: 16907322!
                         layoutSubmorphsIfNeeded
	"Recompute the layout if necessary.
	NOP by default"! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:51:11' prior: 16924804 overrides: 50340611!
                              extentChanged: oldExtent
	"Our extent changed."

	super extentChanged: oldExtent.
	icon ifNotNil: [
		magnifiedIcon := nil ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:51:49' prior: 16923048 overrides: 50340611!
                       extentChanged: oldExtent
	"Our extent changed."

	super extentChanged: oldExtent.
	self buildMagnifiedBackgroundImage.! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 1/3/2025 16:46:43' prior: 16892709!
                    updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			owningLayout layoutSubmorphs ].! !

Morph removeSelector: #extentChanged:!

!methodRemoval: Morph #extentChanged: stamp: 'Install-6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st 1/17/2025 10:30:48'!
extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.!

Morph removeSelector: #layoutSubmorphs!

!methodRemoval: Morph #layoutSubmorphs stamp: 'Install-6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st 1/17/2025 10:30:48'!
layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."
	"Only specific subclasses do layout. They redefine this method.
	Remember to call super, or set layoutNeeded ivar to false!!"

	self layoutNeeded: false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 5:01:41 pm'!
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:55:32' overrides: 16907368!
       someSubmorphPositionOrExtentChanged
	"Some submorph changed at any nested level.
	Must layout submorphs again."

	super someSubmorphPositionOrExtentChanged.
	self layoutNeeded: true.! !
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:55:41' prior: 16907368!
                          someSubmorphPositionOrExtentChanged
	"Some submorph changed at any nested level."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 1/3/2025 17:00:00' prior: 16891319!
                        layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: [].
	
	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ].

	self layoutNeeded: false.! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:57:10' prior: 16874978 overrides: 16926593!
                      someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self updateScrollBarsBounds! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:57:29' prior: 16925354 overrides: 16926593!
      someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self updateScrollBarsBounds! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6967-OnlyLayoutMorphDoLayout-JuanVuletich-2025Jan03-16h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 5:11:13 pm'!
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 17:11:04' prior: 50340703!
                           someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Some Morph classes need to adjust for that."! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:19' prior: 50340694 overrides: 50340756!
                       someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	self layoutNeeded: true.! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:24' prior: 16926593 overrides: 50340756!
   someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	scroller ifNotNil: [ | scrollerLocation doIt |
		doIt := false.
		scroller hasVariableExtent ifTrue: [
			theScrollerExtent = scroller extentInOwner ifFalse: [
				theScrollerExtent := scroller extentInOwner.
				doIt := true ]].
		scrollerLocation := scroller location.
		scrollerScale = scrollerLocation scale ifFalse: [
			scrollerScale := scrollerLocation scale.
			doIt := true ].
		scrollerRadians = scrollerLocation radians ifFalse: [
			scrollerRadians := scrollerLocation radians.
			doIt := true ].
		doIt ifTrue: [ self setScrollDeltas ]].! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:28' prior: 50340729 overrides: 50340772!
                   someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Scrollbars are likely affected."

	self updateScrollBarsBounds! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:33' prior: 50340739 overrides: 50340772!
                              someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Scrollbars are likely affected."

	self updateScrollBarsBounds! !
!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 1/3/2025 17:09:38' prior: 16882626 overrides: 50340756!
                             someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	textComposition ifNotNil: [ 
		textComposition composeAll.
		self fit.
		self selectionChanged ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6968-someSubmorphPositionOrExtentChanged-justOneLevel-JuanVuletich-2025Jan03-17h01m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6968] on 6 January 2025 at 3:21:23 pm'!
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:17:20'!
 coreMethodsDo: aBlock
	self classesDo: [ :cls |
		self coreMethodsOf: cls do: aBlock.
		self coreMethodsOf: cls class do: aBlock ].! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:32:58'!
                      extensionMethodsDo: aBlock
	"Include both class and instance methods we define, for classes we don't define."

	self externalClasses do: [ :classOrMetaClass |
		(self extensionCategoriesForClass: classOrMetaClass) do: [ :cat |
			self methodsInCategory: cat ofClass: classOrMetaClass do: [ :m |
				aBlock value: m ]]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:35:34'!
                           methodsDo: aBlock
	self coreMethodsDo: [ :methodRef |
		methodRef isValid ifTrue: [ aBlock value: methodRef ]].
	self extensionMethodsDo: [ :methodRef |
		methodRef isValid ifTrue: [ aBlock value: methodRef ]].! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:36:49'!
                        extensionMethodCount

	| sum |
	sum := 0.
	self extensionMethodsDo: [ :each |
		sum := sum + 1 ].
	^sum! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:25:16'!
   methodCount

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + 1 ].
	^sum! !
!CodePackageList methodsFor: 'accessing' stamp: 'jmv 1/6/2025 12:37:41' prior: 16824930!
              summary

	| count |
	selection ifNil: [ ^'' ].
	^ String streamContents: [ :strm |
		| methods  linesOfCode |
		strm
			nextPutAll: 'Package: ';
			nextPutAll: selection packageName;
			nextPutAll: ' -- ';
			nextPutAll: selection sourceSystem.
		strm nextPutAll: ' -- Number of system categories '.
		selection systemCategories size printOn: strm.
		strm nextPutAll: '.'.
		strm nextPutAll: ' -- Number of classes: '.
		count := 0.
		selection classesDo: [ :cls | count := count + 1 ].
		count printOn: strm.
		strm nextPutAll: '. Number of extension methods: '.
		selection extensionMethodCount printOn: strm.
		strm nextPutAll: '. Total number of methods: '.
		methods := selection methodCount.
		methods printOn: strm.
		strm nextPutAll: '. Total lines of code: '.
		linesOfCode := selection linesOfCode.
		linesOfCode printOn: strm.
		strm nextPutAll: ' ('.
		linesOfCode / (methods asFloat max: 1.0) printOn: strm fractionDigits: 2.
		strm nextPutAll: ' per method)'.
		strm nextPutAll: '. Total message sends: '.
		linesOfCode := selection messageSendsCount.
		linesOfCode printOn: strm ]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:20:46' prior: 16823841!
  coreMethods
	^Array streamContents: [ :strm |
		self coreMethodsDo: [ :methodRef |
			strm nextPut: methodRef ]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:34:04' prior: 16823862!
                         extensionMethods
	"Include both class and instance methods we define, for classes we don't define."
	^Array streamContents: [ :stream |
		self extensionMethodsDo: [ :methodRef |
			stream nextPut: methodRef ]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:39:48' prior: 16823876!
                        methods

	^Array streamContents: [ :strm |
		self extensionMethodsDo: [ :methodRef |
			methodRef isValid ifTrue: [ strm nextPut: methodRef ]].
		self coreMethodsDo: [ :methodRef |
			methodRef isValid ifTrue: [ strm nextPut: methodRef ]]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:29:01' prior: 16823881!
                          selectors

	^ Array streamContents: [ :strm |
		self methodsDo: [ :ea | strm nextPut: ea methodSymbol ]]! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 1/6/2025 12:27:34' prior: 16823992!
 includesAnyCode
	self classesDo: [ :cls |
		^true ].
	self methodsDo: [ :cls |
		^true ].
	^false! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:24:29' prior: 16824109!
                         linesOfCode
	"An approximate measure of lines of code.
	Does not includes comments, or excludes blank lines.
	See comment at CompiledMethod >> #linesOfCode"

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + each compiledMethod linesOfCode ].
	^sum! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:27:02' prior: 16824120!
                      messageSendsCount
	"See comment at CompiledMethod >> #messageSendsCount"

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + each compiledMethod messageSendsCount ].
	^sum! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 1/6/2025 12:36:13' prior: 16824447!
     register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	| any base |
	self installedPackages at: aCodePackage packageName put: aCodePackage.

	"Anything that now belongs in this package, was moved out of the base system!!"
	base := ChangeSet changeSetForBaseSystem.
	any := false.
	aCodePackage classesDo: [ :cls |
		any := true.
		base noteClassMoveToOtherPackage: cls ].
	aCodePackage extensionMethodsDo: [ :methodReference |
		methodReference isValid ifTrue: [
			any := true.
			base
				noteMethodMoveToOtherPackage: methodReference selector
				forClass: methodReference actualClass ]].
	any ifTrue: [
		aCodePackage hasUnsavedChanges: true ].

	self triggerEvent: #installedPackagesChanged! !

CodePackage removeSelector: #coreMethodsForClass:!

!methodRemoval: CodePackage #coreMethodsForClass: stamp: 'Install-6969-CodePackage-refactor-JuanVuletich-2025Jan06-15h18m-jmv.001.cs.st 1/17/2025 10:30:48'!
coreMethodsForClass: aClass
	^ (aClass selectors difference:
		((self foreignExtensionMethodsForClass: aClass) collect: [:r | r methodSymbol]))
			asArray collect: [:sel | self referenceForMethod: sel ofClass: aClass]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6969-CodePackage-refactor-JuanVuletich-2025Jan06-15h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6962] on 4 January 2025 at 9:03:45 am'!
!CodeWindow methodsFor: 'GUI building' stamp: 'RMV 1/4/2025 09:01:58' prior: 16826573!
                       buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph := (TextModelMorph
		textProvider: model
		textGetter: #annotation) emptyTextDisplayMessage: 'Class or method annotation (not selected?)'.
	aTextMorph disableEditing.
	model when: #annotationChanged send: #refetch to: aTextMorph model.
	model when: #decorateButtons send: #decorateButtons to: self.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6970-DisableEditingInAnnotationsPane-MarkVolkmann-2025Jan04-09h01m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #6970] on 6 January 2025 at 6:54:34 pm'!
!FinalizationRegistry methodsFor: 'removing' stamp: 'jmv 1/6/2025 18:47:15' overrides: 16847673!
        remove: anObject
	"Does NOT run finalization."
	self removeKey: anObject! !
!FinalizationRegistry methodsFor: 'removing' stamp: 'jmv 1/6/2025 18:47:19' overrides: 16847677!
                   remove: anObject ifAbsent: exceptionBlock
	"Does NOT run finalization."
	self removeKey: anObject ifAbsent: exceptionBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6971-FinalizationRegistry-remove-removeifAbsent-JuanVuletich-2025Jan06-18h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6970] on 6 January 2025 at 4:23:28 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/6/2025 16:23:07' prior: 50339273!
    knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jpb' 						'Josef Philip Bernhart')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6972-AddJosefAsKnownAuthor-JuanVuletich-2025Jan06-16h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6971] on 8 January 2025 at 5:42:23 pm'!

Ephemeron removeSelector: #container!

!methodRemoval: Ephemeron #container stamp: 'Install-6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st 1/17/2025 10:30:48'!
container
	"Answer the Dictionary containing the receiver, if any."
	^container!

Ephemeron removeSelector: #isEphemeron!

!methodRemoval: Ephemeron #isEphemeron stamp: 'Install-6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st 1/17/2025 10:30:48'!
isEphemeron
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6973] on 10 January 2025 at 10:02:05 am'!

Smalltalk renameClassNamed: #WeakSet as: #OldWeakSet!

!classRenamed: #WeakSet as: #OldWeakSet stamp: 'Install-6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st 1/17/2025 10:30:48'!
Smalltalk renameClassNamed: #WeakSet as: #OldWeakSet!

Smalltalk renameClassNamed: #WeakIdentitySet as: #OldWeakIdentitySet!

!classRenamed: #WeakIdentitySet as: #OldWeakIdentitySet stamp: 'Install-6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st 1/17/2025 10:30:48'!
Smalltalk renameClassNamed: #WeakIdentitySet as: #OldWeakIdentitySet!
!WorldMorph methodsFor: 'errors on draw' stamp: 'jmv 1/10/2025 10:01:18' prior: 17009171!
                  removeAllKnownFailing
	drawingFailingMorphs do: [ :m | m redrawNeeded ].
	drawingFailingMorphs := OldWeakIdentitySet new.
! !
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 1/10/2025 10:01:18' prior: 17009314 overrides: 16832614!
                    initialize

	super initialize.
	activeHand := HandMorph new.
	damageRecorder := DamageRecorder new.
	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.
	lastAlarmTime := 0.
	deferredUIMessages := SharedQueue new.
	drawingFailingMorphs := OldWeakIdentitySet new.
	pause := 20.
	lastCycleTime := Time localMillisecondClock.
	lastCycleHadAnyEvent := false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6973] on 10 January 2025 at 10:03:16 am'!

Set removeSelector: #withArray:!

!methodRemoval: Set #withArray: stamp: 'Install-6975-cleanup-JuanVuletich-2025Jan10-10h02m-jmv.004.cs.st 1/17/2025 10:30:48'!
withArray: anArray
	"private -- for use only in copy"
	array := anArray!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6975-cleanup-JuanVuletich-2025Jan10-10h02m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6976] on 12 January 2025 at 9:41:18 am'!
!Set methodsFor: 'lookup' stamp: 'jmv 1/10/2025 10:48:11'!
                     lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	^ array at: (self findElementOrNil: anObject).! !
!Dictionary methodsFor: 'testing' stamp: 'jmv 1/10/2025 10:48:44' overrides: 50341414!
              lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	self do: [:each | anObject = each ifTrue: [^each]].
	^nil! !
!Set methodsFor: 'lookup' stamp: 'jmv 1/10/2025 10:49:13' prior: 16950673 overrides: 16828650!
                           includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!OldWeakSet methodsFor: 'public' stamp: 'jmv 1/10/2025 10:49:49' prior: 17007377 overrides: 50341431!
 includes: anObject 
	^ (self lookup: anObject) ~~ flag! !

Dictionary removeSelector: #includes:!

!methodRemoval: Dictionary #includes: stamp: 'Install-6976-Refactor-JuanVuletich-2025Jan12-09h40m-jmv.004.cs.st 1/17/2025 10:30:48'!
includes: anObject 
	self do: [:each | anObject = each ifTrue: [^true]].
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6976-Refactor-JuanVuletich-2025Jan12-09h40m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6976] on 12 January 2025 at 9:46:33 am'!
!SymbolSet methodsFor: 'lookup' stamp: 'jmv 1/10/2025 11:35:59'!
     add: anObject
	"Include anObject as one of the receiver's elements, but only if
	not already present. Answer anObject."
	
	| hash |
	hash := anObject hash.
	(self basicLookup: anObject withHash: hash) ifNil: [
		self basicAdd: anObject withHash: hash ].
	^anObject! !
!SymbolSet methodsFor: 'lookup' stamp: 'jmv 1/10/2025 11:54:12'!
                   lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it."
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock value.
		self basicAdd: newObject withHash: newObject hash.
		newObject ].! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 1/10/2025 11:53:15' prior: 16962895!
  intern: aStringOrSymbol

	^self accessProtect critical:
		[
			Symbols lookup: aStringOrSymbol ifAbsentAddFrom:
				[
					| preferByteStringForAscii |
					aStringOrSymbol isSymbol
						ifTrue: [ aStringOrSymbol ]
						ifFalse: [
							preferByteStringForAscii := aStringOrSymbol.
							(aStringOrSymbol isUnicodeString and: [ aStringOrSymbol isAscii ])
								ifTrue: [preferByteStringForAscii := aStringOrSymbol asByteString].
							preferByteStringForAscii class symbolClassToUse basicFromString: preferByteStringForAscii ].
				]
			].! !
!SymbolSet methodsFor: 'private' stamp: 'jmv 1/10/2025 11:16:10' prior: 16963096!
        rehashSymbolClass: aClass
"quisiera eliminar"
	aClass allInstances do:
		[:symbol | self basicInternNew: symbol withHash: symbol hash]! !
!SymbolSet methodsFor: 'private - lookup' stamp: 'jmv 1/10/2025 11:16:05' prior: 16963139!
                           basicInternNew: aStringOrSymbol withHash: anInteger
"quisiera eliminar"
	| interned preferByteStringForAscii |
	interned := aStringOrSymbol isSymbol
		ifTrue: [ aStringOrSymbol ]
		ifFalse: [
			preferByteStringForAscii := aStringOrSymbol.
			(aStringOrSymbol isUnicodeString and: [ aStringOrSymbol isAscii ])
				ifTrue: [preferByteStringForAscii := aStringOrSymbol asByteString].
			preferByteStringForAscii class symbolClassToUse basicFromString: preferByteStringForAscii ].
	self basicAdd: interned withHash: anInteger.
	^interned! !

SymbolSet removeSelector: #basicIntern:withHash:!

!methodRemoval: SymbolSet #basicIntern:withHash: stamp: 'Install-6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st 1/17/2025 10:30:48'!
basicIntern: aString withHash: anInteger
	"Look up again due to possible race conditions"

	| answer |
	answer := self basicLookup: aString withHash: anInteger.
	answer notNil ifTrue: [^answer].
	^self basicInternNew: aString withHash: anInteger!

SymbolSet removeSelector: #intern:!

!methodRemoval: SymbolSet #intern: stamp: 'Install-6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st 1/17/2025 10:30:48'!
intern: aString

	| hash lookup |
	hash := aString hash.
	lookup := self basicLookup: aString withHash: hash.
	lookup notNil ifTrue: [^lookup].
	^self basicIntern: aString withHash: hash.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6977] on 15 January 2025 at 9:40:31 am'!

Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!

!classDefinition: #WeakSet category: #'Collections-Unordered' stamp: 'Install-6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st 1/17/2025 10:30:48'!
Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!
!WeakSet commentStamp: 'jmv 1/15/2025 09:20:40' prior: 0!
An implementation of WeakSet that gives food performance for large instances.

It is implemented as a two level hash table. The outer level is a closed hash table, and is accessed using the higher bits of each element's hash value. At each position a Bucket is stored.

The lower bits of the hash are used to acess each Bucket. The buckets for an open hash table. Each bucket has a fixed size for direct access using the hash, and after it, a variable size area to store elements with duplicated (partial) hashes.

Currently, the Buckets use 8 positions for O(1) direct access using the lower 3 bits of the hash. The iterable part after it can grow as needed.

Buckets are WeakArrays.

The idea for small WeakArrays as buckets is from a previous SymbolSet by Andrés Valloud.
The idea of buckets having a direct access part, and an variable sized overflow part for (partial) hash collisions is from Juan Vuletich, specific for this class.

Note: An implementations using these ideas, could be good for Set et al.
Note: Perhaps a three level table, with a fixed size outer level, and where the mid level arrays grow as needed, could further improve performance for very large collections.!

WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!

!classDefinition: #WeakIdentitySet category: #'Collections-Unordered' stamp: 'Install-6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st 1/17/2025 10:30:48'!
WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!
!WeakIdentitySet commentStamp: 'jmv 1/13/2025 09:10:25' prior: 0!
   See class comment at WeakSet.

This subclass only differs from it in using #== and #identityHash instead of #= and #hash.!
!WeakSet methodsFor: 'accessing' stamp: 'jmv 1/13/2025 13:08:52'!
   estimatedSize
	"Actual size may be less: as our references to elements are weak, elements could vanish anytime."

	^estimatedSize! !
!WeakSet methodsFor: 'accessing' stamp: 'jmv 1/12/2025 18:05:02' overrides: 16827542!
     size

	^buckets inject: 0 into: [ :prev :bucket | bucket ifNil:[prev] ifNotNil: [(bucket count: [:s | s notNil]) + prev ]]! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/13/2025 13:11:00' overrides: 16827586!
   add: newObject
	"Include newObject as one of the receiver's elements, but only if
	not already present.
	Answer newObject (even if another, but equal, object is already included)."

	| hash |
	hash := self hashFor: newObject.
	(self basicLookup: newObject withHash: hash) ifNil: [
		self basicAdd: newObject withHash: hash ].
	^newObject! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:10:53' overrides: 16827595!
            add: newObject withOccurrences: anInteger
	^ self add: newObject! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:55:11' overrides: 16828650!
                             includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/11/2025 10:14:21'!
                            lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise.
	Note: The hash will be used several times, and it may be expensive. Ask for it just once."

	^self basicLookup: anObject withHash: (self hashFor: anObject)! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/11/2025 10:22:07'!
               lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it.
	Note: Do NOT add anObject to the Set!!"
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock value.
		self basicAdd: newObject withHash: (self hashFor: newObject).
		newObject ].! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:21:45' overrides: 16828730!
               occurrencesOf: anObject
	^ (self includes: anObject) ifTrue: [1] ifFalse: [0]! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 13:09:42' overrides: 16827898!
                       collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.  
	Collect the resulting values into a collection like the receiver. Answer  
	the new collection."

	| newSet |
	newSet := self species newWithRoomForMoreThan: self size.
	self do:
		[ :each |
			newSet add: (aBlock value: each)].
	^ newSet! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 16:59:24' overrides: 16828068!
                          do: aBlock

	buckets do:
		[:eachBucket |
			eachBucket ifNotNil:
				[
					eachBucket do:
						[:element |
							element notNil ifTrue:
								[aBlock value: element]]]]! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 13:09:14' overrides: 16828250!
                      union: aCollection
	"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all."

	^(self species newWithRoomForMoreThan: estimatedSize + aCollection estimatedSize)
		addAll: self;
		addAll: aCollection;
		yourself.! !
!WeakSet methodsFor: 'comparing' stamp: 'jmv 1/10/2025 10:17:35' overrides: 16827645!
                      emptyCollectionHash
	^ Set hash! !
!WeakSet methodsFor: 'copying' stamp: 'jmv 1/13/2025 13:03:50' overrides: 16915537!
         postCopy

	self rehash! !
!WeakSet methodsFor: 'objects from disk' stamp: 'jmv 1/13/2025 13:02:58' overrides: 16916389!
        comeFullyUpOnReload: smartRefStream
	"Symbols have new hashes in this image."

	self rehash.! !
!WeakSet methodsFor: 'initialization' stamp: 'jmv 1/13/2025 12:44:39'!
                         init: n
	"Initialize array to an array size of n"
	buckets := Array new: n.
	estimatedSize := 0.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 17:51:20'!
                            basicAdd: anObject withHash: hashValue
	"Add an object.
	Note: It is assumed that the argument is NOT already included. Check senders."

	| bucketIndex bucket indexInBucket bucketSize newBucket |

	"bucket creation is lazy"
	bucketIndex := self bucketIndexFor: hashValue.
	bucket := buckets at: bucketIndex.
	bucket ifNil: [ bucket := buckets at: bucketIndex put: (WeakArray new: self bucketDirectAccessSize)].

	"1. If our direct access spot in the hasheable area is free, just use it and we are done."
	indexInBucket := self indexInBucketFor: hashValue.
	(bucket at: indexInBucket) == nil ifTrue: [
		bucket at: indexInBucket put: anObject.
		estimatedSize := estimatedSize + 1.
		^self ].

	"2. If there is available room in the iterable part of the bucket, add our new element there."
	bucketSize := bucket size.
	self bucketIterablePartStart to: bucketSize do: [ :i |
		(bucket at: i) == nil ifTrue: [
			bucket at: i put: anObject.
			estimatedSize := estimatedSize + 1.
			^self ]].

	"There's no room in this bucket. It may be worth growing the collection.
	I (jmv) could not find a good heuristic on whether to grow the collection based on a single bucket.
	The adopted one was to limit average mean occupation over all buckets."
	estimatedSize > (buckets size * self bucketDesiredMeanOccupation) ifTrue: [
		self grow.
		"Now try again.
		Maybe the new element is added in the first part of the bucket,
		or in already available room in the second part. (1 and 2 above).
		Or maybe growing the bucket as below (3) is needed.
		What is sure is that this won't recurse more than once: buckets size was just doubled by #grow."
		^self basicAdd: anObject withHash: hashValue ].

	"3. We still need to grow the bucket. Grow it and add our new element."
	newBucket := WeakArray new: bucketSize + self bucketIterablePartGrow.
	newBucket replaceFrom: 1 to: bucketSize with: bucket startingAt: 1.
	newBucket at: bucketSize + 1 put: anObject.
	buckets at: bucketIndex put: newBucket.
	estimatedSize := estimatedSize + 1.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:56:03'!
                        basicLookup: anObject withHash: hashValue
	"Look for anObject. Assume hashValue is anObject hash, passed as argument to avoid possibly expensive repeated hash computation.
	Answer the element found, or nil if not found."

	| bucket indexInBucketForDirectAccess directAccessElelemt |
	bucket := buckets at: (self bucketIndexFor: hashValue).
	bucket ifNil: [ ^nil ].

	indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
	directAccessElelemt := bucket at: indexInBucketForDirectAccess.
	(self areEqual: directAccessElelemt and: anObject)
		ifTrue: [ ^directAccessElelemt ].

	(self basicLook: anObject inIterablePartOf: bucket)
		ifNotNil: [ :index | | found |
			"We found it at the iterable part of the bucket.
			Move to the the direct access slot if possible."
			found := bucket at: index.
			directAccessElelemt isNil ifTrue: 
				[
					bucket at: indexInBucketForDirectAccess put: found.
					bucket at: index put: nil].
			^found].

	^nil! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:38:32'!
                             bucketIndexFor: hashValue

	"The lowest few bits are used to index into each bucket.
	Don't use them for finding the bucket.
	See #indexInBucketFor:"
	^ ((hashValue bitShift: self bucketsHashShift)
			"Take only as much bits as we can use."
			bitAnd: buckets size-1)
				"And remember Smalltalk does 1-based indexing."
				+ 1! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 17:20:05'!
                     grow
	"Duplicate size of buckets. Keep old buckets.
	For each old bucket:
	- Duplicate it as a new bucket
	- Move elements that belong in the new bucket to it
	- If possible, move elements in the iterable area to the hasheable area. This is important for search performance.
	
	Note: An alternative implementation is simply
		self rehash: buckets size * 2
	But the current implementation is much faster, at the expense of additional memory consumption."

	| newBuckets oldBucketsSize maskForNewUsedHashBit anOldBucket aNewBucket elementHash diirectAccessIndexInBucket keepdOldBucket |
	estimatedSize := 0.
	oldBucketsSize := buckets size.
	maskForNewUsedHashBit := oldBucketsSize * self bucketDirectAccessSize. "We're directly accessing the full hash, including the lower bits."
	newBuckets := buckets grownTo: oldBucketsSize * 2.
	1 to: oldBucketsSize do:
		[ :indexToOldBucket |
			anOldBucket := buckets at: indexToOldBucket.
			anOldBucket ifNotNil:
				[
					keepdOldBucket := false.
					aNewBucket := nil.
					"Move elements in hasheable area to new bucket if appropriate."
					1 to: self bucketDirectAccessSize do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									((self hashFor: element) bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ keepdOldBucket := true ]
									ifFalse:
										[
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											aNewBucket at: indexInBucket put: (anOldBucket at: indexInBucket).
											anOldBucket at: indexInBucket put: nil ]]].
					"For elements is iterable area, try to move them to the hasheable area."
					self bucketIterablePartStart to: anOldBucket size do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									elementHash := self hashFor: element.
									diirectAccessIndexInBucket := self indexInBucketFor: elementHash.
									(elementHash bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ "Stays in old bucket. Try to move to hasheable part."
											keepdOldBucket := true.
											(anOldBucket at: diirectAccessIndexInBucket) ifNil:
												[
													anOldBucket at: diirectAccessIndexInBucket put: element.
													anOldBucket at: indexInBucket put: nil ]]
									ifFalse:
										[ "Moves to new bucket. Try to move to hasheable part, or move to iterable part."
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											(aNewBucket at: diirectAccessIndexInBucket) ifNil:
												[ aNewBucket at: diirectAccessIndexInBucket put: element ]
											ifNotNil:
												[ aNewBucket at: indexInBucket put: element ].
											anOldBucket at: indexInBucket put: nil ]]].
					keepdOldBucket ifFalse:
						[newBuckets at: indexToOldBucket put: nil ]]].
	buckets := newBuckets.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:38:55'!
             indexInBucketFor: hashValue
	"see also #bucketIndexFor:"

	^ (hashValue bitAnd: self bucketDirectAccessMask) + 1! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 11:55:48' overrides: 16934010!
                        rehash
	self rehash: buckets size! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 11:55:25'!
                           rehash: newBucketsSize
	| oldBuckets |
	oldBuckets := buckets.
	self init: newBucketsSize.
	oldBuckets do:
		[:eachBucket |
			eachBucket ifNotNil:
				[
					eachBucket do:
						[:element |
							element notNil
								ifTrue: [self add: element]]]]! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:43:19'!
           areEqual: a and: b
	"To make it easy to implement WeakIdentitySet as a subclass."

	^a = b! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:32:18'!
             basicLook: anObject inIterablePartOf: aBucket
	"To make it easy to implement WeakIdentitySet as a subclass."
	"Answer the index or nil if not found"

	self bucketIterablePartStart to: aBucket size do: [ :i |
		(aBucket at: i) = anObject ifTrue: [ ^i ]].
	^nil! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:08:56'!
    hashFor: anObject
	"To make it easy to implement WeakIdentitySet as a subclass."

	^anObject hash! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 14:53:46' overrides: 16827821!
      copyWithout: oldElement 
	"Answer a copy of the receiver that does not contain any elements equal
	to oldElement."

	^ self copy
		remove: oldElement ifAbsent: nil;
		yourself! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 14:53:40' overrides: 16828464!
                        remove: oldObject ifAbsent: aBlock

	| hashValue indexInBucketForDirectAccess |
	hashValue := self hashFor: oldObject.
	(buckets at: (self bucketIndexFor: hashValue)) ifNotNil:
		[ :bucket |
			indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
			(self areEqual: (bucket at: indexInBucketForDirectAccess) and: oldObject) ifTrue:
				[
					bucket at: indexInBucketForDirectAccess put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ].
			(self basicLook: oldObject inIterablePartOf: bucket)
				ifNotNil: [ :index |
					bucket at: index put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ]].
	^ aBlock value! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 12:38:32'!
            removeAll

	buckets atAllPut: nil.
	estimatedSize := 0.! !
!WeakSet methodsFor: 'testing' stamp: 'jmv 1/13/2025 12:29:57' overrides: 16827640!
                 = aSet

	self == aSet ifTrue: [^ true].	"Any object is equal to itself"
	(aSet is: #Set) ifFalse: [^ false].
	(aSet is: #Dictionary) ifTrue: [^ false].
	self size = aSet size ifFalse: [^ false].
	self do: [ :each | (aSet includes: each) ifFalse: [^ false]].
	^ true! !
!WeakSet methodsFor: 'testing' stamp: 'jmv 1/10/2025 10:10:13' overrides: 16828691!
                               is: aSymbol
	^aSymbol == #Set or: [ super is: aSymbol ]! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/14/2025 17:56:51'!
                            bucketDesiredMeanOccupation
	"How much of a bucket to use on average.
	Larger values, avoiding waste of memory on empty slots in buckets mean slower access due to hash conflicts forcing iteration on the iterable part of the unlucky buckets.
	Smaller values, avoiding iteration and faster access mean more wasted memory.
	Some experimentation sugges that using in average half of the buckets gives great performance, with some disregard for memory."

	^5! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:06'!
              bucketDirectAccessMask
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal #bucketDirectAccessSize-1.
	See also #bucketDirectAccessSize, #bucketIterablePartStart and #bucketsHashShift"

	^7! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:28:59'!
                bucketDirectAccessSize
	"The size of the initial part of each bucket, that is only used for elements with matching hash bits.
	See also #bucketDirectAccessMask, #bucketIterablePartStart and #bucketsHashShift"

	^8! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/14/2025 17:53:35'!
                              bucketIterablePartGrow
	"Number of slots to add at once to the iterable part of Buckets."

	^1! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:13'!
                     bucketIterablePartStart
	"The first index of the iterable area of each Bucket.
	Must equal #bucketDirectAccessSize+1
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketsHashShift"

	^9! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:22'!
        bucketsHashShift
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal (#bucketDirectAccessMask highBit negated)
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketIterablePartStart"

	^ -3! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 13:01:47' overrides: 16787783!
    new
	^ self newWithRoomForMoreThan: 32! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 12:53:56' overrides: 16828875!
                  newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self newWithRoomForMoreThan: aCollection size)
		addAll: aCollection;
		yourself! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 12:53:33'!
                           newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing
	WeakSet newWithRoomForMoreThan: 31
	WeakSet newWithRoomForMoreThan: 32
	"

	| answer |
	answer := self basicNew.
	answer init: (2 raisedToInteger: (nElements // answer bucketDesiredMeanOccupation) highBit -1).
	^answer! !
!WeakSet class methodsFor: 'experiments - tuning' stamp: 'jmv 1/15/2025 09:22:57'!
              experiment01
	"For measurements and tuning.
	Slow and memory hungry. Adjust a and m paramenters, play with this.
	A nice visualization of hash values is commented out. Play with it.
	self experiment01
	"
| a bits f h m n o pixelsMask s w ws |
n := 1000.
m := 10000.
a := Array new: n.
Transcript clear.
ws := WeakSet new.
Symbol allSymbols do: [ :sym | ws add: sym ].
ws inspect. a inspect.
Smalltalk garbageCollect.
Symbol rehash.
Smalltalk garbageCollect.
"---"
w := 2048.
h := 2048.
bits := ByteArray new: w*h // 8.
f := Form extent: w@h depth: 1 bits: bits.
bits atAllPut: 0.
pixelsMask := w*h-1.
"---"
[
	1 to: n do: [ :i |
		i \\ 10 = 0 ifTrue: [
			{'i: '. i. Time now} print ].
		o := Array new: m.
		a at: i put: o.
		1 to: m do: [ :i2 |
			s := Random next printString.
			o at: i2 put: s.
			ws add: s.
			"
			bits bitAt: (s hash bitAnd: pixelsMask)+1 put: 1.
			Random next > 10.9999 ifTrue: [
				f display. Display forceToScreen ]
			"
	 ]].
] timeToRun print.
ws size print.
ws instVarNamed: 'buckets' :: size print.
(ws instVarNamed: 'buckets') sum: [ :b | b ifNil: [0] ifNotNil: [b size ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 12 ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 15 ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b allSatisfy: [ :e | e isNil ]] ] :: print.
'-----' print.
8 to: 15 do: [ :xx |
	(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size = xx ]] :: print ].
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 15 ]] :: print.! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:43:13' overrides: 50341996!
                      areEqual: a and: b
	"To make it easy to implement WeakIdentitySet as a subclass."

	^a == b! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:32:27' overrides: 50342002!
                basicLook: anObject inIterablePartOf: aBucket
	"To make it easy to implement WeakIdentitySet as a subclass."
	"Answer the index or nil if not found"

	self bucketIterablePartStart to: aBucket size do: [ :i |
		(aBucket at: i) == anObject ifTrue: [ ^i ]].
	^nil! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:09:15' overrides: 50342013!
       hashFor: anObject
	"To make it easy to implement WeakIdentitySet as a subclass."

	^anObject identityHash! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6978] on 14 January 2025 at 1:07:30 pm'!
!WorldMorph methodsFor: 'errors on draw' stamp: 'jmv 1/13/2025 17:03:05' prior: 50341369!
          removeAllKnownFailing
	drawingFailingMorphs do: [ :m | m redrawNeeded ].
	drawingFailingMorphs := WeakIdentitySet new.
! !
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 1/13/2025 17:02:57' prior: 50341377 overrides: 16832614!
                       initialize

	super initialize.
	activeHand := HandMorph new.
	damageRecorder := DamageRecorder new.
	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.
	lastAlarmTime := 0.
	deferredUIMessages := SharedQueue new.
	drawingFailingMorphs := WeakIdentitySet new.
	pause := 20.
	lastCycleTime := Time localMillisecondClock.
	lastCycleHadAnyEvent := false! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
WorldMorph allInstancesDo: [ :w | w removeAllKnownFailing ].
Smalltalk garbageCollect.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6979-UseNew-WeakIdentitySet-JuanVuletich-2025Jan14-13h04m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6978] on 14 January 2025 at 1:09:32 pm'!

Smalltalk removeClassNamed: #OldWeakIdentitySet!

!classRemoval: #OldWeakIdentitySet stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:48'!
OldWeakSet subclass: #OldWeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

Smalltalk removeClassNamed: #OldWeakSet!

!classRemoval: #OldWeakSet stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:48'!
Set subclass: #OldWeakSet
	instanceVariableNames: 'flag'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

Smalltalk removeClassNamed: #WeakSetInspector!

!classRemoval: #WeakSetInspector stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:48'!
SetInspector subclass: #WeakSetInspector
	instanceVariableNames: 'flagObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector'-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6981] on 14 January 2025 at 1:17:53 pm'!
!Symbol class methodsFor: 'class initialization' stamp: 'jmv 1/14/2025 13:13:34' prior: 16962889 overrides: 16917943!
    initialize
	"Rebuild the hash table"
	"
	Symbol initialize.
	"
	self accessProtect critical:
		[ 	| allSymbols |
			allSymbols := self allSymbols.
			Symbols := WeakSet new.
			Symbols addAll: allSymbols ].! !
!Symbol class methodsFor: 'private' stamp: 'jmv 1/14/2025 13:17:28' prior: 16962935 overrides: 16934010!
     rehash
	"Rebuild the hash table"
	"
	Symbol rehash
	"

	
	self accessProtect critical: [
		Symbols rehash ].! !

Symbol initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6981-Use-WeakSet-ForSymbolTable-JuanVuletich-2025Jan14-13h17m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6981] on 15 January 2025 at 9:58:37 am'!
!Integer methodsFor: 'comparing' stamp: 'jmv 1/15/2025 09:56:58'!
        hashMultiply
	self subclassResponsibility! !
!Integer methodsFor: 'comparing' stamp: 'jmv 1/15/2025 09:57:42' prior: 16886667 overrides: 16913818!
             hash
	"Hash is reimplemented because = is implemented.
	Siimply answering self as #hash has bad performance for the following:
	| s |
	s := (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	"Can only happen in 64 bits images...
	See Float>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
	self abs < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].

	"In 32 bit image it will always go this way"
	^self hashMultiply! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6982-CommentTweak-JuanVuletich-2025Jan15-09h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6962] on 12 January 2025 at 9:01:29 pm'!
!Random methodsFor: 'accessing' stamp: 'eem 1/12/2025 19:26:00'!
                       next: numberOfElements
	| elements |
	elements := Array new: numberOfElements.
	1 to: numberOfElements do:
		[:i| elements at: i put: self next].
	^elements! !
!Character class methodsFor: 'instance creation' stamp: 'eem 2/5/2014 12:49'!
                  value: anInteger
	"Answer the Character whose value is anInteger."
	<primitive: 170>
	^self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6983-Random-next-and-Character-class-value-EliotEmilioMiranda-2025Jan12-19h26m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 11:52:32 am'!
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:37:45'!
recreateObsoleteSubclassesCollection
	"
	Behavior recreateObsoleteSubclassesCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ObsoleteSubclasses keysAndValuesDo: [ :k :v |
		newOne at: k put: v ].
	ObsoleteSubclasses := newOne.! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:49' prior: 16789366!
       addObsoleteSubclass: aClass
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"
	| obs |
	ObsoleteSubclasses ifNil: [
		ObsoleteSubclasses := EphemeronIdentityDictionary new ].
	obs := ObsoleteSubclasses at: self ifAbsent:[WeakArray new].
	(obs includes: aClass) ifTrue:[^self].
	obs := obs copyWithout: nil.
	obs := obs copyWith: aClass.
	ObsoleteSubclasses at: self put: obs.
! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:46:50' prior: 16789383!
       obsoleteSubclasses
	"Return all the weakly remembered obsolete subclasses of the receiver.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^#() ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^#()].
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ ObsoleteSubclasses removeKey: self ifAbsent: nil ]
		ifFalse: [ ObsoleteSubclasses at: self put: obs].
	^obs! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:11' prior: 16789399!
                    removeAllObsoleteSubclasses
	"Remove all the obsolete subclasses of the receiver"
	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses removeKey: self ifAbsent: nil ]! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:47:11' prior: 16789409!
                         removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^ self ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^ self].
	(obs includes: aClass) ifFalse:[^self].
	obs := obs copyWithout: aClass.
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ObsoleteSubclasses removeKey: self ifAbsent: nil]
		ifFalse: [ObsoleteSubclasses at: self put: obs]! !
!ClassBuilder methodsFor: 'initialization' stamp: 'jmv 1/16/2025 11:40:05' prior: 16817262!
             doneCompiling: aClass
	"The receiver has finished modifying the class hierarchy.
	Do any necessary cleanup."
	aClass doneCompiling.! !

Behavior class removeSelector: #flushObsoleteSubclasses!

!methodRemoval: Behavior class #flushObsoleteSubclasses stamp: 'Install-6984-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st 1/17/2025 10:30:48'!
flushObsoleteSubclasses
	"Behavior flushObsoleteSubclasses"

	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses keys "need a copy" 
			do: [ :obs| obs ifNotNil:[ obs obsoleteSubclasses ]]. "remove themselves"
		ObsoleteSubclasses finalizeValues ]!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Behavior recreateObsoleteSubclassesCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6984-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 12:09:31 pm'!
!ActiveModel class methodsFor: 'initialization' stamp: 'jmv 1/16/2025 12:06:37'!
                     recreateActionMapsCollection
	"
	ActiveModel recreateActionMapsCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ActionMaps keysAndValuesDo: [ :k :v |
		newOne at: k put: v ].
	ActionMaps := newOne.! !
!ActiveModel class methodsFor: 'accessing' stamp: 'jmv 1/16/2025 12:06:43' prior: 16779373!
     actionMaps

	ActionMaps ifNil: [
		ActionMaps := EphemeronIdentityDictionary new ].
	^ActionMaps! !
!ActiveModel class methodsFor: 'initialization' stamp: 'jmv 1/16/2025 12:58:12' prior: 16779391!
                           flushEventSystem
	"ActiveModel flushEventSystem"
	self actionMaps keysAndValuesDo: [ :rcvr :evtDict | 
		rcvr ifNotNil:[
			"make sure we don't modify evtDict while enumerating"
			evtDict keys do: [ :evtName | | msgSet |
				msgSet := evtDict at: evtName ifAbsent: nil.
				msgSet ifNil: [ rcvr removeActionsForEvent: evtName]]]].! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
ActiveModel recreateActionMapsCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6985-ActionMaps-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h52m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6984] on 16 January 2025 at 1:06:58 pm'!
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 1/16/2025 13:04:20' prior: 16918067!
                           monitorList
	^monitorList ifNil: [ monitorList := EphemeronIdentityDictionary new ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6986-ObjectExplorer-UseEphemeronDictionaries-JuanVuletich-2025Jan16-13h04m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6984] on 16 January 2025 at 1:06:58 pm'!
!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'jmv 1/16/2025 13:04:52' prior: 16844813!
                            voidMapCache

	self protected: [ 
		MapCache := EphemeronIdentityDictionary new.
		MapCacheEntries := 16 ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DebuggerMethodMap initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6987-DebuggerMethodMap-UseEphemeronDictionaries-JuanVuletich-2025Jan16-13h04m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 2:53:34 pm'!
!UniFileStream class methodsFor: 'registry' stamp: 'jmv 1/16/2025 14:51:58'!
              recreateRegistry
	"
	UniFileStream recreateRegistry
	"
	| newOne |
	newOne := FinalizationRegistry new.
	Registry do: [ :fileStream |
		newOne add: fileStream ].
	Registry := newOne.! !
!UniFileStream class methodsFor: 'registry' stamp: 'jmv 1/16/2025 14:52:21' prior: 16994237!
         registry
	
	^Registry ifNil: [ Registry := FinalizationRegistry new ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
UniFileStream recreateRegistry!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6988-FileRegistry-useFinalizationRegistry-notWeakRegistry-JuanVuletich-2025Jan16-14h45m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6988] on 16 January 2025 at 4:35:07 pm'!
!UniFileStream class methodsFor: 'cached state access' stamp: 'jmv 1/16/2025 16:34:16' prior: 16994352 overrides: 16789305!
                        releaseClassCachedState

	Registry ifNotNil: [
		"Make the best effort to empty the registry.
		Only keep files that are still open have references from some object."
		Registry isEmpty ifFalse: [
			Smalltalk garbageCollectMost.
			Registry isEmpty ifFalse: [
				Smalltalk garbageCollect]].

		"No open files. Can nil the Registry."
		Registry isEmpty ifTrue: [
			Registry := nil ]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6989-FileRegistry-Cleanup-JuanVuletich-2025Jan16-16h31m-jmv.001.cs.st----!

----QUIT----(17 January 2025 10:30:51) Cuis7.3-6989.image priorSource: 276466!

----STARTUP---- (23 January 2025 11:11:11) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-6989.image!


'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 11:52:32 am'!
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:37:45' prior: 50342413!
                        recreateObsoleteSubclassesCollection
	"
	Behavior recreateObsoleteSubclassesCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ObsoleteSubclasses ifNotNil:
		[:oldOne|
		oldOne keysAndValuesDo:
			[ :k :v | newOne at: k put: v ] ].
	ObsoleteSubclasses := newOne.! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:49' prior: 50342424!
     addObsoleteSubclass: aClass
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"
	| obs |
	ObsoleteSubclasses ifNil: [
		ObsoleteSubclasses := EphemeronIdentityDictionary new ].
	obs := ObsoleteSubclasses at: self ifAbsent:[WeakArray new].
	(obs includes: aClass) ifTrue:[^self].
	obs := obs copyWithout: nil.
	obs := obs copyWith: aClass.
	ObsoleteSubclasses at: self put: obs.
! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:46:50' prior: 50342440!
       obsoleteSubclasses
	"Return all the weakly remembered obsolete subclasses of the receiver.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^#() ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^#()].
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ ObsoleteSubclasses removeKey: self ifAbsent: nil ]
		ifFalse: [ ObsoleteSubclasses at: self put: obs].
	^obs! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:11' prior: 50342456!
                    removeAllObsoleteSubclasses
	"Remove all the obsolete subclasses of the receiver"
	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses removeKey: self ifAbsent: nil ]! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:47:11' prior: 50342465!
                         removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^ self ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^ self].
	(obs includes: aClass) ifFalse:[^self].
	obs := obs copyWithout: aClass.
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ObsoleteSubclasses removeKey: self ifAbsent: nil]
		ifFalse: [ObsoleteSubclasses at: self put: obs]! !
!ClassBuilder methodsFor: 'initialization' stamp: 'jmv 1/16/2025 11:40:05' prior: 50342483!
             doneCompiling: aClass
	"The receiver has finished modifying the class hierarchy.
	Do any necessary cleanup."
	aClass doneCompiling.! !

Behavior class removeSelector: #flushObsoleteSubclasses!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Behavior recreateObsoleteSubclassesCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6990-FixForAlreadySavedImages-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6989] on 17 January 2025 at 5:29:31 pm'!
!AbstractVectorCanvas class methodsFor: 'literal path data' stamp: 'jmv 1/17/2025 17:25:55' prior: 50331721!
                   windowSquareButtonPathData: aSize
	| scale |
	(IconPathData at: #windowSquareButtonSize ifAbsent: nil) = aSize ifTrue: [
		IconPathData at: #windowSquareButton ifPresent: [ :found | ^found ]].
	IconPathData at: #windowSquareButtonSize put: aSize.
	scale := aSize / 22.0.
	^IconPathData at: #windowSquareButton put: (
		self scalePathData: `#[
			0.0 0 0
			1    0 20
			1    20 20
			1    20 0
			1    0 0
		] asFloat32Array` scale: scale)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6991-MultiBrowserButtonRescale-fix-JuanVuletich-2025Jan17-17h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6991] on 20 January 2025 at 3:20:43 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 1/20/2025 15:20:18' prior: 16906274!
 findFullBoundsInOwner
	"Find and answer full bounds in whatever owner.
	These might not equal #displayFullBounds at all!!
	Note: Answers an integer rectangle"

	| prevNotVisibleFlag w c answer prevOwner |
	(owner notNil and: [owner isWorldMorph]) ifTrue: [
		w := owner ]
	ifFalse: [
		w := UISupervisor ui ].
	c := w mainBoundsFinderCanvas.
	"Hack owner so #displayBoundsSetFrom: will update privateDisplayBounds"
	prevOwner := owner.
	owner := w.
	prevNotVisibleFlag := self privateFlagAt: 3.
	self privateFlagAt: 3 put: false.
	c fullUpdateProtrudingBounds: self.
	answer := self displayFullBounds.
	"Reset owner and privateDisplayBounds (if needed) so no one finds out what we've just done!!"
	prevOwner == owner ifFalse: [
		owner := prevOwner.
		self world = w ifTrue: [
			self privateFlagAt: 3 put: false.
			self allOwnersReverseDo: [ :m | c into: m ].
			c fullUpdateProtrudingBounds: self.
			self allOwnersDo: [ :m | c outOfMorph ]]].
	self privateFlagAt: 3 put: prevNotVisibleFlag.
	^answer origin corner: answer corner -(1@0).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6992-Tighter-findFullBoundsInOwner-JuanVuletich-2025Jan20-15h19m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6992] on 20 January 2025 at 5:28:36 pm'!
!String methodsFor: 'formatting' stamp: 'eem 1/20/2025 17:30:25'!
                     withCRs
	"Answer a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."

	^ self collect: [ :c | c == $\ ifTrue: [ Character cr ] ifFalse: [ c ]]! !
!WeakArray class methodsFor: 'finalization' stamp: 'eem 1/20/2025 16:59:03' prior: 50334466!
 finalizationProcess
	"nothing here, moved to EphemeronFinalizationProcess class"
	^EphemeronFinalizationProcess runningFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'eem 1/20/2025 16:58:57' prior: 50334488!
                     runningFinalizationProcess
	"Answer the FinalizationProcess I am running, if any"
	^EphemeronFinalizationProcess runningFinalizationProcess! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'eem 1/20/2025 17:02:57' prior: 50335817 overrides: 50335766!
                           finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the ephemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: [].
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron value ifNil: [anEphemeron key]) finalize! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'eem 1/20/2025 16:58:24' prior: 16932289!
                  rulesFor: aProcess
	"Answer two flags: allow-stop, and allow-debug"

	"Don't mess with the process running the ProcessBrowser.
	If we support several active UIs, we'd detect the UI process running us"
	aProcess == Processor activeProcess
		ifTrue: [^{false. false}].

	aProcess name = 'Sound Player'
		ifTrue: [ ^{false. false}].

	^ [aProcess caseOf: {
		[] -> [{false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{false. false}].
		[WeakArray runningFinalizationProcess] -> [{false. false}].
		[EphemeronFinalizationProcess runningFinalizationProcess] -> [{false. false}].
		[Processor activeProcess] -> [{false. true}].
		[Processor backgroundProcess] -> [{false. false}].
		[Sensor interruptWatcherProcess] -> [{false. false}].
		[Sensor eventTicklerProcess] -> [{false. false}].
		[CPUWatcher currentWatcherProcess] -> [{false. false}].
		[Delay timerProcess] -> [{false. false}]}
		otherwise: [ {true. true}]]
		ifError: [ :err :rcvr | {true. true}]! !

EphemeronFinalizationProcess class removeSelector: #theFinalizationProcess!

!methodRemoval: EphemeronFinalizationProcess class #theFinalizationProcess stamp: 'Install-6993-EphemeronPreen-EliotEmilioMiranda-2025Jan20-16h56m-eem.001.cs.st 1/23/2025 11:11:11'!
theFinalizationProcess
	^TheFinalizationProcess!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6993-EphemeronPreen-EliotEmilioMiranda-2025Jan20-16h56m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6992] on 20 January 2025 at 5:28:36 pm'!
!ProcessBrowser class methodsFor: 'process control' stamp: 'eem 1/20/2025 16:58:24' prior: 50342895!
                     rulesFor: aProcess
	"Answer two flags: allow-stop, and allow-debug"

	"Don't mess with the process running the ProcessBrowser.
	If we support several active UIs, we'd detect the UI process running us"
	aProcess == Processor activeProcess
		ifTrue: [^{false. false}].

	aProcess name = 'Sound Player'
		ifTrue: [ ^{false. false}].

	^ [aProcess caseOf: {
		[] -> [{false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{false. false}].
		[EphemeronFinalizationProcess runningFinalizationProcess] -> [{false. false}].
		[Processor activeProcess] -> [{false. true}].
		[Processor backgroundProcess] -> [{false. false}].
		[Sensor interruptWatcherProcess] -> [{false. false}].
		[Sensor eventTicklerProcess] -> [{false. false}].
		[CPUWatcher currentWatcherProcess] -> [{false. false}].
		[Delay timerProcess] -> [{false. false}]}
		otherwise: [ {true. true}]]
		ifError: [ :err :rcvr | {true. true}]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6994-Preen-EliotEmilioMiranda-2025Jan20-16h56m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6994] on 21 January 2025 at 8:23:18 am'!
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: 'jmv 1/21/2025 08:19:08' prior: 50334385!
primitiveFetchMourner
	"Answer the next mourner in the VM's queue of objects to be finalized.
	 The queue contains weak arrays and ephemerons.  If the primitive is
	 not implemented, raise an error telling people to upgrade the VM.  If
	 implemented, the primitive fails if the queue is empty, with the error
	 code #'not found'. Primitive.  Essential."

	<primitive: 172 error: ec>
	ec ifNil: [^self error: 'The primitiveFetchMourner primitive is missing.\Please upgrade your virtual machine to one that has the primitive.' withNewLines].
	^nil! !

String removeSelector: #withCRs!

!methodRemoval: String #withCRs stamp: 'Install-6995-DontUse-withCRs-JuanVuletich-2025Jan21-08h22m-jmv.001.cs.st 1/23/2025 11:11:11'!
withCRs
	"Answer a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."

	^ self collect: [ :c | c == $\ ifTrue: [ Character cr ] ifFalse: [ c ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6995-DontUse-withCRs-JuanVuletich-2025Jan21-08h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6995] on 21 January 2025 at 9:00:36 am'!
!EphemeronIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'jmv 1/21/2025 08:57:52'!
           slowSize
	"Careful!! Answer the maximum amount
	of elements in the receiver, not the
	exact amount"

	| count |
	count := 0.
	self keysDo: [ :k | count := count + 1 ].
	^count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6996-Add-EphemeronIdentityDictionary-slowSize-JuanVuletich-2025Jan21-08h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6983] on 21 January 2025 at 1:27:04 pm'!

'From Cuis7.3 [latest update: #6983] on 21 January 2025 at 12:10:20 pm'!

ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame PreferredBytecodeSetEncoderClass '
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #CompiledMethod category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!CompiledMethod commentStamp: '<historical>' prior: 50338408!
                             My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields. The pointer fields are used for literals and metadata, and the bytes are used for bytecodes and a variety of encoded informaton such as source code, source code position, etc.  The first part of a CompiledMethod object is pointers, the second part is bytes.  CompiledMethod inherits from ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is a ByteArray.

Instance variables: *indexed* (no named inst vars)

Class variables:
SmallFrame							- the number of stack slots in a small frame Context
LargeFrame							- the number of stack slots in a large frame Context
PreferredBytecodeSetEncoderClass	- the encoder class that is used to create new methods (either PrimaryBytecodeSetEncoderClass or SecondaryBytecodeSetEncoderClass)
PrimaryBytecodeSetEncoderClass		- the encoder class that defines the primary instruction set
SecondaryBytecodeSetEncoderClass	- the encoder class that defines the secondary instruction set
	
TThe current format of a CompiledMethod is as follows:

	header (4 or 8 bytes, SmallInteger)
	literals (4 or 8 bytes each, Object, see "The last literal..." below)
	bytecodes  (variable, bytes)
	trailer (variable, bytes)

The header is a SmallInteger (which in the 32-bit system has 31 bits, and in the 64-bit system, 61 bits) in the following format:

	(index 0)		15 bits:	number of literals (#numLiterals)
	(index 15)		  1 bit:	jit without counters - reserved for methods that have been optimized by Sista
	(index 16)		  1 bit:	has primitive
	(index 17)		  1 bit:	whether a large frame size is needed (#frameSize => either SmallFrame or LargeFrame)
	(index 18)		  6 bits:	number of temporary variables (#numTemps)
	(index 24)		  4 bits:	number of arguments to the method (#numArgs)
	(index 28)		  2 bits:	reserved for an access modifier (00-unused, 01-private, 10-protected, 11-public), although accessors for bit 29 exist (see #flag).
	sign bit:			  1 bit:	selects the instruction set, >= 0 Primary, < 0 Secondary (#signFlag)

If the method has a primitive then the first bytecode of the method must be a callPrimitive: bytecode that encodes the primitive index.  This bytecode can encode a primitive index from 0 to 65535.

The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.

While there are disadvantages to this "flat" representation (it is impossible to add named instance variables to CompiledMethodor its subclasses, but it is possible indirectly; see AdditionalMethodState) it is effective for interpreters.  It means that both bytecodes and literals can be fetched directly from a single method object, and that only one object, the method, must be saved and restored on activation and return.  A more natural representation, in which there are searate instance variables for the bytecode, and (conveniently) the literals, requires either much more work on activation and return setting up references to the literals and bytecodes, or slower access to bytecodes and literals, indirecting on each access.

The last literal of a CompiledMethod is reserved for special use by the kernel and/or the virtual machine.  It must either be the methodClassAssociation, used to implement super sends, or nil, if the method is anonymous.

By convention, the penultimate literal is reserved for special use by the kernel. In CompiledMethod instances it must either be the method selector, or an instance of AdditionalMethodState which holds the selector and any pragmas or properties in the method.
!

BytecodeEncoder subclass: #EncoderForSistaV1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #EncoderForSistaV1 category: #'Compiler-Kernel' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
BytecodeEncoder subclass: #EncoderForSistaV1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!EncoderForSistaV1 commentStamp: 'eem 12/22/2024 19:07' prior: 0!
                      EncoderForSistaV1 encodes a bytecode set for Smalltalk that lifts limits on the number of literals, branch distances, the number of temporary variables, and provides extended push integer and push character bytecodes.  The bytecode set also supports creating FullBlockClosures, closures whose method is separate from their home method's.  Bytecodes are ordered by length to make decoding easier.  Bytecodes marked with an * are extensible via a prefix extension bytecode.

N.B.  Extension bytecodes can only come before extensible bytecodes, and only if valid (one cannot extend a bytecode extensible by Ext A with an Ext B).  An extensible bytecode consumes (and zeros) its extension(s).  Hence the hidden implicit variables holding extensions are always zero except after a valid sequence of extension bytecodes.  The implication is that a bytecode interpreter should maintain the extension values in static variables initialized to zero at start-up, and live only from the start of a sequence of extension bytecodes to the end of the extended bytecode immediately following.

While the bytecode set lifts limits, it still assumes there are no more than 65535 literals (as of 2020 the CompiledCode header word imposes a 32,767 limit on number of literals), and no more than 256 stack slots (used for arguments, temporaries, and stack contents) in a Context.

EncoderForSistaV1 also includes an extended set of bytecodes for Sista, the Speculative Inlining Smalltalk Architecture, a project by Clément Bera and Eliot Miranda.  Scorch is an optimizer that exists in the Smalltalk image, /not/ in the VM,  and optimizes by substituting normal bytecoded methods by optimized bytecoded methods that may use special bytecodes for which the Cogit can generate faster code.  These bytecodes eliminate overheads such as bounds checks or polymorphic code (indexing Array, ByteArray, String etc).  But the bulk of the optimization performed is in inlining blocks and sends for the common path.  This bytecode set therefore differs from a normal Smalltalk set in providing a set of inlined primitives that do not validate their arguments that the compiler generates only when it can prove that the primitives' arguments are valid.

The basic scheme is that the Cogit generates code containing performance counters.  When these counters trip, a callback into the image is performed, at which point Scorch analyses some portion of the stack, looking at performance data for the methods on the stack, and optimises based on the stack and performance data.  Execution then resumes in the optimized code.

The Sista Cogit (e.g. SistaStackToRegisterMappingCogit) adds counters to conditional branches.  Each branch has an executed and a taken count.  On execution the executed count is decremented and if the count goes below zero the VM sends a message at a special index in the specialObjectsArray (as of writing, conditionalCounterTrippedOn:).  Then if the branch is taken the taken count is decremented.  The two counter values allow the Sista optimizer to collect basic block execution paths and to know what are the "hot" paths through execution that are worth agressively optimizing.  Since conditional branches are about 1/6 as frequent as sends, and since they can be used to determine the hot path through code, they are a better choice to count than, for example, method or block entry.

The VM provides a primitive that fills an Array with the state of the counters, and the state of each linked send in a method.  The optimizer obtains the branch and send data for a method via this primitive.

Instance Variables (inherited)

Here is the list of bytecodes.  An asterisk implies the bytecode takes either extA or extB extensions. Two asterisks imply it takes both extA and extB extensions.  A number in parentheses is a note.  See the notes at the end of the table.

1 Byte Bytecodes
	code	(note)	binary			name
	0-15		0000 iiii 			Push Receiver Variable #iiii
	16-31		0001 iiii			Push Literal Variable #iiii
	32-63		001 iiiii				Push Literal #iiiii
	64-71		01000 iii			Push Temp #iii
	72-75		010010 ii			Push Temp #ii + 8
	76			01001100			Push Receiver
	77			01001101			Push true
	78			01001110			Push false
	79			01001111			Push nil
	80			01010000			Push 0
	81			01010001			Push 1
*	82			01010010			Push thisContext, (then Extend B = 1 => push thisProcess)
	83			01010011			Duplicate Stack Top
	84-87		010101 ii			UNASSIGNED
	88-91		010110 ii			Return Receiver/true/false/nil
	92			01011100			Return top
	93			01011101			BlockReturn nil
*	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]
*	95			01011111			Nop
	96-111		0110 iiii			Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	112-119	01110 iii			Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	120-127	01111 iii			Send Special Message #iii + 8 (~~ value value: do: new new: x y)
	128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
	144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
	160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments
	176-183	10110 iii			Jump iii + 1 (i.e., 1 through 8)
	184-191	10111 iii			Pop and Jump 0n True iii +1 (i.e., 1 through 8)
	192-199	11000 iii			Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	200-207	11001 iii			Pop and Store Receiver Variable #iii
	208-215	11010 iii			Pop and Store Temporary Variable #iii
	216		11011000			Pop Stack Top
	217	(5)	11011001			Unconditional trap
	218-219	1101101 i			UNASSIGNED
	220-223	110111 ii			UNASSIGNED

2 Byte Bytecodes
*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A) A is an unsigned extension.
*	225		11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B) B is a signed extension.
*	226		11100010	iiiiiiii		Push Receiver Variable #iiiiiiii (+ Extend A * 256)
*	227		11100011	iiiiiiii		Push Literal Variable #iiiiiiii (+ Extend A * 256)
*	228		11100100	iiiiiiii		Push Literal #iiiiiiii (+ Extend A * 256)
	229		11100101	iiiiiiii		Push Temporary Variable #iiiiiiii
	230		11100110	iiiiiiii		UNASSIGNED (was pushNClosureTemps)
	231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)
*	232		11101000	iiiiiiii		Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
*	233		11101001	iiiiiiii		Push Character #iiiiiiii (+ Extend A * 256)
**	234		11101010	iiiiijjj		Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
**	235	(1)	11101011	iiiiijjj	ExtendB < 64
										ifTrue: [Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments]
										ifFalse: [Send To Superclass of Stacked Class Literal Selector #iiiii (+ Extend A * 32) with jjj (+ (Extend B bitAnd: 63) * 8) Arguments]
	236		11101100	iiiiiiii		UNASSIGNED
*	237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
**	238	(4)	11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	239	(4)	11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	240	(3)	11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	241	(3)	11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	242		11110010	iiiiiiii		Pop and Store Temporary Variable #iiiiiiii
**	243	(3)	11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	244	(3)	11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	245		11110110	iiiiiiii		Store Temporary Variable #iiiiiiii
	246-247	1111011 i	xxxxxxxx	UNASSIGNED

3 Byte Bytecodes
	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are as yet unused)
								Lowcode inlined primitives may have extensions.
*	249		11111001 	xxxxxxxx	siyyyyyy	Push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1
**	250		11111010 	eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions
	251		11111011 	kkkkkkkk	sjjjjjjj		Push Temp At kkkkkkkk In Temp Vector At: jjjjjjj, s = 1 implies remote inst var access instead of remote temp vector access 
*	252	(3)	11111100 	kkkkkkkk	sjjjjjjj		Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access 
*	253	(3)	11111101 	kkkkkkkk	sjjjjjjj		Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Not Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ Extend B * 256, where Extend B >= 0 and <= 127)
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ (Extend B bitAnd: 127) * 256, where Extend B >= 128 and <= 255)
*	255		11111111	xxxxxxxx	jjjjjjjj		UNASSIGNED

(1) Bytecode 235 is a super send bytecode that starts the lookup in the superclass of some class.  It has two forms, "normal" and "directed". In the normal form, the class is the value of the method's methodClassAssociation which must be the last literal.  In the directed form the class is the class on top of stack.

(2) The Call Primitive Bytecode (see below) specifies either a primitive in the primitive table (m=0) or an inlined primitive (m=1). Non-inlined primitives from the primitive table have index (jjjjjjj * 256) + iiiiiiii and return from the method if they succeed.  This bytecode is only valid as the first bytecode of a method.  Inline primitives have index (jjjjjjj * 256) + iiiiiiii, cannot fail, and do not return when they succeed, yielding a result (typically on top of stack after popping their arguments, but possibly in a byte data stack, for example for unboxed floating-point primitives).

(3) ExtB lowest bit implies no store check is needed, ExtB second bit implies the object may be a context, ExtB third bit implies no immutability/read-only check is needed, other bits in the extension are unused.

(4) ExtA = 1 implies no mustBeBoolean trampoline is needed, other bits in the extension are unused

(5) these are Scorch/Sista bytecodes generated by an optimizing compiler and not used in normal Smalltalk code.


The CallPrimitive bytecode is divided into two halves, those for normal primtiives, occurring at the beginning of a method, and those for inline primitives, anywhere within the body of a method.  This is a three byte bytecode, the first byte being 248, and the second byte being a big-endian 16-bit primitive index. If the top bit of the first byte of the primitive index is 1 then this is a normal primitive invocation.  If it is zero then the remaining 15 bits define 32k primitives, organized as four 8k "pages".  The first page is used for and reserved by the Sista optimizing compiler.  The second page is usd for and reserved by the Lowcode FFI marshalling primitive set.  The other two sets are unspecified and unused.

Here is the specification of the Sista unsafe instructions (unsafe operations, set 00). The lowcode set uses external specifications.
We sort the inline primitive operations by arity.  Nullary primitives occupy the 0-999 range. Unary primitives occupy the 1-1999 range, up until 8 args. 8191 instructions can be encoded in each unsafe operation set, instructions from 0 to 7 arguments can have 1000 different instructions each, while 8 args instructions can have 192 different instructions.

Sista defines the following inlined primitives (CallPrimitive iiiiiiii 100jjjjj, n = jjjjjiiiiiiii)
1000	class
1001	pointer numSlots
1002	pointer basicSize
1003	byte8Type format numBytes (includes CompiledMethod)
1004	short16Type format numShorts
1005	word32Type format numWords
1006	doubleWord64Type format numDoubleWords
	
1010	ensure number of bytes available.
1011	fixed-sized new. (objects with 0 to n inst vars)
	
1020 	identityHash (non-immediate, non-Behavior)
1021	identityHash (SmallInteger)
1022	identityHash (Character)
1023	identityHash (SmallFloat64)
1024	identityHash (Behavior, has hash?)

1030 	immediateAsInteger (Character)
1031 	immediateAsInteger (SmallFloat64)
1035 	immediateAsFloat 	(Smallinteger)
	
2000	SmallInteger #+.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2001	SmallInteger #-.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2002	SmallInteger #*.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2003	SmallInteger #/.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2004	SmallInteger #//.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2005	SmallInteger #\\.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2006	SmallInteger #quo:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2011	Variable-sized pointers new (new:). Array, etc.
2012	Variable-sized byte new (new:). ByteArray, ByteString, etc.
2013	Variable-sized 16-bit new (new:). DoubleByteArray, etc.
2014	Variable-sized 32-bit new (new:). Bitmap, FloatArray, etc.
2015	Variable-sized 64-bit new (new:). DoubleWordArray, etc.

2016	SmallInteger #bitAnd:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2017	SmallInteger #bitOr:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2018	SmallInteger #bitXor:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2019	SmallInteger #bitShiftLeft:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2020	SmallInteger #bitShiftRight:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2032	SmallInteger #>.  Both arguments are SmallIntegers
2033	SmallInteger #<.  Both arguments are SmallIntegers
2034	SmallInteger #>=.  Both arguments are SmallIntegers
2035	SmallInteger #<=.  Both arguments are SmallIntegers
2036	SmallInteger #=.  Both arguments are SmallIntegers
2037	SmallInteger #~=.  Both arguments are SmallIntegers

2064	Pointer Object>>at:.		The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
2065	Byte Object>>at:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2066	16-bit Word Object>>at:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2067	32-bit DoubleWord Object>>at:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.
2068	64-bit QuadWord Object>>at:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.

The following instructions can have the ExtB check flag (See (3)).
3000	Pointer Object>>at:put:.			The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
3001	Byte Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 8 bits.
3002	Word Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 16 bits.
3003	DoubleWord Object>>at:put:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 32 bits.
3004	QuadWord Object>>at:put:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 64 bits.
			
3021	Byte Object >> equals:length:	The receiver and the arguments are both byte objects and have both the same size (length). The length argument is a smallinteger. Answers true if all fields are equal, false if not. Comparison is bulked to word comparison.

4000	Pointer Object>> fillFrom:to:with: The receiver is a Pointer object. the middle two arguments are smallintegers. Last argument is any object. Fills the object in between the two indexes with last argument. Receiver is guaranteed to be mutable. The pointer accesses are raw (no inst var check). If ExtB is set to 1, no store check is present. Else a single store check is done for the bulk operation. Answers the receiver.
	
5000	Pointer Object>> replaceFrom:to:with:startingAt: Src and dest are pointer objects. ScrPos, scrLast and destLast are smallintegers. Receiver is guaranteed to be mutable.  Both ranges are in-bounds. The pointer accesses are raw (no inst var check). As for the normal primitive, the copy is linear. Answers the receiver.


Lowcode defines inlined primitives for the range CallPrimitive iiiiiiii 101jjjjj, n = jjjjjiiiiiiii.!
!BraceNode commentStamp: 'eem 12/24/2024 16:24:49' prior: 16796986!
 Used for compiling and decompiling brace constructs.

These now compile into either a fast short form for 8 elements or less (see maxElementsForConsArray)
that uses the pushConsArrayWithElements: nElements bytecode
or a long form of indefinfite length:
	(Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray.

The erstwhile brace assignment form is no longer supported.!
!ParseNodeEnumerator commentStamp: 'eem 3/19/2019 11:58' prior: 16920433!
                          ParseNodeEnumerator implements ParseNode>>nodesDo:.  It can be used to enumerate an entire tree via
	aParseNode accept: (ParseNodeEnumerator ofBlock: aBlock)
or selectively, excluding the node and subnodes for which selectBlock answers false, via
	aParseNode accept: (ParseNodeEnumerator
							ofBlock: aBlock
							select: selectBlock)
Instance Variables
	theBlock:			<BlockClosure>
	theSelectBlock:		<BlockClosure | nil>

theBlock
	- the block that is evaluated with the parse nodes the receiver visits.

theSelectBlock
	- an optional block used to select blocks to visit and descend into.

Here's a doIt that generates and compiles the visiting methods:

self superclass selectors do:
	[:s|
	self compile: (String streamContents:
		[:str| | arg |
		arg := 'a', (s allButFirst: 5) allButLast.
		str nextPutAll: s, ' ', arg; crtab;
			nextPutAll: '(theSelectBlock isNil or: [theSelectBlock value: '; nextPutAll: arg; nextPutAll: ']) ifFalse:'; crtab;
			tab: 2; nextPutAll: '[^nil].'; crtab;
			nextPutAll: 'theBlock value: '; nextPutAll: arg; nextPut: $.; crtab;
			nextPutAll: '^super '; nextPutAll: s, ' ', arg])]!

ParseNodeEnumerator subclass: #ParseNodeWithPrecedingStatementEnumerator
	instanceVariableNames: 'precedingStatement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #ParseNodeWithPrecedingStatementEnumerator category: #'Compiler-Support' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
ParseNodeEnumerator subclass: #ParseNodeWithPrecedingStatementEnumerator
	instanceVariableNames: 'precedingStatement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!ParseNodeWithPrecedingStatementEnumerator commentStamp: 'eem 3/19/2019 11:55' prior: 0!
                    A ParseNodeWithPrecedingStatementEnumerator is a ParseNodeEnumerator that accepts a binary block in ofBlock:, and hence enumerates statement nodes with their preceding statement, or nil if they are the first.

Instance Variables
	precedingStatement:		<ParseNode | nil>

precedingStatement
	- the preceding statement node, if any
!

VariableScopeFinder subclass: #NarrowerVariableScopeFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #NarrowerVariableScopeFinder category: #'Compiler-Support' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
VariableScopeFinder subclass: #NarrowerVariableScopeFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!NarrowerVariableScopeFinder commentStamp: 'eem 4/3/2017 11:59' prior: 0!
       A NarrowerVariableScopeFinder is used to find a smaller scope for an already declared variable.!

Warning subclass: #SimulationSideEffectWarning
	instanceVariableNames: 'primitiveIndex context method receiver arguments suppressed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Exceptions'!

!classDefinition: #SimulationSideEffectWarning category: #'Kernel-Exceptions' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
Warning subclass: #SimulationSideEffectWarning
	instanceVariableNames: 'primitiveIndex context method receiver arguments suppressed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Exceptions'!
!SimulationSideEffectWarning commentStamp: 'ct 3/3/2024 19:17' prior: 0!
                 I am signaled to notify the client of the simulator (i.e., a sender of Context>>step) about potential side effects of the next instruction to be executed that would escape the control of the simulator. For example, I am signaled before the simulated code starts another process. See Context>>doPrimitive:method:receiver:args:, my messageText, and Parser>>simulationGuard for more information.!

Object subclass: #ImplicitLiteralInstructionClientHook
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #ImplicitLiteralInstructionClientHook category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
Object subclass: #ImplicitLiteralInstructionClientHook
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!ImplicitLiteralInstructionClientHook commentStamp: 'eem 9/16/2021 19:35' prior: 0!
   ImplicitLiteralInstructionClientHook is a hook to allow clients to intercept bytecodes referencing implicit literals, such as special selector sends which have an implicit selector in Smalltalk specialSelectors.  It implements the messages sent by InstructionStream's interpretNextXXXInstructionFor: methods for bytecodes that reference implicit literals as sends of the relevant explciit literal methods.  This allows clients that want to to intercept implicit literal messages while leaving existing clients unchanged.

The class also supports CompiledCode>>abstractBytecodeMessagesFrom:to:do: et al which depend on MessageNotUnderstood to collect bytecode messages.  Use of instances of this class hides the existence of pushSpecialConstant: and sendSpecial:numArgs: since these are understood, but their sends of pushConstant: and send:super:numArgs: are not.

Instance Variables!

ImplicitLiteralInstructionClientHook subclass: #InstructionClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #InstructionClient category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
ImplicitLiteralInstructionClientHook subclass: #InstructionClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!BlockLocalTempCounter commentStamp: 'eem 1/11/2018 08:30' prior: 16793992!
                             I am a support class for the decompiler that is used to find the number of local temps in a block by finding out what the stack offset is at the end of a block.  I am necessary because in the EncoderForV3PlusClosures bytecode set the only way to initialize block-local temporaries is with pushConstant: nil bytecodes, but such bytecodes are ambiguous with a pushConstant: nil used to pass nil as a parameter or answer it as a result.  By scanning through to the end of the block these can be disambiguated by tracking the stack depth.!

InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts '
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag '
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Decompiler category: #'Compiler-Kernel' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts'
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!Decompiler commentStamp: '<historical>' prior: 16845382!
                    I decompile a method in three phases:
	Reverser: postfix byte codes -> prefix symbolic codes (nodes and atoms)
	Parser: prefix symbolic codes -> node tree (same as the compiler)
	Printer: node tree -> text (done by the nodes)
	

instance vars:

	constructor <DecompilerConstructor> an auxiliary knowing how to generate Abstract Syntax Tree (node tree)
	method <CompiledMethod> the method being decompiled
	instVars <Array of: String> the instance variables of the class implementing method
	tempVars <String | (OrderedCollection of: String)> hold the names of temporary variables (if known)
		NOTE: POLYMORPHISM WILL BE RESOLVED IN #initSymbols:
	constTable <Collection of: ParseNode> parse node associated with byte encoded constants (nil true false 0 1 -1 etc...)
	stack <OrderedCollection of: (ParseNode | String | Integer) > multipurpose...
	statements <OrderedCollection of: ParseNode> the statements of the method being decompiled 
	lastPc <Integer>
	exit <Integer>
	caseExits <OrderedCollection of: Integer> - stack of exit addresses that have been seen in the branches of caseOf:'s
	lastJumpPc <Integer>
	lastReturnPc <Integer>
	limit <Integer>
	hasValue <Boolean>
	blockStackBase <Integer>
	numLocaltemps <Integer | Symbol> - number of temps local to a block; also a flag indicating decompiling a block
	blockStartsToTempVars <Dictionary key: Integer value: (OrderedCollection of: String)>
	tempVarCount <Integer> number of temp vars used by the method
	lastJumpIfPcStack <OrderedCollection of: Integer> the value of program counter just before the last encountered conditional jumps
	tempReadCounts <Dictionary key: String value: Integer> the count of reads of temporaries, used to transform whiole lloops to to:[by:]do: loops accurately!
!Object methodsFor: 'testing' stamp: 'eem 1/4/2025 18:34:20'!
             isCompiledCode

	^ false! !
!CompiledMethod methodsFor: 'accessing' stamp: 'eem 2/19/2012 10:59'!
                              clearSignFlag
	"Clear the sign flag bit.  The sign flag bit may be
	 used by the VM to select an alternate bytecode set."

	self signFlag ifTrue:
		[self objectAt: 1 put: self header - SmallInteger minVal]! !
!CompiledMethod methodsFor: 'accessing' stamp: 'eem 2/19/2012 10:59'!
         setSignFlag
	"Set the sign flag bit.  The sign flag bit may be
	 used by the VM to select an alternate bytecode set."

	self signFlag ifFalse:
		[self objectAt: 1 put: self header + SmallInteger minVal]! !
!CompiledMethod methodsFor: 'accessing' stamp: 'eem 2/19/2012 10:59'!
            signFlag
	"Answer the sign flag bit.  The sign flag bit may be
	 used by the VM to select an alternate bytecode set."

	^self header < 0! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/4/2025 18:35:02'!
              isCompiledBlock

	^false! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/4/2025 18:34:53' overrides: 50344089!
          isCompiledCode

	^true! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/4/2025 18:35:10'!
isCompiledMethod

	^true! !
!CompiledMethod class methodsFor: 'method encoding' stamp: 'eem 10/9/2020 11:22'!
                  primaryBytecodeSetEncoderClass
	^PrimaryBytecodeSetEncoderClass! !
!CompiledMethod class methodsFor: 'method encoding' stamp: 'eem 10/9/2020 11:22'!
           secondaryBytecodeSetEncoderClass
	^SecondaryBytecodeSetEncoderClass! !
!CompiledMethod class methodsFor: 'accessing' stamp: 'eem 12/26/2024 13:45:51'!
         preferredBytecodeSetEncoderClass
	^PreferredBytecodeSetEncoderClass! !
!CompiledMethod class methodsFor: 'preferences' stamp: 'mt 10/15/2020 13:45:18.47243'!
  preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass
	"Set the class that determines the bytecode set used to compile methods with.
			[| nPrimary nSecondary |
			nPrimary := nSecondary := 0.
			self allSubInstancesDo:
				[:cm|
				cm header >= 0
					ifTrue: [nPrimary := nPrimary + 1]
					ifFalse: [nSecondary := nSecondary + 1]].
			{nPrimary. nSecondary}]"
	| nPrimary nSecondary |
	aBytecodeEncoderSubclass ifNil: [ "Use default value."
		PreferredBytecodeSetEncoderClass := nil.
		^ self preferredBytecodeSetEncoderClass: self preferredBytecodeSetEncoderClass].
	self assert: (aBytecodeEncoderSubclass includesBehavior: BytecodeEncoder).
	(aBytecodeEncoderSubclass == PrimaryBytecodeSetEncoderClass
	 or: [aBytecodeEncoderSubclass == SecondaryBytecodeSetEncoderClass]) ifTrue:
		[PreferredBytecodeSetEncoderClass := aBytecodeEncoderSubclass.
		 ^self].
	nPrimary := nSecondary := 0.
	self allSubInstancesDo:
		[:cm|
		 cm header >= 0
			ifTrue: [nPrimary := nPrimary + 1]
			ifFalse: [nSecondary := nSecondary + 1]].
	nPrimary = 0 ifTrue:
		[self installPrimaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	nSecondary = 0 ifTrue:
		[self installSecondaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	self error: 'Cannot set preferred bytecode set.  Both of the current sets appear to be in use.'! !
!ParseNode methodsFor: 'visiting' stamp: 'eem 1/3/2019 15:46'!
nodesWithPrecedingStatementsDo: aBinaryBlock
	self accept: (ParseNodeWithPrecedingStatementEnumerator ofBlock: aBinaryBlock)! !
!ParseNode methodsFor: 'private' stamp: 'mt 9/4/2019 09:21'!
   ifNilTemporary

	^ nil! !
!BytecodeEncoder methodsFor: 'testing' stamp: 'eem 1/10/2018 13:56'!
 supportsFullBlocks
	"Answer if the instruction set supports full closures (closure creation from
	 specfic methods instead of bytecodes embedded in an outer home method)."

	^self subclassResponsibility! !
!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 12/26/2024 11:32:36'!
                       isSpecialLiteralForPush: literal

	^self subclassResponsibility! !
!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 12/26/2024 11:31:27'!
  isSpecialLiteralForReturn: literal
	^literal == false
	  or: [literal == true
	  or: [literal == nil]]! !
!BytecodeEncoder methodsFor: 'accessing' stamp: 'eem 12/24/2024 16:40:27'!
           nextPC
	"Answer the pc to store in a node for source range identification when the node is associated with its following pc."
	^stream position + 1! !
!BytecodeEncoder methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 10:56'!
                         genPushNClosureTemps: numTemps
	"To reduce the number of bytecodes required, the embedded
	 block closure implementation uses explicit push nil instructions
	 to create block-local temps.  In bytecode sets supporting
	 FullBlockClosure/CompiledBlock this isn't needed and the
	 number of temps is derived from the block method header."
	numTemps timesRepeat: [self genPushSpecialLiteral: nil]! !
!BytecodeEncoder class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 14:12' overrides: 16920334!
            pushNilCode
	"Answer the pushNil bytecode."
	^self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'bytecode decoding' stamp: 'eem 8/8/2014 19:23'!
                               stackDeltaForPrimitive: primitiveIndex in: method
	"This is the default implementation.  Subclasses with inline primitives will need to override."
	^0! !
!BytecodeEncoder class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 16:05'!
         isReturnSelfFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return self from method."

	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'instruction stream support' stamp: 'eem 6/3/2024 10:25'!
                       isSuperSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send to super."

	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'testing' stamp: 'eem 10/9/2021 17:28'!
                      canBeSpecialLiteral: aLiteral
	"This check can be used to prevent unnecessary use of #scanBlockOrNilForLiteral:. For performance, this method summarizes specializations from all known bytecode encoders. It is not meant to be refined per bytecode encoder."

	aLiteral isVariableBinding ifTrue: [^false]. "a common case; don't waste time analysing..."
	
	aLiteral isSymbol ifTrue: [^ Smalltalk specialSelectors identityIncludes: aLiteral].
	aLiteral isCharacter ifTrue: [^ aLiteral asInteger <= 65535].
	aLiteral isInteger ifTrue: [^ aLiteral between: -32768 and: 32767].

	aLiteral == true ifTrue: [^ true].
	aLiteral == false ifTrue: [^ true].
	aLiteral == nil ifTrue: [^ true].

	^ false! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:28'!
                          genBranchPopFalse: distance
	(distance > 0 and: [distance < 9]) ifTrue:
		["192-199	11000 iii			Pop and Jump 0n False iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 191 + distance.
		 ^self].
	^self genBranchPopFalseLong: distance! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:33'!
   genBranchPopFalseLong: distance
	"239		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)	"
	| distanceMod256 |
	(distance < 0 or: [distance > 32767]) ifTrue:
		[^self outOfRangeError: 'distance' index: distance range: 0 to: 32767].
	distanceMod256 := (distance < 0 or: [distance > 255])
							ifTrue:
								[self genUnsignedSingleExtendB: (distance bitShift: -8).
								 distance bitAnd: 255]
							ifFalse: [distance].
	stream
		nextPut: 239;
		nextPut: distanceMod256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:31'!
      genBranchPopTrue: distance
	(distance > 0 and: [distance < 9]) ifTrue:
		["184-191	10111 iii			Pop and Jump 0n True iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 183 + distance.
		 ^self].
	^self genBranchPopTrueLong: distance! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:33'!
      genBranchPopTrueLong: distance
	"238		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)"
	| distanceMod256 |
	(distance < 0 or: [distance > 32767]) ifTrue:
		[^self outOfRangeError: 'distance' index: distance range: 0 to: 32767].
	(distance > 0 and: [distance < 9]) ifTrue:
		["184-191	10111 iii			Pop and Jump 0n True iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 183 + distance.
		 ^self].
	distanceMod256 := (distance < 0 or: [distance > 255])
							ifTrue:
								[self genUnsignedSingleExtendB: (distance bitShift: -8).
								 distance bitAnd: 255]
							ifFalse: [distance].
	stream
		nextPut: 238;
		nextPut: distanceMod256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 7/25/2016 14:10'!
     genCallInlinePrimitive: primitiveIndex
	"	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are not used)"
	"N.B. We could have made CallPrimitive a 2-byte code taking an extension, but that would
	 complicate the VM's determination of the primitive number and the primitive error code
	 store since the extension, being optional, would make the sequence variable length."
	(primitiveIndex < 1 or: [primitiveIndex > 32767]) ifTrue:
		[self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 32767].
	stream
		nextPut: 248;
		nextPut: (primitiveIndex bitAnd: 255);
		nextPut: (primitiveIndex bitShift: -8) + 128! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 10:11'!
      genCallPrimitive: primitiveIndex
	"248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are not used)"
	"N.B. We could have made CallPrimitive a 2-byte code taking an extension, but that would
	 complicate the VM's determination of the primitive number and the primitive error code
	 store since the extension, being optional, would make the sequence variable length."
	(primitiveIndex < 1 or: [primitiveIndex > 32767]) ifTrue:
		[self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 32767].
	stream
		nextPut: 248;
		nextPut: (primitiveIndex bitAnd: 255);
		nextPut: (primitiveIndex bitShift: -8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:57'!
                   genDup
	"83			01010011			Duplicate Stack Top"
	stream nextPut: 83! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:59'!
         genJump: distance
	(distance > 0 and: [distance < 9]) ifTrue:
		["176-183	10110 iii			Jump iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 175 + distance.
		 ^self].
	"237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	^self genJumpLong: distance! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:59'!
                   genJumpLong: distance
	"237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	(distance between: -32768 and: 32767) ifFalse:
		[^self outOfRangeError: 'index' index: distance range: -32768 to: 32767].
	(distance < 0 or: [distance > 255]) ifTrue:
		[self genSignedSingleExtendB: (distance bitShift: -8)].
	stream
		nextPut: 237;
		nextPut: (distance bitAnd: 255)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:27'!
   genNop
	"95			01011111			Nop"
	stream nextPut: 95! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 17:01'!
                         genPop
	"216		11011000			Pop Stack Top"
	stream nextPut: 216! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 1/4/2025 17:20:44'!
           genPushCharacter: aCharacterOrCode
	"233		11101001	i i i i i i i i	Push Character #iiiiiiii (+ Extend A * 256)"
	"Why restrict the range to 16 bits when we could encode arbitrary 32-bit Characters?
	 Well, 16 bits requires 4 bytes (extA + byte, 233 + byte) and so beyond this range we
	 lose space verses a single-byte pushLiteral and a 4 byte Character literal on 32-bits.
	 And generating the same bytecode on 64-bit and 32-bit versions is important if we
	 want to be able to load binary code from one to the other (e.g. via Fuel)."
	| code |
	code := aCharacterOrCode isInteger ifTrue: [aCharacterOrCode] ifFalse: [aCharacterOrCode codePoint].
	(code < 0 or: [code > 65535]) ifTrue:
		[^self outOfRangeError: 'character' index: code range: 0 to: 65535].
	(code > 255) ifTrue:
		[self genUnsignedSingleExtendA: (code bitShift: -8)].
	stream
		nextPut: 233;
		nextPut: (code bitAnd: 255)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 17:01'!
                 genPushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize
	"250		11111010 eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ Ext A // 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B * 256). ee = num extensions"
	"Including numExtensions makes decoding the bytecode quicker since it obviates having to scan from the beginning of a method."
	| numExtensions numCopiedMod8 numArgsMod8 extA |
	(jumpSize < 0 or: [jumpSize > 65535]) ifTrue:
		[^self outOfRangeError: 'block size' index: jumpSize range: 0 to: 65535].
	(numCopied < 0 or: [numCopied > 127]) ifTrue:
		[^self outOfRangeError: 'num copied' index: numCopied range: 0 to: 127].
	(numArgs < 0 or: [numArgs > 127]) ifTrue:
		[^self outOfRangeError: 'num args' index: numArgs range: 0 to: 127].
	extA := numExtensions := 0.
	(numArgsMod8 := numArgs) > 7 ifTrue:
		[extA := numArgs // 8.
		 numArgsMod8 := numArgsMod8 \\ 8].
	(numCopiedMod8 := numCopied) > 7 ifTrue:
		[extA := extA + (numCopied // 8 * 16).
		 numCopiedMod8 := numCopiedMod8 \\ 8].
	extA ~= 0 ifTrue:
		[self genUnsignedSingleExtendA: extA.
		 numExtensions := 1].
	jumpSize > 255 ifTrue:
		[numExtensions := numExtensions + 1.
		 self genUnsignedSingleExtendB: jumpSize // 256].
	stream
		nextPut: 250;
		nextPut: (numExtensions bitShift: 6) + (numCopiedMod8 bitShift: 3) + numArgsMod8;
		nextPut: (jumpSize bitAnd: 16rFF)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/1/2015 10:32'!
 genPushConsArray: size
	(size < 0 or: [size > 127]) ifTrue:
		[^self outOfRangeError: 'size' index: size range: 0 to: 127].
	"231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)"
	stream
		nextPut: 231;
		nextPut: size + 128! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 3/23/2017 16:37'!
 genPushFullClosure: compiledBlockLiteralIndex numCopied: numCopied
	"By default the closure will have an outer context and the receiver will be fetched from the current context"
	self genPushFullClosure: compiledBlockLiteralIndex numCopied: numCopied receiverOnStack: false ignoreOuterContext: false! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 3/23/2017 16:48'!
                              genPushFullClosure: compiledBlockLiteralIndex numCopied: numCopied receiverOnStack: receiverOnStack ignoreOuterContext: ignoreOuterContext
	"*	249		11111001 	xxxxxxxx	siyyyyyy	push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1"
	| extendedIndex |
	(numCopied < 0 or: [numCopied > 64]) ifTrue:
		[self outOfRangeError: 'num copied' index: numCopied range: 1 to: 64].
	(compiledBlockLiteralIndex < 0 or: [compiledBlockLiteralIndex > 32767]) ifTrue:
		[^self outOfRangeError: 'index' index: compiledBlockLiteralIndex range: 0 to: 32767].
	(extendedIndex := compiledBlockLiteralIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 249;
		nextPut: extendedIndex;
		nextPut: receiverOnStack asBit << 7 + (ignoreOuterContext asBit << 6) + numCopied! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/12/2012 15:12'!
                      genPushInstVar: instVarIndex
	(instVarIndex between: 0 and: 15) ifTrue:
		["0-15 	0000iiii 	Push Receiver Variable #iiii"
		 stream nextPut: 0 + instVarIndex.
		 ^self].
	self genPushInstVarLong: instVarIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:28'!
                          genPushInstVarLong: instVarIndex
	"226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"
	"See also MaybeContextInstanceVariableNode"
	(instVarIndex < 0 or: [instVarIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535].
	instVarIndex > 255 ifTrue:
		[self genUnsignedSingleExtendA: instVarIndex // 256].
	stream
		nextPut: 226;
		nextPut: instVarIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:22'!
                           genPushInteger: anInteger
	"80			01010000				Push 0
	 81			01010001				Push 1
	 232		11101000	i i i i i i i i	Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	"Why restrict the range to 16 bits when we could encode arbitrarily large integers?
	 Well, 16 bits requires 4 bytes (extB + byte, 78 + byte) and so beyond this range we lose space
	 verses a single-byte pushLiteral and a 4 byte integer literal on 32-bits.  And generating the same
	 bytecode on 64-bit and 32-bit is important if we want to be able to load binary code from one to
	 the other (e.g. via Fuel)."
	anInteger = 0 ifTrue:
		[stream nextPut: 80.
		 ^self].
	anInteger = 1 ifTrue:
		[stream nextPut: 81.
		 ^self].
	(anInteger < -32768 or: [anInteger > 32767]) ifTrue:
		[^self outOfRangeError: 'integer' index: anInteger range: -32768 to: 32767].
	(anInteger < 0 or: [anInteger > 255]) ifTrue:
		[self genSignedSingleExtendB: (anInteger bitShift: -8)].
	stream
		nextPut: 232;
		nextPut: (anInteger bitAnd: 255)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 10:25'!
  genPushLiteral: literalIndex
	| extendedIndex |
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex < 32 ifTrue: 
		["32-63 	001iiiii 	Push Literal #iiiii"
		 stream nextPut: 32 + literalIndex.
		 ^self].
	"228		11100100	i i i i i i i i	Push Literal #iiiiiiii (+ Extend A * 256)"
	(extendedIndex := literalIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 228;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/18/2012 14:51'!
                genPushLiteralVar: literalIndex
	| extendedIndex |
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex < 16 ifTrue: 
		["16-31		0001 i i i i		Push Literal Variable #iiii"
		 stream nextPut: 16 + literalIndex.
		 ^self].
	"227		11100011	i i i i i i i i	Push Literal Variable #iiiiiiii (+ Extend A * 256)"
	(extendedIndex := literalIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 227;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 11/4/2012 15:01'!
                         genPushNewArray: size
	(size < 0 or: [size > 127]) ifTrue:
		[^self outOfRangeError: 'size' index: size range: 0 to: 127].
	"231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)"
	stream
		nextPut: 231;
		nextPut: size! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/18/2012 14:43'!
     genPushReceiver
	"76			01001100		Push Receiver"
	stream nextPut: 76! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/4/2016 18:02'!
        genPushRemoteTemp: tempIndex inVectorAt: tempVectorIndex
	"251		11111011 	kkkkkkkk	sjjjjjjj		Push Temp At kkkkkkkk In Temp Vector At: jjjjjjj, s = 1 implies remote inst var access instead of remote temp vector access"
	(tempIndex < 0 or: [tempIndex >= 256]) ifTrue:
		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].
	(tempVectorIndex < 0 or: [tempVectorIndex >= 128]) ifTrue:
		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127].
	stream
		nextPut: 251;
		nextPut: tempIndex;
		nextPut: tempVectorIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 1/2/2018 13:16'!
                      genPushSpecialLiteral: aLiteral
	"77			01001101			Push true
	 78			01001110			Push false
	 79			01001111			Push nil
	 80			01010000			Push 0
	 81			01010001			Push 1
	 232		11101000	iiiiiiii		Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
	 233		11101001	i i i i i i i i	Push Character #iiiiiiii (+ Extend B * 256)"
	| index |
	aLiteral isInteger ifTrue:
		[aLiteral == 0 ifTrue:
			[stream nextPut: 80.
			 ^self].
		 aLiteral == 1 ifTrue:
			[stream nextPut: 81.
			 ^self].
		 ^self genPushInteger: aLiteral].
	aLiteral isCharacter ifTrue:
		[^self genPushCharacter: aLiteral].
	index := #(true false nil)
					indexOf: aLiteral
					ifAbsent: [^self error: 'push special literal: ', aLiteral printString,  ' is not one of true false nil'].
	stream nextPut: 76 + index! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:52'!
                    genPushTemp: tempIndex
	(tempIndex < 0 or: [tempIndex > 63]) ifTrue:
		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].
	tempIndex < 12 ifTrue: 
		["64-71		01000 i i i		Push Temporary Variable #iii
		   72-75	010010 i i		Push Temporary Variable #ii + 8"
		 stream nextPut: 64 + tempIndex.
		 ^self].
	"229		11100101	i i i i i i i i	Push Temporary Variable #iiiiiiii"
	stream
		nextPut: 229;
		nextPut: tempIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 7/28/2014 20:51'!
                            genPushThisContext
	"82			01010010			Push thisContext, (then e.g. Extend B 1 = push thisProcess)"
	stream nextPut: 82! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 1/5/2018 12:12'!
                     genReturnNilToCaller
	"93			01011101			BlockReturn nil [* return from enclosing block N, ExtA]"
	"If extended, the least significant bit of the extension determines if we return to the caller or not
	 and the most significant bits determine how many levels of the static chain to return from.
		ExtA = iiiiiiij
		iiiiiii=0,j=0	=>	return to caller
		iiiiiii=0,j=1	=>	illegal
		iiiiiii=1,j=0	=>	return to outerContext
		iiiiiii=1,j=1	=>	return to outerContext sender/return from outerContext
		iiiiiii=2,j=0	=>	return to outerContext outerContext
		iiiiiii=2,j=1	=>	return to outerContext outerContext sender/return from outerContext outerContext
		etc"

	stream nextPut: 93! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:56'!
          genReturnReceiver
	"88-91		010110 ii			Return Receiver/true/false/nil"
	stream nextPut: 88! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:58'!
                genReturnSpecialLiteral: aLiteral
	"88-91		010110 ii			Return Receiver/true/false/nil"
	| index |
	index := #(true false nil) indexOf: aLiteral ifAbsent: 0.
	index = 0 ifTrue:
		[^self error: 'return special literal: ', aLiteral printString,  ' is not one of true false nil'].
	stream nextPut: 88 + index! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:06'!
                          genReturnTop
	"92		1011100		Return Stack Top From Message"
	stream nextPut: 92! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/1/2015 09:59'!
                             genReturnTopToCaller
	"94		01011110		Return Stack Top From Block [* return from enclosing block N, ExtA]"
	"If extended, the least significant bit of the extension determines if we return to the caller or not
	 and the most significant bits determine how many levels of the static chain to return from.
		ExtA = iiiiiiij
		iiiiiii=0,j=0	=>	return to caller
		iiiiiii=0,j=1	=>	illegal
		iiiiiii=1,j=0	=>	return to outerContext
		iiiiiii=1,j=1	=>	return to outerContext sender/return from outerContext
		iiiiiii=2,j=0	=>	return to outerContext outerContext
		iiiiiii=2,j=1	=>	return to outerContext outerContext sender/return from outerContext outerContext
		etc"

	stream nextPut: 94! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 14:27'!
genSend: selectorLiteralIndex numArgs: nArgs
	| extendedIndex extendedNArgs |
	(selectorLiteralIndex < 0 or: [selectorLiteralIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535].
	(nArgs < 0 or: [nArgs > 31]) ifTrue:
		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].
	(selectorLiteralIndex < 16 and: [nArgs < 3]) ifTrue: 
	 	["128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
		  144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
		  160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments"
		 stream nextPut: 128 + (nArgs * 16) + selectorLiteralIndex.
		 ^self].
	(extendedIndex := selectorLiteralIndex) > 31 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 32.
		 extendedIndex := extendedIndex \\ 32].
	(extendedNArgs := nArgs) > 7 ifTrue:
		[self genUnsignedSingleExtendB: extendedNArgs // 8.
		 extendedNArgs := extendedNArgs \\ 8].
	"234		11101010	i i i i i j j j	Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
	stream
		nextPut: 234;
		nextPut: extendedNArgs + (extendedIndex * 8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 15:26'!
                           genSendDirectedSuper: selectorLiteralIndex numArgs: nArgs
	| extendedIndex |
	(selectorLiteralIndex < 0 or: [selectorLiteralIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535].
	(nArgs < 0 or: [nArgs > 31]) ifTrue:
		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].
	(extendedIndex := selectorLiteralIndex) > 31 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 32.
		 extendedIndex := extendedIndex \\ 32].
	"Bit 6 of the ExtB byte is the directed send flag.  Bit 6 allows for future expansion to up to 255 args."
	self genUnsignedSingleExtendB: nArgs // 8 + 64.
	"235		11101011	iiiiijjj		Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
	stream
		nextPut: 235;
		nextPut: nArgs \\ 8 + (extendedIndex * 8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:21'!
                genSendSpecial: specialSelectorIndex numArgs: nArgs
	self assert: (specialSelectorIndex between: 1 and: Smalltalk specialSelectorSize).
	self assert: nArgs = (Smalltalk specialNargsAt: specialSelectorIndex).
	"Special selector sends.
		96-111		0110 iiii			Send Arithmetic Message #iiii #(#+ #- #< #> #'<=' #'>=' #= #'~=' #* #/ #'\\' #@ #bitShift: #'//' #bitAnd: #bitOr:)
		112-119	01110 iii			Send Special Message #iii #(#at: #at:put: #size ? ? ? #'==' class ? value value: ? ? ? ? ?)"

	stream nextPut: specialSelectorIndex + 95! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 15:26'!
                         genSendSuper: selectorLiteralIndex numArgs: nArgs
	| extendedIndex extendedNArgs |
	(selectorLiteralIndex < 0 or: [selectorLiteralIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535].
	(nArgs < 0 or: [nArgs > 31]) ifTrue:
		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].
	(extendedIndex := selectorLiteralIndex) > 31 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 32.
		 extendedIndex := extendedIndex \\ 32].
	(extendedNArgs := nArgs) > 7 ifTrue:
		[self genUnsignedSingleExtendB: extendedNArgs // 8.
		 extendedNArgs := extendedNArgs \\ 8].
	"235		11101011	iiiiijjj		Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
	stream
		nextPut: 235;
		nextPut: extendedNArgs + (extendedIndex * 8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/22/2012 16:07'!
                          genSignedSingleExtendB: extendedIndex
	(extendedIndex between: -128 and: 127) ifFalse:
		[^self outOfRangeError: 'index' index: extendedIndex range: -128 to: 127].
	"225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)"
	stream
		nextPut: 225;
		nextPut: (extendedIndex >= 0 ifTrue: [extendedIndex] ifFalse: [extendedIndex + 256]) ! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:27'!
                 genStoreInstVar: instVarIndex
	"243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	self genStoreInstVarLong: instVarIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:28'!
                      genStoreInstVarLong: instVarIndex
	"243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	(instVarIndex < 0 or: [instVarIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535].
	instVarIndex > 255 ifTrue:
		[self genUnsignedSingleExtendA: instVarIndex // 256].
	stream
		nextPut: 243;
		nextPut: instVarIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:35'!
             genStoreLiteralVar: literalIndex
	"244		11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256)"
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex > 255 ifTrue: 
		[self genUnsignedSingleExtendA: literalIndex // 256].
	stream
		nextPut: 244;
		nextPut: literalIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:37'!
             genStorePopInstVar: instVarIndex
	"200-207	11001 iii			Pop and Store Receiver Variable #iii
	 240		11110000	iiiiiiii	Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	(instVarIndex < 0 or: [instVarIndex > 7]) ifTrue:
		[^self genStorePopInstVarLong: instVarIndex].
	stream nextPut: 200 + instVarIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:37'!
                  genStorePopInstVarLong: instVarIndex
	"240		11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	(instVarIndex < 0 or: [instVarIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535].
	instVarIndex > 255 ifTrue:
		[self genUnsignedSingleExtendA: instVarIndex // 256].
	stream
		nextPut: 240;
		nextPut: instVarIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:39'!
  genStorePopLiteralVar: literalIndex
	"241		11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)"
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex > 255 ifTrue: 
		[self genUnsignedSingleExtendA: literalIndex // 256].
	stream
		nextPut: 241;
		nextPut: literalIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/4/2016 18:01'!
   genStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex
	"*	253	(3)	11111101 	kkkkkkkk	sjjjjjjj		Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access"
	(tempIndex < 0 or: [tempIndex >= 256]) ifTrue:
		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].
	(tempVectorIndex < 0 or: [tempVectorIndex >= 128]) ifTrue:
		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127].
	stream
		nextPut: 253;
		nextPut: tempIndex;
		nextPut: tempVectorIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:43'!
     genStorePopTemp: tempIndex
	"208-215	11010 iii			Pop and Store Temporary Variable #iii
	 242		11110010	iiiiiiii	Pop and Store Temporary Variable #iiiiiiii"
	(tempIndex < 0 or: [tempIndex > 63]) ifTrue:
		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].
	tempIndex < 8 ifTrue:
		[stream nextPut: 208 + tempIndex.
		 ^self].
	stream
		nextPut: 242;
		nextPut: tempIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/4/2016 18:02'!
          genStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex
	"*252	(3)	11111100 	kkkkkkkk	sjjjjjjj		Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access"
	(tempIndex < 0 or: [tempIndex >= 256]) ifTrue:
		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].
	(tempVectorIndex < 0 or: [tempVectorIndex >= 128]) ifTrue:
		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127].
	stream
		nextPut: 252;
		nextPut: tempIndex;
		nextPut: tempVectorIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/1/2015 09:58'!
                  genStoreTemp: tempIndex
	"245		11110110	iiiiiiii		Store Temporary Variable #iiiiiiii"
	(tempIndex < 0 or: [tempIndex > 63]) ifTrue:
		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].
	stream
		nextPut: 245;
		nextPut: tempIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 8/1/2014 06:53'!
                     genTrapIfNotInstanceOf: literalIndex
	"*	236		11101100	iiiiiiii		Trap If Not Instance Of Behavior/Array Of Behavior #iiiiiiii (+ Extend A * 256, where Extend A >= 0)"

	| extendedIndex |
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65536].
	(extendedIndex := literalIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 236;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/18/2012 14:47'!
       genUnsignedMultipleExtendA: extendedIndex
	"224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)"
	extendedIndex > 255 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 256].
	stream
		nextPut: 224;
		nextPut: extendedIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 7/25/2016 14:23'!
           genUnsignedSingleExtendA: extendedIndex
	(extendedIndex between: 0 and: 255) ifFalse:
		[^self outOfRangeError: 'index' index: extendedIndex range: 0 to: 255].
	"224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	ExtA is normally unsigned."
	stream
		nextPut: 224;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 7/25/2016 14:23'!
                        genUnsignedSingleExtendB: extendedIndex
	(extendedIndex between: 0 and: 255) ifFalse:
		[^self outOfRangeError: 'index' index: extendedIndex range: 0 to: 255].
	"225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B).
	ExtB is normally signed"
	stream
		nextPut: 225;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'in-line primitive generation' stamp: 'eem 4/7/2014 16:38'!
                 genInlineSmallIntegerAdd
	^self genCallInlinePrimitive: 0! !
!EncoderForSistaV1 methodsFor: 'special literal encodings' stamp: 'eem 1/4/2025 17:20:28' overrides: 50344210!
                    isSpecialLiteralForPush: literal
	^literal isInteger
		ifFalse:
			[literal isCharacter
				ifFalse:
					[false == literal
					 or: [true == literal
					 or: [nil == literal]]]
				ifTrue:
					[literal codePoint between: 0 and: 65535]]
	 	ifTrue:
			[literal between: -32768 and: 32767]! !
!EncoderForSistaV1 methodsFor: 'accessing' stamp: 'eem 6/15/2016 14:37' overrides: 16853469!
                             maxIndexableLiterals
	"Answer the maximum number of literals supported by the receiver's
	 bytecode set."
	^65536! !
!EncoderForSistaV1 methodsFor: 'testing' stamp: 'eem 12/24/2024 16:35:45' overrides: 50344200!
            supportsFullBlocks
	"Answer if the instruction set supports full closures (closure creation from
	 specfic methods instead of bytecodes embedded in an outer home method).

	N.B. While the Sista set *does* support full blocks we are not using them yet.
	So this implementation, unlike e.g. Squeak, answers false."

	^false! !
!EncoderForSistaV1 methodsFor: 'method generation' stamp: 'eem 8/1/2014 22:45' overrides: 16801958!
                       computeMethodHeaderForNumArgs: numArgs numTemps: numTemps numLits: numLits primitive: primitiveIndex
	numTemps > 63 ifTrue:
		[^self error: 'Cannot compile -- too many temporary variables'].	
	numLits > 65535 ifTrue:
		[^self error: 'Cannot compile -- too many literals'].
	^SmallInteger minVal "sign bit is the flag for the alternative bytecode set"
	+ (numArgs bitShift: 24)
	+ (numTemps bitShift: 18)
	"+ (largeBit bitShift: 17)" "largeBit gets filled in later"
	+ numLits
	+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:54' overrides: 16802132!
                  bindingReadScanBlockFor: litVarIndex using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of the value of the binding with zero-relative index litVarIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	16-31		0001 i i i i				Push Literal Variable #iiii
	 *	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	227		11100011	i i i i i i i i	Push Literal Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b < 32 and: [b >= 16 and: [b - 16 = litVarIndex]])
	    or: [b = 227
			and: [scanner followingByte + prevext = litVarIndex]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' overrides: 16802145!
                          bindingWriteScanBlockFor: litVarIndex using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for writes of the value of the binding with zero-relative index litVarIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	241		11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)
	 *	244		11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b = 241 or: [b = 244])
	   and: [scanner followingByte + prevext = litVarIndex]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 6/16/2018 16:29' overrides: 16802158!
         createClosureScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for block closure creation bytecodes.  Note that with this interface we can't answer
	 true for the extension in front of a push closure bytecode and so the interface may
	 have to change at some point."

	"*	224	11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	225	11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	**	249	11111001 	xxxxxxxx	siyyyyyy	push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1
	 **	250	11111010 	eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
	^[:b| b >= 249 and: [b <= 250]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:56' overrides: 16802224!
                               extensionsAt: bcpc in: method into: aTrinaryBlock
	"If the bytecode at pc is an extension then evaluate aBinaryBlock with the values of extA and extB and number of extension *bytes*.
	 If the bytecode at pc is not extended then evaluate aBinaryBlock with 0 and 0.
	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	225		11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)"
 
	| scanpc byte extByte extA extB |
	scanpc := bcpc.
	"There may be an extension (it could be a false positive).  We must scan as fast as possible..."
	extA := extB := 0.
	[byte := method at: scanpc.
	 byte >= 224 and: [byte <= 225]] whileTrue: 
		[extByte := method at: scanpc + 1.
		 scanpc := scanpc + 2.
		 byte = 224
			ifTrue:
				[extA := (extA bitShift: 8) + extByte]
			ifFalse:
				[extB := (extB = 0 and: [extByte > 127])
					ifTrue: [extByte - 256]
					ifFalse: [(extB bitShift: 8) + extByte]]].
	^aTrinaryBlock value: extA value: extB value: scanpc - bcpc


"Why use
	byte >= 224 and: [byte <= 225]
 and not
	(byte bitAnd: 16rFE) = 16rE0
 ?
 | n |
 n := 100000000.
 #(0 224) collect:
	[:byte|
	{ Time millisecondsToRun: [1 to: n do: [:i| (byte >= 224 and: [byte <= 225]) ifTrue: []]].
	   Time millisecondsToRun: [1 to: n do: [:i| (byte bitAnd: 16rFE) = 16rE0 ifTrue: []]] }] #(#(297 599) #(702 671))"! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:57' overrides: 16802167!
     instVarReadScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	0-15		0000 i i i i 				Push Receiver Variable #iiii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b < 16 and: [b = varIndexCode])
	    or: [b = 226
			and: [scanner followingByte + prevext = varIndexCode]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' overrides: 16802180!
                      instVarWriteScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for writes of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	200-207	11001 iii			Pop and Store Receiver Variable #iii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	240		11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	*	243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b >= 200
	    and: [b < 208
	    and: [b - 200 = varIndexCode]])
	   or: [(b = 240 or: [b = 243])
		  and: [scanner followingByte + prevext = varIndexCode]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' overrides: 16802266!
             interpretJumpIfCondIn: anInstructionStream
	"Double-dispatch through the encoder to select the correct conditional jump decoder for the instruction set."
	^anInstructionStream interpretSistaV1JumpIfCond! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 19:00' overrides: 16802275!
 interpretJumpIn: anInstructionStream
	"Double-dispatch through the encoder to select the correct unconditional jump decoder for the instruction set."
	^anInstructionStream interpretSistaV1Jump! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'TraitTest 9/2/2019 17:07' overrides: 16802193!
      markerOrNilFor: aMethod
	"If aMethod is a marker method, answer the symbol used to mark it.  Otherwise
	 answer nil.  What is a marker method?  It is method with body like 
		'self subclassResponsibility' or '^ self subclassResponsibility' 
	 used to indicate ('mark') a special property.

	Marker methods compile to two bytecode forms, this:
		self
		send: <literal 1>
		pop
		returnSelf
	or this:
		self
		send: <literal 1>
		returnTop"
	| expectedHeaderPlusLliteralSize e byte |
	expectedHeaderPlusLliteralSize := Smalltalk wordSize * 4.
	^(((e := aMethod endPC - expectedHeaderPlusLliteralSize) = 3 or: [e = 4]) 
	  and: [aMethod numLiterals = 3
	  and: [(aMethod at: expectedHeaderPlusLliteralSize + 1) = 16r4C "push self"
	  and: [(aMethod at: expectedHeaderPlusLliteralSize + 2) = 16r80 "send"
	  and: [(byte := aMethod at: expectedHeaderPlusLliteralSize + 3) = 16rD8 "pop" or: [byte = 16r5C "returnTop"]]]]])
		ifTrue: [aMethod literalAt: 1]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:00' overrides: 16802219!
                   bytecodeSize: bytecode
	"Answer the number of bytes in the bytecode."
	bytecode < 224 ifTrue: [^1].
	bytecode < 248 ifTrue: [^2].
	^3! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:00' overrides: 16802284!
   interpretNextInstructionFor: aClient in: anInstructionStream
	"Double-dispatch through the encoder to select the correct instruction set decoder."
	^anInstructionStream interpretNextSistaV1InstructionFor: aClient! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:01' overrides: 16802294!
                    isBlockReturnAt: pc in: method
	"Answer whether the bytecode at pc is a return from block."
	"	93			01011101			BlockReturn nil
	 *	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]"
	^(self nonExtensionBytecodeAt: pc in: method) between: 93 and: 94! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:03' overrides: 16802301!
                             isBranchIfFalseAt: pc in: method
	"Answer whether the bytecode at pc is a conditional branch-if-false."

	"	192-199	11000 iii				Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	 *	239		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)"
	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 192 and: [byte <= 199 or: [byte = 239]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:04' overrides: 16802309!
 isBranchIfTrueAt: pc in: method
	"Answer whether the bytecode at pc is a conditional branch-if-true."

	"	184-191	10111 iii				Pop and Jump 0n True iii +1 (i.e., 1 through 8)
	 *	238		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0))"
	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 184 and: [byte <= 191 or: [byte = 238]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:17' overrides: 16802317!
    isExtension: bytecode
	"Answer if the bytecode is an extension bytecode, i.e. one that extends
	 the range of the following bytecode."
	^bytecode >= 16rE0 and: [bytecode <= 16rE1]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:06' overrides: 16802326!
                     isJumpAt: pc in: method
	"Answer whether the bytecode at pc is an (unconditional) jump."

	"	176-183	10110 iii				Jump iii + 1 (i.e., 1 through 8)
	 *	225		11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 *	237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 176 and: [byte <= 183 or: [byte = 237]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 13:29' overrides: 16802333!
       isJustPopAt: pc in: method
	"Answer whether the bytecode at pc is a pop."

	^(method at: pc) = 216 "216		11011000			Pop Stack Top"! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:11' overrides: 16802358!
      isReturnAt: pc in: method
	"Answer whether the bytecode at pc is a return from block."
	"	88-91		010110 ii			Return Receiver/true/false/nil
		92			01011100			Return top
		93			01011101			BlockReturn nil
	 *	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]"
	^(self nonExtensionBytecodeAt: pc in: method) between: 88 and: 94! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 15:55' overrides: 50344259!
                  isReturnSelfFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return self from method."

	^(method at: pc) = 88! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 15:47' overrides: 16802365!
       isReturnTopFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return stack top from method."

	^(method at: pc) = 92! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 7/6/2024 18:53' overrides: 16802373!
   isSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send."

	"	96-111		0110 iiii			Send Arithmetic Message #iiii #(#+ #- #< #> #'<=' #'>=' #= #'~=' #* #/ #'\\' #@ #bitShift: #'//' #bitAnd: #bitOr:)
		112-119	01110 iii			Send Special Message #iii #(#at: #at:put: #size #next #nextPut: #atEnd #'==' class)
		120-127	01111 iii			Send Special Message #iii + 8 #(#'~~' #value #value: #do: #new #new: #x #y)
		128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
		144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
		160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments
	 **	234		11101010	iiiiijjj	Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
	 **	235		11101011	iiiiijjj	Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"

	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 96
	  and: [byte <= 175
		 or: [byte >= 234 and: [byte <= 235]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:19' overrides: 16802380!
  isStoreAt: pc in: method
	"Answer whether the bytecode at pc is a store or store-pop."

	"	200-207	11001 iii						Pop and Store Receiver Variable #iii
		208-215	11010 iii						Pop and Store Temporary Variable #iii
	 *	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	240		11110000	iiiiiiii				Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	 *	241		11110001	iiiiiiii				Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)
		242		11110010	iiiiiiii				Pop and Store Temporary Variable #iiiiiiii
	 *	243		11110011	iiiiiiii				Store Receiver Variable #iiiiiii (+ Extend A * 256)
	 *	244		11110100	iiiiiiii				Store Literal Variable #iiiiiiii (+ Extend A * 256)
		245		11110110	iiiiiiii				Store Temporary Variable #iiiiiiii

		252		11111100 	kkkkkkkk	jjjjjjjj	Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
		253		11111101 	kkkkkkkk	jjjjjjjj	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"

	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 200
	  and: [byte <= 215
		 or: [(byte between: 240 and: 245)
		 or: [(byte between: 252 and: 253)]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:18' overrides: 16802387!
      isStorePopAt: pc in: method
	"Answer whether the bytecode at pc is a store or store-pop."

	"	200-207	11001 iii						Pop and Store Receiver Variable #iii
		208-215	11010 iii						Pop and Store Temporary Variable #iii
	 *	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	240		11110000	iiiiiiii				Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	 *	241		11110001	iiiiiiii				Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)
		242		11110010	iiiiiiii				Pop and Store Temporary Variable #iiiiiiii

		253		11111101 	kkkkkkkk	jjjjjjjj	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"

	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 200
	  and: [byte <= 215
		 or: [(byte between: 240 and: 242)
		 or: [byte = 253]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 6/3/2024 10:29' overrides: 50344267!
               isSuperSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send to super."

	"**	235		11101011	iiiiijjj	Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"

	^235 = (self nonExtensionBytecodeAt: pc in: method)! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 4/6/2017 11:25' overrides: 16802394!
                       isSyntheticStoreAt: pc in: method for: anInstructionStream
	"Answer whether the bytecode at pc is a store or store-pop of an indirect temp vector,
	 which implement mutable closed-over variables in the the closure implementation.
	 Stores into temp vectors are not real stores.  N.B. pcPreviousTo:in:for: is slow, so filter
	 out any preceding bytecodes other than what looks like a pushNewArrayCode.  But the
	 pcPreviousTo:in:for: is still necessary, since the presence of a pcPreviousTo:in:for: in the
	 right place is potentially ambiguous, possibly part of a different bytecode sequence."

	^(self isTempStoreAt: pc in: method)
	  and: [pc - 2 >= method initialPC
	  and: [(method at: pc - 2) = self pushNewArrayCode
	  and: [(method at: pc - 1) <= 127
	  and: [pc - 2 = (self pcPreviousTo: pc in: method for: anInstructionStream)]]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 3/19/2019 09:11'!
                     isTempStoreAt: pc in: method
	"Answer if the bytecode at pc is a store or store-pop into a temporary variable.
	 208-215	11010 iii			Pop and Store Temporary Variable #iii
	 242		11110010	iiiiiiii		Pop and Store Temporary Variable #iiiiiiii
	 245		11110110	iiiiiiii		Store Temporary Variable #iiiiiiii"

	| byte |
	byte := method at: pc.
	^byte >= 208
	  and: [byte <= 215
			or: [byte = 242 or: [byte = 245]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 12/26/2020 19:27' overrides: 16802407!
              nonExtensionBytecodeAt: pc in: method
	"Answer the actual bytecode at pc in method, skipping past any preceding extensions."
	| thePC bytecode |
	thePC := pc.
	[self isExtension: (bytecode := method at: thePC)] whileTrue:
		[thePC := thePC + (self bytecodeSize: bytecode)].
	^bytecode! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 12/26/2020 19:27' overrides: 16802427!
           selectorToSendOrItselfFor: anInstructionStream in: method at: pc
	"If anInstructionStream is at a send bytecode then answer the send's selector,
	 otherwise answer anInstructionStream itself.  The rationale for answering
	 anInstructionStream instead of, say, nil, is that potentially any existing object
	 can be used as a selector, but since anInstructionStream postdates the method,
	 it can't be one of them.

	 The complication is that for convenience we allow the pc to point to the
	 raw send bytecode after its extension(s), or at the extension(s) preceding it.
	96-111		0110 iiii			Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	112-119	01110 iii			Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	120-127	01111 iii			Send Special Message #iii + 8 (~~ value value: do: new new: x y)
	128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
	144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
	160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments
	*	224	11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	225	11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	**	234	11101010	iiiiijjj		Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
	**	235	11101011	iiiiijjj	ExtendB < 64
										ifTrue: [Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments]
										ifFalse: [Send To Superclass of Stacked Class Literal Selector #iiiii (+ Extend A * 32) with jjj (+ (Extend B bitAnd: 63) * 8) Arguments"

	| byte |
	byte := method at: pc.
	byte < 96 ifTrue:
		[^anInstructionStream].
	byte <= 175 ifTrue: 
		["special byte or short send"
		 ^byte >= 128
			ifTrue: [method literalAt: (byte bitAnd: 15) + 1]
			ifFalse: [Smalltalk specialSelectorAt: byte - 95]].
	byte < 234 ifTrue: "need to check for either extension cuz order of extensions is not restricted. so extB could precede extA"
		[(byte >= 224 and: [byte <= 225]) ifTrue:
			[^self extensionsAt: pc in: method into:
				[:extA :extB :nExtBytes| | byteAfter index |
				byteAfter := method at: pc + nExtBytes.
				(byteAfter >= 234 and: [byteAfter <= 235])
					ifTrue:
						[index := ((method at: pc + nExtBytes + 1) bitShift: -3) + (extA bitShift: 5).
						 method literalAt: index + 1]
					ifFalse: [anInstructionStream]]].
		^anInstructionStream].
	byte > 235 ifTrue:
		[^anInstructionStream].
	"they could be extended..."
	^self extensionsFor: pc in: method into:
		[:extA :extB :nExtBytes| | index |
		 index := ((method at: pc + 1) bitShift: -3) + (extA bitShift: 5).
		 method literalAt: index + 1]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:21' overrides: 16802211!
                  superSendScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for super sends."

	"*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 **	235		11101011	iiiiijjj		Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
					
	^[:instr | instr = 235]! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:22' overrides: 16801985!
    callPrimitiveCode
	"Answer the call primitive bytecode, if it exists in the encoder's bytecode set, or nil if not.
	 248	11111000 	iiiiiiii	mjjjjjjj	Call Primitive #iiiiiiii + (jjjjjjj * 256) m=1 means inlined primitive, no hard return after execution."
	^248! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 3/29/2017 09:36' overrides: 16801992!
              createClosureCode
	"Answer the create closure bytecode, if it exists in the encoder's bytecode set, or nil if not.
	 Actually this code is that for a closure whose bytecodes are nested within its home method's."

	^250! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:23' overrides: 16802009!
                       pcOfBlockCreationBytecodeForBlockStartingAt: startpc in: method
	"Answer the pc of the push closure bytecode whose block starts at startpc in method.
	 May need to back up to include extension bytecodes."

	"*	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	225		11100001	bbbbbbbb			Extend B (Ext B = Ext B prev * 256 + Ext B)
	 **	250		11111010 	eeiiikkk		jjjjjjjj	Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
	| numExtensions |
	self assert: (method at: startpc - 3) = 250.
	numExtensions := (method at: startpc - 2) >> 6.
	^startpc - 3 - (numExtensions * 2)! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:24' overrides: 16802110!
                          pushClosureBytecodeSize
	"Answer the size of the push closure bytecode.
	 **	250		11111010 	eeiiikkk		jjjjjjjj	Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
	^3! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 11:26' overrides: 16802117!
     pushNewArrayCode
	"231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)"
	^231! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 14:15' overrides: 50344245!
                             pushNilCode
	"Answer the pushNil bytecode.
	 79			01001111			Push nil"
	^79! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 8/8/2014 19:40' overrides: 50344251!
       stackDeltaForPrimitive: primitiveIndex in: method
	"Answer the stack delta for the callPrimitive: bytecode (see my class comment).
	 There is no delta for non-inlined primitives (its implicitly 0 - method numArgs).
	 Inlined primitives are grouped by the thousand by argument count, 32 args max ;-)."
	^primitiveIndex < 32678
		ifTrue: [0]
		ifFalse: [primitiveIndex - 32768 // 1000]! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:24' overrides: 16802124!
                  unusedBytecode
	"Answer the opcode of a single-byte unused bytecode, if it exists in the encoder's bytecode set, or nil if not."
	^223! !
!EncoderForSistaV1 class methodsFor: 'scanning' stamp: 'eem 7/6/2024 19:01'!
         scanBlockOrNilForLiteral: aLiteral
	"Answer a block argument for CompiledMethod>>#scanFor: that answers
	 if the method refers to the literal implicitly via a special bytecode.
	 If the literal is not accessible via a special bytecode, answer nil."
	| value hi lo unextended |

	"96-111	0110 iiii			Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	 112-119	01110 iii			Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	 120-127	01111 iii			Send Special Message #iii + 8 #(#'~~' #value #value: #do: #new #new: #x #y)"
	self flag: #deprecated. "mt: Use CompiledCode>>#implicitLiteralsDo:."
	aLiteral isSymbol ifTrue:
		[value := 96 + ((Smalltalk specialSelectors indexOf: aLiteral ifAbsent: [^nil]) // 2).
		 ^[:byte| byte = value]].

	"80			01010000			Push 0
	 81			01010001			Push 1
	 232		11101000	iiiiiiii	Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)"
	aLiteral isInteger ifTrue:
		[aLiteral >= 0 ifTrue:
			[aLiteral <= 1 ifTrue:
				[value := aLiteral + 80.
				 ^[:byte| byte = value]].
			 aLiteral <= 255 ifTrue:
				[unextended := true. "Don't be fooled by extended cases with the same least significant byte!!"
				 ^[:b1 :b2| | found |
					found := b1 = 232 and: [b2 = aLiteral and: [unextended]].
					unextended := b1 ~= 16rE1.
					found]]].
		 (aLiteral between: -32768 and: 32767) ifFalse: [^nil].
		 lo := aLiteral bitAnd: 255.
		 hi := (aLiteral bitShift: -8) bitAnd: 255.
		 ^[:b1 :b2 :b3 :b4| b1 = 16rE1 and: [b2 = hi and: [b3 = 232 and: [b4 = lo]]]]].

	"233		11101001	iiiiiiii	Push Character #iiiiiiii (+ Extend B * 256)"
	aLiteral isCharacter ifTrue:
		[(value := aLiteral asInteger) <= 255 ifTrue:
			[unextended := true. "Don't be fooled by extended cases with the same least significant byte!!"
			 ^[:b1 :b2| | found |
				found := b1 = 233 and: [b2 = value and: [unextended]].
				unextended := b1 ~= 16rE1.
				found]].
		 ^value <= 65535 ifTrue:
			[lo := value bitAnd: 255.
			 hi := (value bitShift: -8) bitAnd: 255.
			 [:b1 :b2 :b3 :b4| b1 = 16rE1 and: [b2 = hi and: [b3 = 233 and: [b4 = lo]]]]]].

	"77			01001101			Push true
	 78			01001110			Push false
	 79			01001111			Push nil
	 88-91		010110 ii			Return Receiver/true/false/nil
	 93			01011101			BlockReturn nil"
	aLiteral == true ifTrue:
		[^[:byte| byte = 77 or: [byte = 89]]].
	aLiteral == false ifTrue:
		[^[:byte| byte = 78 or: [byte = 90]]].
	aLiteral == nil ifTrue:
		[^[:byte| byte = 79 or: [byte = 91 or: [byte = 93]]]].
	^nil! !
!EncoderForSistaV1 class methodsFor: 'testing' stamp: 'eem 10/9/2021 17:28' overrides: 50344274!
       canBeSpecialLiteral: aLiteral
	"This check can be used to prevent unnecessary use of #scanBlockOrNilForLiteral:."

	aLiteral isVariableBinding ifTrue: [^false]. "a common case; don't waste time analysing..."
	
	aLiteral isSymbol ifTrue: [^ Smalltalk specialSelectors identityIncludes: aLiteral].
	aLiteral isCharacter ifTrue: [^ aLiteral asInteger <= 65535].
	aLiteral isInteger ifTrue: [^ aLiteral between: -32768 and: 32767].

	aLiteral == true ifTrue: [^ true].
	aLiteral == false ifTrue: [^ true].
	aLiteral == nil ifTrue: [^ true].

	^ false! !
!EncoderForV3PlusClosures methodsFor: 'testing' stamp: 'eem 4/6/2017 10:39' overrides: 50344200!
                         supportsFullBlocks
	"Answer if the instruction set supports full closures (closure creation from
	 specfic methods instead of bytecodes embedded in an outer home method)."
	
	^false! !
!EncoderForV3PlusClosures methodsFor: 'special literal encodings' stamp: 'eem 8/12/2017 15:20' overrides: 50344210!
                   isSpecialLiteralForPush: literal
	^literal isInteger
		ifFalse:
			[false == literal
			 or: [true == literal
			 or: [nil == literal]]]
		ifTrue: [literal between: -1 and: 2]! !
!EncoderForV3PlusClosures class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 14:13' overrides: 50344245!
                            pushNilCode
	"Answer the pushNil bytecode.
	 112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]"
	^115! !
!EncoderForV3PlusClosures class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 15:55' overrides: 50344259!
       isReturnSelfFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return self from method."

	^(method at: pc) = 120! !
!EncoderForV3PlusClosures class methodsFor: 'instruction stream support' stamp: 'eem 6/3/2024 10:25' overrides: 50344267!
                               isSuperSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send to super."

	"132 		10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)
	 133 		10000101 jjjkkkkk 	Send Literal Selector #kkkkk To Superclass With jjj Arguments"

	| byte |
	byte := method at: pc.
	^byte = 133	"double extended do anything"
	  or: [byte = 132 and: [(method at: pc + 1) // 32 = 1]]! !
!EncoderForV3PlusClosures class methodsFor: 'scanning' stamp: 'mt 12/20/2023 13:51'!
            scanBlockOrNilForLiteral: aLiteral
	"Answer a block argument for CompiledMethod>>#scanFor: that answers
	 if the method refers to the literal implicitly via a special bytecode.
	 If the literal is not accessible via a special bytecode, answer nil."
	| value |
	"176-191 	1011iiii 	Send Arithmetic Message #iiii
	 192-207 	1100iiii 	Send Special Message #iiii"
	self flag: #deprecated. "mt: Use CompiledCode>>#implicitLiteralsDo:."
	(aLiteral isSymbol or: [aLiteral isInteger]) ifTrue:
		[value := aLiteral isSymbol
					ifTrue: [176 + ((Smalltalk specialSelectors indexOf: aLiteral ifAbsent: [^nil]) // 2)]
					ifFalse: [(aLiteral between: -1 and: 2) ifFalse: [^nil].
							aLiteral + 117].
		 ^[:byte| byte = value]].
	"112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]
	 120-123 	011110ii 	Return (receiver, true, false, nil) [ii] From Message"
	aLiteral == true ifTrue:
		[^[:byte| byte = 113 or: [byte = 121]]].
	aLiteral == false ifTrue:
		[^[:byte| byte = 114 or: [byte = 122]]].
	aLiteral == nil ifTrue:
		[^[:byte| byte = 115 or: [byte = 123]]].
	^nil! !
!EncoderForV3PlusClosures class methodsFor: 'testing' stamp: 'eem 10/9/2021 17:28' overrides: 50344274!
                         canBeSpecialLiteral: aLiteral
	"This check can be used to prevent unnecessary use of #scanBlockOrNilForLiteral:."

	aLiteral isVariableBinding ifTrue: [^false]. "a common case; don't waste time analysing..."

	aLiteral isSymbol ifTrue: [^ Smalltalk specialSelectors identityIncludes: aLiteral].
	aLiteral isInteger ifTrue: [^ aLiteral between: -1 and: 2].

	aLiteral == true ifTrue: [^ true].
	aLiteral == false ifTrue: [^ true].
	aLiteral == nil ifTrue: [^ true].

	^ false! !
!AssignmentNode methodsFor: 'private' stamp: 'mt 9/4/2019 09:20' overrides: 50344197!
            ifNilTemporary
	"(temp := object) == nil ifTrue: [...] ifFalse: [...]"
	
	^ self variable! !
!BraceNode methodsFor: 'closure analysis' stamp: 'eem 1/18/2020 17:33'!
                           deoptimize
	"Deoptimize the blocks in a caseOf:[otherwise:] that is being used in a cascade."
	elements do:
		[:aMessage|
		self assert: aMessage selector key == #->.
		aMessage receiver deoptimize.
		aMessage arguments first deoptimize]! !
!BlockNode methodsFor: 'accessing' stamp: 'eem 12/24/2024 16:46:15'!
          ensureClosureCreationNode: ignored
	^self closureCreationNode! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 1/16/2025 17:12:45'!
                 preenIfNotNilNode: messageNode preenableNodes: preenableNodes
	"Transform a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| variable relevantNodes |
	self assert: (messageNode isMessageNode
				and: [messageNode macroPrinter == #printIfNilNotNil:indent:
				and: [messageNode receiver receiver isAssignmentNode]]).
	variable := messageNode receiver receiver variable.
	self assert: (variable isTemp and: [variable isRemote not]).
	relevantNodes := preenableNodes keys select:
						[:node| 
						node isMessageNode
						and: [messageNode macroPrinter == #printIfNilNotNil:indent:]].
	(variable isLocalToBlocksInIfNilIfNotNilNodes: relevantNodes in: self) ifFalse:
		[messageNode arguments do:
			[:argBlock|
			(argBlock arguments size = 1
			and: [argBlock firstArgument = variable]) ifTrue:
				[argBlock arguments: #()]].
		 variable beTemp.
		 ^self].
	messageNode arguments last arguments isEmpty
		ifTrue: [messageNode arguments last arguments: { variable }]
		ifFalse:
			[self assert: messageNode arguments last arguments asArray = { variable }.
			 variable := nil].
	messageNode receiver receiver: messageNode receiver receiver value.
	(temporaries includes: variable) ifTrue: "can't use removeAtIndex: cuz temporaries could be an Array"
		[temporaries := temporaries copyWithout: variable].
	variable ifNil: [^self].
	self nodesDo:
		[:node|
		((node == self or: [node isBlockNode])
		 and: [node temporaries anySatisfy: [:temp| temp = variable]]) ifTrue:
			[node temporaries: (node temporaries reject: [:temp| temp = variable])]]! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 12/29/2024 17:44:13'!
                          preenNilNodeFollowingNilIfNode: aNilIfMessageNode preenableNodes: preenableNodes
	self nodesDo:
		[:node| | statements indices |
		 (node isBlockNode
		  and: [(statements := node statements) includes: aNilIfMessageNode]) ifTrue:
			[indices := (2 to: statements size) reject:
							[:i|
							(statements at: i) == NodeNil
							and: [(statements at: i - 1) isNilIf]].
			 node statements: (({1}, indices) collect: [:i| statements at: i])]]! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 12/29/2024 17:44:18'!
                 preenTempsConflictingWithBlockNode: temps preenableNodes: preenableNodes
	"Push temps that conflict with other blocks down into their narrowest enclosing block scope."
	temps do:
		[:tempVar|
		(self accept: (NarrowerVariableScopeFinder new ofVariable: tempVar)) ifNotNil:
			[:enclosingScope |
			 self assert: enclosingScope isBlockNode.
			 self nodesDo:
				[:node|
				 ((node == self or: [node isBlockNode])
				  and: [node temporaries includes: tempVar]) ifTrue:
					[node temporaries: (node temporaries copyWithout: tempVar)]].
			 enclosingScope temporaries: enclosingScope temporaries, { tempVar }]]! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 12/29/2024 17:52:24'!
          preenableNodes
	"Answer a Dictionary from node or sequence of nodes to preen method selector for nodes in
	 the tree that require post-processing after either a format or a decompile.  Such issues are
	 the variable for an ifNotNil: which is local to the ifNotNil: block but, due to the inlining of
	 ifNotNil: appears to be declared at the outer level, and, similarly, a temporary variable that
	 conflicts with one of the same name in a block when, were the variable declared local to
	 some inlined block it would no longer conflict.  The resulting dictionary is used to perform
	 the value with the key (node or array) and the dictionary as arguments to preen the tree."

	| preenableNodes priorBlocks priorVariables |
	preenableNodes := Dictionary new.
	priorBlocks := OrderedCollection new.
	priorVariables := Set new.
	self nodesWithPrecedingStatementsDo:
		[:node :precedingStatementOrNil| | variable temps |
		(node isMessageNode
		and: [node macroPrinter == #printIfNilNotNil:indent:
		and: [node receiver isMessageNode
		and: [node receiver selector key == #==
		and: [node receiver receiver isAssignmentNode
		and: [(variable := node receiver receiver variable) isTemp
		and: [variable isRemote not]]]]]]) ifTrue:
			[preenableNodes at: node put: #preenIfNotNilNode:preenableNodes:.
			 priorVariables add: variable].
		node isBlockNode ifTrue:
			[temps := OrderedCollection new.
			 node temporaries do:
				[:temp|
				 priorBlocks do:
					[:aBlock|
					 aBlock temporaries do:
						[:priorTemp|
						 (priorVariables includes: priorTemp) ifFalse:
							[priorTemp key = temp key ifTrue:
								[temps addLast: priorTemp]]]]].
			 temps isEmpty ifFalse:
				[preenableNodes at: temps put: #preenTempsConflictingWithBlockNode:preenableNodes:].
			 priorBlocks addLast: node].
		(node == NodeNil
		 and: [precedingStatementOrNil notNil
		 and: [precedingStatementOrNil isMessageNode
		 and: [precedingStatementOrNil isNilIf]]]) ifTrue:
			[preenableNodes at: precedingStatementOrNil put: #preenNilNodeFollowingNilIfNode:preenableNodes:]].
	^preenableNodes! !
!TempVariableNode methodsFor: 'testing' stamp: 'eem 12/29/2024 18:05:06'!
                        beTemp
	"This is for preening of ifNil:ifNotNil:"
	argType := nil! !
!TempVariableNode methodsFor: 'testing' stamp: 'eem 1/16/2025 11:58:00'!
                  isLocalToBlocksInIfNilIfNotNilNodes: ifNilIfNotNilMessages "<Collection of: MessageNode>" in: aMethodNode "<MethodNode>"
	"Answer if the receiver only occurs within the ifNotNil: blocks of the message nodes,
	 or is the target of the assignment that is the receiver of each node.
	 Assumes that all ifNilIfNotNilMessages are in fact subnodes of aMethodNode.

	Strategy:
		First visit all nodes outside of the message nodes. If the variable is referenced there answer false.
		Next visit the expressions of all assignments that are the receivers of the ifNilIfNotNil: messages.
		If the variable is referenced there answer false.
		If not found outside, answer true. This does not require the variable to be referenced within the
		block, but that is not necessary to produce a nicely preened tree."
	| ifNotNilBlocks ifNotNilAssignments finder |
	ifNotNilBlocks := Set new.
	ifNotNilAssignments := Set new.
	ifNilIfNotNilMessages do:
		[:messageNode|
		(messageNode receiver isMessageNode
		 and: [messageNode receiver selector key == #==
		 and: [messageNode receiver receiver isAssignmentNode
		 and: [messageNode receiver receiver variable = self]]]) ifTrue:
			[ifNotNilAssignments add: messageNode receiver receiver].
		ifNotNilBlocks add: (messageNode arguments at: (messageNode selector key keywords indexOf: #ifNotNil:))].
	finder := ParseNodeEnumerator
				ofBlock: [:node| node == self ifTrue: [^false]]
				select: [:node| ((node isBlockNode and: [ifNotNilBlocks includes: node])
								or: [node isAssignmentNode and: [ifNotNilAssignments includes: node]]) not].
	aMethodNode accept: finder.
	ifNotNilAssignments do:
		[:assignmentNode|
		assignmentNode value accept: finder].
	^true! !
!MessageNode methodsFor: 'private' stamp: 'mt 9/4/2019 09:27' overrides: 50344197!
         ifNilTemporary

	^ self ifNilReceiver ifNilTemporary! !
!MessageNode methodsFor: 'decompiling' stamp: 'eem 7/11/2024 18:10'!
   toDoFromWhileWithCounts: blockBodyTempCounts init: incrInit limit: limitInitOrNil
	"If the receiver, a whileTrue: loop, represents a to:[by:]do: loop
	 then answer the replacement to:[by:]do:, otherwise answer nil."
	| variable increment limit toDoBlock body test |
	self assert: (selector key == #whileTrue:
				and: [incrInit isAssignmentNode]).
	(limitInitOrNil notNil "limit should not be referenced within the loop"
	  and: [(blockBodyTempCounts at: limitInitOrNil variable ifAbsent: [0]) ~= 1]) ifTrue:
		[^nil].
	body := arguments last statements.
	(variable := incrInit variable) isTemp ifFalse:
		[^nil].
	(increment := body last toDoIncrement: variable) ifNil:
		[^nil].
	receiver statements size ~= 1 ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test should really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable is: limit]]]) ifTrue:
		[^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: {variable}.
	^MessageNode new
		receiver: incrInit value
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: { limit. increment. toDoBlock }
		precedence: precedence! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'mt 10/9/2019 09:42'!
           decodeIfNilWithReceiver: receiver selector: selector arguments: arguments tempReadCounts: tempReadCounts
	
	| node temp |
	receiver ifNil: [ ^nil ].		"For instance, when cascading"
	selector == #ifTrue:ifFalse:
		ifFalse: [^ nil].
				
	(receiver isMessage: #==
				receiver: nil
				arguments: [:argNode | argNode == NodeNil])
		ifFalse: [^ nil].
		
	"Like #to:(by:)do:, support only local temps."
	(((temp := receiver ifNilTemporary) isNil or: [tempReadCounts includesKey: temp]) or: [
		"What about 'object ifNotNil: [:o | ]', which as not read the blockArg? Just check that there is no remote vector pointing to it."
		tempReadCounts keys noneSatisfy:
			[:otherTemp |
				otherTemp isIndirectTempVector
					ifTrue: [otherTemp remoteTemps anySatisfy:
						[:remoteTemp |
						remoteTemp name = temp name]]
					ifFalse: [otherTemp name = temp name]]
			])
		ifFalse: [^ nil].
		
	node := (MessageNode new
			receiver: receiver
			selector: (SelectorNode new key: #ifTrue:ifFalse: code: #macro)
			arguments: arguments
			precedence: 3).

	"Reconfigure the message node to #ifNil:ifNotNil:. Note that original* instance variables keep their optimized format. See MessageNode >> #printIfNilNotNil:indent:."	
	node
		noteSpecialSelector: #ifNil:ifNotNil:;
		selector: (SelectorNode new key: #ifNil:ifNotNil:).
	
	temp ifNil: [^ node].
	temp isTemp ifFalse: [^ node].
	
	(arguments second isJust: NodeNil) not ifTrue:
		[temp beBlockArg.
		node arguments: {
			arguments first.
			arguments second copy arguments: { temp }; yourself }].
				
	^ node! !
!ParseNodeWithPrecedingStatementEnumerator methodsFor: 'initialize-release' stamp: 'eem 3/19/2019 11:50' overrides: 16920643!
              ofBlock: aBlock
	"N.B. This enumerator visits a node before any of the node's children.
	 Hence, when enumerating statements in a block, we can ensure that
	 the second argument to the block, the preceding statement, is non-nil
	 only for top-level statements in the block by nilling out precedingStatement
	 once the block is evaluated. Perhaps stronger would be to capture its value
	 in a temporary and nil it before evaluating, but this is good enough."
	theBlock := [:node|
				aBlock value: node value: precedingStatement.
				precedingStatement := nil]! !
!ParseNodeWithPrecedingStatementEnumerator methodsFor: 'initialize-release' stamp: 'eem 12/24/2017 10:32' overrides: 16920647!
              ofBlock: aBlock select: aSelectBlock
	self ofBlock: aBlock.
	theSelectBlock := aSelectBlock! !
!ParseNodeWithPrecedingStatementEnumerator methodsFor: 'visiting' stamp: 'eem 1/3/2019 15:46' overrides: 16920481!
              visitBlockNode: aBlockNode
	| savedPrecedingStatement |
	(theSelectBlock isNil or: [theSelectBlock value: aBlockNode]) ifFalse:
		[^nil].
	theBlock value: aBlockNode.
	savedPrecedingStatement := precedingStatement.
	precedingStatement := nil.
	[aBlockNode statements do:
		[:statement|
		 statement accept: self.
		 precedingStatement := statement]] ensure:
		[precedingStatement := savedPrecedingStatement]! !
!NarrowerVariableScopeFinder methodsFor: 'visiting' stamp: 'eem 12/29/2024 18:34:35' overrides: 16999289!
                           visitTempVariableNode: aVariableNode
	^(theVariable is: aVariableNode) ifTrue: [theVariable]! !
!NarrowerVariableScopeFinder methodsFor: 'visiting' stamp: 'eem 4/3/2017 12:00' overrides: 16999293!
                           visitUndeclaredVariableNode: aVariableNode
	^nil! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:32'!
                           arguments

	^ arguments! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:04'!
                    context

	^ context! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:32'!
                        method

	^ method! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/2/2021 16:01'!
                          primitive

	^ primitiveIndex! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/9/2021 20:14'!
               suppress

	suppressed := true.! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/9/2021 20:14'!
             suppressed

	^ suppressed ifNil: [self isSimulationGuard not]! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:33'!
              theReceiver

	^ receiver! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/9/2021 20:14'!
                   unsuppress

	suppressed := false.! !
!SimulationSideEffectWarning methodsFor: 'initialize-release' stamp: 'ct 2/6/2022 20:24'!
 context: aContext method: aCompiledMethod receiver: rcvr arguments: args

	context := aContext.
	method := aCompiledMethod.
	receiver := rcvr.
	arguments := args.! !
!SimulationSideEffectWarning methodsFor: 'initialize-release' stamp: 'ct 2/6/2022 20:23'!
primitive: anInteger

	primitiveIndex := anInteger.! !
!SimulationSideEffectWarning methodsFor: 'priv handling' stamp: 'ct 3/2/2024 23:47' overrides: 17005795!
defaultAction

	self suppressed ifFalse: [super defaultAction].
	self flag: #forLater. "When we support explicit exception handler invocation (e.g., #resume, #retry) from the debugger, this exception should publish a #resume handler rather than relying on the weakly defined proceed semantics of the debugger."
	^ self defaultResumeValue! !
!SimulationSideEffectWarning methodsFor: 'defaults' stamp: 'ct 2/6/2022 20:34' overrides: 16856623!
       defaultResumeValue

	^ true! !
!SimulationSideEffectWarning methodsFor: 'testing' stamp: 'ct 5/9/2021 20:43'!
                  isControlPrimitive
	"See StackInterpreter class>>#initializePrimitiveTable."

	^ self primitive between: 80 and: 89! !
!SimulationSideEffectWarning methodsFor: 'testing' stamp: 'ct 5/9/2021 20:43'!
                          isSimulationGuard
	"See Parser >> #simulationGuard."

	^ self primitive = 19! !
!SimulationSideEffectWarning methodsFor: 'printing' stamp: 'ct 3/3/2024 19:24' overrides: 16856659!
            messageText

	^ messageText ifNil: [
		'The code being simulated is trying to control a process ({1}). {2}' translated format: {
			self context method reference.
			self isSimulationGuard
				ifTrue: ['If you proceed, your image may be locked. Continue at own risk, and better save your image before.' translated]
				ifFalse: ['Process controlling cannot be simulated. If you proceed, side effects may occur outside the observable area of the simulator.' translated]}]! !
!SimulationSideEffectWarning methodsFor: 'signaling' stamp: 'ct 2/6/2022 20:38'!
                     signalIfSkipped: skipBlock

	^ self signal ifFalse: skipBlock! !
!SimulationSideEffectWarning methodsFor: 'handling' stamp: 'ct 2/6/2022 20:37'!
               skipPrimitive

	^ self resume: false! !
!SimulationSideEffectWarning class methodsFor: 'instance creation' stamp: 'ct 2/6/2022 20:22'!
                         forPrimitive: primitiveIndex

	^ self new primitive: primitiveIndex! !
!ImplicitLiteralInstructionClientHook methodsFor: 'instruction decoding - implicit literals' stamp: 'mt 12/20/2023 13:19'!
                              methodReturnSpecialConstant: value
	"This is a hook to allow clients to intercept implicit literal bytecodes"
	^self methodReturnConstant: value! !
!ImplicitLiteralInstructionClientHook methodsFor: 'instruction decoding - implicit literals' stamp: 'eem 9/12/2021 14:46'!
                 pushSpecialConstant: value
	"This is a hook to allow clients to intercept implicit literal bytecodes"
	^self pushConstant: value! !
!ImplicitLiteralInstructionClientHook methodsFor: 'instruction decoding - implicit literals' stamp: 'eem 9/12/2021 14:19'!
 sendSpecial: selector numArgs: numArgs
	"This is a hook to allow clients to intercept special selector sends (which have an implicit selector)"
	^self send: selector super: false numArgs: numArgs! !
!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 8/1/2014 07:11'!
  blockReturnConstant: value
	"Return Constant From Block bytecode."
	scanner pc < blockEnd ifTrue:
		[self doJoin]! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 8/1/2014 07:21'!
                       blockReturnConstant: value 
	"Print the Return Constant From Block bytecode."

	self print: 'blockReturn: ', value printString! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 4/6/2015 12:00'!
          directedSuperSend: selector "<Symbol>" numArgs: numArgs "<SmallInteger>"
	self print: 'directedSuperSend: ' , (self stringForSelector: selector numArgs: numArgs)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 8/5/2014 11:38'!
       trapIfNotInstanceOf: behaviorOrArrayOfBehavior
	"If the top of stack is not an instance of either the argument, or, if the argument is an Array,
	  any of the elements of the argument, send the class trap message to the current context."
	self print: 'trapIfNotInstanceOf: ', behaviorOrArrayOfBehavior printString! !
!InstructionPrinter methodsFor: 'printing' stamp: 'eem 1/1/2023 12:04'!
                           stringForReceiverVariableOffset: offset
	| tmpStream |
	tmpStream := WriteStream on: (String new: 16).
	offset printOn: tmpStream.
	method methodClass ifNotNil:
		[:class|
		class isBehavior ifTrue:
			[(class instVarNameForIndex: offset + 1) ifNotNil:
				[:instVarName|
				tmpStream nextPutAll: ' "'; nextPutAll: instVarName; nextPut: $"]]].
	^tmpStream contents! !
!InstructionPrinter methodsFor: 'printing' stamp: 'eem 3/15/2013 15:14'!
      stringForSelector: selector numArgs: numArgs
	^(selector isSymbol and: [selector numArgs = numArgs])
		ifTrue: [selector]
		ifFalse: [selector printString
				, (numArgs = 1
					ifTrue: [' (1 arg)']
					ifFalse: [' (', numArgs printString, ' args)'])]! !
!InstructionPrinter methodsFor: '*BytecodeSets-SistaV1-decoding' stamp: 'cb 1/19/2017 14:10'!
 branchIfInstanceOf: behaviorOrArrayOfBehavior distance: distance
	"If the object on top of stack has the type -or one of the type- present in the literal
	 (the literal is a behavior or an array of behavior), then pop it. Else jumps by the distance."
	self print: 'branchIfInstanceOf: ', behaviorOrArrayOfBehavior printString, ' distance: ', distance printString! !
!InstructionPrinter methodsFor: '*BytecodeSets-SistaV1-decoding' stamp: 'eem 7/11/2016 14:24'!
                   branchIfNotInstanceOf: behaviorOrArrayOfBehavior distance: distance
	"If the object on top of stack has the type -or one of the type- present in the literal
	 (the literal is a behavior or an array of behavior), then pop it. Else jumps by the distance."
	self print: 'branchIfNotInstanceOf: ', behaviorOrArrayOfBehavior printString, ' distance: ', distance printString! !
!InstructionPrinter methodsFor: '*BytecodeSets-instruction decoding' stamp: 'eem 5/14/2020 13:32'!
         callInlinePrimitive: index
	"Print the callInlinePrimitive: bytecode.  This is the m = 1, ss = 0 case in SistaV1:	**	248 below.

	SistaV1:	**	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are as yet used)
	 V3/Spur:		139		10001011	i i i i i i i i	jjjjjjjj		Call Primitive #iiiiiiii + (jjjjjjjj * 256)"

	self print: 'callInlinePrimitive: ' , ((#((1000 ' class')
										(1001 ' pointer numSlots')
										(1002 ' pointer basicSize')
										(1003 ' byte8Type format numBytes')
										(1004 ' short16Type format numSho')
										(1005 ' word32Type format numWord')
										(1006 ' doubleWord64Type format n')

										(1010 ' ensure number of bytes available')
										(1011 ' fixed pointer basicNew')

										(1020 ' identityHash (non-immediate, non-Behavior, has hash)')
										(1021 ' identityHash (SmallInteger)')
										(1022 ' identityHash (Character)')
										(1023 ' identityHash (SmallFloat64)')
										(1024 ' identityHash (Behavior, has hash?)')

										(1030 ' immediateAsInteger (Character)')
										(1031 ' immediateAsInteger (SmallFloat64)')

										(2000 ' SmallInteger #+')
										(2001 ' SmallInteger #-')
										(2002 ' SmallInteger #*')
										(2003 ' SmallInteger #/')
										(2004 ' SmallInteger #//')
										(2005 ' SmallInteger #\\')
										(2006 ' SmallInteger #quo:')

										(2011 ' Variable-sized pointers new (new:). Array, etc')
										(2012 ' Variable-sized byte new (new:). ByteArray, ByteString, etc')
										(2013 ' Variable-sized 16-bit new (new:). DoubleByteArray, etc')
										(2014 ' Variable-sized 32-bit new (new:). Bitmap, FloatArray, etc')
										(2015 ' Variable-sized 64-bit new (new:). DoubleWordArray, etc')

										(2016 ' SmallInteger #bitAnd:')
										(2017 ' SmallInteger #bitOr:')
										(2018 ' SmallInteger #bitXor:')
										(2019 ' SmallInteger #bitShiftLeft:')
										(2019 ' SmallInteger #bitShiftRight:')

										(2032 ' SmallInteger #>')
										(2033 ' SmallInteger #<')
										(2034 ' SmallInteger #>=')
										(2035 ' SmallInteger #<=')
										(2036 ' SmallInteger #=')
										(2037 ' SmallInteger #~=')

										(2064 ' Pointer Object>>at:')
										(2065 ' Byte Object>>at:')
										(2066 ' 16-bit Word Object>>at:')
										(2067 ' Word Object>>at:')
										(2068 ' DoubleWord Object>>at:')
										(2069 ' QuadWord Object>>at:')

										(3000 ' Pointer Object>>at:put:')
										(3001 ' Byte Object>>at:put:')
										(3002 ' Word Object>>at:put:')
										(3003 ' DoubleWord Object>>at:put')
										(3004 ' QuadWord Object>>at:put:'))
											detect: [:tuple| tuple first = index]
											ifNone: [{index printString}]) last)! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'nice 3/10/2022 09:50'!
   interpretNext2ByteSistaV1Instruction: bytecode for: client extA: extA extB: extB startPC: startPC
	"Send to the argument, client, a message that specifies the next instruction.
	 This method handles the two-byte codes.
	 For a table of the bytecode set, see EncoderForV1's class comment."

	| byte method |
	method := self method.
	byte := self method at: pc.
	pc := pc + 1.
	"We do an inline quasi-binary search on bytecode"
	bytecode < 234 ifTrue: "pushes"
		[bytecode < 231 ifTrue:
			[bytecode < 229 ifTrue:
				[| literal |
				 bytecode = 226 ifTrue:
					[^client pushReceiverVariable: (extA bitShift: 8) + byte].
				 literal := method literalAt: (extA bitShift: 8) + byte + 1.
				 bytecode = 227 ifTrue:
					[^client pushLiteralVariable: literal].
				 ^client pushConstant: literal].
			bytecode = 229 ifTrue:
				[^client pushTemporaryVariable: byte].
			^self unusedBytecode: client at: startPC].
		bytecode = 231 ifTrue:
			[^byte < 128
				ifTrue: [client pushNewArrayOfSize: byte]
				ifFalse: [client pushConsArrayWithElements: byte - 128]].
		bytecode = 232 ifTrue:
			[^client pushSpecialConstant: ((extB < 128 ifTrue: [extB] ifFalse: [extB - 256]) bitShift: 8) + byte].
		^client pushSpecialConstant: (Character value: ((extB bitAnd: 16rFF) bitShift: 8) + byte)].
	bytecode < 240 ifTrue: "sends, trap and jump"
		[bytecode < 236 ifTrue: "sends"
			[(bytecode = 235 and: [extB >= 64]) ifTrue:
				[^client
					directedSuperSend: (method literalAt: (extA bitShift: 5) + (byte // 8) + 1)
					numArgs: (extB - 64 bitShift: 3) + (byte \\ 8)].
			 ^client
				send: (method literalAt: (extA bitShift: 5) + (byte // 8) + 1)
				super: bytecode = 235
				numArgs: (extB bitShift: 3) + (byte \\ 8)].
		 bytecode = 236 ifTrue:
			[^client callMappedInlinedPrimitive: byte].
		bytecode = 237 ifTrue:
			[^client jump: (extB bitShift: 8) + byte].
		 ^client jump: (extB bitShift: 8) + byte if: bytecode = 238].
	bytecode < 243 ifTrue:
		[bytecode = 240 ifTrue:
			[^client popIntoReceiverVariable: (extA bitShift: 8) + byte].
		 bytecode = 241 ifTrue:
			[^client popIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].
		 ^client popIntoTemporaryVariable: byte].
	bytecode = 243 ifTrue:
		[^client storeIntoReceiverVariable: (extA bitShift: 8) + byte].
	bytecode = 244 ifTrue:
		[^client storeIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].
	bytecode = 245 ifTrue:
		[^client storeIntoTemporaryVariable: byte].
	"246-247	1111011 i	xxxxxxxx	UNASSIGNED"
	^self unusedBytecode: client at: startPC! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 3/23/2017 16:32'!
         interpretNext3ByteSistaV1Instruction: bytecode for: client extA: extA extB: extB startPC: startPC
	"Send to the argument, client, a message that specifies the next instruction.
	 This method handles the three-byte codes.
	 For a table of the bytecode set, see EncoderForSistaV1's class comment."

	| method byte2 byte3 literal |
	method := self method.
	byte2 := method at: pc.
	byte3 := method at: pc + 1.
	pc := pc + 2.

	"**	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
									m=1 means inlined primitive, no hard return after execution. 
									ss defines the unsafe operation set used to encode the operations. 
									(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are not used)
									Lowcode inlined primitives may have extensions."
	bytecode = 248 ifTrue:
		[| primitiveSetSelector primitiveNumber |
		 byte3 < 128 ifTrue:
			[ "Maybe this should be restricted to the 13 bit primitiveNumber too..."
			 ^client callPrimitive: byte2 + (byte3 bitShift: 8)].
		 primitiveSetSelector := (byte3 bitShift: -5) bitAnd: 3.
		 primitiveNumber := byte2 + ((byte3 bitAnd: 31) bitShift: 8).
		 primitiveSetSelector = 0 ifTrue: "Sista inline primitives"
			[^client callInlinePrimitive: byte2 + (byte3 - 128 bitShift: 8)].
		 primitiveSetSelector = 1 ifTrue: "Lowcode inline primitives"
			[^client callLowcodeInlinePrimitive: byte2 + (byte3 - 128 bitShift: 8) extA: extA extB: extB].
		 "fall through to ^self unusedBytecode: client at: startPC below"].

	"*	249		11111001	xxxxxxxx	siyyyyyy	push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1"
	bytecode = 249 ifTrue:
		[literal := method literalAt: (extA bitShift: 8) + byte2 + 1.
		 (byte3 noMask: 16rC0) ifTrue:
			[^client pushFullClosure: literal numCopied: byte3].
		 ^client
			pushFullClosure: literal
			numCopied: (byte3 bitAnd: 16r3F)
			receiverOnStack: (byte3 anyMask: 16r80)
			ignoreOuterContext: (byte3 anyMask: 16r40)].
	bytecode = 250 ifTrue:
		["**	250  11111010  eeiiikkk  jjjjjjjj  Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
		 ^client
			pushClosureCopyNumCopiedValues: ((byte2 bitShift: -3) bitAnd: 7) + (extA // 16 bitShift: 3)
			numArgs: (byte2 bitAnd: 7) + (extA \\ 16 bitShift: 3)
			blockSize: byte3 + (extB bitShift: 8)].
	bytecode = 251 ifTrue:
		[^client pushRemoteTemp: byte2 inVectorAt: byte3].
	bytecode = 252 ifTrue:
		[^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].
	bytecode = 253 ifTrue:
		[^client popIntoRemoteTemp: byte2 inVectorAt: byte3].
	"**	254		11111110	kkkkkkkk	jjjjjjjj		branch If Not Instance Of Behavior/Array Of Behavior kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ Extend B * 256, where Extend B >= 0)"
	bytecode = 254 ifTrue: "The sign bit of extB inverts the operation.  Would like to have extB < -128, but this is good enough for now."
		[literal := method literalAt: (extA bitShift: 8) + byte2 + 1.
		 extB < 0 ifTrue: [^client branchIfInstanceOf: literal distance: (extB + 128 bitShift: 8) + byte3].
		 ^client branchIfNotInstanceOf: literal distance: (extB bitShift: 8) + byte3].
	^self unusedBytecode: client at: startPC! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'mt 12/20/2023 13:20'!
                   interpretNextSistaV1InstructionFor: client
	"Send to the argument, client, a message that specifies the next instruction."

	| byte div16 offset method extA extB savedPC |
	method := self method.
	"For a table of the bytecode set, see EncoderForSistaV1's class comment."
	"consume and compute any extensions first."
	extA := extB := 0.
	savedPC := pc.
	[byte := self method at: pc.
	 pc := pc + 1.
	 byte >= 16rE0 and: [byte <= 16rE1]] whileTrue:
		[| extByte |
		 extByte := self method at: pc.
		 pc := pc + 1.
		 byte = 16rE0
			ifTrue:
				[extA := (extA bitShift: 8) + extByte]
			ifFalse:
				[extB := (extB = 0 and: [extByte > 127])
							ifTrue: [extByte - 256]
							ifFalse: [(extB bitShift: 8) + extByte]]].
	div16 := byte // 16.
	offset := byte \\ 16.
	"We do an inline quasi-binary search on each of the possible 16 values of div16"
	div16 < 11 ifTrue:
		[div16 < 6 ifTrue:
			[div16 < 4 ifTrue:
				[div16 < 2 ifTrue:
					[div16 = 0 ifTrue:
						 [^client pushReceiverVariable: offset].
					^client pushLiteralVariable: (method literalAt: offset + 1)]. "div16 = 1"
				 ^client pushConstant: (method literalAt: byte \\ 32 + 1)].
			 div16 = 4 ifTrue:
				[offset < 12 ifTrue:
					[^client pushTemporaryVariable: offset].
				 offset = 12 ifTrue:
					[^client pushReceiver].
				 offset = 13 ifTrue:
					[^client pushSpecialConstant: true].
				 offset = 14 ifTrue:
					[^client pushSpecialConstant: false].
				 offset = 15 ifTrue:
					[^client pushSpecialConstant: nil]].
			"div16 = 5"
			 offset < 2 ifTrue:
				[^client pushSpecialConstant: offset].
			 offset = 2 ifTrue:
				[^self interpretSistaV1ExtendedPush: extB for: client].
			 offset = 3 ifTrue:
				[^client doDup].
			 offset = 8 ifTrue:
				[^client methodReturnReceiver].
			 offset = 9 ifTrue:
				[^client methodReturnSpecialConstant: true].
			 offset = 10 ifTrue:
				[^client methodReturnSpecialConstant: false].
			 offset = 11 ifTrue:
				[^client methodReturnSpecialConstant: nil].
			 offset = 12 ifTrue:
				[^client methodReturnTop].
			 offset = 13 ifTrue:
				[^client blockReturnConstant: nil].
			 offset = 14 ifTrue:
				[^client blockReturnTop].
			 offset = 15 ifTrue:
				[^client doNop].
			 ^self unusedBytecode: client at: savedPC].
		"short sends"
		div16 = 6 ifTrue:
			[^client
				sendSpecial: (Smalltalk specialSelectorAt: offset + 1)
				numArgs: (Smalltalk specialNargsAt: offset + 1)].
		 div16 = 7 ifTrue:
			[^client
				sendSpecial: (Smalltalk specialSelectorAt: offset + 17)
				numArgs: (Smalltalk specialNargsAt: offset + 17)].
		^client
			send: (method literalAt: offset + 1)
			super: false
			numArgs: div16 - 8].
	"div16 >= 11; bytecode >= 176"
	div16 < 14 ifTrue:
		[div16 = 11 ifTrue:
			[offset < 8 ifTrue:
				[^client jump: offset + 1].
			 ^client jump: offset - 7 if: true].
		 div16 = 12 ifTrue:
			[offset < 8 ifTrue:
				[^client jump: offset + 1 if: false].
			 ^client popIntoReceiverVariable: offset - 8].
		 "div16 = 13"
		 offset < 8 ifTrue:
		 	[^client popIntoTemporaryVariable: offset].
		 offset = 8 ifTrue:
			[^client doPop].
		 offset = 9 ifTrue:
			[^client trap].
		 ^self unusedBytecode: client at: savedPC].
	"2 byte and 3 byte codes"
	byte < 248 ifTrue:
		[^self interpretNext2ByteSistaV1Instruction: byte for: client extA: extA extB: extB startPC: savedPC].
	^self interpretNext3ByteSistaV1Instruction: byte for: client extA: extA extB: extB startPC: savedPC! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 8/1/2014 07:00'!
     interpretSistaV1ExtendedPush: extB for: client
	"Implement the extended push for non-zero extensions."
	"*	82			01010010			Push thisContext, (then Extend B = 1 => push thisProcess)"
	extB = 0 ifTrue:
		[^client pushActiveContext].
	extB = 1 ifTrue:
		[^client pushActiveProcess].
	self error: 'undefined extended push'! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 1/9/2023 08:40'!
  interpretSistaV1Jump
	"If the instruction at pc is an unconditional jump, interpret it, advancing the pc,
	 and answering the jump distance. Otherwise answer nil."

	"	176-183	10110 iii				Jump iii + 1 (i.e., 1 through 8)
	 *	225/16rE1	11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 *	237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	| method byte nextpc extB |
	method := self method.
	"consume and compute any extension first."
	extB := 0.
	nextpc := pc. "must not advance pc unless this is a jump."
	[byte := self method at: nextpc.
	 nextpc := nextpc + 1.
	 byte = 16rE1] whileTrue:
		[| extByte |
		 extByte := self method at: nextpc.
		 nextpc := nextpc + 1.
		 extB := (extB = 0 and: [extByte > 127])
					ifTrue: [extByte - 256]
					ifFalse: [(extB bitShift: 8) + extByte]].
	(byte between: 176 and: 183) ifTrue:
		[pc := nextpc.
		 ^byte - 175].
	byte = 237 ifTrue:
		[byte := method at: nextpc.
		 pc := nextpc + 1.
		 ^(extB bitShift: 8) + byte].
	^nil! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 8/1/2014 06:45'!
        interpretSistaV1JumpIfCond
	"If the instruction at pc is a conditional jump, interpret it, advancing the pc,
	 and answering the jump distance. Otherwise answer nil."

	"	184-191	10111 iii				Pop and Jump 0n True iii +1 (i.e., 1 through 8)
		192-199	11000 iii				Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	 *	225/E1		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 *	238		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
	 *	239		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)"
	| method byte nextpc extB |
	method := self method.
	"consume and compute any extension first."
	extB := 0.
	nextpc := pc. "must not advance pc unless this is a jump."
	[byte := self method at: nextpc.
	 nextpc := nextpc + 1.
	 byte = 16rE1] whileTrue:
		[| extByte |
		 extByte := self method at: nextpc.
		 nextpc := nextpc + 1.
		 extB := (extB = 0 and: [extByte > 127])
					ifTrue: [extByte - 256]
					ifFalse: [(extB bitShift: 8) + extByte]].
	(byte between: 184 and: 199) ifTrue:
		[pc := nextpc.
		 ^(byte bitAnd: 7) + 1].
	(byte between: 238 and: 239) ifTrue:
		[byte := method at: nextpc.
		 pc := nextpc + 1.
		 ^(extB bitShift: 8) + byte].
	^nil! !
!InstructionStream class methodsFor: 'class initialization' stamp: 'eem 8/22/2018 15:00' overrides: 16917943!
                 initialize
	"Initialize an array of special constants returned by single-bytecode returns
	 in the SqueakV3 bytecode set."

	SpecialConstants := {true. false. nil. -1. 0. 1. 2}
	"InstructionStream initialize."
! !

InstructionStream initialize!
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/1/2014 07:17'!
                               blockReturnConstant: value

	self pushConstant: value; blockReturnTop! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 1/5/2018 10:29'!
           directedSuperSend: selector numArgs: numArgs
	stack removeLast. "Discard the pushed class."
	^self send: selector super: true numArgs: numArgs! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'mt 12/20/2023 13:24'!
 methodReturnSpecialConstant: value
	^self methodReturnConstant: value! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'CompiledMethodTest 9/12/2021 21:20'!
                           pushSpecialConstant: value
	^self pushConstant: value! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'CompiledMethodTest 9/12/2021 21:19'!
           sendSpecial: selector numArgs: numArgs
	^self send: selector super: false numArgs: numArgs! !
!Decompiler methodsFor: 'private' stamp: 'eem 4/25/2017 18:02'!
  convertToDoLoop: blockBodyTempCounts
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	or
		var := startExpr.
		limit := limitExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]
	 and answer true."
	| whileStmt incrStmt initStmt limitStmt toDoStmt |
	whileStmt := statements last.
	incrStmt := whileStmt arguments first statements last.
	incrStmt isAssignmentNode ifFalse:
		[^false].
	(self startAndLimitFor: incrStmt variable from: stack into:
							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr])
		ifTrue:
			[| limitInStatements |
			 limitInStatements := limitStmt isNil
								    and: [statements size > 1
								    and: [self startAndLimitFor: incrStmt variable from: { stack last. (statements last: 2) first } into:
												[:startExpr :limitExpr| limitStmt := limitExpr]]].
			(toDoStmt := statements last toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:
				[^false].
			 limitInStatements
				ifTrue:
					[stack
						removeLast;
						addLast: toDoStmt.
					 statements removeLast: 2]
				ifFalse:
					[stack
						removeLast: (limitStmt ifNil: [1] ifNotNil: [2]);
						addLast: toDoStmt.
					 statements removeLast]]
		ifFalse:
			[(self startAndLimitFor: incrStmt variable from: statements allButLast into:
							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr]) ifFalse:
				[^false].
			 (toDoStmt := statements last toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:
				[^false].
			 statements
				removeLast: (limitStmt ifNil: [2] ifNotNil: [3]);
				addLast: toDoStmt].
	self markTemp: initStmt variable asOutOfScope: -1. "Flag arg as out of scope"
	initStmt variable beBlockArg.
	limitStmt ifNotNil:
		[self markTemp: limitStmt variable asOutOfScope: -2.
		 toDoStmt arguments at: 1 put: limitStmt value]. "Flag limit as hidden"
	^true! !
!Decompiler methodsFor: 'private' stamp: 'eem 4/25/2017 16:07'!
markTemp: tempVarNode asOutOfScope: scopeFlag
	tempVarNode scope: scopeFlag.
	tempReadCounts removeKey: tempVarNode ifAbsent: []! !
!Decompiler methodsFor: 'private' stamp: 'eem 1/10/2023 11:36'!
                            printPCRelative: value on: aStream
	value
		ifNil: [value printOn: aStream]
		ifNotNil:
			[value < method initialPC
				ifTrue: [value printOn: aStream]
				ifFalse: [aStream nextPut: $+; print: value - method initialPC]]! !
!Decompiler methodsFor: 'private' stamp: 'eem 7/12/2024 10:21'!
                              startAndLimitFor: incrVar from: aStack into: binaryBlock
	"If incrVar matches the increment of a whileLoop at the end of statements
	 evaluate binaryBlock with the init statement for incrVar and the init statement
	 for the block's limit, if any, and answer true.  Otherwise answer false.  Used to
	 help convert whileTrue: loops into to:[by:]do: loops."
	| guard initExpr limitInit size |
	((size := aStack size) >= 1
	 and: [(initExpr := aStack at: size) ~~ CaseFlag]
	 and: [initExpr isAssignmentNode]) ifFalse:
		[^false].
	initExpr variable == incrVar ifTrue:
		[binaryBlock value: initExpr value: nil.
		 ^true].
	limitInit := initExpr.
	(size >= 2
	 and: [(initExpr := aStack at: size - 1) isAssignmentNode
	 and: [initExpr variable == incrVar
	 and: [(guard := statements last receiver) isBlockNode
	 and: [guard statements size = 1
	 and: [(guard := guard statements first) isMessageNode
	 and: [guard receiver == incrVar
	 and: [guard arguments size > 0
	 and: [guard arguments first == limitInit variable]]]]]]]]) ifTrue:
		[binaryBlock value: initExpr value: limitInit.
		 ^true].
	^false! !
!Decompiler class methodsFor: 'class initialization' stamp: 'nice 5/10/2020 11:50' overrides: 50347373!
        initialize

	CascadeFlag := 'cascade'.  "A unique object"
	CaseFlag := 'case'. "Ditto"
	OtherwiseFlag := 'otherwise'. "Ditto"
	ArgumentFlag := 'argument'.  "Ditto"
	IfNilFlag := 'ifNil'.  "Ditto"

	"Decompiler initialize"! !

Decompiler initialize!
!ContextPart methodsFor: 'instruction decoding' stamp: 'tpr 12/25/2022 16:36'!
                        directedSuperSend: selector numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, selector,
	 starting the message lookup in the superclass of the class on top of stack.
	 The arguments of the message are found in the next numArgs locations on
	 the stack and the receiver just below them."

	| class newReceiver arguments |
	class := self pop.
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].
	newReceiver := self pop.
	QuickStep == self ifTrue:
		[QuickStep := nil.
		^self quickSend: selector to: newReceiver with: arguments lookupIn: class superclass].
	^self send: selector to: newReceiver with: arguments lookupIn: class superclass! !
!ContextPart methodsFor: 'controlling' stamp: 'eem 12/27/2024 13:55:04'!
   activateMethod: newMethod withArgs: args receiver: rcvr
	"Answer a MethodContext initialized with the arguments."

	^MethodContext 
		sender: self
		receiver: rcvr
		method: newMethod
		arguments: args! !
!ContextPart methodsFor: 'controlling' stamp: 'eem 12/27/2024 14:09:16'!
          executeMethod: meth forSelector: selector withArgs: arguments receiver: rcvr

	| primIndex val ctxt |
	(self objectClass: meth) isCompiledMethodClass ifFalse:
		["Object as Methods (OaM) protocol: 'The contract is that, when the VM encounters an ordinary object (rather than a compiled method) in the method dictionary during lookup, it sends it the special selector #run:with:in: providing the original selector, arguments, and receiver.'. DOI: 10.1145/2991041.2991062."
		^self send: #run:with:in:
			to: meth
			with: {selector. arguments. rcvr}].
	
	meth numArgs = arguments size ifFalse:
		[^ self class primitiveFailTokenFor: #'bad number of arguments'].
	(primIndex := meth primitive) > 0 ifTrue:
		[val := self doPrimitive: primIndex method: meth receiver: rcvr args: arguments.
		(self isPrimFailToken: val) ifFalse:
			[^val]].
	
	ctxt := self activateMethod: meth withArgs: arguments receiver: rcvr.
	(primIndex isInteger and: [primIndex > 0]) ifTrue:
		[ctxt failPrimitiveWith: val].
	
	^ctxt! !
!ContextPart methodsFor: 'controlling' stamp: 'eem 4/13/2017 13:22'!
           send: selector to: rcvr with: arguments
	"Simulate the action of sending a message with selector arguments to rcvr."

	^self send: selector to: rcvr with: arguments lookupIn: (self objectClass: rcvr)! !
!ContextPart methodsFor: 'instruction decoding implicit literals' stamp: 'mt 12/20/2023 13:23'!
                     methodReturnSpecialConstant: value
	"Simulate the action of a 'return constant' bytecode whose value is the
	 argument, value. This corresponds to a source expression like '^0'."

	^self return: value from: self methodReturnContext! !
!ContextPart methodsFor: 'instruction decoding implicit literals' stamp: 'eem 9/12/2021 21:52'!
                     pushSpecialConstant: value 
	"Simulate the action of bytecode that pushes the constant, value, on the 
	top of the stack."

	self push: value! !
!ContextPart methodsFor: 'instruction decoding implicit literals' stamp: 'eem 9/12/2021 21:24'!
               sendSpecial: selector numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, 
	 selector. The arguments  of the message are found in the top numArgs
	 locations on the stack and the receiver just below them."

	| thisReceiver arguments lookupClass |
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].
	thisReceiver := self pop.
	lookupClass := self objectClass: thisReceiver.
	QuickStep == self ifTrue:
		[QuickStep := nil.
		^self quickSend: selector to: thisReceiver with: arguments lookupIn: lookupClass].
	^self send: selector to: thisReceiver with: arguments lookupIn: lookupClass! !
!ContextPart methodsFor: 'read-only objects' stamp: 'eem 12/24/2024 19:58:21'!
                    modificationForbiddenFor: target at: index put: anObject
	"This is a place-holder before proper read-only object support is implemented."
	^self error: 'no modification'! !
!ContextPart methodsFor: 'read-only objects' stamp: 'eem 12/24/2024 19:58:48'!
    modificationForbiddenFor: target instVarAt: index put: anObject
	"This is a place-holder before proper read-only object support is implemented."
	^self error: 'no modification'! !
!ContextPart methodsFor: 'read-only objects' stamp: 'eem 3/11/2020 18:02'!
 simulatedObject: anObject instVarAt: anIndex put: aValue 
	"Primitive. Store a value into a fixed variable in the argument anObject.
	 The numbering of the variables corresponds to the named instance
	 variables.  Fail if the index is not an Integer or is not the index of a
	 fixed variable, or if anObject is read-only. This version correctly simulates
	 assigning to a read-only object. Answer the value stored as the result.
	 Using this message violates the  principle that each object has sovereign
	 control over the storing of values into its instance variables. Essential for
	 the debugger. See Object documentation whatIsAPrimitive."

	<primitive: 174 error: ec>
	ec == #'no modification' ifTrue:
		[^self send: #attemptToAssign:to:withIndex: to: self with: {aValue. anObject. anIndex} lookupIn: self class].
	self primitiveFailed! !
!ContextPart class methodsFor: 'class initialization' stamp: 'eem 12/26/2024 14:02:33' overrides: 50347373!
       initialize

	PrimitiveFailToken := Object new. "A unique token."
	ValueIndex := Association allInstVarNames indexOf: 'value'.
	QuickStep := nil "The context stepping in the debugger"! !

ContextPart initialize!
!Mutex methodsFor: 'system simulation' stamp: 'eem 3/30/2017 15:44'!
        primitiveEnterCriticalSectionOnBehalfOf: effectiveProcess
	"Primitive. Simulate primitiveEnterCriticalSection.  The receiver
	 must be unowned or owned by the effectiveProcess to proceed.
	 Answer if the process is already owned by the current process."
	<primitive: 186>
	^MethodContext primitiveFailTokenFor: nil! !
!Mutex methodsFor: 'system simulation' stamp: 'eem 3/30/2017 15:44'!
                             primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effectiveProcess
	"Primitive. Simulate primitiveEnterCriticalSection.  Attempt to set the ownership
	 of the receiver.  If the receiver is unowned set its owningProcess to the
	 effectiveProcess and answer false.  If the receiver is owned by the effectiveProcess
	 answer true.  If the receiver is owned by some other process answer nil."
	<primitive: 187>
	^MethodContext primitiveFailTokenFor: nil! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/17/2025 15:16:36' prior: 16833192!
                             isSetterOf: anInstVarName at: anInstVarIndex
	"Check if the receiver is a setter of the give inst var located at instVarIndex.
	 Only look at the bytecode to avoid soiurce code parsing issues."
	| scanner instruction |
	
	self isQuick ifTrue: [ ^false ].
	self selector = (anInstVarName, ':') ifFalse: [ ^false ].
	scanner := InstructionStream on: self.
	instruction := scanner nextInstruction.
	(instruction selector == #pushTemporaryVariable:
	 and: [instruction argument = 0]) ifFalse:
		[^false].
	instruction := scanner nextInstruction.
	(instruction selector == #popIntoReceiverVariable:
	 and: [instruction argument = (anInstVarIndex - 1)]) ifFalse:
		[^false].
	^scanner nextInstruction selector == #methodReturnReceiver! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 1/21/2025 12:07' prior: 16835020 overrides: 16917943!
         initialize    "CompiledMethod initialize"
	"Initialize class variables specifying the size of the temporary frame
	needed to run instances of me."

	SmallFrame := 16.	"Context range for temps+stack"
	LargeFrame := 56.
	PrimaryBytecodeSetEncoderClass ifNil:
		[PrimaryBytecodeSetEncoderClass := EncoderForV3PlusClosures].
	SecondaryBytecodeSetEncoderClass ifNil:
		[SecondaryBytecodeSetEncoderClass := EncoderForSistaV1].
	PreferredBytecodeSetEncoderClass ifNil:
		[PreferredBytecodeSetEncoderClass := PrimaryBytecodeSetEncoderClass]! !

CompiledMethod initialize!
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835037!
     installPrimaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header >= 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: []) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	PrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835056!
installSecondaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header < 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: []) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	SecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!Parser methodsFor: 'private' stamp: 'eem 4/3/2017 16:21' prior: 16922693!
                         encoder
	^encoder ifNil:
		[encoder := CompiledMethod preferredBytecodeSetEncoderClass new]! !
!ParseNode methodsFor: 'testing' stamp: '' prior: 16920139!
     isReturningIf

	^false! !
!ParseNode class methodsFor: 'accessing' stamp: 'eem 12/27/2024 15:32:12' prior: 16920324!
           blockReturnCode

	^ EndRemote! !
!ParseNode class methodsFor: 'accessing' stamp: 'eem 12/27/2024 15:32:16' prior: 16920329!
    popCode

	^ Pop! !
!ParseNode class methodsFor: 'accessing' stamp: 'eem 12/27/2024 15:30:17' prior: 16920334!
                  pushNilCode

	^LdNil! !
!ParseNode class methodsFor: 'class initialization' stamp: 'jmv 8/8/2016 12:59:33' prior: 16920401 overrides: 16917943!
                initialize
	"
	ParseNode initialize. VariableNode initialize
	"
	LdInstType := 1.
	LdTempType := 2.
	LdLitType := 3.
	LdLitIndType := 4.
	SendType := 5.
	"Back in the day the following constants corresponded to bytecodes.
	 Now they're just unique values that need to be eliminated when and if
	 things like code:type: are cleaned up."
	CodeBases := #(0 16 32 64 208 ).
	CodeLimits := #(16 16 32 32 16 ).
	LdSelf := 112.
	LdTrue := 113.
	LdFalse := 114.
	LdNil := 115.
	LdMinus1 := 116.
	LoadLong := 128.
	LdSuper := 133.
	Pop := 135.
	LdThisContext := 137.
	EndRemote := 125.
	SendPlus := 176.
	Send := 208.
	
	"((ParseNode class >> #initialize) literals select: [:l| l isVariableBinding and: [(ParseNode classPool includesAssociation: l) and: [(self systemNavigation allCallsOn: l localTo: ParseNode) size = 1]]]) sort: [:a :b| a key <= b key]"

	"ParseNode classPool associations select: [:a| (self systemNavigation allCallsOn: a localTo: ParseNode) isEmpty]"! !

ParseNode initialize!
!Encoder methodsFor: 'initialization' stamp: 'eem 12/27/2024 15:56:37' prior: 16853557!
           initScopeAndLiteralTables

	StdVariables ifNil: [VariableNode initClassCachedState].
	scopeTable := StdVariables copy.
	litSet := StdLiterals copy.
	"comments can be left hanging on nodes from previous compilations.
	 probably better than this hack fix is to create the nodes afresh on each compilation."
	scopeTable do:
		[:varNode| varNode comment: nil].
	litSet do:
		[:varNode| varNode comment: nil].
	selectorSet := StdSelectors copy.
	litIndSet := IdentityDictionary new.
	literalStream := WriteStream on: (Array new: 32).
	addedSelectorAndMethodClassLiterals := false.
	optimizedSelectors := Set new.
	bindingsInBacktickLiterals := Set new.! !
!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 4/5/2017 17:22' prior: 16801497 overrides: 16852806!
               bindBlockArg: name within: aBlockNode
	| nArgs |
	(nArgs := aBlockNode nArgsSlot) isNil ifTrue:
		[aBlockNode nArgsSlot: (nArgs := 0)].
	nArgs >= 15 ifTrue:
		[^self notify: 'Too many arguments'].
	aBlockNode nArgsSlot: nArgs + 1.
	^(self bindTemp: name)
		beBlockArg;
		nowHasDef;
		nowHasRef;
		yourself! !
!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 4/5/2017 17:20' prior: 16801530 overrides: 16852845!
     bindBlockTemp: name within: aBlockNode
	| nArgs |
	(nArgs := aBlockNode nArgsSlot) ifNil:
		[aBlockNode nArgsSlot: (nArgs := 0)].
	nArgs >= (CompiledMethod fullFrameSize - 1) ifTrue:
		[^self notify: 'Too many temporaries'].
	aBlockNode nArgsSlot: nArgs + 1.
	^self bindTemp: name! !
!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 4/5/2017 17:23' prior: 16801556 overrides: 16852883!
                              bindTemp: name
	"Declare a temporary; error not if a field or class variable or out-of-scope temp."
	scopeTable at: name ifPresent:
		[:node|
		"When non-interactive raise the error only if it is a duplicate"
		node isTemp
			ifTrue:[node scope >= 0 ifTrue:
						[^self notify: 'Name already used in this method']]
			ifFalse:[self warnAboutShadowed: name]].
	^self reallyBind: name! !
!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 12/26/2024 11:34:56' prior: 16801635!
                  if: code isSpecialLiteralForPush: aBlock
	"If code is that of a special literal for push then evaluate aBlock with the special literal
	 The special literals for push are nil true false -1 0 1 & 2 which have special encodings
	 in the blue book bytecode set.  Answer whether it was a special literal."
	^(code between: LdTrue and: LdNil + 4)
	    and: [aBlock value: (#(true false nil -1 0 1 2) at: code - LdSelf).
			true]! !
!BraceNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:12' prior: 16797030!
                               emitCodeForValue: stack encoder: encoder
	"Hack; when sizing we have no way of knowing how much stack space is available."
	elements size <= self maxElementsForConsArray ifTrue:
		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].
		 encoder genPushConsArray: elements size.
		 stack
			pop: elements size;
			push: 1.
		 ^self].
	^emitNode emitCodeForValue: stack encoder: encoder! !
!BraceNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:16' prior: 16797047!
                      sizeCodeForValue: encoder

	"Hack; we have no way of knowing how much stack space is available."
	elements size <= self maxElementsForConsArray ifTrue:
		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
		  + (encoder sizePushConsArray: elements size)].
	"Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"
	emitNode := CascadeNode new
					receiver: (MessageNode new
								receiver: (encoder encodeVariable: #Array)
								selector: #braceStream:
								arguments: {encoder encodeLiteral: elements size}
								precedence: 3 from: encoder)
					messages: ((elements collect: [:elt |
											MessageNode new
												receiver: nil
												selector: #nextPut:
												arguments: {elt}
												precedence: 3
												from: encoder])
								copyWith: (MessageNode new
												receiver: nil
												selector: #braceArray
												arguments: #()
												precedence: 1
												from: encoder)).
	^emitNode sizeCodeForValue: encoder! !
!BraceNode methodsFor: 'closure analysis' stamp: 'eem 7/20/2009 09:33' prior: 16797008!
 analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	elements do:
		[:node|
		node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]! !
!BlockNode methodsFor: 'code generation' stamp: 'eem 01/07/2018 18:41' prior: 16795063!
                   emitCodeForValue: stack encoder: encoder
	encoder supportsFullBlocks ifTrue:
		[^self emitCodeForFullBlockValue: stack encoder: encoder].
	copiedValues do:
		[:copiedValue| copiedValue emitCodeForValue: stack encoder: encoder].
	closureCreationNode pc: encoder nextPC.
	encoder
		genPushClosureCopyNumCopiedValues: copiedValues size
		numArgs: arguments size
		jumpSize: size.
	stack
		pop: copiedValues size;
		push: 1.
	"Emit the body of the block"
	self emitCodeForEvaluatedClosureValue: stack encoder: encoder! !
!BlockNode methodsFor: 'code generation' stamp: 'eem 12/24/2024 16:46:18' prior: 16795096!
sizeCodeForValue: encoder
	"Compute the size for the creation of the block and its code."
	copiedValues := self computeCopiedValues: encoder rootNode.
	self closureCreationNode.
	encoder supportsFullBlocks ifTrue:
		[^(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
		 + (encoder
				sizePushFullClosure:
					(closureCreationNode
						key: (self createBlockLiteral: encoder);
						reserve: encoder;
						index)
				numCopied: copiedValues size)].
	"Remember size of body for emit time so we know the size of the jump around it."
	size := self sizeCodeForEvaluatedClosureValue: encoder.
	^(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
	  + (encoder sizePushClosureCopyNumCopiedValues: copiedValues size numArgs: arguments size jumpSize: size)
	  + size! !
!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 12/24/2024 16:30:00' prior: 16794722!
                         constructClosureCreationNode: encoder
	copiedValues := self computeCopiedValues: encoder rootNode.
	^self closureCreationNode! !
!BlockNode class methodsFor: 'instance creation' stamp: 'eem 12/28/2024 13:23' prior: 16795500!
                               withJust: aNode
	^self new statements: { aNode } returns: false! !
!MethodNode methodsFor: 'converting' stamp: 'eem 12/29/2024 17:45:43' prior: 16901166!
      preen
	"Preen for pretty-printing and/or decompilation.
	 i.e. post-process to cover up for inadequacies in both algorithms.

	 Currently two cases:

		preenLocalIfNotNilArg: blockNode
		hiding the assignment to the arg of an inlined block arg to ifNotNil:,
			(var := expr) ifNil: [...] ifNotNil: [...]    =>    expr ifNil: [...] ifNotNil: [:var| ...].

		preenTempsConflictingWithBlockNode: temps
		hiding the declaration of a temp that is redeclared in some block"

	self preenableNodes ifNotNil:
		[:preenableNodes|
		 preenableNodes keysAndValuesDo:
			[:nodeOrArray :selector |
			 self perform: selector with: nodeOrArray with: preenableNodes]]! !
!LiteralNode methodsFor: 'code generation' stamp: 'eem 8/12/2017 15:26' prior: 16893390!
                        emitCodeForValue: stack encoder: encoder
	stack push: 1.
	(encoder isSpecialLiteralForPush: key)
		ifTrue: [encoder genPushSpecialLiteral: key]
		ifFalse: [encoder genPushLiteral: index]! !
!LiteralNode methodsFor: 'code generation' stamp: 'eem 11/29/2022 12:35' prior: 16893406 overrides: 16892950!
                    sizeCodeForValue: encoder
	^(encoder isSpecialLiteralForPush: key)
		ifTrue: [encoder sizePushSpecialLiteral: key]
		ifFalse:
			[self reserve: encoder.
			encoder sizePushLiteral: index]! !
!RemoteTempVectorNode methodsFor: 'closure analysis' stamp: 'eem 4/5/2017 17:23' prior: 16939984!
                               addRemoteTemp: aTempVariableNode encoder: encoder
	remoteTemps ifNil:
		[remoteTemps := OrderedCollection new].
	remoteTemps addLast: aTempVariableNode.
	aTempVariableNode referenceScopesAndIndicesDo:
		[:scopeBlock "<BlockNode>" :location "<Integer>"|
		 self addReadWithin: scopeBlock at: location]! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:30' prior: 16940029!
               emitCodeForStoreInto: aTempVariableNode stack: stack encoder: encoder
	encoder
		genStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:27' prior: 16940042!
                      emitCodeForStorePopInto: aTempVariableNode stack: stack encoder: encoder
	encoder
		genStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index.
	stack pop: 1! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940056!
 emitCodeForValueOf: aTempVariableNode stack: stack encoder: encoder
	encoder
		genPushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index.
	stack push: 1! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:27' prior: 16940076!
         nodeToInitialize: encoder
	^AssignmentNode new
		variable: self
		value: (NewArrayNode new numElements: remoteTemps size)! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940134!
  sizeCodeForStoreInto: aTempVariableNode encoder: encoder
	^encoder
		sizeStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940145!
 sizeCodeForStorePopInto: aTempVariableNode encoder: encoder
	^encoder
		sizeStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940157!
                           sizeCodeForValueOf: aTempVariableNode encoder: encoder
	^encoder
		sizePushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!MessageNode methodsFor: 'testing' stamp: 'eem 9/26/2008 12:39' prior: 16897379 overrides: 50347847!
isReturningIf

	^((special between: 3 and: 4) "ifTrue:ifFalse:/ifFalse:ifTrue:"
	    or: [special between: 17 and: 18]) "ifNil:ifNotNil:/ifNotNil:ifNil:"
		and: [arguments first returns and: [arguments last returns]]! !
!MessageNode class methodsFor: 'class initialization' stamp: 'eem 12/27/2024 15:36:08' prior: 16898590 overrides: 50347864!
        initialize
	"
	MessageNode initialize
	"
	MacroSelectors := 
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:
			repeat ).
	MacroTransformers := 
		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:
			transformAnd: transformOr:
			transformWhile: transformWhile: transformWhile: transformWhile:
			transformToDo: transformToDo:
			transformCase: transformCase:
			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:
			transformRepeat: ).
	MacroEmitters := 
		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:
			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:
			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForRepeat:encoder:value:).
	MacroSizers := 
		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:
			sizeCodeForToDo:value: sizeCodeForToDo:value:
			sizeCodeForCase:value: sizeCodeForCase:value:
			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForRepeat:value:).
	MacroPrinters := 
		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:
			printIfOn:indent: printIfOn:indent:
			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:
			printToDoOn:indent: printToDoOn:indent:
			printCaseOn:indent: printCaseOn:indent:
			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:
			printRepeatOn:indent:).
	Preferences
		name: #allowNonBooleanReceiversOfBooleanMessages
		description: 'If set, do not optimize boolean selectors, allowing, for example, new Boolean classes.'
		category: #programming type: Boolean value: false! !

MessageNode initialize!
!DecompilerConstructor methodsFor: 'constructor' stamp: 'ct 3/27/2020 20:01' prior: 16846500!
                 codeAnyLitInd: association

	^LiteralVariableNode new
		name: association key
		key: association
		index: nil
		type: LdLitIndType! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'ct 3/28/2020 00:36' prior: 16846513!
                            codeAnySelector: selector

	^SelectorNode new
		key: selector
		index: nil
		type: SendType! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'mt 9/4/2019 16:09' prior: 16846586!
    codeMessage: receiver selector: selector arguments: arguments
	| symbol |
	symbol := selector key.
	(self
		decodeLiteralVariableValueDereferenceWithReceiver: receiver
		selector: symbol
		arguments: arguments) ifNotNil: [:node| ^node].

	^MessageNode new
			receiver: receiver selector: selector
			arguments: arguments
			precedence: symbol precedence! !
!Behavior methodsFor: 'system startup' stamp: 'eem 12/26/2024 14:10:16' prior: 16789305!
  releaseClassCachedState
	"Will be called for each class on shutdown or snapshot. Implemented in relevant subclasses.
	 All class vars or class instVar vars that refer to objects that take up space and can be cheaply
	 recreated lazily on demand, should be nilled. For more expensive stuff to clean and recreate,
	 consider implementing #releaseClassState which is not called on every image save.

	 See implementors for examples"! !
!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'eem 4/6/2017 14:16' prior: 16794210!
          tempCountForBlockAt: pc in: method
	"Compute the number of local temporaries in a block.
	 If the block begins with a sequence of push: nil bytecodes then some of
	 These could be initializing local temps.  We can only reliably disambuguate
	 them from other uses of nil by parsing the stack and seeing what the offset
	 of the stack pointer is at the end of the block.

	 There are short-cuts.  The ones we take here are
		- if there is no sequence of push nils there can be no local temps
		- we follow forward jumps to shorten the amount of scanning"
	stackPointer := 0.
	scanner := InstructionStream new method: method pc: pc.
	scanner interpretNextInstructionFor: self.
	blockEnd ifNil:
		[self error: 'pc is not that of a block'].
	scanner nextByte = method encoderClass pushNilCode ifTrue:
		[joinOffsets := Dictionary new.
		 [scanner pc < blockEnd] whileTrue:
			[scanner interpretNextInstructionFor: self]].
	^stackPointer! !
!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'eem 4/6/2017 14:56' prior: 16794242!
                   testTempCountForBlockAt: startPc in: method
	"Compute the number of local temporaries in a block.
	 If the block begins with a sequence of push: nil bytecodes then some of
	 These could be initializing local temps.  We can only reliably disambuguate
	 them from other uses of nil by parsing the stack and seeing what the offset
	 of the stack pointer is at the end of the block.There are short-cuts.  The only
	 one we take here is
		- if there is no sequence of push nils there can be no local temps"

	| symbolicLines line prior thePc |
	symbolicLines := Dictionary new.
	method symbolicLinesDo:
		[:pc :lineForPC| symbolicLines at: pc put: lineForPC].
	stackPointer := 0.
	scanner := InstructionStream new method: method pc: startPc.
	scanner interpretNextInstructionFor: self.
	blockEnd ifNil:
		[self error: 'pc is not that of a block'].
	scanner nextByte = method encoderClass pushNilCode ifTrue:
		[joinOffsets := Dictionary new.
		 [scanner pc < blockEnd] whileTrue:
			[line := symbolicLines at: scanner pc.
			 prior := stackPointer.
			 thePc := scanner pc.
			 scanner interpretNextInstructionFor: self.
			 Transcript cr; print: prior; nextPutAll: '->'; print: stackPointer;  tab; print: thePc; tab; nextPutAll: line; flush]].
	^stackPointer! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 1/1/2023 11:57' prior: 16884686 overrides: 16884448!
                              popIntoReceiverVariable: offset 
	"Print the Remove Top Of Stack And Store Into Instance Variable bytecode."

	self print: 'popIntoRcvr: ' , (self stringForReceiverVariableOffset: offset)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 12/24/2024 17:12:48' prior: 16884743 overrides: 16884488!
    pushConstant: obj
	"Print the Push Constant, obj, on Top Of Stack bytecode."

	self print: (String streamContents:
				[:s |
				s nextPutAll: 'pushConstant: '.
				obj isVariableBinding
					ifFalse: [obj printOn: s]
					ifTrue: [obj key
						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]
						ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]]).

	(obj is: #CompiledMethod) ifTrue:
		[obj longPrintOn: stream indent: self indent + 2.
		^self].! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 1/1/2023 11:57' prior: 16884782 overrides: 16884510!
         pushReceiverVariable: offset
	"Print the Push Contents Of the Receiver's Instance Variable Whose Index 
	is the argument, offset, On Top Of Stack bytecode."

	self print: 'pushRcvr: ' , (self stringForReceiverVariableOffset: offset)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 3/30/2017 15:54' prior: 16884810 overrides: 16884532!
                           send: selector super: supered numArgs: numArgs
	"Print the Send Message With Selector, selector, bytecode. The argument, 
	supered, indicates whether the receiver of the message is specified with 
	'super' in the source method. The arguments of the message are found in 
	the top numArguments locations on the stack and the receiver just 
	below them."

	self print: (supered
				ifTrue: ['superSend: ']
				ifFalse: ['send: '])
			, (self stringForSelector: selector numArgs: numArgs)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 1/1/2023 11:57' prior: 16884838 overrides: 16884552!
                               storeIntoReceiverVariable: offset 
	"Print the Store Top Of Stack Into Instance Variable Of Method bytecode."

	self print: 'storeIntoRcvr: ' , (self stringForReceiverVariableOffset: offset)! !
!InstructionStream methodsFor: 'decoding - private - v3 plus closures' stamp: 'mt 12/20/2023 13:20' prior: 16885418!
         interpretNextV3ClosuresInstructionFor: client 
	"Send to the argument, client, a message that specifies the type of the 
	 next instruction."

	| byte type offset method |
	method := self method.  
	byte := method at: pc.
	type := byte // 16.  
	offset := byte \\ 16.  
	pc := pc+1.
	"We do an inline binary search on each of the possible 16 values of type."
	type < 8 ifTrue:
		[type < 4 ifTrue:
			[type < 2 ifTrue:
				[type = 0 ifTrue:
					[^ client pushReceiverVariable: offset].
				^ client pushTemporaryVariable: offset].				"type = 1"
			type = 2 ifTrue: 
				[^ client pushConstant: (method literalAt: offset + 1)].
			^ client pushConstant: (method literalAt: offset + 17)].		"type = 3"
		type < 6 ifTrue:
			[type = 4 ifTrue:
				[^ client pushLiteralVariable: (method literalAt: offset + 1)].
			^ client pushLiteralVariable: (method literalAt: offset + 17)]."type = 5"
		type = 6 ifTrue:
			[offset < 8 ifTrue:
				[^ client popIntoReceiverVariable: offset].
			^ client popIntoTemporaryVariable: offset - 8].
		"type = 7"
		offset = 0 ifTrue: [^ client pushReceiver].
		offset < 8 ifTrue: [^ client pushSpecialConstant: (SpecialConstants at: offset)].
		offset = 8 ifTrue: [^ client methodReturnReceiver].
		offset < 12 ifTrue: [^ client methodReturnSpecialConstant: (SpecialConstants at: offset - 8)].
		offset = 12 ifTrue: [^ client methodReturnTop].
		offset = 13 ifTrue: [^ client blockReturnTop].
		^ self unusedBytecode: client at: pc - 1]. "offset = 14 & offset = 15, 126 & 127"
	type < 12 ifTrue:
		[type < 10 ifTrue:
			[type = 8 ifTrue:
				[^ self
					interpretV3ClosuresExtension: offset
					in: method
					for: client].
			"type = 9 (short jumps)"
			offset < 8 ifTrue: [^ client jump: offset + 1].
			^ client jump: offset - 8 + 1 if: false].
		type = 10 ifTrue: "(long jumps)"
			[byte := method at: pc.
			pc := pc + 1.
			offset < 8 ifTrue: [^ client jump: offset - 4 * 256 + byte].
			^ client jump: (offset bitAnd: 3) * 256 + byte if: offset < 12].
		"type = 11; arithmetic special selector sends"
		^ client
			sendSpecial: (Smalltalk specialSelectorAt: offset + 1)
			numArgs: (Smalltalk specialNargsAt: offset + 1)].
		type = 12 ifTrue: "non-arithmetic special selector sends"
			[^ client
				sendSpecial: (Smalltalk specialSelectorAt: offset + 17)
				numArgs: (Smalltalk specialNargsAt: offset + 17)].
	"type = 13, 14 or 15"
	^ client
		send: (method literalAt: offset + 1)
		super: false
		numArgs: type - 13 "0, 1 & 2"! !
!Decompiler methodsFor: 'control' stamp: 'ct 3/26/2020 17:16' prior: 16845449!
             blockTo: end
	"Decompile a range of code as in statementsTo:, but return a block node. NB: end is an exclusive index."
	| exprs block oldBase lastStatementOfBlockIsNil |
	oldBase := blockStackBase.
	blockStackBase := stack size.
	exprs := self statementsTo: end.
	lastStatementOfBlockIsNil := pc < method endPC and: [exprs notEmpty and: [exprs last == (constTable at: 4)]].
	lastStatementOfBlockIsNil ifTrue:
		[exprs := exprs allButLast].
	block := constructor codeBlock: exprs returns: lastReturnPc = lastPc.
	blockStackBase := oldBase.
	lastReturnPc := -1.  "So as not to mislead outer calls"
	^block! !
!Decompiler methodsFor: 'control' stamp: 'eem 12/29/2024 15:16:40' prior: 16845488!
             doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize
	| startpc savedTemps savedTempVarCount savedNumLocalTemps
	  jump blockArgs blockTemps blockTempsOffset block tmpNumberBase |
	tmpNumberBase := statements size.
	savedTemps := tempVars.
	savedTempVarCount := tempVarCount.
	savedNumLocalTemps := numLocalTemps.
	jump := blockSize + (startpc := pc).
	numLocalTemps := BlockLocalTempCounter tempCountForBlockStartingAt: pc in: method.
	blockTempsOffset := numArgs + blockCopiedValues size.
	(blockStartsToTempVars notNil "implies we were intialized with temp names."
	 and: [blockStartsToTempVars includesKey: pc])
		ifTrue:
			[tempVars := blockStartsToTempVars at: pc]
		ifFalse:
			[blockArgs := (1 to: numArgs) collect:
							[:i| (constructor
									codeTemp: i - 1
									named: 'argm', tmpNumberBase printString, '_', (tempVarCount + i) printString)
								  beBlockArg].
			blockTemps := (1 to: numLocalTemps) collect:
							[:i| constructor
									codeTemp: i + blockTempsOffset - 1
									named: 'temp', tmpNumberBase printString, '_', (tempVarCount + i + numArgs) printString].
			tempVars := blockArgs, blockCopiedValues, blockTemps].
	numLocalTemps timesRepeat:
		[super interpretNextInstructionFor: self.
		 stack removeLast].
	tempVarCount := tempVarCount + numArgs + numLocalTemps.
	block := self blockTo: jump.
	stack addLast: ((constructor
						codeArguments: (tempVars copyFrom: 1 to: numArgs)
						temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)
						block: block)
							pc: startpc;
							yourself).
	tempVars := savedTemps.
	tempVarCount := savedTempVarCount.
	numLocalTemps := savedNumLocalTemps! !
!Decompiler methodsFor: 'control' stamp: 'nice 5/10/2020 12:23' prior: 16845544!
    statementsForCaseTo: end
	"Decompile the method from pc up to end and return an array of
	expressions. If at run time this block will leave a value on the stack,
	set hasValue to true. If the block ends with a jump or return, set exit
	to the destination of the jump, or the end of the method; otherwise, set
	exit = end. Leave pc = end.
	Note that stack initially contains a OtherwiseFlag which will be removed by
	a subsequent Pop instruction, so adjust the StackPos accordingly."

	| blockPos stackPos |
	blockPos := statements size.
	stackPos := stack size - 1. "Adjust for OtherwiseFlag"
	[pc < end]
		whileTrue:
			[lastPc := pc.  limit := end.  "for performs"
			self interpretNextInstructionFor: self].
	"If there is an additional item on the stack, it will be the value
	of this block."
	(hasValue := stack size > stackPos)
		ifTrue:
			[stack last == OtherwiseFlag
				ifFalse: [ statements addLast: stack removeLast] ].
	lastJumpPc = lastPc ifFalse: [exit := pc].
	caseExits add: exit.
	^self popTo: blockPos! !
!Decompiler methodsFor: 'control' stamp: 'eem 12/29/2024 12:19:28' prior: 16845578!
             statementsTo: end
	"Decompile the method from pc up to end and return an array of
	expressions. If at run time this block will leave a value on the stack,
	set hasValue to true. If the block ends with a jump or return, set exit
	to the destination of the jump, or the end of the method; otherwise, set
	exit = end. Leave pc = end."

	| encoderClass blockPos stackPos localLastPC initialPC |
	initialPC := pc.
	encoderClass := method encoderClass.
	blockPos := statements size.
	stackPos := stack size.
	[pc < end]
		whileTrue:
			[lastPc := localLastPC := pc.  limit := end. "for performs"
			 "for logging use the first form"
			 encoderClass interpretNextInstructionFor: self in: self].
	"If there is an additional item on the stack, it will be the value of this block."
	(hasValue := stack size > stackPos)
		ifTrue:
			[statements addLast: stack removeLast].
	lastJumpPc = lastPc ifFalse: [exit := pc].
	^self popTo: blockPos! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:33' prior: 16845609!
                             case: dist
	"statements = keyStmts CascadeFlag keyValueBlock ... keyStmts"

	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |
	nextCase := pc + dist.

	"Now add CaseFlag & keyValueBlock to statements"
	statements addLast: stack removeLast.
	"Trick: put a flag on the stack.
	If it is the last case before otherwise: block, then
	- there won't be a dup of caseOf: receiver before sending =
	- there won't be a pop in the case handling block"
	stack addLast: OtherwiseFlag. "set for next pop"
	statements addLast: (self blockForCaseTo: nextCase).
		
	stack last == OtherwiseFlag
		ifTrue: "Last case"
			["ensure jump is within block (in case thenExpr returns wierdly I guess)"
			stack removeLast. "get rid of CaseFlag"
			stmtStream := ReadStream on: (self popTo: stack removeLast).
			
			elements := OrderedCollection new.
			b := OrderedCollection new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == CaseFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream next)).
						 b := OrderedCollection new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			"try find the end of the case"
			myExits := caseExits removeLast: elements size.
			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].
			thenJump := myExits isEmpty
							ifTrue: [ nextCase ]
							ifFalse: [ myExits max ].
			
			otherBlock := self blockTo: thenJump.
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)
					arguments: (Array with: cases with: otherBlock))].! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:31' prior: 16845664!
                           doDup
	stack last == CaseFlag
		ifTrue:
			["We are in the process of decompiling a caseOf:"
			stack addLast: CaseFlag.
			^self].
	stack last == CascadeFlag
		ifFalse:
			["Save position and mark cascade"
			stack addLast: statements size.
			stack addLast: CascadeFlag].
	stack addLast: CascadeFlag! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:26' prior: 16845673!
                 doPop

	stack isEmpty ifTrue:
		["Ignore pop in first leg of ifNil for value"
		^ self].
	stack last == OtherwiseFlag
		ifTrue: [stack removeLast]
		ifFalse: [statements addLast: stack removeLast].! !
!Decompiler methodsFor: 'instruction decoding' stamp: '' prior: 16845682!
             doStore: stackOrBlock
	"Only called internally, not from InstructionStream. StackOrBlock is stack
	for store, statements for storePop."

	| var expr |
	var := stack removeLast.
	expr := stack removeLast.
	stackOrBlock addLast: (expr == ArgumentFlag
		ifTrue: [var]
		ifFalse: [constructor codeAssignTo: var value: expr])! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 12/28/2024 14:42' prior: 16845718!
                              jump: dist if: condition

	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock
	  thenJump elseJump condHasValue isIfNil saveStack |
	lastJumpIfPcStack addLast: lastPc.
	stack last == CaseFlag ifTrue: [^ [self case: dist] ensure: [lastJumpIfPcStack removeLast]].
	elsePc := lastPc.
	elseStart := pc + dist.
	end := limit.
	"Check for bfp-jmp to invert condition.
	Don't be fooled by a loop with a null body."
	sign := condition.
	savePc := pc.
	self interpretJump ifNotNil:
		[:elseDist|
		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:
			 [sign := sign not.  elseStart := pc + elseDist]].
	pc := savePc.
	ifExpr := stack removeLast.
	(isIfNil := stack size > 0 and: [stack last == IfNilFlag]) ifTrue:
		[stack removeLast].
	saveStack := stack.
	stack := OrderedCollection new.
	thenBlock := self blockTo: elseStart.
	condHasValue := hasValue or: [isIfNil].
	"ensure jump is within block (in case thenExpr returns)"
	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].
	"if jump goes back, then it's a loop"
	thenJump < elseStart
		ifTrue:
			[| blockBody blockArgs savedReadCounts blockBodyReadCounts selector |
			 "Must be a while loop...
			  thenJump will jump to the beginning of the while expr.  In the case of while's
			  with a block in the condition, the while expr should include more than just
			  the last expression: find all the statements needed by searching for the node
			  with the relevant pc."
			stack := saveStack.
			savedReadCounts := tempReadCounts copy.
			pc := thenJump.
			blockBody := self statementsTo: elsePc.
			blockBodyReadCounts := tempReadCounts.
			savedReadCounts keysAndValuesDo:
				[:temp :count|
				 blockBodyReadCounts at: temp put: (blockBodyReadCounts at: temp) - count].
			tempReadCounts := savedReadCounts.
			"discard unwanted statements from block"
			blockBody size - 1 timesRepeat: [statements removeLast].
			blockArgs := thenBlock statements = constructor codeEmptyBlock statements
							ifTrue: [#()]
							ifFalse: [{ thenBlock }].
			selector := blockArgs isEmpty
							ifTrue: [sign ifTrue: [#whileFalse] ifFalse: [#whileTrue]]
							ifFalse: [sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]].
			statements addLast:
				(constructor
					codeMessage: (constructor codeBlock: blockBody returns: false)
					selector: (constructor codeSelector: selector code: #macro)
					arguments: blockArgs).
			pc := elseStart.
			selector == #whileTrue: ifTrue:
				[self convertToDoLoop: blockBodyReadCounts]]
		ifFalse:
			["Must be a conditional..."
			elseBlock := self blockTo: thenJump.
			elseJump := exit.
			"if elseJump is backwards, it is not part of the elseExpr"
			elseJump < elsePc ifTrue:
				[pc := lastPc].
			cond := isIfNil
						ifTrue:
							[constructor
								codeMessage: ifExpr ifNilReceiver
								selector: (constructor
											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])
											code: #macro)
								arguments: (Array with: thenBlock)]
						ifFalse:
							[| args |
							args := sign
										ifTrue: [{elseBlock. thenBlock}]
										ifFalse: [{thenBlock. elseBlock}].
							(constructor
								decodeIfNilWithReceiver: ifExpr
								selector: #ifTrue:ifFalse:
								arguments: args
								tempReadCounts: tempReadCounts) ifNil:
									[constructor
										codeMessage: ifExpr
										selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)
										arguments: args]].
			stack := saveStack.
			condHasValue
				ifTrue: [stack addLast: cond]
				ifFalse: [statements addLast: cond]].
	lastJumpIfPcStack removeLast! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 12/29/2024 12:42:50' prior: 16845859!
                          popIntoTemporaryVariable: offset
	| maybeTVTag tempVector start |
	maybeTVTag := stack last.
	((maybeTVTag isMemberOf: Association)
	 and: [maybeTVTag key == #pushNewArray]) ifTrue:
		[blockStartsToTempVars "implies we were intialized with temp names."
			ifNotNil: "Use the provided temps"
				[self assert: ((tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp
							 and: [tempVector isIndirectTempVector
							 and: [tempVector remoteTemps size = maybeTVTag value size]])]
			ifNil: "Synthesize some remote temps"
				[tempVector := maybeTVTag value.
				 offset + 1 <= tempVars size
					ifTrue:
						[start := 2.
						 tempVector at: 1 put: (tempVars at: offset + 1)]
					ifFalse:
						[tempVars := (Array new: offset + 1)
										replaceFrom: 1
										to: tempVars size
										with: tempVars.
						start := 1].
				 start to: tempVector size do:
					[:i|
					tempVector
						at: i
						put: (constructor
								codeTemp: numLocalTemps + offset + i - 1
								named: 'temp', (tempVarCount + i) printString)].
				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].
		 tempVarCount := tempVarCount + maybeTVTag value size.
		 stack removeLast.
		 ^self].
	stack addLast: (offset >= tempVars size
						ifTrue: "Handle the case of chained LiteralVariableBinding assigments"
							[stack at: (offset + 1 - tempVars size)]
						ifFalse: "A regular argument or temporary"
							[tempVars at: offset + 1]).
	self doStore: statements! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 4/24/2017 10:17' prior: 16845979!
          pushTemporaryVariable: offset
	| node |
	offset >= tempVars size
				ifTrue: "Handle the case of chained LiteralVariableBinding assigments"
					[self halt.
					 node := stack at: offset + 1 - tempVars size]
				ifFalse: "A regular argument or temporary"
					[node := tempVars at: offset + 1.
					 node isArg ifFalse: "count temp reads for the whileTrue: => to:do: transformation."
						[tempReadCounts at: node put: (tempReadCounts at: node ifAbsent: [0]) + 1]].
	stack addLast: node! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:35' prior: 16845990!
                      send: selector super: superFlag numArgs: numArgs

	| args rcvr selNode msgNode messages |
	args := Array new: numArgs.
	(numArgs to: 1 by: -1) do:
		[:i | args at: i put: stack removeLast].
	rcvr := stack removeLast.
	superFlag ifTrue: [rcvr := constructor codeSuper].
	selNode := constructor codeAnySelector: selector.
	rcvr == CaseFlag
		ifTrue:
			[| cases stmtStream elements node b |
			selector == #= ifTrue:
					[" = signals a case statement..."
					statements addLast: args first.
					stack addLast: rcvr. "restore CaseFlag"
					^ self].
			selector = #caseError ifFalse: [self error: 'unexpected message send while decompiling a caseOf:'].
			stmtStream := ReadStream on: (self popTo: stack removeLast).
			
			elements := OrderedCollection new.
			b := OrderedCollection new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == CaseFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream next)).
						 b := OrderedCollection new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf: code: #macro)
					arguments: (Array with: cases)).
			^self].
	rcvr == CascadeFlag
		ifTrue:
			["May actually be a cascade or an ifNil: for value."
			self willJumpIfFalse
				ifTrue: "= generated by a case macro"
					[selector == #= ifTrue:
						[" = signals a case statement..."
						statements addLast: args first.
						stack removeLast; addLast: CaseFlag; addLast: CaseFlag.	"Properly mark the case statement"
						^ self].
					selector == #== ifTrue:
						[" == signals an ifNil: for value..."
						stack removeLast; removeLast.
						rcvr := stack removeLast.
						stack addLast: IfNilFlag;
							addLast: (constructor
								codeMessage: rcvr
								selector: selNode
								arguments: args).
						^ self]]
				ifFalse:
					[(self willJumpIfTrue and: [selector == #==]) ifTrue:
						[" == signals an ifNotNil: for value..."
						stack removeLast; removeLast.
						rcvr := stack removeLast.
						stack addLast: IfNilFlag;
							addLast: (constructor
								codeMessage: rcvr
								selector: selNode
								arguments: args).
						^ self]].
			msgNode := constructor
							codeCascadedMessage: selNode
							arguments: args.
			stack last == CascadeFlag ifFalse:
				["Last message of a cascade"
				statements addLast: msgNode.
				messages := self popTo: stack removeLast.  "Depth saved by first dup"
				msgNode := constructor
								codeCascade: stack removeLast
								messages: messages]]
		ifFalse:
			[msgNode := constructor
						codeMessage: rcvr
						selector: selNode
						arguments: args].
	stack addLast: msgNode! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 4/24/2017 10:18' prior: 16846074!
storeIntoTemporaryVariable: offset
	stack addLast: (offset >= tempVars size
						ifTrue: "Handle the case of chained LiteralVariableBinding assigments"
							[stack at: (offset + 1 - tempVars size)]
						ifFalse: "A regular argument or temporary"
							[tempVars at: offset + 1]).
	self doStore: stack! !
!Decompiler methodsFor: 'public access' stamp: 'eem 1/21/2025 15:32' prior: 16846275!
                     decompile: aSelector in: aClass method: aMethod using: aConstructor

	| block node |
	constructor := aConstructor.
	method := aMethod.
	self initSymbols: aClass.  "create symbol tables"
	method isQuick
		ifTrue: [block := self quickMethod]
		ifFalse: 
			[stack := OrderedCollection new.
			lastJumpIfPcStack := OrderedCollection new.
			caseExits := OrderedCollection new.
			statements := OrderedCollection new.
			numLocalTemps := 0.
			self method: method pc: method initialPC.
			"skip primitive error code store if necessary"
			(method primitive ~= 0 and: [self skipCallPrimitive; willStore]) ifTrue:
				[pc := pc + (method encoderClass bytecodeSize: self firstByte).
				 tempVars := tempVars asOrderedCollection].
			block := self blockTo: method endPC + 1.
			stack isEmpty ifFalse: [self error: 'stack not empty']].
	node := constructor
				codeMethod: aSelector
				block: block
				tempVars: tempVars
				primitive: method primitive
				class: aClass.
	method primitive > 0 ifTrue:
		[node removeAndRenameLastTempIfErrorCode].
	^node preen! !
!Decompiler methodsFor: 'public access' stamp: 'jmv 9/25/2019 17:51:15' prior: 16846311!
      decompileBlock: aBlock 
	"Decompile aBlock, returning the result as a BlockNode.  
	Show temp names from source if available."
	"Decompiler new decompileBlock: [3 + 4]"
	| methodNode home |
	(home := aBlock home) ifNil: [^ nil].
	method := home method.
	(home methodClass) == #unknown ifTrue: [^ nil].
	aBlock isClosure ifTrue:
		[(methodNode := method decompile)
			ifNil: [^nil]
			ifNotNil: [methodNode nodesDo: [:node| node pc = aBlock startpc ifTrue: [^node]]].
		 ^self error: 'cannot find block node matching aBlock'].
	^self error: 'can only decompile BlockClosures'! !
!Decompiler methodsFor: 'initialization' stamp: 'eem 12/28/2024 14:29:22' prior: 16846338!
   initSymbols: aClass
	| argCount |
	constructor method: method class: aClass literals: method literals.
	constTable := constructor codeConstants.
	instVars := Array new: aClass instSize.
	tempVarCount := method numTemps.
	argCount := method numArgs.
	"(tempVars isNil
	 and: [method holdsTempNames]) ifTrue:
		[tempVars := method tempNamesString]."
	tempVars isString
		ifTrue:
			[blockStartsToTempVars := self mapFromBlockStartsIn: method
											toTempVarsFrom: tempVars
											constructor: constructor.
			 tempVars := blockStartsToTempVars at: method initialPC]
		ifFalse:
			[| namedTemps |
			namedTemps := tempVars ifNil: [(1 to: tempVarCount) collect: [ :i | 
					(i <= argCount ifTrue: ['arg'] ifFalse: ['temp']), i printString]].
			tempVars := (1 to: tempVarCount) collect:
							[:i | i <= namedTemps size
								ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]
								ifFalse: [constructor codeTemp: i - 1]]].
	1 to: method numArgs do:
		[:i|
		(tempVars at: i)
			beMethodArg].
	tempReadCounts := Dictionary new! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'ct 12/30/2023 20:23' prior: 16837100!
   jump: distance if: condition 
	"Simulate the action of a 'conditional jump' bytecode whose offset is the 
	 argument, distance, and whose condition is the argument, condition."

	| bool |
	bool := self pop.
	condition == bool
		ifTrue: [self jump: distance]
		ifFalse:
			[(true == bool or: [false == bool]) ifFalse:
				[^self send: #mustBeBoolean to: bool with: #()]]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:29' prior: 16837143!
             popIntoLiteralVariable: value 
	"Simulate the action of bytecode that removes the top of the stack and 
	 stores it into a literal variable of my method. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self pop.
	result := self simulatedObject: value instVarAt: ValueIndex put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:30' prior: 16837153!
                            popIntoReceiverVariable: offset 
	"Simulate the action of bytecode that removes the top of the stack and 
	 stores it into an instance variable of my receiver. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self pop.
	result := self simulatedObject: self receiver instVarAt: offset + 1 put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/29/2017 12:48' prior: 16837176!
              popIntoTemporaryVariable: offset 
	"Simulate the action of bytecode that removes the top of the stack and 
	stores it into one of my temporary variables."

	self at: offset + 1 put: self pop! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 12/26/2024 14:04:11' prior: 16837220!
                            pushLiteralVariable: value 
	"Simulate the action of bytecode that pushes the contents of the literal 
	variable whose index is the argument, index, on the top of the stack."

	self push: (self object: value instVarAt: ValueIndex)! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 12/24/2024 19:40:19' prior: 16837298!
                    send: selector super: superFlag numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, 
	 selector. The argument, superFlag, tells whether the receiver of the 
	 message was specified with 'super' in the source method. The arguments 
	 of the message are found in the top numArgs locations on the stack and 
	 the receiver just below them."

	| thisReceiver arguments lookupClass |
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].
	thisReceiver := self pop.
	lookupClass := superFlag
					ifTrue: [self method methodClassAssociation value superclass]
					ifFalse: [self objectClass: thisReceiver].
	QuickStep == self ifTrue:
		[QuickStep := nil.
		^self quickSend: selector to: thisReceiver with: arguments lookupIn: lookupClass].
	^self send: selector to: thisReceiver with: arguments lookupIn: lookupClass! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:31' prior: 16837323!
    storeIntoLiteralVariable: value 
	"Simulate the action of bytecode that stores the top of the stack into a 
	literal variable of my method. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self top.
	result := self simulatedObject: value instVarAt: ValueIndex put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:32' prior: 16837333!
          storeIntoReceiverVariable: offset 
	"Simulate the action of bytecode that stores the top of the stack into an 
	instance variable of my receiver. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self top.
	result := self simulatedObject: self receiver instVarAt: offset + 1 put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/29/2017 12:48' prior: 16837355!
                            storeIntoTemporaryVariable: offset 
	"Simulate the action of bytecode that stores the top of the stack into one 
	of my temporary variables."

	self at: offset + 1 put: self top! !
!ContextPart methodsFor: 'controlling' stamp: 'jar 2/14/2023 22:06' prior: 16837746!
                      restart
	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	^self resumeEvaluating: [self privRefresh]! !
!ContextPart methodsFor: 'controlling' stamp: 'ct 3/25/2022 18:36' prior: 16837930!
           send: selector to: rcvr with: arguments lookupIn: lookupClass
	"Simulate the action of sending a message with selector and arguments to rcvr. The argument, lookupClass, is the class in which to lookup the message. This is the receiver's class for normal messages, but for super messages it will be some specific class related to the source method."

	| meth |
	(meth := lookupClass lookupSelector: selector) ifNil:
		[selector == #doesNotUnderstand: ifTrue:
			[self error: 'Recursive message not understood!!' translated].
		^self send: #doesNotUnderstand:
				to: rcvr
				with: {(Message selector: selector arguments: arguments) lookupClass: lookupClass}
				lookupIn: lookupClass].
	
	^ self
		executeMethod: meth
		forSelector: selector
		withArgs: arguments
		receiver: rcvr! !
!ContextPart methodsFor: 'private' stamp: 'ct 3/3/2024 19:22' prior: 16838165!
 doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and
	 arguments are given as arguments to this message. If successful, push result and return
	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes
	 execution needs to be intercepted and simulated to avoid execution running away."

	| value |
	"Test for unsimulatable side effects (that is, code that will be triggered in the image outside of the simulator range). This includes simulation guards, which are traditionally flagged using primitive 19 (a null primitive that doesn't do anything), as well as certain control primitives that might trigger code on other processes. If a side effect is detected, raise a warning to give the user/client a chance to cancel or virtualize the operation."
	"#(19 87) do: [:primitive | self systemNavigation browseAllSelect: [:m | m primitive = primitive]]"
	(primitiveIndex = 19 "simulationGuard" or: [primitiveIndex = 87 "primitiveResume"]) ifTrue:
		[[(SimulationSideEffectWarning forPrimitive: primitiveIndex)
			context: self method: meth receiver: receiver arguments: arguments;
			signalIfSkipped: [^ self]]
				ifCurtailed:
					[self push: receiver "Cheap fix of the context's internal state. Note that unwinding the receiver -- so that the next step would invoke the primitive again -- would be challenging due to to the variety of senders to this method."]].
	
	((primitiveIndex between: 201 and: 222)
	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:
		[(primitiveIndex = 206
		  or: [primitiveIndex = 208]) ifTrue:						"[Full]BlockClosure>>valueWithArguments:"
			[^receiver simulateValueWithArguments: arguments first caller: self].
		 ((primitiveIndex between: 201 and: 209)			 "[Full]BlockClosure>>value[:value:...]"
		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "[Full]BlockClosure>>valueNoContextSwitch[:]"
			[^receiver simulateValueWithArguments: arguments caller: self]].

	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"
		[| selector |
		selector := arguments at: 1 ifAbsent:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: arguments allButFirst].
	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"
		[| selector args |
		arguments size = 2 ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		selector := arguments first.
		args := arguments second.
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: args].
	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"
		[| rcvr selector args superclass |
		arguments size
			caseOf: {
				[3] -> [
					rcvr := receiver.
					selector := arguments first.
					args := arguments second.
					superclass := arguments third].
				[4] -> ["mirror primitive"
					rcvr := arguments first.
					selector := arguments second.
					args := arguments third.
					superclass := arguments fourth] }
			otherwise: [^ self class primitiveFailTokenFor: #'bad number of arguments'].
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		((self objectClass: rcvr) includesBehavior: superclass) ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: rcvr with: args lookupIn: superclass].

	"Mutex>>primitiveEnterCriticalSection
	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSection"
	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:
		[| effective |
		 effective := Processor activeProcess effectiveProcess.
		 "active == effective"
		 value := primitiveIndex = 186
					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]
					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].
		 ^(self isPrimFailToken: value)
			ifTrue: [value]
			ifFalse: [self push: value]].
	
	(primitiveIndex = 188 or: [primitiveIndex = 189]) ifTrue:
		[| n args methodArg thisReceiver |
		 primitiveIndex caseOf:
			{[188 "primitiveExecuteMethodArgsArray"] ->
				["Object>>withArgs:executeMethod:
				  CompiledMethod class>>receiver:withArguments:executeMethod:
				  VMMirror>>ifFail:object:with:executeMethod: et al"
				 ((n := arguments size) between: 2 and: 4) ifFalse:
					[^self class primitiveFailTokenFor: #'unsupported operation'].
				 ((self objectClass: (args := arguments at: n - 1)) == Array
				  and: [(self objectClass: (methodArg := arguments at: n)) includesBehavior: CompiledMethod]) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 thisReceiver := arguments at: n - 2 ifAbsent: [receiver]].
			 [189 "primitiveExecuteMethod"] ->
				["Object>>executeMethod:
				  Object>>with:...executeMethod:"
				 (arguments size > 0) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 ((self objectClass: (methodArg := arguments atLast: 1)) includesBehavior: CompiledMethod) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 args := arguments allButLast.
				 thisReceiver := receiver]}.
		 methodArg numArgs = args size ifFalse:
			[^self class primitiveFailTokenFor: #'bad number of arguments'].
		 methodArg primitive > 0 ifTrue:
			[methodArg isQuick ifTrue:
				[^self push: (methodArg valueWithReceiver: thisReceiver arguments: args)].
			 ^self doPrimitive: methodArg primitive method: methodArg receiver: thisReceiver args: args].
		 ^self
			activateMethod: methodArg
			withArgs: args
			receiver: thisReceiver].

	primitiveIndex = 118 ifTrue: "[receiver:]tryPrimitive:withArgs:; avoid recursing in the VM"
		[(arguments size = 3
		  and: [(self objectClass: arguments second) == SmallInteger
		  and: [(self objectClass: arguments last) == Array]]) ifTrue:
			[^self doPrimitive: arguments second method: meth receiver: arguments first args: arguments last].
		 (arguments size = 2
		 and: [(self objectClass: arguments first) == SmallInteger
		 and: [(self objectClass: arguments last) == Array]]) ifFalse:
			[^self class primitiveFailTokenFor: -3].
		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].

	value := primitiveIndex = 120 "FFI method"
				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]
				ifFalse:
					[primitiveIndex = 117 "named primitives"
						ifTrue: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]
						ifFalse: "should use self receiver: receiver tryPrimitive: primitiveIndex withArgs: arguments but this is only in later VMs (and appears to be broken)"
							[receiver tryPrimitive: primitiveIndex withArgs: arguments]].

	^(self isPrimFailToken: value)
		ifTrue: [value]
		ifFalse: [self push: value]! !
!ContextPart methodsFor: 'private' stamp: 'eem 12/26/2024 14:03:04' prior: 16838330!
                isPrimFailToken: anObject
	^(self objectClass: anObject) == Array
	  and: [anObject size = 2
	  and: [anObject first == PrimitiveFailToken]]! !
!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 2/22/2019 16:26' prior: 16838911!
                     object: anObject instVarAt: anIndex
	"Primitive. Answer a fixed variable in an object. The numbering of the 
	 variables corresponds to the named instance variables. Fail if the index 
	 is not an Integer or is not the index of a fixed variable. Essential for the
	 debugger. See  Object documentation whatIsAPrimitive."

	<primitive: 173 error: ec>
	self primitiveFailed! !
!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 3/11/2020 18:06' prior: 16838928!
              object: anObject instVarAt: anIndex put: aValue 
	"Primitive. Store a value into a fixed variable in the argument anObject.
	 The numbering of the variables corresponds to the named instance
	 variables.  Fail if the index is not an Integer or is not the index of a
	 fixed variable, or if anObject is read-only.  Answer the value stored as
	 the result. Using this message violates the  principle that each object
	 has sovereign control over the storing of values into its instance variables.
	 Essential for the debugger. See Object documentation whatIsAPrimitive."

	<primitive: 174 error: ec>
	ec == #'no modification' ifTrue:
		[^self modificationForbiddenFor: anObject instVarAt: anIndex put: aValue].
	self primitiveFailed! !
!ContextPart class methodsFor: 'simulation' stamp: 'eem 12/26/2024 14:03:14' prior: 16839131!
    primitiveFailTokenFor: errorCode

	^{PrimitiveFailToken. errorCode}! !
!ContextPart class methodsFor: 'cached class state' stamp: 'eem 12/26/2024 14:02:45' prior: 16839244 overrides: 16885795!
                               releaseClassCachedState

	QuickStep := nil! !
!Debugger class methodsFor: 'instance creation' stamp: 'eem 12/24/2024 19:42:44' prior: 16844145!
                informExistingDebugger: aContext label: aString
	"Walking the context chain, we try to find out if we're in a debugger stepping situation.
	If we find the relevant contexts, we must rearrange them so they look just like they would
	if the methods were excuted outside of the debugger."
	| ctx quickStepMethod oldSender baseContext |
	ctx := thisContext.
	quickStepMethod := ContextPart compiledMethodAt: #quickSend:to:with:lookupIn:.
	[ctx sender == nil or: [ctx sender method == quickStepMethod]] whileFalse: [ctx := ctx sender].
	ctx sender ifNil: [^self].
	baseContext := ctx.
	"baseContext is now the context created by the #quickSend... method."
	oldSender := ctx := ctx sender home sender.
	"oldSender is the context which originally sent the #quickSend... method"
	[ctx == nil or: [ctx receiver isKindOf: self]] whileFalse: [ctx := ctx sender].
	ctx == nil ifTrue: [^self].
	"ctx is the context of the Debugger method #doStep"
	ctx receiver labelString: aString.
	baseContext swapSender: baseContext sender sender sender.	"remove intervening contexts"
	thisContext swapSender: oldSender.	"make myself return to debugger"
	^aContext! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'eem 12/27/2024 15:53:47' prior: 16955229!
                 explainTemp: string 
	"Is string the name of a temporary variable (method or block argument or temporary)?"

	| selectedClass methodNode tempNode |
	self codeProvider selectedMessageName ifNil: [^nil].	"not in a method"
	selectedClass := self codeProvider selectedClassOrMetaClass.
	methodNode := selectedClass parserClass new parse: self codeProvider selectedMessage class: selectedClass.
	tempNode := methodNode encoder tempNodes detect: [ :n | n name = string ] ifNone: [^nil].
	^(tempNode isArg
		ifTrue: [string, ' is an argument to this ']
		ifFalse: [string, ' is a temporary variable in this ']),
	   (tempNode isDeclaredAtMethodLevel
		ifTrue: ['method ']
		ifFalse: ['block '])! !

UndefinedObject removeSelector: #literalIndexOfBytecodeAt:in:!

ContextPart class removeSelector: #primitiveFailToken!

!methodRemoval: ContextPart class #primitiveFailToken stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
primitiveFailToken
	"A unique object to be returned when a primitive fails during simulation"
	PrimitiveFailToken ifNil: [ PrimitiveFailToken := Object new ].
	^ PrimitiveFailToken!

ContextPart class removeSelector: #valueIndex!

!methodRemoval: ContextPart class #valueIndex stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
valueIndex
	ValueIndex ifNil: [
		ValueIndex := 2.
		self assert: (Association instVarNameForIndex: ValueIndex) = 'value' ].
	^ ValueIndex!

ContextPart removeSelector: #quickSend:to:with:super:!

!methodRemoval: ContextPart #quickSend:to:with:super: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
quickSend: selector to: rcvr with: arguments super: superFlag
	"Send the given selector with arguments in an environment which closely resembles
	 the non-simulating environment, with an interjected unwind-protected block to catch
	 nonlocal returns.  Attention: don't get lost!!  This beautiful method is due to
	 Hans-Martin Mosner.  Eliot Miranda merely added the mirror primitive code."
	| oldSender contextToReturnTo result lookupClass |
	contextToReturnTo := self.
	lookupClass := superFlag
					ifTrue: [self method methodClassAssociation value superclass]
					ifFalse: [self objectClass: rcvr].
	[oldSender := thisContext sender swapSender: self.
	 result := self object: rcvr perform: selector withArguments: arguments inClass: lookupClass.
	 thisContext sender swapSender: oldSender] ifCurtailed:
		[contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"
		contextToReturnTo pc: contextToReturnTo previousPc.	"skip to front of return bytecode causing this unwind"
		contextToReturnTo willReturnTopFromMethod ifTrue:
			"If it was a returnTop, push the value to be returned.
			Otherwise the value is implicit in the bytecode"
			[contextToReturnTo push: (thisContext sender tempAt: 1)].
		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"
		contextToReturnTo].
	contextToReturnTo push: result.
	^contextToReturnTo!

Decompiler removeSelector: #printInstVarNamed:at:on:asPc:!

Decompiler removeSelector: #convertToDoLoop!

!methodRemoval: Decompiler #convertToDoLoop stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
convertToDoLoop
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]"
	| leaveOnStack initStmt toDoStmt limitStmt |
	leaveOnStack := false.
	(stack notEmpty
	 and: [
		(#(CaseFlag CascadeFlag) statePointsTo: stack last) not
			and: [ stack last isAssignmentNode]])
		ifTrue:
			[initStmt := stack last.
			 (toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			 stack removeLast.
			 statements removeLast; addLast: toDoStmt.
			 leaveOnStack := true]
		ifFalse:
			[statements size < 2 ifTrue:
				[^self].
			initStmt := statements at: statements size-1.
			(toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			statements removeLast; removeLast; addLast: toDoStmt].
	initStmt variable scope: -1.  "Flag arg as block temp"

	"Attempt further conversion of the pattern
		limitVar := limitExpr.
		startExpr to: limitVar by: incConst do: [:var | ...statements...]
	to
		startExpr to: limitExpr by: incConst do: [:var | ...statements...].
	The complication here is that limitVar := limitExpr's value may be used, in which case it'll
	be statements last, or may not be used, in which case it'll be statements nextToLast."
	statements size < 2 ifTrue:
		[leaveOnStack ifTrue:
			[stack addLast: statements removeLast].
			 ^self].
	limitStmt := statements last.
	((limitStmt isMemberOf: AssignmentNode)
		and: [limitStmt variable isTemp
		and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
			[limitStmt := statements at: statements size-1.
			((limitStmt isMemberOf: AssignmentNode)
				and: [limitStmt variable isTemp
				and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
					[leaveOnStack ifTrue:
						[stack addLast: statements removeLast].
					^self]].

	(self blockScopeRefersOnlyOnceToTemp: limitStmt variable fieldOffset) ifFalse:
		[^self].
	toDoStmt arguments at: 1 put: limitStmt value.
	limitStmt variable scope: -2.  "Flag limit var so it won't print"
	statements last == limitStmt
		ifTrue: [statements removeLast]
		ifFalse: [statements removeLast; removeLast; addLast: toDoStmt]!

Decompiler removeSelector: #withTempNames:!

!methodRemoval: Decompiler #withTempNames: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
withTempNames: tempNames "<Array|String>"
	"Optionally initialize the temp names to be used when decompiling.
	 For backward-copmpatibility, if tempNames is an Array it is a single
	 vector of temp names, probably for a blue-book-compiled method.
	 If tempNames is a string it is a schematic string that encodes the
	 layout of temp vars in the method and any closures/blocks within it.
	 Decoding encoded tempNames is done in decompile:in:method:using:
	 which has the method from which to derive blockStarts.
	 See e.g. BytecodeEncoder>>schematicTempNamesString for syntax."
	tempVars := tempNames!

Decompiler removeSelector: #methodRefersOnlyOnceToTemp:!

Decompiler removeSelector: #doClosureCopy:copiedValues:!

InstructionStream class removeSelector: #releaseClassCachedState!

!methodRemoval: InstructionStream class #releaseClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
releaseClassCachedState

	SpecialConstants := nil!

InstructionStream class removeSelector: #specialConstants!

!methodRemoval: InstructionStream class #specialConstants stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
specialConstants
	SpecialConstants ifNil: [ self initSpecialConstants ].
	^SpecialConstants!

InstructionStream class removeSelector: #initSpecialConstants!

!methodRemoval: InstructionStream class #initSpecialConstants stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
initSpecialConstants
	"Initialize an array of special constants returned by single-bytecode returns."

	SpecialConstants := 
		(Array with: true with: false with: nil)
			, (Array with: -1 with: 0 with: 1 with: 2)	
	"
	InstructionStream initSpecialConstants
	"
!

InstructionStream removeSelector: #interpretExtension:in:for:!

!methodRemoval: InstructionStream #interpretExtension:in:for: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
interpretExtension: offset in: method for: client
	| type offset2 byte2 byte3 byte4 |
	offset <= 6 ifTrue: 
		["Extended op codes 128-134"
		byte2 := method at: pc. pc := pc + 1.
		offset <= 2 ifTrue:
			["128-130:  extended pushes and pops"
			type := byte2 // 64.
			offset2 := byte2 \\ 64.
			offset = 0 ifTrue: 
				[type = 0 ifTrue: [^client pushReceiverVariable: offset2].
				type = 1 ifTrue: [^client pushTemporaryVariable: offset2].
				type = 2  ifTrue: [^client pushConstant: (method literalAt: offset2 + 1)].
				type = 3 ifTrue: [^client pushLiteralVariable: (method literalAt: offset2 + 1)]].
			offset = 1 ifTrue: 
				[type = 0 ifTrue: [^client storeIntoReceiverVariable: offset2].
				type = 1 ifTrue: [^client storeIntoTemporaryVariable: offset2].
				type = 2 ifTrue: [self error: 'illegalStore'].
				type = 3 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].
			offset = 2 ifTrue: 
				[type = 0 ifTrue: [^client popIntoReceiverVariable: offset2].
				type = 1 ifTrue: [^client popIntoTemporaryVariable: offset2].
				type = 2 ifTrue: [self error: 'illegalStore'].
				type = 3  ifTrue: [^client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].
		"131-134: extended sends"
		offset = 3 ifTrue:  "Single extended send"
			[^client send: (method literalAt: byte2 \\ 32 + 1)
					super: false numArgs: byte2 // 32].
		offset = 4 ifTrue:    "Double extended do-anything"
			[byte3 := method at: pc. pc := pc + 1.
			type := byte2 // 32.
			type = 0 ifTrue: [^client send: (method literalAt: byte3 + 1)
									super: false numArgs: byte2 \\ 32].
			type = 1 ifTrue: [^client send: (method literalAt: byte3 + 1)
									super: true numArgs: byte2 \\ 32].
			type = 2 ifTrue: [^client pushReceiverVariable: byte3].
			type = 3 ifTrue: [^client pushConstant: (method literalAt: byte3 + 1)].
			type = 4 ifTrue: [^client pushLiteralVariable: (method literalAt: byte3 + 1)].
			type = 5 ifTrue: [^client storeIntoReceiverVariable: byte3].
			type = 6 ifTrue: [^client popIntoReceiverVariable: byte3].
			type = 7 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].
		offset = 5 ifTrue:  "Single extended send to super"
			[^client send: (method literalAt: byte2 \\ 32 + 1)
					super: true numArgs: byte2 // 32].
		offset = 6 ifTrue:   "Second extended send"
			[^client send: (method literalAt: byte2 \\ 64 + 1)
					super: false numArgs: byte2 // 64]].
	offset = 7 ifTrue: [^client doPop].
	offset = 8 ifTrue: [^client doDup].
	offset = 9 ifTrue: [^client pushActiveContext].
	byte2 := method at: pc. pc := pc + 1.
	offset = 10 ifTrue:
		[^byte2 < 128
			ifTrue: [client pushNewArrayOfSize: byte2]
			ifFalse: [client pushConsArrayWithElements: byte2 - 128]].
	offset = 11 ifTrue: [^self error: 'unusedBytecode'].
	byte3 := method at: pc.  pc := pc + 1.
	offset = 12 ifTrue: [^client pushRemoteTemp: byte2 inVectorAt: byte3].
	offset = 13 ifTrue: [^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].
	offset = 14 ifTrue: [^client popIntoRemoteTemp: byte2 inVectorAt: byte3].
	"offset = 15"
	byte4 := method at: pc.  pc := pc + 1.
	^client
		pushClosureCopyNumCopiedValues: (byte2 bitShift: -4)
		numArgs: (byte2 bitAnd: 16rF)
		blockSize: (byte3 * 256) + byte4!

InstructionStream removeSelector: #scanForInstructionSequence:!

InstructionStream removeSelector: #blockMethodOrNil!

InstructionPrinter removeSelector: #pushFullClosure:numCopied:receiverOnStack:ignoreOuterContext:!

InstructionPrinter removeSelector: #pushFullClosure:numCopied:!

NarrowerVariableScopeFinder removeSelector: #visitVariableUsageNode:!

MessageNode class removeSelector: #releaseClassCachedState!

!methodRemoval: MessageNode class #releaseClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
releaseClassCachedState

	MacroSelectors := nil.
	MacroTransformers := nil.
	MacroEmitters := nil.
	MacroSizers := nil.
	MacroPrinters := nil!

MessageNode class removeSelector: #new!

!methodRemoval: MessageNode class #new stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
new
	MacroSelectors ifNil: [ self initClassCachedState ].
	^super new!

MessageNode class removeSelector: #initClassCachedState!

!methodRemoval: MessageNode class #initClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
initClassCachedState
	"
	MessageNode initialize
	"
	MacroSelectors := 
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:
			repeat ).
	MacroTransformers := 
		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:
			transformAnd: transformOr:
			transformWhile: transformWhile: transformWhile: transformWhile:
			transformToDo: transformToDo:
			transformCase: transformCase:
			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:
			transformRepeat: ).
	MacroEmitters := 
		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:
			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:
			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForRepeat:encoder:value:).
	MacroSizers := 
		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:
			sizeCodeForToDo:value: sizeCodeForToDo:value:
			sizeCodeForCase:value: sizeCodeForCase:value:
			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForRepeat:value:).
	MacroPrinters := 
		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:
			printIfOn:indent: printIfOn:indent:
			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:
			printToDoOn:indent: printToDoOn:indent:
			printCaseOn:indent: printCaseOn:indent:
			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:
			printRepeatOn:indent:).
	Preferences
		name: #allowNonBooleanReceiversOfBooleanMessages
		description: 'If set, do not optimize boolean selectors, allowing, for example, new Boolean classes.'
		category: #programming type: Boolean value: false!

RemoteTempVectorNode removeSelector: #emitCodeForIndexOf:stack:encoder:!

!methodRemoval: RemoteTempVectorNode #emitCodeForIndexOf:stack:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder
	self assert: encoder supportsClosureOpcodes not.
	(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode))
		emitCodeForValue: stack encoder: encoder!

RemoteTempVectorNode removeSelector: #sizeCodeForIndexOf:encoder:!

!methodRemoval: RemoteTempVectorNode #sizeCodeForIndexOf:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForIndexOf: aTempVariableNode encoder: encoder
	self assert: encoder supportsClosureOpcodes not.
	^(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode)) sizeCodeForValue: encoder!

RemoteTempVectorNode removeSelector: #sizeCodeForLoadFor:encoder:!

!methodRemoval: RemoteTempVectorNode #sizeCodeForLoadFor:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForLoadFor: aTempVariableNode encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^0].
	"Need to size the first half of
		tempVector at: index put: expr
	 i.e. the push of tempVector and index."
	^(super sizeCodeForValue: encoder)
	+ (self sizeCodeForIndexOf: aTempVariableNode encoder: encoder)!

RemoteTempVectorNode removeSelector: #emitCodeForLoadFor:stack:encoder:!

!methodRemoval: RemoteTempVectorNode #emitCodeForLoadFor:stack:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForLoadFor: aTempVariableNode stack: stack encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^self].
	"Need to generate the first half of
		tempVector at: index put: expr
	 i.e. the push of tempVector and index."
	super emitCodeForValue: stack encoder: encoder.
	self emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder!

TempVariableNode removeSelector: #emitCodeForLoad:forValue:encoder:!

!methodRemoval: TempVariableNode #emitCodeForLoad:forValue:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	remoteNode ~~ nil ifTrue:
		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]!

TempVariableNode removeSelector: #sizeCodeForLoad:forValue:!

!methodRemoval: TempVariableNode #sizeCodeForLoad:forValue: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForLoad: encoder forValue: forValue
	^remoteNode
		ifNil: [0]
		ifNotNil: [remoteNode sizeCodeForLoadFor: self encoder: encoder]!

VariableNode removeSelector: #emitCodeForLoad:forValue:encoder:!

!methodRemoval: VariableNode #emitCodeForLoad:forValue:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	"Do nothing"!

MethodNode removeSelector: #preenIfNotNilNode:!

MethodNode removeSelector: #preenNilNodeFollowingNilIfNode:!

MethodNode removeSelector: #preenTempsConflictingWithBlockNode:!

MethodNode removeSelector: #preenLocalIfNotNilArg!

!methodRemoval: MethodNode #preenLocalIfNotNilArg stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
preenLocalIfNotNilArg
	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| varsToHide |
	varsToHide := Set new.
	self nodesDo:
		[:node| | variable |
		(node isMessageNode
		and: [node macroPrinter == #printIfNilNotNil:indent:
		and: [node receiver isMessageNode
		and: [node receiver selector key == #==
		and: [node receiver receiver isAssignmentNode
		and: [(variable := node receiver receiver variable) isTemp
		and: [variable isRemote not
		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:
			[node arguments last arguments isEmpty
				ifTrue: [node arguments last arguments: { variable }.
						varsToHide add: variable]
				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].
			 node receiver receiver: node receiver receiver value]].
	varsToHide notEmpty ifTrue:
		[self nodesDo:
			[:node|
			((node == self or: [node isBlockNode])
			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:
				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]!

BlockNode removeSelector: #sizeCodeForClosureValue:!

!methodRemoval: BlockNode #sizeCodeForClosureValue: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForClosureValue: encoder
	"Compute the size for the creation of the block and its code."
	"If we have the closure bytecodes constructClosureCreationNode: will note
	 the copied values in the copiedValues inst var and answer #pushCopiedValues."
	closureCreationNode := self constructClosureCreationNode: encoder.
	"Remember size of body for emit time so we know the size of the jump around it."
	size := self sizeCodeForEvaluatedClosureValue: encoder.
	^encoder supportsClosureOpcodes
		ifTrue:
			[(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
			 + (encoder sizePushClosureCopyNumCopiedValues: copiedValues size numArgs: arguments size jumpSize: size)
			 + size]
		ifFalse:
			["closureCreationSupportNode is send closureCopy:copiedValues:"
			(closureCreationNode sizeCodeForValue: encoder)
			 + (encoder sizeJumpLong: size)
			 + size]!

BlockNode removeSelector: #emitCodeForClosureValue:encoder:!

!methodRemoval: BlockNode #emitCodeForClosureValue:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForClosureValue: stack encoder: encoder
	"if not supportsClosureOpcodes closureCreationSupportNode is the
	 node for thisContext closureCopy: numArgs [ copiedValues: { values } ]"
	encoder supportsClosureOpcodes
		ifTrue:
			[copiedValues do:
				[:copiedValue| copiedValue emitCodeForValue: stack encoder: encoder].
			 closureCreationNode pc: encoder methodStreamPosition + 1.
			 encoder
				genPushClosureCopyNumCopiedValues: copiedValues size
				numArgs: arguments size
				jumpSize: size.
			 stack
				pop: copiedValues size;
				push: 1]
		ifFalse:
			[closureCreationNode emitCodeForValue: stack encoder: encoder.
			 encoder genJumpLong: size]. "Force a two byte jump."
	"Emit the body of the block"
	self emitCodeForEvaluatedClosureValue: stack encoder: encoder!

BlockNode removeSelector: #ensureClosureCreationNode!

EncoderForV3PlusClosures class removeSelectorIfInBaseSystem: #literalIndexOfBytecodeAt:in:!

EncoderForV3PlusClosures removeSelector: #if:isSpecialLiteralForPush:!

EncoderForV3PlusClosures removeSelector: #if:isSpecialLiteralForReturn:!

EncoderForV3PlusClosures removeSelector: #isSpecialLiteralForReturn:!

EncoderForV3PlusClosures removeSelector: #genPushNClosureTemps:!

!methodRemoval: EncoderForV3PlusClosures #genPushNClosureTemps: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
genPushNClosureTemps: numTemps
	numTemps timesRepeat: [self genPushSpecialLiteral: nil]!

EncoderForV3PlusClosures removeSelector: #supportsClosureOpcodes!

!methodRemoval: EncoderForV3PlusClosures #supportsClosureOpcodes stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
supportsClosureOpcodes
	^true!

EncoderForSistaV1 class removeSelector: #supportsClosures!

EncoderForSistaV1 class removeSelector: #method:refersInBytecodeToLiteral:specialSelectorIndex:!

EncoderForSistaV1 class removeSelector: #isBranchAt:in:!

EncoderForSistaV1 class removeSelector: #nopCode!

EncoderForSistaV1 class removeSelector: #blockMethodOrNilFor:in:at:!

EncoderForSistaV1 class removeSelector: #isRealSendAt:in:!

EncoderForSistaV1 class removeSelectorIfInBaseSystem: #literalIndexOfBytecodeAt:in:!

EncoderForSistaV1 removeSelector: #isSpecialLiteralForReturn:!

BytecodeEncoder removeSelector: #supportsClosureOpcodes!

!methodRemoval: BytecodeEncoder #supportsClosureOpcodes stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
supportsClosureOpcodes
	"Answer if the receiver supports the
		genPushNewArray:/genPushConsArray:
		genPushRemoteTemp:inVectorAt:
		genStoreRemoteTemp:inVectorAt:
		genStorePopRemoteTemp:inVectorAt:
		genPushClosureCopyCopiedValues:numArgs:jumpSize:
	 opcodes"
	^false!

BytecodeEncoder removeSelectorIfInBaseSystem: #litIndexOrNilFor:!

Encoder removeSelector: #initForCuisWithClass:literalStream:!

Encoder removeSelectorIfInBaseSystem: #initPreFullBlocksClass:literalStream:!

Encoder removeSelectorIfInBaseSystem: #initClass:literalStream:!

ParseNode class removeSelector: #releaseClassCachedState!

!methodRemoval: ParseNode class #releaseClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
releaseClassCachedState

	LdInstType := LdTempType := LdLitType := LdLitIndType := SendType := nil.
	CodeBases := CodeLimits := nil.
	LdSelf := LdTrue := LdFalse := nil.
	LdNil := LdMinus1 := LoadLong := nil.
	LdSuper := Pop := nil.
	LdThisContext := EndRemote := nil.
	SendPlus := Send := nil!

ParseNode class removeSelector: #new!

!methodRemoval: ParseNode class #new stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
new
	LdInstType ifNil: [
		ParseNode initClassCachedState.
		VariableNode initClassCachedState ].
	^super new!

ParseNode class removeSelector: #initClassCachedState!

!methodRemoval: ParseNode class #initClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
initClassCachedState
	"
	ParseNode initialize. VariableNode initialize
	"
	LdInstType := 1.
	LdTempType := 2.
	LdLitType := 3.
	LdLitIndType := 4.
	SendType := 5.
	"Back in the day the following constants corresponded to bytecodes.
	 Now they're just unique values that need to be eliminated when and if
	 things like code:type: are cleaned up."
	CodeBases := #(0 16 32 64 208 ).
	CodeLimits := #(16 16 32 32 16 ).
	LdSelf := 112.
	LdTrue := 113.
	LdFalse := 114.
	LdNil := 115.
	LdMinus1 := 116.
	LoadLong := 128.
	LdSuper := 133.
	Pop := 135.
	LdThisContext := 137.
	EndRemote := 125.
	SendPlus := 176.
	Send := 208.
	
	"((ParseNode class >> #initialize) literals select: [:l| l isVariableBinding and: [(ParseNode classPool includesAssociation: l) and: [(self systemNavigation allCallsOn: l localTo: ParseNode) size = 1]]]) sort: [:a :b| a key <= b key]"

	"ParseNode classPool associations select: [:a| (self systemNavigation allCallsOn: a localTo: ParseNode) isEmpty]"!

ParseNode removeSelector: #isOnlySubnodeOf:in:!

!methodRemoval: ParseNode #isOnlySubnodeOf:in: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
isOnlySubnodeOf: aSubtree "<ParseNode>" in: aParseTree "<ParseNode>"
	"Answer if the receiver only occurs within aSubtree of aParseTree, not in the rest of aParseTree.
	 Assumes that aSubtree is in fact a subnode of aParseTree."
	| isSubnode |
	isSubnode := false.
	aSubtree accept: (ParseNodeEnumerator
							ofBlock: [:node| node == self ifTrue: [isSubnode := true]]).
	isSubnode ifFalse:
		[^false].
	aParseTree accept: (ParseNodeEnumerator
							ofBlock: [:node| node == self ifTrue: [^false]]
							select: [:node| node ~= aSubtree]).
	^true!

WriteStream removeSelectorIfInBaseSystem: #crtab!

ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #CompiledMethod category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'Kernel-Methods'!

InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts'
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Decompiler category: #'Compiler-Kernel' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts'
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6996] on 22 January 2025 at 8:26:14 am'!
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:25:53'!
      browseEqEqSentToNumericConstants
	"
	Smalltalk browseEqEqSentToNumericConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isLiteralNumber or: [ node arguments first isLiteralNumber ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:26:02'!
                              browseEqSentToCharacterConstants
	"
	Smalltalk browseEqSentToCharacterConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#= #~= ) identityIncludes: node selector key) and: [
					node receiver isLiteralCharacter or: [ node arguments first isLiteralCharacter ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:26:06'!
                         browseEqSentToNumericConstants
	"
	Smalltalk browseEqSentToNumericConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#= #~= ) identityIncludes: node selector key) and: [
					node receiver isLiteralNumber or: [ node arguments first isLiteralNumber ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:26:10'!
   browseEqSentToSmallIntegerConstants
	"
	Smalltalk browseEqSentToSmallIntegerConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#= #~= ) identityIncludes: node selector key) and: [
					node receiver isLiteralSmallInteger or: [ node arguments first isLiteralSmallInteger ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:16:27'!
                     isLiteralCharacter  "Overridden in LiteralNode"
	^false! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:17:12'!
   isLiteralNumber  "Overridden in LiteralNode"
	^false! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:21:06'!
      isLiteralSmallInteger  "Overridden in LiteralNode"
	^false! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:16:30' overrides: 50350699!
          isLiteralCharacter
	^ key isCharacter! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:17:15' overrides: 50350703!
                               isLiteralNumber
	^ key isNumber! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:22:59' overrides: 50350707!
     isLiteralSmallInteger
	^ key isNumber and: [ key class == SmallInteger ]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:25:49' prior: 16969133!
                          browseEqEqSentToCharacterConstants
	"
	Smalltalk browseEqEqSentToCharacterConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isLiteralCharacter or: [ node arguments first isLiteralCharacter ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:25:58' prior: 16969153!
    browseEqEqSentToSmallIntegerConstants
	"
	Smalltalk browseEqEqSentToSmallIntegerConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isLiteralSmallInteger or: [ node arguments first isLiteralSmallInteger ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:16:50' prior: 16920062!
isConstantCharacter
	"Compatibility"

	^self isLiteralCharacter! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:17:32' prior: 16920067!
           isConstantNumber
	"Compatibility"

	^self isLiteralNumber! !

LiteralNode removeSelector: #isConstantCharacter!

!methodRemoval: LiteralNode #isConstantCharacter stamp: 'Install-6998-BrowseEqualityWithLiterals-JuanVuletich-2025Jan22-08h10m-jmv.001.cs.st 1/23/2025 11:11:12'!
isConstantCharacter
	^ key isCharacter!

LiteralNode removeSelector: #isConstantNumber!

!methodRemoval: LiteralNode #isConstantNumber stamp: 'Install-6998-BrowseEqualityWithLiterals-JuanVuletich-2025Jan22-08h10m-jmv.001.cs.st 1/23/2025 11:11:12'!
isConstantNumber
	^ key isNumber!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6998-BrowseEqualityWithLiterals-JuanVuletich-2025Jan22-08h10m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6996] on 22 January 2025 at 8:32:52 am'!
!MethodSet methodsFor: 'message functions' stamp: 'jmv 1/22/2025 08:31:36'!
                     fileOutAllMethods
	"Put a description of the selected message on a file"

	DirectoryEntry fileOutsDirQuery: 'methods.st' writeStreamDo: [ :fileStream |
		fileStream timeStamp.
		self messageList do: [ :methodRef |
			methodRef actualClass
				printMethodChunk: methodRef methodSymbol
				withPreamble: true
				on: fileStream
				moveSource: false
				toFile: 0 ]].! !
!MethodSetWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 1/22/2025 08:29:35' prior: 16903426!
          messageListMenuSpec
	"Spec for the menu and shortcut keys for the messages list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message Set' 				false)
		#(10	'Browse Full (b)' 				$b 	window browseMethodFull 						editFindReplaceIcon)
		#(20	'Browse Hierarchy (h)' 		$h 	window browseHierarchy 							goTopIcon)
		#(30	'Browse Method (O)' 			$O 	window openSingleMessageBrowser 				scriptIcon)
		#(40	'Browse Protocol (p)' 			$p 	window browseFullProtocol 						spreadsheetIcon)
		#(45	'Browse Package' 			nil 	window browsePackage 							packageIcon)
		#(50 	'-----')
		#(60	'File Out' 					nil 	model 	fileOutMessage 							fileOutIcon)
		#(61	'File Out All' 					nil 	model 	fileOutAllMethods 							fileOutIcon)
		#(70	'Run Test (t)' 				$t 	model 	runMethodTest 							weatherFewCloudsIcon)
		#(80	'Debug Test (r)' 				$r 	model 	debugMethodTest 							weatherFewCloudsIcon)
		#(90	'Inspect CompiledMethod' 	nil 	model 	inspectCompiledMethod 					exploreIcon)
		#(100 	'-----')
		#(110	'Senders of... (n)' 			nil 	window browseSendersOfMessages 				mailForwardIcon)
		#(120	'Local Senders of...' 			nil 	window browseLocalSendersOfMessages 			mailForwardIcon)
		#(130	'Implementors of... (m)' 		nil 	window browseImplementorsOfMessages 			developmentIcon)
		#(140	'Local Implementors of...' 		nil 	window browseLocalImplementorsOfMessages 	developmentIcon)
		#(150	'Inheritance (i)' 				$i 	window methodInheritance 						goDownIcon)
		#(160	'Versions (v)' 				$v 	window browseVersions 							clockIcon)
		#(170 	'-----')
		#(180	'Remove Method (x)' 			$x 	model 	removeMessage 							deleteIcon)
		#(190	'more' 						nil 	nil 		2000 										listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 							$m 	window browseImplementors)
		#(992	nil 							$n 	window browseSenders)
		#(993	nil 							$c 	model 	copySelector)
		#(994	nil 							$N 	window browseClassRefs)

		" 'more' SubMenu"
		#(2010	'Sample instance' 			nil 	window makeSampleInstance 						instanceIcon)
		#(2020	'Inspect instances' 			nil 	window inspectInstances 							inspectIcon)
		#(2030	'Inspect subinstances' 		nil 	window inspectSubInstances 						inspectIcon)
		#(2040 	'-----')
		#(2050 	'Remove from this Browser' 	nil 	model 	removeMessageFromBrowser 				listRemoveIcon)
		#(2060 	'Filter message list...' 			nil 	window filterMessageList 							findIcon)
		#(2070	'Change category...' 			nil 	model 	changeCategory 							saveAsIcon)
		#(2080	'Change sets with this Method' nil 	window findMethodInChangeSets 					changesIcon)
		#(2090	'Revert to previous Version' 	nil 	model 	revertToPreviousVersion 					undoIcon)
		#(2100 	'-----')
		#(2110 	'Sort by class Hierarchy' 		nil 	model 	sortByClassHierarchy 						classIcon)
		#(2120 	'Sort by class Name' 			nil 	model 	sortByClassName 							classIcon)
		#(2130 	'Sort by Selector' 				nil 	model 	sortBySelector 								scriptIcon)
		#(2140 	'Sort by Date' 				nil 	model 	sortByDate 								dateIcon)
		#(2150 	'Reverse sort' 				nil 	model 	sortReverse 								redoIcon)
	).
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6999-MethodSet-fileOutAll-JuanVuletich-2025Jan22-08h26m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6996] on 22 January 2025 at 8:37:48 am'!
!CompiledMethod methodsFor: 'debugger support' stamp: 'jmv 11/30/2014 11:37' prior: 16834361!
                             mapFromBlockKeys: keys toSchematicTemps: schematicTempNamesString
	"Decode a schematicTempNamesString that encodes the layout of temp names
	 in a method and any closures/blocks within it, matching keys in keys to
	 vectors of temp names."
	| map tempNames |
	map := Dictionary new.
	tempNames := schematicTempNamesString readStream.
	keys do:
		[:key| | tempSequence tempIndex |
		tempSequence := OrderedCollection new.
		tempIndex := 0.
		[(tempNames skipSeparators; peek) ifNil: [true] ifNotNil: [:ch| '[]' includes: ch]] whileFalse:
			[tempNames peek == $(
				ifTrue: [tempSequence addAll: ((self tempsSubSequenceFrom: (tempNames next; yourself)) withIndexCollect:
														[:temp :index|
														{ temp. { tempIndex + 1. index } }]).
						tempNames peek ~~ $) ifTrue: [self error: 'parse error'].
						tempIndex := tempIndex + 1.
						tempNames next]
				ifFalse: [tempSequence addAll: ((self tempsSubSequenceFrom: tempNames) withIndexCollect:
														[:temp :index|
														{ temp. tempIndex := tempIndex + 1 }])]].
		map at: key put: tempSequence asArray.
		[tempNames peek == $]] whileTrue: [tempNames next].
		tempNames peek == $[ ifTrue:
			[tempNames next]].
	^map! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 7/21/2023 16:59:57' prior: 16958199!
          trimParentesisOn: aSourceCode
			
	| parentesis |
	
	parentesis := 1.
	start+1 to: stop-1 do: [ :index | | char |
		char := aSourceCode at: index.
		char == $( 
			ifTrue: [ parentesis := parentesis + 1]
			ifFalse: [ char == $) 
				ifTrue: [ 
					parentesis = 1 ifTrue: [ ^self ].
					parentesis := parentesis - 1]]].
		
	^(self trimLeft: 1 right: 1) trimToMatchExpressionOn: aSourceCode ! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 7/21/2023 16:53:59' prior: 16958214!
                     trimToMatchExpressionOn: aSourceCode

	| initialChar endingChar |
	
	initialChar := aSourceCode at: start ifAbsent: [ nil ].
	endingChar := aSourceCode at: stop ifAbsent: [ nil ].
	
	^(initialChar == $( and: [ endingChar == $) ])
		ifTrue: [ self trimParentesisOn: aSourceCode ]
		ifFalse: [ self trimNoParentesisStartingWith: initialChar endingWith: endingChar on: aSourceCode]! !
!SourceCodeInterval methodsFor: 'private - source code' stamp: 'RNG 5/9/2020 15:39:55' prior: 16958235!
                          canBeExpandedStartingWith: firstChar endingWith: lastChar

	^ (firstChar == $( and: [ lastChar == $) ]) or: [ firstChar == $` and: [ lastChar == $` ] ]! !
!SourceCodeInterval methodsFor: 'private - source code' stamp: 'RNG 5/8/2020 21:30:59' prior: 16958243!
                             canBeTrimmed: initialChar

	^ initialChar notNil and: [ initialChar isSeparator or: [ initialChar == $. ] ]! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:22' prior: 16958262!
                      endsOnDotOn: aSourceCode

	^(self lastCharacterOfRangeOn: aSourceCode) == $.! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:07' prior: 16958284!
                     isEndOfTemporariesDeclarationOn: aSourceCode

	^((self lastCharacterOfRangeOn: aSourceCode) == $|) and: [^(aSourceCode indexOf: $|) < self last]! !
!CharacterSequence methodsFor: 'comparing' stamp: 'ul 11/14/2010 06:02' prior: 16813068!
                   startingAt: keyStart match: text startingAt: textStart
	"Answer whether text matches the pattern in this string.
	Matching ignores upper/lower case differences.
	Where this string contains #, text may contain any character.
	Where this string contains *, text may contain any sequence of characters."
	| anyMatch matchStart matchEnd i matchStr j ii jj |
	i := keyStart.
	j := textStart.

	"Check for any #'s"
	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].
	(self at: i) == $#] whileTrue:
		["# consumes one char of key and one char of text"
		j > text size ifTrue: [^ false "no more text"].
		i := i+1.  j := j+1].

	"Then check for *"
	(self at: i) == $*
		ifTrue: [i = self size ifTrue:
					[^ true "Terminal * matches all"].
				"* means next match string can occur anywhere"
				anyMatch := true.
				matchStart := i + 1]
		ifFalse: ["Otherwise match string must occur immediately"
				anyMatch := false.
				matchStart := i].

	"Now determine the match string"
	matchEnd := self size.
	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '** not valid -- use * instead'].
		matchEnd := ii-1].
	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '*# not valid -- use #* instead'].
		matchEnd := matchEnd min: ii-1].
	matchStr := self copyFrom: matchStart to: matchEnd.

	"Now look for the match string"
	[jj := text findString: matchStr startingAt: j caseSensitive: false.
	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]
		whileTrue:
		["Found matchStr at jj.  See if the rest matches..."
		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:
			[^ true "the rest matches -- success"].
		"The rest did not match."
		anyMatch ifFalse: [^ false].
		"Preceded by * -- try for a later match"
		j := j+1].
	^ false "Failed to find the match string"! !
!CharacterSequence methodsFor: 'converting' stamp: 'ls 10/28/2003 12:24' prior: 16813245!
                asSmalltalkComment
	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"

	^self species streamContents:  [ :str |
		| quoteCount first |

		str nextPut: $".
	
		quoteCount := 0.
		first := true.
		self do: [ :char |
			char == $"
				ifTrue: [
					first ifFalse: [
						str nextPut: char.
						quoteCount := quoteCount + 1 ] ]
				ifFalse: [
					quoteCount odd ifTrue: [
						"add a quote to even the number of quotes in a row"
						str nextPut: $" ].
					quoteCount := 0.
					str nextPut: char ].
			first := false ]. 

		quoteCount odd ifTrue: [
			"check at the end"
			str nextPut: $". ].

		str nextPut: $".
	].
	! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:50:36' prior: 50336452!
                              asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek == $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [
					| char |
					(char := in next) == $&
					ifTrue: [
						| rest did |
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $¡].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first == $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:11' prior: 50336487!
 keywords
	"Answer an array of the keywords that compose the receiver."
	| keywords |
	keywords := Array streamContents: [ :kwds |
		| kwd isAllValidInIdentifiers |
		kwd := self species writeStream.
		isAllValidInIdentifiers := true.
		1
			to: self size
			do: [ :i |
				| char |
				char := self at: i.
				kwd nextPut: char.
				char == $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers := true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers := false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/6/2024 17:27:30' prior: 16813819!
                             withDoubleColonsDoubled
	"Return a copy of the receiver with any double colons duplicated.
	Useful for turning text into Smalltalk comments."

	^self species streamContents: [ :stream |
		self do: [ :c |
			stream nextPut: c.
			c == $"
				ifTrue: [ stream nextPut: c ]]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:42' prior: 50336532!
             withDoubleColonsUndoubled
	"Do the inverse of #withDoubleColonsDoubled"

	^self species streamContents: [ :stream |
		| lastWasDoubleColon |
		lastWasDoubleColon := false.
		self do: [ :c |
			c == $"
				ifTrue: [
					lastWasDoubleColon
						ifFalse: [
							stream nextPut: c.
							lastWasDoubleColon := true ]
						ifTrue: [
							lastWasDoubleColon := false]]
				ifFalse: [
					stream nextPut: c.
					lastWasDoubleColon := false ]]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 15:01:25' prior: 16813848!
 withNewLines
	"Return a copy of the receiver in which backslash (\) characters have been replaced with newLine (i.e. Lf)."

	^ self collect: [ :c | c == $\ ifTrue: [ Character newLineCharacter ] ifFalse: [ c ]].! !
!CharacterSequence methodsFor: 'printing' stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16813970 overrides: 16828385!
                    storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do:
		[:i |
		aStream nextPut: (x := self at: i).
		x == $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'jmv 2/21/2024 15:09:00' prior: 16814194!
                  isAbsolutePathName
	"Note: On Windows, both 'C:\Users\Someone\file.txt' and '\Users\Someone\file.txt'
	and even '/Users/Someone/file.txt' are considered an absolute pathName.
	This is essentially because FilePlugin can handle them. The gained uniformity with Unix is nice."
	
	self isEmpty ifTrue: [^ false].
	self first isPathSeparator ifTrue: [^ true].
	
	"tilde means user's home folder, if possible.
	https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	self first == $~ ifTrue: [^ true ].

	FileIOAccessor default onWindows
		ifTrue: [
			^ self beginsWithWindowsDriveName and: [ self size = 2 or: [ (self at: 3) isPathSeparator ]]].

	^ false! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 6/13/2022 09:25:45' prior: 16814559!
     getEnclosedExpressionFrom: aStream
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"

	| result currentChar |
	result := self species writeStream.
	[aStream atEnd 
		or: [(currentChar := aStream next) == $}]]
			whileFalse: [result nextPut: currentChar].
	^ result contents withBlanksTrimmed.! !
!CharacterSequence methodsFor: 'formatting' stamp: 'jmv 12/19/2024 13:52:18' prior: 50336579!
                               format: aCollection
	"format the receiver with aCollection  
	 
	simplest example:
	'foo {1} bar' format: {Date today}.
	 
	complete example:
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}..
	"
	^self species streamContents: [ :out |
		| stream |
		stream := self readStream.
		[stream atEnd]
			whileFalse: [| currentChar | 
				currentChar := stream next.
				currentChar == ${
					ifTrue: [| expression | 
						expression := self getEnclosedExpressionFrom: stream.
						out nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
					ifFalse: [
						currentChar == $\
							ifTrue: [stream atEnd ifFalse: [out nextPut: stream next]]
							ifFalse: [out nextPut: currentChar]]]].! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 7/5/2020 16:47:58' prior: 16814640!
                             article
	| article first letter second |
	self isEmpty ifTrue: [^self].
	article := self first isVowel ifTrue: ['an'] ifFalse: ['a'].
	first := self first asLowercase.
	letter := self size = 1.
	second := letter ifFalse: [self second asLowercase].
	(first == $f and: [letter orNot: ['aeiloru' includes: second]])
		ifTrue: [^'an'].
	first == $u ifTrue: [
		(letter or: ['cks' includes: second]) ifTrue: [^'a'].
		second == $n
			ifTrue: [(self size = 2 or: [self third isVowel]) ifTrue: [^'a']]].
	(first == $e and: [second == $u]) ifTrue: [^'a'].
	^article! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 4/25/2020 10:24:38' prior: 16814753!
                      lowercasePlural
	| last |
	self exceptionalPlural ifNotNil: [:pl | ^pl].
	self isUninflictedNoun ifTrue: [^self].
	last := self last.
	last == $y ifTrue: [
		#('ay' 'ey' 'oy' 'uy') do: [:t |
			(self endsWith: t) ifTrue: [^self , 's'].
			^self allButLast , 'ies']].
	#('zz' 'ch' 'sh') do: [:t | (self endsWith: t) ifTrue: [^self , 'es']].
	last == $s ifTrue: [
		self = 'its' ifTrue: [^'their'].
		#('bs' 'cs' 'ds' 'ks' 'ls' 'ms' 'rs' 'ts' 'ws')
			do: [:t | (self endsWith: t) ifTrue: [^self]].
		#('sis' 'xis')
			do: [:t | (self endsWith: t) ifTrue: [^(self allButLast: 2) , 'es']]].
	last == $z ifTrue: [^self , 'zes'].
	(last == $x or: [last == $s]) ifTrue: [^self , 'es'].
	(self endsWith: 'man') ifTrue: [^(self allButLast: 2) , 'en'].
	last == $f ifTrue: [^self allButLast , 'ves'].
	(self endsWith: 'fe') ifTrue: [^(self allButLast: 2) , 'ves'].
	^self , 's'! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 13:52:49' prior: 50336606 overrides: 16917720!
                         readFrom: inStream
	"Answer a new String that is determined by reading the stream, inStream.  Embedded
	double quotes become the quote Character."

	^self streamContents: [ :outStream |
		| done |
		"go to first quote"
		inStream skipTo: $'.
		done := false.
		[done or: [inStream atEnd]]
			whileFalse: 
				[ |char|
				char := inStream next.
				char == $'
					ifTrue: 
						[char := inStream next.
						char == $'
							ifTrue: [outStream nextPut: char]
							ifFalse: [done := true]]
					ifFalse: [outStream nextPut: char]]].! !
!String methodsFor: 'testing' stamp: 'fgz 7/1/2024 16:33:58' prior: 16961227!
                      isIntegerDenotation
	"Answer true if the receiver denotes an integer number."
	
	^(self size > 1 and: [
		self first == $- and: [ (self findFirst: [:each | each isDigit not ] startingAt: 2) = 0 ]
			]) or: [ self size > 0 and: [ self allSatisfy: [:each | each isDigit ] ] ]

! !
!Symbol methodsFor: 'accessing' stamp: 'jmv 6/28/2022 14:45:08' prior: 16962542!
                        precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise. The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c := self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last == $: ifTrue: [^ 3].
	^ 1! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 8/15/2015 10:21' prior: 16962916 overrides: 50351344!
                   readFrom: strm
	"
	Symbol readFrom: '#abc' readStream
	"

	strm peek == $# ifFalse: [self error: 'Symbols must be introduced by #'].
	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !
!Symbol class methodsFor: 'services' stamp: 'jmv 2/5/2024 17:59:33' prior: 16962993!
                         possibleSelectorsFor: misspelled 
	"Answer an ordered collection of possible corrections
	for the misspelled selector in order of likelyhood"

	| numArgs candidates lookupString best binary short long first ss |
	lookupString := misspelled asLowercase. "correct uppercase selectors to lowercase"
	numArgs := lookupString numArgs.
	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new].
	first := lookupString first.
	short := lookupString size - (lookupString size // 4 max: 3) max: 2.
	long := lookupString size + (lookupString size // 4 max: 3).

	"First assemble candidates for detailed scoring"
	candidates := OrderedCollection new.
	self allSymbolTablesDo: [:s | (((ss := s size) >= short	"not too short"
			and: [ss <= long			"not too long"
					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"
			and: [s numArgs = numArgs])	"and numArgs is the same"
			ifTrue: [candidates add: s]].

	"Then further prune these by correctAgainst:"
	best := lookupString correctAgainst: candidates.
	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [
		binary := misspelled, ':'.		"try for missing colon"
		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].
	^ best! !
!UnicodeSymbol methodsFor: 'accessing' stamp: 'jmv 6/28/2022 14:45:18' prior: 16996576!
                          precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise. The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c := self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last == $: ifTrue: [^ 3].
	^ 1! !
!UnicodeSymbol class methodsFor: 'instance creation' stamp: 'jmv 7/6/2023 11:52:07' prior: 16996828 overrides: 50351344!
          readFrom: strm
	"
	UnicodeSymbol readFrom: '#abc' readStream
	"

	strm peek == $# ifFalse: [self error: 'Symbols must be introduced by #'].
	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !
!SystemDictionary methodsFor: 'query' stamp: 'jmv 10/1/2022 12:02:12' prior: 16970333!
                classesWithExtensionCategories
	"For a base image, there should be none.
	Smalltalk classesWithExtensionCategories
	"

	Object withAllSubclasses do: [ :cls | cls organization categories do: [ :cat | cat first == $* ifTrue: [cls print ]]]! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 8/16/2024 09:21:38' prior: 16970805!
                      processCommandLineArguments: initialOptions
	"
	Smalltalk processCommandLineArguments: true
	Smalltalk processCommandLineArguments: false

	Note: By default, any exceptions thrown during the evaluation of arguments are simply ignored.
	To ease debugging, use the -e argument: Do Not Ignore Exceptions. 
	For example:
		squeak Cuis.image -e -s myScript.st
	If ``myScript.st`` contains an error, a Debugger will pop up.
	
	See comment at
		processInitialCommandLineOption:optionArgument:
		processFinalCommandLineOption:optionArgument:raiseExceptions:
	See displayCommandLineUsageOn:
	"
	| optionString optionArgument optionIndex nextOptionIndex optionLastParameterIndex raiseExceptions dashFinder |

	"Any command line argument that starts with $- is an Option.
	NonOption arguments are parameters for the preceding Option."
	raiseExceptions := false.
	startUpScriptArguments := #().
	"Empty Strings are valid command line arguments, generated by two double quotes. Handle them."
	dashFinder := [ :any | any notEmpty and: [ any first == $- ] ].
	optionIndex := startUpArguments findFirst: dashFinder startingAt: 1.
	[ optionIndex > 0 ] whileTrue: [
		"Find parameters for this option"
		nextOptionIndex := startUpArguments findFirst: dashFinder startingAt: optionIndex+1.
		optionLastParameterIndex := nextOptionIndex = 0
			ifTrue: [startUpArguments size]
			ifFalse: [nextOptionIndex-1].
		optionString := startUpArguments at: optionIndex.
		optionString size > 1 ifTrue: [
			optionString = '--' 						"Including    --    as an option means 'ignore everything after here'"
				ifTrue: [^self].
			optionString = '-e'
				ifTrue: [ raiseExceptions := true ]
				ifFalse: [
					optionArgument := optionLastParameterIndex > optionIndex ifTrue: [startUpArguments at: optionIndex+1].
					startUpScriptArguments := startUpArguments copyFrom: optionIndex+2 to: optionLastParameterIndex.
					initialOptions
						ifTrue: [ self processInitialCommandLineOption: optionString optionArgument: optionArgument ]
						ifFalse: [ self processFinalCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: raiseExceptions ].
					startUpScriptArguments := #() ]
			].
		optionIndex := nextOptionIndex ].! !
!Base64MimeConverter methodsFor: 'conversion' stamp: 'jmv 5/21/2022 22:29:58' prior: 16786556!
                      nextValue
	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"
	| raw num |
	FromCharTable ifNil: [ self class initializeTables ].
	[
		raw := mimeStream next.
		raw ifNil: [^ nil].	"end of stream"
		raw == $= ifTrue: [^ nil].
		num := FromCharTable at: raw asciiValue + 1.
		num ifNotNil: [^ num].
		"else ignore space, return, tab, ..."
	] repeat! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 5/26/2022 15:14:19' prior: 16960426!
nextNumber
	"Answer a number from the (text) stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element == $- or: [element == $. or: [element == $)]]]]] whileFalse.
	element ifNil: [^nil].
	self skipBack.
	element == $) ifTrue: [^nil].
	^Number readFrom: self! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 11/16/2015 14:52' prior: 16928511!
   nextKeyword
	^self
		untilAnySatisfying: [:c | (c isValidInIdentifiers or: [c == $:]) not]! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16929068!
                              unCommand
	"If this read stream is at a <, then skip up to just after the next >.  For removing html commands."
	| char |
	[self peek == $<] whileTrue: ["begin a block"
		[self atEnd == false and: [self next ~~ $>]] whileTrue.
		"absorb characters"
		].
 ! !
!Transcripter methodsFor: 'command line' stamp: 'di 8/12/97 22:11' prior: 16990646 overrides: 16917177!
                     confirm: queryString 
	| choice |
	[true]
		whileTrue: 
			[choice := self request: queryString , '
Please type yes or no followed by return'.
			choice first asUppercase == $Y ifTrue: [^ true].
			choice first asUppercase == $N ifTrue: [^ false]]! !
!Scanner methodsFor: 'expression types' stamp: 'HAW 6/22/2020 16:11:44' prior: 16946318!
            scanToken

	"Skip delimiters fast, there almost always is one."
	self skipDelimiters.

	mark := source position - 1.
	(tokenType at: 1) == $x "x as first letter"
		ifTrue: [self perform: tokenType "means perform to compute token & type"]
		ifFalse: [token := self step asSymbol "else just unique the first char"].
	^token! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 11/28/2022 11:51:26' prior: 16946518!
                            xBinary

	tokenType := #binary.
	token := source collectionSpecies streamContents: [ :stream |
	stream nextPut: self step.
	[	| type |
		type := self typeTableAt: hereChar.
		(type == #xBinary or: [ type == #xDiacritical ]) and: [
			hereChar ~~ $- or: [aheadChar isDigit not]]
	] whileTrue: [
		stream nextPut: self step]].
	token := token asSymbol.! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:30:01' prior: 16946532!
xColon
	"Allow := for assignment"
	
	aheadChar == $= ifTrue:
		[self step.
		tokenType := #leftArrow.
		self step.
		^ token := #':='].
	"Otherwise, just do what normal scan of colon would do"
	tokenType := #colon.
	^ token := self step asSymbol! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/23/2022 17:16:31' prior: 16946570!
         xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := source collectionSpecies writeStream.
    self step.
    [hereChar == $"]
        whileFalse:
            [(hereChar = stopChar and: [source atEnd])
                ifTrue: [^self offEnd: self class unmatechedCommentQuoteErrorDescription].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollection with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 1/9/2024 11:37:11' prior: 16946604!
        xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore
		or: [type == #xDiacritical
		or: [ hereChar == $′ ]]]]  						"Also see #isValidInIdentifiers"
	] whileTrue: [
			"open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
				ifTrue: [DoItCharacter "doit"]
				ifFalse: [source next]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])
		ifTrue: [
			buffer nextPut: self step.
			"Allow any number of embedded colons in literal symbols"
			[(self typeTableAt: hereChar) == #xColon]
				whileTrue:
					[buffer nextPut: self step].
			#keyword]
		ifFalse: [
			#word].
	token := buffer contents.! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 11/27/2024 14:56:06' prior: 16946786!
              typeTable: aTypeTable at: aCharacterOrCodePoint

	"Prebuilt tables for the ASCII range"
	aCharacterOrCodePoint isAscii ifTrue: [
		^aTypeTable at: aCharacterOrCodePoint asciiValue ].

	"For CodePoints not in the ASCII range"
	aCharacterOrCodePoint isDiacriticalMark ifTrue: [ ^#xDiacritical ].
	aCharacterOrCodePoint isLetter ifTrue: [ ^#xLetter ].
	aCharacterOrCodePoint isSymbolLike ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint == $­ ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint isSeparator ifTrue: [ ^#xDelimiter ].
	"Many should actually be #xIllegal"
	^#xLetter! !
!Parser methodsFor: 'pragmas' stamp: 'jmv 5/21/2022 22:31:42' prior: 16921045!
                    pragmaLiteral: selectorSoFar
	"Read a pragma literal.  As a nicety we allow a variable name (rather
	 than a literal string) as the second argument to primitive:error:"

	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])
		ifTrue: [ ^ self advance ].
	(here == $# and: [ tokenType == #word ])
		ifTrue: [ ^ self advance ].
	(here == #- and: [ tokenType == #number ])
		ifTrue: [ ^ (self advance; advance) negated ].
	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])
		ifTrue: [ ^ (Scanner new scanTokens: self advance) first ].
	"This nicety allows one to supply a primitive error
	 temp as a variable name, rather than a string."
	((selectorSoFar beginsWith: 'primitive:')
	 and: [(selectorSoFar endsWith: 'error:')
	 and: [hereType == #word]]) ifTrue:
		[^self advance].
	^self expected: 'Literal constant'! !
!Parser methodsFor: 'pragmas' stamp: 'jmv 7/12/2023 11:53:03' prior: 16921098!
                             pragmaStatement
	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."
	
	| selector arguments words index keyword |
	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])
		ifFalse: [  ^ self expected: 'pragma declaration' ].

	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "
	(here = #apicall: or: [ here = #cdecl: ])
		ifTrue: [ ^ self externalFunctionDeclaration ].

	selector := String new.
	arguments := OrderedCollection new.
	words := OrderedCollection new.
	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [
		index := self startOfNextToken + requestorOffset.
		selector := selector , self advance.
		selector := encoder asciiStringLiteral: selector.
		words add: (index to: self endOfLastToken + requestorOffset).
		(selector last == $: or: [ selector first isLetter not ]) ifTrue: [
			arguments add: (encoder asciiStringLiteral: (self pragmaLiteral: selector)) ] ].
	selector numArgs ~= arguments size
		ifTrue: [ ^ self expected: 'pragma argument' ].
	(Symbol hasInterned: selector 
		ifTrue: [ :value | keyword := value]) 
		ifFalse: [ 
			keyword := self 
				correctSelector: selector wordIntervals: words
				exprInterval: (words first first to: words last last)
				ifAbort: [ ^ self fail ] ].
	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).
	^ true! !
!Parser methodsFor: 'error correction' stamp: 'jmv 4/26/2024 15:20:48' prior: 16922137!
     correctSelector: proposedKeyword wordIntervals: aSpots exprInterval: expInt ifAbort: abortAction
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| correctSelector userSelection delta adjustedSpots |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [^proposedKeyword asSymbol].
	
	"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"
	"
	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])
		ifFalse: [ ^ proposedKeyword asSymbol ].
	"

	userSelection := requestor selectionInterval.

	delta := self sourceDelta.
	adjustedSpots := aSpots collect: [ :interval | interval first + delta to: interval last + delta ].
	requestor selectFrom: adjustedSpots first first to: adjustedSpots last last.

	correctSelector := UnknownSelector name: proposedKeyword.
	correctSelector ifNil: [^abortAction value].

	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	self substituteSelector: correctSelector keywords wordIntervals: adjustedSpots.
	^(proposedKeyword last ~~ $:
	   and: [correctSelector last == $:])
		ifTrue: [abortAction value]
		ifFalse: [correctSelector]! !
!Parser methodsFor: 'error correction' stamp: 'EB 1/27/2020 20:19:48' prior: 16922482!
                        isLastPipeOfEmptyTempsDeclaration: pipeIndex

	| indexOfPreviousPipe sourceCode |
	
	sourceCode := requestor text string.
	indexOfPreviousPipe := sourceCode lastIndexOf: $| startingAt: pipeIndex - 1 endingAt: 1 ifAbsent: [ ^false ].
	^(sourceCode at: pipeIndex) == $| and: [
		(sourceCode copyFrom: indexOfPreviousPipe + 1 to: pipeIndex - 1) allSatisfy: [ :char | char isSeparator ]]! !
!Parser methodsFor: 'error correction' stamp: 'HAW 12/12/2019 17:44:22' prior: 16922497!
    newRangeRemovingTempsDeclarationFrom: currentSource 
	startingAt: start
	to: originalEnd
	
	| end |
	
	end := self filterSeparatorsToTheRightOn: currentSource startingAt: originalEnd.
	
	(currentSource at: end+1) == $| ifTrue: [ | possibleNewStart |
		possibleNewStart := (self filterSeparatorsToTheLeftOn: currentSource startingAt: start) - 1.
		(currentSource at: possibleNewStart) == $| ifTrue: [ ^Array with: possibleNewStart with: end + 1 ]]. 
	
	^Array with: start with: end
! !
!Parser methodsFor: 'error correction' stamp: 'EB 12/13/2019 01:26:43' prior: 16922531!
   pasteTempAtMethodLevel: name

	| theTextString |
	
	theTextString := requestor text string.
	tempsMark := 
		(theTextString at: tempsMark) == $| 
			ifTrue: [
  				"Paste it before the second vertical bar"
		 		self pasteTemp: name before: tempsMark ] 
			ifFalse: [ self createTempDeclarationInMethodWith: name ].
	! !
!BlockNode methodsFor: 'printing' stamp: 'hlsf 6/24/2022 09:29:25' prior: 16795182 overrides: 16919938!
                       printOn: aStream indent: level
	| separateLines |
	aStream nextPut: $[.
	self
		printArgumentsOn: aStream
		indent: level.
	separateLines := (self
		printTemporaries: temporaries
		on: aStream
		doPrior: [ aStream space ]) or: [arguments notNil and: [arguments notEmpty] ].
	(Preferences at: #prettyPrintRectangularBlocks)
		ifTrue: [
			"If args+temps > 0 and statements > 1 (or just one complex statement),
			put all statements on separate lines"
			separateLines
				ifTrue: [
					(statements size > 1 or: [
						statements size = 1 and: [ statements first isComplex ]])
							ifTrue: [ aStream newLineTab: (1 max: level) ]
							ifFalse: [ aStream space ] ]
				ifFalse: [
					(statements size = 1 and: [ statements first isComplex not ])
						ifTrue: [ aStream space ]]]
		ifFalse: [
			self isComplex
				ifTrue: [ aStream newLineTab: (1 max: level) ]
				ifFalse: [ aStream space ] ].
	((self printStatementsOn: aStream indent: level) > 0 and: [ aStream peekLast ~~ $] ])
		ifTrue: [ aStream space ].
	aStream nextPut: $]! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 8/23/2024 14:57:38' prior: 16974344!
                         mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint == $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint == $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOf: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOf: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph. rightArrowGlyph. upArrowGlyph. downArrowGlyph. carriageReturnGlyph}! !
!Date class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 16:33:54' prior: 16841926 overrides: 16917720!
                          readFrom: aStream 
	"Read a Date from the stream in any of the forms:
		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  
		<month> <day> <year>		(April 15, 1982; 4/15/82)
		<year>-<month>-<day>		(1982-04-15) (ISO8601)"
	| day month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 31])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isLetter
		ifTrue: ["MonthName-DD-YY or DD-MonthName-YY or YY-MonthName-DD"
			month := String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
			firstAsNumber
				ifNil: ["MonthName DD YY"
					day := Integer readFrom: aStream]
				ifNotNil: [
					year ifNil: ["DD MonthName YY"
						day := firstAsNumber]]]
		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"
			year 
				ifNil: ["MM-DD-YY or DD-MM-YY"
					firstAsNumber > 12
						ifTrue: ["DD-MM-YY"
							day := firstAsNumber.
							month := Month nameOfMonth: (Integer readFrom: aStream)]
						ifFalse: ["MM-DD-YY"
							month := Month nameOfMonth: firstAsNumber.
							day := Integer readFrom: aStream]]
				ifNotNil: ["YY-MM-DD"
					month := Month nameOfMonth: (Integer readFrom: aStream)]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	year
		ifNil: [year := Integer readFrom: aStream]
		ifNotNil: [day := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year :=  year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self year: year month: month day: day! !
!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 16:33:59' prior: 16904411 overrides: 16917720!
        readFrom: aStream 
	"Read a Month from the stream in any of the forms:  
		<month> <year>			(April 1982; APR-82; 4.82; APR82)  
		<month> <year>			(April, 1982; 4/82)
		<year>-<month>			(1982-04) (ISO8601)"
	"
	Month readFrom: 'July 1998' readStream
	"
	| month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isLetter
		ifTrue: ["MonthName-YY or YY-MonthName"
			month := String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip]]
		ifFalse: ["MM-YY or YY-MM"
			month := year 
				ifNil: ["MM-YY"
					Month nameOfMonth: firstAsNumber ]
				ifNotNil: ["YY-MM"
					Month nameOfMonth: (Integer readFrom: aStream)]].

	year ifNil: [
		[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
		year := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year := year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self month: month year: year! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 15:07:01' prior: 17007707 overrides: 16917720!
                         readFrom: aStream 
	"Read a Week from the stream in any of the forms:  
		<year>-W<week>			(2009-W01) (ISO8601)"
	| weekNumber yearNumber firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [yearNumber := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream next == $W ifFalse: [
		self error: 'Invalid Format' ].

	weekNumber := Integer readFrom: aStream.
	weekNumber < 1 ifTrue: [ self error: 'Invalid Format' ].
	(yearNumber < 100 and: [yearNumber >= 0])  ifTrue: [
		yearNumber := yearNumber < 69 
			ifTrue: [2000 + yearNumber]
			ifFalse: [1900 + yearNumber]].

	^ self yearNumber: yearNumber weekNumber: weekNumber! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 15:07:07' prior: 17010753 overrides: 16917720!
                    readFrom: aStream 

	| year sign |
	sign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isDigit] whileFalse: [aStream skip].
	year := (Integer readFrom: aStream) * sign.
	^ self yearNumber: year! !
!Browser methodsFor: 'class functions' stamp: 'jmv 5/21/2022 22:29:19' prior: 16797765!
                 explainSpecial: string 
	"Answer a string explaining the code pane selection if it is displaying 
	one of the special edit functions."

	| classes whole lits reply |
	self isEditingClass
		ifTrue: 
			["Selector parts in class definition"
			string last == $: ifFalse: [^nil].
			lits := Array with:
				#subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.
			(whole := lits detect: [:each | (each keywords
					detect: [:frag | frag = string] ifNone: nil) notNil]
						ifNone: nil) notNil
				ifTrue: [reply := '"' , string , ' is one part of the message selector ' , whole , '.']
				ifFalse: [^nil].
			classes := Smalltalk allClassesImplementing: whole.
			classes := 'these classes ' , classes printString.
			^reply , '  It is defined in ' , classes , '."
Smalltalk browseAllImplementorsOf: #' , whole].

	editSelection == #editSystemCategories ifTrue: [^nil].
	editSelection == #editMessageCategories ifTrue: [^nil].
	^nil! !
!Browser methodsFor: 'message category functions' stamp: 'jmv 3/14/2024 10:32:52' prior: 16798119!
                             addExtensionCategory
	"Present a choice package names and let the user enter a new category suffx.
	Take the suffix form the selected category."

	| packageNames packageNameIndex |
	
	selectedClassName ifNil: [ ^self ].

	packageNames := (CodePackage installedPackages collect: [ :package |
		package packageName ]) sorted.
	packageNames ifEmpty: [ ^ self ].
	
	packageNameIndex := PopUpMenu 
		withCaption: 'Which package to extend?'
		chooseFrom: packageNames.
	packageNameIndex = 0 ifTrue: [ ^ self ].

	self 
		request: 'Enter the category name'
		initialAnswer: 
			(String streamContents: [ :stream |
				stream
					nextPut: $*;
					nextPutAll: (packageNames at: packageNameIndex).
				selectedMessageCategory ifNotNil: [
					stream
						nextPut: $-;
						nextPutAll: selectedMessageCategory ] ])
		 verifying: [ :newCategoryName | 
			((newCategoryName at: 1) == $* or: [
				self confirm:
					"I know about with #withNewlines ..."
					`'The selected category does not start with an asterix (*).',
					String newLineString,
					'Do you want to use it anyway?'` ]) and: [
						(packageNames includes:				(newCategoryName copyUpTo: $-) allButFirst) or: [
							self confirm:
								`'The selected prefix does not match any package name.', 
								String newLineString,
								'Do you want to use it anyway?'` ] ] ]
		do: [ :newCategoryName | | oldMessageCategoryListIndex |
			oldMessageCategoryListIndex := self messageCategoryListIndex.
			self classOrMetaClassOrganizer
				addCategory: newCategoryName
				before: selectedMessageCategory.
			self changed: #messageCategoryList.
			self messageCategoryListIndex:
				(oldMessageCategoryListIndex = 0
					ifTrue: [ self classOrMetaClassOrganizer categories size + 1 ]
					ifFalse: [ oldMessageCategoryListIndex ]).
			self changed: #messageCategoryList ]! !
!MessageNames methodsFor: 'search' stamp: 'jmv 4/28/2022 11:40:38' prior: 16896313!
     computeSelectorListFromSearchString
	"Compute selector list from search string"
	| sorted |
	sorted := SortedCollection sortBlock: [ :x :y |
		x asLowercase <= y asLowercase ].
	(searchString findBetweenSubStrs: ';') do: [ :selPat | | raw n m |
		selPat notEmpty ifTrue: [
			(selPat first == $" and: [
				selPat last == $" and: [ selPat size > 2 ]])
				ifTrue: [
					Symbol
						hasInterned:
							(selPat
								copyFrom: 2
								to: selPat size - 1)
						ifTrue: [ :sym |
							sorted add: sym ]]
				ifFalse: [
					raw := ((n := selPat occurrencesOf: $*) > 0 | ((m := selPat occurrencesOf: $#) > 0) and: [ selPat size > (n + m) ])
						ifTrue: [ Symbol selectorsMatching: selPat ]
						ifFalse: [ Symbol selectorsContaining: selPat ].
					sorted addAll: raw ]]].
	selectorList := sorted asArray  select: [ :sym |
		(Smalltalk isThereAnImplementorOf: sym) or: [ Smalltalk isThereAReferenceTo: sym ]].
	^ selectorList.! !
!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 3/27/2024 10:50:49' prior: 16809851!
                               contents: input notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Create an error if the category of the selected message is unknown. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| codeString category selector class oldSelector |
	codeString := input string.
	(class := self selectedClassOrMetaClass) ifNil:
		[(myChangeSet preambleString == nil or: [codeString isEmpty]) ifTrue: [ ^ false].
		(codeString count: [:char | char == $"]) odd 
			ifTrue: [self inform: 'unmatched double quotes in preamble']
			ifFalse: [(Scanner new scanTokens: codeString) notEmpty ifTrue: [
				self inform: 'Part of the preamble is not within double-quotes.
To put a double-quote inside a comment, type two double-quotes in a row.
(Ignore this warning if you are including a doIt in the preamble.)']].
		myChangeSet preambleString: codeString.
		self currentSelector: nil.  "forces update with no 'unsaved chages' feedback"
		^ true].
	oldSelector := self selectedMessageName.
	category := class organization categoryOfElement: oldSelector.
	selector := class compile: codeString
				classified: category
				notifying: aRequestor.
	selector ifNil: [^ false].
	(self messageList includes: selector)
		ifTrue: [self currentSelector: selector]
		ifFalse: [self currentSelector: oldSelector].
	self update.
	^ true! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 3/28/2023 15:37:43' prior: 16862897!
                        doesPattern: aPattern allow: entry 

	(aPattern = '*' or: [ aPattern match: entry name ]) ifFalse: [ ^false ].

	(showHidden not and: [ entry name first == $. ]) ifTrue: [ ^false ].

	"Hide Mac resurce forks and folder service stores"
	(entry name = '.DS_Store') ifTrue: [ ^false ].
	('._*' match: entry name) ifTrue: [ ^false ].
	^true! !
!FileList methodsFor: 'private' stamp: 'jmv 8/5/2024 16:44:13' prior: 16863299!
                            updateFileList
	"Update my files list with file names in the current directory  
	that match the pattern.
	The pattern string may have embedded newlines or semicolons; these separate different patterns."
	| patterns patternsThatReject patternsThatSelect newList |
	patterns := OrderedCollection new.
	(pattern findTokens: (String with: Character cr with: Character lf with: $;))
		do: [ :each |
			(each includes: $*) | (each includes: $?)
				ifTrue: [ patterns add: (each copyReplaceAll: '?' with: '#')]
				ifFalse: [
					each isEmpty
						ifTrue: [ patterns add: '*']
						ifFalse: [ patterns add: '*' , each , '*']]].
	"A pattern that starts with $/ is used to reject entries
	Rejecting patterns are applied after selecting patterns."
	patternsThatSelect := patterns reject: [ :any | any first == $/ ].
	patternsThatSelect isEmpty ifTrue: [ patternsThatSelect add: '*' ]. 
	patternsThatReject := patterns select: [ :any | any first == $/ ] thenCollect: [ :each | each copyFrom: 2 to: each size ].
	newList := self listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject.

	newList = list ifFalse: [
		"If we had a selection, ensure it is valid, or discard it."
		listIndex = 0 ifFalse: [
			(listIndex > newList size or: [(list at: listIndex) ~= (newList at: listIndex)]) ifTrue: [
				listIndex := newList indexOf: (list at: listIndex) ]].
		list := newList.
		listIndex > 0 ifFalse: [ "Had no selection or it was discarded"
			fileName := nil.
			acceptedContentsCache := ''.
			self acceptedContentsChanged.
			self changed: #fileListIndex ].
		self changed: #fileList.
		self triggerEvent: #updateButtonRow ].! !
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:39' prior: 16842824 overrides: 16917720!
                      readFrom: aStream

	| offset date time ch |

	date := Date readFrom: aStream.
	[aStream peek isDigit]
		whileFalse: [aStream next].
	time := Time readFrom: aStream.
	aStream atEnd
		ifTrue: [ offset := self localOffset ]
		ifFalse: [
			ch := aStream next.
			ch == $+ ifTrue: [ch := Character space].
			offset := Duration fromString: (String with: ch), '0:', aStream upToEnd, ':0'].
		
	^ self
		year: date yearNumber
		month: date monthIndex
		day: date dayOfMonth
		hour: time hour
		minute: time minute
		second: time second
		nanoSecond: time nanoSecond
		offset: offset


	"
		DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.02+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.003+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0004+01:01' readStream
  		DateAndTime readFrom: ' 2002-05-16T17:20:45.00005' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000006+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000007+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.00000008-01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000000009+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000000001+01:01' readStream

 		DateAndTime readFrom: ' 2002-05-16T17:20' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45+01:57' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45-02:34' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45+00:00' readStream
		DateAndTime readFrom: ' 1997-04-26T01:02:03+01:02:3' readStream
 	"! !
!Time class methodsFor: 'smalltalk-80' stamp: 'jmv 11/15/2022 10:33:12' prior: 16989079 overrides: 16917720!
          readFrom: aStream
	"Read a Time from the stream in the form:
		<hour>:<minute>:<second> <am/pm>

	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"

	| hour minute second nanos ampm |
	hour := Integer readFrom: aStream.
	minute := 0.
	second := 0.
	nanos := 0.
	(aStream peekFor: $:) 
		ifTrue: [
			minute := Integer readFrom: aStream.
			(aStream peekFor: $:) ifTrue: [
				second := Integer readFrom: aStream.
				(aStream peekFor: $.)
					ifTrue: [ | nanosStart scale |
						nanosStart := aStream position.
						nanos := Integer readFrom: aStream.
						"As if there were trailing zeros to fill 9 positions"
						scale := 10 raisedToInteger: nanosStart + 9 - aStream position.
						nanos := nanos * scale ]]].
	aStream skipSeparators.
	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: [
		ampm := aStream next asLowercase.
	
	(ampm == $p and: [hour < 12]) ifTrue: [hour := hour + 12].
		(ampm == $a and: [hour = 12]) ifTrue: [hour := 0].
	
	(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].
	^ self 
		hour: hour 
		minute: minute 
		second: second 
		nanoSecond: nanos.

	"
	Time readFrom: '2:23:09 pm' readStream
	Time readFrom: '2:23:09.0 pm' readStream
	Time readFrom: '2:23:09.123402 pm' readStream
	Time readFrom: '2:23:09.00123402 pm' readStream
	Time readFrom: '2:23:09.001234020 pm' readStream
	Time readFrom: '2:23:09.000123402 pm' readStream
	"! !
!Number class methodsFor: 'instance creation' stamp: 'jmv 6/6/2022 10:59:12' prior: 16914943 overrides: 16917720!
              readFrom: stringOrStream 
	"Answer a number as described on aStream.  The number may
	include a leading radix specification, as in 16rFADE"
	| value base aStream sign |
	aStream := stringOrStream isString
		ifTrue: [stringOrStream readStream]
		ifFalse: [stringOrStream].
	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].
	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [aStream peekFor: $+. 1].
	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].
	base := 10.
	aStream peek == $.
		ifTrue: [ value := 0 ]
		ifFalse: [
			value := Integer readFrom: aStream base: base.
			(aStream peekFor: $r)
				ifTrue: [
					"<base>r<integer>"
					(base := value) < 2 ifTrue: [
						base = 1 ifTrue: [ ^Integer readBaseOneFrom: aStream ].
						^self error: 'Invalid radix'].
					(aStream peekFor: $-) ifTrue: [sign := sign negated].
					value := Integer readFrom: aStream base: base].
			(aStream peekFor: $x)
				ifTrue: [
					"0x<integer>" "Hexadecimal"
					base := 16.
					(aStream peekFor: $-) ifTrue: [sign := sign negated].
					value := Integer readFrom: aStream base: base]].
	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !
!Number class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 15:15:32' prior: 16914983!
  readRemainderOf: integerPart from: aStream base: base withSign: sign
	"Read optional fractional part and exponent, and return the final result"
	| value fraction fracpos peekChar exp scale convertToFloat |

	convertToFloat := false.
	value := integerPart.
	(aStream peekFor: $.)
		ifTrue: [		 "<integer>.<fraction>"
			(aStream atEnd not and: [ aStream peek digitValue between: 0 and: base - 1 ])
				ifTrue:  [
					fracpos := aStream position.
					fraction := Integer readFrom: aStream base: base.
					fraction := fraction / (base raisedToInteger: aStream position - fracpos).
					value := value + fraction.
					convertToFloat := true ]
				ifFalse: [
					"oops - just <integer>."
					aStream skipBack.
					"un-gobble the period"
					^ value * sign"Number readFrom: '3r-22.2'"]].
	peekChar := aStream peek.
	('deqp' includes: peekChar)
		ifTrue: [			"<number>(e|d|q)<exponent>>" "<number>(p)<binaryExponent>>"
			aStream next.
			(aStream atEnd not and: [ (aStream peek digitValue between: 0 and: 9) or: [ '+-' includes: aStream peek ]])
				ifTrue:  [
					exp := Integer readFrom: aStream.
					scale := (peekChar == $p ifTrue: [2] ifFalse: [base]) raisedToInteger: exp.
					value := value * scale ]
				ifFalse: [
					"oops - just <number>."
					aStream skipBack.]].
	^convertToFloat
		ifTrue: [
			(value = 0.0 and: [ sign = -1 ])
				ifTrue: [ Float negativeZero ]
				ifFalse: [ (value * sign) asFloat ]]
		ifFalse: [ value * sign ]! !
!MessageSend methodsFor: 'evaluating' stamp: 'jmv 5/15/2024 15:51:16' prior: 16898912 overrides: 16915784!
      valueWithPossibleArgument: anObject

	^selector last == $:
		ifFalse: [ receiver perform: selector ]
		ifTrue: [ receiver perform: selector with: anObject ]! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 8/3/2020 17:30:42' prior: 16830411!
   fromHexString: aString
	"For HTML color spec: #FFCCAA.
	See http://www.w3schools.com/cssref/css_colors_legal.asp
	Also handles 3 digit shorthand."
	"
	Color fromHexString: '#FFCCAA'.
	"
	(aString size = 7 and: [ aString first == $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU := aString asUppercase.
		red := ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green := ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue := ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].
	(aString size = 4 and: [ aString first == $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU := aString asUppercase.
		red := aColorHexU at: 2.
		green := aColorHexU at: 3.
		blue := aColorHexU at: 4.
		red := ('16r', (String with: red with: red)) asNumber/255.
		green := ('16r', (String with: green with: green)) asNumber/255.
		blue := ('16r', (String with: blue with: blue)) asNumber/255.
		^ self r: red g: green b: blue].
	^ nil! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 1/8/2024 12:38:20' prior: 16882862!
              kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char := nil.
	[ char == $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char := self keyboard.
		Display fill: `5@5 extent: 400@50` fillColor: `Color white`.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char codePoint;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ].
			Time now printOn: s
			])
		displayAt: 10 @ 10 ].! !
!EventSensor methodsFor: 'test' stamp: 'jmv 3/8/2023 10:26:28' prior: 16856441!
                               test
	"
	Sensor test

Also useful:
	Sensor kbdTest
	"
	| c lastStamp stamp |
	c := nil.
	lastStamp := 0.
	[ c == $x asciiValue ] whileFalse: [
		Sensor nextEvent ifNotNil: [ :evt |
			stamp := evt at: 2.
			stamp - lastStamp > 300 ifTrue: [ ' ' print.' ' print ].
			Transcript show: evt; newLine.
			self printEventBuffer: evt.
			(evt first = 2 and: [ evt fourth = 0 ]) ifTrue: [
				c := evt third ].
			lastStamp := stamp]]! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:39:35' prior: 16810590!
isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self == $′ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'testing' stamp: 'jmv 11/16/2015 14:51' prior: 16810621!
            tokenish
	"Answer whether the receiver is a valid token-character--letter, digit, or 
	colon."

	^self isValidInIdentifiers or: [self == $:]! !
!Character methodsFor: 'converting' stamp: 'jmv 7/5/2024 17:17:06' prior: 16810712!
                            withDiacriticalMark: codePointOrCharacter
	"Answer the character resulting from adding a diacritical mark (accent) to a letter.
	If the result is unsupported in ISO 8859-1, answer the receiver.
	Supported diacritical marks are:
		U+0300 	COMBINING GRAVE ACCENT
		U+0301 	COMBINING ACUTE ACCENT
		U+0302 	COMBINING CIRCUMFLEX ACCENT
		U+0303 	COMBINING TILDE
		U+0308 	COMBINING DIAERESIS
		U+030A 	COMBINING RING ABOVE
		U+030C 	COMBINING CARON
		$a withDiacriticalMark: 16r301
		$N withDiacriticalMark: $~
		$Z withDiacriticalMark: $v
		
		invalid:
		$9 withDiacriticalMark:$v
		$A withDiacriticalMark: $v
		$Á withDiacriticalMark: $v
		$A withDiacriticalMark: 1244
		"
	| answer i |
	i := ((codePointOrCharacter isNumber
			ifTrue: [#(16r300 16r301 16r302 16r303 16r308 16r30A 16r30C)]
			ifFalse: [#($` $' $^ $~ $" $° $v)]) indexOf: codePointOrCharacter
				) + 1.
	answer := (Character accentedLetters detect: [ :group | group first = self ] ifNone: [ ^self ]) at: i.
	^answer == $- ifFalse: [answer] ifTrue: [self]! !
!Character methodsFor: 'fileman-testing' stamp: 'jmv 5/21/2022 22:29:28' prior: 16810753!
     isDriveSeparator
	^self == $:
	! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 10/4/2024 11:13:02' prior: 16810798 overrides: 16917943!
    initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	Character initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Pd'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~~ $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap.! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:13:35' prior: 16811064!
   codePoint: anInteger
	"Answer the Character whose value is anInteger.
	
	self assert: (Character codePoint: 16r41) == $A.
	self assert: (Character codePoint: 16r20AC) == $€.
	"

	<primitive: 170>
	^self primitiveFailed! !
!Character class methodsFor: 'static state' stamp: 'jmv 7/25/2024 14:36:48' prior: 16811552!
   basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self codePoint: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		(group first == $ÿ or: [group first == $ß])
			ifFalse: [ | lowercaseChar uppercaseChar |
				uppercase := group first codePoint.
				lowercase := group second codePoint.
				lowercaseChar := self codePoint: lowercase.
				uppercaseChar := self codePoint: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third codePoint.
						unaccentedLowercase := group fourth codePoint.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifTrue: [ | lowercaseChar |
				lowercase := group first codePoint.
				lowercaseChar := self codePoint: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				group size > 1
					ifTrue: [|unaccentedLowercase|
						unaccentedLowercase := group second codePoint.
						unaccentedTable
							at: lowercase+1 put: unaccentedLowercase]]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 7/3/2023 12:18:01' prior: 16889227!
                         isCloseWindowShortcut

	self flag: #definesKeyboardShortcuts.
	^ (self commandAltKeyPressed or: [ self controlKeyPressed ])
		and: [self keyCharacter == $w].! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:04:09' prior: 16889235!
         isColon

	^ self keyCharacter == $:.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'db 7/1/2020 17:09:47' prior: 16889292!
    isQuestionMark
	
	^ self keyCharacter == $? ! !
!KeyboardEvent methodsFor: 'platform peculiarities' stamp: 'jmv 12/29/2011 10:52' prior: 16889322!
             isCmdAltGreaterThan
	"Answer true if the user pressed cmd/Alt + $>
	We need this special method because of platform differences, especially the weird way the Mac VM reports keystrokes if cmd or control are held down (the character answered is usually the unshifted one, even if shift is pressed, depending on keyboard layout!!)
	Note: On the Mac, this code handles US, German and Spanish layouts. Add more as needed...
	Tweak both #isCmdAltLessThan and #isCmdAltGreaterThan !!"
	| char shifted |

	self commandAltKeyPressed ifFalse: [ ^false ].

	char := self keyCharacter.
	"Do the easy test for non macOS"
	Smalltalk platformName = 'Mac OS' ifFalse: [
		^char == $> ].

	shifted := self shiftPressed.
	
	"For Mac keyboard layouts where $> is unshifted (Is there such a layout?)"
	(shifted not and: [ char == $> ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $> is shift + $. (for example US).
	As cmd is pressed, the Mac VM gives us the unshifted character, i.e. $."
	(shifted and: [ char == $. ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $> is shift + $<.
	In this case, in the German layout, the Mac VM gives us $> (surprising!!)"
	(shifted and: [ char == $> ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $> is shift + $<
	In the Spanish layout, as cmd is pressed, the Mac VM gives us the unshifted character, i.e. $<"
	(shifted and: [ char == $< ])
		ifTrue: [ ^true ].

	"We guess it is not cmd + $> then..."
	^false! !
!KeyboardEvent methodsFor: 'platform peculiarities' stamp: 'jmv 12/29/2011 10:52' prior: 16889371!
      isCmdAltLessThan
	"Answer true if the user pressed cmd/Alt + $<
	We need this special method because of platform differences, especially the weird way the Mac VM reports keystrokes if cmd or control are held down (the character answered is usually the unshifted one, even if shift is pressed, depending on keyboard layout!!)
	Note: On the Mac, this code handles US, German and Spanish layouts. Add more as needed...
	Tweak both #isCmdAltLessThan and #isCmdAltGreaterThan !!"
	| char shifted |

	self commandAltKeyPressed ifFalse: [ ^false ].

	char := self keyCharacter.
	"Do the easy test for non macOS"
	Smalltalk platformName = 'Mac OS' ifFalse: [
		^char == $< ].

	shifted := self shiftPressed.
	
	"For Mac keyboard layouts where $< is unshifted (for example, German and Spanish)"
	(shifted not and: [ char == $< ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $< is shift + $, (for example US).
	As cmd is pressed, the Mac VM gives us the unshifted character, i.e. $,"
	(shifted and: [ char == $, ])
		ifTrue: [ ^true ].

	"We guess it is not cmd + $< then..."
	^false! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/21/2018 09:21:39' prior: 16905723!
       focusKeyboardFor: aKeyboardEvent

	"If aKeyboardEvent ctrl-tab or shift-ctrl-tab use it to navigate keyboard focus.
	Warning: This doesn't work on Windows... the event is not sent"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent controlKeyPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ]
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ].
			^ true ].
	"On Windows use at least some keystroke to navigate morphs... even shift-Tab that should navigate backwards"
"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent shiftPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent hand keyboardFocusNext.
			^ true ].
"

	"Cycle through windows with cmdAlt + < and cmdAlt + >.
	VM and platform peculiarities are hidden in #isCmdAltLessThan and #isCmdAltGreaterThan"
	"This was done as an attempt to mimic the Mac OSX keystrokes for 'Move focus to next window in active application'. Unfortunately, it only works if OS X is set to use any other keys for this. If (as for example, with German defaults), OS-X uses these keystrokes, then they are not sent to the VM. This is a long standing issues in Chromium and PhotoShop, for example..."
	self disableCode: [
		aKeyboardEvent isCmdAltLessThan ifTrue: [
			aKeyboardEvent hand activatePreviousWindow.
			^true ].
		aKeyboardEvent isCmdAltGreaterThan ifTrue: [
			aKeyboardEvent hand activateNextWindow.
			^true ]].
	"Alternative for Mac OS-X: option-Tab and option-shift-Tab"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent rawMacOptionKeyPressed ])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand activatePreviousWindow ]
				ifFalse: [ aKeyboardEvent hand activateNextWindow ].
			^ true ].
	"Alternative for non-Mac OS-X: alt-< and alt->"
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter == $< ]) ifTrue: [
		aKeyboardEvent hand activatePreviousWindow.
		^true ].
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter == $> ]) ifTrue: [
		aKeyboardEvent hand activateNextWindow.
		^true ].
	^false! !
!Morph methodsFor: 'submorphs-menus' stamp: 'jmv 11/22/2024 11:35:30' prior: 16908370!
  getMenu
	"Answer the right-click (contextual) menu."
	"Spec for the menu and shortcut keys.
	Each entry is
		#(itemId 			'menu item label'    shortcut    receiverGetter    selector     iconOrNil(optional)    'helpText(optional)'    selectorArgument(optional))
		- itemId is a number (integer or float). It specifies the position of the item in the menu, and is also an id, allowing for overrides and deletions.
		- label is a string or symbol. Symbol means self updating menu entry. nil means just keyboard shortcut, no menu entry.
		- shortcut is a Character or nil
		- receiverGetter sent to the widget to get the actual receiver for selector.
			Typically #window, #model or #editor. If nil, receiver is the widget itself.
		- selector is #aSymbol. Usually no arguments, or one single argument in 8th entry. 
			If a Number (multiple of 1000), indicates a subMenu. ItemsIds must be in range. See BrowserWindow>>#classListMenuSpec.
			If nil, the menu entry is created but disabled. The keyboard shortcut is disabled too.
		- icon may be nil. It is also optional (but must be there if there is help text)
		- help text is optional
		- selectorArgument is optional. If selector takes an argument, and selectorArgument is not provided, the argument is self.
	Entries of size 1 mean 'remove menu item'.
	Entries of size 2 are separators.
	An entry of size 3 (usually with key 0 and at the first position), if present, tells a menu title, whether to #addStayUpIcons.
	"

	| menuNshortcutsSpecs itemSpec menu submenus |
	menuNshortcutsSpecs := self allMenuNshortcutsSpecs.
	menuNshortcutsSpecs ifEmpty: [ ^nil ].
	menu := MenuMorph new.
	submenus := nil.
	menuNshortcutsSpecs keys sorted do: [ :key |
		itemSpec := menuNshortcutsSpecs at: key.
		itemSpec size =1 ifTrue: [
				"Do nothing. This is a marker for removing a previously provided entry" ]
			ifFalse: [ itemSpec size = 2 ifTrue: [
				itemSpec second first == $X ifFalse: [ "Compatibility. Also a marker for removing previous entries."
					self addLineTo: menu fromSpec: itemSpec submenus: submenus ]]
			ifFalse: [ itemSpec size = 3 ifTrue: [
				self addTitleTo: menu fromSpec: itemSpec ]
			ifFalse: [ itemSpec fifth isNumber ifTrue: [
				submenus ifNil: [submenus := Dictionary new ].
				self addSubmenuTo: menu fromSpec: itemSpec submenus: submenus ]
			ifFalse: [
				self addItemTo: menu fromSpec: itemSpec submenus: submenus ]]]]].
	^ menu! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2024 15:54:13' prior: 16894183!
                            contentsWithMarkers: aString inverse: invertMarkers
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString := nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	(aString notEmpty and: [aString first == $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString := aString.	"remember actual string"
	marker := ((marker = '<on>' or: [marker = '<yes>']) xor: invertMarkers)
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents: (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph newWith: marker.
	self addMorphFront: marker position: 1@(self morphHeight +1- marker morphHeight // 2).
	marker lock.! !
!BrowserWindow class methodsFor: 'services' stamp: 'HAW 6/27/2020 19:48:57' prior: 16800429!
   classNamesFrom: potentialClassNames with: pattern matching: toMatch 

	^ (pattern last == $. or: [pattern last == $ ])
		ifTrue: [potentialClassNames select: [:className | className asLowercase = toMatch]]
		ifFalse: [potentialClassNames select: [:className | className includesSubstring: toMatch caseSensitive: false]]! !
!HierarchyBrowserWindow class methodsFor: 'examples' stamp: 'jmv 5/21/2022 22:33:45' prior: 16875783!
                       example2
	"Put up a ClassListBrowser that shows all classes whose names start with the letter S"

	self forClassesNamed: (Smalltalk allClasses collect: [:c | c name] thenSelect: [:aName | aName first == $S]) title: 'All classes starting with S'

"HierarchyBrowserWindow example2"! !
!WorldMorph methodsFor: 'events' stamp: 'jmv 9/19/2024 12:36:07' prior: 17009192 overrides: 16905314!
                               keyStroke: aKeyboardEvent

	self flag: #definesKeyboardShortcuts.
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [ ^self ].

	"Handle a keystroke event."
	(aKeyboardEvent commandAltKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifTrue: [
			aKeyboardEvent keyCharacter == $b ifTrue: [
				Smalltalk browseFull: nil.
				aKeyboardEvent wasHandled: true. ].
			aKeyboardEvent keyCharacter == $f ifTrue: [
				Smalltalk findAndBrowseClass.
				aKeyboardEvent wasHandled: true. ].
			aKeyboardEvent keyCharacter == $F ifTrue: [
				Smalltalk findInSourceCode.
				aKeyboardEvent wasHandled: true. ].
		].
	"aKeyboardEvent keyCharacter print."! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 2/21/2024 15:37:28' prior: 16861855!
       expandTildeFor: aString

	aString size = 0 ifTrue: [ ^aString ].
	aString first == $~ifFalse: [ ^aString ].
	"Basic tilde expansion. Consider $~ to mean user's home folder, if possible.
	See, for example, https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	Smalltalk at: #OSProcess
		ifPresent: [ :osProcess |
			(osProcess thisOSProcess environmentAt: 'HOME')
				ifNotNil: [ :homeVariable |
					^homeVariable, (aString copyFrom: 2 to: aString size) ]
				ifNil: [ self error: 'The $HOME variable could not be resolved' ]]
		ifAbsent: [
			self error: 'Use of tilde (~) to mean $HOME folder requires OSProcess' ]! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'bp 5/10/2024 11:25:01' prior: 16861878!
        extensionFor: pathName 
	"In original FileMan, accepts only a localName (withouth path separators). Modify it for Cuis for also allowing them, as it is traditional in Squeak / Cuis.
	
	FileIOAccessor default extensionFor: 'writings.txt'
	FileIOAccessor default extensionFor: 'folder.ext/file'
	FileIOAccessor default extensionFor: 'optionalstuff.pck.st'
	FileIOAccessor default extensionFor: 'code.cs.st'
	FileIOAccessor default extensionFor: 'code.cs'
	"
	| index |
	{ '.cs.st' . '.pck.st'. '.ws.st' } do: [ :specialExtension |
		(pathName endsWith: specialExtension)
			ifTrue: [ ^specialExtension copyFrom: 2 to: specialExtension size ]].
	index := pathName
				findLast: [ :c | c == $.].
	^ (index = 0 or: [ pathName indexOfLastPathSeparator > index ])
		ifTrue: ['']
		ifFalse: [pathName copyFrom: index + 1 to: pathName size]! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 12/20/2024 16:32:24' prior: 50337717!
   splitNameVersionExtensionFor: fileName
	" answer an array with the root name, version # and extension.
	See comment in senders for more details"

	self baseNameAndExtensionFor: fileName do: [ :b :extension |
		| baseName version i j |
		baseName := b.
		i := j := baseName findLast: [:c | c isDigit not].
		i = 0
			ifTrue: [version := 0]
			ifFalse: [
				(baseName at: i) == $.
					ifTrue: [
						version := (baseName copyFrom: i+1 to: baseName size) asNumber.
						j := j - 1]
					ifFalse: [version := 0].
				baseName := baseName copyFrom: 1 to: j ].
		^ Array with: baseName with: version with: extension ]! !
!FileIOAccessor methodsFor: 'testing' stamp: 'pb 5/25/2016 00:32' prior: 16862144!
  onUnix
	^self pathNameDelimiter == $/! !
!FileIOAccessor methodsFor: 'testing' stamp: 'pb 5/25/2016 00:32' prior: 16862148!
    onWindows
	^self pathNameDelimiter == $\! !
!DirectoryEntry methodsFor: 'testing' stamp: 'jmv 10/9/2019 11:28:39' prior: 16848946!
                             isRegularDirectory
	"hidden convention in Unix"
	name first == $. ifTrue: [ ^false ].
	"in MacOS, applications are actually directories, but are usually not treated as such"
	self extension = 'app' ifTrue: [ ^false ].
	"in MacOS, .bundle directories, are resource packages"
	self extension = 'bundle' ifTrue: [ ^false ].
	^true! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 3/16/2012 10:48' prior: 16823930!
    category: categoryName matches: prefix
	| prefixSize catSize |
	categoryName ifNil: [ ^false ].
	catSize := categoryName size.
	prefixSize := prefix size.
	catSize < prefixSize ifTrue: [ ^false ].
	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1
		ifFalse: [ ^false ].
	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) == $-! !
!CodePackage methodsFor: 'testing' stamp: 'jfr 8/3/2024 10:43:36' prior: 16824032!
     isForeignClassExtension: categoryName
	"Answer true if <categoryName> is a foreign class extension reference"
	
	categoryName ifNil: [ ^false ].
	(categoryName size = 0) ifTrue:[^false].
	^ categoryName first == $* and: [(self isYourClassExtension: categoryName) not]! !
!PreferenceSet class methodsFor: 'services' stamp: 'jmv 12/19/2024 12:47:39' prior: 50337870!
                   readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [ | line parts |
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[ | pref value |
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first == $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefts.txt Error' print.
						error print.
						line print ].
				]]].! !
!Utilities class methodsFor: 'summer97 additions' stamp: 'jmv 9/27/2016 21:41:18' prior: 16997761!
            classFromPattern: pattern withCaption: aCaption
	"If there is a class whose name exactly given by pattern, return it.
	If there is only one class in the system whose name matches pattern, return it.
	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.
	This method ignores tab, space, & newline characters in the pattern"

	| toMatch potentialClassNames classNames exactMatch index |
	(toMatch :=  pattern copyWithoutAll:
			{Character space.  Character newLineCharacter.  Character tab})
		isEmpty ifTrue: [^ nil].
	Symbol hasInterned: toMatch ifTrue:
		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:
			[:maybeClass | (maybeClass class isMeta) ifTrue: [^ maybeClass]]].

	toMatch := (toMatch copyWithout: $.) asLowercase.
	potentialClassNames := Smalltalk classNames asOrderedCollection.
	classNames := pattern last == $. 
		ifTrue: [potentialClassNames select:
					[:nm |  nm asLowercase = toMatch]]
		ifFalse: [potentialClassNames select: 
					[:n | n includesSubstring: toMatch caseSensitive: false]].
	classNames isEmpty ifTrue: [^ nil].
	exactMatch := classNames detect: [:each | each asLowercase = toMatch] ifNone: nil.

	index := classNames size = 1
		ifTrue:	[1]
		ifFalse:	[exactMatch
			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUpWithCaption: aCaption]
			ifNotNil: [classNames addFirst: exactMatch.
				(PopUpMenu labelArray: classNames lines: #(1)) startUpWithCaption: aCaption]].
	index = 0 ifTrue: [^ nil].
	^ Smalltalk at: (classNames at: index) asSymbol

"
	Utilities classFromPattern: 'CharRecog' withCaption: 'xx'
	Utilities classFromPattern: 'rRecog' withCaption: 'xx'
	Utilities classFromPattern: 'znak' withCaption: 'xx'
	Utilities classFromPattern: 'orph' withCaption: 'xx'
"
! !
!Editor methodsFor: 'new selection' stamp: 'HAW 10/28/2024 12:13:31' prior: 16851952!
                wordRangeIncluding: aPositionInText
	"Select delimited text or word--the result of double-clicking."

	| direction level string here hereChar start sSize |
	string := self privateCurrentString.
	sSize := string size.
	sSize < 2 ifTrue: [^1 to: 1].
	here := aPositionInText min: sSize max: 2.
	"no delimiters -- select a token"
	direction := -1.
	level := 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar := string at: (here := here + direction).
			"token scan goes left, then right"
			hereChar isValidInIdentifiers 	"Consider $: as a word separator"
				ifTrue: [
					here = 1
						ifTrue: [
							start := 1.
							"go right if hit string start"
							direction := 1]]
				ifFalse: [
					direction < 0
						ifTrue: [
							start := here + 1.
							"go right if hit non-token"
							direction := 1]
						ifFalse: [level := 0]]].
	level > 0 ifTrue: [
		here := here + direction ].
	"If a word ends with $: (a keyword), consider it part of the word"
	hereChar == $: ifTrue: [here := here + 1].
	^start to: here - 1! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/26/2024 11:54:17' prior: 16852165!
                             normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| character i replacement |

	"Ignore keystrokes that could be keyboard shortcuts, even if not defined as such."
	((aKeyboardEvent keyValue between: 32 and: 126) and: [ aKeyboardEvent commandAltKeyPressed ])
		ifTrue: [ ^true ].

	"Convert strings like '\+161 ' (š) to unicode"
	aKeyboardEvent isSpace ifTrue: [ | string |
		string := self privateCurrentString.
		self pointIndex - 1 to: (self pointIndex - 7 max: 1) by: -1 do: [ :index |
		(string at: index) == $\ ifTrue: [ | key |
			key := string copyFrom: index + 1 to: self pointIndex - 1.
			(key size > 2 and: [ (key at: 1) == $+ ])
				ifTrue: [ | stream number value |
					stream := ReadStream on: key asUppercase from: 2 to: key size.
					[ number := Integer readFrom: stream  base: 16 ] on: Error do: [ ^ false ].
					value := Character codePoint: number.
					self
						selectFrom: index to: self pointIndex - 1;
						replaceSelectionWith: (UnicodeString with: value).
						^ false ] ] ] ].
	character := aKeyboardEvent keyCharacter.
	"Linux VMs don't automatically replace combining marks + space with ASCII,
	as Windows and Mac VMs do. It seems it is an app responsibility to do that in Linux."
	character isDiacriticalMark ifTrue: [
		i := self pointIndex-1.
		(i > 0 and: [ (self privateCurrentString at: i) == $  ]) ifTrue: [
			replacement := character caseOf: {
				[ `Character codePoint: 16r300` ] -> [ '`' ].
				[ `Character codePoint: 16r301` ] -> [ '''' ].
				[ `Character codePoint: 16r302` ] -> [ '^' ].
				[ `Character codePoint: 16r303` ] -> [ '~' ].
				[ `Character codePoint: 16r308` ] -> [ '"' ].
			} otherwise: [].
			replacement notNil ifTrue: [
				self selectFrom: i to: i; replaceSelectionWith: replacement.
				^ false ]
			]
		].
	self addString: (UnicodeString with: character).
	^false! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 6/10/2024 17:24:53' prior: 16954712 overrides: 16982344!
      encloseWith: aCharacter
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| startIndex stopIndex oldSelection new enlargedBy |
	"This implementation is only for commenting and uncommenting code.
	Other cases are handled by the super implementation.
	This implementation only handles String and discards Text attributes."
	aCharacter == $" ifFalse: [
		^super encloseWith: aCharacter ].

	startIndex := self startIndex.
	stopIndex := self stopIndex.
	oldSelection := self selection string.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) == $"
				and: [(model actualContents at: stopIndex) == $"]])
		ifTrue: [
			"already enclosed in double colons; make selection no longer a comment"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection withDoubleColonsUndoubled ]
		ifFalse: [
			"not enclosed in double colons; make selection a comment"
			new := oldSelection withDoubleColonsDoubled.
			enlargedBy := new size - oldSelection size.
			self replaceSelectionWith: $" asString, new, $" asString.
			self selectFrom: startIndex+1 to: stopIndex + enlargedBy ].
	^ true.! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 9/17/2016 18:06:28' prior: 16954795!
                       explainChar: string
	"Does string start with a special character?"

	| char |
	char := string at: 1.
	char == $. ifTrue: [^'Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float).'].
	char == $' ifTrue: [^'The characters between two single quotes are made into an instance of class String'].
	char == $" ifTrue: [^'Double quotes enclose a comment.  Smalltalk ignores everything between double quotes.'].
	char == $# ifTrue: [^'The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants.'].
	(char == $( or: [char == $)]) ifTrue: [^'Expressions enclosed in parenthesis are evaluated first'].
	(char == $[ or: [char == $]]) ifTrue: [^'The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockClosure and is usually passed as an argument.'].
	(char == ${ or: [char == $}]) ifTrue: [^ 'A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array'].
	(char == $< or: [char == $>]) ifTrue: [^'<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails.'].
	char == $^ ifTrue: [^'Up arrow means return from this method.  The value returned is the expression following the ^'].
	char == $| ifTrue: [^'Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code.'].
	char == $_ ifTrue: [^'Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it.'].
	char == $; ifTrue: [^'Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon.'].
	char == $: ifTrue: [^'A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withNewLines, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon).'].
	char == $$ ifTrue: [^'The single character following a dollar sign is made into an instance of class Character'].
	char == $- ifTrue: [^'A minus sign in front of a number means a negative number.'].
	char == $e ifTrue: [^'An e in the middle of a number means that the exponent follows.'].
	char == $r ifTrue: [^'An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base.'].
	char = Character space ifTrue: [^'the space Character'].
	char = Character tab ifTrue: [^'the tab Character'].
	char = Character cr ifTrue: [^'the carriage return Character'].
	char = Character lf ifTrue: [^'newline. The line feed Character'].
	^nil! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 9/22/2024 22:18:22' prior: 16955013!
    explainDelimiter: string
	"Is string enclosed in delimiters?"

	| str |
	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"
	(string first = string last) ifTrue:
			[^ self explainChar: (String with: string first)]
		ifFalse:
			[(string first == $( and: [string last == $)]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == $[ and: [string last == $]]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == ${ and: [string last == $}]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == $< and: [string last == $>]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == $# and: [string last == $)]) ifTrue:
				[^'An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array.'].
			string first == $# ifTrue:
				[^'An instance of class Symbol.'].
			(string first == $$ and: [string size = 2]) ifTrue:
				[^'An instance of class Character.  This one is the character ', (String with: string last), '.'].
			(string first == $:) ifTrue:
				[str := string allButFirst.
				(self explainTemp: str) ifNotNil: [
					^'An argument to this block will be bound to the temporary variable ',
						str, '.']]].
	^ nil! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 5/22/2022 20:43:16' prior: 16955167!
           explainNumber: string 
	"Is string a Number?"

	| strm c |
	(c := string at: 1) isDigit ifFalse: [(c == $- and: [string size > 1 and: [(string at: 2) isDigit]])
			ifFalse: [^nil]].
	strm := string readStream.
	c := Number readFrom: strm.
	strm atEnd ifFalse: [ ^nil ].
	c printString = string
		ifTrue: [ ^ string , ' is a ' , c class name ]
		ifFalse: [ ^ string , ' (= ' , c printString , ') is a ' , c class name ]! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/26/2024 10:25:33' prior: 16955183!
 explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"
	| lits whole reply classes s msg |
	(msg := self codeProvider selectedMessageName) ifNil: [^ nil].  "not in a message"
	string last == $: ifFalse: [^ nil].
	"Name of this method"
	lits := Array with: msg.
	(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: nil) notNil]
				ifNone: nil)
		ifNotNil: [
			reply := ', which is the selector of this very method!!'.
			s := self class plateA]
		ifNil: [ 
			"Selectors called from this method"
			lits := (self codeProvider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(whole := lits detect: [:each | (each keywords detect: [ :frag | frag = string ]
							ifNone: nil) notNil]
						ifNone: nil) notNil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply := '.'.
			s := self class plateB].
		classes := Smalltalk allClassesImplementing: whole.
		classes size > 12
			ifTrue: [classes := 'many classes']
			ifFalse: [classes := 'these classes ' , classes printString].
		^ String streamContents: [:str |
			str
				nextPutAll: string;
				nextPutAll: ' is one part of the message selector ';
				nextPutAll: whole;
				nextPutAll: reply;
				nextPutAll: '  It is defined in ';
				nextPutAll: classes;
				nextPutAll: s]! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 6/10/2024 16:45:42' prior: 16955789!
                    argPrev
	"Invoked by cmd-Q.
	 Search backwards from the start of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the start of the text.."

	| t i |
	t := model actualContents.
	i := self stopIndex.
	i > 1 ifTrue: [
		i := i -2.
		[i > 0 and: [ (t at: i) ~~ $  or: [(t at: i-1) ~~ $: ]]] whileTrue: [
			i := i -1 ].
		self deselectAndPlaceCursorAt: i + 1.
	].
	^true! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/7/2022 09:05:55' prior: 16955821 overrides: 16852159!
                            newLine: aKeyboardEvent
	"Replace the current text selection with a newLine (i.e. LF) followed by as many tabs
	as there are leading tabs on the current line (+/- bracket count)."

	| char s i tabCount stopIndex newLineString |
	s := self privateCurrentString.
	stopIndex := self stopIndex.
	i := stopIndex.
	tabCount := 0.
	[ (i := i-1) > 0 and: [ (char := s at: i) isLineSeparator not ] ] whileTrue: [
		"Count brackets"
		char == $[ ifTrue: [tabCount := tabCount + 1].
		char == $] ifTrue: [tabCount := tabCount - 1]].
	[ (i := i + 1) < stopIndex and: [ (char := s at: i) isSeparator ] ] whileTrue: [
		"Count leading tabs"
		char = Character tab ifTrue: [ tabCount := tabCount + 1 ]].
	"Now inject newline with tabCount tabs, generating a new undoable command"
	newLineString := UnicodeString streamContents: [ :strm | strm newLineTab: tabCount ].
	model startNewUndoRedoCommand.
	self replaceSelectionWith: newLineString.
	^ false! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 10/22/2024 10:56:14' prior: 16955854 overrides: 50353590!
                          normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| string key |

	"To enable:
	Preferences name: #autoReplaceNamedCharacters category: #gui value: true.
	Preferences saveToDisk: #autoReplaceNamedCharacters.
	PreferenceSet saveUserPrefs.
	"
	"To disable:
	Preferences name: #autoReplaceNamedCharacters category: #gui value: false.
	Preferences saveToDisk: #autoReplaceNamedCharacters.
	PreferenceSet saveUserPrefs.
	"
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	(Preferences at: #autoReplaceNamedCharacters) ifTrue: [
		aKeyboardEvent keyCharacter isLetter ifFalse: [
			string := self privateCurrentString.
			"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
			self pointIndex - 1 to: (self pointIndex - 20 max: 1) by: -1 do: [:i|
				(string at: i) == $\ ifTrue: [
					key := string copyFrom: i + 1 to: self pointIndex - 1.
					Character namedCharactersMap at: key ifPresent: [ :value |
						self selectFrom: i to: self pointIndex - 1; replaceSelectionWith: (UnicodeString with: value) ].
					^ super normalCharacter: aKeyboardEvent]]]].

	^ super normalCharacter: aKeyboardEvent! !
!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:44' prior: 16980389!
                          analyze: aString
	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:
3+4
<3+4>
Click Here<3+4>
<3+4>Click Here
"
	"Obtain the showing text and the instructions"
	| b1 b2 trim param show |
	b1 := aString indexOf: $<.
	b2 := aString indexOf: $>.
	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"
		param := self validate: aString.
		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].
	"Two parts"
	trim := aString withBlanksTrimmed.
	trim first == $< 
		ifTrue: [ trim last == $>
			ifTrue: ["only instructions" 
				param := self validate: (aString copyFrom: b1+1 to: b2-1).
				show := param size = 0 ifTrue: [nil] ifFalse: [param]]
			ifFalse: ["at the front"
				param := self validate: (aString copyFrom: b1+1 to: b2-1).
				show := param size = 0 ifTrue: [nil] 
						ifFalse: [aString copyFrom: b2+1 to: aString size]]]
		ifFalse: [ trim last == $>
			ifTrue: ["at the end"
				param := self validate: (aString copyFrom: b1+1 to: b2-1).
				show := param size = 0 ifTrue: [nil] 
						ifFalse: [aString copyFrom: 1 to: b1-1]]
			ifFalse: ["Illegal -- <> has text on both sides"
				show := nil]].
	^ Array with: param with: show
! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 10/22/2024 16:38:26' prior: 16784554!
                     lastCharacterWantsAutoComplete

	| lastCharIndex lastCharacter |
	textMorph editor hasSelection ifTrue: [ ^ false ].

	lastCharIndex := textMorph editor startIndex-1.
	lastCharIndex <= 0 ifTrue: [ ^ false ].
	lastCharacter := model actualContents at: lastCharIndex.

	^ lastCharacter isAlphaNumeric or: [
		lastCharacter isValidInBinarySelectors or: [ lastCharacter == $: ]]! !
!AutoCompleter methodsFor: 'entries' stamp: 'HAW 2/8/2019 17:27:05' prior: 16784635!
                 insertSelected
	
	| entry editor selEnd str |
	
	textMorph ifNil: [ ^false ].
	
	entry := self selectedEntryFormatted.
	(self canSelect: entry) ifFalse: [ ^true ].
	
	editor := textMorph editor.
	str := model actualContents string.
	selEnd := position.
	[selEnd < str size and: [ (str at: selEnd+1) tokenish ]] whileTrue: [ selEnd := selEnd + 1 ].
	(selEnd < str size and: [ (str at: selEnd+1) == $ ]) ifTrue: [ selEnd := selEnd + 1].
	editor selectFrom: position-prefix size+1 to: selEnd.
	editor
		replaceSelectionWith: entry;
		deselectAndPlaceCursorAt: position - prefix size + 1 + (self newCursorPosition: entry).
	textMorph redrawNeeded.
	menuMorph delete.
	menuMorph := nil.
	
	^ true! !
!MethodReference methodsFor: 'testing' stamp: 'HAW 6/11/2022 20:04:20' prior: 16902354!
                 isMessageListTitle

	^(self actualClass isKindOf: Object) and: [methodSymbol first == $_]
! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 6/1/2022 11:07:41' prior: 16807790!
           fatDefForClass: class

	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |
	newDef := class definition.
	oldDef := (self changeRecorderFor: class) priorDefinition.
	oldDef ifNil: [^ newDef].
	oldDef = newDef ifTrue: [^ newDef].

	oldStrm := oldDef readStream.
	newStrm := newDef readStream.
	outStrm := String writeStream.

	"Merge inst vars from old and new defs..."
	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.
	outStrm 
		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 
		nextPutAll: 'instanceVariableNames:'.
	newStrm peek == $: ifTrue: [newStrm next].	"may or may not be there, but already written"
	outStrm
		nextPutAll: (newStrm upTo: $'); nextPut: $'.
	oldVars := (oldStrm upTo: $') findTokens: Character separators.
	newVars := (newStrm upTo: $') findTokens: Character separators.
	addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
	outStrm nextPut: $'.

	class isMeta ifFalse: [
		"Merge class vars from old and new defs..."
		oldStrm upToAll: 'classVariableNames:'; upTo: $'.
		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';
			nextPutAll: (newStrm upTo: $'); nextPut: $'.
		oldVars := (oldStrm upTo: $') findTokens: Character separators.
		newVars := (newStrm upTo: $') findTokens: Character separators.
		addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
		outStrm nextPut: $'].

	outStrm nextPutAll: newStrm upToEnd.
	^ outStrm contents
! !
!ExtractAsParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/22/2021 15:42:21' prior: 16857606!
              removeDotsAt: anInterval in: sourceCode
	
	| lastToReplace |
	
	lastToReplace := anInterval last.
	[(sourceCode at: lastToReplace) == $. ] whileTrue: [ lastToReplace := lastToReplace - 1].
	
	^anInterval first to: lastToReplace! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 7/4/2022 21:18:15' prior: 16878163!
                replaceRange: aSourceCodeInterval withNewSourceCode: newSourceCode inMethod: aCompiledMethod

	| currentUpdates sourceCodeReplacement|
	
	sourceCodeReplacement := newSourceCode.
	((aSourceCodeInterval last < aCompiledMethod sourceCode size) and: [((aCompiledMethod sourceCode at: aSourceCodeInterval last + 1) == $.)]
		and: [newSourceCode endsWith: '.']) ifTrue: [sourceCodeReplacement := newSourceCode copyUpToLast: $.].
	"It's important to use < and not <= because temporaries declarations are added to the changes collection
	after the changes concerning the inlining of the implementor code, but they need to be replaced first - Fernando"
	currentUpdates := updatedSendersCode at: aCompiledMethod methodReference ifAbsent: (SortedCollection 
		sortBlock: [ :left :right | left key first < right key first ]).
	currentUpdates add: (aSourceCodeInterval -> sourceCodeReplacement).
	updatedSendersCode at: aCompiledMethod methodReference put: currentUpdates.
	! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 8/27/2022 21:06:09' prior: 16878269!
                addParenthesesIfNeededTo: anExpression

	"TODO: duplicated code in InlineTemporaryVariable"

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |
	
 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) == $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) == $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [^anExpression]
		ifFalse: [ (anExpression endsWith: '.')
			ifTrue: [^('(', anExpression copyUpToLast: $.), ').']
	 		ifFalse: [^'(', anExpression, ')']
		].! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 6/12/2022 18:33:45' prior: 16878460!
            indentationUpTo: anIndex in: aSourceCode

	| indentation currentIndex character|

	currentIndex := anIndex - 1.
	((aSourceCode at: currentIndex) == $^) ifTrue: [currentIndex := currentIndex  -1]. "Skip the return character if present"
	indentation := ''.

	[currentIndex > 0 and: [
		character := (aSourceCode at: currentIndex).
		(character = Character tab) or: [character = Character space]
	]] whileTrue: [
		indentation := indentation, character asString.
		currentIndex := currentIndex - 1.
	].

	^(character = Character newLineCharacter) ifFalse: [^''] ifTrue: [^indentation reversed].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'HAW 6/11/2022 19:21:17' prior: 16880295!
                       addParenthesesIfNeededTo: anExpression

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |

 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) == $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) == $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [anExpression]
		ifFalse: ['(', anExpression, ')'].! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/24/2022 11:20:42' prior: 16943027!
      scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := source class with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].
	(c == $: and: [d == $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (source class with: d).
			self nextChar.
			^currentToken].
	"|| empty temp declaration"
	"This makes || colorize as an invalid method definition.
	It is better to allow #|| as valid selector, and mark an empty temp declaration as invalid instead!!"
	"(c == $| and: [d == $|])
		ifTrue: [^currentToken]."
	c := d.
	[
		d := self peekChar.
		c == $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken := currentToken copyWith: c.
			c := self nextChar ].
	^currentToken! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:35' prior: 16943056!
                        scanComment
	| c s e |
	s := sourcePosition.
	
	[sourcePosition := sourcePosition + 1.
	(c := self currentChar) 
		ifNil: [
			self rangeType: #unfinishedComment start: s end: source size.
			^self error	": 'unfinished comment'"].
	c == $"] 
		whileFalse: [].
	e := sourcePosition.
	s < e ifTrue: [self rangeType: #comment start: s end: e].
	self nextChar.
	self scanWhitespace! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:41' prior: 16943070!
                 scanIdentifier
	| c start |
	start := sourcePosition.
	[ (c := self nextChar) isValidInIdentifiers ] whileTrue: [].
	(c == $: and: [(self isBinarySelectorCharacter: self peekChar) not]) 
		ifTrue: [self nextChar].
	currentToken := source copyFrom: start to: sourcePosition - 1.
	currentTokenSourcePosition := start! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/23/2022 12:46:55' prior: 16943096!
                scanNumber
	| start c nc base |
	start := sourcePosition.
	self skipDigits.
	c := self currentChar.
	('rx' includes: c)
		ifTrue: [
			base := Integer readFrom: ((source copyFrom: start to: sourcePosition - 1) readStream).
			self peekChar == $- ifTrue: [self nextChar].
			self skipBigDigits: base.
			c := self currentChar.
			c == $. 
				ifTrue: [
					(self isBigDigit: self nextChar base: base) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipBigDigits: base]].
			c := self currentChar.
			('deqp'includes: c)
				ifTrue: [
					((nc := self nextChar) isDigit or: [nc == $- and:[self peekChar isDigit]]) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			c == $s 
				ifTrue: [
					self nextChar isDigit 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c == $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits.].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c == $. 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [
					sourcePosition := sourcePosition - 1.
					currentToken := source copyFrom: start to: sourcePosition - 1.
					^currentTokenSourcePosition := start]
				ifTrue: [self skipDigits]].
	c := self currentChar.
	('deqp' includes: c)
		ifTrue: [
			((nc := self nextChar) isDigit or: [nc == $-  and:[self peekChar isDigit]]) 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	c == $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	currentToken := source copyFrom: start to: sourcePosition - 1.
	^currentTokenSourcePosition := start! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:45' prior: 16943200!
     scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'token testing' stamp: 'jmv 5/21/2022 22:35:28' prior: 16943278!
                       isBinary
	| c |
	(currentToken isNil or: [self isName or: [self isKeyword]]) 
		ifTrue: [^false].
	"Special case: '::' is not a binary selector but the Chain operator"
	(sourcePosition - currentTokenSourcePosition = 1 and: [
		(source at: currentTokenSourcePosition ifAbsent: nil) == $: and: [		
			(source at: sourcePosition ifAbsent: nil) == $: ]])
				ifTrue: [^ false ].
	1 to: currentToken size do: [ :i |
		c := currentToken at: i.
		((self isBinarySelectorCharacter: c) or: [c == $:])
			ifFalse: [^false]].
	^true! !
!SHParserST80 methodsFor: 'token testing' stamp: 'jmv 5/21/2022 22:35:32' prior: 16943297!
                        isKeyword
	^ currentTokenFirst isValidStartOfIdentifiers and: [ currentToken last == $: ]! !
!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 12/14/2018 15:39:18' prior: 16943331!
   isBinarySelectorCharacter: aCharacter
	aCharacter == $: ifTrue: [^ false].
	^aCharacter isValidInBinarySelectors! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:36' prior: 16943672!
                         parseArray
	[currentTokenFirst == $)] whileFalse: [self parseLiteralArrayElement].
	self scanPast: #arrayEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:41' prior: 16943678!
                             parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:49' prior: 16943711!
                               parseBlock

	"Just read $["
	blockDepths add: blockDepth+1.
	blockDepthsStartIndexes add: sourcePosition-1.

	self enterBlock.
	self scanPast: #blockStart level: bracketDepth.
	currentTokenFirst == $: ifTrue: [self parseBlockArguments].
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $].

	"Just read $]"
	blockDepths add: blockDepth-1.
	blockDepthsStartIndexes add: sourcePosition.

	self scanPast: #blockEnd level: bracketDepth.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:55' prior: 16943730!
                         parseBlockArguments
	[ currentTokenFirst == $: ]
		whileTrue: [
			self scanPast: #blockArgColon.
			self failUnless: self isName.
			self scanPast: #blockPatternArg ].
	currentTokenFirst == $| 
		ifTrue: [ self scanPast: #blockArgsBar ]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/13/2024 11:32:52' prior: 16943740!
                            parseBlockTemporaries

	currentToken = '||' "Empty temp declaration without whitespace"
		ifTrue: [ ^self scanPast: #blockTempBar ].

	currentTokenFirst == $| 
		ifTrue: [
			self scanPast: #blockTempBar.
			[self isName] 
				whileTrue: [self scanPast: #blockPatternTempVar].
			self failUnless: currentToken = '|'.
			self scanPast: #blockTempBar]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:05' prior: 16943754!
            parseBraceArray
	self parseStatementListForBraceArray.
	self failUnless: currentTokenFirst == $}.
	self scanPast: #rightBrace level: braceDepth.
	braceDepth := braceDepth - 1! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:12' prior: 16943762!
                           parseByteArray
	"Literal ByteArray or literal FloatArray"
	[currentTokenFirst == $]] whileFalse: [
		currentTokenFirst isDigit | (currentTokenFirst == $-)
			ifTrue: [
				"do not parse the number, can be time consuming"
				self scanPast: #number]
			ifFalse: [
				self failWhen: currentTokenFirst == $. .
				self error]].
	self scanPast: #arrayEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/16/2024 10:17:00' prior: 16943776!
          parseCascadeAndChain

	| beforeKeywordPos |
	beforeKeywordPos := currentTokenSourcePosition.
	self parseKeyword.

	"At least one message send before cascade and chain"
	beforeKeywordPos =​ currentTokenSourcePosition ifTrue: [ ^self ].

	currentTokenFirst == $; ifTrue:
		[
			self scanPast: #cascadeSeparator.
			^self parseCascadeAndChain
		].
	currentTokenFirst == $: ifTrue:
		[
			self scanPast: #chainSeparator.

			"These lines implement double colon chains"
			currentTokenFirst == $: ifFalse: [^self].
			self scanPast: #chainSeparator.
			
			^self parseCascadeAndChain
		].! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:25' prior: 16943819!
parseExternalCall
	self scanNext.
	self failWhen: currentToken isNil.
	self scanPast: #externalCallType.
	currentToken = '*' 
		ifTrue: [self scanPast: #externalCallTypePointerIndicator].
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: 	[
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentTokenFirst == $(.
	self scanPast: #leftParenthesis.
	[currentTokenFirst ~~ $)] 
		whileTrue: [
			self failWhen: currentToken isNil.
			self scanPast: #externalCallType.
			currentToken = '*' 
				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].
	self scanPast: #rightParenthesis.
	currentToken = 'module:' 
		ifTrue: [
			self scanPast: #module.
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:44:55' prior: 16943887!
        parseLiteral: inArray 
	currentTokenFirst == $$ 
		ifTrue: [
			| pos |
			self failWhen: self currentChar isNil.
			self rangeType: #'$'.
			pos := currentTokenSourcePosition + 1.
			self nextChar.
			self scanPast: #character start: pos end: pos.
			^self ].
	currentTokenFirst isDigit 
		ifTrue: [
			"do not parse the number, can be time consuming"
			self scanPast: #number.
			^self ].
	currentToken = '-' 
		ifTrue: [
			| c |
			c := self currentChar.
			(inArray and: [c isNil or: [c isDigit not]]) 
				ifTrue: [
					"single - can be a symbol in an Array"
					self scanPast: #symbol.
					^self ].
			self scanPast: #-.
			self failWhen: currentToken isNil.
			"token isNil ifTrue: [self error: 'Unexpected End Of Input']."
			"do not parse the number, can be time consuming"
			self scanPast: #number.
			^self ].
	currentTokenFirst == $' ifTrue: [
		self parseString.
		^self ].
	currentTokenFirst == $# ifTrue: [
		self parseSymbol.
		^self ].
	(inArray and: [currentToken notNil]) ifTrue: [
		self scanPast: #symbol.
		^self ].
	self failWhen: currentTokenFirst == $. .
	self error	": 'argument missing'"! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:39' prior: 16943925!
         parseLiteralArrayElement
	 currentTokenFirst isValidStartOfIdentifiers ifTrue: [
		#true = currentToken ifTrue: [
			self scanPast: #true.
			^ self ].
		#false = currentToken ifTrue: [
			self scanPast: #false.
			^ self ].
		#nil = currentToken ifTrue: [
			self scanPast: #nil.
			^ self ].
		self scanPast: #symbol.
		^ self ].
	currentTokenFirst == $( ifTrue: [
		self scanPast: #arrayStart.
		self parseArray.
		^ self ].
	self parseLiteral: true! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/13/2024 11:33:12' prior: 16943952!
     parseMethodTemporaries

	currentToken = '||' "Empty temp declaration without whitespace"
		ifTrue: [ ^self scanPast: #methodTempBar ].

	currentTokenFirst == $| 
		ifTrue: [
			self scanPast: #methodTempBar.
			[self isName] 
				whileTrue: [self scanPast: #patternTempVar].
			self failUnless: currentToken = '|'.
			self scanPast: #methodTempBar]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 8/23/2024 15:13:54' prior: 16944040!
             parseStatement
	(currentToken isNil or: [	currentToken size = 1]) ifTrue: [
		currentTokenFirst == $^ ifTrue: [self scanPast: #return].
		currentTokenFirst = Character smalltalkUpArrow ifTrue: [self scanPast: #return]].
	self parseExpression.! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:00' prior: 16944050!
                       parseStatementList
	
	[[currentTokenFirst == $.] whileTrue: [self scanPast: #statementSeparator].
	(currentToken notNil and: [currentTokenFirst ~~ $]]) 
		ifTrue: [self parseStatement].
	currentTokenFirst == $.] 
			whileTrue: [self scanPast: #statementSeparator]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/13/2024 11:38:10' prior: 16944061!
  parseStatementListForBraceArray
	"same as parseStatementList, but does not allow empty statements e.g {...$a...}.
	A single terminating . IS allowed e.g. {$a.} "

	
	[currentTokenFirst ~~ $} ifTrue: [self parseExpression].
	currentTokenFirst == $.] 
		whileTrue: [self scanPast: #statementSeparator]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:09' prior: 16944073!
                              parseString
	| first c last |
	first := sourcePosition.
	[
		(c := self currentChar) ifNil: [
			self
				rangeType: #unfinishedString
				start: first - 1
				end: source size.
			self error": 'unfinished string'" ].
		c ~~ $' or: [
			self peekChar == $' and: [
				sourcePosition := sourcePosition + 1.
				true ]]] whileTrue: [ sourcePosition := sourcePosition + 1 ].
	last := sourcePosition.
	self nextChar.
	self
		scanPast: #string
		start: first - 1
		end: last! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:15' prior: 16944090!
                    parseStringOrSymbol

	currentTokenFirst == $' ifTrue: [ ^self parseString ].
	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].
	self error! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:45:04' prior: 16944097!
                         parseSymbol
	| c |
	currentToken = '#' 
		ifTrue: [
			"if token is just the #, then scan whitespace and comments
			and then process the next character.
			Allows space between the # and the start of the symbol 
			e.g. # (),  #  a, #  'sym' "
			self rangeType: #symbol.
			self scanWhitespace].
	c := self currentChar.
	self failWhen: (c isNil or: [c isSeparator]).
	c == $( 
		ifTrue: [
			self nextChar.
			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.
			^self parseArray].
	c == $' ifTrue: [
		self parseSymbolString.
		^self ].
	c == $[ ifTrue: [
			self nextChar.
			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.
			^self parseByteArray].
	(self isBinarySelectorCharacter: c) ifTrue: [
		self parseSymbolSelector.
		^self ].
	( c isValidStartOfIdentifiers or: [c == $:]) ifTrue: [
		self parseSymbolIdentifier.
		^self].
	self parseCharSymbol! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:29' prior: 16944129!
              parseSymbolIdentifier
	| c start end |
	c := self currentChar.
	self failUnless: ( c isValidStartOfIdentifiers or: [ c == $: ]).
	start := sourcePosition.
	[
		c := self nextChar.
		c isValidInIdentifiers or: [ c == $: ]
	] whileTrue: [].
	end := sourcePosition - 1.
	self scanPast: #symbol start: start - 1 end: end! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:34' prior: 16944152!
             parseSymbolString
	| first c last |
	first := sourcePosition.
	self nextChar.
	[
		(c := self currentChar) 
			ifNil: [
				self rangeType: #unfinishedString start: first end: source size.
				self error	": 'unfinished string'"].
		c ~~ $' or: [
			self peekChar == $' 
				ifTrue: [sourcePosition := sourcePosition + 1. true] 
				ifFalse: [false]]
	] whileTrue: [sourcePosition := sourcePosition + 1].
	last := sourcePosition.
	self nextChar.
	self scanPast: #stringSymbol start: first - 1 end: last! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:45:14' prior: 16944170!
                    parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst == $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst == $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst == $[ ifTrue: [^self parseBlock].
	currentTokenFirst == $` ifTrue: [^self parseBacktick].
	currentTokenFirst == ${ 
		ifTrue: [
			braceDepth := braceDepth + 1.
			self scanPast: #leftBrace level: braceDepth.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !

Character initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7000-UseEqualEqualForLiteralCharacters-JuanVuletich-2025Jan22-08h32m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7000] on 22 January 2025 at 3:01:40 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/22/2025 15:00:17'!
                       translated
	"In Squeak, #translated does localization of Strings. This method helps with compatibility.
	Additionally, applications written in Cuis could do the same.
	This method should be redefined in a Localization package."! !
!Text methodsFor: 'converting' stamp: 'jmv 1/22/2025 15:00:27'!
                         translated
	"In Squeak, #translated does localization of Strings. This method helps with compatibility.
	Additionally, applications written in Cuis could do the same.
	This method should be redefined in a Localization package."! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7001-translated-JuanVuletich-2025Jan22-14h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7000] on 22 January 2025 at 3:02:14 pm'!
!ContextPart methodsFor: 'controlling' stamp: 'jmv 1/22/2025 15:01:43' prior: 50347579!
                               executeMethod: meth forSelector: selector withArgs: arguments receiver: rcvr

	| primIndex val ctxt isPrimitive |
	(self objectClass: meth) isCompiledMethodClass ifFalse:
		["Object as Methods (OaM) protocol: 'The contract is that, when the VM encounters an ordinary object (rather than a compiled method) in the method dictionary during lookup, it sends it the special selector #run:with:in: providing the original selector, arguments, and receiver.'. DOI: 10.1145/2991041.2991062."
		^self send: #run:with:in:
			to: meth
			with: {selector. arguments. rcvr}].
	
	meth numArgs = arguments size ifFalse:
		[^ self class primitiveFailTokenFor: #'bad number of arguments'].
	primIndex := meth primitive.
	isPrimitive := primIndex > 0 and: [ meth isQuick not ].
	isPrimitive ifTrue:
		[val := self doPrimitive: primIndex method: meth receiver: rcvr args: arguments.
		(self isPrimFailToken: val) ifFalse:
			[^val]].
	
	ctxt := self activateMethod: meth withArgs: arguments receiver: rcvr.
	isPrimitive ifTrue:
		[ctxt failPrimitiveWith: val].
	
	^ctxt! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7002-RestoreStepIntoQuickMethods-JuanVuletich-2025Jan22-15h01m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7002] on 23 January 2025 at 8:38:17 am'!
!Debugger methodsFor: 'method creation' stamp: 'jmv 1/23/2025 08:37:41' prior: 16843897!
                      wasInterruptedOnOverridableMethod
	| methodClass receiverClass |

	self interruptedContext sender ifNotNil:
		[ :senderContext |
			senderContext selector == #shouldBeImplemented ifTrue: 
				[ ^false ]].

	methodClass := self interruptedContext method methodClass.
	receiverClass := self interruptedContext receiver class.

	^ methodClass ~= receiverClass! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7003-Debugger-Dont-Create-if-shouldBeImplemented-JuanVuletich-2025Jan23-08h37m-jmv.001.cs.st----!

----QUIT----(23 January 2025 11:11:19) Cuis7.3-7003.image priorSource: 352489!