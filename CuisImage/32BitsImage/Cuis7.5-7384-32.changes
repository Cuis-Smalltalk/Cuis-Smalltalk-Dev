'From Cuis7.4 [latest update: #7257] on 30 May 2025 at 6:34:32 pm'!


----SNAPSHOT----(30 May 2025 18:34:32) Cuis7.4-32.image priorSource: 0!

Preferences at: #saveReleaseOptionsInWorldMenu put: true!

----QUIT----(30 May 2025 18:34:56) Cuis7.5-7257-32.image priorSource: 68!

----STARTUP---- (15 July 2025 11:02:24) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\Cuis7.5-7257-32.image!


'From Cuis7.5 [latest update: #7257] on 2 June 2025 at 2:40:50 pm'!
!WeakSet commentStamp: '<historical>' prior: 17016074!
                             An implementation of WeakSet that gives good performance for large instances.

It is implemented as a two level hash table. The outer level is a closed hash table, and is accessed using the higher bits of each element's hash value. At each position a Bucket is stored.

The lower bits of the hash are used to acess each Bucket. The buckets for an open hash table. Each bucket has a fixed size for direct access using the hash, and after it, a variable size area to store elements with duplicated (partial) hashes.

Currently, the Buckets use 8 positions for O(1) direct access using the lower 3 bits of the hash. The iterable part after it can grow as needed.

Buckets are WeakArrays.

The idea for small WeakArrays as buckets is from a previous SymbolSet by Andr√©s Valloud.
The idea of buckets having a direct access part, and an variable sized overflow part for (partial) hash collisions is from Juan Vuletich, specific for this class.

Note: An implementations using these ideas, could be good for Set et al.
Note: Perhaps a three level table, with a fixed size outer level, and where the mid level arrays grow as needed, could further improve performance for very large collections.!
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 14:07:59'!
               recreateObsoleteClassesCollection
	"
	Behavior recreateObsoleteClassesCollection
	"
	ObsoleteSubclasses := nil.
	Smalltalk garbageCollect.
	Smalltalk allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [
			ObsoleteSubclasses ifNil: [
				ObsoleteSubclasses := WeakIdentitySet new ].
			ObsoleteSubclasses add: cl]].! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 13:25:19' prior: 16789725!
                   addObsoleteSubclass: aClass
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"

	ObsoleteSubclasses ifNil: [
		ObsoleteSubclasses := WeakIdentitySet new ].
	ObsoleteSubclasses add: aClass.! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 13:25:44' prior: 16789741!
     obsoleteSubclasses
	"Return all the weakly remembered obsolete subclasses of the receiver.
	Clean out the already collected ones."

	ObsoleteSubclasses ifNil: [
		^#() ].
	^ObsoleteSubclasses select: [ :any |
		any superclass == self ].! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 13:30:18' prior: 16789776!
                    removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses."

	ObsoleteSubclasses ifNil: [
		^ self ].
	ObsoleteSubclasses remove: aClass ifAbsent: [].! !
!WeakSet class methodsFor: '[mkSymbol] instance creation' stamp: 'jmv 6/2/2025 14:38:40' prior: 17016625!
                        newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing
	WeakSet newWithRoomForMoreThan: 31
	WeakSet newWithRoomForMoreThan: 32
	"

	| answer |
	answer := self basicNew.
	answer init: (2 raisedToInteger: (nElements // answer bucketDesiredMeanOccupation max: 1) highBit -1).
	^answer! !

Metaclass removeSelector: #replaceObsoleteInstanceWith:!

!methodRemoval: Metaclass #replaceObsoleteInstanceWith: stamp: 'Install-7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st 7/15/2025 11:02:24'!
replaceObsoleteInstanceWith: newInstance
	thisClass class == self ifTrue:[^self error:'I am fine, thanks'].
	newInstance class == self ifFalse:[^self error:'Not an instance of me'].
	thisClass := newInstance.!

Behavior removeSelector: #removeAllObsoleteSubclasses!

!methodRemoval: Behavior #removeAllObsoleteSubclasses stamp: 'Install-7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st 7/15/2025 11:02:24'!
removeAllObsoleteSubclasses
	"Remove all the obsolete subclasses of the receiver"
	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses removeKey: self ifAbsent: nil ]!

Behavior removeSelector: #recreateObsoleteSubclassesCollection!

!methodRemoval: Behavior #recreateObsoleteSubclassesCollection stamp: 'Install-7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st 7/15/2025 11:02:24'!
recreateObsoleteSubclassesCollection
	"
	Behavior recreateObsoleteSubclassesCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ObsoleteSubclasses ifNotNil:
		[:oldOne|
		oldOne keysAndValuesDo:
			[ :k :v | newOne at: k put: v ] ].
	ObsoleteSubclasses := newOne.!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	Behavior recreateObsoleteClassesCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7258] on 2 June 2025 at 4:51:09 pm'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 6/2/2025 16:50:18'!
noButtonShape
	"Draw only the icon and or label, with no button shape"
	roundButtonStyle := #none.
	self redrawNeeded.! !

PluggableButtonMorph removeSelector: #iconOnly:!

!methodRemoval: PluggableButtonMorph #iconOnly: stamp: 'Install-7259-PluggableButtonMorph-noButtonShape-JuanVuletich-2025Jun02-16h49m-jmv.001.cs.st 7/15/2025 11:02:24'!
iconOnly: aForm
	"Draw only the icon, with no button shape or mouse over indication"
	icon := aForm.
	magnifiedIcon := nil.
	roundButtonStyle := #none.
	self redrawNeeded.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7259-PluggableButtonMorph-noButtonShape-JuanVuletich-2025Jun02-16h49m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7259] on 5 June 2025 at 11:11:13 am'!
!Morph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:20'!
                 defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	Please make them natural numbers.
	See implementors."

	^100! !
!HaloMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:26' overrides: 50331851!
        defaultLayerNumber
	^ 20! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:45' overrides: 50331851!
        defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be on top."

	^10! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 11:00:48' overrides: 50331851!
    defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^10! !
!StringRequestMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:48' overrides: 50331851!
                        defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:58:40' overrides: 50331851!
                          defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:47:03' overrides: 50331851!
                        defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!Morph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:48:36' prior: 16910428!
         layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	See #defaultLayerNumber."

	^self
		valueOfProperty: #layerNumber
		ifAbsent: [self defaultLayerNumber]! !
!Morph methodsFor: 'private' stamp: 'jmv 6/5/2025 10:42:19' prior: 16914633!
              privateFixLayerOrder
	"Ensure that morphs with smaller #layerNumber are above morphs with larger #layerNumber.
	Keep current sorting inside each set with same #layerNumber."

	| layerNumbers sortedSubmorphs newIndex |
	self honorsLayerOrder ifFalse: [ ^self ].
	submorphs size < 2 ifTrue: [ ^self ].
	layerNumbers := Set new.
	submorphs do: [ :m | layerNumbers add: m layerNumber ].
	layerNumbers := layerNumbers asArray sort.
	sortedSubmorphs := Array new: submorphs size.
	newIndex := 1.
	layerNumbers do: [ :layerNumber |
		submorphs withIndexDo: [ :m :i |
			m layerNumber = layerNumber ifTrue: [
				sortedSubmorphs at: newIndex put: m.
				newIndex = i ifFalse: [ m invalidateBounds ].
				newIndex := newIndex + 1 ]]].
	submorphs := sortedSubmorphs.! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 6/5/2025 11:00:51' prior: 16940092 overrides: 16896737!
                        initialize
	super initialize.
	self separation: 0.
	labelMorph := LabelMorph contents: '' font: FontFamily defaultFamilyAndPointSize.
	subLabelMorph := LabelMorph contents: '' font: FontFamily defaultFamilyAndPointSize.
	progress := ProgressBarMorph new.
	progress morphExtent: 200 @ FontFamily defaultLineSpacing.
	self addMorphFront: labelMorph.
	self addMorphFront: subLabelMorph.
	self addMorph: progress fixedHeight: FontFamily defaultLineSpacing.! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:59:39' prior: 16900367!
     stayUp: aBoolean

	stayUp := aBoolean.
	aBoolean ifTrue: [ self removeStayUpBox ].
	self taskbar ifNotNil: [ :tb | tb refreshTaskbarFor: self ].! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/5/2025 10:35:38' prior: 16980057!
                           addWindowControlTo: aMenu

	aMenu
		add: 'send to back' 				action: #sendToBack 				icon: #goBottomIcon;
		add: 'make next-to-topmost' 	action: #makeSecondTopmost 		icon: #goUpIcon;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ])
										action: #toggleStickiness 			icon: (self isSticky ifFalse: [#pushPinIcon]);
		addLine;
		add: 'close' 						action: #delete 						icon: #closeIcon;
		add: 'collapse' 					action: #collapse 					icon: #collapseIcon;
		add: 'expand / contract' 			action: #expandBoxHit 				icon: #expandIcon;
		addLine;
		add: 'resize...' 					action: #resize.
		
	^aMenu! !

AutoCompleterMorph removeSelector: #layerNumber!

!methodRemoval: AutoCompleterMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:24'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20!

MenuMorph removeSelector: #layerNumber!

!methodRemoval: MenuMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:24'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	stayUp ifTrue: [ ^super layerNumber ].
	^20!

StringRequestMorph removeSelector: #layerNumber!

!methodRemoval: StringRequestMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:24'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30!

HoverHelpMorph removeSelector: #layerNumber!

!methodRemoval: HoverHelpMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:24'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be on top."

	^10!

HaloMorph removeSelector: #layerNumber!

!methodRemoval: HaloMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:24'!
layerNumber
	^ 10!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7259] on 5 June 2025 at 11:06:45 am'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/5/2025 11:06:02' prior: 16914012!
     comeToFront

	"Restore default #layerNumber for us.
	We may still end behind other 'more topMost' morphs."
	self removeProperty: #layerNumber.
	self atFront ifFalse: [owner privateMoveFrontMorph: self]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/5/2025 11:06:36' prior: 16914043!
                         goBehind
	| regularLayerNumber |
	"Set our #layerNumber to the default for most morphs, allowing us
	to go behind them."
	regularLayerNumber  := 100.
	self layerNumber = regularLayerNumber ifFalse: [
		self setProperty: #layerNumber toValue: regularLayerNumber ].
	owner privateMoveBackMorph: self.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7261-goBehind-despiteLayerNumber-JuanVuletich-2025Jun05-11h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7261] on 5 June 2025 at 12:00:20 pm'!
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/5/2025 11:57:45' prior: 16900676!
                     addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preferences at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW := Theme current titleBarButtonsExtent x.
	closeButton := PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; noButtonShape.
	pinButton := PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; noButtonShape.
	w := (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + (buttonHW*2).
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW * 12 // 10);
			color: `Color transparent`;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//10;
			addMorph: (closeButton layoutSpec: (LayoutSpec fixedWidth: buttonHW fixedHeight: buttonHW));
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7262-MenuStayUpButtonTweak-JuanVuletich-2025Jun05-11h57m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7262] on 9 June 2025 at 9:38:08 am'!
!ChangeSorterWindow methodsFor: 'menu commands' stamp: 'NPM 6/9/2025 09:23:31'!
                trimHistory
	
	(self confirm: self trimHistoryConfirmationMessage)
		ifFalse: [ ^ self ].
	
	model trimHistory
	
	! !
!ChangeSorterWindow methodsFor: 'menu commands' stamp: 'NPM 6/9/2025 09:23:19'!
                          trimHistoryConfirmationMessage
	
	^ String streamContents: [ :confirmationMessage |
		confirmationMessage
			nextPutAll: 'You are about to permanently remove non-essential history,';
			newLine;
			nextPutAll: 'including methods that were added and then removed,';
			newLine;
			nextPutAll: 'as well as renames and reorganizations of newly added classes.';
			newLine;
			newLine;
			nextPutAll: 'This action cannot be undone.';
			newLine;
			newLine;
			nextPutAll: 'Do you want to continue?'
		]! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'NPM 6/9/2025 09:28:00' prior: 16809899!
              trimHistory
	"Drop non-essential history (rename, reorg, method removals) from newly-added classes."

	myChangeSet trimHistory.
	
	self showChangeSet: myChangeSet

! !
!ChangeSorterWindow methodsFor: 'menu & kbd shortcuts' stamp: 'NPM 6/9/2025 09:35:33' prior: 16810351!
                 changeSetListMenuSpec
	"Spec for the menu and shortcut keys for the changesets list.
	See coment at Morph >> #getMenu
	"
	| answer |
	answer := #(
			#(0 		'Change Set' 						true)
			#(10 		'File out, start a new cs (o)' 			$o 	model 		fileOutAndRemove 				fileOutIcon)
			#(20 		'File out, keep current cs (k)' 			$k 	model 		fileOutAndKeep 				fileOutIcon)
			#(30 		'-----')
			#(40 		'Rename change set (R)' 				$R 	model 		rename 						saveAsIcon)
			#(50 		'Destroy change set (x)' 			 	$x 	model 		remove 						warningIcon)
	).
	model currentCanHavePreambleAndPostscript ifTrue: [
		model currentHasPreamble
			ifTrue: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Edit preamble (p)' 					$p 	model 		addPreamble 					textEditorIcon)
				#(80 	'Remove preamble' 					nil 	model 		removePreamble 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Add preamble (p)' 					$p 	model 		addPreamble 					listAddIcon) )].
		model currentHasPostscript
			ifTrue: [ answer  := answer, #(
				#(90 	'Edit postscript...' 					nil 	model 		editPostscript 					textEditorIcon)
				#(100 	'Remove postscript' 					nil 	model 		removePostscript 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(90 	'Add postscript...' 					nil 	model 		editPostscript 					listAddIcon) )].
	].

	answer  := answer, #(
		#(110 			'-----')
		#(120 			'Conflicts with other change sets' 		nil 	window		browseMethodConflicts 		emblemImportantIcon
			'Browse all methods that occur both in this change set and in at least one other change set.')
		#(130 			'-----')
		#(140 			'Trim history' 						nil 	window		trimHistory 					clockIcon
			'Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.
 NOTE: can cause confusion if later filed in over an earlier version of these changes.')
		#(150 			'View affected class categories' 		nil 	model 		viewAffectedClassCategories	packageIcon
			'Show class categories affected by any contained change')
	).
	model csIsForBase ifFalse: [ "Maybe disable a few: Copy them the same as above, but without selector."
		answer := answer, #(
			#(40 		'Rename change set (R)' 				$R 	model 		nil 								saveAsIcon)
			#(50 		'Destroy change set (x)' 		 		$x 	model 		nil 								warningIcon)) ].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7263-ChangeSet-trimHistory-tweaks-NicolasPapagnaMaldonado-2025Jun09-09h09m-NPM.001.cs.st----!

'From Cuis7.5 [latest update: #7263] on 13 June 2025 at 10:12:24 am'!

ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep uniqueNodeVisitedCounter '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #EquivalentNodesFinder category: #'Compiler-Support' stamp: 'Install-7264-FindsRepeatedBlocks-HernanWilkinson-2025Jun12-14h25m-HAW.001.cs.st 7/15/2025 11:02:24'!
ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep uniqueNodeVisitedCounter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860204!
      completeSourceRangeOf: aNode

	| sourceRangeIndex completeSourceRanges completeRange trimmedRange |
	
	sourceRangeIndex := uniqueNodeVisitedCounter occurrencesOf: aNode.
	sourceRangeIndex = 0 ifTrue: [ sourceRangeIndex := 1 ].
	
	"It should always find the completeSourceRanges of aNode and a range at the sourceRangeIndex - Hernan"
	completeSourceRanges := methodNode completeSourceRanges at: aNode.
	completeRange := completeSourceRanges at: sourceRangeIndex.
	
	"See ExtractMethodFinderTest>>test27FindsInsideParentesis - Hernan"
	trimmedRange := nodesToLookForSize = 1 
		ifTrue: [ completeRange trimToMatchExpressionOn: methodNode sourceText ]
		ifFalse: [ completeRange ].
	
	^trimmedRange! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 10:00:04' prior: 16860298 overrides: 16927072!
                  visitBlockNode: blockNode

	| blockStatements |

	self addToEquivalentsIfOneStatementEquivalentTo: blockNode.

	super visitBlockNode: blockNode.
	
	nodesToLookForSize > 1 ifTrue: [ 
		blockStatements := blockNode statements. 
		"I need to add temp declaration to statements becuase user could have selected the temp declaration
		See ExtractMethodFinderTest>>test22FindsTemporaryWhenSelectingDefinitionInInnerClosure - Hernan"
		blockNode declaresAnyVariable ifTrue: [ blockStatements addFirst: blockNode temporariesDeclaration ].
		self addEquivalentNodesOf: blockStatements ]
		! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860317 overrides: 16927080!
     visitBraceNode: aBraceNode 
	
	uniqueNodeVisitedCounter add: aBraceNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aBraceNode.
	
	^super visitBraceNode: aBraceNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860332 overrides: 16927093!
                           visitInstanceVariableNode: anInstanceVariableNode 

	uniqueNodeVisitedCounter add: anInstanceVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: anInstanceVariableNode.

	^super visitInstanceVariableNode: anInstanceVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860343 overrides: 16927097!
                       visitLiteralNode: aLiteralNode

	uniqueNodeVisitedCounter add: aLiteralNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralNode.

	^super visitLiteralNode: aLiteralNode! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860352 overrides: 16927101!
                   visitLiteralVariableNode: aLiteralVariableNode 
	
	uniqueNodeVisitedCounter add: aLiteralVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralVariableNode.
	
	^super visitLiteralVariableNode: aLiteralVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860369 overrides: 16927147!
                               visitTempVariableNode: aTempVariableNode 
	
	uniqueNodeVisitedCounter add: aTempVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aTempVariableNode.
	
	^super visitTempVariableNode: aTempVariableNode ! !
!EquivalentNodesFinder methodsFor: 'initialization' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860379!
                               initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	nodesToLookFor := aNodesToLookFor.
	methodNode := aMethodNode.
	selectionToKeep := aSelectionToKeep.
	
	nodesToLookForSize := nodesToLookFor size.
	uniqueNodeVisitedCounter := IdentityBag new.
	equivalentNodesRanges := OrderedCollection new.
	! !

ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize uniqueNodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #EquivalentNodesFinder category: #'Compiler-Support' stamp: 'Install-7264-FindsRepeatedBlocks-HernanWilkinson-2025Jun12-14h25m-HAW.001.cs.st 7/15/2025 11:02:24'!
ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize uniqueNodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7264-FindsRepeatedBlocks-HernanWilkinson-2025Jun12-14h25m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7263] on 13 June 2025 at 11:46:57 am'!
!ChangeList class methodsFor: 'public access' stamp: 'jmv 6/13/2025 11:45:20' prior: 16805317!
                    browsePackageContents: aFileEntry
	"Opens a changeList on a fileStream"
	| changeList packageFile |
	packageFile := CodePackageFile onFileEntry: aFileEntry.
	changeList := aFileEntry readStreamDo: [ :stream |
		self new scanFile: stream from: 0 to: stream size ].
	"Add deletions of methods and classes that are in the CodePackage (i.e., active in the system)
	but are no longer in the CodePackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new
				methodReference: methodReference;
				doItOnlyIfInBaseSystem: false)
			text: 'method no longer in package: ', methodReference stringVersion ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new
				className: clsName;
				doItOnlyIfInBaseSystem: false)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aFileEntry name! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7265-browsePackageContents-fix-JuanVuletich-2025Jun13-11h37m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7246] on 26 May 2025 at 4:16:40 pm'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7266-ReleaseFontCache-afterTroublesomeFirstProgressUpdate-JuanVuletich-2025May26-16h16m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7263] on 9 June 2025 at 4:41:03 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7267-InstructionStream-cleanup-JuanVuletich-2025Jun09-16h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7267] on 17 June 2025 at 5:18:17 pm'!
!Object methodsFor: 'user interface' stamp: 'len 5/20/2020 04:00:44' prior: 16923457!
                       request: queryString do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: '' verifying: [:aString| true] do: acceptBlock orCancel: [nil]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:57' prior: 16856550 overrides: 16802555!
                         instVarReadScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	0-15	0000 i i i i 				Push Receiver Variable #iiii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b < 16 and: [b = varIndexCode])
	    or: [b = 226
			and: [scanner followingByte + prevext = varIndexCode]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' prior: 16856577 overrides: 16802568!
       instVarWriteScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for writes of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	200-207	11001 iii					Pop and Store Receiver Variable #iii
	*	224			11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	240			11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	*	243			11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b >= 200
	    and: [b < 208
	    and: [b - 200 = varIndexCode]])
	   or: [(b = 240 or: [b = 243])
		  and: [scanner followingByte + prevext = varIndexCode]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7268-FormattingTweaks-JuanVuletich-2025Jun17-17h16m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7268] on 17 June 2025 at 5:19:13 pm'!
!DataStream class methodsFor: '[mkObjectSerialization] cached state access' stamp: 'jmv 6/17/2025 16:24:25' prior: 16842455!
 initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  #nextPut: writes these IDs to the data stream.
	NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"
	| t |
	t := TypeMap := Dictionary newWithRoomForMoreThan: 80. "sparse for fast hashing"

	t at: #UndefinedObject put: 1.
	t at: #True put: 2.
	t at: #False put: 3.
	t at: #SmallInteger put: 4.
	"(type ID 5 was for Squeak's old String format)"
	t at: #Symbol put: 6.
	t at: #ByteArray put: 7.
	t at: #Array put: 8.
	"(type ID 9 is for arbitrary instances of any class. See #typeIDFor: See #writeInstance: See #readInstance)"
	"(type ID 10 is for references, See ReferenceStream>>tryToPutReference:typeID:)"
	t at: #Bitmap put: 11.
	t at: #Metaclass put: 12.
	"Type ID 13 was for Squeak's  HyperSqueak User classes."
	t at: #Float put: 14.
	t at: #BoxedFloat64 put: 14.
	t at: #SmallFloat64 put: 14.
	"(type ID 15 was for Squeak's old Deprecated compact Rects."
	"type ID 16 is an instance with short header.  See #beginInstance:size:"
	t at: #String put: 17.	"'new' String format, 1 or 4 bytes of length"
	t at: #WordArray put: 18.
	"type ID 19 was for Squeak's Word Array for Segment."
	"For all classes that are like WordArrays, store them as bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isBehavior ifTrue: [
			cls isPointers not & cls isVariable & cls isWords ifTrue: [
				(t includesKey: cls name) ifFalse: [
					t at: cls name put: 20 ]]]].
	t at: #CompiledMethod put: 21.	"special creation method"
	t at: #Character put: 22.
	t at: #UnicodeString put: 23.
	t at: #UnicodeSymbol put: 24.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7269-RemoveSlip-JuanVuletich-2025Jun17-17h18m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7268] on 17 June 2025 at 5:20:33 pm'!
!EncoderForSistaV1 commentStamp: 'eem 12/22/2024 19:07' prior: 16854876!
     EncoderForSistaV1 encodes a bytecode set for Smalltalk that lifts limits on the number of literals, branch distances, the number of temporary variables, and provides extended push integer and push character bytecodes.  The bytecode set also supports creating FullBlockClosures, closures whose method is separate from their home method's.  Bytecodes are ordered by length to make decoding easier.  Bytecodes marked with an * are extensible via a prefix extension bytecode.

N.B.  Extension bytecodes can only come before extensible bytecodes, and only if valid (one cannot extend a bytecode extensible by Ext A with an Ext B).  An extensible bytecode consumes (and zeros) its extension(s).  Hence the hidden implicit variables holding extensions are always zero except after a valid sequence of extension bytecodes.  The implication is that a bytecode interpreter should maintain the extension values in static variables initialized to zero at start-up, and live only from the start of a sequence of extension bytecodes to the end of the extended bytecode immediately following.

While the bytecode set lifts limits, it still assumes there are no more than 65535 literals (as of 2020 the CompiledCode header word imposes a 32,767 limit on number of literals), and no more than 256 stack slots (used for arguments, temporaries, and stack contents) in a Context.

EncoderForSistaV1 also includes an extended set of bytecodes for Sista, the Speculative Inlining Smalltalk Architecture, a project by Cl√©ment Bera and Eliot Miranda.  Scorch is an optimizer that exists in the Smalltalk image, /not/ in the VM,  and optimizes by substituting normal bytecoded methods by optimized bytecoded methods that may use special bytecodes for which the Cogit can generate faster code.  These bytecodes eliminate overheads such as bounds checks or polymorphic code (indexing Array, ByteArray, String etc).  But the bulk of the optimization performed is in inlining blocks and sends for the common path.  This bytecode set therefore differs from a normal Smalltalk set in providing a set of inlined primitives that do not validate their arguments that the compiler generates only when it can prove that the primitives' arguments are valid.

The basic scheme is that the Cogit generates code containing performance counters.  When these counters trip, a callback into the image is performed, at which point Scorch analyses some portion of the stack, looking at performance data for the methods on the stack, and optimises based on the stack and performance data.  Execution then resumes in the optimized code.

The Sista Cogit (e.g. SistaStackToRegisterMappingCogit) adds counters to conditional branches.  Each branch has an executed and a taken count.  On execution the executed count is decremented and if the count goes below zero the VM sends a message at a special index in the specialObjectsArray (as of writing, conditionalCounterTrippedOn:).  Then if the branch is taken the taken count is decremented.  The two counter values allow the Sista optimizer to collect basic block execution paths and to know what are the "hot" paths through execution that are worth agressively optimizing.  Since conditional branches are about 1/6 as frequent as sends, and since they can be used to determine the hot path through code, they are a better choice to count than, for example, method or block entry.

The VM provides a primitive that fills an Array with the state of the counters, and the state of each linked send in a method.  The optimizer obtains the branch and send data for a method via this primitive.

Instance Variables (inherited)

Here is the list of bytecodes.  An asterisk implies the bytecode takes either extA or extB extensions. Two asterisks imply it takes both extA and extB extensions.  A number in parentheses is a note.  See the notes at the end of the table.

1 Byte Bytecodes
	code (note)	binary				name
	0-15		0000 iiii 				Push Receiver Variable #iiii
	16-31		0001 iiii				Push Literal Variable #iiii
	32-63		001 iiiii				Push Literal #iiiii
	64-71		01000 iii				Push Temp #iii
	72-75		010010 ii			Push Temp #ii + 8
	76			01001100			Push Receiver
	77			01001101			Push true
	78			01001110			Push false
	79			01001111			Push nil
	80			01010000			Push 0
	81			01010001			Push 1
*	82			01010010			Push thisContext, (then Extend B = 1 => push thisProcess)
	83			01010011			Duplicate Stack Top
	84-87		010101 ii			UNASSIGNED
	88-91		010110 ii			Return Receiver/true/false/nil
	92			01011100			Return top
	93			01011101			BlockReturn nil
*	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]
*	95			01011111			Nop
	96-111		0110 iiii				Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	112-119	01110 iii				Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	120-127	01111 iii				Send Special Message #iii + 8 (~~ value value: do: new new: x y)
	128-143	1000 iiii				Send Literal Selector #iiii With 0 Argument
	144-159	1001 iiii				Send Literal Selector #iiii With 1 Arguments
	160-175	1010 iiii				Send Literal Selector #iiii With 2 Arguments
	176-183	10110 iii				Jump iii + 1 (i.e., 1 through 8)
	184-191	10111 iii				Pop and Jump 0n True iii +1 (i.e., 1 through 8)
	192-199	11000 iii				Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	200-207	11001 iii				Pop and Store Receiver Variable #iii
	208-215	11010 iii				Pop and Store Temporary Variable #iii
	216			11011000			Pop Stack Top
	217	(5)		11011001			Unconditional trap
	218-219	1101101 i			UNASSIGNED
	220-223	110111 ii			UNASSIGNED

2 Byte Bytecodes
*	224			11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A) A is an unsigned extension.
*	225			11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B) B is a signed extension.
*	226			11100010	iiiiiiii		Push Receiver Variable #iiiiiiii (+ Extend A * 256)
*	227			11100011	iiiiiiii		Push Literal Variable #iiiiiiii (+ Extend A * 256)
*	228			11100100	iiiiiiii		Push Literal #iiiiiiii (+ Extend A * 256)
	229			11100101	iiiiiiii		Push Temporary Variable #iiiiiiii
	230			11100110	iiiiiiii		UNASSIGNED (was pushNClosureTemps)
	231			11100111	jkkkkkkk		Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)
*	232			11101000	iiiiiiii		Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
*	233			11101001	iiiiiiii		Push Character #iiiiiiii (+ Extend A * 256)
**	234			11101010	iiiiijjj		Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
**	235	(1)		11101011	iiiiijjj		ExtendB < 64
										ifTrue: [Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments]
										ifFalse: [Send To Superclass of Stacked Class Literal Selector #iiiii (+ Extend A * 32) with jjj (+ (Extend B bitAnd: 63) * 8) Arguments]
	236			11101100	iiiiiiii		UNASSIGNED
*	237			11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
**	238	(4)		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	239	(4)		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	240	(3)		11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	241	(3)		11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	242			11110010	iiiiiiii		Pop and Store Temporary Variable #iiiiiiii
**	243	(3)		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	244	(3)		11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	245			11110110	iiiiiiii		Store Temporary Variable #iiiiiiii
	246-247	1111011 i	xxxxxxxx	UNASSIGNED

3 Byte Bytecodes
	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
												m=1 means inlined primitive, no hard return after execution. 
												ss defines the unsafe operation set used to encode the operations. 
												(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are as yet unused)
												Lowcode inlined primitives may have extensions.
*	249		11111001 	xxxxxxxx	siyyyyyy		Push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1
**	250		11111010 	eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions
	251		11111011 	kkkkkkkk	sjjjjjjj		Push Temp At kkkkkkkk In Temp Vector At: jjjjjjj, s = 1 implies remote inst var access instead of remote temp vector access 
*	252	(3)	11111100 	kkkkkkkk	sjjjjjjj		Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access 
*	253	(3)	11111101 	kkkkkkkk	sjjjjjjj		Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Not Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ Extend B * 256, where Extend B >= 0 and <= 127)
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ (Extend B bitAnd: 127) * 256, where Extend B >= 128 and <= 255)
*	255		11111111	xxxxxxxx	jjjjjjjj		UNASSIGNED

(1) Bytecode 235 is a super send bytecode that starts the lookup in the superclass of some class.  It has two forms, "normal" and "directed". In the normal form, the class is the value of the method's methodClassAssociation which must be the last literal.  In the directed form the class is the class on top of stack.

(2) The Call Primitive Bytecode (see below) specifies either a primitive in the primitive table (m=0) or an inlined primitive (m=1). Non-inlined primitives from the primitive table have index (jjjjjjj * 256) + iiiiiiii and return from the method if they succeed.  This bytecode is only valid as the first bytecode of a method.  Inline primitives have index (jjjjjjj * 256) + iiiiiiii, cannot fail, and do not return when they succeed, yielding a result (typically on top of stack after popping their arguments, but possibly in a byte data stack, for example for unboxed floating-point primitives).

(3) ExtB lowest bit implies no store check is needed, ExtB second bit implies the object may be a context, ExtB third bit implies no immutability/read-only check is needed, other bits in the extension are unused.

(4) ExtA = 1 implies no mustBeBoolean trampoline is needed, other bits in the extension are unused

(5) these are Scorch/Sista bytecodes generated by an optimizing compiler and not used in normal Smalltalk code.


The CallPrimitive bytecode is divided into two halves, those for normal primtiives, occurring at the beginning of a method, and those for inline primitives, anywhere within the body of a method.  This is a three byte bytecode, the first byte being 248, and the second byte being a big-endian 16-bit primitive index. If the top bit of the first byte of the primitive index is 1 then this is a normal primitive invocation.  If it is zero then the remaining 15 bits define 32k primitives, organized as four 8k "pages".  The first page is used for and reserved by the Sista optimizing compiler.  The second page is usd for and reserved by the Lowcode FFI marshalling primitive set.  The other two sets are unspecified and unused.

Here is the specification of the Sista unsafe instructions (unsafe operations, set 00). The lowcode set uses external specifications.
We sort the inline primitive operations by arity.  Nullary primitives occupy the 0-999 range. Unary primitives occupy the 1-1999 range, up until 8 args. 8191 instructions can be encoded in each unsafe operation set, instructions from 0 to 7 arguments can have 1000 different instructions each, while 8 args instructions can have 192 different instructions.

Sista defines the following inlined primitives (CallPrimitive iiiiiiii 100jjjjj, n = jjjjjiiiiiiii)
1000	class
1001	pointer numSlots
1002	pointer basicSize
1003	byte8Type format numBytes (includes CompiledMethod)
1004	short16Type format numShorts
1005	word32Type format numWords
1006	doubleWord64Type format numDoubleWords
	
1010	ensure number of bytes available.
1011	fixed-sized new. (objects with 0 to n inst vars)
	
1020 	identityHash (non-immediate, non-Behavior)
1021	identityHash (SmallInteger)
1022	identityHash (Character)
1023	identityHash (SmallFloat64)
1024	identityHash (Behavior, has hash?)

1030 	immediateAsInteger (Character)
1031 	immediateAsInteger (SmallFloat64)
1035 	immediateAsFloat 	(Smallinteger)
	
2000	SmallInteger #+.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2001	SmallInteger #-.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2002	SmallInteger #*.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2003	SmallInteger #/.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2004	SmallInteger #//.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2005	SmallInteger #\\.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2006	SmallInteger #quo:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2011	Variable-sized pointers new (new:). Array, etc.
2012	Variable-sized byte new (new:). ByteArray, ByteString, etc.
2013	Variable-sized 16-bit new (new:). DoubleByteArray, etc.
2014	Variable-sized 32-bit new (new:). Bitmap, FloatArray, etc.
2015	Variable-sized 64-bit new (new:). DoubleWordArray, etc.

2016	SmallInteger #bitAnd:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2017	SmallInteger #bitOr:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2018	SmallInteger #bitXor:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2019	SmallInteger #bitShiftLeft:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2020	SmallInteger #bitShiftRight:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2032	SmallInteger #>.  Both arguments are SmallIntegers
2033	SmallInteger #<.  Both arguments are SmallIntegers
2034	SmallInteger #>=.  Both arguments are SmallIntegers
2035	SmallInteger #<=.  Both arguments are SmallIntegers
2036	SmallInteger #=.  Both arguments are SmallIntegers
2037	SmallInteger #~=.  Both arguments are SmallIntegers

2064	Pointer Object>>at:.				The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
2065	Byte Object>>at:.				The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2066	16-bit Word Object>>at:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2067	32-bit DoubleWord Object>>at:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.
2068	64-bit QuadWord Object>>at:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.

The following instructions can have the ExtB check flag (See (3)).
3000	Pointer Object>>at:put:.			The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
3001	Byte Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 8 bits.
3002	Word Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 16 bits.
3003	DoubleWord Object>>at:put:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 32 bits.
3004	QuadWord Object>>at:put:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 64 bits.
			
3021	Byte Object >> equals:length:	The receiver and the arguments are both byte objects and have both the same size (length). The length argument is a smallinteger. Answers true if all fields are equal, false if not. Comparison is bulked to word comparison.

4000	Pointer Object>> fillFrom:to:with: The receiver is a Pointer object. the middle two arguments are smallintegers. Last argument is any object. Fills the object in between the two indexes with last argument. Receiver is guaranteed to be mutable. The pointer accesses are raw (no inst var check). If ExtB is set to 1, no store check is present. Else a single store check is done for the bulk operation. Answers the receiver.
	
5000	Pointer Object>> replaceFrom:to:with:startingAt: Src and dest are pointer objects. ScrPos, scrLast and destLast are smallintegers. Receiver is guaranteed to be mutable.  Both ranges are in-bounds. The pointer accesses are raw (no inst var check). As for the normal primitive, the copy is linear. Answers the receiver.


Lowcode defines inlined primitives for the range CallPrimitive iiiiiiii 101jjjjj, n = jjjjjiiiiiiii.!
!EncoderForV3PlusClosures commentStamp: 'jmv 9/20/2016 19:42:38' prior: 16857279!
                        I add behaviour to Encoder to size and emit bytecodes for the Squeak V3.x VM bytecode set, a close variant of the original Smalltalk-80 bytecode set defined in the Blue Book.

	0-15 		0000iiii 			Push Receiver Variable #iiii
	16-31 		0001iiii 			Push Temporary Location #iiii
	32-63 		001iiiii 			Push Literal Constant #iiiii
	64-95 		010iiiii 			Push Literal Variable #iiiii
	96-103 		01100iii 			Pop and Store Receiver Variable #iii
	104-111 	01101iii 			Pop and Store Temporary Location #iii
	112-119 	01110iii 			Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]
	120-123 	011110ii 		Return (receiver, true, false, nil) [ii] From Message
	124-125 	0111110i 		Return Stack Top From (Message, Block) [i]
	(126-127 unassigned)
	128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk
	129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	131 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk With jjj Arguments
	132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)
	133 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk To Superclass With jjj Arguments
	134 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk With jjj Arguments
	135 		10000111 		Pop Stack Top
	136 		10001000 		Duplicate Stack Top
	137 		10001001 		Push Active Context
	(138-143 unassigned)
	144-151 	10010iii 			Jump iii + 1 (i.e., 1 through 8)
	152-159 	10011iii 			Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	160-167 	10100iii jjjjjjjj 	Jump(iii - 4) *256+jjjjjjjj
	168-171 	101010ii jjjjjjjj 	Pop and Jump On True ii *256+jjjjjjjj
	172-175 	101011ii jjjjjjjj 	Pop and Jump On False ii *256+jjjjjjjj
	176-191 	1011iiii 			Send Arithmetic Message #iiii
	192-207 	1100iiii 			Send Special Message #iiii
	208-223 	1101iiii 			Send Literal Selector #iiii With No Arguments
	224-239 	1110iiii 			Send Literal Selector #iiii With 1 Argument
	240-255 	1111iiii 			Send Literal Selector #iiii With 2 Arguments

An encoder for the V3 bytecode set augmented with the following bytecodes that are part of the full closure implementation.
	138   10001010 jkkkkkkk		Push (Array new: kkkkkkk) (j = 0)
								or	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)
	139   10001011 kkkkkkkk jjjjjjjj 	Invoke primitive number jjjjjjjjkkkkkkkk
	140   10001100 kkkkkkkk jjjjjjjj 	Push Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
	141   10001101 kkkkkkkk jjjjjjjj 	Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
	142   10001110 kkkkkkkk jjjjjjjj 	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
	143   10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num Args kkkk BlockSize jjjjjjjjiiiiiiii
This is an exact duplicate of EncoderForLongFormV3PlusClosures.
Could be a trait (or in Newspeak, a Mixin).
For now we impose upon you to synchronise any and all changes between these two classes.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7270-ByteEncoderClassCommentFormatting-EliotMiranda-JuanVuletich-2025Jun17-17h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7270] on 17 June 2025 at 5:25:12 pm'!
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 6/17/2025 16:51:19'!
                        nonLocalReturnScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for non-local returns."
	self subclassResponsibility! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'jmv 6/17/2025 16:54:59' overrides: 50333333!
                             nonLocalReturnScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for non-local returns."

	"88-91		010110 ii			Return Receiver/true/false/nil
	 92			01011100			Return top"

	^[ :instr |
		instr between: 88 and: 92 ]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 6/17/2025 16:53:09' overrides: 50333333!
                       nonLocalReturnScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for non-local returns."

	^[ :instr |
		instr between: 120 and: 124 ]! !
!CompiledMethod methodsFor: 'closures' stamp: 'jmv 6/9/2025 17:12:52' prior: 16833983!
            containsBlockClosures

	| scanner |
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		self encoderClass createClosureScanBlock! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:09:09' prior: 16834982!
                           readsField: varIndex 
	"Answer whether the receiver loads the instance variable indexed by the 
	 argument."
	"eem 5/24/2008 Rewritten to no longer assume the compiler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| varIndexCode scanner |
	varIndexCode := varIndex - 1.
	self isReturnField ifTrue: [^self returnField = varIndexCode].
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass instVarReadScanBlockFor: varIndexCode using: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:09:22' prior: 16835007!
             readsRef: literalAssociation 
	"Answer whether the receiver loads the argument."
	"eem 5/24/2008 Rewritten to no longer assume the compler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| litIndex scanner |
	(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:
		[^false].
	litIndex := litIndex - 1.
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass bindingReadScanBlockFor: litIndex using: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:30:36' prior: 16835103!
       sendsToSuper
	"Answer whether the receiver sends any message to super."
	| scanner |
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass superSendScanBlockUsing: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:08:55' prior: 16835114!
                              writesField: varIndex
	"Answer whether the receiver stores into the instance variable indexed
	 by the argument."
	"eem 5/24/2008 Rewritten to no longer assume the compler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| varIndexCode scanner |
	self isQuick ifTrue: [^false].
	varIndexCode := varIndex - 1.
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass instVarWriteScanBlockFor: varIndexCode using: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:10:28' prior: 16835148!
        writesRef: literalAssociation 
	"Answer whether the receiver stores into the argument."
	"eem 5/24/2008 Rewritten to no longer assume the compler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| litIndex scanner |
	(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:
		[^false].
	litIndex := litIndex - 1.
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass bindingWriteScanBlockFor: litIndex using: scanner)! !
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 6/17/2025 16:31:27' prior: 16835666!
                               usesClosureBytecodes
	"Answer whether the receiver was compiled using the closure compiler.
	 This is used to help DebuggerMethodMap choose which mechanisms to
	 use to inspect activations of the receiver.
	In Cuis all the subclasses of BytecodeEncoder #supportsClosures."
	
	^true! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 6/17/2025 16:55:24' prior: 16794105!
              hasNonLocalReturn
	"Answer whether the receiver has a method-return ('^') in its code."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass nonLocalReturnScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 6/17/2025 16:39:58' prior: 16794160!
          sendsToSuper
	"Answer whether the receiver sends any message to super."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass superSendScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !

Decompiler removeSelector: #blockScopeRefersOnlyOnceToTemp:!

!methodRemoval: Decompiler #blockScopeRefersOnlyOnceToTemp: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
blockScopeRefersOnlyOnceToTemp: offset
	| nRefs byteCode extension scanner scan |
	scanner := InstructionStream on: method.
	nRefs := 0.
	scan := offset <= 15
				ifTrue:
					[byteCode := 16 + offset.
					 [:instr |
					  instr = byteCode ifTrue:
						[nRefs := nRefs + 1].
					  nRefs > 1]]
				ifFalse:
					[extension := 64 + offset.
					 [:instr |
					  (instr = 128 and: [scanner followingByte = extension]) ifTrue:
						[nRefs := nRefs + 1].
					   nRefs > 1]].
	self scanBlockScopeFor: pc from: method initialPC to: method endPC with: scan scanner: scanner.
	^nRefs = 1!

CompiledMethod removeSelector: #scanLongStore:!

!methodRemoval: CompiledMethod #scanLongStore: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
scanLongStore: extension 
	"Answer whether the receiver contains a long store whose extension is 
	the argument."
	| scanner |
	scanner := InstructionStream on: self.
	^scanner scanFor: 
		[:instr |  (instr = 129 or: [instr = 130]) and: [scanner followingByte = extension]]!

CompiledMethod removeSelector: #writesFieldCode:with:using:!

!methodRemoval: CompiledMethod #writesFieldCode:with:using: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
writesFieldCode: varIndexCode with: byteCode using: scanner 

	^byteCode >= 96
		and: [byteCode <= 103
			ifTrue: [byteCode - 96 = varIndexCode]
			ifFalse:
				[(byteCode = 129 or: [byteCode = 130])
					ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]
					ifFalse:
						[byteCode = 132
						 and: [(scanner followingByte between: 160 and: 223)
						 and: [scanner thirdByte = varIndexCode]]]]]
!

CompiledMethod removeSelector: #scanVeryLongStore:offset:!

!methodRemoval: CompiledMethod #scanVeryLongStore:offset: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
scanVeryLongStore: extension offset: offset
	"Answer whether the receiver contains a long load with the given offset.
	Note that the constant +32 is the known difference between a
	store and a storePop for instVars, and it will always fail on literal variables,
	but these only use store (followed by pop) anyway."
	| scanner |
	scanner := InstructionStream on: self.
	^scanner scanFor:
		[:instr | | ext |
		(instr = 132 and: [(ext := scanner followingByte) = extension
											or: ["might be a store/pop into rcvr"
												ext = (extension+32)]])
		and: [scanner thirdByte = offset]]!

CompiledMethod removeSelector: #scanLongLoad:!

!methodRemoval: CompiledMethod #scanLongLoad: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
scanLongLoad: extension 
	"Answer whether the receiver contains a long load whose extension is the
	argument."

	| scanner |
	scanner := InstructionStream on: self.
	^scanner scanFor: [:instr | instr = 128 and: [scanner followingByte = extension]]!

CompiledMethod removeSelector: #scanVeryLongLoad:offset:!

!methodRemoval: CompiledMethod #scanVeryLongLoad:offset: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
scanVeryLongLoad: extension offset: offset
	"Answer whether the receiver contains a long load whose extension is the 
	argument."
	| scanner |
	scanner := InstructionStream on: self.
	^ scanner scanFor: [:instr | (instr = 132 and: [scanner followingByte = extension])
											and: [scanner thirdByte = offset]]!

EncoderForV3PlusClosures class removeSelector: #method:readsField:!

!methodRemoval: EncoderForV3PlusClosures class #method:readsField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
method: method readsField: varIndex
	"Answer if method loads the instance variable indexed by varIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available.
	0-15 		0000iiii 	Push Receiver Variable #iiii
	128 		10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk
	132 		10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)"
	| varIndexCode scanner |
	varIndexCode := varIndex - 1.
	method isReturnField ifTrue:
		[^method returnField = varIndexCode].
	^(scanner := InstructionStream on: method) scanFor:
		[:b|
		b < 16
			ifTrue: [b = varIndexCode]
			ifFalse:
				[b = 128
					ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]
					ifFalse:
						[b = 132
						 and: [(scanner followingByte between: 64 and: 95)
						 and: [scanner thirdByte = varIndexCode]]]]]!

EncoderForV3PlusClosures class removeSelector: #method:writesField:!

!methodRemoval: EncoderForV3PlusClosures class #method:writesField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
method: method writesField: varIndex
	"Answer if method stores into the instance variable indexed by varIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available.
	96-103 	01100iii 	Pop and Store Receiver Variable #iii
	129 		10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	130 		10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	132 		10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)"
	| varIndexCode scanner |
	method isQuick ifTrue: [^false].
	varIndexCode := varIndex - 1.
	^(scanner := InstructionStream on: method) scanFor:
		[:b|
		b >= 96
		and: [b <= 103
				ifTrue: [b - 96 = varIndexCode]
				ifFalse:
					[(b = 129 or: [b = 130])
						ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]
						ifFalse:
							[b = 132
							 and: [(scanner followingByte between: 160 and: 223)
							 and: [scanner thirdByte = varIndexCode]]]]]]!

BytecodeEncoder class removeSelector: #method:readsField:!

!methodRemoval: BytecodeEncoder class #method:readsField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
method: method readsField: varIndex
	"Answer if method loads the instance variable indexed by varIndex."
	^self subclassResponsibility!

BytecodeEncoder class removeSelector: #method:writesField:!

!methodRemoval: BytecodeEncoder class #method:writesField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:25'!
method: method writesField: varIndex
	"Answer if method stores into the instance variable indexed by varIndex."
	^self subclassResponsibility!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7271] on 17 June 2025 at 5:54:08 pm'!

SystemDictionary removeSelector: #browseEqSmallConstant!

!methodRemoval: SystemDictionary #browseEqSmallConstant stamp: 'Install-7272-Cleanup-JuanVuletich-2025Jun17-17h53m-jmv.001.cs.st 7/15/2025 11:02:25'!
browseEqSmallConstant

    "Dan Ingalls' search for arithmetic use of ==
Answer whether the receiver contains the pattern <expression> == <constant>,
where constant is -1, 0, 1, or 2...
	Smalltalk browseEqSmallConstant
"

	self browseAllSelect: [:m | m scanForEqSmallConstant]!

CompiledMethod removeSelector: #scanForEqSmallConstant!

!methodRemoval: CompiledMethod #scanForEqSmallConstant stamp: 'Install-7272-Cleanup-JuanVuletich-2025Jun17-17h53m-jmv.001.cs.st 7/15/2025 11:02:25'!
scanForEqSmallConstant

    "Dan Ingalls' search for arithmetic use of ==
Answer whether the receiver contains the pattern <expression> == <constant>,
where constant is -1, 0, 1, or 2...
	Smalltalk browseAllSelect: [:m | m scanForEqSmallConstant]
"



    | scanner |

    scanner := InstructionStream on: self.

    ^ scanner scanFor: [:instr | (instr between: 116 and: 119) and: [scanner followingByte = 198]]



"

Smalltalk browseAllSelect: [:m | m scanForEqSmallConstant]

"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7272-Cleanup-JuanVuletich-2025Jun17-17h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 5:05:03 pm'!
!Object methodsFor: 'user interface' stamp: 'jmv 6/17/2025 17:57:51' prior: 50332494!
                   request: queryString do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: '' verifying: [:aString| true] do: acceptBlock orCancel: nil! !
!Object methodsFor: 'user interface' stamp: 'jmv 6/17/2025 17:56:49' prior: 16923476!
      request: queryString initialAnswer: defaultAnswer do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: defaultAnswer verifying: [:aString| true] do: acceptBlock orCancel: nil! !
!Object methodsFor: 'user interface' stamp: 'jmv 6/17/2025 17:58:27' prior: 16923522!
                              request: queryString initialAnswer: defaultAnswer verifying: validationBlock do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: defaultAnswer verifying: validationBlock do: acceptBlock orCancel: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7273-RemoveEmptyClosures-JuanVuletich-2025Jun18-16h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 5:36:01 pm'!
!Parser methodsFor: 'expression types' stamp: 'jmv 6/17/2025 18:01:15' prior: 16928464!
    variable
	
	^self advanceWithRangeDo: [ :variableName :range | | varName result rightRange |
		varName := variableName.
		
		"See ParserTest>>#testRangesAreOkWhenReturningAVariableWithoutSpaceAfterThat
		There is a very difficult bug to fix. It happends when the source code ends with a return of a variable of 
		one char an no other char after that, for example: '^a' 
		In that case the range includes the ^ that is incorrect and makes the rename temporary fail.
		I do this fix becuase changing how the range is calculated is almost imposible due to the coupling 
		and complexity of the parser. This change applies only to variables and therefore it assures no
		unexpected behavior. I'm not cheching for size = 1 because it is redundant - Hernan"
		rightRange := varName size = range size
			ifTrue: [ range ]
			ifFalse: [ range last - varName size + 1 to: range last ].
		
		[result := encoder encodeVariable: varName sourceRange: rightRange ifUnknown: nil.
		result ifNil: [
			result := (UndeclaredVariableReference new)
				parser: self;
				varName: varName;
				varStart: rightRange first;
				varEnd: rightRange last;
				signal ].
		result isString ] whileTrue: [ varName := result].
		encoder addMultiRange: rightRange for: result ].
	! !
!Parser methodsFor: 'error correction' stamp: 'jmv 6/17/2025 18:00:35' prior: 16928713!
 declarationRangesForTemps: someTempNodes
	
	^someTempNodes collect: [ :temporaryNode | 
		(encoder rangeForNode: temporaryNode ifAbsent: nil) first ].! !
!Encoder methodsFor: 'results' stamp: 'jmv 6/17/2025 18:02:03' prior: 16853947!
                      associationForClass
	| assoc |
	assoc := Smalltalk associationAt: class name ifAbsent: nil.
	^assoc value == class
		ifTrue: [ assoc ]
		ifFalse: [ Association new value: class ]! !
!Encoder methodsFor: 'temps' stamp: 'eem 12/1/2008 12:07' prior: 16854156!
                               fixTemp: name
	| node |
	node := scopeTable at: name ifAbsent: nil.
	node class ~~ TempVariableNode ifTrue:
		[self error: 'can only fix a floating temp var'].
	node index: nTemps.
	nTemps := nTemps + 1.
	^node! !
!Encoder methodsFor: 'temps' stamp: 'eem 7/13/2007 14:13' prior: 16854165!
                               floatTemp: node
	(node ~~ (scopeTable at: node name ifAbsent: nil)
	or: [node class ~~ TempVariableNode
	or: [node code ~= (node code: nTemps - 1 type: LdTempType)]]) ifTrue:
		[self error: 'can only float the last allocated temp var'].
	nTemps := nTemps - 1! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'jmv 6/17/2025 18:51:01' prior: 16847818!
                        codeMethod: selector block: block tempVars: vars primitive: primitive class: class

	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries properties |
	selectorNode := self codeSelector: selector code: nil.
	tempVars := vars.
	visibleTemps := OrderedCollection new.
	invisibleTemps := OrderedCollection new.
	tempVars do: [:t|
				   ((t isIndirectTempVector or: [t scope >= 0])
						ifTrue: [visibleTemps]
						ifFalse: [invisibleTemps]) addLast: t].
	arguments := visibleTemps copyFrom: 1 to: nArgs.
	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.
	block
		arguments: arguments;
		temporaries: temporaries.
	properties := method properties copy.
	(properties at: #onceCache ifAbsent: nil) ifNotNil:
		[:onceCache|
		 properties := properties copyWithout: (Association
													key: #onceCache
													value: onceCache)].
	blockNode := MethodNode new
		selector: selectorNode
		arguments: arguments
		precedence: selector precedence
		temporaries: temporaries
		block: block
		encoder: (method encoderClass new initScopeAndLiteralTables
					temps: visibleTemps, invisibleTemps
					literals: literalValues
					class: class)
		primitive: primitive
		properties: properties.
	blockNode properties method: blockNode.
	^blockNode! !
!TemporaryVariableDeclarationRemover methodsFor: 'source text generation' stamp: 'EB 5/28/2019 21:22:07' prior: 16984224!
                             sourceTextWithoutTemporaryDeclaration

	| temporaryVariablePositions variableDeclarationPosition | 

	temporaryVariablePositions := methodNode positionsForTemporaryVariable: temporaryVariable ifAbsent: nil.
	variableDeclarationPosition := {temporaryVariablePositions first}.
	^methodNode sourceText copyReplacing: variableDeclarationPosition with: ''! !
!FontFamily class methodsFor: 'accessing fonts' stamp: 'jmv 6/17/2025 18:51:13' prior: 16872535!
                             familyNamed: aString
	"
	FontFamily familyNamed: FontFamily defaultFamilyName
	"
	^AvailableFamilies at: aString ifAbsent: nil.! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 6/17/2025 18:51:21' prior: 16817562!
 mutateInstances: oldClass to: newClass
	"Mutate the old class and subclasses into newClass and subclasses.
	Note: This method is slightly different from: #mutate:toSuper: since
	here we are at the root of reshaping and have two distinct roots."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do: [ :oldSubclass | | newSubclass |
		newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ]. 
		self mutateInstances: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do: [ :oldSubclass | | newSubclass |
		oldSubclass ifNotNil: [
			newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ] ifNone: nil.
			newSubclass ifNotNil: [
				self mutateInstances: oldSubclass to: newSubclass ].
		].
	].
	self update: oldClass to: newClass.
	^newClass! !
!CodeProvider methodsFor: 'categories' stamp: 'jmv 6/17/2025 18:03:13' prior: 16826164!
               categoryFromUserWithPrompt: aPrompt for: aClass
	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"

	^(MethodCategoriesPrompter 
		staringFrom: aClass 
		rejectingFirst: false) prompt: aPrompt ifNone: nil! !
!Browser methodsFor: 'class list' stamp: 'jmv 6/17/2025 18:03:34' prior: 16798247!
        classListIndex: anInteger
	"Set anInteger to be the index of the current class selection."

	| className recent canSelectClass classList prevSelectedClassName prevSelectedMessage |
	classList := self classList.
	canSelectClass := classList isInBounds: anInteger.
	prevSelectedClassName := selectedClassName.
	selectedClassName := canSelectClass ifTrue: [
		| newClassName |
		newClassName := classList at: anInteger ifAbsent: nil.
		newClassName := newClassName ifNotNil: [newClassName withoutLeadingBlanks asSymbol].
		newClassName ].
	self setClassOrganizer.
	prevSelectedMessage := selectedMessage.
	selectedMessage := nil.

	self classCommentIndicated ifFalse: [
		self editSelection: (canSelectClass
			ifTrue: [#editClass]
			ifFalse: [ metaClassIndicated | selectedSystemCategory isNil
				ifTrue: [#none]
				ifFalse: [#newClass]])].

	self selectedClass ifNotNil: [
		recent := self class recentClasses.
		className := self selectedClass name.
		(recent includes: className) ifTrue: [recent remove: className].
		recent addFirst: className.
		recent size > 16 ifTrue: [recent removeLast]].

	"Clear selectedMessageCategory if there is no match in the new list of categories"
	(self messageCategoryList indexOf: selectedMessageCategory) = 0 ifTrue: [
		selectedMessageCategory := nil].

	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged.
	prevSelectedClassName = selectedClassName ifFalse: [
		"If clicked on already selected class, deselect selector, so class definition is shown"
		self setSelector: prevSelectedMessage ].! !
!Debugger methodsFor: 'code pane' stamp: 'jmv 6/17/2025 18:07:09' prior: 16844244 overrides: 16992950!
                   contentsSelection

	"If we are just creating the method in the debugger, help the user by selecting the method body."
	| sendInterval |
	currentCompiledMethod ifNotNil: [
		((currentCompiledMethod hasLiteral: #shouldBeImplemented) and: [
			(currentCompiledMethod abstractPCForConcretePC: self selectedContext pc) = 1]) ifTrue: [
				sendInterval := (self selectedContext debuggerMap abstractSourceMap at: 2 ifAbsent: nil).
				sendInterval ifNotNil: [ ^ sendInterval first - 5 to: sendInterval last + 1 ]]].

	^self pcRange! !
!Color methodsFor: 'other' stamp: 'jmv 6/17/2025 18:07:16' prior: 16830184!
    colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color.
	Return nil if named color support is not present"

	Color classPool 
		at: #ColorNamesDict
		ifPresent: [ :dict | ^dict keyAtValue: self ifAbsent: nil].
	^nil! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/17/2025 18:51:50' prior: 50331741!
     removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses."

	ObsoleteSubclasses ifNil: [
		^ self ].
	ObsoleteSubclasses remove: aClass ifAbsent: nil.! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'jmv 6/17/2025 18:04:18' prior: 16965459!
  trimToMatchExpressionOn: aSourceCode

	| initialChar endingChar |
	
	initialChar := aSourceCode at: start ifAbsent: nil.
	endingChar := aSourceCode at: stop ifAbsent: nil.
	
	^(initialChar == $( and: [ endingChar == $) ])
		ifTrue: [ self trimParentesisOn: aSourceCode ]
		ifFalse: [ self trimNoParentesisStartingWith: initialChar endingWith: endingChar on: aSourceCode]! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835857!
   installPrimaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header >= 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: nil) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	PrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835878!
                               installSecondaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header < 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: nil) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	SecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!CompiledMethod class methodsFor: 'source code management aux' stamp: 'jmv 6/17/2025 18:09:13' prior: 16836398!
                   overridenMethodReferenceFrom: tokens

	^ self field: #overrides: from: tokens ifAbsentOrNil: nil! !
!CompiledMethod class methodsFor: 'source code management aux' stamp: 'jmv 6/17/2025 18:09:18' prior: 16836405!
            priorReferenceFrom: tokens

	^ self field: #prior: from: tokens ifAbsentOrNil: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7274-RemoveEmptyClosures-JuanVuletich-2025Jun18-17h05m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 5:40:40 pm'!
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 6/17/2025 18:53:13' prior: 16975856!
           recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active processor (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	newArray at: 25 put: nil. "This is nil in Spur, which has immediate Characters."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "This is nil in Spur, no compact classes."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization.
	In Squeak these are: DoubleByteArray, WordArray, DoubleWordArray.
	Understand why."
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.
	newArray at: 36 put: nil. "was the prototype MethodContext"
	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: nil).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: nil).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: nil).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: nil).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: nil).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: nil).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: nil).

	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: nil).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray.! !
!SystemDictionary methodsFor: 'query' stamp: 'jmv 6/17/2025 18:52:17' prior: 16977919!
                      methodsWithUnboundGlobals
	"Get all methods that use undeclared global objects that are not listed in Undeclared. For a clean image the result should be empty."
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty
	"
	^ self allSelect: [ :m |
		m literals anySatisfy: [ :l |
			l isVariableBinding and: [
				l key isSymbol and: [
					"avoid class-side methodClass literals"
					(m methodClass bindingOf: l key)
						ifNil: [
							(Undeclared
								associationAt: l key
								ifAbsent: nil) ~~ l ]
						ifNotNil: [ :b |
							b ~~ l ]]]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7275-RemoveEmptyClosures-JuanVuletich-2025Jun18-17h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 6:03:40 pm'!
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'eem 12/18/2024 11:55:20' prior: 16860127!
       finalizeEphemeron: anEphemeron

	"Remove the ephemeron from myself.  Note that no finalization of the ephemeron's key is done.
	 Here we are using ephemerons to clean up property tables."

	mutex critical:
		[self removeKey: anEphemeron key ifAbsent: nil]! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'eem 1/20/2025 17:02:57' prior: 16869046 overrides: 50334398!
       finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the ephemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: nil.
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron value ifNil: [anEphemeron key]) finalize! !
!UndeclaredVariable methodsFor: 'exception handling' stamp: 'jmv 6/17/2025 18:10:17' prior: 17000284 overrides: 16919632!
                            defaultAction
	
	| labels actions lines caption choice icons |
	
	labels := OrderedCollection new.
	actions := OrderedCollection new.
	lines := OrderedCollection new.
	icons := OrderedCollection new.
	
	self createMenuOptionsAddingTo: labels actions: actions icons: icons lines: lines.
	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.
	choice := (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	
	self resume: (actions at: choice ifAbsent: nil).! !
!UnknownSelector methodsFor: 'exception handling' stamp: 'jmv 6/17/2025 18:04:32' prior: 17004612 overrides: 16919632!
          defaultAction 

	| alternatives labels lines caption choice icons |

	alternatives := Symbol possibleSelectorsFor: name.
	labels := Array streamContents: [:s | s nextPut: name; nextPutAll: alternatives; nextPut: 'cancel'].
	lines := {1. alternatives size + 1}.
	icons := Array new: labels size.
	icons at: 1 put: #acceptIcon.
	icons at: icons size put: #cancelIcon.
	caption := 'Unknown selector, please\confirm, correct, or cancel' withNewLines.
	
	choice := (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	choice = 1 ifTrue: [self resume: name asSymbol].
	choice = labels size ifTrue: [self resume: nil].
	self resume: (alternatives at: choice - 1 ifAbsent: nil)! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'jmv 6/17/2025 18:53:42' prior: 16847082!
                             pushReceiverVariable: offset

	| var |
	(var := instVars at: offset + 1 ifAbsent: nil) == nil
		ifTrue:
			["Not set up yet"
			var := constructor codeInst: offset.
			instVars size < (offset + 1) ifTrue: [
				instVars := (Array new: offset + 1)
					replaceFrom: 1 to: instVars size with: instVars; yourself ].
			instVars at: offset + 1 put: var].
	stack addLast: var! !
!Decompiler methodsFor: 'private' stamp: 'eem 4/25/2017 16:07' prior: 16847375!
                          markTemp: tempVarNode asOutOfScope: scopeFlag
	tempVarNode scope: scopeFlag.
	tempReadCounts removeKey: tempVarNode ifAbsent: nil! !
!Process methodsFor: 'changing process state' stamp: 'jar 8/15/2022 12:48:39' prior: 16937170!
                            suspendAndUnblock
	"ar 12/7/2007 17:10:
	 Primitive. Stop the process that the receiver represents in such a way 
	 that it can be restarted at a later time (by sending the receiver the 
	 message resume). If the receiver represents the activeProcess, suspend it. 
	 Otherwise remove the receiver from the list of waiting processes.
	 The return value of this method is the list the receiver was previously on (if any)."

	<primitive: 88 error: ec>
	"ar 12/7/2007 17:10:
	 This is fallback code for VMs which only support the old primitiveSuspend which 
	 would not accept processes that are waiting to be run."
	 ^myList ifNotNil: "this allows us to use suspend multiple times"
		[:oldList|
		 myList := nil.
		 oldList remove: self ifAbsent: nil.
		 oldList]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'KLG 9/19/2022 10:42:35' prior: 16912809!
       balloonText
	"Answer balloon help text or nil, if no help is available.
	NB: subclasses may override such that they programatically
	construct the text, for economy's sake, such as model phrases in
	a Viewer.
	Allow for dynamic balloon text."

	^ (self valueOfProperty: #balloonText ifAbsent: nil) value.! !
!FindInSourceDialog methodsFor: 'scopes list' stamp: 'jmv 6/17/2025 18:56:03' prior: 16869228!
             scopesList
	| scopeClassName labelList |
	labelList := {
		'This method or text'.
		'All methods in image'. } asOrderedCollection.
	smalltalkEditor selectedClass ifNotNil:
		[ :scopeClass |
			scopeClassName := scopeClass name asString.
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := smalltalkEditor selectedMethod
				ifNotNil: [ :scopeMethod |CodePackage packageOfMethod: scopeMethod ifNone: nil]
				ifNil: [CodePackage packageOfClass: scopeClass ifNone: nil].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
	^labelList! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/17/2025 18:57:38' prior: 16896876!
                   layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.
	
	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ].

	self layoutNeeded: false.! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 6/18/2025 17:49:26' prior: 16969517 overrides: 50333788!
        request: queryString initialAnswer: defaultAnswer do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	
	^ self
		request: queryString
		centeredAt: self runningWorld activeHand morphPosition
		initialAnswer: defaultAnswer
		validationBlock: [:aString| true]
		acceptBlock: acceptBlock
		cancelBlock: nil! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 6/17/2025 18:57:50' prior: 16969559 overrides: 16923512!
                              request: queryString initialAnswer: defaultAnswer verifying: validationBlock
	"Modal. This method returns when an answer is provided."

	^self request: queryString initialAnswer: defaultAnswer verifying: validationBlock orCancel: nil! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 12:54:46' prior: 16931473 overrides: 16911047!
                          acceptDroppingMorph: aMorph event: dropEvent
	| localPosition row dropSelectorArgument dropActionSelector args |
	localPosition := self internalizeFromWorld: dropEvent eventPosition.
	row := self rowAtLocation: localPosition ifNone: nil.
	dropSelectorArgument := aMorph
		valueOfProperty: #dropSelectorArgument
		ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
	dropActionSelector := self valueOfProperty: #dropActionSelector.
	args := dropActionSelector numArgs.
	args = 1 ifTrue: [ ^model perform: dropActionSelector with: dropSelectorArgument ].
	args = 2 ifTrue: [ ^model perform: dropActionSelector with: row with: dropSelectorArgument ].
	self error: 'dropActionSelector must be a 1- or 2-keyword symbol'! !
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 6/17/2025 18:56:15' prior: 16931739 overrides: 16911789!
  processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	scroller highlightedRow: (
		(self viewableArea containsPoint: localEventPosition) ifTrue: [
			self rowAtLocation: localEventPosition ifNone: nil]).
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'jpb 8/16/2019 17:34:29' prior: 16931875!
       deleteAction
	"Handles deleting action, which happens when the user presses backspace or delete key within me"
	| deleteActionBlock |
	deleteActionBlock := self valueOfProperty: #deleteAction ifAbsent: nil.
	deleteActionBlock isNil
		ifTrue: [ self flash ]
		ifFalse: [ deleteActionBlock value ].
	^self! !
!PluggableListMorphByItem methodsFor: 'model access' stamp: 'jmv 6/17/2025 18:06:07' prior: 16932302 overrides: 16932047!
                   setSelectionIndex: anInteger
	"Change the model's selected item to be the one at the given index."

	| item |
	setIndexSelector ifNotNil: [
		item := itemList at: anInteger ifAbsent: nil.
		model perform: setIndexSelector with: item.
		self privateVisualSelectionIndex: self getCurrentSelectionIndex.
		^ true ].
	^false
	! !
!BrowserWindow class methodsFor: 'services' stamp: 'jmv 6/17/2025 18:11:29' prior: 16800812!
                             findClassFrom: potentialClassNames ifFound: aBlock with: pattern

	| exactMatch foundClass index  classNames toMatch |
	pattern isEmpty ifTrue: [^self flash].

	"If the user entered an exact class name (including case), just use it."
	(potentialClassNames includes: pattern) ifTrue: [
		foundClass := Smalltalk at: pattern asSymbol.
		aBlock value: foundClass.
		^self ].

	toMatch := (pattern copyWithout: $.) asLowercase withBlanksTrimmed.
	classNames := self classNamesFrom: potentialClassNames with: pattern matching: toMatch.
	classNames isEmpty ifTrue: [^self flash].

	exactMatch := classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.
	index := self indexOfClassFrom: classNames exactMatch: exactMatch.
	index = 0 ifTrue: [^self flash].

	foundClass := Smalltalk at: (classNames at: index) asSymbol.
	aBlock value: foundClass.! !
!BrowserWindow class methodsFor: 'services' stamp: 'jmv 6/17/2025 18:54:10' prior: 16800842!
            indexOfClassFrom: classNames exactMatch: exactMatch

	| options |
	
	classNames size = 1 ifTrue: [ ^1 ].
	
	options := exactMatch
		ifNil: [ PopUpMenu labelArray: classNames lines: #()]
		ifNotNil: [
			classNames remove: exactMatch ifAbsent: nil.
			classNames addFirst: exactMatch.
			PopUpMenu labelArray: classNames lines: #(1)].
		
	^options startUpMenu! !
!WorldMorph methodsFor: 'stepping' stamp: 'jmv 6/17/2025 18:54:16' prior: 17018655!
  runLocalStepMethods: nowTime
	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world."

	| timerBefore timerAfter stepMessage |
	timerAfter := nowTime.
	[ stepList notEmpty and: [ (stepMessage := stepList first) scheduledTime <= nowTime ]] 
		whileTrue: [
			(stepMessage receiver shouldGetStepsFrom: self)
				ifFalse: [
					stepList remove: stepMessage ifAbsent: nil]
				ifTrue: [
					timerBefore := timerAfter.
					stepMessage valueAtTime: nowTime.
					timerAfter := Time localMillisecondClock.
					"No step message should take more than 50% CPU. 
					Reschedule it only after its required time is elapsed again."
					stepMessage rescheduleAfter: timerAfter + (timerAfter - timerBefore).
					"We've just updated the  scheduled time for stepMessage.
					It might have been that stepMessage was removed altogether from stepList.
					It also may be the case that stepList got added or removed other elements while on #valueAtTime:
					Just reSort. It will be ok in any case."
					stepList reSort ]].! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 6/18/2025 17:51:35' prior: 16886455!
                               rowAtLocation: aPoint ifNone: aNoneBlock

	| potentialRowNumber |
	
	potentialRowNumber := aPoint y // font lineSpacing + 1.
	
	^(listItems isInBounds: potentialRowNumber) 
		ifTrue: [ potentialRowNumber ]
		ifFalse: [ aNoneBlock value ]! !
!HandMorph methodsFor: 'private' stamp: 'jmv 6/17/2025 18:58:02' prior: 16878976!
                             forgetGrabMorphDataFor: aMorph

	grabMorphData 
		removeKey: aMorph 
		ifAbsent: nil "no error"! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'jmv 6/17/2025 18:54:21' prior: 16852776!
                       addSubMenuTo: aMenuItem

	subMenuItemsDefinition 
		at: aMenuItem contents
		ifPresent: [ :subMenuDefinition | self addSubMenuTo: aMenuItem from: subMenuDefinition ]
		ifAbsent: nil! !
!FileIOAccessor methodsFor: 'actions' stamp: 'pb 5/25/2016 00:32' prior: 16866231!
                    deleteFile: fullPathName
	^self deleteFile: fullPathName ifAbsent: nil! !
!DirectoryEntry methodsFor: 'dictionary-like' stamp: 'pb 5/25/2016 00:31' prior: 16850204!
                           removeKey: localFileName 
	self removeKey: localFileName ifAbsent: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7276-RemoveEmptyClosures-JuanVuletich-2025Jun18-17h40m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 6:17:39 pm'!
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 6/18/2025 18:16:54' prior: 16820671!
                    withSubclassesThatDefineInstanceVariable: aName do: foundBlock ifNone: noneBlock

	| definingSubclasses |

	definingSubclasses := self allSubclasses select: [ :aSubclass |
		aSubclass definesInstanceVariableNamed: aName ].

	^definingSubclasses isEmpty
		ifTrue: [ noneBlock value ]
		ifFalse: [ foundBlock value: definingSubclasses ]! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 6/17/2025 18:58:06' prior: 16961690!
                       debugIt

	self lineSelectAndEmptyCheck: [^self].
	self 
		afterCompiling: self selection string
		do: [ :compiler :method :receiver :context |
			(method notNil and: [method isQuick not]) ifTrue: [
				self debug: method receiver: receiver in: context ]]
		ifFail: nil.! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 6/17/2025 18:54:38' prior: 16961847!
                        selectNodeUnderCursorForInspectionIn: aMethodNode 
	
	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self selectForInspection: nodeUnderCursor in: aMethodNode ]
		ifAbsent: nil! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 6/17/2025 18:56:27' prior: 16963475!
     findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |

	true ifTrue: [
		^FindInSourceDialog openOn: self ].

	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingExistingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: nil]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: nil].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !
!MethodCategoriesPrompter methodsFor: 'categories initialization - private' stamp: 'jmv 6/17/2025 18:54:45' prior: 16905406!
                      initializeCategoriesWhenMeta: classCategories

	categories add: Categorizer instanceCreation.
	classCategories remove: Categorizer instanceCreation ifAbsent: nil.
	reject add: Categorizer instanceCreation! !
!TrieNode methodsFor: 'private' stamp: 'jmv 6/17/2025 18:56:33' prior: 16999278!
                               removeChildFor: aString characterIndex: i
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."
	| nextSegmentStart nextSegmentFirst |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		childrenFirstChars = nextSegmentFirst
			ifTrue: [ childrenFirstChars := nil. children := nil ].
		^self ].
	
	"Already more than one child."
	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found |
			childrenFirstChars size = 2
				ifTrue: [		"Two children: remove the arrays"
					childrenFirstChars := childrenFirstChars at: 3-found.
					children := children at: 3-found ]
				ifFalse: [	"More than two children. condense the arrays"
					childrenFirstChars := (childrenFirstChars copyFrom: 1 to: found-1), 
						(childrenFirstChars copyFrom: found+1 to: childrenFirstChars size).
					children := (children copyFrom: 1 to: found-1), (children copyFrom: found+1 to: children size) ]]
		ifNone: nil.! !
!MethodReference methodsFor: 'queries' stamp: 'jmv 6/17/2025 18:06:28' prior: 16907931!
       actualClass 

	^self actualClassIfAbsent: nil! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 6/17/2025 18:07:22' prior: 16807753!
                      noteRenameClass: class as: newName 
	"Include indication that a class has been renamed."

	| recorder |
	(recorder := self changeRecorderFor: class)
		noteChangeType: #rename;
		noteNewName: newName asSymbol.
		
	"store under new name (metaclass too)"
	changeRecords at: newName put: recorder.
	changeRecords removeKey: class name.
	self noteClassStructure: class.

	recorder := changeRecords at: class class name ifAbsent: nil.
	recorder ifNotNil: [
		changeRecords at: (newName, ' class') put: recorder.
		changeRecords removeKey: class class name.
		recorder noteNewName: newName , ' class' ].

	self hasUnsavedChanges: true! !
!PopUpMenu methodsFor: 'accessing' stamp: 'jmv 6/17/2025 18:06:34' prior: 16934515!
                     iconAt: aPosition

	^icons at: aPosition ifAbsent: nil! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'jmv 6/17/2025 18:56:40' prior: 16864458!
                          positionToInsertNewTemporaryVariableAssignment

	| siblings |
	
	siblings := self siblingStatementsOfTemporaryAssignment.
	siblings do: [ :sibling |
		(completeSourceRanges at: sibling) 
			detect: [ :range | range includesAllOf: intervalToExtract ]
			ifFound: [ :range | ^range first ]
			ifNone: nil].
		
	self shouldNotHappenBecause: 'sibling should be part of completeSourceRanges'! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 18:20:30' prior: 16885818!
      selectCompleteRangesOfAssignmentsToTemporaryFrom: aParseNode thatMatch: aConditionBlock

	| assignments |

	assignments := Set new.
	aParseNode nodesDo: [:aNode |
		(self nodeIsAssignmentToTemporaryToInline: aNode)
			ifTrue: [
				| nodeRanges satisfyingRanges |
				nodeRanges := methodNode completeSourceRanges at: aNode ifAbsent: nil.
				satisfyingRanges := (nodeRanges select: aConditionBlock)
					collect:[:range | range asSourceCodeInterval
						expandUntilStartOfNextStatementOn: methodNode sourceText].
				assignments addAll: (satisfyingRanges)]
	].

	^assignments






! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:11:50' prior: 16953758!
   addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor

	| potentialImplementor |

	"Phil B. requested to avoid refactoring OMeta2 classes, so right now
	it avoids implementors and senders whose compilerClass is not register
	as allowed compiler - Hernan"
	(self canRefactor: aPotentialClassToRefactor) ifFalse: [ ^self ].

	potentialImplementor := aPotentialClassToRefactor compiledMethodAt: anOldSelector ifAbsent: nil.
	potentialImplementor ifNotNil: [ implementors add: potentialImplementor ].

	(aPotentialClassToRefactor whichSelectorsReferTo: anOldSelector) do: [ :aSelector |
		self addTo: senders referencesTo: anOldSelector from: aSelector in: aPotentialClassToRefactor ]! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'jmv 6/17/2025 18:56:46' prior: 16807137!
               warnIfImplementionsOf: aNewSelector overridesImplementationInSuperclassesOf: implementorsCollection

	implementorsCollection do: [:anImplementor |
		anImplementor methodClass
			withSuperclassThatIncludesSelector: aNewSelector
			do: [ :aSuperclass | self warnImplementionOf: aNewSelector in: anImplementor methodClass willOverrideImplementationIn: aSuperclass ]
			ifNone: nil]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'jmv 6/17/2025 18:50:11' prior: 16780204!
assertNewParameterValueCompiles: trimmedNewParameterValue

	^ [ Parser new parse: trimmedNewParameterValue readStream class: self noPattern: true notifying: nil ifFail: nil ]
		on: SyntaxErrorNotification 
		do: [ :error | self signalNewParameterValueDoesNotCompile ].! !
!AddParameter class methodsFor: 'exceptions' stamp: 'jmv 6/17/2025 18:11:39' prior: 16780261!
                  classesDefiningInstanceVariable: aName inAny: implementors
 
	^ implementors 
		inject: Set new
		into: [ :classesDefiningInstVar :implementor | 
			(implementor methodClass whichClassDefinesInstanceVariable: aName ifNone: nil) ifNotNil: [ :classDefiningInstVar |
				classesDefiningInstVar add: classDefiningInstVar ].
			classesDefiningInstVar ]
! !
!TransferMethod class methodsFor: 'warnings' stamp: 'jmv 6/17/2025 18:54:58' prior: 16998595!
  warnIfMethodIsImplementedInSuperClass: aMethodToTransfer

	aMethodToTransfer methodClass superclass
		compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superclassMethod | (self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superclassMethod)
			ifFalse: [ self refactoringWarning: self methodImplementedInSuperclassWarningMessage ]]
		ifAbsent: nil! !
!RefactoringApplier class methodsFor: 'appliers - private' stamp: 'jmv 6/17/2025 18:55:03' prior: 16945033!
                           resetApplierAt: anApplierId

	Appliers removeKey: anApplierId ifAbsent: nil! !
!NewInstanceVariablePrecondition methodsFor: 'pre-conditions' stamp: 'jmv 6/17/2025 18:58:12' prior: 16918863!
  assertIsNotAlreadyDefined
	
	^ classToAddInstVar 
		withClassesThatDefineInHierarchyInstanceVariable: instVarName 
		do: [ :definingClasses | self signalAlreadyDefinedInAll: definingClasses ]
		ifNone: nil.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7277-RemoveEmptyClosures-JuanVuletich-2025Jun18-18h03m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7270] on 18 June 2025 at 12:48:09 pm'!
!FileList methodsFor: 'file list' stamp: 'fgz 6/18/2025 12:44:43' prior: 16867117!
                            fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | entry fileSize ifNil: [mx] ifNotNil: [:fs| mx max: fs]]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: (entry fileSize ifNil: [0])]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7278-FileList-fix-FelipeZak-2025Jun18-12h41m-fgz.001.cs.st----!

'From Cuis7.5 [latest update: #7265] on 20 June 2025 at 11:40:59 am'!
!PreferenceSet class methodsFor: 'services' stamp: 'eem 6/20/2025 11:40:47' prior: 16936964!
readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [ | line parts |
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[ | pref value |
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first == $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefs.txt Error' print.
						error print.
						line print ].
				]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7279-PreferenceSet-typo-EliotMiranda-11h43m-eem.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 26 June 2025 at 1:00:31 pm'!
!WorldMorph methodsFor: 'drawing' stamp: 'jmv 6/26/2025 12:53:00' prior: 17018217!
          displayWorldOn: aMorphicCanvas
	"Update this world's display on the argument."

	| allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"Restore world drawing under hands and their carried morphs"
	(Preferences at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		activeHand restoreSavedPatchOn: aMorphicCanvas ].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	aMorphicCanvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage := aMorphicCanvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	self submorphNeedsRedraw: false.
	self needsRedraw: false.
	aMorphicCanvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self ifHandToBeDrawnForDamage: allDamage do: [
		(Preferences at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage := (activeHand savePatchFrom: aMorphicCanvas) quickMerge: allDamage ]
			ifFalse: [ allDamage := activeHand displayFullBoundsForPatch quickMerge: allDamage ].
		aMorphicCanvas fullDrawHand: activeHand.
		activeHand needsRedraw: false.
		activeHand submorphNeedsRedraw: false ].

	"Copy altered rects to Display"
	allDamage ifNotNil: [
		aMorphicCanvas drawsOnDisplay
			ifTrue: [
				"For instance for Linux and Windows. Drawing was done to Display, but given that #deferUpdates: is on,
				we need to specifically ask for changes to be visually effective."
				DisplayScreen isDisplayExtentOk ifTrue: [
					Display forceToScreen: allDamage ]]
			ifFalse: [
				"For Mac, drawing was done to off-Display canvas. Copy content to Display.
				#deferUpdates: is off, so no additional indication to show Display contents is needed."
				aMorphicCanvas showAt: self viewBox origin invalidRect: allDamage ]].! !
!MorphicCanvas methodsFor: 'testing' stamp: 'jmv 6/26/2025 12:52:04' prior: 16915687!
  drawsOnDisplay
	"Answer true if we actually draw on (Display shallowCopy)"
	^form == Display | (form bits == Display bits)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7280-WorldAndHandTweaks-optionalNoDetachedDisplayOnMac-JuanVuletich-2025Jun26-12h49m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7280] on 26 June 2025 at 5:21:44 pm'!
!Transcript class methodsFor: 'private' stamp: 'jmv 6/26/2025 16:11:15' prior: 16997755!
             displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	(displayEngine isNil or: [
		displayEngine class ~= BitBltCanvasEngine]) ifTrue: [
			displayEngine := BitBltCanvasEngine toForm: Display shallowCopy].
	^ displayEngine! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:11:07' prior: 16997789!
  display
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		Display forceToScreen: bounds ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:11:02' prior: 16997845!
                   displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			Display forceToScreen: bounds ]]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	Transcript releaseClassCachedState!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7281-TranscriptOnDisplayCopy-JuanVuletich-2025Jun26-17h21m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7287] on 26 June 2025 at 6:02:54 pm'!
!ProgressInitiationException methodsFor: 'exceptionDescription' stamp: 'jmv 6/26/2025 18:02:44' prior: 16939858 overrides: 16861277!
           defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame lastDrawTime |
	f := FontFamily defaultFamilyAndPointSize.
	h := f lineSpacing * 3//2.
	textWidth := (f widthOfString: progressTitle) + h.
	width := 150 max: textWidth.

	textForm := Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame := Rectangle center: aPoint extent: (width@h) roundedToEven.
	textFrame := `0@0` extent: width@h.
	textFrame := textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame := barFrame merge: textFrame.
	delta := outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame := barFrame translatedBy: delta.
	textFrame := textFrame translatedBy: delta.
	outerFrame := outerFrame translatedBy: delta.
	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame := barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	Display forceToScreen: outerFrame.
	lastDrawTime := Time localMillisecondClock.
	result := workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal := barVal ]
			ifNil: [
				currentVal := currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal := minVal ]].
		filledWidth := ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		Time localMillisecondClock - lastDrawTime > 100 ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + `2@2` extent: filledWidth@(h-4)).
			Display forceToScreen: outerFrame.
			lastDrawTime := Time localMillisecondClock ]].
	UISupervisor ui ifNotNil: [ :ui | ui invalidateDisplayRect: outerFrame for: nil ].
	self resume: result! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7282-ProgressBar-Performance-JuanVuletich-2025Jun26-18h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7282] on 26 June 2025 at 5:33:59 pm'!

DisplayScreen removeSelector: #fillShape:fillColor:at:!

!methodRemoval: DisplayScreen #fillShape:fillColor:at: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
fillShape: aShapeForm fillColor: aColor at: location
	super fillShape: aShapeForm fillColor: aColor at: location.
	DisplayScreen screenUpdateRequired: nil!

DisplayScreen removeSelector: #eraseShape:!

!methodRemoval: DisplayScreen #eraseShape: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
eraseShape: bwForm
	super eraseShape: bwForm.
	DisplayScreen screenUpdateRequired: nil!

DisplayScreen removeSelector: #copyBits:from:at:clippingBox:rule:!

!methodRemoval: DisplayScreen #copyBits:from:at:clippingBox:rule: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule
	super copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule.
	DisplayScreen screenUpdateRequired: clipRect!

DisplayScreen removeSelector: #copy:from:in:rule:!

!methodRemoval: DisplayScreen #copy:from:in:rule: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
copy: destRectangle from: sourcePt in: sourceForm rule: rule
	super copy: destRectangle from: sourcePt in: sourceForm rule: rule.
	DisplayScreen screenUpdateRequired: destRectangle!

DisplayScreen removeSelector: #copyBits:at:translucent:!

!methodRemoval: DisplayScreen #copyBits:at:translucent: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
copyBits: sourceForm at: destOrigin translucent: factor
	super copyBits: sourceForm at: destOrigin translucent: factor.
	DisplayScreen screenUpdateRequired: (destOrigin extent: sourceForm extent)!

DisplayScreen removeSelector: #copyBits:from:at:clippingBox:rule:map:!

!methodRemoval: DisplayScreen #copyBits:from:at:clippingBox:rule:map: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule map: map
	super copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule map: map.
	DisplayScreen screenUpdateRequired: clipRect!

DisplayScreen removeSelector: #fillFromXYColorBlock:!

!methodRemoval: DisplayScreen #fillFromXYColorBlock: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
fillFromXYColorBlock: colorBlock
	super fillFromXYColorBlock: colorBlock.
	DisplayScreen screenUpdateRequired: nil!

DisplayScreen removeSelector: #fill:rule:fillColor:!

!methodRemoval: DisplayScreen #fill:rule:fillColor: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:25'!
fill: aRectangle rule: anInteger fillColor: aForm 
	super fill: aRectangle rule: anInteger fillColor: aForm.
	DisplayScreen screenUpdateRequired: aRectangle!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7282] on 26 June 2025 at 5:35:08 pm'!
!Form class methodsFor: 'instance creation' stamp: 'jmv 6/26/2025 16:52:37' prior: 16875454!
                  fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb := BitBltCanvasEngine toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect := aPoint extent: diameter.
	bb fillOval: rect.
	p := (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: `Color white alpha: 0.3`.
		d := i * diameter // 10.
		rect := Rectangle
			center: p
			extent: d roundedToEven.
		bb fillOval: rect ].
	Display forceToScreen.
"
	Form fakeSphereAt: 70@70 diameter: 40 color:  (Color red alpha: 0.5)
"! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:40:00' prior: 16790999!
            alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 := Color cachedColormapFrom: Display depth to: 32.
		map32toD := Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff := Form extent: 500@50 depth: 32.
	dispToBuff := BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay := BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.
	Display forceToScreen.

	"Create a brush with radially varying alpha"
	brush := Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize := 100.
	buff := Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff := BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff := BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff := BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor isMouseButton2Pressed] whileFalse:
		[prevP := nil.
		buffRect := Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor isMouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p := Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP := p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta := (p-prevP) theta.
					p := ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect := p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta := brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect := buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect := newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect := (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				Display forceToScreen: updateRect.
				prevP := p]]]! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:40:23' prior: 16791122!
                exampleColorMap	"BitBlt exampleColorMap"
	"This example shows what one can do with the fixed part of a color map. The color map, as setup below, rotates the bits of a pixel all the way around. Thus you'll get a (sometime strange looking ;-) animation of colors which will end up exactly the way it looked at the beginning. The example is given to make you understand that the masks and shifts can be used for a lot more than simply color converting pixels. In this example, for instance, we use only two of the four independent shifters."
	| cc bb |
	cc := ColorMap masks: {
		1 << (Display depth-1). "mask out high bit of color component"
		1 << (Display depth-1) - 1. "mask all other bits"
		0.
		0}
		shifts: {
			1 - Display depth. "shift right to bottom most position"
			1. "shift all other pixels one bit left"
			0.
			0}.
	bb := BitBlt toForm: Display.
	bb 
		sourceForm: Display;
		combinationRule: 3;
		colorMap: cc.
	1 to: Display depth do: [ :i |
		bb copyBits.
		Display forceToScreen.
	]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:55:19' prior: 17015131!
                           test1
	"
	Display restoreAfter: [WarpBlt test1]
	"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p ext box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		box := (r1 extent*5-ext//2 extent: ext).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:55:34' prior: 17015163!
    test12
	"
	Display restoreAfter: [WarpBlt test12]
	"
	"Just like test1, but comparing smooth to non-smooth warps"
	| warp pts r1 p0 p ext warp2 box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		cellSize: 2;  "installs a colormap"
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	warp2 := (self toForm: Display)
		clipRect: ((0@0 extent: r1 extent*5) translatedBy: 250@0);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		box := (r1 extent*5-ext//2 extent: ext).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box.
		box := ((r1 extent*5-ext//2 extent: ext) translatedBy: 250@0).
		warp2 copyQuad: pts toRect: box.
		Display forceToScreen: box.
		]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:55:51' prior: 17015206!
           test1Mirrored
	"
	Display restoreAfter: [WarpBlt test1Mirrored]
	"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p ext box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 topRight. r1 bottomRight. r1 bottomLeft}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		box := (r1 extent*5-ext//2 extent: ext).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:56:09' prior: 17015239!
                    test3
	"
	Display restoreAfter: [WarpBlt test3]
	"
	"The Squeak Release Mandala - 9/23/96 di"

	"Move the mouse near the center of the square.
	Up and down affects shrink/grow
	Left and right affect rotation angle"
	| warp pts p0 p box map d t |
	box := 100@100 extent: 300@300.
	Display border: (box expandBy: 2) width: 2.

	"Make a color map that steps through the color space"
	map := (Display depth > 8
		ifTrue: ["RGB is a bit messy..."
				d := Display depth = 16 ifTrue: [5] ifFalse: [8].
				(1 to: 512) collect: [:i | t := i bitAnd: 511.
					((t bitAnd: 16r7) bitShift: d-3)
					+ ((t bitAnd: 16r38) bitShift: d-3*2)
					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]
		ifFalse: ["otherwise simple"
				1 to: (1 bitShift: Display depth)])
			as: Bitmap.
	warp := (WarpBlt toForm: Display)
		clipRect: box;
		sourceForm: Display;
		colorMap: map;
		combinationRule: Form over.
	p0 := box center.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := (box insetBy: p y - p0 y) innerCorners
			collect: [:pt | pt inverseRotatedBy: p x - p0 x / 50.0 about: p0].
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:56:29' prior: 17015278!
      test4
	"
	Display restoreAfter: [WarpBlt test4]
	"
	"The Squeak Release Mandala - 9/23/96 di
	This version does smoothing"

	"Move the mouse near the center ofhe square.
	Up and dn affects shrink/grow
	Left and right affect rotation angle"
	| warp pts p0 p box |
	box := 100@100 extent: 300@300.
	Display border: (box expandBy: 2) width: 2.

	warp := (WarpBlt toForm: Display)
		clipRect: box;
		sourceForm: Display;
		cellSize: 2;  "installs a colormap"
		combinationRule: Form over.
	p0 := box center.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := (box insetBy: p y - p0 y) innerCorners
			collect: [:pt | pt inverseRotatedBy: p x - p0 x / 50.0 about: p0].
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:56:44' prior: 17015305!
                   test5
	"
	Display restoreAfter: [WarpBlt test5]
	"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle fromUser.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		cellSize: 1;
		sourceForm: Display;
		cellSize: 2;  "installs a colormap"
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		box := (r1 translatedBy: r1 width@0).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]
! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:57:02' prior: 17015335!
         testSourceDestOverlap
	"Show that if source and destination are the same, then source quad and dest rect should not overlap,
	or data will be lost.
	WarpBlt testSourceDestOverlap
	"
	| warp box | 
	warp := (WarpBlt toForm: Display)
		sourceForm: Display;
		combinationRule: Form over.
	box := (0@0 extent: 160@160).
	warp copyQuad: {0@0. 160@0. 160@160. 0@160} toRect: box.
	Display forceToScreen: box.! !
!CharacterSequence methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:46:27' prior: 16814821!
             displayAt: aPoint 
	"Display the receiver as a DisplayText at aPoint on the display screen."

	self displayOn: Display at: aPoint.
	Display forceToScreen.! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 6/26/2025 16:33:22' prior: 16998230!
           endEntry
	| c d cb |
	c := self contents.
	DisplayScreen isDisplayExtentOk ifFalse: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame := frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d := textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb := textComposition characterBlockAtPoint:
			`0@0` + (0@(d+FontFamily defaultLineSpacing)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit := position := collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		drawTextComposition: textComposition
		at: `4@4` + frame topLeft
		extent: Display extent
		color: `Color black`
		selectionColor: `Color blue`.
	Display forceToScreen.! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:35:38' prior: 50335344!
                 displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			Display forceToScreen: damage ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7284-DisplayScreen-cleanup-JuanVuletich-2025Jun26-17h33m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7280] on 26 June 2025 at 5:01:47 pm'!

DisplayScreen class removeSelector: #screenUpdateRequired:!

!methodRemoval: DisplayScreen class #screenUpdateRequired: stamp: 'Install-7285-screenUpdateRequired-removal-JuanVuletich-2025Jun26-17h00m-jmv.001.cs.st 7/15/2025 11:02:25'!
screenUpdateRequired: aRectangle

	ScreenUpdaterProcess ifNotNil: [
		Damage := aRectangle
			ifNotNil: [ aRectangle quickMerge: Damage ]
			ifNil: [ Display boundingBox ].
		ScreenUpdaterSemaphore signal ].!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DisplayScreen terminateScreenUpdater!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7285-screenUpdateRequired-removal-JuanVuletich-2025Jun26-17h00m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:39:06 pm'!

Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: 'Damage ScreenUpdaterProcess ScreenUpdaterSemaphore '
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!classDefinition: #DisplayScreen category: #'Graphics-Display Objects' stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:25'!
Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: 'Damage ScreenUpdaterProcess ScreenUpdaterSemaphore'
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/26/2025 17:02:54' prior: 16851470!
  setupDisplay
	"
	DisplayScreen setupDisplay.
	Display forceToScreen.
	"

	Display ifNil: [
		Smalltalk at: #Display put: DisplayScreen new.
		"See #recreateSpecialObjectsArray"
		Smalltalk specialObjectsArray at: 15 put: Display ].
	[
		Display setExtent: self actualScreenSize depth: Display nativeDepth.
		"{'New Smalltalk Display:'. self actualScreenSize} print."
	] on: OutOfMemory do: [
		"In case of memory emergency, use a much smaller Display"
		'Display allocation failed - Using Emergency (small) Display.'  print.
		'Resize Display (or OS Window) to retry Display allocation.'  print.
		Display setExtent: self actualScreenSize // 4 depth: Display nativeDepth ].! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/26/2025 17:03:00' prior: 16851495 overrides: 16789693!
         shutDown 
	"Minimize Display memory saved in image"
	Display prepareForImageSave.! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 6/26/2025 17:02:39' prior: 16916113!
     onDisplay
	"Answer an instance of the appropriate subclass targetting Display,
	or an intermediate buffer, as appropriate.
	Create a new VectorEngineDrawer or BitBltCanvasEngine as appropriate."
	        "If this platform supports deferred updates
		- Set Display to deferred update mode
		- Use a Canvas on Display
	otherwise
		- Set a non-Display canvas"

	| canvasTarget |
	canvasTarget := (Display deferUpdates: true)
		"Both Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display."
		ifNotNil: [ Display ]
		"Mac VMs don't support deferUpdates:, so Morphic Canvas target is this aux Form."
		ifNil: [ Form extent: Display extent depth: Display depth ].
	^self onForm: canvasTarget.! !

DisplayScreen class removeSelector: #terminateScreenUpdater!

!methodRemoval: DisplayScreen class #terminateScreenUpdater stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:25'!
terminateScreenUpdater

	ScreenUpdaterProcess ifNotNil: [
		ScreenUpdaterProcess terminate ].
	ScreenUpdaterProcess := nil.
	ScreenUpdaterSemaphore := nil.
	Damage := nil.!

DisplayScreen class removeSelector: #installScreenUpdater!

!methodRemoval: DisplayScreen class #installScreenUpdater stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:25'!
installScreenUpdater
	"Initialize the event tickler process. Terminate the old process if any."
	"
	DisplayScreen installScreenUpdater
	"

	self terminateScreenUpdater.
	ScreenUpdaterProcess := [ self screenUpdater ] newProcess.
	ScreenUpdaterProcess priority: Processor lowIOPriority.
	ScreenUpdaterProcess name: '[system] Background Screen updater'.
	ScreenUpdaterProcess resume!

DisplayScreen class removeSelector: #screenUpdater!

!methodRemoval: DisplayScreen class #screenUpdater stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:25'!
screenUpdater
	| delay |
	delay := Delay forMilliseconds: 50.
	ScreenUpdaterSemaphore := Semaphore new.
	Damage := nil.
	[
		"Could happen if process is halted and resumed."
		delay beingWaitedOn ifTrue: [ delay := Delay forMilliseconds: delay delayDuration ].
		delay wait.
		ScreenUpdaterSemaphore wait.
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: Damage.
			ScreenUpdaterSemaphore initSignals.
			Damage := nil ].
	] repeat!

Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!classDefinition: #DisplayScreen category: #'Graphics-Display Objects' stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:25'!
Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:46:45 pm'!
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:44:56' prior: 16831377!
    showColorCube
	"Show a 12x12x12 color cube."
	"
	Color showColorCube
	"

	| offDisplay |
	offDisplay := Display shallowCopy.
	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				offDisplay fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
	Display forceToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:45:46' prior: 16831387!
 showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r offDisplay |
	offDisplay := Display shallowCopy.
	w := Display width // colorList size.
	r := 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		offDisplay fill: r fillColor: c.
		r := r translatedBy: w@0].
	Display forceToScreen.! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:46:33' prior: 16831398!
                 showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"
	Color showHSVPalettes
	"

	| left top c offDisplay |
	offDisplay := Display shallowCopy.
	left := top := 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left := (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c := Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4).
				offDisplay fill: (left@top extent: 4@4) fillColor: c.

				c := Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4) + 50.
				offDisplay fill: (left@top extent: 4@4) fillColor: c]]].
	Display forceToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:45:16' prior: 16831419!
             showHuesInteractively
	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."
	"
	Color showHuesInteractively
	"

	| p s v |
	[Sensor isAnyButtonPressed] whileFalse: [
		p := Sensor mousePoint.
		s := p x asFloat / 300.0.
		v := p y asFloat / 300.0.
		self showColors: (self wheel: 12 saturation: s brightness: v)].
	^ (s min: 1.0) @ (v min: 1.0)! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:50:37' prior: 16831300!
             experimentsTowardsANewColorPalette
"
For UIs.
	TopLeft. Show 'selected' color.
	BottomLeft. For selected Hue, change Saturation and brightness.
	TopRight. For selected Luminance, change Hue and Chroma
	BottomRight. For selected Chroma, change Hue and Luminance.
Color experimentsTowardsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance offDisplay |
width := 300.
height := 120.
selectedColor := Color random.
selectedHue := selectedColor hue.
selectedSaturation := selectedColor saturation.
selectedChroma := selectedColor chroma.
selectedV := selectedColor brightness.
selectedLuminance := selectedColor luminance.
"TopLeft. Show 'selected' color."
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
offDisplay := Display shallowCopy.

0 to: height do: [ :y |
	v := 1.0 - (y / height).
	0 to: height do: [ :x |
		s := x / height.
		color := Color new setHue: selectedHue saturation: s brightness: v.
		offDisplay colorAt: x@(y+height) put: color
	].
	Display forceToScreen: (0@y extent: height@y).
].
0 to: height do: [ :y | | c |
	v := 1.0 - (y / height).
	s := 1.0 - (y / height).
	c := s.
	0 to: width do: [ :x |
		h := x / width * 360.
		
		color := Color new setHue: h chroma: c luminance: selectedLuminance.
"		color := Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: s brightness: selectedV."
		offDisplay colorAt: x+height@y put: color.
		
		color := Color new setHue: h chroma: selectedChroma luminance: v.
"		color := Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: selectedSaturation brightness: v."
		offDisplay colorAt: x+height@(y+height) put: color.
		
	].
	Display forceToScreen: (0@y extent: width@y).
].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7287-ColorExamples-performance-JuanVuletich-2025Jun26-17h39m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:52:31 pm'!
!Form methodsFor: 'transitions' stamp: 'jmv 6/26/2025 17:51:56' prior: 16874930!
  pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d delay |
	delay := Delay forSeconds: 0.1.
	pageRect := otherImage boundingBox.
	oldPage := self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: `Color black`.
	oldBottom := self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps := 8.
	buffer := Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d := pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
					p := pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: `0@0` rule: Form over.
					p := pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect := pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad := Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp := (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen: leafRect.
		delay wait.
		].

	buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
	delay wait.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"! !
!Form methodsFor: 'transitions' stamp: 'jmv 6/26/2025 17:49:40' prior: 16875001!
                         slideImage: otherImage at: topLeft delta: delta
	"
	Display slideImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse
		at: 40@40 delta: 3@ -4
	"
	| bb nSteps clipRect |
	bb := otherImage boundingBox.
	clipRect := topLeft extent: otherImage extent.
	nSteps := 1.
	delta x = 0 ifFalse: [nSteps := nSteps max: (bb width//delta x abs) + 1].
	delta y = 0 ifFalse: [nSteps := nSteps max: (bb height//delta y abs) + 1].
	1 to: nSteps do: [ :i | 
			self 
				copyBits: bb from: otherImage
				at: delta*(i-nSteps) + topLeft
				clippingBox: clipRect rule: Form paint.
			Display forceToScreen: clipRect.
		]! !
!Form methodsFor: 'transitions' stamp: 'jmv 6/26/2025 17:49:16' prior: 16875022!
            wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock

	| i clipRect t rectsOrNil waitTime |
	i := 0.
	clipRect := topLeft extent: otherImage extent.
	clipBox ifNotNil: [ clipRect := clipRect intersect: clipBox ].
	[ rectsOrNil := rectForIndexBlock value: (i := i + 1) ]
		whileNotNil: [
			t := Time localMillisecondClock.
			rectsOrNil do: [ :r |
				self copyBits: r from: otherImage at: topLeft + r topLeft
					clippingBox: clipRect rule: Form over ].
			Display forceToScreen: clipRect.
			waitTime := 3 - (Time localMillisecondClock - t).
			waitTime > 0 ifTrue:
				["(Delay forMilliseconds: waitTime) wait"]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7288-FormExamples-performance-JuanVuletich-2025Jun26-17h47m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:47:45 pm'!
!InputSensor methodsFor: 'joystick' stamp: 'jmv 6/26/2025 17:47:26' prior: 16887847!
                          testJoystick: index
	"Sensor testJoystick: 3"

	| f pt buttons status |
	f := Form extent: 110@50 depth: 32.
	[Sensor isAnyButtonPressed] whileFalse: [
		pt := Sensor joystickXY: index.
		buttons := Sensor joystickButtons: index.
		status :=
'xy: ', pt printString, '
buttons: ', buttons hex.
		f fillWhite.
		status displayOn: f at: 10@10.
		f displayOn: Display at: 10@10.
	].
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7289-tweak-JuanVuletich-2025Jun26-17h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 9:18:23 am'!
!DisplayScreen methodsFor: 'copying' stamp: 'jmv 6/27/2025 09:15:59'!
           copyToDisableImmediateUpdates
	"Answer an instance that shares our pixel storage.
	This is useful to prevent the VM from immediately updating the host platform pixels the user actually sees,
	especially on platforms where #deferUpdates: answers ni, meaning it doesn't really support doing this.
	Flicking is possible. See comment at #beDisplay . For this reason Morphic doesn't use this technique.
	Alternatively, the separate Form used as the Morphic Canvas target on such platforms could be made into
	a service provided by this class, together with the appropriate way to update the real host pixels, removing
	this code from #displayWorldOn:.
	"
	^self shallowCopy! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:40' prior: 50336270!
           experimentsTowardsANewColorPalette
"
For UIs.
	TopLeft. Show 'selected' color.
	BottomLeft. For selected Hue, change Saturation and brightness.
	TopRight. For selected Luminance, change Hue and Chroma
	BottomRight. For selected Chroma, change Hue and Luminance.
Color experimentsTowardsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance offDisplay |
width := 300.
height := 120.
selectedColor := Color random.
selectedHue := selectedColor hue.
selectedSaturation := selectedColor saturation.
selectedChroma := selectedColor chroma.
selectedV := selectedColor brightness.
selectedLuminance := selectedColor luminance.
"TopLeft. Show 'selected' color."
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
offDisplay := Display copyToDisableImmediateUpdates.

0 to: height do: [ :y |
	v := 1.0 - (y / height).
	0 to: height do: [ :x |
		s := x / height.
		color := Color new setHue: selectedHue saturation: s brightness: v.
		offDisplay colorAt: x@(y+height) put: color
	].
	Display forceToScreen: (0@y extent: height@y).
].
0 to: height do: [ :y | | c |
	v := 1.0 - (y / height).
	s := 1.0 - (y / height).
	c := s.
	0 to: width do: [ :x |
		h := x / width * 360.
		
		color := Color new setHue: h chroma: c luminance: selectedLuminance.
"		color := Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: s brightness: selectedV."
		offDisplay colorAt: x+height@y put: color.
		
		color := Color new setHue: h chroma: selectedChroma luminance: v.
"		color := Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: selectedSaturation brightness: v."
		offDisplay colorAt: x+height@(y+height) put: color.
		
	].
	Display forceToScreen: (0@y extent: width@y).
].! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:36' prior: 50336201!
                showColorCube
	"Show a 12x12x12 color cube."
	"
	Color showColorCube
	"

	| offDisplay |
	offDisplay := Display copyToDisableImmediateUpdates.
	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				offDisplay fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
	Display forceToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:32' prior: 50336214!
               showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r offDisplay |
	offDisplay := Display copyToDisableImmediateUpdates.
	w := Display width // colorList size.
	r := 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		offDisplay fill: r fillColor: c.
		r := r translatedBy: w@0].
	Display forceToScreen.! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:29' prior: 50336228!
                               showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"
	Color showHSVPalettes
	"

	| left top c offDisplay |
	offDisplay := Display copyToDisableImmediateUpdates.
	left := top := 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left := (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c := Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4).
				offDisplay fill: (left@top extent: 4@4) fillColor: c.

				c := Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4) + 50.
				offDisplay fill: (left@top extent: 4@4) fillColor: c]]].
	Display forceToScreen.
! !
!MorphicCanvas methodsFor: 'testing' stamp: 'jmv 6/27/2025 09:17:19' prior: 50335300!
                          drawsOnDisplay
	"Answer true if we actually draw on (Display copyToDisableImmediateUpdates)"
	^form == Display | (form bits == Display bits)! !
!Transcript class methodsFor: 'private' stamp: 'jmv 6/27/2025 09:17:24' prior: 50335316!
                       displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	(displayEngine isNil or: [
		displayEngine class ~= BitBltCanvasEngine]) ifTrue: [
			displayEngine := BitBltCanvasEngine toForm: Display copyToDisableImmediateUpdates].
	^ displayEngine! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7290-Document-DisplayCopy-technique-JuanVuletich-2025Jun27-09h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 9:24:56 am'!
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 09:23:56' prior: 16944331!
            newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay offDisplay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	offDisplay := Display copyToDisableImmediateUpdates.
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay forceToScreen: (rect merge: newRect).
			rect := newRect]].
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 09:23:09' prior: 16944363!
                        newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay offDisplay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	offDisplay := Display copyToDisableImmediateUpdates.
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay forceToScreen: (rect merge: newRect).
			rect := newRect]].
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7291-Rectngle-fromUser-performance-JuanVuletich-2025Jun27-09h18m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 10:08:39 am'!

DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay '!

!classDefinition: 'DisplayScreen class' category: #'Graphics-Display Objects' stamp: 'Install-7292-DisplayScreen-deferredUpdatingDisplay-p1-JuanVuletich-2025Jun27-09h24m-jmv.001.cs.st 7/15/2025 11:02:25'!
DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay'!
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 09:49:49'!
                            clearDeferredUpdatingDisplay

	DeferredUpdatingDisplay ifNotNil: [
		DeferredUpdatingDisplay bits unpin.
		DeferredUpdatingDisplay := nil ].! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 09:43:00'!
                          deferredUpdatingDisplay
	"Answer the instance to be used from most clients, including Morphic.
	If the platform supports #deferUpdates:, it will be Display itself.
	If the platform does NOT support #deferUpdates, it will be a separate Form.
	Methods in this category provide convenient access."

	DeferredUpdatingDisplay ifNil: [
		 DeferredUpdatingDisplay := (Display deferUpdates: true)
			"Both Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display."
			ifNotNil: [ Display ]
			"Mac VMs don't support deferUpdates:, so Morphic Canvas target is this aux Form."
			ifNil: [ Form extent: Display extent depth: Display depth ]].
	^DeferredUpdatingDisplay! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:06:24'!
                           isDisplay: aFormOrDisplayScreen
	"Answer true if:
		Display
		DeferredUpdatingDisplay
	flase otherwise."
	aFormOrDisplayScreen == Display ifTrue: [ ^true ].
	aFormOrDisplayScreen == DeferredUpdatingDisplay ifTrue: [ ^true ].
	^false.! !
!DisplayScreen class methodsFor: 'cached state access' stamp: 'jmv 6/27/2025 09:59:01' overrides: 16789661!
       releaseClassCachedState
	self clearDeferredUpdatingDisplay! !
!DisplayScreen methodsFor: 'private' stamp: 'jmv 6/27/2025 09:50:50' prior: 16851275 overrides: 16875229!
                        setExtent: aPoint depth: bitsPerPixel
	"DisplayScreen startUp"
	"This method is critical. If the setExtent fails, there will be no
	proper display on which to show the error condition."

	| bitsPerPixelToUse oldBits |
	DisplayScreen clearDeferredUpdatingDisplay.
	(depth = bitsPerPixel and: [aPoint = self extent and: [
					self supportsDisplayDepth: bitsPerPixel]]) ifFalse: [
		bitsPerPixelToUse := (self supportsDisplayDepth: bitsPerPixel)
			ifTrue: [ bitsPerPixel ]
			ifFalse: [
				(self supportsDisplayDepth: bitsPerPixel negated)
					ifTrue: [ bitsPerPixel negated ]
					ifFalse: [ self findAnyDisplayDepth ]].
		"Keep the old bits with a hard reference until the #beDisplay call below."
		oldBits := bits.
		"This super call will assign the new contents of the 'bits' instance variable.
		The old one may be still used by the VM (see comment at #beDisplay),
		but it is also stored in the oldBits variable, so it is safe."
		super setExtent: aPoint depth: bitsPerPixelToUse.
		"Let the VM know our bits have changed.
		See http://lists.squeakfoundation.org/archives/list/vm-dev@lists.squeakfoundation.org/message/F3I7L5IJT2J5RXCS3QXLLQ3TZ6KU6FD6/	"
		"Usually you don't create new instances of DisplayScreen, but if ever done, do what follows only for the real Display."
		self == Display ifTrue: [
			"It is important to keep oldBits referencing the bits passed to the VM in the previous
			call to #beDisplay until AFTER we passed it the new value in the call that follows."
			self beDisplay ].
		"Most likely not needed, even if some VMs could have pinned it.
		Still, this is a way to ensure that no optimizer may ever try to kill the oldBits before we're sure the VM doesn't need us to keep a reference to it."
		oldBits unpin.
		"Only now it is safe to no longer reference oldBits."
		oldBits := nil.
	].! !
!DisplayScreen methodsFor: 'initialization' stamp: 'jmv 1/15/2018 15:51:20' prior: 16851405 overrides: 16940323!
           initialize
	self
		setExtent: self class actualScreenSize
		depth: (self class actualScreenDepth ifNil: [ 32 ])! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/27/2025 09:51:05' prior: 50336066!
               setupDisplay
	"
	DisplayScreen setupDisplay.
	Display forceToScreen.
	"

	Display ifNil: [
		Smalltalk at: #Display put: DisplayScreen new.
		"See #recreateSpecialObjectsArray"
		Smalltalk specialObjectsArray at: 15 put: Display ].
	[
		Display setExtent: self actualScreenSize depth: Display nativeDepth.
		"{'New Smalltalk Display:'. self actualScreenSize} print."
	] on: OutOfMemory do: [
		"In case of memory emergency, use a much smaller Display"
		'Display allocation failed - Using Emergency (small) Display.'  print.
		'Resize Display (or OS Window) to retry Display allocation.'  print.
		Display setExtent: self actualScreenSize // 4 depth: Display nativeDepth ].! !
!VectorEngineDrawer methodsFor: 'services' stamp: 'jmv 6/27/2025 10:07:23' prior: 17010360!
                               unpinAndFreeMemory

	"Unpin, if possible, any pinned large arrays."
	"Unpin if pinning is supported by the VM, NOP otherwise."
	targetForm ifNotNil: [
		(DisplayScreen isDisplay: targetForm) ifFalse: [
			targetForm bits unpin ]].
	morphIds ifNotNil: [ morphIds unpin ].
	edgeCounts ifNotNil: [ edgeCounts unpin ].
	alphaMask ifNotNil: [ alphaMask unpin ].
	affectedBits ifNotNil: [ affectedBits unpin ].
	contour ifNotNil: [ contour unpin ].

	targetForm := nil.
	morphIds := nil.
	edgeCounts := nil.
	alphaMask := nil.
	affectedBits := nil.
	contour := nil.! !

DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay'!

!classDefinition: 'DisplayScreen class' category: #'Graphics-Display Objects' stamp: 'Install-7292-DisplayScreen-deferredUpdatingDisplay-p1-JuanVuletich-2025Jun27-09h24m-jmv.001.cs.st 7/15/2025 11:02:25'!
DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7292-DisplayScreen-deferredUpdatingDisplay-p1-JuanVuletich-2025Jun27-09h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 10:25:25 am'!
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:22:57'!
      forceDeferredToScreen
	"Force the entire display area to the screen"
	DeferredUpdatingDisplay ifNotNil: [
		self forceDeferredToScreen: DeferredUpdatingDisplay boundingBox ]! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:20:09'!
                         forceDeferredToScreen: updateRect
	"Force the given rectangular section of the Display to be copied to the host screen. Make it visible to user."

	DeferredUpdatingDisplay ifNil:
		[ ^self ].
	DisplayScreen isDisplayExtentOk ifFalse:
		[ ^self ].
	DeferredUpdatingDisplay == Display
		ifTrue:
			[Display forceToScreen: updateRect ]
		ifFalse:
			[
			(BitBlt toForm: Display)
				sourceForm: DeferredUpdatingDisplay;
				combinationRule: Form over;
				sourceRect: updateRect;
				destOrigin: updateRect topLeft;
				copyBits ]! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:10:40' prior: 50336771!
      deferredUpdatingDisplay
	"Answer the instance to be used from most clients, including Morphic.
	If the platform supports #deferUpdates:
		Set Display to deferred upodating
		Answer will be Display itself.
	If the platform does NOT support #deferUpdates
		Answer a separate Form.
	Methods in this category provide convenient access."

	DeferredUpdatingDisplay ifNil: [
		 DeferredUpdatingDisplay := (Display deferUpdates: true)
			"Both Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display."
			ifNotNil: [ Display ]
			"Mac VMs don't support deferUpdates:, so Morphic Canvas target is this aux Form."
			ifNil: [ Form extent: Display extent depth: Display depth ]].
	^DeferredUpdatingDisplay! !
!WorldMorph methodsFor: 'drawing' stamp: 'jmv 6/27/2025 10:20:32' prior: 50335233!
                        displayWorldOn: aMorphicCanvas
	"Update this world's display on the argument."

	| allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"Restore world drawing under hands and their carried morphs"
	(Preferences at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		activeHand restoreSavedPatchOn: aMorphicCanvas ].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	aMorphicCanvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage := aMorphicCanvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	self submorphNeedsRedraw: false.
	self needsRedraw: false.
	aMorphicCanvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self ifHandToBeDrawnForDamage: allDamage do: [
		(Preferences at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage := (activeHand savePatchFrom: aMorphicCanvas) quickMerge: allDamage ]
			ifFalse: [ allDamage := activeHand displayFullBoundsForPatch quickMerge: allDamage ].
		aMorphicCanvas fullDrawHand: activeHand.
		activeHand needsRedraw: false.
		activeHand submorphNeedsRedraw: false ].

	"Copy altered rects to Display"
	allDamage ifNotNil: [
		DisplayScreen forceDeferredToScreen: allDamage ].! !
!WorldMorph methodsFor: 'drawing' stamp: 'jmv 6/27/2025 10:24:45' prior: 17018281 overrides: 16929409!
                      drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			super drawOn: aCanvas ]
		ifNil: [
			"draw background fill"
			(aCanvas form == Display and: [ color mightBeTranslucent ])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Cuis Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: `0@0` in: nil
						fillColor: color rule: Form over.
					Display forceToScreen]
				ifFalse: [ super drawOn: aCanvas ]]! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 10:11:44' prior: 50336097!
         onDisplay
	"Answer an instance of the appropriate subclass targetting Display,
	or an intermediate buffer, as appropriate.
	Create a new VectorEngineDrawer or BitBltCanvasEngine as appropriate.
	Use a#deferredUpdatingDisplay, so actual contents are flushed to visible pixels only when appropriate.
	See DisplayScreen 'deferred updating' class methods category."

	| canvasTarget |
	canvasTarget := DisplayScreen deferredUpdatingDisplay.
	^self onForm: canvasTarget.! !

MorphicCanvas removeSelector: #drawsOnDisplay!

!methodRemoval: MorphicCanvas #drawsOnDisplay stamp: 'Install-7293-DisplayScreen-deferredUpdatingDisplay-p2-JuanVuletich-2025Jun27-10h08m-jmv.001.cs.st 7/15/2025 11:02:25'!
drawsOnDisplay
	"Answer true if we actually draw on (Display copyToDisableImmediateUpdates)"
	^form == Display | (form bits == Display bits)!

DisplayScreen class removeSelector: #forceToScreen!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
UISupervisor ui releaseCachedState.
UISupervisor spawnNewMorphicProcessFor: UISupervisor ui

!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7293-DisplayScreen-deferredUpdatingDisplay-p2-JuanVuletich-2025Jun27-10h08m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 10:54:54 am'!
!DisplayScreen methodsFor: 'copying' stamp: 'jmv 6/27/2025 10:36:57' prior: 50336491!
          copyToDisableImmediateUpdates
	"Answer an instance that shares our pixel storage.
	This is useful to prevent the VM from immediately updating the host platform pixels the user actually sees,
	especially on platforms where #deferUpdates: answers ni, meaning it doesn't really support doing this.
	Flicking is possible. For this reason Morphic doesn't use this technique.
	Preferred technique is to use #deferredUpdatingDisplay and related methods.
	"
	^self shallowCopy! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 10:33:59' prior: 50336662!
                 newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen deferredUpdatingDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen forceDeferredToScreen: (rect merge: newRect).
			rect := newRect]].
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 10:34:20' prior: 50336701!
            newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen deferredUpdatingDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen forceDeferredToScreen: (rect merge: newRect).
			rect := newRect]].
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:34:42' prior: 50336515!
                        experimentsTowardsANewColorPalette
"
For UIs.
	TopLeft. Show 'selected' color.
	BottomLeft. For selected Hue, change Saturation and brightness.
	TopRight. For selected Luminance, change Hue and Chroma
	BottomRight. For selected Chroma, change Hue and Luminance.
Evaluate multiple times and see results:
	Color experimentsTowardsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width := 300.
height := 120.
selectedColor := Color random.
selectedHue := selectedColor hue.
selectedSaturation := selectedColor saturation.
selectedChroma := selectedColor chroma.
selectedV := selectedColor brightness.
selectedLuminance := selectedColor luminance.
"TopLeft. Show 'selected' color."
DisplayScreen deferredUpdatingDisplay getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.

0 to: height do: [ :y |
	v := 1.0 - (y / height).
	0 to: height do: [ :x |
		s := x / height.
		color := Color new setHue: selectedHue saturation: s brightness: v.
		DisplayScreen deferredUpdatingDisplay colorAt: x@(y+height) put: color
	].
	DisplayScreen forceDeferredToScreen: (0@y extent: height@y).
].
0 to: height do: [ :y | | c |
	v := 1.0 - (y / height).
	s := 1.0 - (y / height).
	c := s.
	0 to: width do: [ :x |
		h := x / width * 360.
		
		color := Color new setHue: h chroma: c luminance: selectedLuminance.
"		color := Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: s brightness: selectedV."
		DisplayScreen deferredUpdatingDisplay colorAt: x+height@y put: color.
		
		color := Color new setHue: h chroma: selectedChroma luminance: v.
"		color := Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: selectedSaturation brightness: v."
		DisplayScreen deferredUpdatingDisplay colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen forceDeferredToScreen: (0@y extent: width@y).
].! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:35:01' prior: 50336579!
                           showColorCube
	"Show a 12x12x12 color cube."
	"
	Color showColorCube
	"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				DisplayScreen deferredUpdatingDisplay fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
	DisplayScreen forceDeferredToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:35:24' prior: 50336593!
            showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w := DisplayScreen deferredUpdatingDisplay width // colorList size.
	r := 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		DisplayScreen deferredUpdatingDisplay fill: r fillColor: c.
		r := r translatedBy: w@0].
	DisplayScreen forceDeferredToScreen.! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:35:47' prior: 50336608!
                         showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"
	Color showHSVPalettes
	"

	| left top c |
	left := top := 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left := (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c := Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4).
				DisplayScreen deferredUpdatingDisplay fill: (left@top extent: 4@4) fillColor: c.

				c := Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4) + 50.
				DisplayScreen deferredUpdatingDisplay fill: (left@top extent: 4@4) fillColor: c]]].
	DisplayScreen forceDeferredToScreen.! !
!ProgressInitiationException methodsFor: 'exceptionDescription' stamp: 'jmv 6/27/2025 10:46:14' prior: 50335373 overrides: 16861277!
         defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame lastDrawTime |
	f := FontFamily defaultFamilyAndPointSize.
	h := f lineSpacing * 3//2.
	textWidth := (f widthOfString: progressTitle) + h.
	width := 150 max: textWidth.

	textForm := Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame := Rectangle center: aPoint extent: (width@h) roundedToEven.
	textFrame := `0@0` extent: width@h.
	textFrame := textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame := barFrame merge: textFrame.
	delta := outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame := barFrame translatedBy: delta.
	textFrame := textFrame translatedBy: delta.
	outerFrame := outerFrame translatedBy: delta.
	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame := barFrame insetBy: 2.
	textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
	DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
	DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
	DisplayScreen forceDeferredToScreen: outerFrame.
	lastDrawTime := Time localMillisecondClock.
	result := workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal := barVal ]
			ifNil: [
				currentVal := currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal := minVal ]].
		filledWidth := ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		Time localMillisecondClock - lastDrawTime > 100 ifTrue: [
			textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
			DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
			DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
			DisplayScreen deferredUpdatingDisplay fillGray: (barFrame topLeft + `2@2` extent: filledWidth@(h-4)).
			DisplayScreen forceDeferredToScreen: outerFrame.
			lastDrawTime := Time localMillisecondClock ]].
	UISupervisor ui ifNotNil: [ :ui | ui invalidateDisplayRect: outerFrame for: nil ].
	self resume: result! !
!Transcript class methodsFor: 'private' stamp: 'jmv 6/27/2025 10:28:48' prior: 50336641!
                             displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	(displayEngine isNil or: [
		displayEngine class ~= BitBltCanvasEngine]) ifTrue: [
			displayEngine := BitBltCanvasEngine toForm: DisplayScreen deferredUpdatingDisplay ].
	^ displayEngine! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/27/2025 10:44:05' prior: 50335328!
               display
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		DisplayScreen forceDeferredToScreen: bounds ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/27/2025 10:44:12' prior: 50335998!
     displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			DisplayScreen forceDeferredToScreen: damage ]]! !

MorphicCanvas removeSelector: #showAt:invalidRect:!

!methodRemoval: MorphicCanvas #showAt:invalidRect: stamp: 'Install-7294-DisplayScreen-deferredUpdatingDisplay-p3-JuanVuletich-2025Jun27-10h25m-jmv.003.cs.st 7/15/2025 11:02:25'!
showAt: pt invalidRect: updateRect
	| blt |
	blt := (BitBlt toForm: Display)
		sourceForm: form;
		combinationRule: Form over.
	blt sourceRect: updateRect;
		destOrigin: updateRect topLeft + pt;
		copyBits!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Transcript releaseClassCachedState!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7294-DisplayScreen-deferredUpdatingDisplay-p3-JuanVuletich-2025Jun27-10h25m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7294] on 30 June 2025 at 9:12:35 am'!
!Transcript class methodsFor: 'private' stamp: 'jmv 6/30/2025 09:11:45' prior: 50337431!
   displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	| deferredDisplay |
	deferredDisplay := DisplayScreen deferredUpdatingDisplay.
	(displayEngine isNil or: [ displayEngine class ~= BitBltCanvasEngine])
		ifTrue: [
			^ displayEngine := BitBltCanvasEngine toForm: DisplayScreen deferredUpdatingDisplay ].
	displayEngine destForm == deferredDisplay ifFalse: [
		displayEngine setDestForm: deferredDisplay ].
	^ displayEngine! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7295-DisplayScreen-deferredUpdatingDisplay-p4-JuanVuletich-2025Jun30-09h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7295] on 30 June 2025 at 3:39:23 pm'!
!ProgressInitiationException methodsFor: 'exceptionDescription' stamp: 'jmv 6/30/2025 15:37:07' prior: 50337355 overrides: 16861277!
                           defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame lastDrawTime |
	f := FontFamily defaultFamilyAndPointSize.
	h := f lineSpacing * 3//2.
	textWidth := (f widthOfString: progressTitle) + h.
	width := 150 max: textWidth.

	textForm := Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame := Rectangle center: aPoint extent: (width@h) roundedToEven.
	textFrame := `0@0` extent: width@h.
	textFrame := textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame := barFrame merge: textFrame.
	delta := outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame := barFrame translatedBy: delta.
	textFrame := textFrame translatedBy: delta.
	outerFrame := outerFrame translatedBy: delta.
	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame := barFrame insetBy: 2.
	textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
	DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
	DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
	DisplayScreen forceDeferredToScreen: outerFrame.
	lastDrawTime := Time localMillisecondClock.
	result := workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal := barVal ]
			ifNil: [
				currentVal := currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal := minVal ]].
		filledWidth := ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		(Time localMillisecondClock - lastDrawTime > 100 or: [
				currentVal = maxVal ]) ifTrue: [
			textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
			DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
			DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
			DisplayScreen deferredUpdatingDisplay fillGray: (barFrame topLeft + `2@2` extent: filledWidth@(h-4)).
			DisplayScreen forceDeferredToScreen: outerFrame.
			lastDrawTime := Time localMillisecondClock ]].
	UISupervisor ui ifNotNil: [ :ui | ui invalidateDisplayRect: outerFrame for: nil ].
	self resume: result! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7296-ProgressBar-showCompletionOfVeryFastOnes-JuanVuletich-2025Jun30-15h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7296] on 1 July 2025 at 11:06:26 am'!
!Process methodsFor: 'debugging' stamp: 'jmv 7/1/2025 09:59:25'!
effectiveProcess
	"If we are debugging a Process, simulating its execution as we step in the Debugger even if it is suspended, answer it.
	Otherwise answer self.
	See #evaluate:onBehalfOf:
	"

	^self environmentAt: #effectiveProcess ifAbsent: self! !
!Process methodsFor: 'debugging' stamp: 'jmv 7/1/2025 10:04:44'!
    evaluate: aBlock onBehalfOf: aProcess
	"Evaluate aBlock setting effectiveProcess to aProcess.
	Needed so #effectiveProcess gives the correct answer.
	See senders."

	| oldEffectiveProcess |
	aProcess == self ifTrue: [^ aBlock value]. "Optimization"
	
	oldEffectiveProcess := self environmentAt: #effectiveProcess ifAbsent: nil.
	self environmentAt: #effectiveProcess put: aProcess.
	^ aBlock ensure: [
		oldEffectiveProcess
			ifNotNil: [ self environmentAt: #effectiveProcess put: oldEffectiveProcess]
			ifNil: [ self environmentRemoveKey: #effectiveProcess ifAbsent: nil ]]! !
!Process methodsFor: 'testing' stamp: 'LM 10/10/2023 14:42'!
                               isInExternalCode
	"In a threaded VM, a Smalltalk Process may run a primitive in the background.
	Answer whether this is currently the case for this Process."

	"Special Object 41 (40 in VM) is the ProcessInExternalCodeTag, which is an empty LinkedList."
	^ myList == (Smalltalk specialObjectsArray at: 41)! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:13' prior: 16937258!
                   activateReturn: aContext value: value
	"Activate 'aContext return: value', so execution will return to aContext's sender"

	^Processor activeProcess
		evaluate: [suspendedContext := suspendedContext activateReturn: aContext value: value]
		onBehalfOf: self! !
!Process methodsFor: 'simulate execution' stamp: 'jmv 7/1/2025 10:10:00' prior: 16937275!
  complete: aContext
	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."

	| ctxt pair error |
	ctxt := suspendedContext.
	suspendedContext := nil. "disable this process while running its stack in active process below"
	pair := Processor activeProcess
		evaluate: [ctxt runUntilErrorOrReturnFrom: aContext]
		onBehalfOf: self.
	suspendedContext := pair first.
	error := pair second.
	error ifNotNil: [^ error signalerContext].
	^ suspendedContext! !
!Process methodsFor: 'simulate execution' stamp: 'eem 4/11/2017 12:03' prior: 16937295!
                 completeStep: aContext 
	"Resume self until aContext is on top, or if already on top, complete next step"

	| callee |
	self isTerminated ifTrue:
		[^ nil].
	self suspendedContext == aContext ifFalse:
		[^ self complete: (self calleeOf: aContext)].
	callee := self step.
	callee == aContext ifTrue: [^ callee].
	aContext isDead ifTrue: [^ self suspendedContext].  "returned"
	^ self complete: callee  "finish send"! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:19' prior: 16937358!
      popTo: aContext 
	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.
	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.
	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."

	self == Processor activeProcess ifTrue:
		[^self error: 'The active process cannot pop contexts'].
	^(self calleeOf: aContext)
		ifNil: [aContext]  "aContext is on top"
		ifNotNil:
			[:callee|
			 Processor activeProcess
				evaluate: [self return: callee value: callee receiver]
				onBehalfOf: self]! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:19' prior: 16937386!
           popTo: aContext value: aValue
	"Replace the suspendedContext with aContext, releasing all contexts 
	 between the currently suspendedContext and it."

	self == Processor activeProcess ifTrue:
		[^self error: 'The active process cannot pop contexts'].
	^(self calleeOf: aContext)
		ifNil: [aContext]  "aContext is on top"
		ifNotNil:
			[:callee|
			 Processor activeProcess
				evaluate: [self return: callee value: aValue]
				onBehalfOf: self]! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:13' prior: 16937418!
       return: aContext value: value
	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way.  See #popTo: comment and #runUntilErrorOrReturnFrom: for more details."

	suspendedContext == aContext ifTrue:
		[^Processor activeProcess
			evaluate: [suspendedContext := aContext return: value from: aContext]
			onBehalfOf: self].
	self activateReturn: aContext value: value.
	^self complete: aContext! !
!Process methodsFor: 'simulate execution' stamp: 'eem 9/7/2009 11:19' prior: 16937432!
        step

	^Processor activeProcess
		evaluate: [suspendedContext := suspendedContext step]
		onBehalfOf: self! !
!Process methodsFor: 'simulate execution' stamp: 'eem 3/15/2013 09:35' prior: 16937437!
                          step: aContext 
	"Resume self until aContext is on top, or if already on top, do next step"

	^Processor activeProcess
		evaluate:
			[self suspendedContext == aContext
				ifTrue: [suspendedContext := suspendedContext step]
				ifFalse: [self complete: (self calleeOf: aContext)]]
		onBehalfOf: self! !
!Process methodsFor: 'simulate execution' stamp: 'eem 9/7/2009 11:52' prior: 16937447!
                         stepToCallee
	"Step until top context changes"

	Processor activeProcess
		evaluate:
			[| ctxt |
			ctxt := suspendedContext.
			[ctxt == suspendedContext] whileTrue: [
				suspendedContext := suspendedContext step]]
		onBehalfOf: self.
	^suspendedContext! !
!Process methodsFor: 'simulate execution' stamp: 'jmv 7/1/2025 10:36:40' prior: 16937456!
  stepToHome: requestedContext
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| requestedHome |
	Processor activeProcess
		evaluate:
			[
				requestedHome := requestedContext home.
				[
					suspendedContext := suspendedContext step.
				
					"We reached the home context of the block we are doing [Through] on."
					suspendedContext home == requestedHome ifTrue: [
						^suspendedContext ].
				
					"But if the requestedHome is dead, meaning that we'll never reach back there,
					stop when we get back to where [Through] was requested."
					requestedHome isDead ifTrue: [
						suspendedContext = requestedContext ifTrue: [
							^suspendedContext ]].
				
					"There's nowhere to continue stepping into. Don't do it."
					(suspendedContext sender isNil or: [suspendedContext sender isDead]) ifTrue: [
						^suspendedContext ].
				
					self ifSuspendedContextIsUnhandledErrorDo: [ :anError |
						anError signalerContext ifNotNil: [ :unhandledErrorSignalerContext |
							self completeStepUpTo: unhandledErrorSignalerContext.
							"Give a debugger a chance to update its title to reflect the new exception"
							 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
							^unhandledErrorSignalerContext ]]
				
				] repeat.
			]
		onBehalfOf: self.! !
!Process methodsFor: 'simulate execution' stamp: 'eem 9/7/2009 11:10' prior: 16937505!
           stepToSendOrReturn

	^Processor activeProcess
		evaluate: [suspendedContext := suspendedContext stepToSendOrReturn]
		onBehalfOf: self! !
!Process methodsFor: 'private' stamp: 'jmv 7/1/2025 10:29:12' prior: 16937645!
       resolvePendingQuickReturns
	| method |	
	method := suspendedContext method.
	method isQuick ifTrue: [
		Processor activeProcess
			evaluate: [suspendedContext := suspendedContext callPrimitive: method primitive]
			onBehalfOf: self ]! !
!Process methodsFor: 'changing suspended state' stamp: 'eem 3/30/2017 15:44' prior: 16937408!
                     restartTopWith: method
	"Rollback top context and replace with new method.  Assumes self is suspended"

	method isQuick 
		ifTrue: [self popTo: suspendedContext sender]
		ifFalse:
			[suspendedContext method frameSize >= method frameSize
				ifTrue: [suspendedContext privRefreshWith: method]
				ifFalse:
					[self assert: suspendedContext isExecutingBlock not.
					 suspendedContext := MethodContext
												sender: suspendedContext sender
												receiver: suspendedContext receiver
												method: method
												arguments: ((1 to: method numArgs) collect:
																[:i| suspendedContext tempAt: i])]].
! !
!Process class methodsFor: 'instance creation' stamp: 'jmv 7/1/2025 10:40:19' prior: 16937852!
     forContext: aMethodContext priority: anInteger 
	"Answer an instance of me that has suspended aContext at priority anInteger."

	| newProcess |
	newProcess := self new.
	newProcess priority: anInteger.
	newProcess suspendedContext: aMethodContext.
	^newProcess! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7297-Process-effectiveProcess-JuanVuletich-2025Jun30-17h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7296] on 1 July 2025 at 11:10:00 am'!
!Process methodsFor: 'simulate execution' stamp: 'jmv 7/1/2025 11:09:51'!
           isSimulatingAnotherProcess
	"Answer true if we are a debugger process, simulating the execution of another."

	^self effectiveProcess ~~ self! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7298-Process-isSimulatingAnotherProcess-JuanVuletich-2025Jul01-11h06m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7296] on 1 July 2025 at 11:14:01 am'!
!VectorEngine class methodsFor: 'instance creation' stamp: 'jmv 7/1/2025 11:13:53' prior: 17009452!
                              onForm: aForm subPixelAntiAliasing: aBoolean
	"nil means use default kind of anti aliasing
	Use the VectorEnginePlugin if available."

	| engineClass doSubPixelAntiAliasing |
	self hasSubclasses
		ifFalse: [
			engineClass := self ]
		ifTrue: [
			doSubPixelAntiAliasing := aBoolean ifNil: [
				"Assume high resolution implies high DPI"
				Display width <= 1920 ].
			engineClass := (VectorEngineWithPlugin isPluginAvailable and: [
					"VectorEnginePlugin calls can not be reliably simulated in the Debugger because the plugin holds static state."
					Processor activeProcess isSimulatingAnotherProcess not ])
				ifTrue: [ doSubPixelAntiAliasing
					ifTrue: [VectorEngineWithPluginSubPixel]
					ifFalse: [VectorEngineWithPluginWholePixel]]
				ifFalse: [ doSubPixelAntiAliasing
					ifTrue: [VectorEngineSubPixel]
					ifFalse: [VectorEngineWholePixel]]].
		^engineClass new initializeOnForm: aForm.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7299-DontUseVectorPluginInSimulatedCode-JuanVuletich-2025Jul01-11h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7299] on 1 July 2025 at 12:27:24 pm'!
!ContextPart methodsFor: 'private' stamp: 'jmv 7/1/2025 12:26:54' prior: 16839077!
                  doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and
	 arguments are given as arguments to this message. If successful, push result and return
	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes
	 execution needs to be intercepted and simulated to avoid execution running away."

	| value |
	"Test for unsimulatable side effects (that is, code that will be triggered in the image outside of the simulator range). This includes simulation guards, which are traditionally flagged using primitive 19 (a null primitive that doesn't do anything), as well as certain control primitives that might trigger code on other processes. If a side effect is detected, raise a warning to give the user/client a chance to cancel or virtualize the operation."
	"#(19 87) do: [:primitive | self systemNavigation browseAllSelect: [:m | m primitive = primitive]]"
	(primitiveIndex = 19 "simulationGuard" or: [primitiveIndex = 87 "primitiveResume"]) ifTrue:
		[[(SimulationSideEffectWarning forPrimitive: primitiveIndex)
			context: self method: meth receiver: receiver arguments: arguments;
			signalIfSkipped: [^ self]]
				ifCurtailed:
					[self push: receiver "Cheap fix of the context's internal state. Note that unwinding the receiver -- so that the next step would invoke the primitive again -- would be challenging due to to the variety of senders to this method."]].
	
	((primitiveIndex between: 201 and: 222)
	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:
		[(primitiveIndex = 206
		  or: [primitiveIndex = 208]) ifTrue:						"[Full]BlockClosure>>valueWithArguments:"
			[^receiver simulateValueWithArguments: arguments first caller: self].
		 ((primitiveIndex between: 201 and: 209)			 "[Full]BlockClosure>>value[:value:...]"
		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "[Full]BlockClosure>>valueNoContextSwitch[:]"
			[^receiver simulateValueWithArguments: arguments caller: self]].

	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"
		[| selector |
		selector := arguments at: 1 ifAbsent:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: arguments allButFirst].
	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"
		[| selector args |
		arguments size = 2 ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		selector := arguments first.
		args := arguments second.
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: args].
	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"
		[| rcvr selector args superclass |
		arguments size
			caseOf: {
				[3] -> [
					rcvr := receiver.
					selector := arguments first.
					args := arguments second.
					superclass := arguments third].
				[4] -> ["mirror primitive"
					rcvr := arguments first.
					selector := arguments second.
					args := arguments third.
					superclass := arguments fourth] }
			otherwise: [^ self class primitiveFailTokenFor: #'bad number of arguments'].
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		((self objectClass: rcvr) includesBehavior: superclass) ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: rcvr with: args lookupIn: superclass].

	"Mutex>>primitiveEnterCriticalSectionOnBehalfOf:
	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf:"
	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:
		[| effective |
		 effective := Processor activeProcess.
		 value := primitiveIndex = 186
					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]
					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].
		 ^(self isPrimFailToken: value)
			ifTrue: [value]
			ifFalse: [self push: value]].
	
	(primitiveIndex = 188 or: [primitiveIndex = 189]) ifTrue:
		[| n args methodArg thisReceiver |
		 primitiveIndex caseOf:
			{[188 "primitiveExecuteMethodArgsArray"] ->
				["Object>>withArgs:executeMethod:
				  CompiledMethod class>>receiver:withArguments:executeMethod:
				  VMMirror>>ifFail:object:with:executeMethod: et al"
				 ((n := arguments size) between: 2 and: 4) ifFalse:
					[^self class primitiveFailTokenFor: #'unsupported operation'].
				 ((self objectClass: (args := arguments at: n - 1)) == Array
				  and: [(self objectClass: (methodArg := arguments at: n)) includesBehavior: CompiledMethod]) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 thisReceiver := arguments at: n - 2 ifAbsent: [receiver]].
			 [189 "primitiveExecuteMethod"] ->
				["Object>>executeMethod:
				  Object>>with:...executeMethod:"
				 (arguments size > 0) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 ((self objectClass: (methodArg := arguments atLast: 1)) includesBehavior: CompiledMethod) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 args := arguments allButLast.
				 thisReceiver := receiver]}.
		 methodArg numArgs = args size ifFalse:
			[^self class primitiveFailTokenFor: #'bad number of arguments'].
		 methodArg primitive > 0 ifTrue:
			[methodArg isQuick ifTrue:
				[^self push: (methodArg valueWithReceiver: thisReceiver arguments: args)].
			 ^self doPrimitive: methodArg primitive method: methodArg receiver: thisReceiver args: args].
		 ^self
			activateMethod: methodArg
			withArgs: args
			receiver: thisReceiver].

	primitiveIndex = 118 ifTrue: "[receiver:]tryPrimitive:withArgs:; avoid recursing in the VM"
		[(arguments size = 3
		  and: [(self objectClass: arguments second) == SmallInteger
		  and: [(self objectClass: arguments last) == Array]]) ifTrue:
			[^self doPrimitive: arguments second method: meth receiver: arguments first args: arguments last].
		 (arguments size = 2
		 and: [(self objectClass: arguments first) == SmallInteger
		 and: [(self objectClass: arguments last) == Array]]) ifFalse:
			[^self class primitiveFailTokenFor: -3].
		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].

	value := primitiveIndex = 120 "FFI method"
				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]
				ifFalse:
					[primitiveIndex = 117 "named primitives"
						ifTrue: [
							"primDecl := meth literalAt: 1.
							moduleNameOrNil := primDecl at: 1.
							primitiveName := primDecl at: 2."
							(#(VectorEnginePlugin) statePointsTo: ((meth literalAt: 1) at: 1))
								ifTrue: [self class primitiveFailTokenFor: 1]
								ifFalse: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments].
							]
						ifFalse: "should use self receiver: receiver tryPrimitive: primitiveIndex withArgs: arguments but this is only in later VMs (and appears to be broken)"
							[receiver tryPrimitive: primitiveIndex withArgs: arguments]].

	^(self isPrimFailToken: value)
		ifTrue: [value]
		ifFalse: [self push: value]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7300-FailSimulatedPrimitivesForVectorEngine-JuanVuletich-2025Jul01-12h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7300] on 1 July 2025 at 4:49:08 pm'!
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 7/1/2025 16:44:24' prior: 17018832!
                           checkForNewScreenSize
	"Check whether the screen size has changed and if so take appropriate actions"

	| newScaleFactor e p needsNewUIProcessAndCanvas |

	"Linux and MacOS VMs continuously update #actualScreenSize while the user is resizing the OS window.
	Try to avoid reallocation of Display until the user is done with that.
	For that, wait until a real event happens inside Cuis. (This requires the user to move the mouse back into Cuis).
	Or use a timer, and do it no more often than every quarter a second, and only if the resize finishes/pauses for that time."
	DisplayScreen isDisplayExtentOk ifFalse: [
		Smalltalk platformName = 'Win32' ifFalse: [
			self valueOfProperty: #startForNewDisplayTimeout ifAbsentPut: [Time localMillisecondClock].
			self valueOfProperty: #newDisplayOldExtent ifAbsentPut: [DisplayScreen actualScreenSize].
			lastCycleHadAnyEvent ifFalse: [
				(self valueOfProperty: #newDisplayOldExtent) = DisplayScreen actualScreenSize ifFalse: [
					"If user still resizing, restart timer: wait until the user finishes resizing."
					self setProperty: #startForNewDisplayTimeout toValue: Time localMillisecondClock.
					self setProperty: #newDisplayOldExtent toValue: DisplayScreen actualScreenSize].
				Time localMillisecondClock - (self valueOfProperty: #startForNewDisplayTimeout) < 250 ifTrue: [
					^self ]].
			self removeProperty: #startForNewDisplayTimeout.
			self removeProperty: #newDisplayOldExtent ]].

	needsNewUIProcessAndCanvas := false.
	DisplayScreen isDisplayExtentOk ifFalse: [
		"''print. {DateAndTime now. 'Smalltalk Display:'. Display extent. 'os display:'. DisplayScreen actualScreenSize} print."
		"If host OS scale factor has changed, try to recover our previous Display extent"
		newScaleFactor := DisplayScreen hostOSScaleFactor.
		newScaleFactor = ScaleFactor ifFalse: [
			ScaleFactor := newScaleFactor.
			e := DisplayScreen hostOSWindowExtent ifNotNil: [ :ee |
				(ee * ScaleFactor - DisplayScreen actualScreenSize + Display extent) truncated ].
			p := DisplayScreen hostOSWindowPosition.
			e ifNotNil: [
				"{'New ScaleFactor'. ScaleFactor. 'Set os display to:'. e} print."
				DisplayScreen hostOSWindowExtent: e].
			p ifNotNil: [DisplayScreen hostOSWindowPosition: p].
		].
		"When moving the Cuis window, for instance, between a laptop screen with ScaleFactor=2.0 and an external screen with
		ScaleFactor=1.0, usually the #hostOSWindowExtent: already left us with isDisplayExtentOk, so asking again is in order."
		DisplayScreen isDisplayExtentOk ifFalse: [
			"This allocates new memory for Display and is critical."
			needsNewUIProcessAndCanvas := true.
			"This may help with memory fragmentation issues possibly making new display allocation fail."
			canvas unpinAndFreeMemory.
			DisplayScreen setupDisplay ]].
	(needsNewUIProcessAndCanvas or: [canvas isConsistentWithTarget not])
		ifTrue: [
			self whenUIinSafeState: [ Cursor defaultCursor activateCursor ].
			"The current canvas is not consistent with Display, and therefore can no longer be used. A new one is required.
			Freeeing the memory it uses may help with memory fragmentation issues possibly making new canvas allocation fail.
			(If there is not enough free memory for VectorCanvas and engine, use a BitBltCanvas, see #getMainCanvas)"
			canvas unpinAndFreeMemory.
			"Create a new UI process, including a new canvas consistent with updated Display."
			UISupervisor spawnNewMorphicProcessFor: self createNewCanvas: true.
			"Terminate the current process (the old UI process). This is needed because the old canvas can no longer be used:
			A canvas + vector engine inconsistent with Display will cause invalid memory accesses, crashing the system."
			Processor terminateActive.
			].! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 7/1/2025 16:27:55' prior: 16878383!
            processEventQueue
	"Process user input events from the local input devices.
	Answer true if any event was handled (but ignore MouseMove)"

	| evt evtBuf type hadAny mcs hadAnyMouseEvent hadAnyMouseMoveEvent |
	mcs := mouseClickState.
	hadAny := false.
	hadAnyMouseEvent := false.
	hadAnyMouseMoveEvent := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		type := evtBuf first.
		evt := self createEventFrom: evtBuf ofType: type.
		evt ifNotNil: [
			"Finally, handle it. But process only up to one mouseMove per cycle. Discard the rest."
			(evt isMouseMove and: [ hadAnyMouseMoveEvent ]) ifFalse: [
				self startEventDispatch: evt.
				(evt isMouse or: [ evt isKeyboard ]) ifTrue: [
					hadAny := true ].
				evt isMouse ifTrue: [
					hadAnyMouseEvent := true.
					evt isMouseMove ifTrue: [
						hadAnyMouseMoveEvent := true ]]]]].
	hadAnyMouseEvent ifFalse: [
		mcs 
			ifNotNil: [ 
				"No mouse events during this cycle. Make sure click states time out accordingly"
				mcs
					handleEvent: lastMouseEvent asMouseMove
					from: self ]].
	^hadAny! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7301-checkForNewScreenSize-tweaks-YourName-2025Jul01-16h48m-mv.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 25 June 2025 at 10:07:32 am'!
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 6/25/2025 10:02:13'!
                              undeclaredReferences
	"
	Smalltalk undeclaredReferences
	"
	| undeclaredReferences |
	
	undeclaredReferences := Dictionary new.
	self cleanOutUndeclared.
	Undeclared associationsDo: [ :undeclaredAssoc |
		undeclaredReferences
			at: undeclaredAssoc key
			put: (self allCallsOn: undeclaredAssoc) ].

	^undeclaredReferences! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 6/25/2025 10:00:33' prior: 16971633!
                            browseUndeclaredReferences
	"
	Smalltalk browseUndeclaredReferences
	"
	| undeclaredReferences |
	
	undeclaredReferences := self undeclaredReferences.
	undeclaredReferences ifEmpty: [
		 ^(PopUpMenu labels: ' OK ') startUpWithCaption: 'There are no Undeclared at all' ].
	
	undeclaredReferences keysAndValuesDo: [ :undeclared :references |
		self
			browseMessageList: references
			name: 'References to Undeclared: ', undeclared printString ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7302-browseUndeclaredReferencesDecoupling-HernanWilkinson-2025Jun25-09h23m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7294] on 27 June 2025 at 2:25:24 pm'!

Smalltalk renameClassNamed: #LayoutSpec as: #LayoutSizeSpec!

!classRenamed: #LayoutSpec as: #LayoutSizeSpec stamp: 'Install-7303-LayoutSpec-renameAs-LayoutSizeSpec-2025Jun27-14h01m-jmv.001.cs.st 7/15/2025 11:02:25'!
Smalltalk renameClassNamed: #LayoutSpec as: #LayoutSizeSpec!
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 6/27/2025 14:24:58' prior: 16930554!
                         layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec ! !
!BoxMorph methodsFor: 'layout-properties' stamp: 'jmv 6/27/2025 14:24:58' prior: 16796867 overrides: 50338423!
                            layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec keepMorphExtent.
	layoutSpec morph: self.

	^ layoutSpec! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896534!
   addAdjusterAndMorph: aMorph fixedHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addAdjusterAndMorph: aMorph layoutSpec: (LayoutSizeSpec fixedHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896552!
       addAdjusterAndMorph: aMorph proportionalHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addAdjusterAndMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896561!
                         addAdjusterAndMorph: aMorph proportionalWidth: aNumber
	"Convenience method.
	Add others as necessary."
	self addAdjusterAndMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalWidth: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896570!
                           addMorph: aMorph fixedHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec fixedHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896578!
                             addMorph: aMorph fixedWidth: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec fixedWidth: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896586!
                               addMorph: aMorph proportionalHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896594!
               addMorph: aMorph proportionalWidth: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalWidth: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896602!
                 addMorphKeepMorphHeight: aMorph
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec new useMorphHeight)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896610!
     addMorphUseAll: aMorph
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: LayoutSizeSpec useAll! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897126!
                           addAdjusterMorph
	"So the user can adjust layout"
	"twekear para ui grande..."

	| thickness |
	thickness := Theme current layoutAdjusterThickness.

	direction == #horizontal ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedWidth: thickness) ].

	direction == #vertical ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedHeight: thickness)]! !
!LayoutMorph methodsFor: 'layout in owner' stamp: 'jmv 6/27/2025 14:24:58' prior: 16897214 overrides: 50338435!
      layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec ! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:58' prior: 16897274!
                example1
"
	self example1
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897340!
                example10
"
	self example10 openInWorld
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:58' prior: 16897407!
     example101VG
"
	self example101VG
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897466!
        example11
"
	self example11
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897534!
                               example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897581!
           example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897641!
      example2
	"
	self example2
	"
	| pane row |
	pane := (LayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897672!
                    example20
"
	self example20
"
| column |

column := (LayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897695!
 example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897737!
                  example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897808!
   exampleEdgesColumn
	"Show 2 cases :1 useEdgeSpace true and 1 false"
	" self exampleEdgesColumn "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newColumn :: padding: (120 @ 40);  gap: 20.
	noEdge := self newColumn ::  padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 200; proportionalHeight: 0.8 minimum: 200.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 200; proportionalHeight: 0.5 minimum: 200.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897843!
                  exampleEdgesRow
	"Show 2 cases: 1 useEdgeSpace true and 1 false"
	" self exampleEdgesRow "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newRow :: padding: (120 @ 40);  gap: 20.
	noEdge := self newRow :: padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 100; proportionalHeight: 0.8 minimum: 100.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 100; proportionalHeight: 0.5 minimum: 100.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 6/27/2025 14:24:57' prior: 16983113 overrides: 16896737!
          initialize
	super initialize.
	viewBox := LayoutMorph newRow color: self defaultColor.
	self
		addMorph: (clock := UpdatingLabelMorph initializedInstance)
		layoutSpec:  (LayoutSizeSpec morphWidthProportionalHeight: 0.5).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSizeSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			offAxisEdgeWeight: #rightOrBottom).
	viewBox separation: self defaultHeight // 8.
	self setBalloonText: [ 
		'About this system:' bold, `String newLineString`,
		Smalltalk systemInformationString ].
	clock
		setProperty: #handlesMouseDown: toValue: true;
		setProperty: #'mouseButton1Down:localPosition:' 
		toValue: [ :evt : pos | | menu taskbarEdge point | 
			self runningWorld ifNotNil: [ :w |
				taskbarEdge := self positionInWorld y.
				menu := (Preferences at: #worldMenu) getMenuIn: w at: w activeHand.	
				menu hide.
				w addMorph: menu. ": Otherwise we do not have a proper extent"
				point := 0 @ (taskbarEdge - menu extentInWorld y).
				menu popUpAt: point allowKeyboard: false ] ]! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/27/2025 14:24:57' prior: 50332073!
                          addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preferences at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW := Theme current titleBarButtonsExtent x.
	closeButton := PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; noButtonShape.
	pinButton := PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; noButtonShape.
	w := (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + (buttonHW*2).
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW * 12 // 10);
			color: `Color transparent`;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//10;
			addMorph: (closeButton layoutSpec: (LayoutSizeSpec fixedWidth: buttonHW fixedHeight: buttonHW));
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 6/27/2025 14:24:57' prior: 16825667!
                        buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout updateReqButton |
	requirements := PluggableListMorph
		withModel: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
		
	deleteReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete')
							setBalloonText: 'Remove selected Feature requirement'.
	deleteReqButton color: self widgetsColor.
	updateReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #updateSelectedRequirement 
							label: 'update')
							setBalloonText: 'Update requirement to current Feature revision'.
	updateReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newRow.
	buttonLayout 
		addMorph: deleteReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter;
		addMorph: updateReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.8
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #leftOrTop);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.2 
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #rightOrBottom);
		color: `Color transparent`;
		yourself
		! !
!LayoutSizeSpec class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 14:24:57' prior: 16898301!
   fixedWidth: aNumber fixedHeight: otherNumber
	^ LayoutSizeSpec new
		fixedWidth: aNumber;
		fixedHeight: otherNumber! !
!LayoutSizeSpec class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 14:24:57' prior: 16898308!
 fixedWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	^ LayoutSizeSpec new
		fixedWidth: aNumber;
		fixedHeight: otherNumber;
		offAxisEdgeWeight: aSymbolOrNumber! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7303-LayoutSpec-renameAs-LayoutSizeSpec-2025Jun27-14h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7294] on 27 June 2025 at 2:25:55 pm'!

Object subclass: #LayoutSpec
	instanceVariableNames: 'morph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutSpec category: #'Morphic-Layouts' stamp: 'Install-7304-LayoutSpec-create-JuanVuletich-2025Jun27-14h25m-jmv.001.cs.st 7/15/2025 11:02:26'!
Object subclass: #LayoutSpec
	instanceVariableNames: 'morph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7304-LayoutSpec-create-JuanVuletich-2025Jun27-14h25m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7294] on 27 June 2025 at 2:26:22 pm'!

LayoutSpec subclass: #LayoutSizeSpec
	instanceVariableNames: 'fixedWidth fixedHeight offAxisEdgeWeight proportionalWidth proportionalHeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutSizeSpec category: #'Morphic-Layouts' stamp: 'Install-7305-LayoutSizeSpec-subclassOf-LayoutSpec-2025Jun27-14h25m-jmv.001.cs.st 7/15/2025 11:02:26'!
LayoutSpec subclass: #LayoutSizeSpec
	instanceVariableNames: 'fixedWidth fixedHeight offAxisEdgeWeight proportionalWidth proportionalHeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7305-LayoutSizeSpec-subclassOf-LayoutSpec-2025Jun27-14h25m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7297] on 27 June 2025 at 2:34:19 pm'!
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 6/27/2025 14:33:50'!
    morph
	"For #showHalo"
	^ morph! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 6/27/2025 14:33:57'!
                        morph: aMorph
	morph := aMorph! !

LayoutSizeSpec removeSelector: #morph!

!methodRemoval: LayoutSizeSpec #morph stamp: 'Install-7306-LayoutSpec-morphAccessors-JuanVuletich-2025Jun27-14h32m-jmv.001.cs.st 7/15/2025 11:02:26'!
morph
	"For #showHalo"
	^ morph!

LayoutSizeSpec removeSelector: #morph:!

!methodRemoval: LayoutSizeSpec #morph: stamp: 'Install-7306-LayoutSpec-morphAccessors-JuanVuletich-2025Jun27-14h32m-jmv.001.cs.st 7/15/2025 11:02:26'!
morph: aMorph
	morph := aMorph!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7306-LayoutSpec-morphAccessors-JuanVuletich-2025Jun27-14h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7300] on 30 June 2025 at 10:19:15 am'!
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:18:45'!
             initializeColumn

	self initialize.

	gap := self defaultGap.
	axisEdgeWeight := 0.0.
	doAdoptWidgetsColor := false.
	self beColumn.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:18:34'!
             initializeRow

	self initialize.

	gap := self defaultGap.
	axisEdgeWeight := 0.0.
	doAdoptWidgetsColor := false.
	self beRow.! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 15:16:07' prior: 16897265!
                          newColumn
	^self basicNew initializeColumn! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 15:16:12' prior: 16897270!
              newRow
	^self basicNew initializeRow! !

LayoutMorph removeSelector: #initialize!

!methodRemoval: LayoutMorph #initialize stamp: 'Install-7307-LayoutMorph-Refactor-JuanVuletich-2025Jun30-10h15m-jmv.001.cs.st 7/15/2025 11:02:26'!
initialize
	super initialize.
	gap := self defaultGap.
	axisEdgeWeight := 0.0.
	doAdoptWidgetsColor := false.!

LayoutMorph removeSelector: #direction:!

!methodRemoval: LayoutMorph #direction: stamp: 'Install-7307-LayoutMorph-Refactor-JuanVuletich-2025Jun30-10h15m-jmv.001.cs.st 7/15/2025 11:02:26'!
direction: horizOrVert

	direction := horizOrVert!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7307-LayoutMorph-Refactor-JuanVuletich-2025Jun30-10h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7297] on 27 June 2025 at 2:51:16 pm'!

Object subclass: #Layout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #Layout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:26'!
Object subclass: #Layout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

Layout subclass: #FormLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #FormLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:26'!
Layout subclass: #FormLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!FormLayout commentStamp: '<historical>' prior: 0!
                              Inspired by https://archive.eclipse.org/eclipse/downloads/documentation/2.0/html/plugins/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormLayout.html!

Layout subclass: #LinearLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:26'!
Layout subclass: #LinearLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LinearLayout subclass: #ColumnLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #ColumnLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:26'!
LinearLayout subclass: #ColumnLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LinearLayout subclass: #RowLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #RowLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:26'!
LinearLayout subclass: #RowLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7301] on 30 June 2025 at 10:32:15 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:26'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayout category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:26'!
Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/27/2025 15:05:35'!
                   gap: aNumber axisEdgeWeight: aNumberOrNil
	gap := aNumber.
	axisEdgeWeight := aNumberOrNil.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:29:04' prior: 16896696!
      beColumn
	"Establish the major layout axis, with default edge weight" 
	direction := #vertical.
	axisEdgeWeight ifNil: [self axisEdgeWeight: #center].
	layout := ColumnLayout new.
	layout gap: gap axisEdgeWeight: axisEdgeWeight.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:29:09' prior: 16896704!
      beRow
	"Establish the major layout axis, with default edge weight" 
	direction := #horizontal.
	axisEdgeWeight ifNil: [self axisEdgeWeight: #rowLeft].
	layout := RowLayout new.
	layout gap: gap axisEdgeWeight: axisEdgeWeight.
	self layoutSubmorphs.! !

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:26'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayout category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:26'!
Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	LayoutMorph allSubInstancesDo: [ :lm | | l |
		l := lm isRow ifTrue: [ RowLayout new ] ifFalse: [ ColumnLayout new ].
		l gap: lm gap axisEdgeWeight: lm axisEdgeWeight.
		lm instVarNamed: 'layout' put: l ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7302] on 30 June 2025 at 11:08:05 am'!
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:01:21'!
                    axisEdgeWeight
	^axisEdgeWeight! !
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 10:55:12'!
                      axisEdgeWeight: aNumberOrNil
	axisEdgeWeight := aNumberOrNil.! !
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:05:20'!
                        gap
	^gap! !
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 10:46:07'!
            gap: aNumber
	gap := aNumber! !
!ColumnLayout methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:56:22' overrides: 16940323!
initialize
	gap := 0.
	axisEdgeWeight := 0.5. "#center"! !
!RowLayout methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:56:34' overrides: 16940323!
        initialize
	gap := 0.
	axisEdgeWeight := 0.0. "#rowLeft"! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:04:39' prior: 16896332!
              axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the 	 	 LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			(self direction = #horizontal) 
				ifTrue: [ "Row"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #rowLeft ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #rowRight ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Row: ', aSymbolOrNumber printString ].
				]
				ifFalse: [ "vertical => Column"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #columnTop ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #columnBottom ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Column: ', aSymbolOrNumber printString ].
				]
		].
	layout axisEdgeWeight: edgeWeight.
	self layoutSubmorphs! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:06:53' prior: 16896397!
gap: aNumber

	layout gap = aNumber ifFalse: [
		self adjustExtentFor: [
			layout gap: aNumber ]].
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2025 11:06:05' prior: 16896659!
             minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	(self direction = #vertical)
		ifTrue: [ "Column"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"use maximum width across submorphs"
				width := width max: mle x.
				"sum up submorph heights, including separation between them"
				height := height + mle y + layout gap.
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"sum up submorphs width, include gap"
				width := width + mle x + layout gap.
				"use maximum height across submorph"
				height := height max: mle y.
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:04:49' prior: 50339587!
                         beColumn
	"Establish the major layout axis, with default edge weight" 
	direction := #vertical.
	layout := ColumnLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:04:45' prior: 50339598!
                beRow
	"Establish the major layout axis, with default edge weight" 
	direction := #horizontal.
	layout := RowLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:06:24' prior: 50339416!
                    initializeColumn

	self initialize.

	doAdoptWidgetsColor := false.
	self beColumn.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:06:20' prior: 50339423!
              initializeRow

	self initialize.

	doAdoptWidgetsColor := false.
	self beRow.! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:05:29' prior: 16896892!
                            layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * layout gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + layout gap.
	].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:05:36' prior: 16896935!
    layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * layout gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + layout gap.
	].! !

LayoutMorph removeSelector: #gap!

!methodRemoval: LayoutMorph #gap stamp: 'Install-7310-gap-axisEdgeWeight-toLayoutObject-2025Jun30-10h59m-jmv.002.cs.st 7/15/2025 11:02:26'!
gap
	^gap!

LayoutMorph removeSelector: #axisEdgeWeight!

!methodRemoval: LayoutMorph #axisEdgeWeight stamp: 'Install-7310-gap-axisEdgeWeight-toLayoutObject-2025Jun30-10h59m-jmv.002.cs.st 7/15/2025 11:02:26'!
axisEdgeWeight

	^ axisEdgeWeight ifNil: [
		direction == #horizontal
			ifTrue: [0.0]
			ifFalse: [0.5]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7310-gap-axisEdgeWeight-toLayoutObject-2025Jun30-10h59m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7303] on 30 June 2025 at 11:44:48 am'!
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:24:40'!
     heightsFor: visibleSubs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| numSubs scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutHeightMin |
		sm := visibleSubs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec privateProportionalHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:23:10'!
                            layoutMorphs: visibleSubmorphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| gapCount heights heightToAllocate leftOver y cache |

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:23:46'!
        offAxisWidthFor: aMorph within: availableWidth minLayoutExtentCache: cache
	"Answer width for a single morph -- offAxis calculation for a Column"

	^ (availableWidth * aMorph layoutSpec proportionalLayoutWidth)
						 	max: (aMorph minimumLayoutExtent: cache) x.
! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:24:03'!
                 offAxisXOffsetFor: aMorph within: availableWidth
	"Answer x offset for a single morph -- offAxis calculation for a Column"

	^ availableWidth * aMorph layoutSpec offAxisEdgeWeight. ! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:17:05'!
      layoutMorphs: visibleSubmorphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| gapCount widths widthToAllocate leftOver x cache |

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:19:33'!
               offAxisHeightFor: aMorph within: availableHeight minLayoutExtentCache: cache
	"Answer height for a single morph -- offAxis calculation for a Row"
	
	^(availableHeight * aMorph layoutSpec proportionalLayoutHeight)
							 max: (aMorph minimumLayoutExtent: cache) y.! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:19:58'!
                   offAxisYOffsetFor: aMorph within: availableHeight
	"Answer y offset for a single morph -- offAxis calculation for a Row"
	
	^ availableHeight * aMorph layoutSpec offAxisEdgeWeight! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:18:40'!
        widthsFor: visibleSubs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| numSubs scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutWidthMin |
		sm := visibleSubs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec privateProportionalWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:39:09' prior: 50334572!
                      layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs |
	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order") ifEmpty: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layout layoutMorphs: visibleSubmorphs in: self layoutBounds.
	self layoutNeeded: false.! !

LayoutMorph removeSelector: #widthsFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #widthsFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
widthsFor: visibleSubs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| numSubs scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutWidthMin |
		sm := visibleSubs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec privateProportionalWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths!

LayoutMorph removeSelector: #offAxisYOffsetFor:within:!

!methodRemoval: LayoutMorph #offAxisYOffsetFor:within: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
offAxisYOffsetFor: aMorph within: availableHeight
	"Answer y offset for a single morph -- offAxis calculation for a Row"
	
	^ availableHeight * aMorph layoutSpec offAxisEdgeWeight!

LayoutMorph removeSelector: #offAxisWidthFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #offAxisWidthFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
offAxisWidthFor: aMorph within: availableWidth minLayoutExtentCache: cache
	"Answer width for a single morph -- offAxis calculation for a Column"

	^ (availableWidth * aMorph layoutSpec proportionalLayoutWidth)
						 	max: (aMorph minimumLayoutExtent: cache) x.
!

LayoutMorph removeSelector: #offAxisHeightFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #offAxisHeightFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
offAxisHeightFor: aMorph within: availableHeight minLayoutExtentCache: cache
	"Answer height for a single morph -- offAxis calculation for a Row"
	
	^(availableHeight * aMorph layoutSpec proportionalLayoutHeight)
							 max: (aMorph minimumLayoutExtent: cache) y.!

LayoutMorph removeSelector: #offAxisXOffsetFor:within:!

!methodRemoval: LayoutMorph #offAxisXOffsetFor:within: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
offAxisXOffsetFor: aMorph within: availableWidth
	"Answer x offset for a single morph -- offAxis calculation for a Column"

	^ availableWidth * aMorph layoutSpec offAxisEdgeWeight. !

LayoutMorph removeSelector: #layoutSubmorphsHorizontallyIn:!

!methodRemoval: LayoutMorph #layoutSubmorphsHorizontallyIn: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * layout gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + layout gap.
	].!

LayoutMorph removeSelector: #layoutSubmorphsVerticallyIn:!

!methodRemoval: LayoutMorph #layoutSubmorphsVerticallyIn: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * layout gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + layout gap.
	].!

LayoutMorph removeSelector: #heightsFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #heightsFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:26'!
heightsFor: visibleSubs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| numSubs scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutHeightMin |
		sm := visibleSubs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec privateProportionalHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7303] on 30 June 2025 at 12:07:01 pm'!
!Layout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:32'!
 isColumn
	^false! !
!Layout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:27'!
             isRow
	^false! !
!ColumnLayout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:43' overrides: 50340659!
                      isColumn
	^true! !
!RowLayout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:55' overrides: 50340662!
                       isRow
	^true! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 12:03:02' prior: 50339691!
                          axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the 	 	 LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			layout isRow 
				ifTrue: [ "Row"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #rowLeft ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #rowRight ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Row: ', aSymbolOrNumber printString ].
				]
				ifFalse: [ "vertical => Column"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #columnTop ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #columnBottom ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Column: ', aSymbolOrNumber printString ].
				]
		].
	layout axisEdgeWeight: edgeWeight.
	self layoutSubmorphs! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 12:03:46' prior: 16896408!
                  separation: aNumberOrPoint

	| g |
	self padding: aNumberOrPoint.
	g := aNumberOrPoint.
	g isPoint ifTrue: [
		g := layout isRow ifTrue: [ g x ] ifFalse: [ g y ]].
	self gap: g.! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 6/30/2025 12:02:43' prior: 16896417!
                        adjustBy: aLayoutAdjustMorph at: aGlobalPoint
	"See Class Comment of LayoutAdjustingMorph"

	| localPoint |
	localPoint := self internalizeFromWorld: aGlobalPoint.

	layout isRow ifTrue: [
		self adjustHorizontallyBy: aLayoutAdjustMorph at: localPoint ].

	layout isColumn ifTrue: [
		self adjustVerticallyBy: aLayoutAdjustMorph at: localPoint ].! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2025 12:03:21' prior: 50339748!
             minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	layout isColumn
		ifTrue: [ "Column"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"use maximum width across submorphs"
				width := width max: mle x.
				"sum up submorph heights, including separation between them"
				height := height + mle y + layout gap.
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"sum up submorphs width, include gap"
				width := width + mle x + layout gap.
				"use maximum height across submorph"
				height := height max: mle y.
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 12:04:10' prior: 50339780!
      beColumn
	"Establish the major layout axis, with default edge weight"
	layout := ColumnLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 12:04:07' prior: 50339789!
          beRow
	"Establish the major layout axis, with default edge weight"
	layout := RowLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/30/2025 12:01:58' prior: 50338527!
          addAdjusterMorph
	"So the user can adjust layout"

	| thickness |
	thickness := Theme current layoutAdjusterThickness.

	layout isRow ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedWidth: thickness) ].

	layout isColumn ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedHeight: thickness)]! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:01:30' prior: 16897186!
                  isColumn

	^ layout isColumn! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:01:22' prior: 16897190!
            isRow

	^ layout isRow! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:54:30' prior: 16896157!
       cursor
	^ layoutSpec fixedWidth = Theme current layoutAdjusterThickness
		ifTrue: [ Cursor cursorAt: #resizeLeftCursor ]
		ifFalse: [ Cursor cursorAt: #resizeTopCursor ].! !

LayoutMorph removeSelector: #direction!

!methodRemoval: LayoutMorph #direction stamp: 'Install-7312-LayoutMorph-cleanup-JuanVuletich-2025Jun30-11h44m-jmv.002.cs.st 7/15/2025 11:02:26'!
direction
	^direction!

LayoutMorph removeSelector: #desiredLayoutHeight!

!methodRemoval: LayoutMorph #desiredLayoutHeight stamp: 'Install-7312-LayoutMorph-cleanup-JuanVuletich-2025Jun30-11h44m-jmv.002.cs.st 7/15/2025 11:02:26'!
desiredLayoutHeight

	| fixed proportional |
	proportional := 0.
	fixed := 0.
	self submorphsToLayout do: [ :m | | ls |
		ls := m layoutSpec.
		ls isProportionalHeight ifTrue: [
			proportional := proportional max: ls fixedOrMinimumLayoutHeight / ls proportionalLayoutHeight ]
		ifFalse: [
			fixed := fixed + ls fixedOrMinimumLayoutHeight ]].
	^fixed + proportional!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7312-LayoutMorph-cleanup-JuanVuletich-2025Jun30-11h44m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7312] on 3 July 2025 at 1:06:25 pm'!
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 7/3/2025 10:49:34' prior: 50336975!
                               deferredUpdatingDisplay
	"Answer the instance to be used from most clients, including Morphic.
	If the platform supports #deferUpdates:
		Set Display to deferred upodating
		Answer will be Display itself.
	If the platform does NOT support #deferUpdates
		Answer a separate Form.
	Methods in this category provide convenient access."

	DeferredUpdatingDisplay ifNil: [
		 DeferredUpdatingDisplay := (Display deferUpdates: true)
			"Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display.
			Mac VMs newer than July 2025 also do support it.
			For VMs that don't support deferUpdates:, use this aux Form as Morphic Canvas target."
			ifNil: [ Form extent: Display extent depth: Display depth ]].
	^DeferredUpdatingDisplay! !
!Transcript class methodsFor: 'private' stamp: 'jmv 7/3/2025 13:02:55' prior: 50337502!
                         displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	| deferredDisplay |
	deferredDisplay := DisplayScreen deferredUpdatingDisplay.
	(displayEngine isNil or: [ displayEngine class ~= BitBltCanvasEngine])
		ifTrue: [
			^ displayEngine := BitBltCanvasEngine toForm: deferredDisplay ].
	displayEngine destForm == deferredDisplay ifFalse: [
		displayEngine setDestForm: deferredDisplay ].
	^ displayEngine! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7313-deferredDisplay-tweaks-JuanVuletich-2025Jul03-13h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 2:56:12 pm'!
!ColumnLayout methodsFor: 'accessing' stamp: 'jmv 7/3/2025 14:55:32' overrides: 50339669!
               axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			"vertical => Column"
			edgeWeight := aSymbolOrNumber
				caseOf: {
					[ #columnTop ] -> [ 0.0 ].
					[ #center ] -> [ 0.5 ].
					[ #columnBottom ] -> [ 1.0 ]
				}
				otherwise: [ self error: 'bad axisEdgeWeight for Column: ', aSymbolOrNumber printString ].
		].
	super axisEdgeWeight: edgeWeight.! !
!RowLayout methodsFor: 'accessing' stamp: 'jmv 7/3/2025 14:54:50' overrides: 50339669!
               axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			"Row"
			edgeWeight := aSymbolOrNumber
				caseOf: {
					[ #rowLeft ] 	-> [ 0.0 ].
					[ #center ] 		-> [ 0.5 ].
					[ #rowRight ] 	-> [ 1.0 ]
				}
				otherwise: [ self error: 'bad axisEdgeWeight for Row: ', aSymbolOrNumber printString ].
		].
	super axisEdgeWeight: edgeWeight.! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 14:53:45' prior: 50340674!
     axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layout axisEdgeWeight: aSymbolOrNumber.
	self layoutSubmorphs! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7314-Layouts-refactor-JuanVuletich-2025Jul03-14h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:22:20 pm'!
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:21:04'!
       adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint
	| lCurrentWidth rCurrentWidth delta lNewWidth rNewWidth ls rs |

	lCurrentWidth := l extentInOwner x max: 1.	"avoid division by zero"
	rCurrentWidth := r extentInOwner x max: 1.	"avoid division by zero"
	delta := localPoint x - adjusterRefPos x.
	delta := delta max: l minimumShrinkWidth - lCurrentWidth.
	delta := delta min: rCurrentWidth - r minimumShrinkWidth.
	delta = 0 ifTrue: [ ^false ].
	rNewWidth := rCurrentWidth - delta.
	lNewWidth := lCurrentWidth + delta.
	ls := l layoutSpec.
	rs := r layoutSpec.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [ | leftNewProportion rightNewProportion toDistribute |	"If both proportional, update them"
			leftNewProportion := lNewWidth / (lNewWidth + rNewWidth).
			rightNewProportion := 1.0 - leftNewProportion.
			toDistribute := ls proportionalLayoutWidth + rs proportionalLayoutWidth.
			ls setProportionalWidth: leftNewProportion * toDistribute.
			rs setProportionalWidth: rightNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	^true! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:20:58'!
     adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint
	| tCurrentHeight bCurrentHeight delta tNewHeight bNewHeight ts bs |

	tCurrentHeight := t extentInOwner y max: 1.	"avoid division by zero"
	bCurrentHeight := b extentInOwner y max: 1.	"avoid division by zero"
	delta := localPoint y - adjusterRefPos y.
	delta := delta max: t minimumShrinkHeight - tCurrentHeight.
	delta := delta min: bCurrentHeight - b minimumShrinkHeight.
	delta = 0 ifTrue: [ ^false ].
	tNewHeight := tCurrentHeight + delta.
	bNewHeight := bCurrentHeight - delta.
	ts := t layoutSpec.
	bs := b layoutSpec.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [ | bottomNewProportion toDistribute topNewProportion |	"If both proportional, update them"
			topNewProportion := tNewHeight / (tNewHeight + bNewHeight).
			bottomNewProportion := 1.0 - topNewProportion.
			toDistribute := ts proportionalLayoutHeight + bs proportionalLayoutHeight.
			ts setProportionalHeight: topNewProportion * toDistribute.
			bs setProportionalHeight: bottomNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	^true! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:20:03' prior: 16896431!
                              adjustHorizontallyBy: aLayoutAdjustMorph at: localPoint
	| i l r adjusterRefPos |

	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		 self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self  ].
	l := self submorphs at: i +1.
	r := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:19:54' prior: 16896482!
                      adjustVerticallyBy: aLayoutAdjustMorph at: localPoint

	| i t b adjusterRefPos |
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
			 self inform: 'LayoutAdjustingMorphs require morphs above and below'.
			^self ].
	t := self submorphs at: i +1.
	b := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !

LayoutMorph removeSelector: #adjustHorizontallyBy2:at:!

LayoutMorph removeSelector: #adjustVerticallyBy2:at:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7315-Layouts-refactor-JuanVuletich-2025Jul03-14h56m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:29:45 pm'!
!ColumnLayout methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:23:49'!
  adjustMorphBefore: t morphAfter: b adjusterRefPos: adjusterRefPos at: localPoint
	| tCurrentHeight bCurrentHeight delta tNewHeight bNewHeight ts bs |

	tCurrentHeight := t extentInOwner y max: 1.	"avoid division by zero"
	bCurrentHeight := b extentInOwner y max: 1.	"avoid division by zero"
	delta := localPoint y - adjusterRefPos y.
	delta := delta max: t minimumShrinkHeight - tCurrentHeight.
	delta := delta min: bCurrentHeight - b minimumShrinkHeight.
	delta = 0 ifTrue: [ ^false ].
	tNewHeight := tCurrentHeight + delta.
	bNewHeight := bCurrentHeight - delta.
	ts := t layoutSpec.
	bs := b layoutSpec.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [ | bottomNewProportion toDistribute topNewProportion |	"If both proportional, update them"
			topNewProportion := tNewHeight / (tNewHeight + bNewHeight).
			bottomNewProportion := 1.0 - topNewProportion.
			toDistribute := ts proportionalLayoutHeight + bs proportionalLayoutHeight.
			ts setProportionalHeight: topNewProportion * toDistribute.
			bs setProportionalHeight: bottomNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	^true! !
!RowLayout methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:25:01'!
                         adjustMorphBefore: l morphAfter: r adjusterRefPos: adjusterRefPos at: localPoint
	| lCurrentWidth rCurrentWidth delta lNewWidth rNewWidth ls rs |

	lCurrentWidth := l extentInOwner x max: 1.	"avoid division by zero"
	rCurrentWidth := r extentInOwner x max: 1.	"avoid division by zero"
	delta := localPoint x - adjusterRefPos x.
	delta := delta max: l minimumShrinkWidth - lCurrentWidth.
	delta := delta min: rCurrentWidth - r minimumShrinkWidth.
	delta = 0 ifTrue: [ ^false ].
	rNewWidth := rCurrentWidth - delta.
	lNewWidth := lCurrentWidth + delta.
	ls := l layoutSpec.
	rs := r layoutSpec.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [ | leftNewProportion rightNewProportion toDistribute |	"If both proportional, update them"
			leftNewProportion := lNewWidth / (lNewWidth + rNewWidth).
			rightNewProportion := 1.0 - leftNewProportion.
			toDistribute := ls proportionalLayoutWidth + rs proportionalLayoutWidth.
			ls setProportionalWidth: leftNewProportion * toDistribute.
			rs setProportionalWidth: rightNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	^true! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:28:46' prior: 50340733!
   adjustBy: aLayoutAdjustMorph at: aGlobalPoint
	"See Class Comment of LayoutAdjustingMorph"

	| localPoint  i before after adjusterRefPos |
	localPoint := self internalizeFromWorld: aGlobalPoint.
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self ].
	before := self submorphs at: i +1.
	after := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(layout adjustMorphBefore: before morphAfter: after adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !

LayoutMorph removeSelector: #adjustHorizontallyBy:at:!

!methodRemoval: LayoutMorph #adjustHorizontallyBy:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:26'!
adjustHorizontallyBy: aLayoutAdjustMorph at: localPoint
	| i l r adjusterRefPos |

	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		 self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self  ].
	l := self submorphs at: i +1.
	r := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].!

LayoutMorph removeSelector: #adjustHorizontallyMorphAtLeft:morphAtRight:adjusterRefPos:at:!

!methodRemoval: LayoutMorph #adjustHorizontallyMorphAtLeft:morphAtRight:adjusterRefPos:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:26'!
adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint
	| lCurrentWidth rCurrentWidth delta lNewWidth rNewWidth ls rs |

	lCurrentWidth := l extentInOwner x max: 1.	"avoid division by zero"
	rCurrentWidth := r extentInOwner x max: 1.	"avoid division by zero"
	delta := localPoint x - adjusterRefPos x.
	delta := delta max: l minimumShrinkWidth - lCurrentWidth.
	delta := delta min: rCurrentWidth - r minimumShrinkWidth.
	delta = 0 ifTrue: [ ^false ].
	rNewWidth := rCurrentWidth - delta.
	lNewWidth := lCurrentWidth + delta.
	ls := l layoutSpec.
	rs := r layoutSpec.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [ | leftNewProportion rightNewProportion toDistribute |	"If both proportional, update them"
			leftNewProportion := lNewWidth / (lNewWidth + rNewWidth).
			rightNewProportion := 1.0 - leftNewProportion.
			toDistribute := ls proportionalLayoutWidth + rs proportionalLayoutWidth.
			ls setProportionalWidth: leftNewProportion * toDistribute.
			rs setProportionalWidth: rightNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	^true!

LayoutMorph removeSelector: #adjustVerticallyBy:at:!

!methodRemoval: LayoutMorph #adjustVerticallyBy:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:26'!
adjustVerticallyBy: aLayoutAdjustMorph at: localPoint

	| i t b adjusterRefPos |
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
			 self inform: 'LayoutAdjustingMorphs require morphs above and below'.
			^self ].
	t := self submorphs at: i +1.
	b := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].!

LayoutMorph removeSelector: #adjustVerticallyMorphAbove:morphBelow:adjusterRefPos:at:!

!methodRemoval: LayoutMorph #adjustVerticallyMorphAbove:morphBelow:adjusterRefPos:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:26'!
adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint
	| tCurrentHeight bCurrentHeight delta tNewHeight bNewHeight ts bs |

	tCurrentHeight := t extentInOwner y max: 1.	"avoid division by zero"
	bCurrentHeight := b extentInOwner y max: 1.	"avoid division by zero"
	delta := localPoint y - adjusterRefPos y.
	delta := delta max: t minimumShrinkHeight - tCurrentHeight.
	delta := delta min: bCurrentHeight - b minimumShrinkHeight.
	delta = 0 ifTrue: [ ^false ].
	tNewHeight := tCurrentHeight + delta.
	bNewHeight := bCurrentHeight - delta.
	ts := t layoutSpec.
	bs := b layoutSpec.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [ | bottomNewProportion toDistribute topNewProportion |	"If both proportional, update them"
			topNewProportion := tNewHeight / (tNewHeight + bNewHeight).
			bottomNewProportion := 1.0 - topNewProportion.
			toDistribute := ts proportionalLayoutHeight + bs proportionalLayoutHeight.
			ts setProportionalHeight: topNewProportion * toDistribute.
			bs setProportionalHeight: bottomNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:37:48 pm'!
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/3/2025 15:37:29' prior: 50340747!
                              minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	layout isColumn
		ifTrue: [ "Column"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"use maximum width across submorphs"
					width := width max: mle x.
					"sum up submorph heights, including separation between them"
					height := height + mle y + layout gap.
				]
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"sum up submorphs width, include gap"
					width := width + mle x + layout gap.
					"use maximum height across submorph"
					height := height max: mle y.
				]
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:36:28' prior: 50340243!
 layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layout layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:36:07' prior: 50340035!
                         layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |

	visibleSubmorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:36:04' prior: 50340084!
  layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |

	visibleSubmorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !

LayoutMorph removeSelector: #submorphsToLayout!

!methodRemoval: LayoutMorph #submorphsToLayout stamp: 'Install-7317-Layouts-refactor-JuanVuletich-2025Jul03-15h29m-jmv.001.cs.st 7/15/2025 11:02:26'!
submorphsToLayout
	"Select those that will be layout"

	^submorphs select: [ :m | m visible ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7317-Layouts-refactor-JuanVuletich-2025Jul03-15h29m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:46:51 pm'!
!ColumnLayout methodsFor: 'services' stamp: 'jmv 7/3/2025 15:45:26'!
                minimumExtentFor: morphs cachedValues: cachedValues
	| width height mle |
	width  := 0.
	height := 0.
	morphs do: [ :sm |
		sm visible ifTrue: [
			mle := sm minimumLayoutExtent: cachedValues.
			"use maximum width across submorphs"
			width := width max: mle x.
			"sum up submorph heights, including separation between them"
			height := height + mle y + gap.
		]
	].
	height := height - gap. "An extra gap was just added"
	^width@height! !
!RowLayout methodsFor: 'services' stamp: 'jmv 7/3/2025 15:45:25'!
   minimumExtentFor: morphs cachedValues: cachedValues
	| width height mle |
	width  := 0.
	height := 0.
	morphs do: [ :sm |
		sm visible ifTrue: [
			mle := sm minimumLayoutExtent: cachedValues.
			"sum up submorphs width, include gap"
			width := width + mle x + gap.
			"use maximum height across submorph"
			height := height max: mle y.
		]
	].
	width := width - gap. "An extra gap was just added"
	^width@height! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/3/2025 15:46:32' prior: 16896653 overrides: 16796315!
                      minimumExtent
	"Answer size sufficient to frame my submorphs."
	
	^ (layout minimumExtentFor: submorphs cachedValues: IdentityDictionary new) + (2 * self interiorOrigin)! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:41:48' prior: 50339909!
heightsFor: visibleMorphs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| n scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	n := visibleMorphs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutHeightMin |
		sm := visibleMorphs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec privateProportionalHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:40:22' prior: 50341467!
                             layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleMorphs gapCount heights heightToAllocate leftOver y cache |

	visibleMorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleMorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleMorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * axisEdgeWeight).

	visibleMorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:40:56' prior: 50341500!
                 layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleMorphs gapCount widths widthToAllocate leftOver x cache |

	visibleMorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleMorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleMorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * axisEdgeWeight).

	visibleMorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:41:34' prior: 50340133!
                     widthsFor: visibleMorphs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| n scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	n := visibleMorphs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutWidthMin |
		sm := visibleMorphs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec privateProportionalWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths! !

LayoutMorph removeSelector: #minimumExtent:!

!methodRemoval: LayoutMorph #minimumExtent: stamp: 'Install-7318-Layouts-refactor-JuanVuletich-2025Jul03-15h37m-jmv.001.cs.st 7/15/2025 11:02:26'!
minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	layout isColumn
		ifTrue: [ "Column"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"use maximum width across submorphs"
					width := width max: mle x.
					"sum up submorph heights, including separation between them"
					height := height + mle y + layout gap.
				]
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"sum up submorphs width, include gap"
					width := width + mle x + layout gap.
					"use maximum height across submorph"
					height := height max: mle y.
				]
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7318-Layouts-refactor-JuanVuletich-2025Jul03-15h37m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:49:03 pm'!

LayoutMorph removeSelector: #isRow!

!methodRemoval: LayoutMorph #isRow stamp: 'Install-7319-Layouts-Cleanup-JuanVuletich-2025Jul03-15h46m-jmv.001.cs.st 7/15/2025 11:02:26'!
isRow

	^ layout isRow!

LayoutMorph removeSelector: #isColumn!

!methodRemoval: LayoutMorph #isColumn stamp: 'Install-7319-Layouts-Cleanup-JuanVuletich-2025Jul03-15h46m-jmv.001.cs.st 7/15/2025 11:02:26'!
isColumn

	^ layout isColumn!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7319-Layouts-Cleanup-JuanVuletich-2025Jul03-15h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:57:45 pm'!
!Layout methodsFor: 'testing' stamp: 'jmv 7/3/2025 15:51:04'!
 isLinearLayout
	^false! !
!LinearLayout methodsFor: 'testing' stamp: 'jmv 7/3/2025 15:50:56' overrides: 50341955!
              isLinearLayout
	^true! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:51:39' prior: 50340989!
                  axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }
	
	Ignored for other kinds of Layouts"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layout isLinearLayout ifTrue: [
		layout axisEdgeWeight: aSymbolOrNumber.
		self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:52:16' prior: 50339741!
  gap: aNumber
	"Only for Linear Layouts"
	layout isLinearLayout ifTrue: [
		layout gap = aNumber ifFalse: [
			self adjustExtentFor: [
				layout gap: aNumber ]].
		self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:56:52' prior: 16896403 overrides: 16796238!
                        padding: numberOrPoint
	"Honored by all kinds of Layouts"

	super padding: numberOrPoint.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:52:50' prior: 50340724!
                       separation: aNumberOrPoint
	"Only for Linear Layouts"

	| g |
	layout isLinearLayout ifTrue: [
		self padding: aNumberOrPoint.
		g := aNumberOrPoint.
		g isPoint ifTrue: [
			g := layout isRow ifTrue: [ g x ] ifFalse: [ g y ]].
		self gap: g ].! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/3/2025 15:54:54' prior: 16896721!
              defaultGap
	"Answer the default gap between submorphs for the receiver.
	Redefine this method for a different initial gap in your morphs.
	Only for Linear Layouts"

	^ 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7320-Layout-PrepareForAdditionalLayoutStyles-JuanVuletich-2025Jul03-15h49m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7320] on 4 July 2025 at 12:22:30 pm'!
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/4/2025 12:22:15' prior: 50339798!
       initializeColumn

	layout := ColumnLayout new.
	layout gap: self defaultGap.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/4/2025 12:22:13' prior: 50339804!
     initializeRow

	layout := RowLayout new.
	layout gap: self defaultGap.
	doAdoptWidgetsColor := false.
	self initialize.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7321-LayoutMorph-fix-JuanVuletich-2025Jul04-12h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7320] on 4 July 2025 at 12:32:10 pm'!
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:27:44'!
                         fixedExtent: aPoint
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedExtent: aPoint! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:27:57'!
                            fixedHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:04'!
                          fixedWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:12'!
                            fixedWidth: aNumber fixedHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber fixedHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:23'!
          fixedWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:32'!
    fixedWidth: aNumber proportionalHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber proportionalHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:40'!
                            fixedWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:54'!
                      keepMorphExtent
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec keepMorphExtent! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:03'!
    morphHeightFixedWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphHeightFixedWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:24'!
      morphHeightProportionalWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphHeightProportionalWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:42'!
                        morphWidthFixedHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphWidthFixedHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:51'!
      morphWidthProportionalHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphWidthProportionalHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:05'!
                        proportionalHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:16'!
            proportionalWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:25'!
              proportionalWidth: aNumber fixedHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber fixedHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:33'!
                            proportionalWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:40'!
                      proportionalWidth: aNumber proportionalHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber proportionalHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:48'!
              proportionalWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:56'!
        useAll
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec useAll! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7322-LayoutSpec-backCompatibility-JuanVuletich-2025Jul04-12h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7322] on 4 July 2025 at 3:22:02 pm'!
!Layout methodsFor: 'services' stamp: 'jmv 7/4/2025 14:56:57'!
   minimumExtentFor: morphs cachedValues: cachedValues
	self subclassResponsibility ! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 7/4/2025 14:23:06'!
         updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/4/2025 14:31:20' prior: 16930150!
                              allocHeightForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSpecs may specify propottional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minHeight
	so breakeven is when
	  amountToAlloc = minHeight / proportion * factor"
	| minHeight |
	minHeight := (self minimumLayoutExtent: cachedValues) y.
	^(self isProportionalHeight)
		ifFalse:  [ minHeight ]
		ifTrue: [ minHeight / (aFactor * self layoutSpec proportionalLayoutHeight) ]! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/4/2025 14:24:45' prior: 16930168!
          allocWidthForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSpecs may specify propottional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minWidth
	so breakeven is when
	  amountToAlloc = minWidth / proportion * factor"
	| minWidth |
	minWidth := (self minimumLayoutExtent: cachedValues) x.
	^(self isProportionalWidth)
		ifFalse:  [ minWidth ]
		ifTrue: [ minWidth / (aFactor * self layoutSpec proportionalLayoutWidth) ]! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:25:25' prior: 50341591!
                    heightsFor: visibleMorphs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| n scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	n := visibleMorphs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutHeightMin |
		sm := visibleMorphs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec proportionalLayoutHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:32:17' prior: 50341783!
 widthsFor: visibleMorphs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| n scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	n := visibleMorphs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutWidthMin |
		sm := visibleMorphs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec proportionalLayoutWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths! !

LayoutSizeSpec removeSelector: #updateContainingLayout!

!methodRemoval: LayoutSizeSpec #updateContainingLayout stamp: 'Install-7323-Layout-Cleanup-JuanVuletich-2025Jul04-15h19m-jmv.001.cs.st 7/15/2025 11:02:26'!
updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].!

LayoutSizeSpec removeSelector: #proportionaLayoutlHeight!

!methodRemoval: LayoutSizeSpec #proportionaLayoutlHeight stamp: 'Install-7323-Layout-Cleanup-JuanVuletich-2025Jul04-15h19m-jmv.001.cs.st 7/15/2025 11:02:26'!
proportionaLayoutlHeight

	^ proportionalHeight ifNil: [ 0 ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7323-Layout-Cleanup-JuanVuletich-2025Jul04-15h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7322] on 4 July 2025 at 3:25:41 pm'!

LayoutSpec subclass: #LayoutEdgesSpec
	instanceVariableNames: 'topLeftEdgesWeight topLeftOffset bottomRightEdgesWeight bottomRightOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutEdgesSpec category: #'Morphic-Layouts' stamp: 'Install-7324-FormLayout-JuanVuletich-2025Jul04-15h22m-jmv.001.cs.st 7/15/2025 11:02:26'!
LayoutSpec subclass: #LayoutEdgesSpec
	instanceVariableNames: 'topLeftEdgesWeight topLeftOffset bottomRightEdgesWeight bottomRightOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LayoutEdgesSpec commentStamp: '<historical>' prior: 0!
 To be used with FormLayout.
Inspired by 
https://archive.eclipse.org/eclipse/downloads/documentation/2.0/html/plugins/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormData.html and
https://archive.eclipse.org/eclipse/downloads/documentation/2.0/html/plugins/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormAttachment.html!
!Rectangle methodsFor: 'mathematical functions' stamp: 'jmv 6/24/2025 18:03:19'!
 interpolateAt: amountDone
	"Interpolate between the instance and end after the specified amount has been done (0 - 1)."

	^ self extent * amountDone + origin! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/4/2025 14:49:27'!
                     initializeForm

	layout := FormLayout new.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/4/2025 14:50:02'!
              newForm
	^self basicNew initializeForm! !
!LayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/4/2025 15:08:42'!
 example1Form
"
	self example1Form
"
	| pane |
	pane := (LayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!FormLayout methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:45:00'!
                           layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	morphs do: [ :eachMorph | | ls r |
		eachMorph visible ifTrue: [
			ls := eachMorph layoutSpec.
			r := (boundsForLayout interpolateAt: ls topLeftEdgesWeight) + ls topLeftOffset
				corner: 
					(boundsForLayout interpolateAt: ls bottomRightEdgesWeight) + ls bottomRightOffset.
			eachMorph fitInto: r ]]! !
!FormLayout methodsFor: 'services' stamp: 'jmv 7/4/2025 14:58:13' overrides: 50342217!
               minimumExtentFor: morphs cachedValues: cachedValues
	"Ojo!!"
	^100@100! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:35:06'!
             bottomRightEdgesWeight
	^bottomRightEdgesWeight! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:24'!
    bottomRightEdgesWeight: aPoint
	"Argument x and y must be in [0.0 .. 1.0]"
	bottomRightEdgesWeight := aPoint! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:35:16'!
       bottomRightOffset
	^bottomRightOffset! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:41'!
              bottomRightOffset: aPoint
	bottomRightOffset := aPoint! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:54'!
                             topLeftEdgesWeight
	^topLeftEdgesWeight! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:11'!
            topLeftEdgesWeight: aPoint
	"Argument x and y must be in [0.0 .. 1.0]"
	topLeftEdgesWeight := aPoint! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:35:00'!
               topLeftOffset
	^topLeftOffset! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:34'!
                      topLeftOffset: aPoint
	topLeftOffset := aPoint! !
!LayoutEdgesSpec methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:36:17'!
        minimumSpecExtent
	"We specify position, but not extent."

	^0@0! !
!LayoutEdgesSpec class methodsFor: 'instance creation' stamp: 'jmv 7/4/2025 14:53:37'!
     tlEdgesWeight: tlWeight offset: tlOffset brEdgesWeight: brWeight offset: brOffset

	^LayoutEdgesSpec new
		topLeftEdgesWeight: tlWeight;
		topLeftOffset: tlOffset;
		bottomRightEdgesWeight: brWeight;
		bottomRightOffset: brOffset! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7324-FormLayout-JuanVuletich-2025Jul04-15h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7324] on 4 July 2025 at 4:19:21 pm'!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/4/2025 16:13:26'!
                              gap
	"Only for Linear Layouts"
	^layout isLinearLayout ifTrue: [
		layout gap ]! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/4/2025 16:14:16'!
          isColumn
	"Only makes sense for Linear Layouts"
	^layout isColumn! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/4/2025 16:14:11'!
                        isRow
	"Only makes sense for Linear Layouts"
	^layout isRow! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7325-Layout-Add3convenienceMethods-JuanVuletich-2025Jul04-16h13m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7324] on 4 July 2025 at 4:20:28 pm'!
!ColumnLayout methodsFor: 'initialization' stamp: 'jmv 7/4/2025 16:20:02' prior: 50339681 overrides: 16940323!
           initialize
	gap := 0.
	axisEdgeWeight := 0.0. "#columnTop"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7326-ColumnLayout-defaultAxisEdgeWeight-fix-JuanVuletich-2025Jul04-16h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7326] on 7 July 2025 at 8:52:48 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7327-Layout-RemoveUnusedIVars-JuanVuletich-2025Jul07-08h51m-jmv.001.cs.st 7/15/2025 11:02:27'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7327-Layout-RemoveUnusedIVars-JuanVuletich-2025Jul07-08h51m-jmv.001.cs.st 7/15/2025 11:02:27'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7327-Layout-RemoveUnusedIVars-JuanVuletich-2025Jul07-08h51m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7328] on 7 July 2025 at 10:19:06 am'!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/7/2025 10:18:47'!
                 axisEdgeWeight
	"Only for Linear Layouts"
	^layout isLinearLayout ifTrue: [
		layout axisEdgeWeight ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7328-LayoutMorph-axisEdgeWeigh-JuanVuletich-2025Jul07-10h04m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7326] on 7 July 2025 at 9:37:40 am'!

Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush '!

!classDefinition: 'Transcript class' category: #'System-Support' stamp: 'Install-7329-TranscriptSpeedupForMacIntel-JuanVuletich-2025Jul07-08h52m-jmv.003.cs.st 7/15/2025 11:02:27'!
Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush'!
!Transcript class methodsFor: 'private' stamp: 'jmv 7/7/2025 09:37:30'!
 dirtyScreenRect: someDamage
	"aRectangle needs updating on real OS Screen. This can be simply done by
	DisplayScreen forceDeferredToScreen: damage.
	The reason to do something more complicated is because #forceDeferredToScreen: may be expensive, especially on Mac Intel VMs as of July 2025, and especially if done at high frequency (i.e. with a time interval between calls below 25 milliseconds.
	"
	| now |
	now := Time localMillisecondClock.
	lastDisplayFlush ifNil: [ lastDisplayFlush := now ].

	"If enough time has elapsed since last push, just do it."
	now - lastDisplayFlush > 25 ifTrue: [
		dirtyRectOnDisplay := someDamage quickMerge: dirtyRectOnDisplay.
		DisplayScreen forceDeferredToScreen: dirtyRectOnDisplay.
		dirtyRectOnDisplay := nil.
		lastDisplayFlush := now.
		^self
		].

	dirtyRectOnDisplay
		ifNil: [
			"We don't have a previous dirty rect. If there has been some, it has already been pushed to Screen.
			Start a forked process to push it. Do it in a while. In the meantime, other calls to this process may
			add additional damage. It is also possible that some other call to this method ends up clearing the
			dirtyRectOnDisplay. Consider that too."
			dirtyRectOnDisplay := someDamage.
			[
				(Delay forMilliseconds: 50) wait.
				dirtyRectOnDisplay ifNotNil: [
					DisplayScreen forceDeferredToScreen: dirtyRectOnDisplay.
					dirtyRectOnDisplay := nil.
					lastDisplayFlush := Time localMillisecondClock ].
			] forkAt: Processor userInterruptPriority ]
		ifNotNil: [
			"We already have a forked process that will soon do the push. Wait for it. Merge damage."
			dirtyRectOnDisplay := someDamage quickMerge: dirtyRectOnDisplay.
			].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 7/7/2025 09:35:27' prior: 50337444!
                            display
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		self dirtyScreenRect: bounds ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 7/7/2025 09:35:46' prior: 50337460!
                     displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			self dirtyScreenRect: damage ]]! !

Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush'!

!classDefinition: 'Transcript class' category: #'System-Support' stamp: 'Install-7329-TranscriptSpeedupForMacIntel-JuanVuletich-2025Jul07-08h52m-jmv.003.cs.st 7/15/2025 11:02:27'!
Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7329-TranscriptSpeedupForMacIntel-JuanVuletich-2025Jul07-08h52m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7278] on 19 June 2025 at 10:13:46 am'!
!CompiledMethod class methodsFor: 'method encoding' stamp: 'jmv 6/19/2025 10:12:44'!
         headerFlagForEncoderClass: anEncoderClass
	
	(anEncoderClass includesBehavior: PrimaryBytecodeSetEncoderClass) ifTrue: [^0].
	(anEncoderClass includesBehavior: SecondaryBytecodeSetEncoderClass) ifTrue: [^SmallInteger minVal].
	
	self error: 'The encoder is not one of the two installed bytecode sets'! !
!BytecodeEncoder methodsFor: 'method generation' stamp: 'jmv 6/19/2025 10:12:56' prior: 16802332!
              computeMethodHeaderForNumArgs: numArgs numTemps: numTemps numLits: numLits primitive: primitiveIndex
	numArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	numTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	numLits > 65535
		ifTrue: [^self error: 'Cannot compile -- too many literals'].
	^(CompiledMethod headerFlagForEncoderClass: self class)
		+ (numArgs bitShift: 24)
		+ (numTemps bitShift: 18)
		"+ (largeBit bitShift: 17)" "largeBit gets filled in later"
		+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])
		+ numLits! !
!CompiledMethod class methodsFor: 'instance creation' stamp: 'jmv 6/19/2025 10:13:30' prior: 16835903!
                             newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	 arguments. The remaining parts are not as yet determined."
	| method pc |
"15 | 63 | 32767"
	nArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	nTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 32767
		ifTrue: [^self error: 'Cannot compile -- too many literals'].

	method := self
				createMethod: numberOfBytes
				trailer: trailer
				header:  (CompiledMethod headerFlagForEncoderClass: PreferredBytecodeSetEncoderClass)
						+ (nArgs bitShift: 24)
						+ (nTemps bitShift: 18)
						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])
						+ nLits
						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).
	primitiveIndex > 0 ifTrue: [
		pc := method initialPC.
		method
			at: pc + 0 put: method encoderClass callPrimitiveCode;
			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);
			at: pc + 2 put: (primitiveIndex bitShift: -8)].
	^method! !

CompiledMethod class removeSelector: #headerFlagForEncoder:!

!methodRemoval: CompiledMethod class #headerFlagForEncoder: stamp: 'Install-7330-headerFlagForEncoderClass-JuanVuletich-2025Jun19-10h12m-jmv.001.cs.st 7/15/2025 11:02:27'!
headerFlagForEncoder: anEncoder
	
	(anEncoder class includesBehavior: PrimaryBytecodeSetEncoderClass) ifTrue: [^0].
	(anEncoder class includesBehavior: SecondaryBytecodeSetEncoderClass) ifTrue: [^SmallInteger minVal].
	
	self error: 'The encoder is not one of the two installed bytecode sets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7330-headerFlagForEncoderClass-JuanVuletich-2025Jun19-10h12m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 19 June 2025 at 2:46:56 pm'!
!SequenceableCollection methodsFor: '[mk] comparing' stamp: 'jmv 6/19/2025 10:48:21'!
               is: otherCollection subcollectionAt: index
	"Answer whether the receiver includes otherCollection as a subcollection at position index."

	| sequenceSize |
	index < 1 ifTrue: [ ^false ].
	sequenceSize := otherCollection size.
	sequenceSize = 0 ifTrue: [ ^true ].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :i |
		(self at: index+i-1) = (otherCollection at: i) ifFalse: [ ^false ]].
	^true! !
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 6/19/2025 10:48:50' prior: 16813421!
                   is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	^self is: subString subcollectionAt: index! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7331-is-subCollectionAt-JuanVuletich-2025Jun19-14h45m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 19 June 2025 at 2:48:05 pm'!
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'jmv 6/19/2025 10:35:26'!
                               emptyClosurePattern
	"Answer the byte pattern for an empty closure. For instance (verbatim from the bytecode view):
		45 <FA 00 02> closureNumCopied: 0 numArgs: 0 bytes 48 to 49
		48 	<4F> pushConstant: nil
		49 	<5E> blockReturn"
	"ByteArray readHexFrom: 'FA00024F5E'"
	^ #[250 0 2 79 94]! !
!EncoderForV3PlusClosures class methodsFor: 'bytecode decoding' stamp: 'jmv 6/19/2025 10:35:30'!
                          emptyClosurePattern
	"Answer the byte pattern for an empty closure. For instance (verbatim from the bytecode view):
		33 <8F 00 00 02> closureNumCopied: 0 numArgs: 0 bytes 37 to 38
		37 	<73> pushConstant: nil
		38 	<7D> blockReturn"
	"ByteArray readHexFrom: '8F000002737D'"
	^ #[143 0 0 2 115 125]! !
!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 6/19/2025 10:51:33' prior: 16977216!
            browseMethodsWithEmptyClosures
	"
	Smalltalk browseMethodsWithEmptyClosures
	"
	| pattern1 pattern2 |
	pattern1 := CompiledMethod primaryBytecodeSetEncoderClass emptyClosurePattern.
	pattern2 := CompiledMethod secondaryBytecodeSetEncoderClass emptyClosurePattern.
	self
		browseAllSelect: [ :m | | s |
			s := InstructionStream on: m.
			s scanFor: [ :bytecode |
				(s method is: pattern1 subcollectionAt: s pc) or:
					[s method is: pattern2 subcollectionAt: s pc]]]
		name:  'Methods with empty closures'
		autoHighlight: '[]'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7332-SistaCompatibility-EmptyClosureDetection-2025Jun19-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7332] on 7 July 2025 at 11:23:30 am'!

IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments '
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp SystemAttributeCache '
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

!classDefinition: #SystemDictionary category: #'MinimalKernel-Support' stamp: 'Install-7333-SystemDictionary-cleanup-JuanVuletich-2025Jul07-11h22m-jmv.001.cs.st 7/15/2025 11:02:27'!
IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp SystemAttributeCache'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!
!SystemDictionary methodsFor: 'special objects' stamp: 'ul 3/21/2017 18:52' prior: 16977142!
specialSelectors
	"Return an array with flattened special selector - argument count pairs. VMMaker relies on this."
	
	^self specialObjectsArray at: 24! !

IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString StartUpList StartupStamp SystemAttributeCache'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

!classDefinition: #SystemDictionary category: #'MinimalKernel-Support' stamp: 'Install-7333-SystemDictionary-cleanup-JuanVuletich-2025Jul07-11h22m-jmv.001.cs.st 7/15/2025 11:02:27'!
IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString StartUpList StartupStamp SystemAttributeCache'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7333-SystemDictionary-cleanup-JuanVuletich-2025Jul07-11h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7332] on 7 July 2025 at 12:02:40 pm'!
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 7/7/2025 12:00:15' prior: 16825977!
 annotationForSelector: aSelector ofClass: aClass
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	| method |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	method := aClass compiledMethodAt: aSelector ifAbsent: nil.
	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp := self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						method notNil ifTrue: [
							strm
								print: method linesOfCode;
								nextPutAll: ' lines of code' ]].
					[#messageSendsCount] -> [
						method notNil ifTrue: [
							strm
								print: method messageSendsCount;
								nextPutAll: ' message sends' ]].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount := Smalltalk numberOfSendersOf: aSelector.
						sendersCount := sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount := Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount := implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp := VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						method notNil ifTrue: [
							(CodePackage packageOfMethod: method methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList := (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ].
		(method notNil and: [method hasBreakpoint]) ifTrue: [
			strm nextPutAll: self annotationSeparator.
			strm nextPutAll: '[Breakpoint]' ]
	].! !
!ChangeList methodsFor: 'viewing access' stamp: 'jmv 7/7/2025 12:00:26' prior: 16804989 overrides: 16825888!
                     annotation
	"Answer the string to be shown in an annotation pane.  Make plain that the annotation is associated with the current in-image version of the code, not of the selected disk-based version, and if the corresponding method is missing from the in-image version, mention that fact."

	| change count selectedCount ann1 ann2 |
	change := self currentChange.
	
	change isNil ifTrue: [
		count := listSelections size.
		selectedCount := listSelections count: [ :flag | flag ].
		^ 'Total items: ', count printString, ' - Selected items: ', selectedCount printString ].

	change changeType == #classDefinition ifTrue: [
		ann1 := change isMetaClassChange ifTrue: [ 'Metaclass' ] ifFalse: [ 'Class' ].
		ann2 := (Smalltalk includesKey: change changeClassName) ifTrue: [ ' already exists' ] ifFalse: [ ' not in system' ].
		^ann1, ann2 ].
	
	(self selectedMessageName isNil or: [self selectedClassOrMetaClass isNil])
		ifTrue: [^ ''].

	^ change methodSelector notNil
		ifFalse: [ super annotation]
		ifTrue: [
			(self isNewMethod: change)
				ifTrue: [
					String streamContents: [ :strm | | sel |
						sel := change methodSelector.
						strm
							nextPutAll: change changeClassName;
							nextPutAll: ' >> ';
							nextPutAll: sel;
							nextPutAll: ' is not present in the system. It has '.
							count := Smalltalk numberOfImplementorsOf: sel.
							count = 1
								ifTrue: [strm nextPutAll: '1 implementor']
								ifFalse: [count printOn: strm. strm nextPutAll: ' implementors' ].
							strm nextPutAll: ' and '.
							count := Smalltalk numberOfSendersOf: sel.
							count = 1
								ifTrue: [strm nextPutAll: '1 sender.']
								ifFalse: [count printOn: strm. strm nextPutAll: ' senders.' ].
						]
					]
				ifFalse: [
					'current version: ', super annotation]]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 11:59:25' prior: 16974125!
numberOfSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	"
	| count |
	count := 0.
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			(method hasLiteral: aSymbol)
				ifTrue: [ count := count + 1 ]]].
	^ count! !

SystemDictionary removeSelector: #numberOfDirectSendersOf:!

!methodRemoval: SystemDictionary #numberOfDirectSendersOf: stamp: 'Install-7334-Senders-Not-DirectSenders-JuanVuletich-2025Jul07-11h23m-jmv.001.cs.st 7/15/2025 11:02:27'!
numberOfDirectSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfDirectSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	[ (Smalltalk numberOfDirectSendersOf: #==) ] timeToRun
	"
	| count specialFlag specialByte |
	count := 0.
	specialFlag := self hasSpecialSelector: aSymbol ifTrueSetByte: [ :b | specialByte := b ].
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			((method hasLiteral: aSymbol) or: [specialFlag and: [(method scanFor: specialByte)]])
				ifTrue: [ count := count + 1 ]]].
	^ count!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7334-Senders-Not-DirectSenders-JuanVuletich-2025Jul07-11h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7334] on 7 July 2025 at 1:15:33 pm'!
!PreferenceSet methodsFor: 'services' stamp: 'jmv 7/7/2025 13:15:10'!
                               removeUnused
	"
	Preferences removeUnused
	Preferences allPreferences keys select: [ :key | (Smalltalk numberOfSendersOf: key) = 0 ]
	"
	(self allPreferences keys select: [ :key | (Smalltalk numberOfSendersOf: key) = 0 ])
		do: [ :key | self removeKey: key ].! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 13:10:25' prior: 16789273!
                       whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |

	who := self thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte.

	^self rejectSelectorsFrom: who thatReferenceTo: literal byte: specialByte! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:01' prior: 16936525!
                           machineDefault
	^ #(
		#(drawKeyboardFocusIndicator true )
		#(balloonHelpEnabled true )
		#(biggerCursors false )
		#(browseWithPrettyPrint false )
		#(caseSensitiveFinds false )
		#(checkForSlips true )
		#(cmdDotEnabled true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(menuKeyboardControl true )
		#(optionalButtons true )
		#(extraDebuggerButtons true )
		#(subPixelRenderFonts true )
		#(cheapWindowReframe false )
		#(syntaxHighlightingAsYouType true )
		#(tapAndHoldEmulatesButton2 true )
		#(clickGrabsMorphs false )
		#(showAssignmentAsLeftArrow false )
		#(wantsMenuIcons true )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:06' prior: 16936548!
                         machineSlow
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
		(methodAnnotations #(timeStamp messageCategory packages changeSets) )
		(classAnnotations  #(instanceMethodsCount classMethodsCount) )
		(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount) )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:11' prior: 16936574!
                        machineSmalltalk80
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:19' prior: 16936628!
              prefProgramming
	^ #(
		#(atMinusDigitMeaning st80 #(st80 ansiSmalltalk disabled) )
		#(allowBlockArgumentAssignment false )
		#(allowNonBooleanReceiversOfBooleanMessages false )
		#(alternativeBrowseIt false )
		#(browseWithPrettyPrint false )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount "linesOfCode" messageSendsCount) )
		#(classAnnotations #(instanceMethodsCount classMethodsCount "linesOfCode" messageSendsCount) )
		#(messageCategoryAnnotations #(messagesCount messageSendsCount) )
		#(methodAnnotations #(timeStamp "linesOfCode" messageSendsCount messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(syntaxHighlightingAsYouType true )
		#(showAssignmentAsLeftArrow false )
		#(usePreDebugWindow false)
		#(clearPackagePathsOnImageMove true)
	)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

Preferences removeUnused!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7335-throughSenders-Preference-remove-JuanVuletich-2025Jul07-13h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7335] on 7 July 2025 at 2:19:40 pm'!
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 13:33:18' prior: 16908878!
             filterToNotSendersOf
	"Filter the receiver's list down to only those items which do not send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol |
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) isNil or:
							[(aMethod hasLiteral: aSymbol) not]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 13:33:23' prior: 16908895!
                             filterToSendersOf
	"Filter the receiver's list down to only those items which send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) notNil and:
							[aMethod hasLiteral: aSymbol]]]]! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 14:18:29' prior: 50343458!
                           whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteral: literal)
			ifTrue: [
				((literal isVariableBinding) not
					or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
					or: [(method indexOfLiteral: literal) ~= 0]])
						ifTrue: [who add: sel]]].

	"For special selectors, look for the literal in the source code.
	Otherwise, for example, searching for senders of #== will include senders of #ifNil.
	Except for #at:put:, because it has two arguments and won't find it in the source code like that."
	^ (specialByte isNil or: [ literal = #at:put: ]) 
		ifTrue: [ who ]
		ifFalse: [ who select: [ :sel | ((self sourceCodeAt: sel) findString: literal) > 0]]! !
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 7/7/2025 13:33:52' prior: 16835660!
                             sendsOrRefersTo: aSelector

	^ (self hasLiteral: aSelector) or: [ self sendsSelector: aSelector ]! !

AdditionalMethodState removeSelector: #hasLiteralThorough:!

!methodRemoval: AdditionalMethodState #hasLiteralThorough: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:28'!
hasLiteralThorough: literal
	"Answer true if any literal in these properties is literal,
	 even if embedded in array structure."
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [propertyOrPragma key == literal
					or: [propertyOrPragma value == literal
					or: [propertyOrPragma value isArray
						and: [propertyOrPragma value hasLiteral: literal]]]]
			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:
			[^true]].
	^false!

CompiledMethod removeSelector: #hasLiteralThorough:!

!methodRemoval: CompiledMethod #hasLiteralThorough: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:28'!
hasLiteralThorough: literal
	"Answer true if any literal in this method is literal,
	even if embedded in array structure."

	| lit |
	
	self withPropertiesDo: [ :properties | (properties hasLiteralThorough: literal) ifTrue:[^true]].
	
	2 to: self numLiterals - 1 "exclude superclass + selector/properties"
	   do: [ :index |
		(((lit := self objectAt: index) literalEqual: literal)
		 or: [(lit isVariableBinding and: [lit key == literal])
		 or: [lit isArray and: [lit hasLiteral: literal]]]) ifTrue:
			[^ true]].
	^ false !

Behavior removeSelector: #rejectSelectorsFrom:thatReferenceTo:byte:!

!methodRemoval: Behavior #rejectSelectorsFrom:thatReferenceTo:byte: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:28'!
rejectSelectorsFrom: selectors thatReferenceTo: aLiteral byte: specialByte 

	"For special selectors, look for the literal in the source code.
	Otherwise, for example, searching for senders of #== will include senders of #ifNil.
	Except for #at:put:, because it has two arguments and won't find it in the source code like that."

	^ (specialByte isNil or: [ aLiteral = #at:put: ]) 
		ifTrue: [ selectors ]
		ifFalse: [ selectors select: [ :sel | ((self sourceCodeAt: sel) findString: aLiteral) > 0]]!

Behavior removeSelector: #thoroughWhichSelectorsReferTo:special:byte:!

!methodRemoval: Behavior #thoroughWhichSelectorsReferTo:special:byte: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:28'!
thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method is: #CompiledMethod) ifTrue: [
			((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])
				ifTrue: [
					((literal isVariableBinding) not
						or: [method sendsToSuper not
						"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
						Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
						or: [(method indexOfLiteral: literal) ~= 0]])
							ifTrue: [who add: sel]]]].
	^ who.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:34:54 am'!
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 7/8/2025 09:49:17' prior: 50334398!
      finalizeEphemeron: anEphemeron

	"Remove the ephemeron from myself.  Note that no finalization of the ephemeron's key is done.
	 Here we are using ephemerons to clean up property tables."

	self removeKey: anEphemeron key ifAbsent: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7337-EphemeronIdentityDictionary-tweak-JuanVuletich-2025Jul08-11h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:36:54 am'!
!Object methodsFor: 'events-removing' stamp: 'jmv 7/8/2025 11:32:33'!
                               removeAllActions
	"Empty our #actionMap.
	Use this method when done with some object holding dependents. Do not call #releaseActionMap.
	Actually, usually you don't need to call any of these. Our #actionMap is cleared autonatically when
	we are collected,	as ActionMaps is an EphemeronIdentityDictionary.
	"
	self removeActionsSatisfying: [ :any | true ]! !
!ActiveModel methodsFor: 'accessing' stamp: 'jmv 7/8/2025 11:31:12' overrides: 50343814!
 removeAllActions

    actionMap := nil! !
!Object methodsFor: 'events-removing' stamp: 'jmv 7/8/2025 11:27:36' prior: 16922306!
releaseActionMap
	"Modifying ActionMaps is kinda dangerous.
	It is an instance of EphemeronIdentityDictionary.
	Its integrity is protected by a Mutex, meaning that nested accesses from the same process could
	break it, leading to system crash if not done very carefully.
	As this is public protocol, and in any case EphemeronIdentityDictionary are automatically cleared
	when keys are collected, the risk is not worth it.
	"
	"ActiveModel releaseActionMapFor: self."
	self removeAllActions.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7338-Safer-releaseActionMap-JuanVuletich-2025Jul08-11h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:38:56 am'!
!Object methodsFor: 'events-removing' stamp: 'jmv 7/8/2025 11:09:50' prior: 16922319!
                           removeActionsForEvent: anEventSelector

	| map |
	map := self actionMap.
	map ifNotNil: [
		map removeKey: anEventSelector asSymbol ifAbsent: nil.
		"No need. ActionMaps is an EphemeronIdentityDictionary. Keys are automatically removed when collectable.
		Besides, this is dangerous for instance, if called from an iteration of ActionMaps."
		"map isEmpty
			ifTrue: [ self releaseActionMap ]"
		]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/8/2025 11:23:30' prior: 16914003!
                     clearDependencyAndEvents
"
Morph allSubInstancesDo: [ :m | m clearDependencyAndEvents ].
"
	SystemChangeNotifier uniqueInstance removeActionsWithReceiver: self.
	self removeAllActions.! !
!ProgressiveTestRunner methodsFor: 'evaluating - private' stamp: 'jmv 7/8/2025 11:27:48' prior: 16940283!
                          unregisterTestSuiteAction
	
	testSuite removeAllActions! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7339-DontCall-releaseActionMap-JuanVuletich-2025Jul08-11h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:40:14 am'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/8/2025 09:33:40' prior: 16914017!
       delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld := self world ifNil: [ self runningWorld ].
	aWorld ifNotNil: [
		aWorld activeHand ifNotNil: [ :h | h
			releaseKeyboardFocus: self;
			releaseMouseFocus: self ]].
	self clearDependencyAndEvents.
	self allSubmorphsDo: [ :each |
		each clearDependencyAndEvents ].
	self privateDelete.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7340-Morph-tweak-JuanVuletich-2025Jul08-11h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7340] on 8 July 2025 at 2:29:39 pm'!
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 16:00:14'!
          whichSelectorsReferExplicitlyTo: literal
	"Answer a set of selectors whose methods access the argument as a literal,
	and refer explicitly to in Source Code.
	Useful for finding senders of selectors.
	See #whichSelectorsReferTo:."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteralExplicitly: literal)
			ifTrue: [
				who add: sel]].
	^who
	"
	Rectangle whichSelectorsReferExplicitlyTo: #==.
	"! !
!Behavior methodsFor: 'methods' stamp: 'jmv 7/8/2025 14:28:23'!
      addMethodsTo: methodsReferencingLiteral thatReferExplicitlyTo: aLiteral
	
	| selectors |
	
	selectors := self whichSelectorsReferExplicitlyTo: aLiteral.
	selectors do: [ :sel | methodsReferencingLiteral add: (MethodReference class: self selector: sel) ]! !
!Behavior methodsFor: 'methods' stamp: 'jmv 7/8/2025 14:26:05'!
                               addMethodsTo: methodsReferencingLiteral thatReferTo: aLiteral

	(self whichSelectorsReferTo: aLiteral)
		do: [ :sel |
			methodsReferencingLiteral add: (MethodReference class: self selector: sel) ]! !
!Behavior methodsFor: 'methods' stamp: 'jmv 7/8/2025 14:28:51'!
                       addTo: aSet methodsThatReferInHierarchyTo: aSymbol
	
	self withAllSuperAndSubclassesDo: [ :class |
		class addMethodsTo: aSet thatReferExplicitlyTo: aSymbol ] 
		! !
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 7/7/2025 15:45:36'!
                    hasLiteralExplicitly: aLiteral
	"Similar to #hasLiteral:
	But do not include methods that (for example) #hasLiteral: #==
	only because the Compiler implements #ifNil: that way.
	See #hasLiteral:.
	Useful for finding senders of selectors."

	| canBeSpecialLiteral |
	canBeSpecialLiteral := self encoderClass canBeSpecialLiteral: aLiteral.

	"If we don't hasLiteral: it, just answer false."
	(self
		hasLiteralSuchThat: [:lit | lit literalEqual: aLiteral]
		scanForSpecial: canBeSpecialLiteral)
			ifFalse: [ ^false ].

	"Any literal but these appears for sure in source code, so it appears explicitly."
	canBeSpecialLiteral
		ifFalse: [ ^true ].

	"#at:put: is the only special selector that can't be found with #findString:
	But, it is also not generated implicitly by the Compiler.
	So we know it is actually sent in source code anyway."
	aLiteral = #at:put: ifTrue: [
		^true ].

	"Other special selectors, like #== must be found in source code to be considered."
	^(self getSource findString: aLiteral) > 0! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 15:57:33' prior: 50343605!
                        filterToNotSendersOf
	"Filter the receiver's list down to only those items which do not send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol |
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) isNil or:
							[(aMethod hasLiteralExplicitly: aSymbol) not]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 15:57:37' prior: 50343623!
                   filterToSendersOf
	"Filter the receiver's list down to only those items which send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) notNil and:
							[aMethod hasLiteralExplicitly: aSymbol]]]]! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 16:00:05' prior: 16789260!
                 whichSelectorsReferTo: literal
	"Answer a set of selectors whose methods access the argument as a literal.
	Useful for finding references to literals.
	See #whichSelectorsReferExplicitlyTo:."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteral: literal)
			ifTrue: [
				who add: sel]].
	^who
	"
	Rectangle whichSelectorsReferTo: #==.
	"! !
!Behavior methodsFor: 'user interface' stamp: 'jmv 7/8/2025 14:28:57' prior: 16789402!
          allLocalCallsOn: aSymbol
	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."

	| aSet cls |
	
	aSet := Set new.
	cls := self theNonMetaClass.
	
	cls addTo: aSet methodsThatReferInHierarchyTo: aSymbol.
	cls class addTo: aSet methodsThatReferInHierarchyTo: aSymbol.
	
	^aSet! !
!CompiledMethod methodsFor: 'literals' stamp: 'eem 7/8/2024 15:15' prior: 16834524 overrides: 16923970!
                  hasLiteral: aLiteral
	"Overwrite this method to invoke the bytecode encoder scanner explicitly.
	 This might be removed if there would be a way to enumerate special literals in a compiled-code object.
	See #allLiteralsDo:.
	See #hasLiteralExplicitly:. Prefer this for finding senders of selectors."

	^ self
		hasLiteralSuchThat: [:lit | lit literalEqual: aLiteral]
		scanForSpecial: (self encoderClass canBeSpecialLiteral: aLiteral)! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/8/2025 14:28:34' prior: 16973369!
                allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection |

	#(23 48 'fred' (new open:label:)) size.
	"Example above should find #open:label:, though it is deeply embedded here."

	aCollection := OrderedCollection new.
	self allBehaviorsDo: [ :class |
		class addMethodsTo: aCollection thatReferExplicitlyTo: aLiteral ].
	
	^ aCollection! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 15:37:33' prior: 16973390!
                      allCallsOn: firstLiteral and: secondLiteral
	"Answer a SortedCollection of all the methods that call on both aLiteral
	and secondLiteral."

	| aCollection secondArray |
	aCollection := SortedCollection new.
	self allBehaviorsDo: [ :class |
		secondArray := class
			whichSelectorsReferExplicitlyTo: secondLiteral.
				((class whichSelectorsReferExplicitlyTo: firstLiteral ) select: [ :aSel |
			(secondArray includes: aSel)]) do: [ :sel |
				aCollection add: (MethodReference class: class selector: sel )]].
	^aCollection! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/8/2025 14:26:13' prior: 16973850!
                       allReferencesToLiteral: aLiteral
	| coll |
	coll := OrderedCollection new.
	self allBehaviorsDo: [ :eaClass |
		eaClass
			addMethodsTo: coll
			thatReferTo: aLiteral ]..
	^ coll.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 16:37:36' prior: 16974035!
              isThereAReferenceTo: aLiteral
	"Answer a Collection of all the methods that call on aLiteral."
	"
	Smalltalk isThereAReferenceTo: #open:label:
	"

	#(23 48 'fred' (new open:label:)) size.
"Example above should find #open:label:, though it is deeply embedded here."

	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			(method hasLiteral: aLiteral)
				ifTrue: [ ^true ]]].
	^ false! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 16:19:53' prior: 50343394!
    numberOfSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	Note: For some selectors, like #==, this method will give an incorrect answer, much larger than the correct one.
	The correct answer would require calling the more expensive #hasLiteralExplicitly: method.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	"
	| count |
	count := 0.
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			"
			(method hasLiteralExplicitly: aSymbol)
			"
			(method hasLiteral: aSymbol)
				ifTrue: [ count := count + 1 ]]].
	^ count! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 7/8/2025 14:26:22' prior: 16977031!
  browseViewReferencesFromNonViews
	"
	Smalltalk browseViewReferencesFromNonViews
	"
	| aLiteral aCollection |

	aCollection := OrderedCollection new.

	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)"
"	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"
	PluggableMorph withAllSubclassesDo: [ :view |
"	MenuMorph withAllSubclassesDo: [ :view |"
		
		aLiteral := view name.
		
		"tweak to linclude refs to SysWindow subhierarchy or not"
		(view includesBehavior: SystemWindow) & false ifFalse: [
			self allBehaviorsDo: [ :class |
				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [
					class addMethodsTo: aCollection thatReferTo: aLiteral ]]]].
	
	self
		browseMessageList: aCollection asSet
		name: 'References to Views from non-Views'.! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'jmv 7/7/2025 14:55:57' prior: 16807323!
                  askAndAddSenderOf: classOfSenderToAdd 
		
	| senderSelector senderToAdd |
	
	senderSelector := self request: 'Selector of sender of #', self oldSelector initialAnswer: '' orCancel: [^self ].
	senderToAdd := classOfSenderToAdd 
		compiledMethodAt: senderSelector asSymbol
		ifAbsent: [ ^self inform: classOfSenderToAdd doesNotImplement: senderSelector asSymbol].
		
	(senderToAdd sendsSelector: self oldSelector) ifFalse: [
		^self inform: senderToAdd classAndSelector, ' does not refer to #', self oldSelector ].
	
	self addToList: senderToAdd! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'jmv 7/7/2025 14:55:54' prior: 16884940!
                         askAndAddAllUsagesInSenderOf: classOfSenderToAdd

	"Adds all usages of the selected sender to the usages to refactor"
	| senderSelector senderToAdd |

	senderSelector := self request: 'Selector of sender of #', self selectorToInline initialAnswer: '' orCancel: [^self ].
	senderToAdd := classOfSenderToAdd
		compiledMethodAt: senderSelector asSymbol
		ifAbsent: [ ^self inform: classOfSenderToAdd doesNotImplement: senderSelector asSymbol].

	(senderToAdd sendsSelector: self selectorToInline) ifFalse: [
		^self inform: senderToAdd classAndSelector, ' does not refer to #', self selectorToInline].

	(applier refactoringClass findReferencesToSelector: self selectorToInline in: senderToAdd asMethodReference)
		do: [:aMessageNodeReference | self addToList: aMessageNodeReference]! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'jmv 7/7/2025 14:55:40' prior: 16806248!
addToSendersIfOldSelectorIsSentIn: newImplementor
	
	(newImplementor sendsSelector: oldSelector) ifTrue: [
		senders add: newImplementor ].! !
!ChangeSelector class methodsFor: 'pre-conditions' stamp: 'jmv 7/7/2025 14:55:31' prior: 16806422!
              assertAllSenders: senders send: aSelector

	| invalidSenders |
	
	invalidSenders := senders reject: [ :aSender | aSender sendsSelector: aSelector ].
	invalidSenders notEmpty ifTrue: [ self signalInvalidSenders: invalidSenders of: aSelector ].! !

SystemDictionary removeSelector: #hasSpecialSelector:ifTrueSetByte:!

!methodRemoval: SystemDictionary #hasSpecialSelector:ifTrueSetByte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:28'!
hasSpecialSelector: aLiteral ifTrueSetByte: aBlock
	1 to: self specialSelectorSize do:
		[:index | 
		(self specialSelectorAt: index) == aLiteral
			ifTrue: [aBlock value: index + 16rAF. ^true]].
	^false!

CompiledMethod removeSelector: #refersToLiteral:!

!methodRemoval: CompiledMethod #refersToLiteral: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:28'!
refersToLiteral:aLiteral

	^self hasLiteral: aLiteral.!

CompiledMethod removeSelector: #sendsOrRefersTo:!

!methodRemoval: CompiledMethod #sendsOrRefersTo: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:28'!
sendsOrRefersTo: aSelector

	^ (self hasLiteral: aSelector) or: [ self sendsSelector: aSelector ]!

Behavior removeSelector: #addMethodsTo:thatReferenceTo:!

Behavior removeSelector: #addTo:methodsThatReferenceInHierarchyTo:special:byte:!

!methodRemoval: Behavior #addTo:methodsThatReferenceInHierarchyTo:special:byte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:28'!
addTo: aSet methodsThatReferenceInHierarchyTo: aSymbol special: special byte: byte.
	
	self withAllSuperAndSubclassesDo: [ :class |
		class addMethodsTo: aSet thatReferenceTo: aSymbol special: special byte: byte ] 
		!

Behavior removeSelector: #addTo:methodsThatReferenceInHierarchyTo:!

Behavior removeSelector: #addMethodsTo:thatReferenceTo:special:byte:!

!methodRemoval: Behavior #addMethodsTo:thatReferenceTo:special:byte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:28'!
addMethodsTo: methodsReferencingLiteral thatReferenceTo: aLiteral special: specialFlag byte: specialByte
	
	| selectors |
	
	selectors := self whichSelectorsReferTo: aLiteral special: specialFlag byte: specialByte.
	selectors do: [ :sel | methodsReferencingLiteral add: (MethodReference class: self selector: sel) ]!

Behavior removeSelector: #addMethodsTo:thatReferenceExplicitlyTo:!

Behavior removeSelector: #whichSelectorsReferTo:special:byte:!

!methodRemoval: Behavior #whichSelectorsReferTo:special:byte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:28'!
whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteral: literal)
			ifTrue: [
				((literal isVariableBinding) not
					or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
					or: [(method indexOfLiteral: literal) ~= 0]])
						ifTrue: [who add: sel]]].

	"For special selectors, look for the literal in the source code.
	Otherwise, for example, searching for senders of #== will include senders of #ifNil.
	Except for #at:put:, because it has two arguments and won't find it in the source code like that."
	^ (specialByte isNil or: [ literal = #at:put: ]) 
		ifTrue: [ who ]
		ifFalse: [ who select: [ :sel | ((self sourceCodeAt: sel) findString: literal) > 0]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7341] on 8 July 2025 at 2:57:54 pm'!
!ChangeSelector class methodsFor: 'pre-conditions' stamp: 'jmv 7/8/2025 14:52:43' prior: 50344255!
     assertAllSenders: senders send: aSelector

	| invalidSenders |
	
	invalidSenders := senders reject: [ :aSender | aSender hasLiteral: aSelector ].
	invalidSenders notEmpty ifTrue: [ self signalInvalidSenders: invalidSenders of: aSelector ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7342-assertAllSenders-use-hasLiteral-JuanVuletich-2025Jul08-14h49m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7342] on 10 July 2025 at 1:38:35 pm'!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 7/10/2025 09:39:35' overrides: 16848941!
         at: key ifAbsentPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	^mutex critical: [ super at: key ifAbsentPut: aBlock ]! !
!Dictionary methodsFor: 'accessing' stamp: 'jmv 7/10/2025 09:43:22' prior: 16848941!
                at: key ifAbsentPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	| index assoc newObject |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc ifNotNil: [
		^assoc value ].
	newObject := aBlock value.
	self atNewIndex: index put: (self associationClass key: key value: newObject).
	^ newObject! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7343-atifAbsentPut-JuanVuletich-2025Jul10-13h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7342] on 10 July 2025 at 1:30:09 pm'!
!Dictionary methodsFor: 'accessing' stamp: 'jmv 7/10/2025 10:31:25'!
      at: key ifAbsentOrNilPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	| index assoc newObject |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc ifNotNil: [
		assoc value ifNil: [ assoc value: aBlock value ].
		^assoc value ].
	newObject := aBlock value.
	self atNewIndex: index put: (self associationClass key: key value: newObject).
	^ newObject! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 7/10/2025 10:28:32' overrides: 50344440!
                at: key ifAbsentOrNilPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	^mutex critical: [ super at: key ifAbsentOrNilPut: aBlock ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7344-atifAbsentOrNilPut-JuanVuletich-2025Jul10-13h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7343] on 10 July 2025 at 2:10:48 pm'!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:39:36' prior: 16860084 overrides: 16849155!
                   removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us.
	Note: Usually removing from our instances is done automatically when the key is collected.
	This method usually doesn't need to be called by users of this class."

	^mutex critical: [super removeKey: key ifAbsent: aBlock]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7345-EphemeronDictTweak-JuanVuletich-2025Jul10-14h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7345] on 11 July 2025 at 9:55:23 am'!
!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'jmv 7/11/2025 09:29:27'!
                          classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition

	self
		triggerEvent: #classDefinitionChanged
		withArguments: { oldClass . newClass . oldClassDefinition }! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/11/2025 09:43:21' prior: 16816659!
                         class: oldClass instanceVariableNames: instVarString unsafe: unsafe
	"This is the basic initialization message to change the definition of
	an existing Metaclass"
	| instVars newClass needNew copyOfOldClass oldClassDefinition |
	instVars := Scanner new scanFieldNames: instVarString.
	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].
		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].
	"See if we need a new subclass or not"
	needNew := self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.
	needNew ifNil:[^nil]. "some error"
	needNew ifFalse:[^oldClass]. "no new class needed"

	"Create the new class"
	oldClassDefinition := oldClass definition.
	copyOfOldClass := oldClass copy.
	newClass := self 
		newSubclassOf: oldClass superclass 
		type: oldClass typeOfClass
		instanceVariables: instVars
		from: oldClass.

	"Please see comment at this method. Also see other senders."
	newClass := self recompileSingleRecursion: false from: oldClass to: newClass.
	newClass isNil ifTrue: [ ^nil ].

	self doneCompiling: newClass.
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/11/2025 09:43:14' prior: 16816727!
         name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory behaviorClasses oldClassDefinition |
	
	instVars := Scanner new scanFieldNames: instVarString.
	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass := Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass := nil]. "Already checked in #validateClassName:"
	oldClassDefinition := oldClass ifNotNil: [ oldClass definition ].
	copyOfOldClass := oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class"
		newClass := self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass := oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force := (newClass declareClassVarString: classVarString) | (newClass declareSharedPoolString: poolString).

	"... classify ..."
	organization := Smalltalk organization.
	newCategory := (category isNil or: [ category isEmpty ])
		ifFalse: [category withBlanksTrimmed]
		ifTrue: [organization class defaultClassCategory].
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	(oldClass notNil and: [oldClass includesBehavior: Behavior])
		ifTrue: [
			"This is only true for Behavior, ClassDescription, Class and Metaclass. Special treatment."
			unsafe ifFalse: [
				behaviorClasses := (oldClass withAllSubclasses select: [ :c | c isMeta not ]) asArray.
				(Processor anyReceiverInStackInstanceOfClassIn: behaviorClasses) ifTrue: [
					self error: oldClass name,' has some subInstance running some CompiledMethod.'.
					^nil ]].
			"Please see comment at this method"
			newClass := self recompileSingleRecursion: force from: oldClass to: newClass ]
		ifFalse: [
			"Other classes"
			newClass := self recompile: force from: oldClass to: newClass mutate: false ].
	newClass isNil ifTrue: [ ^nil ].

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: newCategory ].
	^newClass! !
!ClassBuilder methodsFor: 'private' stamp: 'jmv 7/11/2025 09:43:04' prior: 16817201!
                 recordClass: oldClass replacedBy: newClass
	"Keep the changes up to date when we're moving instVars around"

	(instVarMap includesKey: oldClass name) ifTrue:[
		SystemChangeNotifier uniqueInstance
			classDefinitionChangedFrom: oldClass
			to: newClass
			oldClassDefinition: oldClass definition.
	].! !
!Class methodsFor: 'class variables' stamp: 'jmv 7/11/2025 09:42:53' prior: 16815557!
                          addClassVarName: aString
	"Add the argument, aString, as a class variable of the receiver.
	Signal an error if the first character of aString is not capitalized,
	or if it is already a variable named in the class."
	| symbol oldState oldDefinition |
	oldDefinition := self definition.
	oldState := self copy.
	aString first isLowercase
		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].
	symbol := aString asSymbol.
	self withAllSubclasses do: 
		[:subclass | 
		(subclass bindingOf: symbol) ifNotNil:[
			^ self error: aString 
				, ' is already used as a variable name in class ' 
				, subclass name]].
	classPool ifNil: [classPool := Dictionary new].
	(classPool includesKey: symbol) ifFalse: [
		"Pick up any refs in Undeclared"
		classPool declare: symbol from: Undeclared.
		SystemChangeNotifier uniqueInstance
			classDefinitionChangedFrom: oldState
			to: self
			oldClassDefinition: oldDefinition ].! !

SystemChangeNotifier removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: SystemChangeNotifier #classDefinitionChangedFrom:to: stamp: 'Install-7346-classDefinitionChanged-provide-oldClass-definition-JuanVuletich-2025Jul11-09h54m-jmv.001.cs.st 7/15/2025 11:02:28'!
classDefinitionChangedFrom: oldClass to: newClass

	self
		triggerEvent: #classDefinitionChanged
		withArguments: { oldClass . newClass }!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7346-classDefinitionChanged-provide-oldClass-definition-JuanVuletich-2025Jul11-09h54m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7346] on 11 July 2025 at 5:00:08 pm'!

Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameInstanceVariable category: #'Tools-Refactoring' stamp: 'Install-7347-classDefinitionChanged-use-oldClassDefinition-p1-JuanVuletich-2025Jul11-16h52m-jmv.002.cs.st 7/15/2025 11:02:28'!
Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!Inspector methodsFor: 'private' stamp: 'jmv 7/11/2025 16:48:11'!
                classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition

	self objectClass = newClass ifTrue: [self changed: #fieldList]! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 7/11/2025 16:39:58'!
                          noteChangeClass: class from: oldClass oldClassDefinition: oldClassDefinition
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorClassDefinition: oldClassDefinition.
	self noteClassStructure: oldClass.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'system change notifications' stamp: 'jmv 7/11/2025 16:40:32'!
                classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition

	(newClass hasChangedComparedTo: oldClass) ifTrue: [ 
		self noteChangeClass: newClass from: oldClass oldClassDefinition: oldClassDefinition ]! !
!ChangeSet class methodsFor: 'system change notifications' stamp: 'jmv 7/11/2025 16:41:58'!
                        classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition
	"In case the class is moved from one package to another, both change sets should be affected.
	But there's no need to do it here, as #classRecategorized:from:to: is also called."

	| packageOrNil |
	
	newClass wantsChangeSetLogging ifFalse: [ ^self ].
	
	packageOrNil := CodePackage packageOfClass: newClass ifNone: nil.
	(self changeSetForPackage: packageOrNil) ifNotNil: [ :changeSet |
		changeSet classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition ].
	packageOrNil ifNotNil: [
		packageOrNil hasUnsavedChanges: true ]! !
!ClassChangeRecord methodsFor: 'definition' stamp: 'jmv 7/11/2025 16:38:29'!
       notePriorClassDefinition: oldClassDefinition

	oldClassDefinition ifNil: [^ self].
	priorDefinition ifNil: [priorDefinition := oldClassDefinition]! !
!Inspector methodsFor: 'initialization' stamp: 'jmv 7/11/2025 16:56:40' prior: 16888662!
                 initializeEvents

	SystemChangeNotifier uniqueInstance
		when: #classDefinitionChanged send: #classDefinitionChangedFrom:to:oldClassDefinition: to: self! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'jmv 7/11/2025 16:45:42' prior: 16947922!
                          logChange
		
	Smalltalk
		logChange: classToRefactor definition 
		preamble: classToRefactor definitionPreamble.
		
	ChangeSet
		classDefinitionChangedFrom: originalClassToRefactor
		to: classToRefactor
		oldClassDefinition: originalClassDefinition.! !
!RenameInstanceVariable methodsFor: 'applying' stamp: 'jmv 7/11/2025 16:45:12' prior: 16947985 overrides: 16944602!
               apply

	originalClassDefinition := classToRefactor definition.
	originalClassToRefactor := classToRefactor copy.
	
	self 
		lookForMethodsReferencingOldVariable;
		changeInstanceVariableName;
		logChange;
		renameReferencesToOldVariable.
		
	^renamedReferences 
		! !

Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameInstanceVariable category: #'Tools-Refactoring' stamp: 'Install-7347-classDefinitionChanged-use-oldClassDefinition-p1-JuanVuletich-2025Jul11-16h52m-jmv.002.cs.st 7/15/2025 11:02:28'!
Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Inspector allSubInstancesDo: [ :i | i initializeEvents ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7347-classDefinitionChanged-use-oldClassDefinition-p1-JuanVuletich-2025Jul11-16h52m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7347] on 11 July 2025 at 5:16:26 pm'!
!ChangeSet class methodsFor: 'class initialization' stamp: 'jmv 7/11/2025 17:15:40' prior: 16809023 overrides: 16924243!
           initialize
	"
	ChangeSet initialize
	"
	AllChangeSets := OrderedCollection new.

	"Avoid double registration"
	SystemChangeNotifier uniqueInstance removeActionsWithReceiver: self.
	SystemChangeNotifier uniqueInstance
		when: #classAdded send: #classAdded:inCategory: to: self;
		when: #classCommented send: #classCommented: to: self;
		when: #classDefinitionChanged send: #classDefinitionChangedFrom:to:oldClassDefinition: to: self;
		when: #classRecategorized send: #classRecategorized:from:to: to: self;
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #aboutToRenameClass send: #aboutToRenameClass:from:to:inCategory: to: self;
		when: #classReorganized send: #classReorganized: to: self;
		when: #methodAddedInProtocolTimeStamp send: #methodAdded:selector:inProtocol:class:methodTimeStamp:requestor: to: self;
		when: #methodChanged send: #methodChangedFrom:to:selector:inClass:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self;
		when: #selectorRecategorized send: #selectorRecategorized:from:to:inClass: to: self.! !

ClassChangeRecord removeSelector: #notePriorDefinition:!

!methodRemoval: ClassChangeRecord #notePriorDefinition: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:28'!
notePriorDefinition: oldClass

	oldClass ifNil: [^ self].
	priorDefinition ifNil: [priorDefinition := oldClass definition]!

ChangeSet class removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: ChangeSet class #classDefinitionChangedFrom:to: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:28'!
classDefinitionChangedFrom: oldClass to: newClass
	"In case the class is moved from one package to another, both change sets should be affected.
	But there's no need to do it here, as #classRecategorized:from:to: is also called."

	| packageOrNil |
	
	newClass wantsChangeSetLogging ifFalse: [ ^self ].
	
	packageOrNil := CodePackage packageOfClass: newClass ifNone: nil.
	(self changeSetForPackage: packageOrNil) ifNotNil: [ :changeSet |
		changeSet classDefinitionChangedFrom: oldClass to: newClass ].
	packageOrNil ifNotNil: [
		packageOrNil hasUnsavedChanges: true ]!

ChangeSet removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: ChangeSet #classDefinitionChangedFrom:to: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:28'!
classDefinitionChangedFrom: oldClass to: newClass

	(newClass hasChangedComparedTo: oldClass) ifTrue: [ 
		self noteChangeClass: newClass from: oldClass ]!

ChangeSet removeSelector: #noteChangeClass:from:!

!methodRemoval: ChangeSet #noteChangeClass:from: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:29'!
noteChangeClass: class from: oldClass
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorDefinition: oldClass.
	self noteClassStructure: oldClass.
	self hasUnsavedChanges: true!

Inspector removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: Inspector #classDefinitionChangedFrom:to: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:29'!
classDefinitionChangedFrom: oldClass to: newClass

	self objectClass = newClass ifTrue: [self changed: #fieldList]!

ChangeSet initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7349] on 14 July 2025 at 10:55:42 am'!
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:40:17' prior: 50344511!
              class: oldClass instanceVariableNames: instVarString unsafe: unsafe
	"This is the basic initialization message to change the definition of
	an existing Metaclass"
	| instVars newClass needNew copyOfOldClass oldClassDefinition |
	instVars := Scanner new scanFieldNames: instVarString.
	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].
		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].
	"See if we need a new subclass or not"
	needNew := self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.
	needNew ifNil:[^nil]. "some error"
	needNew ifFalse:[^oldClass]. "no new class needed"

	"Create the new class. Include all methods from oldClass recompiled for it."
	oldClassDefinition := oldClass definition.
	copyOfOldClass := oldClass copy.
	newClass := self 
		newSubclassOf: oldClass superclass 
		type: oldClass typeOfClass
		instanceVariables: instVars
		from: oldClass.

	"Please see comment at this method. Also see other senders."
	newClass := self recompileSingleRecursion: false from: oldClass to: newClass.
	newClass isNil ifTrue: [ ^nil ].

	self doneCompiling: newClass.
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:39:06' prior: 50344560!
                   name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory behaviorClasses oldClassDefinition |
	
	instVars := Scanner new scanFieldNames: instVarString.
	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass := Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass := nil]. "Already checked in #validateClassName:"
	oldClassDefinition := oldClass ifNotNil: [ oldClass definition ].
	copyOfOldClass := oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class. Include all methods from oldClass recompiled for it."
		newClass := self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass := oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force := (newClass declareClassVarString: classVarString) | (newClass declareSharedPoolString: poolString).

	"... classify ..."
	organization := Smalltalk organization.
	newCategory := (category isNil or: [ category isEmpty ])
		ifFalse: [category withBlanksTrimmed]
		ifTrue: [organization class defaultClassCategory].
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	(oldClass notNil and: [oldClass includesBehavior: Behavior])
		ifTrue: [
			"This is only true for Behavior, ClassDescription, Class and Metaclass. Special treatment."
			unsafe ifFalse: [
				behaviorClasses := (oldClass withAllSubclasses select: [ :c | c isMeta not ]) asArray.
				(Processor anyReceiverInStackInstanceOfClassIn: behaviorClasses) ifTrue: [
					self error: oldClass name,' has some subInstance running some CompiledMethod.'.
					^nil ]].
			"Please see comment at this method"
			newClass := self recompileSingleRecursion: force from: oldClass to: newClass ]
		ifFalse: [
			"Other classes"
			newClass := self recompile: force from: oldClass to: newClass mutate: false ].
	newClass isNil ifTrue: [ ^nil ].

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: newCategory ].
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:53:40' prior: 16816886!
                  recompile: force from: oldClass to: newClass mutate: forceMutation
	"Do the necessary recompilation after changing oldClass to newClass.
	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass
	and all its subclasses. If forceMutation is true force a mutation even
	if oldClass and newClass are the same."

	| compilationSuccess compilationErrorDescription |
	oldClass
		ifNil: [^ newClass].

	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[
		^newClass].

	currentClassIndex := 0.
	maxClassIndex := oldClass withAllSubclasses size.

	(oldClass == newClass and:[forceMutation not]) ifTrue:[
		"Recompile from newClass without mutating"
		self informUserDuring:[
			newClass withAllSubclassesDo: [ :cl |
				self showProgressFor: cl.
				cl compileAll]].
		^newClass].

	"Recompile oldClass and subclasses to newClass and subclasses.
	Recompile all the methods in the newly created classes."
	self informUserDuring: [
		compilationSuccess := true.
		[self createHierarchy: oldClass to: newClass] on: Error do: [ :exception |
			"If compilation failed, don't continue!!"
			compilationErrorDescription := exception printString.
			compilationSuccess := false ].
	].

	compilationSuccess ifFalse: [
		oldClass superclass removeSubclass: newClass.
		Smalltalk garbageCollect.
		Error signal: compilationErrorDescription, '. Please see Transcript.'.
		^ nil ].

	(newClass canUpdateFrom: oldClass) ifFalse: [
		MethodInCallStackToBecomeInvalid signal ifFalse: [
			oldClass superclass removeSubclass: newClass.
			Smalltalk garbageCollect.
			'Class reshaping aborted.' print.
			Error signal: oldClass name, 
				' has some subInstance running a CompiledMethod that would become invalid. Please see Transcript.'.
			^nil ]].

	"Make newClass thake the place of oldClass in the system: update instances and references.
	Do it for the whole hierarchy."
	self informUserDuring: [
		self mutateInstances: oldClass to: newClass.
	].
	^oldClass "now mutated to newClass"! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:43:45' prior: 16816946!
           recompileSingleRecursion: force from: oldClass to: newClass
	"Based on #recompile:from:to:mutate:
	Older behavior of that method (before January 2022) did a single BFS on the hierarchy tree,
	creating new classes when traveling downwards, and migrating instances before returning upwards.
	This was changed to build the entire hierarchy, then validate with #canUpdateFrom: and only keep
	the new classes, and migrate instances if #canUpdateFrom: answered true.
	This breaks when recompiling the instance side of the Behavior hierarchy (Behavior, ClassDescription,
	Class and Metaclass).
	This method, appropriate for these classes does a single recursion, i.e. the pre-2022 behavior.
	It uses a more restrictive check for existing instances: It will not allow recompilation if any instance is
	executing any method, regardless of it being affected by the reshaping of the class or not. For this
	reason, for other classes, we prefer the more careful check done by #canUpdateFrom:
	
	See senders."

	(newClass == oldClass and: [force not]) ifTrue:[
		^newClass].

	currentClassIndex := 0.
	maxClassIndex := oldClass withAllSubclasses size.

	(oldClass == newClass) ifTrue: [
		"Recompile from newClass without mutating"
		self informUserDuring: [
			newClass withAllSubclassesDo: [ :cl |
				self showProgressFor: cl.
				cl compileAll ]].
		^newClass].

	"Recompile oldClass and subclasses to newClass and subclasses.
	Recompile all the methods in the newly created classes."
	self informUserDuring: [
		self mutate: oldClass to: newClass.
	].
	^oldClass "now mutated to newClass"! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 7/14/2025 10:51:45' prior: 16817510!
                    createHierarchy: oldClass to: newClass
	"Create a new class hierarchy from the old class and subclasses into newClass and subclasses.
	Recompile all the methods in the newly created classes."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do:[:oldSubclass| | newSubclass |
		"create new class. recompile all methods for it."
		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
		self createHierarchy: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do:[:oldSubclass| | newSubclass |
		oldSubclass ifNotNil:[
			"create new class. recompile all methods for it."
			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
			self createHierarchy: oldSubclass to: newSubclass.
		].
	].
	^newClass! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'eem 6/11/2008 16:47' prior: 16817536!
             mutate: oldClass to: newClass
	"Mutate the old class and subclasses into newClass and subclasses.
	Recompile all the methods in the newly created classes."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do:[:oldSubclass| | newSubclass |
		"create new class. recompile all methods for it."
		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
		self mutate: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do:[:oldSubclass| | newSubclass |
		oldSubclass ifNotNil:[
			"create new class. recompile all methods for it."
			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
			self mutate: oldSubclass to: newSubclass.
		].
	].
	"New class creation with all new methods is done.
	Make newClass thake the place of oldClass in the system: update instances and references."
	self update: oldClass to: newClass.
	^newClass! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 7/14/2025 10:54:49' prior: 50333970!
            mutateInstances: oldClass to: newClass
	"Make newClass thake the place of oldClass in the system: update instances and references.
	Do this for the whole sub hierarchy."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do: [ :oldSubclass | | newSubclass |
		newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ]. 
		self mutateInstances: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do: [ :oldSubclass | | newSubclass |
		oldSubclass ifNotNil: [
			newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ] ifNone: nil.
			newSubclass ifNotNil: [
				self mutateInstances: oldSubclass to: newSubclass ].
		].
	].
	"Make newClass thake the place of oldClass in the system: update instances and references."
	self update: oldClass to: newClass.
	^newClass! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7349-ClassBuilder-comments-JuanVuletich-2025Jul14-10h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7349] on 14 July 2025 at 11:24:46 am'!
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 7/14/2025 11:23:58' prior: 50344799!
                           noteChangeClass: class from: oldClass oldClassDefinition: oldClassDefinition
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorClassDefinition: oldClassDefinition.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 7/14/2025 11:24:07' prior: 50334995!
                 noteRenameClass: class as: newName 
	"Include indication that a class has been renamed."

	| recorder |
	(recorder := self changeRecorderFor: class)
		noteChangeType: #rename;
		noteNewName: newName asSymbol.
		
	"store under new name (metaclass too)"
	changeRecords at: newName put: recorder.
	changeRecords removeKey: class name.

	recorder := changeRecords at: class class name ifAbsent: nil.
	recorder ifNotNil: [
		changeRecords at: (newName, ' class') put: recorder.
		changeRecords removeKey: class class name.
		recorder noteNewName: newName , ' class' ].

	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'moving changes' stamp: 'jmv 7/14/2025 11:23:19' prior: 16808272!
                 removeClassChanges: classOrClassName
	"Remove all memory of changes associated with this class"
	| cname |
	cname := classOrClassName isString
		ifTrue: [ classOrClassName ]
		ifFalse: [ classOrClassName name ].

	changeRecords removeKey: cname ifAbsent: nil.! !

ChangeSet removeSelector: #askAddedInstVars:!

!methodRemoval: ChangeSet #askAddedInstVars: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:29'!
askAddedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly added inst vars need to be non-nil"

	pairList := OrderedCollection new.
	pairClasses := OrderedCollection new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct := (cls allInstVarNames).
		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		newStruct do: [ :instVarName |
			(oldStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index := PopUpMenu withCaption: 'These instance variables were added.
When an old project comes in, newly added 
instance variables will have the value nil.
Click on items to remove them from the list.
Click on any for which nil is an OK value.'
			chooseFrom: pairList, #('all of these need a non-nil value'
						'all of these are OK with a nil value').
		(index <= (pls := pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"!

ChangeSet removeSelector: #askRemovedInstVars:!

!methodRemoval: ChangeSet #askRemovedInstVars: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:29'!
askRemovedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly removed inst vars need to have their info saved"

	pairList := OrderedCollection new.
	pairClasses := OrderedCollection new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct := (cls allInstVarNames).
		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		oldStruct do: [:instVarName |
			(newStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index := PopUpMenu withCaption: 'These instance variables were removed.
When an old project comes in, instance variables 
that have been removed will lose their contents.
Click on items to remove them from the list.
Click on any whose value is unimportant and need not be saved.'
			chooseFrom: pairList, #('all of these need a conversion method'
						'all of these have old values that can be erased').
		(index <= (pls := pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"!

ChangeSet removeSelector: #askRenames:addTo:using:!

!methodRemoval: ChangeSet #askRenames:addTo:using: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:29'!
askRenames: renamed addTo: msgSet using: smart
	| list |
	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."

	list := OrderedCollection new.
	renamed do: [ :cls | | rec |
		rec := changeRecords at: cls name.
		rec priorName ifNotNil: [
			| ans |
			ans := PopUpMenu withCaption: 'You renamed class ', rec priorName, 
				' to be ', rec thisName,
				'.\Could an instance of ', rec priorName, 
				' be in a project on someone''s disk?'
			chooseFrom: #('Yes, write code to convert those instances'
				'No, no instances are in projects').
			ans = 1 ifTrue: [
				| oldStruct newStruct  |
				oldStruct := structures at: rec priorName ifAbsent: nil.
				newStruct := (Array with: cls classVersion), (cls allInstVarNames).
				oldStruct ifNotNil: [
					smart writeConversionMethodIn: cls fromInstVars: oldStruct 
							to: newStruct renamedFrom: rec priorName.
					smart writeClassRename: cls name was: rec priorName.
					list add: cls name, ' convertToCurrentVersion:refStream:']]
			ifFalse: [structures removeKey: rec priorName ifAbsent: nil]]].
	list isEmpty ifTrue: [^ msgSet].
	msgSet messageList ifNil: [msgSet initializeMessageList: list]
		ifNotNil: [list do: [:item | msgSet addMethodReference: item]].
	^ msgSet!

ChangeSet removeSelector: #noteClassForgotten:!

!methodRemoval: ChangeSet #noteClassForgotten: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:29'!
noteClassForgotten: className
	"Remove from structures if class is not a superclass of some other one we are remembering"

	self hasUnsavedChanges: true.	"set the flag in any case"
	structures ifNil: [^ self].
	Smalltalk at: className ifPresent: [:cls |
		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [
			^ self]]].  "No delete"
	structures removeKey: className ifAbsent: nil!

ChangeSet removeSelector: #noteClassStructure:!

!methodRemoval: ChangeSet #noteClassStructure: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:29'!
noteClassStructure: aClass
	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."

	| clsName |
	aClass ifNil: [^ self].
	structures ifNil: [structures := Dictionary new.
				superclasses := Dictionary new].
	clsName := (aClass name asLowercase beginsWith: 'anobsolete') 
		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]
		ifFalse: [aClass name].
	(structures includesKey: clsName) ifFalse: [
		structures at: clsName put: 
			((Array with: aClass classVersion), (aClass allInstVarNames)).
		superclasses at: clsName put: aClass superclass name].
	"up the superclass chain"
	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7350] on 14 July 2025 at 12:05:16 pm'!
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'jmv 7/14/2025 11:57:38'!
           mournAllPending
	"See #finalizationProcess.
	This additional implementation is only to be called one last time before snapshot / quit.
	Warning: Unlike #finalizationProcess, this run is not protected against failure in #mourn.
		Failure in #mourn will halt snapshot / quit"

	self primitiveFetchMourner ifNotNil: [ :firstMourner |
		self mournLoopWith: firstMourner ].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 7/14/2025 11:42:57' prior: 16974753!
         quit
	"Just quit. No questions asked. No validations done.
	Smalltalk quit.
	"

	(SourceFiles at: 2) ifNotNil: [ :changes |
		ChangesInitialFileSize ifNotNil: [ changes truncate: ChangesInitialFileSize ]].
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	ProcessorScheduler stopBackgroundProcess.

	self processShutDownList: true.
	self closeSourceFiles.

	"Be sure all unreferenced objects are finalized as approriate.
	Do this as close to the quit / snapshot primitive as possible."
	self garbageCollect.
	EphemeronFinalizationProcess ensureFinalizationComplete.
	EphemeronFinalizationProcess stopFinalizationProcess.

	"Do image save & quit as apropriate"
	self quitPrimitive.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 7/14/2025 11:59:58' prior: 16975119!
                             snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
	"This is the main method for image save and / or quit.
	See senders."
	"WARNING: Current process will be killed. UI Process will be restarted"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic
	checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
	| activeProc |
	"If it is just about quitting, do it the simpler way."
	save not & quit ifTrue: [
		self quit.
		"Execution doesn't reach this point"
		^self.
	].
	self logSnapshot: save andQuit: quit.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each |
			each isInWorld ifTrue: [ each delete.]].
		UISupervisor ui tearDownDesktop.
		Transcript logToFile: false ].
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	ProcessorScheduler stopBackgroundProcess.
	"Be sure all unreferenced objects are finalized as approriate.
	Do this again later, as close to the snapshot / quit primitive as possible."
	self garbageCollect.
	EphemeronFinalizationProcess ensureFinalizationComplete.
	EphemeronFinalizationProcess stopFinalizationProcess.
	activeProc := Processor activeProcess.
[
	| isARealStartup guiRootObject guiRootObjectClass userBaseDirectory |
	"Stuff needed to relaunch UI on startup"
	guiRootObjectClass := UISupervisor ui class.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	guiRootObject := clearAllStateFlag ifFalse: [ UISupervisor ui ].

	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [ activeProc terminate ].
	guiRootObject ifNotNil: [ guiRootObject releaseCachedState ].
	clearAllStateFlag ifTrue: [
		Processor processesDo: [ :p |
			(p name = 'Formerly: Morphic UI') ifTrue: [ p terminate ]]].
	MorphicCanvas allSubInstancesDo: [ :c |
		c nilState ].
	self processShutDownList: quit.

	"Clean Globals"
	userBaseDirectory := DirectoryEntry userBaseDirectory.
	self at: #Sensor put: nil.
	self closeSourceFiles.
	self at: #SourceFiles put: nil.
	self allClassesDo: [ :cls |
		cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [
		self allClassesDo: [ :cls |
			cls releaseClassState ]].
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [
		Transcript clear.
		"Enable this call to actually see the image clean report."
		false ifTrue: [self printStuffToCleanOnImageSave]].
	(Cursor cursorAt: #writeCursor) activateCursor.
	"The snapshot primitive will run a GC, but any detected Ephemeron will not be finalized, and the finalization
	queue will be cleared by the VM both in running and snapshotted image. This means they will never be finalized.
	To avoid that, just before snapshot, do a GC.
	We also need to do #mournAllPending because TheFinalizationProcess has been already stopped. "
	self garbageCollect.
	EphemeronFinalizationProcess mournAllPending.
	"Do image save & quit as apropriate"
	isARealStartup := false.
	save ifTrue: [
		"The snapshot primitive answers false if it was just called to do the snapshot.
		But image startup is resumed by returning (again) from the primitive, but this time answering true.
		nil means saving image failed"
		isARealStartup := embeddedFlag
			ifTrue: [ self snapshotEmbeddedPrimitive ]
			ifFalse: [ self snapshotPrimitive ]].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ]. "Don't quit on nil (image save failed)"

	isARealStartup == true ifFalse: [ 									"Keep current #userBaseDirectory unless a real startup"
		DirectoryEntry setUserBaseDirectory: userBaseDirectory ].

	"If starting from absolute scratch, this would be a good time to recreate Global names"
	self at: #Sensor put: nil.
	self at: #SourceFiles put: (Array new: 2).
	self logStartupDebugAid: 'To #openSourceFiles'.
	self openSourceFiles.
	"Here, startup begins!! (isARealStartup might be nil)"
	self logStartupDebugAid: 'To #initClassCachedState'.
	self allClassesDo: [ :cls | cls initClassCachedState ].
	self logStartupDebugAid: 'To #doStartUp:'.
	self doStartUp: isARealStartup == true.
	self logStartupDebugAid: 'To #spawnNewMorphicProcessFor: ', guiRootObject printString.
	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject := guiRootObjectClass newWorld ]).
	isARealStartup == true
		ifTrue: [
			self logStartupDebugAid: 'To #checkIfAlreadyRunningOrStoppedNoExit'.
			self checkIfAlreadyRunningOrStoppedNoExit.
			"Some command line arguments need to be processed before starting the UI"
			self processCommandLineArguments: true.
			self assureStartupStampLogged ].
	clearAllStateFlag ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #recreateDefaultDesktop'.
			guiRootObject recreateDefaultDesktop; restoreDisplay ]]
	ifFalse: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #restoreDisplay'.
			guiRootObject restoreDisplay ]].
	"It is needed to do this at least once on MacVMs, where it may not be needed later.
	For instance #forceToScreen: is usually not called in #displayWorldOn: if running on Mac."
	Display forceToScreen.
	isARealStartup == true
		ifTrue: [
			"If system is coming up (VM and image just started)"
			UISupervisor whenUIinSafeState: [
				self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
				self readAndApplyUserPrefs.
				self logStartupDebugAid: 'To #processCommandLineArguments'.
				"Some command line arguments need to be processed after the UI is up, and in the UI process"
				self processCommandLineArguments: false.
				self logStartupDebugAid: 'To #launchApp'.
				AppLauncher launchApp ]]
		ifFalse: [
			"If we are just saving the image"
			UISupervisor whenUIinSafeState: [
				self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
				self readAndApplyUserPrefs ]].
	"Now it's time to raise an error"
	isARealStartup ifNil: [ self logStartupError: 'Failed to write image file (disk full?)' ]
]
	forkAt: Processor timingPriority - 1
	named: 'Startup process'.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7351-RunFinalizationBeforeSnapshotOrQuit-JuanVuletich-2025Jul14-11h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7351] on 14 July 2025 at 4:46:31 pm'!
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 15:50:34'!
                  instVarReadScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var."
	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:13:10'!
                     instVarWriteScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var."
	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:33:01'!
                    pushReceiverScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for push receiver bytecode."
	self subclassResponsibility! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:11:58' overrides: 50346022!
           instVarReadScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genPushInstVar:
	See #genPushInstVarLong:"

	"	0-15	0000 i i i i 				Push Receiver Variable #iiii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"

	^[:b|
		(b < 16)
		or: [b = 226 ]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:27:00' overrides: 50346031!
                    instVarWriteScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genStoreInstVar:
	See #genStoreInstVarLong:
	See #genStorePopInstVar:
	See #genStorePopInstVarLong:"

	"	200-207	11001 iii					Pop and Store Receiver Variable #iii
	*	224			11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	240			11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	*	243			11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b|
		(b >= 200 and: [b < 208])
		or: [b = 240 or: [b = 243]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:32:57' overrides: 50346040!
pushReceiverScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for push receiver bytecode."

	^[ :bc | bc = 76]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:11:13' overrides: 50346022!
             instVarReadScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genPushInstVar:
	See #genPushInstVarLong:"

	^[:b|
		(b < 16)
		or: [(b = 16r80 and: [scanner followingByte <= 16r3F])
		or:  [(b = 16r84 and: [scanner followingByte = 16r40])]]]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:24:18' overrides: 50346031!
                             instVarWriteScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genStoreInstVar:
	See #genStoreInstVarLong:
	See #genStorePopInstVar:
	See #genStorePopInstVarLong:"

	^[:b|
		(b between: 16r60 and: 16r60 + 7)
		or: [(b = 16r81 and: [scanner followingByte <= 16r3F])
		or: [(b = 16r82 and: [scanner followingByte <= 16r3F])
		or: [(b = 16r84 and: [scanner followingByte = 160])
		or: [(b = 16r84 and: [scanner followingByte = 192])]]]]]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:32:34' overrides: 50346040!
                           pushReceiverScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for push receiver bytecode."

	^[ :bc | bc = 112]! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:35:05'!
  pushesSelf
	"Answer whether the receiver pushes self to send a message or pass as argument."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass pushReceiverScanBlock)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:29:06'!
     readsReceiverIvar
	"Answer whether the receiver reads an instance variable of 'self'."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass instVarReadScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:29:23'!
                              writesReceiverIvar
	"Answer whether the receiver writes an instance variable of 'self'."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass instVarWriteScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:44:44' prior: 16794118!
           isCleanClosure
	"A clean closure is one that doesn't really need the home context because:
		- It doesn't send messages to self or super
		- It doesn't use self in any way
		- It doesn't access any instance variable
		- It doesn't access any outer temp
		- It doesn't do ^ return (Non local return, return from method to caller)
	Therefore it doesn't close over a lexical scope, and in this sense they are trivial.
	They can also be called 'context free' or 'simple' block.
	"

	| recreated source |
	source := self decompile decompileString.

	"This catches any acess to outer context!!"
	recreated := [ Compiler evaluate: source. ] on: UndeclaredVariableWarning do: [ :ex | ex return].
	recreated isNil ifTrue: [^false].
	
	recreated hasNonLocalReturn ifTrue: [ ^false ].
	recreated sendsToSuper ifTrue: [ ^false ].
	recreated pushesSelf ifTrue: [ ^false ].
	recreated readsReceiverIvar ifTrue: [ ^false ].
	recreated writesReceiverIvar ifTrue: [ ^false ].

	"Ok."
	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7352-SistaCompatibility-isCleanClosure-JuanVuletich-2025Jul14-16h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7351] on 14 July 2025 at 4:59:03 pm'!
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 7/14/2025 16:57:14' prior: 50343191!
           annotationForSelector: aSelector ofClass: aClass
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	| method |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	method := aClass compiledMethodAt: aSelector ifAbsent: nil.
	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp := self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						method notNil ifTrue: [
							strm
								print: method linesOfCode;
								nextPutAll: ' lines of code' ]].
					[#messageSendsCount] -> [
						method notNil ifTrue: [
							strm
								print: method messageSendsCount;
								nextPutAll: ' message sends' ]].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount := Smalltalk numberOfSendersOf: aSelector.
						sendersCount := sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount := Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount := implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp := VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						method notNil ifTrue: [
							(CodePackage packageOfMethod: method methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList := (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ].
		(method notNil and: [method hasBreakpoint]) ifTrue: [
			strm nextPutAll: self annotationSeparator.
			strm nextPutAll: '[Breakpoint]' ]
	].! !

PseudoClass removeSelector: #closuresInfoAt:!

!methodRemoval: PseudoClass #closuresInfoAt: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
closuresInfoAt: selector
	^''!

SystemDictionary removeSelector: #eliotsClosureMeasurements2!

!methodRemoval: SystemDictionary #eliotsClosureMeasurements2 stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
eliotsClosureMeasurements2
	"
	Smalltalk eliotsClosureMeasurements2
	"
	| numMethods numMethodsWithClosure numMethodsWithIndirectTemps anyClosureDoesNonLocalReturnCount anyClosureUsesSelfCount bothCount onlyCleanBlocksCount anyClosureHasCopiedCount |

	numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=
	anyClosureDoesNonLocalReturnCount := anyClosureUsesSelfCount := bothCount := onlyCleanBlocksCount := 0.
	anyClosureHasCopiedCount := 0.
	self allSelect: [ :m | 
		self eliotsClosureMeasurementsOn: m over: [ :closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
			numMethods := numMethods + 1.
			closuresCount > 0 ifTrue: [ numMethodsWithClosure := numMethodsWithClosure + 1 ].
			hasIndirectTemps ifTrue: [ numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].
			anyClosureDoesNonLocalReturn ifTrue: [ anyClosureDoesNonLocalReturnCount := anyClosureDoesNonLocalReturnCount + 1].
			anyClosureUsesSelf ifTrue: [ anyClosureUsesSelfCount := anyClosureUsesSelfCount + 1].
			(anyClosureDoesNonLocalReturn and: [anyClosureUsesSelf]) ifTrue: [ bothCount := bothCount + 1].
			closuresCount > 0 ifTrue: [
				(anyClosureDoesNonLocalReturn or: [anyClosureUsesSelf or: [anyClosureHasCopied]]) ifFalse: [
					onlyCleanBlocksCount := onlyCleanBlocksCount + 1]].
			anyClosureHasCopied ifTrue: [ anyClosureHasCopiedCount := anyClosureHasCopiedCount + 1 ].
			false.
		]
	].
	^{
		{'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. 
		{'WithClosuresAccessingOuterTemps'. anyClosureHasCopiedCount}.
		{'WithClosuresWritingOuterTemps'. numMethodsWithIndirectTemps}.
		{'WithNonLocalReturnsInClosures'. anyClosureDoesNonLocalReturnCount}. 
		{'WithReferencesToSelfInClosures'. anyClosureUsesSelfCount}. 
		{'BothAbove'. bothCount}.
		{'WithOnlyCleanClosures'. onlyCleanBlocksCount}.
	}!

SystemDictionary removeSelector: #eliotsClosureMeasurements!

!methodRemoval: SystemDictionary #eliotsClosureMeasurements stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
eliotsClosureMeasurements
	"
	Smalltalk eliotsClosureMeasurements
	From http://www.mirandabanda.org/cogblog/2008/11/14/mechanised-modifications-and-miscellaneous-measurements/
	by Eliot Miranda
	"
      | numMethods numMethodsWithClosure numMethodsWithIndirectTemps
         numClosures numClosuresWithCopiedValues numCopiedValuesForClosure
         numRemoteTemps numScopesWithRemoteTemps
         nonLocalReturnsInClosure closureUsesSelfs nonLocalReturnAndUsesSelfs numClean |

        numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=
        numClosures := numClosuresWithCopiedValues := numCopiedValuesForClosure :=
        numRemoteTemps := numScopesWithRemoteTemps :=
        nonLocalReturnsInClosure := closureUsesSelfs := nonLocalReturnAndUsesSelfs := numClean := 0.
        self allSelect: [ :m |
                 | s hasClosure hasIndirectTemps blkPc blkSz doesNonLocalReturn usesSelf hasCopied sel |
                 sel := false.
                 hasClosure := hasIndirectTemps := false.
                 s := InstructionStream on: m.
                 s scanFor:
                          [:b|
                          b = 143 "closure creation" ifTrue:
                                   [hasClosure := true.
                                   numClosures := numClosures + 1.
                                   s followingByte >= 16 ifTrue:
                                            [numClosuresWithCopiedValues := numClosuresWithCopiedValues + 1.
                                             numCopiedValuesForClosure := numCopiedValuesForClosure + (s followingByte >> 4)]].
                          (b = 138 "indirect temp vector creation"
                           and: [s followingByte <= 127]) ifTrue:
                                   [hasIndirectTemps := true.
                                    numScopesWithRemoteTemps := numScopesWithRemoteTemps + 1.
                                    numRemoteTemps := numRemoteTemps + s followingByte].
                          false].
                 numMethods := numMethods + 1.
                 hasClosure ifTrue:
                          [numMethodsWithClosure := numMethodsWithClosure + 1.
                           s pc: m initialPC; scanFor: [:b| b = 143].

"jmv-This looks like the correct place to do this"
                           hasCopied := s followingByte >= 16.

                           blkSz := s interpretNextInstructionFor: BlockStartLocator new.
                           blkPc := s pc.
                           doesNonLocalReturn := usesSelf := false.

"jmv-Doing this here looks like a bug. See the other comment"
                           hasCopied := s followingByte >= 16.

"jmv-Another bug. This only considers the first closure (and any nested closure in it), but not later ones"

                           s scanFor:
                                   [:b|
                                   s pc >= (blkPc + blkSz)
                                            ifTrue: [true]
                                            ifFalse:
                                                     [doesNonLocalReturn := doesNonLocalReturn or: [s willReturn and: [s willBlockReturn not]].
                                                      usesSelf := usesSelf or: [b = 112 "pushSelf"
                                                                                                  or: [b < 16 "pushInstVar"
                                                                                                  or: [(b = 128 and: [s followingByte <= 63]) "pushInstVar"
                                                                                                  or: [(b between: 96 and: 96 + 7) "storePopInstVar"
                                                                                                  or: [(b = 130 and: [s followingByte <= 63]) "storePopInstVar"
                                                                                                  or: [(b = 129 and: [s followingByte <= 63]) "storeInstVar"
                                                                                                  or: [b = 132 and: [s followingByte = 160]]]]]]]].
                                                     false]].
                           doesNonLocalReturn ifTrue:
                                   [nonLocalReturnsInClosure := nonLocalReturnsInClosure + 1].
                           usesSelf ifTrue:
                                   [closureUsesSelfs := closureUsesSelfs + 1].
                           (doesNonLocalReturn and: [usesSelf]) ifTrue:
                                   [nonLocalReturnAndUsesSelfs := nonLocalReturnAndUsesSelfs + 1].
                           (doesNonLocalReturn or: [usesSelf or: [hasCopied]]) ifFalse:
                                   [numClean := numClean + 1]].
                 hasIndirectTemps ifTrue: [numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].
                 sel].
^        { {'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. {'MethodsWithIndirectTemps'. numMethodsWithIndirectTemps}.
         {'Closures'. numClosures}. {'CopiedValuesForClosures'. numCopiedValuesForClosure}. {'ClosuresWithCopiedValues'. numClosuresWithCopiedValues}.
         {'RemoteTemps'. numRemoteTemps}. {'ScopesWithRemoteTemps'. numScopesWithRemoteTemps}.
         {'MethodsWithNonLocalReturnsInClosures'. nonLocalReturnsInClosure}. {'MethodsWithReferencesToSelfInClosures'. closureUsesSelfs}. {'Both'. nonLocalReturnAndUsesSelfs}.
         {'MethodsWithOnlyCleanClosures'. numClean} }!

SystemDictionary removeSelector: #browseMethodsWithOnlyCleanClosures!

!methodRemoval: SystemDictionary #browseMethodsWithOnlyCleanClosures stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
browseMethodsWithOnlyCleanClosures
	"
	Smalltalk browseMethodsWithOnlyCleanClosures
	"
	self
		browseMessageList: (
			self allSelect: [ :m | 
				self eliotsClosureMeasurementsOn: m over: [ :closuresCount
						:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
					closuresCount > 0 and: [
						(anyClosureHasCopied or: [ anyClosureDoesNonLocalReturn or: [ anyClosureUsesSelf ]]) not ].
				]
			])
		name: 'Methods with only Clean Closures'!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatOnlyReadOuterTemps!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatOnlyReadOuterTemps stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
browseMethodsWithClosuresThatOnlyReadOuterTemps
	"
	Smalltalk browseMethodsWithClosuresThatOnlyReadOuterTemps
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount
					:hasIndirectTemps :anyClosureHasCopiedValues :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				anyClosureHasCopiedValues & hasIndirectTemps not].
			])
		name: 'Closures that read but not write to outer temps'!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatAccessOuterTemps!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatAccessOuterTemps stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
browseMethodsWithClosuresThatAccessOuterTemps
	"
	Smalltalk browseMethodsWithClosuresThatAccessOuterTemps
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				anyClosureHasCopied ].
			])
		name: 'Closures that read or write to outer temps'!

SystemDictionary removeSelector: #eliotsClosureMeasurements2On:!

!methodRemoval: SystemDictionary #eliotsClosureMeasurements2On: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
eliotsClosureMeasurements2On: aMethod
	"
	A Couple of Clean Closures
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01Argument
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01LocalTemp
	
	Closures reading and writing to outer temps
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTemp
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempWithAssignment

	Closure doing an method return
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01UpArrowReturn

	Closures sending messages to self & super
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01SelfSend
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01SuperSend

	A couple of non-closures, i.e. blocks that are optimized by the compiler and a closure is never created
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempOptimized
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempOptimizedWithAssignment
	
	A remote temp whose declaration can not be moved inside the block
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempCantBeMovedInside
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempAssignedTwice
	A remote temp whose declaration can be moved inside the block
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempCanBeMovedInside
	A not-so remote temp. The declaration was moved inside the block, making it a clean block
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01LocalTemp
	"
	| numMethods numMethodsWithClosure numMethodsWithIndirectTemps anyClosureDoesNonLocalReturnCount anyClosureUsesSelfCount bothCount onlyCleanBlocksCount anyClosureHasCopiedCount |

	numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=
	anyClosureDoesNonLocalReturnCount := anyClosureUsesSelfCount := bothCount := onlyCleanBlocksCount := 0.
	anyClosureHasCopiedCount := 0.
	self eliotsClosureMeasurementsOn: aMethod over: [ :closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
		numMethods := numMethods + 1.
		closuresCount > 0 ifTrue: [ numMethodsWithClosure := numMethodsWithClosure + 1 ].
		hasIndirectTemps ifTrue: [ numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].
		anyClosureDoesNonLocalReturn ifTrue: [ anyClosureDoesNonLocalReturnCount := anyClosureDoesNonLocalReturnCount + 1].
		anyClosureUsesSelf ifTrue: [ anyClosureUsesSelfCount := anyClosureUsesSelfCount + 1].
		(anyClosureDoesNonLocalReturn and: [anyClosureUsesSelf]) ifTrue: [ bothCount := bothCount + 1].
		closuresCount > 0 ifTrue: [
			(anyClosureDoesNonLocalReturn or: [anyClosureUsesSelf or: [anyClosureHasCopied]]) ifFalse: [
				onlyCleanBlocksCount := onlyCleanBlocksCount + 1]].
		anyClosureHasCopied ifTrue: [ anyClosureHasCopiedCount := anyClosureHasCopiedCount + 1 ].
	].
	^{
		{'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. 
		{'WithClosuresAccessingOuterTemps'. anyClosureHasCopiedCount}.
		{'WithClosuresWritingOuterTemps'. numMethodsWithIndirectTemps}.
		{'WithNonLocalReturnsInClosures'. anyClosureDoesNonLocalReturnCount}. 
		{'WithReferencesToSelfInClosures'. anyClosureUsesSelfCount}. 
		{'BothAbove'. bothCount}.
		{'WithOnlyCleanClosures'. onlyCleanBlocksCount}.
	}!

SystemDictionary removeSelector: #closuresInfoStringForClass:selector:!

!methodRemoval: SystemDictionary #closuresInfoStringForClass:selector: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
closuresInfoStringForClass: aClass selector: aSelector
	"
	Smalltalk closuresInfoStringFor: PlayingWithClosures class >> #exp01Argument
	"
	| answer all someDo noneDoes method |
	method := aClass compiledMethodAt: aSelector ifAbsent: [ ^'' ].
	self eliotsClosureMeasurementsOn: method over: [ 
				:closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
			
		closuresCount > 0
			ifFalse: [ answer := 'No real (non-optimized) Closures' ]
			ifTrue: [
				closuresCount = 1
					ifTrue: [
						answer := '1 Closure: '.
						all := ''.
						someDo := 'does'. 
						noneDoes := 'does not' ]
					ifFalse: [
						answer := closuresCount printString, ' Closures: '.
						all := 'all '.
						someDo := 'some do'. 
						noneDoes := 'none does' ].
				(anyClosureHasCopied or: [ anyClosureDoesNonLocalReturn or: [ anyClosureUsesSelf ]])
					ifFalse: [ answer := answer, all, 'clean' ]
					ifTrue: [
						answer := answer, (anyClosureHasCopied
							ifTrue: [
								hasIndirectTemps
									ifTrue: [ someDo, ' write (and maybe ', someDo, ' read)' ]
									ifFalse: [ someDo, ' read (but ', noneDoes, ' write)' ] ]
							ifFalse: [ noneDoes, ' access' ]), ' outer temps; '.
						answer := answer, (anyClosureDoesNonLocalReturn
							ifTrue: [ someDo ]
							ifFalse: [ noneDoes ]), ' ^return; '.
						answer := answer, (anyClosureUsesSelf
							ifTrue: [ someDo ]
							ifFalse: [ noneDoes ]), ' use self'
					].
			]
		].
		^answer!

SystemDictionary removeSelector: #browseMethodsWithMoreThanOneClosure!

!methodRemoval: SystemDictionary #browseMethodsWithMoreThanOneClosure stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
browseMethodsWithMoreThanOneClosure
	"
	Smalltalk browseMethodsWithMoreThanOneClosure
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				closuresCount > 1 ].
			])
		name: 'Methods with more than one Closure'!

SystemDictionary removeSelector: #eliotsClosureMeasurementsOn:over:!

!methodRemoval: SystemDictionary #eliotsClosureMeasurementsOn:over: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
eliotsClosureMeasurementsOn: m over: aFiveArgBlock
	"
	See senders.
	Or try something like:
		Smalltalk
			eliotsClosureMeasurementsOn: FileList >> #defaultContents
			over: [ :closuresCount :hasCopiedValuesForClosure :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				(Array with: closuresCount with: hasCopiedValuesForClosure with: hasIndirectTemps with: anyClosureHasCopied with: anyClosureDoesNonLocalReturn with: anyClosureUsesSelf)]

	From http://www.mirandabanda.org/cogblog/2008/11/14/mechanised-modifications-and-miscellaneous-measurements/
	by Eliot Miranda
	
	Note: This could perhaps be refactored to use the newer #embeddedBlockClosures and testing methods on the closures themselves.
	"
	| s nextScanStart thisClosureHasCopied closuresCount hasIndirectTemps blkPc blkSz anyClosureHasCopied anyClosureDoesNonLocalReturn anyClosureUsesSelf analyzedClosures |
	closuresCount := 0.
	hasIndirectTemps := false.
	anyClosureHasCopied :=  anyClosureDoesNonLocalReturn := anyClosureUsesSelf := false.
	s := InstructionStream on: m.
	s scanFor: [ :b |
		b = 16r8F "16r8F = 143 closure creation" ifTrue: [
			closuresCount := closuresCount + 1].
		(b = 16r8A "16r8A = 138indirect temp vector creation" and: [ s followingByte <= 127]) ifTrue: [
				hasIndirectTemps := true].
		false].
	nextScanStart := m initialPC.
	analyzedClosures := 0.
	[ analyzedClosures < closuresCount ] whileTrue: [
		s pc: nextScanStart; scanFor: [ :b | b = 16r8F ].	"16r8F = 143 Search for first closure"
		analyzedClosures := analyzedClosures + 1.
		thisClosureHasCopied := s followingByte >= 16r10.
		anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.
		blkSz := s interpretNextInstructionFor: BlockStartLocator new.		"Findout size of first closure"
		blkPc := s pc.
		s scanFor: [ :b |
			s pc >= (blkPc + blkSz)
				ifTrue: [
					nextScanStart := s pc.
					true]
				ifFalse: [
					b = 16r8F ifTrue: [			
						thisClosureHasCopied := s followingByte >= 16r10.
						anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.
						analyzedClosures := analyzedClosures + 1 ].
					anyClosureDoesNonLocalReturn := anyClosureDoesNonLocalReturn or: [s willReturn and: [s willBlockReturn not]].
					anyClosureUsesSelf := anyClosureUsesSelf or: [b = 16r70 "pushSelf"
										or: [b < 16r10 "pushInstVar"
										or: [(b = 16r80 and: [s followingByte <= 16r3F]) "pushInstVar"
										or: [(b between: 16r60 and: 16r60 + 7) "storePopInstVar"
										or: [(b = 16r82 and: [s followingByte <= 63]) "storePopInstVar"
										or: [(b = 16r81 and: [s followingByte <= 63]) "storeInstVar"
										or: [b = 16r84 and: [s followingByte = 160]]]]]]]].
					false]]].
	^aFiveArgBlock valueWithArguments: (Array
			with: closuresCount
			with: hasIndirectTemps
			with: anyClosureHasCopied
			with: anyClosureDoesNonLocalReturn
			with: anyClosureUsesSelf)!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatWriteOuterTemps!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatWriteOuterTemps stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
browseMethodsWithClosuresThatWriteOuterTemps
	"
	Smalltalk browseMethodsWithClosuresThatWriteOuterTemps
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				hasIndirectTemps ].
			])
		name: ' Closures that write to outer temps'!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise
	"
	Smalltalk browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				hasIndirectTemps and: [  anyClosureDoesNonLocalReturn not and: [ anyClosureUsesSelf not ] ] ].
			])
		name: ' Closures that write to outer temps, but clean otherwise'!

Behavior removeSelector: #closuresInfoAt:!

!methodRemoval: Behavior #closuresInfoAt: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:29'!
closuresInfoAt: selector
	^Smalltalk closuresInfoStringForClass: self selector: selector!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:14:27 am'!
!BytecodeEncoder methodsFor: 'testing' stamp: 'jmv 7/15/2025 10:10:03'!
      hasLocalNamed: aName

	^ scopeTable includesKey: aName ! !

EncoderForV3PlusClosures removeSelector: #hasLocalNamed:!

!methodRemoval: EncoderForV3PlusClosures #hasLocalNamed: stamp: 'Install-7354-hasLocalNamed-moveUp-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st 7/15/2025 11:02:29'!
hasLocalNamed: aName

	^ scopeTable includesKey: aName !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7354-hasLocalNamed-moveUp-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:15:30 am'!
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 7/15/2025 09:11:32'!
  initSortBlocks

	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7355-World-initSortBlocks-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:14:53 am'!
!CompiledMethod class methodsFor: 'preferences' stamp: 'jmv 7/15/2025 09:50:34'!
                       useSistaBytecodes
	"
	CompiledMethod useSistaBytecodes.

		| nPrimary nSecondary |
		nPrimary := nSecondary := 0.
		self allSubInstancesDo:
			[:cm|
			cm header >= 0
				ifTrue: [nPrimary := nPrimary + 1]
				ifFalse: [nSecondary := nSecondary + 1]].
		{nPrimary. nSecondary} print
	"
	self preferredBytecodeSetEncoderClass: EncoderForSistaV1.
	Compiler recompileAll.
	ProcessorScheduler startUp.
	Delay startTimerEventLoop.
	EphemeronFinalizationProcess restartFinalizationProcess.
	Sensor installInterruptWatcher.
	Sensor installEventTickler.
	UISupervisor ui ifNotNil: [ :w |
		[
			w showTaskbar.
			UISupervisor newUIProcess.
			Smalltalk garbageCollect ] fork.
		w
			initSortBlocks;
			hideTaskbar ].
	PreferenceSet installMiscPreferences.
	Smalltalk garbageCollect.! !
!CompiledMethod class methodsFor: 'preferences' stamp: 'jmv 7/15/2025 09:55:43'!
     useV3Bytecodes
	"
	CompiledMethod useV3Bytecodes.

		| nPrimary nSecondary |
		nPrimary := nSecondary := 0.
		self allSubInstancesDo:
			[:cm|
			cm header >= 0
				ifTrue: [nPrimary := nPrimary + 1]
				ifFalse: [nSecondary := nSecondary + 1]].
		{nPrimary. nSecondary} print
	"
	self preferredBytecodeSetEncoderClass: EncoderForV3PlusClosures.
	Compiler recompileAll.
	ProcessorScheduler startUp.
	Delay startTimerEventLoop.
	EphemeronFinalizationProcess restartFinalizationProcess.
	Sensor installInterruptWatcher.
	Sensor installEventTickler.
	UISupervisor ui ifNotNil: [ :w |
		[
			w showTaskbar.
			UISupervisor newUIProcess.
			Smalltalk garbageCollect ] fork.
		w
			initSortBlocks;
			hideTaskbar ].
	PreferenceSet installMiscPreferences.
	Smalltalk garbageCollect.! !
!CompiledMethod class methodsFor: 'preferences' stamp: 'jmv 7/15/2025 08:49:52' prior: 16836417!
                    preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass
	"Set the class that determines the bytecode set used to compile methods with.

		| nPrimary nSecondary |
		nPrimary := nSecondary := 0.
		self allSubInstancesDo:
			[:cm|
			cm header >= 0
				ifTrue: [nPrimary := nPrimary + 1]
				ifFalse: [nSecondary := nSecondary + 1]].
		{nPrimary. nSecondary} print
	"
	| nPrimary nSecondary |
	self assert: (aBytecodeEncoderSubclass includesBehavior: BytecodeEncoder).
	(aBytecodeEncoderSubclass == PrimaryBytecodeSetEncoderClass
	 or: [aBytecodeEncoderSubclass == SecondaryBytecodeSetEncoderClass]) ifTrue:
		[PreferredBytecodeSetEncoderClass := aBytecodeEncoderSubclass.
		 ^self].
	nPrimary := nSecondary := 0.
	self allSubInstancesDo:
		[:cm|
		 cm header >= 0
			ifTrue: [nPrimary := nPrimary + 1]
			ifFalse: [nSecondary := nSecondary + 1]].
	nPrimary = 0 ifTrue:
		[self installPrimaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	nSecondary = 0 ifTrue:
		[self installSecondaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	self error: 'Cannot set preferred bytecode set.  Both of the current sets appear to be in use.'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7356-BytecodeSet-selection-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:16:29 am'!

Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType currentMethod infoFromRemoval stamp '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #MethodChangeRecord category: #'Tools-Changes' stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:29'!
Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType currentMethod infoFromRemoval stamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!
!MethodChangeRecord commentStamp: '<historical>' prior: 16905461!
              MethodChangeRecords are used to record method changes.  Here is a simple summary of the relationship between the changeType symbol and the recording of prior state

					|	prior == nil			|	prior not nil	
	---------	|----------------------------	|--------------------
			add		|	add					|	change
	---------	|----------------------------	|--------------------
			remove	|	addedThenRemoved	|	remove

Structure:
changeType		symbol -- as summarized above
currentMethod	method
				This is the current version of the method.
				It can be used to assert this change upon entry to a layer. 
infoFromRemoval -- an array of size 2.
				The first element is the source index of the last version of the method.
				The second element is the category in which it was defined, so it
				can be put back there if re-accepted from a version browser.

Note that the above states each have an associated revoke action:
	add --> remove
	change --> change back
	remove --> add back
	addedThenRemoved --> no change
However all of these are accomplished trivially by restoring the original method dictionary.!
!ClassChangeRecord methodsFor: 'method changes' stamp: 'jmv 7/15/2025 09:02:59' prior: 16818384!
noteNewMethod: newMethod selector: selector priorMethod: methodOrNil

	| methodChange |
	methodChange := self findOrMakeMethodChangeAt: selector priorMethod: methodOrNil.
	methodOrNil
		ifNil: [ methodChange noteChangeType: #add ]
		ifNotNil: [ methodChange noteChangeType: #change ].
! !

MethodChangeRecord removeSelector: #storeDataOn:!

!methodRemoval: MethodChangeRecord #storeDataOn: stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:29'!
storeDataOn: aDataStream
	| oldMethod |
	oldMethod := currentMethod.
	currentMethod := nil.
	super storeDataOn: aDataStream.
	currentMethod := oldMethod.
!

MethodChangeRecord removeSelector: #currentMethod!

!methodRemoval: MethodChangeRecord #currentMethod stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:29'!
currentMethod

	^ currentMethod!

MethodChangeRecord removeSelector: #noteNewMethod:!

!methodRemoval: MethodChangeRecord #noteNewMethod: stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:29'!
noteNewMethod: newMethod

	currentMethod := newMethod!

ClassChangeRecord removeSelector: #compileAll:from:!

!methodRemoval: ClassChangeRecord #compileAll:from: stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:29'!
compileAll: newClass from: oldClass
	"Something about this class has changed.  Locally retained methods must be recompiled.
	NOTE:  You might think that if this changeSet is in force, then we can just note
	the new methods but a lower change set may override and be in force which
	would mean that only the overriding copies go recompiled.  Just do it."

	methodChanges associationsDo:
		[:assn | | sel changeType changeRecord newMethod |
		sel := assn key.
		changeRecord := assn value.
		changeType := changeRecord changeType.
		(changeType == #add or: [changeType == #change]) ifTrue:
			[newMethod := newClass
				recompileNonResidentMethod: changeRecord currentMethod
				atSelector: sel from: oldClass.
			changeRecord noteNewMethod: newMethod]]!

Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType infoFromRemoval stamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #MethodChangeRecord category: #'Tools-Changes' stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:29'!
Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType infoFromRemoval stamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7357] on 15 July 2025 at 10:47:33 am'!
!SerializableBlockClosure methodsFor: 'initialization' stamp: 'jmv 7/15/2025 10:41:23' prior: 16957120!
onBlockClosure: aBlockClosure

	| both blockNode methodNode indirectTempNames sortedOuterTemps ownNames usedOuterNames sortedUsedOuterNames |
	aBlockClosure hasNonLocalReturn ifTrue: [
		self error: 'Can not serialize closures with non-local returns.' ].
	aBlockClosure sendsToSuper ifTrue: [
		self error: 'Can not currently serialize closures with super sends.' ].
'tota!!' print.
	both := SerializableClosureDecompiler new  decompileBlockAndMethod: aBlockClosure.
	blockNode := both first.
	methodNode := both second.

	indirectTempNames := methodNode temporaries
		detect: [ :node | node isIndirectTempVector ]
		ifFound: [ :node | node remoteTemps collect: [ :n | n name ]]
		ifNone: [#()].
	sortedOuterTemps := OrderedCollection new.
	aBlockClosure outerContextsDo: [ :c | c closure ifNotNil: [ :cc |
		| ccn |
		ccn := cc decompile.
		sortedOuterTemps addAll: ccn arguments; addAll: ccn temporaries ]].
	sortedOuterTemps addAll: methodNode temporaries; addAll: methodNode arguments.

	ownNames := ((blockNode arguments, blockNode temporaries)
		collect: [ :node | node name ]) asSet.
	usedOuterNames := Set new.
	blockNode nodesDo: [ :node | node isTemp ifTrue: [
		(ownNames includes: node name) | (indirectTempNames includes: node name) ifFalse: [
			usedOuterNames add: node name]]].

	sortedUsedOuterNames := sortedOuterTemps select: [ :node |
		usedOuterNames includes: node name ]. "sort them"
	sortedUsedOuterNames := sortedUsedOuterNames collect: [ :node | node name ].

	blockNode nodesDo: [ :node | node isTemp ifTrue: [ 
		node isRemote
			ifTrue: [node capturedIndex: (indirectTempNames indexOf: node name) ]
			ifFalse: [
				(sortedUsedOuterNames includes: node name)
					ifTrue: [node capturedIndex: (sortedUsedOuterNames indexOf: node name)]]]].

	theSelf := aBlockClosure receiver.
	capturedValues := aBlockClosure capturedValues.
	sourceCode := blockNode decompileString.! !

SystemDictionary removeSelector: #unusedBlocks!

!methodRemoval: SystemDictionary #unusedBlocks stamp: 'Install-7358-unusedBlocks-remove-JuanVuletich-2025Jul15-10h41m-jmv.001.cs.st 7/15/2025 11:02:29'!
unusedBlocks
	"Answer all methods that contain a block that is not used (not
	 sent a message, returned, passed as an argument, or assigned)."
	"Smalltalk unusedBlocks"
	"Smalltalk
		browseMessageList: Smalltalk unusedBlocks
		name: 'unused blocks'"
	^self allSelect:
		[:m| | is |
		is := InstructionStream on: m.
		is scanFor: [:b| b = 143 and: [(m at: is thirdByte * 256 + is fourthByte + is pc + 4) = 135]]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7358-unusedBlocks-remove-JuanVuletich-2025Jul15-10h41m-jmv.001.cs.st----!

----QUIT----(15 July 2025 11:02:34) Cuis7.5-7358-32.image priorSource: 200!

----STARTUP---- (22 July 2025 09:53:21) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\Cuis7.5-7358-32.image!


'From Cuis7.5 [latest update: #7358] on 15 July 2025 at 2:23:13 pm'!
!BoxMorph methodsFor: 'layout' stamp: 'jmv 7/15/2025 13:23:51' overrides: 16930414!
                         minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."
	| minExtent |

	^cachedValues at: self ifAbsentPut: [
		minExtent :=  self externalizeDistance: self minimumExtent.
		layoutSpec
			ifNil: [ minExtent ] 
			ifNotNil: [ :ls | minExtent max: ls minimumSpecExtent ]]! !
!PlacedMorph methodsFor: 'layout' stamp: 'jmv 7/15/2025 13:25:05' prior: 16930414 overrides: 16913180!
             minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."
	| minExtent |

	^cachedValues at: self ifAbsentPut: [
		minExtent :=  self minimumExtent.
		layoutSpec
			ifNil: [ minExtent ] 
			ifNotNil: [ :ls | minExtent max: ls minimumSpecExtent ]]! !

Morph removeSelector: #minimumLayoutExtent:!

!methodRemoval: Morph #minimumLayoutExtent: stamp: 'Install-7359-minimumLayoutExtent-fix-JuanVuletich-2025Jul15-14h20m-jmv.001.cs.st 7/22/2025 09:53:21'!
minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."

	^cachedValues at: self ifAbsentPut: [
		self externalizeDistance: self minimumExtent ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7359-minimumLayoutExtent-fix-JuanVuletich-2025Jul15-14h20m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7359] on 17 July 2025 at 9:29:54 am'!
!InstructionClient methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 11:36:04'!
                               doNop
	"Do Nothing Operation bytecode."
! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 11:36:44' overrides: 50347477!
        doNop
	"Print the Do Nothing Operation bytecode."
	self print: 'nop'! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 16:38:06'!
        doNop
	"No action needed"! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 16:43:49'!
                  doNop
	"Simulates the action of a 'No Operation' bytecode."! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:46:14' prior: 16855748!
                           genPushInstVar: instVarIndex
	"0-15 		0000iiii 					Push Receiver Variable #iiii
	 226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"

	(instVarIndex < 0 or: [instVarIndex > 15]) ifTrue:
		[^self genPushInstVarLong: instVarIndex].

	 stream nextPut: 0 + instVarIndex.
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the Sista V1 Bytecode Set is to add a NOP (do nothing)
	byte to use two bytes in any case.
	This is good up to 255 instance variables: Use of #genUnsignedSingleExtendA: requires
	a more expensive approach."
	self genNop.! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 10:21:12' prior: 16856152!
                            genStoreInstVar: instVarIndex
	"243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"

	self genStoreInstVarLong: instVarIndex.! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:46:25' prior: 16856190!
genStorePopInstVar: instVarIndex
	"200-207	11001 iii				Pop and Store Receiver Variable #iii
	 240		11110000	iiiiiiii	Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)"

	(instVarIndex < 0 or: [instVarIndex > 7]) ifTrue:
		[^self genStorePopInstVarLong: instVarIndex].

	stream nextPut: 200 + instVarIndex.
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the Sista V1 Bytecode Set is to add a NOP (do nothing)
	byte to use two bytes in any case.
	This is good up to 255 instance variables: Use of #genUnsignedSingleExtendA: requires
	a more expensive approach."
	self genNop.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:38:57' prior: 16857509!
    genPushInstVar: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	"
	true ifTrue: [
		^self genPushInstVarAllowForIvarsRemapping: instVarIndex ].

	"See BlueBook page 596"
	instVarIndex >= 0 ifTrue:
		[instVarIndex < 16 ifTrue:
			["0-15 	0000iiii 	Push Receiver Variable #iiii"
			 stream nextPut: 0 + instVarIndex.
			 ^self].
		instVarIndex < 64 ifTrue:
			["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"
			 stream
				nextPut: 128;
				nextPut: instVarIndex.
			 ^self]].
	self genPushInstVarLong: instVarIndex.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:40:51' prior: 16857533!
      genPushInstVarAllowForIvarsRemapping: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the V3 Bytecode Set is as follows:
		- never use the single byte bytecodes in [0..15] and [96..103]
		- Use 2 byte bytecodes 128, 129, 130 for ivar accesses up to 9 (even if they can handle up to 63)
		- Use 3 byte bytecode 132 for all ivar accesses, if ivar index >= 10
	This means that the first 10 ivars can be shifted by adding up to 54 ivars in superclasses, and
	other ivars can be shifted by adding any number of ivars in superclasses (up to the 255 ivars limit).
	This is needed for binding class shape modifying DynamicCuisLibraries, or 
	DynamicCuisLibraries built with a different class shape than the image loading them.
	The reason for using 128, 129 and 130 bytecodes for the first ivars is because the VM uses bytecode 132
	with small ivar index to indicate an access to ivars of MethodContext or ContextPart that require a more
	expensive processing. Using 128, 129 or 130 avoids this extra cost.
	This applies both to Spur Interpreter and Cog jitter.
	In the VMMaker package see #isReadMediatedContextInstVarIndex: and #isWriteMediatedContextInstVarIndex:
	The space cost of the use of these longer bytecodes is very small: about 34kb in the official Cuis image, or
	2 bytes per CompiledMethod in average.
	"

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 10]) ifTrue: [
		"128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 128;
			nextPut: instVarIndex.
		 ^self ].
	self genPushInstVarLong: instVarIndex.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:39:16' prior: 16857938!
            genStoreInstVar: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	"
	true ifTrue: [
		^self genStoreInstVarAllowForIvarsRemapping: instVarIndex ].

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 64]) ifTrue: 
		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 129;
			nextPut: instVarIndex.
		 ^self].
	self genStoreInstVarLong: instVarIndex! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:40:57' prior: 16857958!
                    genStoreInstVarAllowForIvarsRemapping: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the V3 Bytecode Set is as follows:
		- never use the single byte bytecodes in [0..15] and [96..103]
		- Use 2 byte bytecodes 128, 129, 130 for ivar accesses up to 9 (even if they can handle up to 63)
		- Use 3 byte bytecode 132 for all ivar accesses, if ivar index >= 10
	This means that the first 10 ivars can be shifted by adding up to 54 ivars in superclasses, and
	other ivars can be shifted by adding any number of ivars in superclasses (up to the 255 ivars limit).
	This is needed for binding class shape modifying DynamicCuisLibraries, or 
	DynamicCuisLibraries built with a different class shape than the image loading them.
	The reason for using 128, 129 and 130 bytecodes for the first ivars is because the VM uses bytecode 132
	with small ivar index to indicate an access to ivars of MethodContext or ContextPart that require a more
	expensive processing. Using 128, 129 or 130 avoids this extra cost.
	This applies both to Spur Interpreter and Cog jitter.
	In the VMMaker package see #isReadMediatedContextInstVarIndex: and #isWriteMediatedContextInstVarIndex:
	The space cost of the use of these longer bytecodes is very small: about 34kb in the official Cuis image, or
	2 bytes per CompiledMethod in average.
	"

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 10]) ifTrue: [
		"129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 129;
			nextPut: instVarIndex.
		 ^self ].
	self genStoreInstVarLong: instVarIndex.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:39:22' prior: 16858062!
                  genStorePopInstVar: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	"
	true ifTrue: [
		^self genStorePopInstVarAllowForIvarsRemapping: instVarIndex ].

	"See BlueBook page 596"
	instVarIndex >= 0 ifTrue:
		[instVarIndex < 8 ifTrue:
			["96-103 	01100iii 	Pop and Store Receiver Variable #iii"
			 stream nextPut: 96 + instVarIndex.
			 ^self].
		instVarIndex < 64 ifTrue:
			["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
			 stream
				nextPut: 130;
				nextPut: instVarIndex.
			 ^self]].
	self genStorePopInstVarLong: instVarIndex! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:41:01' prior: 16858087!
                 genStorePopInstVarAllowForIvarsRemapping: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the V3 Bytecode Set is as follows:
		- never use the single byte bytecodes in [0..15] and [96..103]
		- Use 2 byte bytecodes 128, 129, 130 for ivar accesses up to 9 (even if they can handle up to 63)
		- Use 3 byte bytecode 132 for all ivar accesses, if ivar index >= 10
	This means that the first 10 ivars can be shifted by adding up to 54 ivars in superclasses, and
	other ivars can be shifted by adding any number of ivars in superclasses (up to the 255 ivars limit).
	This is needed for binding class shape modifying DynamicCuisLibraries, or 
	DynamicCuisLibraries built with a different class shape than the image loading them.
	The reason for using 128, 129 and 130 bytecodes for the first ivars is because the VM uses bytecode 132
	with small ivar index to indicate an access to ivars of MethodContext or ContextPart that require a more
	expensive processing. Using 128, 129 or 130 avoids this extra cost.
	This applies both to Spur Interpreter and Cog jitter.
	In the VMMaker package see #isReadMediatedContextInstVarIndex: and #isWriteMediatedContextInstVarIndex:
	The space cost of the use of these longer bytecodes is very small: about 34kb in the official Cuis image, or
	2 bytes per CompiledMethod in average.
	"

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 10]) ifTrue: [
		"130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 130;
			nextPut: instVarIndex.
		 ^self ].
	self genStorePopInstVarLong: instVarIndex.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7360-Sista-ShortIvarAccesses-PadWithNOP-JuanVuletich-2025Jul17-09h27m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7360] on 17 July 2025 at 9:49:14 am'!
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/17/2025 09:20:52'!
                   displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"This initial implementation can not handle inst var indexes greater than 255.
	See #genPushInstVar: #genStoreInstVar: #genStorePopInstVar:"

	| pc end bytecode followingByte oldIvar newIvar bytecodeSize |

	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 > end ifTrue: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			followingByte := aCompiledMethodOrMethodSpec at: pc+1.
			oldIvar := followingByte+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 256 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1.
					(bytecode = 226 and: [ newIvar <= 16 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genPushInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					(bytecode = 240 and: [ newIvar <= 8 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genStorePopInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/17/2025 09:21:37'!
         remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive"
	
	"This initial implementation can not handle inst var indexes greater than 255.
	See #genPushInstVar: #genStoreInstVar: #genStorePopInstVar:"

	| pc end bytecode followingByte oldIvar bytecodeSize |

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 > end ifTrue: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			followingByte := aCompiledMethodOrMethodSpec at: pc+1.
			oldIvar := followingByte+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 256 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1.
					(bytecode = 226 and: [ newIvar <= 16 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genPushInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					(bytecode = 240 and: [ newIvar <= 8 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genStorePopInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/16/2025 16:35:49'!
         displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."

	| pc end bytecode followingByte thirdByte oldIvar newIvar bytecodeSize |
	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		oldIvar >= firstIvarToDisplace ifTrue: [
			aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
			^false ]	.
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			followingByte+1 >= firstIvarToDisplace ifTrue: [
				followingByte+delta < 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: followingByte+delta ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			thirdByte+1 >= firstIvarToDisplace ifTrue: [
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: thirdByte+delta ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/16/2025 16:23:11'!
                        remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !

CompiledMethod class removeSelector: #displaceInstVarAccessesIn:starting:by:doIt:!

!methodRemoval: CompiledMethod class #displaceInstVarAccessesIn:starting:by:doIt: stamp: 'Install-7361-MoveIvarRemapServicesToBytecodeEncoder-AddSista-2025Jul17-09h46m-jmv.cs.st 7/22/2025 09:53:21'!
displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvar. Displace them by delta.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders.
	"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	"Just in case..."
	delta = 0 ifTrue: [ ^true ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				primitiveCode := oldIvar+delta-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true 	].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		oldIvar >= firstIvarToDisplace ifTrue: [
			aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
			^false ]	.
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			followingByte+1 >= firstIvarToDisplace ifTrue: [
				followingByte+delta < 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: followingByte+delta ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			thirdByte+1 >= firstIvarToDisplace ifTrue: [
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: thirdByte+delta ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 						"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true!

CompiledMethod class removeSelector: #remapInstVarAccessesIn:asPer:doIt:!

!methodRemoval: CompiledMethod class #remapInstVarAccessesIn:asPer:doIt: stamp: 'Install-7361-MoveIvarRemapServicesToBytecodeEncoder-AddSista-2025Jul17-09h46m-jmv.cs.st 7/22/2025 09:53:21'!
remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true 	].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 						"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7361-MoveIvarRemapServicesToBytecodeEncoder-AddSista-2025Jul17-09h46m-jmv.cs.st----!

'From Cuis7.5 [latest update: #7361] on 17 July 2025 at 2:13:00 pm'!
!TTFontDescription methodsFor: 'conversion' stamp: 'jmv 7/17/2025 14:10:15' prior: 16981420!
    formGlyphForUtf8Byte1: aByte1 byte2: aByte2OrNil byte3: aByte3OrNil byte4: aByte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"
	| byte1 byte2OrNil byte3OrNil byte4OrNil utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset horizontalStrokesAtPixelCenter xtraRoom form canvas advanceWidth boundsLeft boundsRight boundsBottom boundsTop i deltaXToCenter |

	byte1 := aByte1.
	byte2OrNil := aByte2OrNil.
	byte3OrNil := aByte3OrNil.
	byte4OrNil := aByte4OrNil.
	i := contourDataIndexesByUtf8 at: byte1 + 1.
	utf8ByteArray := ByteArray with: byte1.
	byte2OrNil notNil ifTrue: [
		i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		utf8ByteArray := ByteArray with: byte1 with: byte2OrNil.
		byte3OrNil notNil ifTrue: [
			i := contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil.
			byte4OrNil notNil ifTrue: [
				i := contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1.
				utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil with: byte4OrNil ]]].

	"If glyph not found, take first glyph 'theUnknownGlyph'"
	i = 0 ifTrue: [ i := 1 ].

	advanceWidth := contourDataForUtf8 at: i. i := i + 1.
	boundsLeft := contourDataForUtf8 at: i. i := i + 1.
	boundsRight := contourDataForUtf8 at: i. i := i + 1.
	boundsBottom := contourDataForUtf8 at: i. i := i + 1.
	boundsTop := contourDataForUtf8 at: i. i := i + 1.

	horizontalStrokesAtPixelCenter := 0.5 * 0.
	toPixelsScale := 0.0 + pixelSize / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed"
		xtraRoom := 0.4 "+1".
	leftPixelOffset := (boundsLeft * toPixelsScale - xtraRoom) "floor".
		xtraRoom := 1.8 "+2".
	formWidth := ((boundsRight - boundsLeft) * toPixelsScale + xtraRoom) ceiling.

	"Usually positive. Needed pixels above the baseline"
		xtraRoom := 0.0 "+1".
	topPixelOffset := (boundsTop * toPixelsScale + xtraRoom) ceiling.
		xtraRoom := 1.7 "+2".
	formHeight := ((boundsTop - boundsBottom) * toPixelsScale + xtraRoom) ceiling.
	
	form := Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
"form fillColor: (Color gray: 0.95)."
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	canvas 
		engine
			drawUtf8String: utf8ByteArray
			fromByte: 1
			toByte: utf8ByteArray size
			at: leftPixelOffset negated@(topPixelOffset - horizontalStrokesAtPixelCenter)
			trueTypeFont: self
			color: Color black
			scale: 1.0 * pixelSize
			preventMirroring: true.
"
f2 := form copy.
f2 fill: (form boundingBox insetBy: 1) fillColor: (f2 colorAt: 0@0).
(f2 tallyPixelValues count: [ :v | v > 0 ]) > 1 ifTrue: [
	Tota ifNil: [ Tota := OrderedCollection new ].
	Tota add: form.
	Tota2 ifNil: [ Tota2 := OrderedCollection new ].
	Tota2 add: utf8ByteArray.
].
"

	"TrueType doesn't speciy how to position diacritics wrt base character glyph.
	Horizontally center diacriticals wrt base glyph.
	See
	basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
	Apparently OpenType can do better than TrueType, as it includes the GPOS table."
	deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.51)) * toPixelsScale.
	byte1 = 204 ifTrue: [
		byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.43)) * toPixelsScale ].
		byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.65)) * toPixelsScale ]].

	"DoubleWidth code points that combine above previous and following characters.
	Codepoints between 16r035C and 16r0363.
	Example: oÕ¢o
	Don't center them"
	(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
		deltaXToCenter := 0 ].
	
	^(FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale))
			deltaXToCenter: deltaXToCenter.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7362-CachedFontTweaks-JuanVuletich-2025Jul17-12h59m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7362] on 19 July 2025 at 11:44:29 am'!
!TTFontDescription methodsFor: 'conversion' stamp: 'jmv 7/19/2025 11:42:12' prior: 50348583!
                 formGlyphForUtf8Byte1: aByte1 byte2: aByte2OrNil byte3: aByte3OrNil byte4: aByte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"
	| byte1 byte2OrNil byte3OrNil byte4OrNil utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset form canvas advanceWidth boundsLeft boundsRight boundsBottom boundsTop i deltaXToCenter xtraRoom usedRect |

	byte1 := aByte1.
	byte2OrNil := aByte2OrNil.
	byte3OrNil := aByte3OrNil.
	byte4OrNil := aByte4OrNil.
	i := contourDataIndexesByUtf8 at: byte1 + 1.
	utf8ByteArray := ByteArray with: byte1.
	byte2OrNil notNil ifTrue: [
		i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		utf8ByteArray := ByteArray with: byte1 with: byte2OrNil.
		byte3OrNil notNil ifTrue: [
			i := contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil.
			byte4OrNil notNil ifTrue: [
				i := contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1.
				utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil with: byte4OrNil ]]].

	"If glyph not found, take first glyph 'theUnknownGlyph'"
	i = 0 ifTrue: [ i := 1 ].

	advanceWidth := contourDataForUtf8 at: i. i := i + 1.
	boundsLeft := contourDataForUtf8 at: i. i := i + 1.
	boundsRight := contourDataForUtf8 at: i. i := i + 1.
	boundsBottom := contourDataForUtf8 at: i. i := i + 1.
	boundsTop := contourDataForUtf8 at: i. i := i + 1.

	toPixelsScale := 0.0 + pixelSize / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed.
	Be sure to leave extra room so there's no risk of missing pixels."
	leftPixelOffset := (boundsLeft * toPixelsScale) rounded.
	formWidth := ((boundsRight - boundsLeft) * toPixelsScale) ceiling.
	xtraRoom := formWidth * 2 //10 + 3.
	leftPixelOffset := leftPixelOffset - xtraRoom.
	formWidth := formWidth + xtraRoom + xtraRoom.

	"Usually positive. Needed pixels above the baseline.
	Be sure to leave extra room so there's no risk of missing pixels."
	topPixelOffset := (boundsTop * toPixelsScale) ceiling.
	formHeight := ((boundsTop - boundsBottom) * toPixelsScale) ceiling.
	xtraRoom := formHeight * 2 //10 + 3.
	topPixelOffset := topPixelOffset + xtraRoom.
	formHeight := formHeight + xtraRoom + xtraRoom.
	
	"Draw our glyph."
	form := Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
"form fillColor: (Color r: 01.0 g: 0.9 b: 0.9)." "Debug aid"
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	canvas 
		engine
			drawUtf8String: utf8ByteArray
			fromByte: 1
			toByte: utf8ByteArray size
			at: leftPixelOffset negated@topPixelOffset
			trueTypeFont: self
			color: Color black
			scale: 1.0 * pixelSize
			preventMirroring: true.

	"Now only take the pixels that are actually needed."
	usedRect := form boundingBox intersect: canvas engine morphBoundsAfterDraw.
	"usedRect := usedRect outsetBy: 1." "Debug aid"
	form := form copy: usedRect.
	leftPixelOffset := leftPixelOffset + usedRect left.
	topPixelOffset := topPixelOffset - usedRect top.

"Debug Aid"
"
f2 := form copy.
f2 fill: (form boundingBox insetBy: 1) fillColor: (f2 colorAt: 0@0).
(f2 tallyPixelValues count: [ :v | v > 0 ]) > 1 ifTrue: [
	Tota ifNil: [ Tota := OrderedCollection new ].
	Tota add: form.
	Tota2 ifNil: [ Tota2 := OrderedCollection new ].
	Tota2 add: utf8ByteArray.
].
"

	"TrueType doesn't speciy how to position diacritics wrt base character glyph.
	Horizontally center diacriticals wrt base glyph.
	See
	basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
	Apparently OpenType can do better than TrueType, as it includes the GPOS table."
	deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.51)) * toPixelsScale.
	byte1 = 204 ifTrue: [
		byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.43)) * toPixelsScale ].
		byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.65)) * toPixelsScale ]].

	"DoubleWidth code points that combine above previous and following characters.
	Codepoints between 16r035C and 16r0363.
	Example: oÕ¢o
	Don't center them"
	(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
		deltaXToCenter := 0 ].
	
	^(FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale))
			deltaXToCenter: deltaXToCenter.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7363-CachedGlyphsTweaks-JuanVuletich-2025Jul18-21h17m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7363] on 21 July 2025 at 12:09:47 pm'!
!TTFontDescription methodsFor: 'accessing' stamp: 'jmv 7/21/2025 11:47:00'!
               contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil
	"Answer the position in contourDataForUtf8 for requested UTF-8 encoded code point.
	Answer 0 if we don't include it.
	Entries in contourDataIndexesByUtf8 may be:
		> 1: actual index in countourData for this CodePoint
		= 1: No contourData for this CodePoint. Use the UnknownGlyph, stored at position 1. (If byte1 > 0)
		< 0: Another UTF-8 byte is needed.
		= 0: No contourData for this CodePoint. Use the UnknownGlyph, stored at position 1."

	| i |
	i := contourDataIndexesByUtf8 at: byte1 + 1.
	byte2OrNil notNil ifTrue: [
		i < 0 ifFalse: [ ^0 ].
		i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		byte3OrNil notNil ifTrue: [
			i < 0 ifFalse: [ ^0 ].
			i := contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			byte4OrNil notNil ifTrue: [
				i < 0 ifFalse: [ ^0 ].
				i := contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1 ]]].
	
	^i! !
!TTFontDescription methodsFor: 'accessing' stamp: 'jmv 7/21/2025 11:48:07'!
                 includesContourDataForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil
	"Answer true if we include a glyph definition for the requested UTF-8 encoded code point.
	Answer false if we don't include it.
	See comment at #contourDataIndexForUtf8Byte1:byte2:byte3:byte4:"

	"The unknown glyph is indeed included.
	See #appendGlyphDataTo:glyphsArray:indexes:base:bar:unknown:scaleArrowGlyphs:"
	byte1 = 1 ifTrue: [
		^true ].

	"But any other glyph redirected to it is not included."
	^(self contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil) > 1! !
!TrueTypeFont methodsFor: 'glyph access' stamp: 'jmv 7/21/2025 12:05:02' prior: 16999741!
         glyphAtUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil
	"Needed only for BitBltCanvasEngine"

	| lastArray lastIndex |
	
	"Avoid creating multiple cached instances for the unknown glyph. Just keep one!!"
	(ttFontDescription includesContourDataForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil)
		 ifFalse: [
			^self glyphAtUtf8Byte1: 1 byte2: nil byte3: nil byte4: nil ].
	lastArray := glyphFormsByUtf8 .
	lastIndex := byte1 + 1.
	byte2OrNil notNil ifTrue: [
		(lastArray at: lastIndex) ifNil: [ lastArray at: lastIndex put: (Array new: 64) ].
		lastArray := lastArray at: lastIndex.
		lastIndex := (byte2OrNil bitAnd: 63) + 1.
		byte3OrNil notNil ifTrue: [
			(lastArray at: lastIndex) ifNil: [ lastArray at: lastIndex put: (Array new: 64) ].
			lastArray := lastArray at: lastIndex.
			lastIndex := (byte3OrNil bitAnd: 63) + 1.
			byte4OrNil notNil ifTrue: [
				(lastArray at: lastIndex) ifNil: [ lastArray at: lastIndex put: (Array new: 64) ].
				lastArray := lastArray at: lastIndex.
				lastIndex := (byte4OrNil bitAnd: 63) + 1 ]]].
	^ (lastArray at: lastIndex) ifNil: [
		| formGlyph |
		formGlyph := (ttFontDescription
				formGlyphForUtf8Byte1: byte1 byte2: byte2OrNil
				byte3: byte3OrNil byte4: byte4OrNil
				pixelSize: pointSize)
			ifNotNil: [ :theGlyph |
				self isUnderlined ifTrue: [
					self makeUnderlinedGlyph: theGlyph ].
				self isStruckThrough ifTrue: [
					self makeStruckThroughGlyph: theGlyph ].
				theGlyph].
		lastArray at: lastIndex put: formGlyph.
		formGlyph ]! !
!TTFontDescription methodsFor: 'private-initialization' stamp: 'jmv 7/21/2025 12:08:11' prior: 16981267!
         appendGlyphDataTo: stream glyphsArray: glyphsArray indexes: indexes base: baseIndex bar: aProgressBarOrNil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

		glyphsArray withIndexDo: [ :glyphOrArrayOrNumberNil :index |
			aProgressBarOrNil ifNotNil: [ :bar | bar value: index ].
			glyphOrArrayOrNumberNil ifNotNil: [
				glyphOrArrayOrNumberNil == theUnknownGlyph
					ifTrue: [ indexes at: baseIndex + index put: 1 ] "Set to unknownGlyph. UnknownGlyph is index 1."
					ifFalse: [
						glyphOrArrayOrNumberNil isArray
							ifTrue: [
								| nextBaseIndex |
								nextBaseIndex := indexes size - 128.
								indexes addAll: (IntegerArray new: 64).
								indexes at: baseIndex + index put: nextBaseIndex negated.
								self appendGlyphDataTo: stream glyphsArray: glyphOrArrayOrNumberNil indexes: indexes
									base: nextBaseIndex bar: nil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]
							ifFalse: [
								glyphOrArrayOrNumberNil isNumber
									ifTrue: [ | glyph tx |
										glyph := arrowGlyphs at: glyphOrArrayOrNumberNil.
										tx := AffineTransformation withScale: letterMTopSideBearing asFloat / arrowGlyphs second topSideBearing * 0.7.
										indexes at: baseIndex + index put: stream position+1.
										glyph addGlyphDataTo: stream tx: tx
										]
									ifFalse: [
										indexes at: baseIndex + index put: stream position+1.
										glyphOrArrayOrNumberNil addGlyphDataTo: stream tx: nil ]]]]].! !
!TTFontDescription methodsFor: 'conversion' stamp: 'jmv 7/21/2025 11:55:48' prior: 50348727!
    formGlyphForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"

	| utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset form canvas advanceWidth boundsLeft boundsRight boundsBottom boundsTop i deltaXToCenter xtraRoom usedRect |

	"Get the position in contourData for our glyph definition."
	i := self contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil.
	
	advanceWidth := contourDataForUtf8 at: i. i := i + 1.
	boundsLeft := contourDataForUtf8 at: i. i := i + 1.
	boundsRight := contourDataForUtf8 at: i. i := i + 1.
	boundsBottom := contourDataForUtf8 at: i. i := i + 1.
	boundsTop := contourDataForUtf8 at: i. i := i + 1.

	toPixelsScale := 0.0 + pixelSize / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed.
	Be sure to leave extra room so there's no risk of missing pixels."
	leftPixelOffset := (boundsLeft * toPixelsScale) rounded.
	formWidth := ((boundsRight - boundsLeft) * toPixelsScale) ceiling.
	xtraRoom := formWidth * 2 //10 + 3.
	leftPixelOffset := leftPixelOffset - xtraRoom.
	formWidth := formWidth + xtraRoom + xtraRoom.

	"Usually positive. Needed pixels above the baseline.
	Be sure to leave extra room so there's no risk of missing pixels."
	topPixelOffset := (boundsTop * toPixelsScale) ceiling.
	formHeight := ((boundsTop - boundsBottom) * toPixelsScale) ceiling.
	xtraRoom := formHeight * 2 //10 + 3.
	topPixelOffset := topPixelOffset + xtraRoom.
	formHeight := formHeight + xtraRoom + xtraRoom.
	
	"Draw our glyph."
	utf8ByteArray := { byte1. byte2OrNil. byte3OrNil. byte4OrNil} select: [ :b | b notNil ] :: asByteArray.
	form := Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
"form fillColor: (Color r: 01.0 g: 0.9 b: 0.9)." "Debug aid"
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	canvas 
		engine
			drawUtf8String: utf8ByteArray
			fromByte: 1
			toByte: utf8ByteArray size
			at: leftPixelOffset negated@topPixelOffset
			trueTypeFont: self
			color: Color black
			scale: 1.0 * pixelSize
			preventMirroring: true.

	"Now only take the pixels that are actually needed."
	usedRect := form boundingBox intersect: canvas engine morphBoundsAfterDraw.
	"usedRect := usedRect outsetBy: 1." "Debug aid"
	form := form copy: usedRect.
	leftPixelOffset := leftPixelOffset + usedRect left.
	topPixelOffset := topPixelOffset - usedRect top.

"Debug Aid"
"
f2 := form copy.
f2 fill: (form boundingBox insetBy: 1) fillColor: (f2 colorAt: 0@0).
(f2 tallyPixelValues count: [ :v | v > 0 ]) > 1 ifTrue: [
	Tota ifNil: [ Tota := OrderedCollection new ].
	Tota add: form.
	Tota2 ifNil: [ Tota2 := OrderedCollection new ].
	Tota2 add: utf8ByteArray.
].
"

	"TrueType doesn't speciy how to position diacritics wrt base character glyph.
	Horizontally center diacriticals wrt base glyph.
	See
	basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
	Apparently OpenType can do better than TrueType, as it includes the GPOS table."
	deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.51)) * toPixelsScale.
	byte1 = 204 ifTrue: [
		byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.43)) * toPixelsScale ].
		byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.65)) * toPixelsScale ]].

	"DoubleWidth code points that combine above previous and following characters.
	Codepoints between 16r035C and 16r0363.
	Example: oÕ¢o
	Don't center them"
	(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
		deltaXToCenter := 0 ].
	
	^(FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale))
			deltaXToCenter: deltaXToCenter.! !
!TTFontDescription methodsFor: 'glyph properties' stamp: 'jmv 7/21/2025 11:21:27' prior: 16981549!
          widthOfUtf8Byte1: byte1 b2: byte2OrNil b3: byte3OrNil b4: byte4OrNil

	| i advanceWidth |
	
	i := self contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil.
	
	"If glyph not found, take first glyph 'theUnknownGlyph'"
	i = 0 ifTrue: [ i := 1 ].
	advanceWidth := contourDataForUtf8 at: i.
	^ advanceWidth / letterMTopSideBearing.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7364-CachedFonts-MemoryOptimization-JuanVuletich-2025Jul21-12h06m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7364] on 21 July 2025 at 4:26:35 pm'!
!TTFontDescription methodsFor: 'private-initialization' stamp: 'jmv 7/21/2025 16:00:49' prior: 50348994!
  appendGlyphDataTo: stream glyphsArray: glyphsArray indexes: indexes base: baseIndex bar: aProgressBarOrNil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

		glyphsArray withIndexDo: [ :glyphOrArrayOrNumberNil :index |
			aProgressBarOrNil ifNotNil: [ :bar | bar value: index ].
			glyphOrArrayOrNumberNil ifNotNil: [
				glyphOrArrayOrNumberNil == theUnknownGlyph
					ifTrue: [ indexes at: baseIndex + index put: 1 ] "Set to unknownGlyph. UnknownGlyph is index 1."
					ifFalse: [
						glyphOrArrayOrNumberNil isArray
							ifTrue: [
								| nextBaseIndex |
								nextBaseIndex := indexes size - 128.
								"Any incomplete array sequence will point at 1. VectorEngine will show (Character codePoint: 500001)
								as four invalid glyphs and not just one. Real solution is for VectorEngine to skip ignored bytes."
								indexes addAll: ((IntegerArray new: 64) atAllPut: 1).
								indexes at: baseIndex + index put: nextBaseIndex negated.
								self appendGlyphDataTo: stream glyphsArray: glyphOrArrayOrNumberNil indexes: indexes
									base: nextBaseIndex bar: nil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]
							ifFalse: [
								glyphOrArrayOrNumberNil isNumber
									ifTrue: [ | glyph tx |
										glyph := arrowGlyphs at: glyphOrArrayOrNumberNil.
										tx := AffineTransformation withScale: letterMTopSideBearing asFloat / arrowGlyphs second topSideBearing * 0.7.
										indexes at: baseIndex + index put: stream position+1.
										glyph addGlyphDataTo: stream tx: tx
										]
									ifFalse: [
										indexes at: baseIndex + index put: stream position+1.
										glyphOrArrayOrNumberNil addGlyphDataTo: stream tx: nil ]]]]].! !
!TTFontDescription methodsFor: 'private-initialization' stamp: 'jmv 7/21/2025 16:01:10' prior: 16981322!
                  glyphsByUtf8Bytes: glyphsByUTF8 unknownGlyph: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

	| mGlyph |
	
	mGlyph := glyphsByUTF8 at: $M asciiValue + 1.
	letterMTopSideBearing := (mGlyph ifNil: [theUnknownGlyph]) topSideBearing.

	"Any incomplete array sequence will point at 1. VectorEngine will show (Character codePoint: 500001)
	as four invalid glyphs and not just one. Real solution is for VectorEngine to skip ignored bytes."
	contourDataIndexesByUtf8 := ((IntegerArray new: 256) atAllPut: 1) as: OrderedCollection.
	contourDataForUtf8 := Float32Array streamContents: [ :stream |
		theUnknownGlyph addGlyphDataTo: stream tx: nil.		"First data is for unknownGlyph"	
		self fullName, ' - Processing glyph data' 
			displayProgressAt: 100@100
			from: 1 
			to: glyphsByUTF8 size 
			during: [ :bar |
				self appendGlyphDataTo: stream glyphsArray: glyphsByUTF8 indexes: contourDataIndexesByUtf8
					base: 0 bar: bar unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]].
	contourDataIndexesByUtf8 := contourDataIndexesByUtf8 as: IntegerArray.
	"Any incomplete array sequence will point at 1. VectorEngine will show (Character codePoint: 500001)
	as four invalid glyphs and not just one. Real solution is for VectorEngine to skip ignored bytes."
	contourDataIndexesByLatin1 := (IntegerArray new: 256)  atAllPut: 1.
	0 to: 255 do: [ :cp | | i |
		Character
			evaluateOnce: [ :byte1 :byte2OrNil :byte3OrNil :byte4OrNil |
				i := contourDataIndexesByUtf8 at: byte1 + 1.
				(byte2OrNil notNil and: [ i < 0 ]) ifTrue: [
					i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1 ].
				contourDataIndexesByLatin1 at: cp+1 put: i ]
			withUtf8BytesOf: cp ].! !
!TTFontDescription class methodsFor: 'instance creation' stamp: 'jmv 7/21/2025 16:03:24' prior: 16981605!
            readTrueTypeFontsIn: aDirectoryEntry
	"
	TTFontDescription readTrueTypeFontsIn: DirectoryEntry trueTypeFontsDirectory
	"
	| read |
	read := OrderedDictionary new.
	aDirectoryEntry
		allFilesDo: [ :file | | ttf |
			ttf := TTFontReader readTTFFrom: file binaryContents.
			ttf folderName: file parent name.
			self add: ttf to: read ]
		matches: [ :file | '*.ttf' match: file name ].
	aDirectoryEntry
		allFilesDo: [ :file | | ttc |
			ttc := TTFontReader readTTCFrom: file binaryContents.
			ttc do: [ :eachTtf |
				eachTtf folderName: file parent name.
				self add: eachTtf to: read ]]
		matches: [ :file | '*.ttc' match: file name ].
	Descriptions ifNil: [ Descriptions := Dictionary new ].
	read keysAndValuesDo: [ :familyName :emphasisDict |
		emphasisDict keysAndValuesDo: [ :emphasis :ttf |
			(Descriptions at: familyName ifAbsentPut: [ Dictionary new]) at: emphasis put: ttf ]].
	^read keys.! !
!TTFontDescription class methodsFor: 'class initialization' stamp: 'jmv 7/21/2025 16:17:15' prior: 16981643 overrides: 16924243!
                      initialize
	"
	TTFontDescription initialize.
	FontFamily releaseClassCachedState.
	TrueTypeFontFamily readAllTrueTypeFontsIn: DirectoryEntry trueTypeFontsDirectory / 'DejaVu' / 'DejaVuSans'.
	"
	Descriptions := nil.! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 14:45:21' prior: 17008696!
                contourDataIndexForUtf32: codePoint contourDataIndexes: contourDataIndexes
	"contourDataIndexes is designed to be directly accessible via UTF-8 bytes of a CodePoint.
	This allows for a compact and efficient packing of TrueType contour data.
	In order to be used for a plain Code Point (as expressed in UTF-32), the UTF-8 bytes of
	the code point need to be extracted and used to access contourDataIndexes."

	| i utf8Byte1 utf8Byte2 utf8Byte3 utf8Byte4 |
	codePoint <= 16r7F
		ifTrue: [
			utf8Byte1 := codePoint.
			i := contourDataIndexes at: utf8Byte1 + 1 ]
		ifFalse: [
			codePoint <= 16r7FF
				ifTrue: [
					utf8Byte1 := (codePoint bitShift: -6) bitOr: 2r11000000.
					utf8Byte2 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i < 0 ifFalse: [ ^0 ].
					i := contourDataIndexes at: i negated + utf8Byte2 + 1 ]
				ifFalse: [
					codePoint <= 16rFFFF
						ifTrue: [
							utf8Byte1 := (codePoint bitShift: -12) bitOr: 2r11100000.
							utf8Byte2 := ((codePoint bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
							utf8Byte3 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
							i := contourDataIndexes at: utf8Byte1 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte2 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte3 + 1 ]
						ifFalse: [
							utf8Byte1 := (codePoint bitShift: -18) bitOr: 2r11110000.
							utf8Byte2 := ((codePoint bitShift: -12) bitAnd: 2r00111111) bitOr: 2r10000000.
							utf8Byte3 := ((codePoint bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
							utf8Byte4 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
							i := contourDataIndexes at: utf8Byte1 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte2 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte3 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte4 + 1 ]]].
	^i! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:24:51' prior: 17008755!
         displayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours |
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
		latin1Code := (aString at: charIndex) codePoint.
		i := contourDataIndexes at: latin1Code + 1.
		i < 1 ifTrue: [ i := 1 ].
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		self glyphContours: numContours atx: nextGlyphX y: destY scalex: sx y: sy contourData: contourData i: i.
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:25:00' prior: 17008787!
        displayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :utf32Index | | utf32 i |
		utf32 := aWordArray at: utf32Index.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 16r131 Dotless i
		This should also be done for VectorEngineWithPlugin"
		(utf32 = 16r69 and: [ utf32Index < stopIndex ] and: [
			(aWordArray at: utf32Index+1) between: 16r300 and: 16r36F ])
				ifTrue: [ utf32 := 16r131 ].
		i :=  self contourDataIndexForUtf32: utf32 contourDataIndexes: contourDataIndexes.
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		
		"TrueType doesn't speciy how to position diacritics wrt base character glyph.
		Horizontally center diacriticals wrt base glyph.
		See
			basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
			formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
			displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
		This should also be done for VectorEngineWithPlugin
		Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
		deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
		utf32 = 16r300 ifTrue: [	"Combining Grave Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
		utf32 = 16r301 ifTrue: [ 	"Combining Acute Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ].
		"DoubleWidth code points that combine above previous and following characters.
		Codepoints between 16r035C and 16r0363.
		Example: oÕ¢o
		Don't center them"
		(utf32 between: 16r035C and: 16r0363) ifTrue: [
			deltaXToCenter := 0.0 ].
				
		deltaXForDiacriticalMark := 0.0.
		deltaYForDiacriticalMark := 0.
		advanceWidth = 0.0
			ifFalse: [ "Regular glyph"
				deltaXForBaseGlyph := deltaXToCenter.
				baseBoundsTop := boundsTop ]
			ifTrue: [ "Diacritical mark"
				deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
					ifFalse: [
						deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
						baseBoundsTop > boundsBottom ifTrue: [
							deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
		
		self
			glyphContours: numContours
			atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
			scalex: sx y: sy
			contourData: contourData i: i.
		
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:25:08' prior: 17008883!
 displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX byte1 byte2OrNil baseIndex advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	nextGlyphX := destX.
	byte1 := nil.
	byte2OrNil := nil.
	baseIndex := 0.
	byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
		byte := aByteArray at: byteIndex.
		byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
		i := contourDataIndexes at: baseIndex + byte + 1.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
		(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32
			105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ]) edit
		This should also be done for VectorEngineWithPlugin"
		(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
			(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
				ifTrue: [
					i := contourDataIndexes at: 196 + 1.
					i := contourDataIndexes at: i negated + 177 + 1 ].
		
		i < 0
			ifTrue: [ baseIndex := i negated ]
			ifFalse: [
				advanceWidth := contourData at: i. i := i + 1.
				boundsLeft := contourData at: i. i := i + 1.
				boundsRight := contourData at: i. i := i + 1.
				boundsBottom := contourData at: i. i := i + 1.
				boundsTop := contourData at: i. i := i + 1.
				numContours := (contourData at: i) asInteger. i := i + 1.
				"TrueType doesn't speciy how to position diacritics wrt base character glyph.
				Horizontally center diacriticals wrt base glyph.
				See
					basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
					formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
					displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
				This should also be done for VectorEngineWithPlugin
				Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
				byte1 = 204 ifTrue: [
					byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
					byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].
				"DoubleWidth code points that combine above previous and following characters.
				Codepoints between 16r035C and 16r0363.
				Example: oÕ¢o
				Don't center them"
				(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
					deltaXToCenter := 0.0 ].
				
				deltaXForDiacriticalMark := 0.0.
				deltaYForDiacriticalMark := 0.
				advanceWidth = 0.0
					ifFalse: [ "Regular glyph"
						deltaXForBaseGlyph := deltaXToCenter.
						baseBoundsTop := boundsTop ]
					ifTrue: [ "Diacritical mark"
						deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
							ifFalse: [
								deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
								baseBoundsTop > boundsBottom ifTrue: [
									deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
				
				self
					glyphContours: numContours
					atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
					scalex: sx y: sy
					contourData: contourData i: i.
				
				nextGlyphX := nextGlyphX + (advanceWidth * sx).
				baseIndex := 0.
				byte1 := nil.
				byte2OrNil := nil ]].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:24:46' prior: 17009015!
               glyphContours: numContours atx: nextGlyphX y: nextGlyphY scalex: sx y: sy contourData: contourData i: contourDataIndex

		| i contourStart numBeziers ttMoveToX ttMoveToY x y |
		i := contourDataIndex.
		numContours timesRepeat: [
			numBeziers := (contourData at: i) asInteger. i := i + 1.
			ttMoveToX := contourData at: i. i := i + 1.
			ttMoveToY := contourData at: i. i := i + 1.
			x := ttMoveToX * sx + nextGlyphX.
			y := ttMoveToY * sy + nextGlyphY.
			contourStart := x@y.
			self moveTo: contourStart.
			numBeziers timesRepeat: [ | cx cy ttControlX ttControlY ttEndX ttEndY |
				ttEndX := contourData at: i. i := i + 1.
				ttEndY := contourData at: i. i := i + 1.
				ttControlX := contourData at: i. i := i + 1.
				ttControlY := contourData at: i. i := i + 1.
				cx := ttControlX * sx + x.
				cy := ttControlY * sy + y.
				x := ttEndX * sx + x.
				y := ttEndY * sy + y.
				self quadraticBezierTo: x@y control: cx@cy ].
			self lineTo: contourStart ].! !

TTFontDescription initialize.
	FontFamily releaseClassCachedState.
	TrueTypeFontFamily readAllTrueTypeFontsIn: DirectoryEntry trueTypeFontsDirectory / 'DejaVu' / 'DejaVuSans'.
	PreferenceSet setDefaultFont: FontFamily defaultFamilyName.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7365-TrueType-display-fix-JuanVuletich-2025Jul21-16h22m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7364] on 21 July 2025 at 6:41:39 pm'!
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 7/21/2025 18:33:05' prior: 50332304 overrides: 16927072!
                 visitBlockNode: blockNode

	| blockStatements |

	self addToEquivalentsIfOneStatementEquivalentTo: blockNode.

	super visitBlockNode: blockNode.
	
	nodesToLookForSize > 1 ifTrue: [ 
		blockStatements := blockNode statements copy. 
		"I need to add temp declaration to statements becuase user could have selected the temp declaration
		See 
		- ExtractMethodFinderTest>>test22FindsTemporaryWhenSelectingDefinitionInInnerClosure
		- ExtractMethodFinderTest>>test22_1_FindsTemporaryWhenSelectingDefinitionInInnerClosure - Hernan"
		blockNode declaresAnyVariable ifTrue: [ blockStatements addFirst: blockNode temporariesDeclaration ].
		self addEquivalentNodesOf: blockStatements ]
		! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7366-ExtractMethodInnerBlocksFix-HernanWilkinson-2025Jul21-17h30m-HAW.001.cs.st----!

----QUIT----(22 July 2025 09:53:25) Cuis7.5-7366-32.image priorSource: 504492!

----STARTUP---- (23 July 2025 14:33:11) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\Cuis7.5-7366-32.image!


'From Cuis7.5 [latest update: #7366] on 23 July 2025 at 2:24:18 pm'!
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 7/23/2025 14:23:44' prior: 17013627 overrides: 17009057!
                     pvtStrokeWidth: aNumber hop: aFloat

	strokeWidth := aNumber.
	hop := aFloat.
	"Set AntiAliasingWidth in the plugin, as #primStrokeWidth:hop: needs it."
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat.
	"This call in the plugin uses AntiAliasingWith."
	self primStrokeWidth: strokeWidth hop: hop.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7367-VectorEngineWithPlugin-fix-JuanVuletich-2025Jul23-13h47m-jmv.001.cs.st----!

----QUIT----(23 July 2025 14:33:14) Cuis7.5-7367-32.image priorSource: 579278!

----STARTUP---- (27 July 2025 12:44:13) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\Cuis7.5-7367-32.image!


'From Cuis7.5 [latest update: #7367] on 24 July 2025 at 11:00:14 am'!
!CodeFileBrowser methodsFor: 'diffs' stamp: 'jmv 7/24/2025 10:59:57' prior: 16823291!
methodDiffFor: aString selector: selector
	"Answer the diff between the current copy of the given class/selector/meta for the string provided"
	| theClass base |
	base := ''.
	theClass := self pvtBaseClassOrMetaclass.
	theClass ifNotNil: [
		(theClass includesSelector: selector) ifTrue: [
			base := theClass sourceCodeAt: selector ]].
	^ DifferenceFinder
		displayPatchFrom: base
		to: aString
		tryWords: self shouldDiffWords
		prettyPrintedIn:
			(self showingAnyKindOfPrettyDiffs ifTrue: [ theClass ]).! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 7/24/2025 11:00:00' prior: 16804483!
         compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| base class baseString caseString differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	base := changeList at: listIndex.
	((class := base changeClass) notNil
			and: [class includesSelector: base methodSelector])
		ifTrue: [
			baseString := base string.
			caseString := (class sourceCodeAt: base methodSelector) asPlainString.
			baseString = caseString
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords := self shouldDiffWords.
			differDesc := diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: baseString to: caseString
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: (Preferences at: #standardCodeFont)))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 7/24/2025 11:00:03' prior: 17014290!
        compareToOtherVersion
	"Prompt the user for a reference version, then spawn a window 
	showing the diffs between the older and the newer of the current 
	version and the reference version as text."

	| base case baseString caseString differDesc diffWords targetChanges labels label1 |
	base := changeList at: listIndex ifAbsent: [ ^self ].
	label1 := list at: listIndex.

	labels := list reject: [ :any | any = label1 ].
	targetChanges := changeList reject: [ :any | any = base ].
	case := ((SelectionMenu
				labels: labels
				selections: targetChanges) startUpMenu) ifNil: [ ^self ].
	
	"compare earlier -> later"
	"change1 timeStamp < change2 timeStamp
		ifFalse: [ | temp | temp := change1. change1 := change2. change2 := temp ]."

	baseString := base string.
	caseString := case string.
	baseString = caseString
		ifTrue: [^ self inform: 'Exact Match'].

	diffWords := self shouldDiffWords.
	differDesc := diffWords
		ifTrue: [ 'Words']
		ifFalse: [ 'Lines'].

	(TextModel new
		contents: (DifferenceFinder
			displayPatchFrom: baseString to: caseString
			tryWords: diffWords
			prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [classOfMethod])))
		openLabel: 
			(('Comparison from {1} to {2}: ', differDesc, 
				(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])) 
					format: { base stamp. case stamp })! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7368-VersionDiffingTweaks-JuanVuletich-2025Jul24-10h59m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7367] on 24 July 2025 at 9:54:25 am'!
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 7/24/2025 09:53:36' prior: 16932405 overrides: 16932763!
                              mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row := (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ self vLeftoverScrollRange > 0 and: [ scrollBar scrollValue < 1.0 ]])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [
					self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff := (self listSelectionAt: row) not.
		dragStartRow := row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex := self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal := self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self setSelectionIndex: row ]
		ifFalse: [ self setSelectionIndex: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	dragStartRow ifNotNil: [
		(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
			self listSelectionAt: r put: dragOnOrOff ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7369-clickNdragScrollFix-JuanVuletich-2025Jul24-09h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 24 July 2025 at 12:11:57 pm'!
!FormGlyph methodsFor: 'initialization' stamp: 'jmv 7/24/2025 11:33:12'!
                       form: aForm leftOffsetBy: aNumber.
	form := aForm.
	leftOffset := leftOffset + aNumber! !
!TrueTypeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 7/24/2025 11:57:10' prior: 16999845!
   makeStruckThroughGlyph: aFormGlyph
	| oldForm form d |
	"Please keep consistent with
	#drawOnVectorEngine:from:to:at:font:color:
	#drawOnVectorEngine:from:to:at:font:color:borderWidth:borderColor:
	Similar to: #makeUnderlinedGlyph:"

	form := aFormGlyph form.
	form width = 0 ifTrue: [ ^self ].
	d := (self descent / 4) ceiling.
	true ifTrue: [
		oldForm := form.
		form := Form extent: oldForm width+2 @ oldForm height depth: oldForm depth.
		form fillWhite.
		form copyBits: oldForm boundingBox from: oldForm at: `1@0` clippingBox: form boundingBox rule: Form over.
		aFormGlyph form: form leftOffsetBy: -1].
	form fillBlack: (0 @ (aFormGlyph topOffset - self descent) floor extent: form width @ d).
	"For testing it:
	FontFamily releaseClassCachedState
	"! !
!TrueTypeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 7/24/2025 12:10:23' prior: 16999855!
   makeUnderlinedGlyph: aFormGlyph
	| height y oldForm form d |
	"Please keep consistent with
	#drawOnVectorEngine:from:to:at:font:color:
	#drawOnVectorEngine:from:to:at:font:color:borderWidth:borderColor:
	Similar to #makeStruckThroughGlyph:"

	form := aFormGlyph form.
	form width = 0 ifTrue: [ ^self ].
	d := (self descent / 4) ceiling.
	y := aFormGlyph topOffset + d.
	height := aFormGlyph topOffset + (2*d).
	true "height > form height" ifTrue: [
		oldForm := form.
		form := Form extent: oldForm width+2 @ height depth: oldForm depth.
		form fillWhite.
		form copyBits: oldForm boundingBox from: oldForm at: `1@0` clippingBox: form boundingBox rule: Form over.
		aFormGlyph form: form leftOffsetBy: -1 ].
	form fillBlack: (0 @ y extent: form width @ d).
	"For testing it:
	FontFamily releaseClassCachedState
	"! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 7/24/2025 11:41:40' prior: 16981684!
                       mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint == $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint == $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOf: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOf: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i | glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph. rightArrowGlyph. upArrowGlyph. downArrowGlyph. carriageReturnGlyph}! !
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 7/24/2025 12:06:50' prior: 17003231!
                    drawOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		drawUtf8String: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph: and #drawOnVectorEngine:from:to:at:font:color:borderWidth:borderColor:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer! !
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 7/24/2025 12:07:04' prior: 17003273!
        drawOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color borderWidth: sw borderColor: sc

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		drawUtf8String: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		strokeWidth: sw strokeColor: sc
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph: and #drawOnVectorEngine:from:to:at:font:color:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7370-Underline-StruckThrough-tweaks-JuanVuletich-2025Jul24-11h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 25 July 2025 at 9:28:35 am'!

Smalltalk renameClassNamed: #LayoutMorph as: #LinearLayoutMorph!

!classRenamed: #LayoutMorph as: #LinearLayoutMorph stamp: 'Install-7371-Rename-LayoutMorph-as-LinearLayoutMorph-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:44:14'!
Smalltalk renameClassNamed: #LayoutMorph as: #LinearLayoutMorph!
!Dialog methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:28:21' prior: 16848639!
         beColumn
	layoutMorph
		ifNotNil: [ layoutMorph beColumn ]
		ifNil: [
			layoutMorph := LinearLayoutMorph newColumn.
			self addMorphFront: layoutMorph ]! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:20' prior: 16869092 overrides: 16848620!
             buildWidgets

	| buttonRow titleMorph |
	titleMorph := (LabelMorph contents: 'Find in source code' fontSize: 16 emphasis: 1).
	titleMorph layoutSpec offAxisEdgeWeight: 0.
	searchField := EntryFieldMorph new.
	searchField
		crAction: [ self ok ];
		escAction: [ self cancel ].
	searchField layoutSpec offAxisEdgeWeight: 0.
	initialSearchString ifNotNil: [ searchField contents: initialSearchString ].
	scopeList := PluggableListMorph
		withModel: self
		listGetter: #scopesList
		indexGetter: #scopeIndex
		indexSetter: #scopeIndex:.
	scopeList 
		doubleClickSelector: #ok.
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		gap: 14;
		addMorphKeepMorphHeight: titleMorph;
		addMorphKeepMorphHeight: searchField;
		addMorphUseAll: scopeList;
		addMorphKeepMorphHeight: buttonRow.

	self morphExtent: self minimumExtent * (2@1.5).! !
!SampleModalDialog methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:21' prior: 16952761 overrides: 16848620!
    buildWidgets
	"
	This is a sample implementation. Actual subclasses should reimplement #buildWidgets (without calling super!!).
	self openModal
	"

	| typeRow buttonRow |
	typeRow := LinearLayoutMorph newRow.
	typeRow
		addMorph: (LabelMorph contents: 'Type');
		addMorph: (LabelMorph contents: 'So what');
		addMorph: (LabelMorph contents: 'And then').
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		padding: 10;
		gap: 20;
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		addMorph: 
			((LabelMorph contents: 'This is a title for this Dialog' fontSize: 25)
				borderWidth: 2; borderColor: color lighter;
				padding: 20);
		addMorph: Sample01Star new;
		addMorph: typeRow;
		addMorph: buttonRow.

	"self ensureMinimumExtent."
	"To make the star somehow larger"
	self morphExtent: self minimumExtent + (0@200).! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 09:28:22' prior: 16897181 overrides: 16796324!
      is: aSymbol
	^ aSymbol == #LinearLayoutMorph or: [ super is: aSymbol ]! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50338555!
        example1
"
	self example1
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50338623!
     example10
"
	self example10 openInWorld
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338692!
                          example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338753!
                             example11
"
	self example11
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50338824!
                    example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:22' prior: 50338872!
      example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338934!
                           example2
	"
	self example2
	"
	| pane row |
	pane := (LinearLayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:22' prior: 50338966!
                     example20
"
	self example20
"
| column |

column := (LinearLayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338989!
        example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:22' prior: 50339032!
             example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LinearLayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LinearLayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LinearLayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 16897788!
                              example7
	"
	Useful example contributed by Ken Dickey
	self example7
	"
	"============================================"
	| c colorHexValue colorName r w |
	w := SystemWindow new.
	r := LinearLayoutMorph newRow separation: 30 @ 10.
	c := LinearLayoutMorph newColumn separation: 20 @ 10.
	colorHexValue := LabelMorph contents:  'F97306'.
	colorName := LabelMorph contents: 'cornSilk'.

	r addMorph: colorHexValue.
	r addMorph: colorName.
	c addMorph: ColoredBoxMorph new.
	c addMorph: r.
	w addMorph: c .
	w openInWorld.
	"============================================"! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 16897878!
                        iconsExample
	"
	LayoutMorph iconsExample
	"
	| lm ilm counter |
	lm := LinearLayoutMorph newColumn.
	ilm := LinearLayoutMorph newRow.
	counter := 1.
	Theme methodsDo: [ :method | | sel | 
		(sel := method selector) numArgs = 0 ifTrue: [
			(sel endsWith: 'Icon') ifTrue: [ | mayBeForm |
				mayBeForm := Theme current perform: sel.
				(mayBeForm isKindOf: Form) ifTrue: [ | imageMorph |
					counter \\ 10 = 0 ifTrue: [
						lm addMorph: ilm.
						ilm := LinearLayoutMorph newRow ].
					counter := counter + 1.
					ilm addMorph: (imageMorph := ImageMorph newWith: (mayBeForm magnifyBy: 2)).
					imageMorph 
						setBalloonText: 'Copy ''', sel storeString bold, ''' to the Clipboard';
						setProperty: #'handlesMouseDown:' toValue: true;
						setProperty: #mouseButton1Down:localPosition:  toValue: [ :event :pos |
							Clipboard storeObject: sel storeString ] ] ] ] ].
	lm 
		setProperty: #taskbarButtonIcon toValue: Theme current imageIcon;
		setBalloonText: 'Drag me here!!'.
	lm openInWorld
! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 16897912!
                               launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random := Random new.
	b1 := PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 := PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 := PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 := PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons := {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row := LinearLayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!LinearLayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50342579!
            example1Form
"
	self example1Form
"
	| pane |
	pane := (LinearLayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:22' prior: 16969289!
                    addTextPane
	"Add a text pane and two buttons."
	
	| controlsContainer |
	textMorph := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textMorph emptyTextDisplayMessage: msg ].
	textMorph
		hasUnacceptedEdits: true;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LinearLayoutMorph newRow)
		addMorphUseAll: textMorph;
		addMorph: 
			((PluggableButtonMorph model: textMorph scroller action: #acceptContents)
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			((PluggableButtonMorph model: self action: #cancel)
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:21' prior: 50339156 overrides: 16796268!
                       initialize
	super initialize.
	viewBox := LinearLayoutMorph newRow color: self defaultColor.
	self
		addMorph: (clock := UpdatingLabelMorph initializedInstance)
		layoutSpec:  (LayoutSizeSpec morphWidthProportionalHeight: 0.5).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSizeSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			offAxisEdgeWeight: #rightOrBottom).
	viewBox separation: self defaultHeight // 8.
	self setBalloonText: [ 
		'About this system:' bold, `String newLineString`,
		Smalltalk systemInformationString ].
	clock
		setProperty: #handlesMouseDown: toValue: true;
		setProperty: #'mouseButton1Down:localPosition:' 
		toValue: [ :evt : pos | | menu taskbarEdge point | 
			self runningWorld ifNotNil: [ :w |
				taskbarEdge := self positionInWorld y.
				menu := (Preferences at: #worldMenu) getMenuIn: w at: w activeHand.	
				menu hide.
				w addMorph: menu. ": Otherwise we do not have a proper extent"
				point := 0 @ (taskbarEdge - menu extentInWorld y).
				menu popUpAt: point allowKeyboard: false ] ]! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 7/25/2025 09:28:21' prior: 50339192!
                    addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preferences at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW := Theme current titleBarButtonsExtent x.
	closeButton := PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; noButtonShape.
	pinButton := PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; noButtonShape.
	w := (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + (buttonHW*2).
	self addMorphFront: 
		(LinearLayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW * 12 // 10);
			color: `Color transparent`;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//10;
			addMorph: (closeButton layoutSpec: (LayoutSizeSpec fixedWidth: buttonHW fixedHeight: buttonHW));
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 7/25/2025 09:28:21' prior: 16901259!
      removeStayUpBox
	| box |
	submorphs isEmpty ifTrue: [^self].
	(submorphs first is: #LinearLayoutMorph) ifFalse: [^self].
	box := submorphs first submorphs second.
	(box is: #PluggableButtonMorph) 
		ifTrue: [ box hide ]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 7/25/2025 09:28:20' prior: 16931312!
                              example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 := Switch new.
	s2 := Switch new turnOn.
	s3 := Switch new.
	s1 onAction: [s3 turnOn].
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 := (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 := (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 := (PluggableButtonMorph model: s3 stateGetter: nil action: #switch) 
		enableSelector: #isOn;
		label: 'S3'.
	b1 color: `Color lightRed`.
	b2 color: `Color lightRed`.
	b3 color: `Color lightRed`.
	row := LinearLayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: `120@35`.
	^ row! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:28:21' prior: 16979990!
                       beColumn
	layoutMorph
		ifNotNil: [ layoutMorph beColumn ]
		ifNil: [
			layoutMorph := LinearLayoutMorph newColumn.
			self addMorphFront: layoutMorph ]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:28:21' prior: 16979997!
               beRow
	layoutMorph
		ifNotNil: [ layoutMorph beRow ]
		ifNil: [
			layoutMorph := LinearLayoutMorph newRow.
			self addMorphFront: layoutMorph ]! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16825559!
         buildButtonPane

	| saveButton createButton deleteButton browseChangesButton browseButton addReqButton buttonRow |
	saveButton := PluggableButtonMorph 
							model: model 
							action: #save 
							label: 'save'.
	createButton := PluggableButtonMorph 
							model: self 
							action: #createPackage 
							label: 'new'.
	deleteButton := PluggableButtonMorph 
							model: self 
							action: #deletePackage 
							label: 'delete/merge'.
	browseChangesButton := PluggableButtonMorph 
							model: self 
							action: #browseChanges 
							label: 'changes'.
	browseButton := PluggableButtonMorph 
							model: self 
							action: #browse 
							label: 'browse'.
	addReqButton := PluggableButtonMorph 
							model: self 
							action: #addRequirement 
							label: 'add requirement'.
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		doAdoptWidgetsColor;
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6;
		addMorph: addReqButton proportionalWidth: 0.6.
	buttonRow submorphsDo: [ :button | button  color: self widgetsColor ].
	^ buttonRow ! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16825603!
      buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| names fileNames namesPane fileNamesPane 
	upperRow  description summary labelBackground |
	labelBackground := Theme current background.
	
	names := PluggableListMorph
		withModel: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	namesPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: ' Package Name');
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		withModel: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames alwaysHideVerticalScrollbar.
	fileNamesPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: ' File Name');
		addMorphUseAll: fileNames.

	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: namesPane proportionalWidth: 0.4;
		addAdjusterAndMorph: fileNamesPane proportionalWidth: 0.6.
		
	description := (TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:) emptyTextDisplayMessage: 'Please enter a description for this package'.

	summary := (TextModelMorph
		textProvider: model
		textGetter: #summary) emptyTextDisplayMessage: 'Package summary (No package selected?)'.
	
	names scrollSiblings: {fileNames}.
	fileNames scrollSiblings: {names}.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: self buildButtonPane fixedHeight: Theme current buttonPaneHeight;
		addAdjusterAndMorph: summary fixedHeight: 60;
		addAdjusterAndMorph: description proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.15.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 50339247!
         buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout updateReqButton |
	requirements := PluggableListMorph
		withModel: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
		
	deleteReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete')
							setBalloonText: 'Remove selected Feature requirement'.
	deleteReqButton color: self widgetsColor.
	updateReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #updateSelectedRequirement 
							label: 'update')
							setBalloonText: 'Update requirement to current Feature revision'.
	updateReqButton color: self widgetsColor.
							
	buttonLayout := LinearLayoutMorph newRow.
	buttonLayout 
		addMorph: deleteReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter;
		addMorph: updateReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LinearLayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.8
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #leftOrTop);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.2 
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #rightOrBottom);
		color: `Color transparent`;
		yourself
		! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16827067!
      buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons := LinearLayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16827154!
          optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons := OrderedCollection new.
	widths := OrderedCollection new.
	buttonColor := self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button := PluggableButtonMorph
			model: self
			action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		tuple size > 3 ifTrue: [ button setBalloonText: tuple fourth ].
		tuple size > 4 ifTrue: [ button secondaryActionSelector: tuple fifth ].
		buttons add: button ].
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row
		addMorphs: buttons
		widthProportionalTo: widths.
	^ row.! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16800012 overrides: 50351381!
                               buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code := self buildMorphicCodePane.
	comment := self buildMorphicCommentPane.
	separator := LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons := LinearLayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16800045!
              buildMorphicClassColumnWith: classList
	| column |
	column := LinearLayoutMorph newColumn.
	column
		addMorphUseAll: classList;
		addAdjusterAndMorph: self buildMorphicSwitches fixedHeight: Theme current buttonPaneHeight.
	^column! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16800099!
                           buildMorphicSwitches

	| instanceSwitch commentSwitch classSwitch row buttonColor |
	
	instanceSwitch := self createInstanceButton.
	commentSwitch := self createCommentButton.
	classSwitch := self createClassButton.
	
	row := LinearLayoutMorph newRow.
	row
		doAdoptWidgetsColor;
		addMorph: instanceSwitch proportionalWidth: 0.45;
		addMorph: commentSwitch proportionalWidth: 0.22;
		addMorph: classSwitch proportionalWidth: 0.33.
	buttonColor := self buttonColor.
	row color: buttonColor.

	{ 
		instanceSwitch.
		commentSwitch.
		classSwitch} do: [:m |  m color: buttonColor ].
		
	^row! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16800132!
                    buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList := self buildMorphicSystemCategoryList.
	classList := self buildMorphicClassList.
	messageCatList := self buildMorphicMessageCatList.
	messageList := self buildMorphicMessageList.
	
	classList allowItemDrag: true.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategory:class:.
		
	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.
	
	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16800169!
                buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList := (PluggableListMorph
				withModel: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:)
					menuNshortcutsKey: #systemCatSingletonMenuSpec.
	mySingletonList hideScrollBarsIndefinitely.

	classList := self buildMorphicClassList.
	classColumn := self buildMorphicClassColumnWith: classList.
	messageCatList := self buildMorphicMessageCatList.
	messageList := self buildMorphicMessageList.
	
	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (Preferences at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16823800 overrides: 50351500!
    buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model systemCategoryList ifNotEmpty: [ 
		model setSelectedSystemCategory: model systemCategoryList first ].
	sysCatList := (PluggableListMorph
			withModel: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:)
				menuNshortcutsKey: #codeFileListMenuSpec.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList := (PluggableListMorph
			withModel: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:)
				menuNshortcutsKey: #messageCatListMenuSpec.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.

	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (Preferences at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16805660 overrides: 50351406!
                 optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons := OrderedCollection new.
	widths := OrderedCollection new.
	buttonColor := self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button := PluggableButtonMorph 
					model: model
					action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16810217!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| changeSetList classList changeSetListPane classListPane
	  messageList upperPanes labelBackground |
	labelBackground := Theme current background.
	model myChangeSet ifNil: [
		"Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	changeSetList := (PluggableListMorphByItem
				withModel: model
				listGetter: #changeSetList
				indexGetter: #currentChangeSetName
				indexSetter: #showChangeSetNamed:)
					menuNshortcutsKey: #changeSetListMenuSpec;
					autoDeselect: false.
	changeSetListPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList := (PluggableListMorphByItem
				withModel: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:)
					menuNshortcutsKey: #classListMenuSpec.
	classListPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: changeSetListPane proportionalWidth: 0.6;
		addAdjusterAndMorph: classListPane proportionalWidth: 0.4.
	
	messageList := (PluggableListMorphByItem
				withModel: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:)
					menuNshortcutsKey: #messageListMenuSpec.
	messageList := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16845911 overrides: 50351381!
                buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons := LinearLayoutMorph newColumn.
	h := self defaultButtonPaneHeight.
	(Preferences at: #optionalButtons) ifTrue: [
		h := self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16845944!
                       buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| bottomMorph |
	bottomMorph := LinearLayoutMorph newRow.
	bottomMorph
		addMorph: self receiverInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: self receiverInspectorText proportionalWidth: 0.3;
		addAdjusterAndMorph: self contextVariableInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: self contextVariableInspectorText proportionalWidth: 0.3.

	self layoutMorph
		addMorph: self stackList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2.! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16845999!
   customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons := OrderedCollection new.
	buttonColor := self buttonColor.
	"button with target = self"
	button := PluggableButtonMorph 
		model: self
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button := PluggableButtonMorph 
					model: self
					action: tuple second.
		button color: buttonColor.
		button label: tuple first.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!MethodSetWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:19' prior: 16909092 overrides: 50351381!
            buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons := LinearLayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MessageNamesWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16902078 overrides: 16909129!
              buildMorphicWindow
	"Answer a morphic window with the given initial search string, nil if none"
	"MessageNames open"
	| selectorListView firstRow searchButton secondRow |
	textMorph := (TextModelMorph
		textProvider: model
		textGetter: #searchString
		textSetter: #searchString:
		selectionGetter: #contentsSelection)
		setBalloonText: 'See MessageNames class comment for search string options';
		emptyTextDisplayMessage: 'Type here, then hit Search'.
	textMorph askBeforeDiscardingEdits: false.
	textMorph acceptOnCR: true.
	textMorph hideScrollBarsIndefinitely.
	searchButton := PluggableButtonMorph new
		model: textMorph innerTextMorph;
		label: 'Search';
		action: #acceptContents.
	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.
	firstRow := LinearLayoutMorph newRow.
	firstRow color: self windowColor.
	firstRow
		doAdoptWidgetsColor;
		
			addMorph: searchButton
			proportionalWidth: 0.25;
		
			addMorph: textMorph
			proportionalWidth: 0.75.
	selectorListView := (PluggableListMorph
		withModel: model
		listGetter: #selectorList
		indexGetter: #selectorListIndex
		indexSetter: #selectorListIndex:)
			menuNshortcutsKey: #selectorListMenuSpec.
	secondRow := LinearLayoutMorph newRow.
	secondRow
		
			addMorph: selectorListView
			proportionalWidth: 0.5;
		
			addAdjusterAndMorph: self buildMorphicMessageList
			proportionalWidth: 0.5.
	self layoutMorph
		
			addMorph: firstRow
			fixedHeight: self defaultButtonPaneHeight + 4;
		
			addAdjusterAndMorph: secondRow
			proportionalHeight: 0.5;
		
			addAdjusterAndMorph: self buildLowerPanes
			proportionalHeight: 0.5.
	model changed: #editSelection! !
!ProtocolBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16940867 overrides: 16909129!
      buildMorphicWindow
	"Answer a morphic window that can display the receiver with a class hierarchy"
	| topRow |

	topRow := LinearLayoutMorph newRow.
	topRow 
		addMorph: self buildSelectiveClassList proportionalWidth: 0.25;
		addAdjusterMorph;
		addMorph: self buildCategoriesList proportionalWidth: 0.25;
		addAdjusterMorph;
		addMorph: self buildMorphicMessageList proportionalWidth: 0.5.
	self layoutMorph
		addMorph: topRow proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.8.
	model changed: #editSelection! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16807478 overrides: 50351830!
                    buildLowerPanes

	| codeAndButtons  |
	
	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16807490!
                           buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!ExtractMethodReplacementsWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16864168 overrides: 50351830!
          buildLowerPanes

	| codeAndButtons  |
	
	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!ExtractMethodReplacementsWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16864180!
                          buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16885109 overrides: 50351830!
             buildLowerPanes

	| codeAndButtons  |

	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.

	^codeAndButtons ! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16885121!
                               buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.

	^row

	! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16985466 overrides: 50351830!
                           buildLowerPanes

	| codeAndButtons  |

	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16985477!
          buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16936010!
               buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons := OrderedCollection new.
	triads := OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton := PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: `Color transparent`.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16868175!
      buildMorphicWindow
	| middleRow upperRow |
	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: self morphicPatternPane proportionalWidth: 0.3;
		addAdjusterAndMorph: self optionalButtonRow proportionalWidth: 0.7.
	middleRow := LinearLayoutMorph newRow.
	middleRow
		addMorph: self morphicDirectoryTreePane proportionalWidth: 0.3;
		addAdjusterAndMorph: self morphicFileListPane proportionalWidth: 0.7.
	self layoutMorph
		addMorph: upperRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterAndMorph: middleRow proportionalHeight: 0.4;
		addAdjusterAndMorph: self morphicFileContentsPane proportionalHeight: 0.6.
	self setLabel: model directory pathName.
	model postOpen! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16868249!
                   optionalButtonRow
	"Answer the button row associated with a file list"

	| row buttonColor |
	row := LinearLayoutMorph newRow.
	buttonColor := self buttonColor.
	row setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"
	row doAdoptWidgetsColor.
	row color: buttonColor.
	self updateButtonRow: row.
	^row! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16889122!
                       buildMorphicWindow
	" Inspector openOn: SystemOrganization "
	| contentsText list upperRow evaluatorText |

	"Build widgets. We'll assemble them below."
	list := self buildList.
	contentsText := self buildContentsText.
	evaluatorText := self buildEvaluatorText.
	
	"Upper row has two widgets, side by side: the list of variables at the left side, and the variable contents pane at the right side."
	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: list proportionalWidth: 0.3;
		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.
	"Inspector Window has two rows: At the top, the one we just bult. Below it, the evaluation pane."
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.7;
		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.
	"Set label"
	self setLabel: model displayLabel! !
!ProcessBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16939021!
      buildMorphicWindow
	"Create a pluggable version of me, answer a window"
	| aTextMorph list1 list2 upperRow |
	list1 := (PluggableListMorph
				withModel: model
				listGetter: #processNameList
				indexGetter: #processListIndex
				indexSetter: #processListIndex:)
					menuNshortcutsKey: #processListMenuSpec.
	list2 := (PluggableListMorph
				withModel: model
				listGetter: #stackNameList
				indexGetter: #stackListIndex
				indexSetter: #stackListIndex:)
					menuNshortcutsKey: #stackMenuSpec.
	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: list1 proportionalWidth: 0.5;
		addAdjusterAndMorph: list2 proportionalWidth: 0.5.
	aTextMorph := (TextModelMorph
				textProvider: model
				textGetter: #selectedMethod) emptyTextDisplayMessage: 'Method source (not selected?)'.
	aTextMorph askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: aTextMorph proportionalHeight: 0.5.
	self setLabel: 'Process Browser'! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16986004!
                              buildLowerPanes
	| failuresList errorsList column |
	progress := ProgressMorph label: '' subLabel: ''.
	self buildPassFailText.
	self buildDetailsText.
	failuresList := self buildFailuresList.
	errorsList := self buildErrorsList.
	column := LinearLayoutMorph newColumn.
	column
		addMorph: progress fixedHeight: 50;
		addMorph: passFailText fixedHeight: 26;
		addMorph: detailsText fixedHeight: 52;
		addMorph: failuresList proportionalHeight: 0.6;
		addAdjusterAndMorph: errorsList proportionalHeight: 0.6.
	^ column! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16986109!
                         buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton buttonsRow theTestsList column |

	runOneButton := self buildRunOneButton.
	runButton := self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	

	refreshButton := self buildRefreshButton.
	filterButton := self buildFilterButton.
	stopButton := self buildStopButton.

	theTestsList := (PluggableListMorphOfMany
				withModel: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:)
					menuNshortcutsKey: #listMenuSpec.
	theTestsList autoDeselect: false.
	theTestsList color: self textBackgroundColor.

	buttonsRow := LinearLayoutMorph newRow.
	buttonsRow doAdoptWidgetsColor.
	buttonsRow color: self buttonColor.
	buttonsRow
		addMorphs: {runButton. runOneButton. runProfiledButton};
		addMorphs: {refreshButton. filterButton. stopButton}.

	column := LinearLayoutMorph newColumn.
	column
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: buttonsRow fixedHeight: self defaultButtonPaneHeight.

	^ column! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 7/25/2025 09:28:21' prior: 50342222!
         updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LinearLayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7371-Rename-LayoutMorph-as-LinearLayoutMorph-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 25 July 2025 at 9:28:53 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:44:14'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:44:14'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:44:14'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:41:55 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7373-LayoutMorph-moveIvarsToSuperclass-p1-JuanVuletich-2025Jul25-09h34m-jmv.001.cs.st 7/27/2025 12:44:14'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:36:17'!
            doAdoptWidgetsColor
	adoptsWidgetsColor := true.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:39:00' overrides: 16796268!
             initialize
	super initialize.
	adoptsWidgetsColor := false.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:21' prior: 50340778!
beColumn
	"Establish the major layout axis, with default edge weight"
	layout := ColumnLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:17' prior: 50340786!
           beRow
	"Establish the major layout axis, with default edge weight"
	layout := RowLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:36:25' prior: 16896728 overrides: 50352312!
                             doAdoptWidgetsColor
	super doAdoptWidgetsColor.
	doAdoptWidgetsColor := true! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:39:57' prior: 50342033!
               initializeColumn

	layout := ColumnLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:10' prior: 50342569!
     initializeForm

	layout := FormLayout new.
	layoutObject := layout.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:06' prior: 50342040!
       initializeRow

	layout := RowLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	doAdoptWidgetsColor := false.
	self initialize.! !

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7373-LayoutMorph-moveIvarsToSuperclass-p1-JuanVuletich-2025Jul25-09h34m-jmv.001.cs.st 7/27/2025 12:44:14'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
LayoutMorph allSubInstancesDo: [ :m |
	m instVarNamed: 'adoptsWidgetsColor' put: (m instVarNamed: 'doAdoptWidgetsColor').
	m instVarNamed: 'layoutObject' put: (m instVarNamed: 'layout') ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7373-LayoutMorph-moveIvarsToSuperclass-p1-JuanVuletich-2025Jul25-09h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:47:28 am'!
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:46:17' prior: 16896317 overrides: 16910416!
   adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	adoptsWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: color) ]
		ifFalse: [ self color: `Color transparent` ]! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:18' prior: 50342775!
                           axisEdgeWeight
	"Only for Linear Layouts"
	^layoutObject isLinearLayout ifTrue: [
		layoutObject axisEdgeWeight ]! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:23' prior: 50341963!
               axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }
	
	Ignored for other kinds of Layouts"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layoutObject isLinearLayout ifTrue: [
		layoutObject axisEdgeWeight: aSymbolOrNumber.
		self layoutSubmorphs ].! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:28' prior: 50342696!
               gap
	"Only for Linear Layouts"
	^layoutObject isLinearLayout ifTrue: [
		layoutObject gap ]! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:36' prior: 50341988!
     gap: aNumber
	"Only for Linear Layouts"
	layoutObject isLinearLayout ifTrue: [
		layoutObject gap = aNumber ifFalse: [
			self adjustExtentFor: [
				layoutObject gap: aNumber ]].
		self layoutSubmorphs ].! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:43:31' prior: 50342005!
                   separation: aNumberOrPoint
	"Only for Linear Layouts"

	| g |
	layoutObject isLinearLayout ifTrue: [
		self padding: aNumberOrPoint.
		g := aNumberOrPoint.
		g isPoint ifTrue: [
			g := layoutObject isRow ifTrue: [ g x ] ifFalse: [ g y ]].
		self gap: g ].! !
!LinearLayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/25/2025 09:45:12' prior: 50341244!
   adjustBy: aLayoutAdjustMorph at: aGlobalPoint
	"See Class Comment of LayoutAdjustingMorph"

	| localPoint  i before after adjusterRefPos |
	localPoint := self internalizeFromWorld: aGlobalPoint.
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self ].
	before := self submorphs at: i +1.
	after := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(layoutObject adjustMorphBefore: before morphAfter: after adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !
!LinearLayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 09:43:35' prior: 50341583 overrides: 16796315!
                               minimumExtent
	"Answer size sufficient to frame my submorphs."
	
	^ (layoutObject minimumExtentFor: submorphs cachedValues: IdentityDictionary new) + (2 * self interiorOrigin)! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:43:24' prior: 50352322!
            beColumn
	"Establish the major layout axis, with default edge weight"
	layoutObject := ColumnLayout new.
	layoutObject gap: self defaultGap.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:43:18' prior: 50352331!
                        beRow
	"Establish the major layout axis, with default edge weight"
	layoutObject := RowLayout new.
	layoutObject gap: self defaultGap.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:46:38' prior: 50352347!
                              initializeColumn

	layoutObject := ColumnLayout new.
	layoutObject gap: self defaultGap.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:46:47' prior: 50352355!
                 initializeForm

	layoutObject := FormLayout new.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:46:50' prior: 50352362!
                         initializeRow

	layoutObject := RowLayout new.
	layoutObject gap: self defaultGap.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:43:44' prior: 50341454!
                               layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layoutObject layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.! !
!LinearLayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 09:45:06' prior: 50340794!
                               addAdjusterMorph
	"So the user can adjust layout"

	| thickness |
	thickness := Theme current layoutAdjusterThickness.

	layoutObject isRow ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedWidth: thickness) ].

	layoutObject isColumn ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedHeight: thickness)]! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 09:45:40' prior: 50342701!
isColumn
	"Only makes sense for Linear Layouts"
	^layoutObject isColumn! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 09:45:43' prior: 50342706!
                           isRow
	"Only makes sense for Linear Layouts"
	^layoutObject isRow! !

LinearLayoutMorph removeSelector: #doAdoptWidgetsColor!

!methodRemoval: LinearLayoutMorph #doAdoptWidgetsColor stamp: 'Install-7374-LayoutMorph-moveIvarsToSuperclass-p2-JuanVuletich-2025Jul25-09h41m-jmv.001.cs.st 7/27/2025 12:44:14'!
doAdoptWidgetsColor
	super doAdoptWidgetsColor.
	doAdoptWidgetsColor := true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7374-LayoutMorph-moveIvarsToSuperclass-p2-JuanVuletich-2025Jul25-09h41m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:47:48 am'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7375-LayoutMorph-moveIvarsToSuperclass-p3-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:44:14'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7375-LayoutMorph-moveIvarsToSuperclass-p3-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:44:15'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7375-LayoutMorph-moveIvarsToSuperclass-p3-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:54:58 am'!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:48:16' overrides: 16910416!
                      adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	adoptsWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: color) ]
		ifFalse: [ self color: `Color transparent` ]! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 09:52:40' overrides: 16796315!
                              minimumExtent
	"Ojo!!"
	^100@100! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:50:41'!
                         layoutBounds
	"Return the bounds for laying out children of the receiver"

	^ self interiorOrigin extent: self interiorExtent ! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:50:22'!
                           layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layoutObject layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.! !
!LinearLayout methodsFor: 'services' stamp: 'jmv 7/25/2025 09:53:25' overrides: 50342217!
            minimumExtentFor: morphs cachedValues: cachedValues
	self subclassResponsibility ! !

FormLayout removeSelector: #minimumExtentFor:cachedValues:!

!methodRemoval: FormLayout #minimumExtentFor:cachedValues: stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:44:15'!
minimumExtentFor: morphs cachedValues: cachedValues
	"Ojo!!"
	^100@100!

Layout removeSelector: #minimumExtentFor:cachedValues:!

!methodRemoval: Layout #minimumExtentFor:cachedValues: stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:44:15'!
minimumExtentFor: morphs cachedValues: cachedValues
	self subclassResponsibility !

LinearLayoutMorph removeSelector: #adoptWidgetsColor:!

!methodRemoval: LinearLayoutMorph #adoptWidgetsColor: stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:44:15'!
adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	adoptsWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: color) ]
		ifFalse: [ self color: `Color transparent` ]!

LinearLayoutMorph removeSelector: #layoutSubmorphs!

!methodRemoval: LinearLayoutMorph #layoutSubmorphs stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:44:15'!
layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layoutObject layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.!

LinearLayoutMorph removeSelector: #layoutBounds!

!methodRemoval: LinearLayoutMorph #layoutBounds stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:44:15'!
layoutBounds
	"Return the bounds for laying out children of the receiver"

	^ self interiorOrigin extent: self interiorExtent !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 10:01:19 am'!

LayoutMorph subclass: #FormLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #FormLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
LayoutMorph subclass: #FormLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:56:26' overrides: 16914787!
                            initializedInstance

	^LinearLayoutMorph newRow! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:57:23' overrides: 16787643!
     new

	^self error: 'Use LayoutMorph #newRow, #newColumn or #newForm'.! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:58:04'!
   newColumn
	^LinearLayoutMorph basicNew initializeColumn! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:56:48'!
                 newForm
	^FormLayoutMorph basicNew initializeForm! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:58:09'!
                       newRow
	^LinearLayoutMorph basicNew initializeRow! !
!LayoutMorph class methodsFor: 'new-morph participation' stamp: 'jmv 7/25/2025 09:58:18' overrides: 16796976!
                             categoryInNewMorphMenu
	^ 'Layouts'! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
 example1
"
	self example1
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                           example10
"
	self example10 openInWorld
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                   example11
"
	self example11
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
          example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                            example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                 example2
	"
	self example2
	"
	| pane row |
	pane := (LinearLayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
           example20
"
	self example20
"
| column |

column := (LinearLayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                              example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
   example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LinearLayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LinearLayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LinearLayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                    example7
	"
	Useful example contributed by Ken Dickey
	self example7
	"
	"============================================"
	| c colorHexValue colorName r w |
	w := SystemWindow new.
	r := LinearLayoutMorph newRow separation: 30 @ 10.
	c := LinearLayoutMorph newColumn separation: 20 @ 10.
	colorHexValue := LabelMorph contents:  'F97306'.
	colorName := LabelMorph contents: 'cornSilk'.

	r addMorph: colorHexValue.
	r addMorph: colorName.
	c addMorph: ColoredBoxMorph new.
	c addMorph: r.
	w addMorph: c .
	w openInWorld.
	"============================================"! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
              exampleEdgesColumn
	"Show 2 cases :1 useEdgeSpace true and 1 false"
	" self exampleEdgesColumn "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newColumn :: padding: (120 @ 40);  gap: 20.
	noEdge := self newColumn ::  padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 200; proportionalHeight: 0.8 minimum: 200.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 200; proportionalHeight: 0.5 minimum: 200.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                     exampleEdgesRow
	"Show 2 cases: 1 useEdgeSpace true and 1 false"
	" self exampleEdgesRow "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newRow :: padding: (120 @ 40);  gap: 20.
	noEdge := self newRow :: padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 100; proportionalHeight: 0.8 minimum: 100.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 100; proportionalHeight: 0.5 minimum: 100.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
  iconsExample
	"
	LayoutMorph iconsExample
	"
	| lm ilm counter |
	lm := LinearLayoutMorph newColumn.
	ilm := LinearLayoutMorph newRow.
	counter := 1.
	Theme methodsDo: [ :method | | sel | 
		(sel := method selector) numArgs = 0 ifTrue: [
			(sel endsWith: 'Icon') ifTrue: [ | mayBeForm |
				mayBeForm := Theme current perform: sel.
				(mayBeForm isKindOf: Form) ifTrue: [ | imageMorph |
					counter \\ 10 = 0 ifTrue: [
						lm addMorph: ilm.
						ilm := LinearLayoutMorph newRow ].
					counter := counter + 1.
					ilm addMorph: (imageMorph := ImageMorph newWith: (mayBeForm magnifyBy: 2)).
					imageMorph 
						setBalloonText: 'Copy ''', sel storeString bold, ''' to the Clipboard';
						setProperty: #'handlesMouseDown:' toValue: true;
						setProperty: #mouseButton1Down:localPosition:  toValue: [ :event :pos |
							Clipboard storeObject: sel storeString ] ] ] ] ].
	lm 
		setProperty: #taskbarButtonIcon toValue: Theme current imageIcon;
		setBalloonText: 'Drag me here!!'.
	lm openInWorld
! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                     launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random := Random new.
	b1 := PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 := PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 := PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 := PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons := {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row := LinearLayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!LayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/25/2025 09:59:06'!
  example1Form
"
	self example1Form
"
	| pane |
	pane := (FormLayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!FormLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:55:25'!
         initializeForm

	layoutObject := FormLayout new.
	self initialize.! !

LinearLayoutMorph class removeSelector: #example13!

!methodRemoval: LinearLayoutMorph class #example13 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph class removeSelector: #newRow!

!methodRemoval: LinearLayoutMorph class #newRow stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
newRow
	^self basicNew initializeRow!

LinearLayoutMorph class removeSelector: #newForm!

!methodRemoval: LinearLayoutMorph class #newForm stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
newForm
	^self basicNew initializeForm!

LinearLayoutMorph class removeSelector: #example1b!

!methodRemoval: LinearLayoutMorph class #example1b stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #exampleEdgesRow!

!methodRemoval: LinearLayoutMorph class #exampleEdgesRow stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
exampleEdgesRow
	"Show 2 cases: 1 useEdgeSpace true and 1 false"
	" self exampleEdgesRow "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newRow :: padding: (120 @ 40);  gap: 20.
	noEdge := self newRow :: padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 100; proportionalHeight: 0.8 minimum: 100.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 100; proportionalHeight: 0.5 minimum: 100.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.!

LinearLayoutMorph class removeSelector: #example11!

!methodRemoval: LinearLayoutMorph class #example11 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example11
"
	self example11
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #exampleEdgesColumn!

!methodRemoval: LinearLayoutMorph class #exampleEdgesColumn stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
exampleEdgesColumn
	"Show 2 cases :1 useEdgeSpace true and 1 false"
	" self exampleEdgesColumn "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newColumn :: padding: (120 @ 40);  gap: 20.
	noEdge := self newColumn ::  padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 200; proportionalHeight: 0.8 minimum: 200.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 200; proportionalHeight: 0.5 minimum: 200.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.!

LinearLayoutMorph class removeSelector: #example1!

!methodRemoval: LinearLayoutMorph class #example1 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example1
"
	self example1
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #example1Form!

!methodRemoval: LinearLayoutMorph class #example1Form stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example1Form
"
	self example1Form
"
	| pane |
	pane := (LinearLayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph class removeSelector: #launcherExample!

!methodRemoval: LinearLayoutMorph class #launcherExample stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random := Random new.
	b1 := PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 := PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 := PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 := PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons := {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row := LinearLayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld!

LinearLayoutMorph class removeSelector: #example101VG!

!methodRemoval: LinearLayoutMorph class #example101VG stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #example20!

!methodRemoval: LinearLayoutMorph class #example20 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example20
"
	self example20
"
| column |

column := (LinearLayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld!

LinearLayoutMorph class removeSelector: #iconsExample!

!methodRemoval: LinearLayoutMorph class #iconsExample stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
iconsExample
	"
	LayoutMorph iconsExample
	"
	| lm ilm counter |
	lm := LinearLayoutMorph newColumn.
	ilm := LinearLayoutMorph newRow.
	counter := 1.
	Theme methodsDo: [ :method | | sel | 
		(sel := method selector) numArgs = 0 ifTrue: [
			(sel endsWith: 'Icon') ifTrue: [ | mayBeForm |
				mayBeForm := Theme current perform: sel.
				(mayBeForm isKindOf: Form) ifTrue: [ | imageMorph |
					counter \\ 10 = 0 ifTrue: [
						lm addMorph: ilm.
						ilm := LinearLayoutMorph newRow ].
					counter := counter + 1.
					ilm addMorph: (imageMorph := ImageMorph newWith: (mayBeForm magnifyBy: 2)).
					imageMorph 
						setBalloonText: 'Copy ''', sel storeString bold, ''' to the Clipboard';
						setProperty: #'handlesMouseDown:' toValue: true;
						setProperty: #mouseButton1Down:localPosition:  toValue: [ :event :pos |
							Clipboard storeObject: sel storeString ] ] ] ] ].
	lm 
		setProperty: #taskbarButtonIcon toValue: Theme current imageIcon;
		setBalloonText: 'Drag me here!!'.
	lm openInWorld
!

LinearLayoutMorph class removeSelector: #new!

!methodRemoval: LinearLayoutMorph class #new stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
new

	^self error: 'Use LayoutMorph newRow or LayoutMorph newColumn'.!

LinearLayoutMorph class removeSelector: #example6!

!methodRemoval: LinearLayoutMorph class #example6 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LinearLayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LinearLayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LinearLayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld!

LinearLayoutMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: LinearLayoutMorph class #categoryInNewMorphMenu stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
categoryInNewMorphMenu
	^ 'Layouts'!

LinearLayoutMorph class removeSelector: #example10!

!methodRemoval: LinearLayoutMorph class #example10 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example10
"
	self example10 openInWorld
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane!

LinearLayoutMorph class removeSelector: #example7!

!methodRemoval: LinearLayoutMorph class #example7 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example7
	"
	Useful example contributed by Ken Dickey
	self example7
	"
	"============================================"
	| c colorHexValue colorName r w |
	w := SystemWindow new.
	r := LinearLayoutMorph newRow separation: 30 @ 10.
	c := LinearLayoutMorph newColumn separation: 20 @ 10.
	colorHexValue := LabelMorph contents:  'F97306'.
	colorName := LabelMorph contents: 'cornSilk'.

	r addMorph: colorHexValue.
	r addMorph: colorName.
	c addMorph: ColoredBoxMorph new.
	c addMorph: r.
	w addMorph: c .
	w openInWorld.
	"============================================"!

LinearLayoutMorph class removeSelector: #initializedInstance!

!methodRemoval: LinearLayoutMorph class #initializedInstance stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
initializedInstance

	^self newRow!

LinearLayoutMorph class removeSelector: #newColumn!

!methodRemoval: LinearLayoutMorph class #newColumn stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
newColumn
	^self basicNew initializeColumn!

LinearLayoutMorph class removeSelector: #example3!

!methodRemoval: LinearLayoutMorph class #example3 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph class removeSelector: #example2!

!methodRemoval: LinearLayoutMorph class #example2 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
example2
	"
	self example2
	"
	| pane row |
	pane := (LinearLayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph removeSelector: #initializeForm!

!methodRemoval: LinearLayoutMorph #initializeForm stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:44:15'!
initializeForm

	layoutObject := FormLayout new.
	self initialize.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 10:09:54 am'!
!FormLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:03:33' overrides: 50352317!
  initialize

	super initialize.
	layoutObject := FormLayout new.! !
!LinearLayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:00' overrides: 50352785!
               newColumn
	^self basicNew initializeColumn! !
!LinearLayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:11' overrides: 50352795!
    newRow
	^self basicNew initializeRow! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:53' prior: 50352775 overrides: 16914787!
initializedInstance
	^LinearLayoutMorph newRow! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:21' prior: 50352785!
          newColumn
	^LinearLayoutMorph newColumn! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:01:35' prior: 50352790!
                 newForm
	^FormLayoutMorph new! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:27' prior: 50352795!
                           newRow
	^LinearLayoutMorph newRow! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:10' prior: 50352420!
                               axisEdgeWeight
	"Only for Linear Layouts"
	^layoutObject axisEdgeWeight! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:27' prior: 50352427!
                         axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }
	
	Ignored for other kinds of Layouts"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layoutObject axisEdgeWeight: aSymbolOrNumber.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:39' prior: 50352453!
                          gap
	"Only for Linear Layouts"
	^layoutObject gap! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:49' prior: 50352459!
               gap: aNumber
	"Only for Linear Layouts"
	layoutObject gap = aNumber ifFalse: [
		self adjustExtentFor: [
			layoutObject gap: aNumber ]].
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:57' prior: 50352469!
separation: aNumberOrPoint
	"Only for Linear Layouts"

	| g |
	self padding: aNumberOrPoint.
	g := aNumberOrPoint.
	g isPoint ifTrue: [
		g := layoutObject isRow ifTrue: [ g x ] ifFalse: [ g y ]].
	self gap: g.! !

LinearLayout removeSelector: #isLinearLayout!

!methodRemoval: LinearLayout #isLinearLayout stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:44:15'!
isLinearLayout
	^true!

Layout removeSelector: #isLinearLayout!

!methodRemoval: Layout #isLinearLayout stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:44:15'!
isLinearLayout
	^false!

FormLayoutMorph class removeSelector: #new!

FormLayoutMorph removeSelector: #initializeForm!

!methodRemoval: FormLayoutMorph #initializeForm stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:44:15'!
initializeForm

	layoutObject := FormLayout new.
	self initialize.!

LayoutMorph class removeSelector: #new!

!methodRemoval: LayoutMorph class #new stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:44:15'!
new

	^self error: 'Use LayoutMorph #newRow, #newColumn or #newForm'.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 10:32:00 am'!
!LinearLayoutMorph commentStamp: 'jmv 7/25/2025 10:14:16' prior: 16896260!
                A row or column of Morphs, does layout by placing them along either a horizontal axis or a vertical axis.

Submorphs might specify a LayoutSpec. If some don't, then, for a column, the column width is taken as the width, and any morph height is kept. Same for rows: submorph width would be maintained, and submorph height would be made equal to row height.

Notes:
  - Contained submorphs may have fixed or minimum sizes.
  - We can specify fixed separation.
  - We can offset to left or right.
  - Contained submorphs can, via LayoutSizeSpecs, ask for a proportion of
    the space which is left over after the minimum extent.

  One subtlety with the proportional layouts is that the sum of
  proportions may add up to more than 100%.

  We want to allocate fairly.

  Say we have 2 submorphs which ask for 80% and 50%.

  They should be normalized to get 80/130 and 50/130 of the excess space.

Instance Variables:
  direction - either #horizontal (row) or #vertical (column).
  gap - Empty space between Morphs:
	gap for both x and y axes or a point: (xGap @ yGap)
  axisEdgeWeight  - Along the Major or Layout Axis, subMorphs may be attracted 
	toward one side (0.0) or the other (1.0).  
	See comment in method #axisEdgeWeight:
  doAdoptWidgetsColor - see method #adoptWidgetsColor:
  useEdgeSpace - When true, x and y separation are kept between submorphs and the
	edge of our extent, othersize no space is kept between submorphs 
	and our outer edge.

!
!LayoutSizeSpec commentStamp: 'jmv 7/25/2025 10:15:05' prior: 16897948!
   LayoutSizeSpecs are the basis for the LinearLayout mechanism. Any Morph can be given a LayoutSizeSpecs, but in order to honor it, its owner must be a LinearLayout.

A LayoutSpec specifies how a morph wants to be layed out. In particular, a LayoutSizeSpec It can specify either a fixed width or a fraction of some available owner width. Same goes for height. If a fraction is specified, a minimum extent is also possible.


Alternatives:
	- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width
	- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width
	- proportionalWidth isNil, fixedWidth notNil	->		Use fixedWidth
	- proportionalWidth notNil, fixedWidth isNil	->		NOT VALID

Same goes for proportionalHeight and fixedHeight
!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:12:04' overrides: 16913987!
                         addMorphFrontFromWorldPosition: aMorph

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	self addMorphFront: aMorph.
	self layoutSubmorphs.
! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:25:51' overrides: 16796227!
                       borderWidth: anInteger

	super borderWidth: anInteger.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:26:00' overrides: 16796238!
                     padding: numberOrPoint
	"Honored by all kinds of Layouts"

	super padding: numberOrPoint.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:13' overrides: 16796251!
             defaultBorderWidth
	"answer the default border width for the receiver"
	^ 0! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:17' overrides: 16796256!
                  defaultColor
	^ Theme current defaultWindowColor! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:21'!
 defaultGap
	"Answer the default gap between submorphs for the receiver.
	Redefine this method for a different initial gap in your morphs.
	Only for Linear Layouts"

	^ 0! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:28'!
        doClipSubmorphs
	self setProperty: #doClipSubmorphs toValue: true.! !
!LayoutMorph methodsFor: 'drawing' stamp: 'jmv 7/25/2025 10:18:14' overrides: 16796275!
  drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."

	aCanvas
		fillRectangle: self localBounds
		color: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor.! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 10:21:30' overrides: 16913170!
                    layoutSubmorphsIfNeeded
	"Recompute the layout if necessary."

	self isLayoutNeeded ifTrue: [
		self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:23:03' overrides: 16796596!
            extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:24:35' overrides: 16913216!
                            someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:11:13'!
  addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, at the bottom or right, with aLayoutSpec"

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec: aLayoutSpec.
	self addMorphFront: aMorph.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:11:49' overrides: 16913949!
                         addMorphBack: aMorph
	"Add a submorph, at the top or left, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphBack: aMorph.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:11:13' overrides: 16913968!
                               addMorphFront: aMorph
	"Add a submorph, at the bottom or right, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphFront: aMorph! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:21:22' overrides: 16914094!
                          removedMorph: aMorph
	"One of my submorphs has been removed."

	super removedMorph: aMorph.
	self layoutSubmorphs! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 10:12:09' overrides: 16914517!
                   privateAddAllMorphs: aCollection atIndex: index

	aCollection do: [ :m |
		m isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
		m layoutSpec ].
	^ super privateAddAllMorphs: aCollection atIndex: index.! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 10:12:13' overrides: 16914561!
                         privateAddMorph: aMorph atIndex: index position: aPoint

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	^ super privateAddMorph: aMorph atIndex: index position: aPoint.! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 10:20:23' overrides: 16796324!
                           is: aSymbol
	^ aSymbol == #LayoutMorph or: [ super is: aSymbol ]! !
!LayoutMorph methodsFor: 'geometry testing' stamp: 'jmv 7/25/2025 10:18:45' overrides: 16912677!
                           clipsSubmorphs
	"LayoutMorphs usually not do not clip submorphs.
	A special case is Transcript. It doesn't include a ScrollPane (that usually does clipping).
	Note: for this to work, we can't be transparent, as transparent morphs can't clip submorphs.
		Senders may also call #doAdoptWidgetsColor.
	There may be other similar cases in the future."

	^self hasProperty: #doClipSubmorphs.! !
!LayoutMorph methodsFor: 'layout in owner' stamp: 'jmv 7/25/2025 10:19:11' overrides: 50338435!
                          layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec ! !
!FormLayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:24:13' overrides: 50352661!
              minimumExtent
	"Ojo!!"
	^100@100! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:13:48' prior: 50342231!
       allocHeightForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minHeight
	so breakeven is when
	  amountToAlloc = minHeight / proportion * factor"
	| minHeight |
	minHeight := (self minimumLayoutExtent: cachedValues) y.
	^(self isProportionalHeight)
		ifFalse:  [ minHeight ]
		ifTrue: [ minHeight / (aFactor * self layoutSpec proportionalLayoutHeight) ]! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:14:04' prior: 50342249!
 allocWidthForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minWidth
	so breakeven is when
	  amountToAlloc = minWidth / proportion * factor"
	| minWidth |
	minWidth := (self minimumLayoutExtent: cachedValues) x.
	^(self isProportionalWidth)
		ifFalse:  [ minWidth ]
		ifTrue: [ minWidth / (aFactor * self layoutSpec proportionalLayoutWidth) ]! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 10:30:30' prior: 50352944!
                       example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 800@600.
pane openInWorld! !
!LayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/25/2025 10:31:38' prior: 50353492!
     example1Form
"
	self example1Form
"
	| pane |
	pane := (FormLayoutMorph newForm padding: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 7/25/2025 10:20:30' prior: 50351152!
            removeStayUpBox
	| box |
	submorphs isEmpty ifTrue: [^self].
	(submorphs first is: #LayoutMorph) ifFalse: [^self].
	box := submorphs first submorphs second.
	(box is: #PluggableButtonMorph) 
		ifTrue: [ box hide ]! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 7/25/2025 10:20:25' prior: 50352223!
                    updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].! !

LinearLayoutMorph removeSelector: #defaultColor!

!methodRemoval: LinearLayoutMorph #defaultColor stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
defaultColor
	^ Theme current defaultWindowColor!

LinearLayoutMorph removeSelector: #clipsSubmorphs!

!methodRemoval: LinearLayoutMorph #clipsSubmorphs stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
clipsSubmorphs
	"LayoutMorphs usually not do not clip submorphs.
	A special case is Transcript. It doesn't include a ScrollPane (that usually does clipping).
	Note: for this to work, we can't be transparent, as transparent morphs can't clip submorphs.
		Senders may also call #doAdoptWidgetsColor.
	There may be other similar cases in the future."

	^self hasProperty: #doClipSubmorphs.!

LinearLayoutMorph removeSelector: #layoutSpec!

!methodRemoval: LinearLayoutMorph #layoutSpec stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec !

LinearLayoutMorph removeSelector: #padding:!

!methodRemoval: LinearLayoutMorph #padding: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
padding: numberOrPoint
	"Honored by all kinds of Layouts"

	super padding: numberOrPoint.
	self layoutSubmorphs.!

LinearLayoutMorph removeSelector: #defaultGap!

!methodRemoval: LinearLayoutMorph #defaultGap stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
defaultGap
	"Answer the default gap between submorphs for the receiver.
	Redefine this method for a different initial gap in your morphs.
	Only for Linear Layouts"

	^ 0!

LinearLayoutMorph removeSelector: #drawOn:!

!methodRemoval: LinearLayoutMorph #drawOn: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."

	aCanvas
		fillRectangle: self localBounds
		color: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor.!

LinearLayoutMorph removeSelector: #addMorphFrontFromWorldPosition:!

!methodRemoval: LinearLayoutMorph #addMorphFrontFromWorldPosition: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
addMorphFrontFromWorldPosition: aMorph

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	self addMorphFront: aMorph.
	self layoutSubmorphs.
!

LinearLayoutMorph removeSelector: #privateAddAllMorphs:atIndex:!

!methodRemoval: LinearLayoutMorph #privateAddAllMorphs:atIndex: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
privateAddAllMorphs: aCollection atIndex: index

	aCollection do: [ :m |
		m isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
		m layoutSpec ].
	^ super privateAddAllMorphs: aCollection atIndex: index.!

LinearLayoutMorph removeSelector: #is:!

!methodRemoval: LinearLayoutMorph #is: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
is: aSymbol
	^ aSymbol == #LinearLayoutMorph or: [ super is: aSymbol ]!

LinearLayoutMorph removeSelector: #doClipSubmorphs!

!methodRemoval: LinearLayoutMorph #doClipSubmorphs stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
doClipSubmorphs
	self setProperty: #doClipSubmorphs toValue: true.!

LinearLayoutMorph removeSelector: #layoutSubmorphsIfNeeded!

!methodRemoval: LinearLayoutMorph #layoutSubmorphsIfNeeded stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
layoutSubmorphsIfNeeded
	"Recompute the layout if necessary."

	self isLayoutNeeded ifTrue: [
		self layoutSubmorphs ].!

LinearLayoutMorph removeSelector: #addMorph:layoutSpec:!

!methodRemoval: LinearLayoutMorph #addMorph:layoutSpec: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, at the bottom or right, with aLayoutSpec"

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec: aLayoutSpec.
	self addMorphFront: aMorph.!

LinearLayoutMorph removeSelector: #someSubmorphPositionOrExtentChanged!

!methodRemoval: LinearLayoutMorph #someSubmorphPositionOrExtentChanged stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	self layoutNeeded: true.!

LinearLayoutMorph removeSelector: #addMorphBack:!

!methodRemoval: LinearLayoutMorph #addMorphBack: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
addMorphBack: aMorph
	"Add a submorph, at the top or left, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphBack: aMorph.!

LinearLayoutMorph removeSelector: #privateAddMorph:atIndex:position:!

!methodRemoval: LinearLayoutMorph #privateAddMorph:atIndex:position: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
privateAddMorph: aMorph atIndex: index position: aPoint

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	^ super privateAddMorph: aMorph atIndex: index position: aPoint.!

LinearLayoutMorph removeSelector: #addMorphFront:!

!methodRemoval: LinearLayoutMorph #addMorphFront: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
addMorphFront: aMorph
	"Add a submorph, at the bottom or right, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphFront: aMorph!

LinearLayoutMorph removeSelector: #extentChanged:!

!methodRemoval: LinearLayoutMorph #extentChanged: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.!

LinearLayoutMorph removeSelector: #defaultBorderWidth!

!methodRemoval: LinearLayoutMorph #defaultBorderWidth stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
defaultBorderWidth
	"answer the default border width for the receiver"
	^ 0!

LinearLayoutMorph removeSelector: #borderWidth:!

!methodRemoval: LinearLayoutMorph #borderWidth: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
borderWidth: anInteger

	super borderWidth: anInteger.
	self layoutSubmorphs.!

LinearLayoutMorph removeSelector: #removedMorph:!

!methodRemoval: LinearLayoutMorph #removedMorph: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
removedMorph: aMorph
	"One of my submorphs has been removed."

	super removedMorph: aMorph.
	self layoutSubmorphs!

LayoutMorph removeSelector: #minimumExtent!

!methodRemoval: LayoutMorph #minimumExtent stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:44:15'!
minimumExtent
	"Ojo!!"
	^100@100!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 11:30:30 am'!
!FormLayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:26:14' overrides: 50354683!
addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, with aLayoutSpec"
	
	aLayoutSpec isLayoutEdgesSpec ifFalse: [ self error: 'Only LayoutEdgesSpec can be used in FormLayoutMorphs' ].
	super addMorph: aMorph layoutSpec: aLayoutSpec! !
!LinearLayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:26:40' overrides: 50354683!
   addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, at the bottom or right, with aLayoutSpec"
	
	aLayoutSpec isLayoutSizeSpec ifFalse: [ self error: 'Only LayoutSizeSpec can be used in LinearLayoutMorphs' ].
	super addMorph: aMorph layoutSpec: aLayoutSpec! !
!Layout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:17:52'!
                       isFormLayout
	^false! !
!Layout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:17:47'!
         isLinearLayout
	^false! !
!FormLayout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:18:55' overrides: 50355228!
               isFormLayout
	^true! !
!LinearLayout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:19:07' overrides: 50355231!
                isLinearLayout
	^true! !
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:25:43'!
    isLayoutEdgesSpec
	^false! !
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:24:59'!
isLayoutSizeSpec
	^false! !
!LayoutEdgesSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:25:34' overrides: 50355242!
        isLayoutEdgesSpec
	^true! !
!LayoutSizeSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:27:27' overrides: 50355245!
         isLayoutSizeSpec
	^true! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:29:53' prior: 50354683!
    addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, with aLayoutSpec.
	Subclasses validate that aLayoutSpec is appropriate for them before calling super."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec: aLayoutSpec.
	self addMorphFront: aMorph.! !

LayoutSizeSpec removeSelector: #isLinearLayoutSpec!

LayoutSpec removeSelector: #isLinearLayoutSpec!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7380-ValidateLayoutSpecClass-JuanVuletich-2025Jul25-10h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7380] on 25 July 2025 at 12:34:00 pm'!
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 11:56:30'!
          assureLayoutSpecForOwner: toBeOwner
	"If we haven't been set a layout spec yet, or we carry one that can no longe be used,
	set a default one for our new context."

	(toBeOwner isLayoutSpecOk: layoutSpec ) ifFalse: [
		layoutSpec := nil ].

	layoutSpec ifNil: [
		layoutSpec := toBeOwner defaultLayoutSpecFor: self.
		layoutSpec morph: self ].! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:01:06'!
                       defaultLayoutEdgesSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a FormLayout.
	Not really useful in practice, just _some_  default."

	^LayoutEdgesSpec
		tlEdgesWeight: 0.5@0.5 offset: -100 @ -10
		brEdgesWeight: 0.5@0.5 offset: 100 @ 10! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 11:51:03'!
          defaultLayoutSizeSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a LinearLayout."

	^LayoutSizeSpec useAll! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:30:26'!
               useDefaultLayoutSizeSpec
	"Set our default for LinearLayout. Answer it for convenience."

	self layoutSpec: self defaultLayoutSizeSpec.
	^layoutSpec! !
!BoxMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 11:51:06' overrides: 50355307!
         defaultLayoutSizeSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a LinearLayout."

	^LayoutSizeSpec keepMorphExtent! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 12:00:29'!
                isLayoutSpecOk: aLayoutSpecOrNil
	"Answer whether the argument can work with us."
	
	^self subclassResponsibility! !
!LayoutMorph methodsFor: 'layout in owner' stamp: 'jmv 7/25/2025 11:51:09' overrides: 50355323!
           defaultLayoutSizeSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a LinearLayout."

	^LayoutSizeSpec useAll! !
!LayoutMorph methodsFor: 'aux' stamp: 'jmv 7/25/2025 11:55:30'!
                             defaultLayoutSpecFor: aMorph
	^self subclassResponsibility! !
!FormLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 12:00:46' overrides: 50355331!
      isLayoutSpecOk: aLayoutSpecOrNil
	"Answer whether the argument can work with us."
	
	^aLayoutSpecOrNil notNil and: [aLayoutSpecOrNil isLayoutEdgesSpec]! !
!FormLayoutMorph methodsFor: 'aux' stamp: 'jmv 7/25/2025 11:55:46' overrides: 50355346!
             defaultLayoutSpecFor: aMorph
	^aMorph defaultLayoutEdgesSpec! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 12:00:51' overrides: 50355331!
  isLayoutSpecOk: aLayoutSpecOrNil
	"Answer whether the argument can work with us."
	
	^aLayoutSpecOrNil notNil and: [aLayoutSpecOrNil isLayoutSizeSpec]! !
!LinearLayoutMorph methodsFor: 'aux' stamp: 'jmv 7/25/2025 12:09:56' overrides: 50355346!
            defaultLayoutSpecFor: aMorph
	^aMorph defaultLayoutSizeSpec! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 12:32:52' prior: 50354785!
            allocHeightForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minHeight
	so breakeven is when
	  amountToAlloc = minHeight / proportion * factor"
	| minHeight |
	minHeight := (self minimumLayoutExtent: cachedValues) y.
	^(self isProportionalHeight)
		ifFalse:  [ minHeight ]
		ifTrue: [ minHeight / (aFactor * layoutSpec proportionalLayoutHeight) ]! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 12:32:56' prior: 50354804!
      allocWidthForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minWidth
	so breakeven is when
	  amountToAlloc = minWidth / proportion * factor"
	| minWidth |
	minWidth := (self minimumLayoutExtent: cachedValues) x.
	^(self isProportionalWidth)
		ifFalse:  [ minWidth ]
		ifTrue: [ minWidth / (aFactor * layoutSpec proportionalLayoutWidth) ]! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:32:15' prior: 50338423!
      layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in an owning layout.
	If asked before setting it, and before adding us to some owner,
	just answer nil."

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	owner notNil ifTrue: [
		self assureLayoutSpecForOwner: owner ].
	^ layoutSpec.! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:25:56' prior: 16930564!
                            layoutSpec: aLayoutSpec
	"Layout specific. Set the layout spec describing where the receiver should appear in a proportional layout"
	layoutSpec == aLayoutSpec ifTrue: [ ^self ].
	aLayoutSpec morph: self.
	layoutSpec := aLayoutSpec.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 7/25/2025 12:30:39' prior: 50350292 overrides: 16848620!
                               buildWidgets

	| buttonRow titleMorph |
	titleMorph := (LabelMorph contents: 'Find in source code' fontSize: 16 emphasis: 1).
	titleMorph useDefaultLayoutSizeSpec offAxisEdgeWeight: 0.
	searchField := EntryFieldMorph new.
	searchField
		crAction: [ self ok ];
		escAction: [ self cancel ].
	searchField useDefaultLayoutSizeSpec offAxisEdgeWeight: 0.
	initialSearchString ifNotNil: [ searchField contents: initialSearchString ].
	scopeList := PluggableListMorph
		withModel: self
		listGetter: #scopesList
		indexGetter: #scopeIndex
		indexSetter: #scopeIndex:.
	scopeList 
		doubleClickSelector: #ok.
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		gap: 14;
		addMorphKeepMorphHeight: titleMorph;
		addMorphKeepMorphHeight: searchField;
		addMorphUseAll: scopeList;
		addMorphKeepMorphHeight: buttonRow.

	self morphExtent: self minimumExtent * (2@1.5).! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:58:36' prior: 50354695 overrides: 16913949!
        addMorphBack: aMorph
	"Add a submorph, at the top or left, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	super addMorphBack: aMorph.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:58:40' prior: 50354707 overrides: 16913968!
                           addMorphFront: aMorph
	"Add a submorph, at the bottom or right, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	super addMorphFront: aMorph! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:58:45' prior: 50354604 overrides: 16913987!
                      addMorphFrontFromWorldPosition: aMorph

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	self addMorphFront: aMorph.
	self layoutSubmorphs.
! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 11:58:02' prior: 50354726 overrides: 16914517!
                     privateAddAllMorphs: aCollection atIndex: index

	aCollection do: [ :m |
		m isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
		m assureLayoutSpecForOwner: self ].
	^ super privateAddAllMorphs: aCollection atIndex: index.! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 11:58:52' prior: 50354737 overrides: 16914561!
                     privateAddMorph: aMorph atIndex: index position: aPoint

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	^ super privateAddMorph: aMorph atIndex: index position: aPoint.! !

LayoutMorph removeSelector: #layoutSpec!

!methodRemoval: LayoutMorph #layoutSpec stamp: 'Install-7381-PickLayoutSpecClass-JuanVuletich-2025Jul25-12h06m-jmv.002.cs.st 7/27/2025 12:44:15'!
layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec !

BoxMorph removeSelector: #layoutSpec!

!methodRemoval: BoxMorph #layoutSpec stamp: 'Install-7381-PickLayoutSpecClass-JuanVuletich-2025Jul25-12h06m-jmv.002.cs.st 7/27/2025 12:44:15'!
layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec keepMorphExtent.
	layoutSpec morph: self.

	^ layoutSpec!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7381-PickLayoutSpecClass-JuanVuletich-2025Jul25-12h06m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7381] on 25 July 2025 at 3:19:13 pm'!
!ExtractMethodReplacementsWindow methodsFor: 'as yet unclassified' stamp: 'jmv 7/25/2025 15:17:32' prior: 16864250 overrides: 16909166!
                       createCodePaneMorph

	^super createCodePaneMorph
		disableEditing;
		yourself! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7382-ExtractMethodReplacementsWindow-fix-JuanVuletich-2025Jul25-15h13m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 25 July 2025 at 3:21:37 pm'!
!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/25/2025 15:21:09' prior: 16844552!
     runToCursorAt: aPositionToStop

	| runToCursorContext |
	
	runToCursorContext := self selectedContext home.
	self assert: runToCursorContext mapsPcTo: aPositionToStop.
	
	[ (self pcRange includes: aPositionToStop) 
		ifTrue: [ self stepIntoBlock ]
		ifFalse: [ self doStep ].
	self isPcAt: aPositionToStop in: runToCursorContext ] whileFalse! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7383-RunToCursorImprovement-HernanWilkinson-2025Jul25-15h21m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 27 July 2025 at 12:27:25 pm'!
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 7/27/2025 12:26:17' prior: 17018488!
      mainLoop

	[
		self displayWorldOn: canvas.
		[
			"Here canvas and waitDelay are passed as arguments.
			This is because when debugging Morphic, a new UI process,
			these ivars are updated, but in the debugger process we still want the original ones."
			self doOneCycleOn: canvas delay: waitDelay.
			UISupervisor isUIProcessRunning ]
				whileTrue: []
	] on: Error, Halt do: [ :ex |
		"Handle a drawing error"
		(ex signalerContext findContextSuchThat: [ :context |
				#(drawOn: postDrawOn: fullDraw:) statePointsTo: context selector ])
			ifNotNil: [ :context |
				context selector = #fullDraw:
					ifTrue: [ (context at: 1) drawingFails ]
					ifFalse: [ context receiver drawingFails ].
				"Install the old error handler, so we can re-raise the error.
				This means, open a Debugger.
				This will also create a new Morphic process. if the user closes the debugger."
				ex receiver error: ex description.
				"Create a new UI process, if the user proceeds in the debugger.
				This is to use a new, clean Canvas."
				UISupervisor newUIProcess ]
			ifNil: [
				"Debugging aid: Uncomment. Set Transcript to log to StdOut and File.
				Be ready to need to kill Cuis from the OS."
				"'-----' print.
				{Time now. Processor activeProcess. ex} print.
				thisContext printStack: 50.
				[UISupervisor newUIProcess] fork."
				ex return ]
	].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 7/27/2025 12:22:02' prior: 16915565!
                             fullDraw: aMorph
	"Draw the full Morphic structure on us"
	aMorph visible ifFalse: [^ self].

	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."
	self into: aMorph.

	currentMorph isKnownFailing ifTrue: [
		self canvasToUse drawCurrentAsError.
		self outOfMorph.
		^ self].

	currentMorph layoutSubmorphsIfNeeded.

	(currentMorph isOwnedByHand and: [
			(Preferences at: #cheapWindowReframe) and: [currentMorph is: #SystemWindow]]) ifTrue: [
		self canvasToUse drawCurrentAsOutline ifTrue: [
			self outOfMorph.
			^ self]].

	"Draw current Morph and submorphs"	
	self canvasToUse drawCurrentAndSubmorphs.

	self outOfMorph.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\7384-FurtherProtectMorphicAgainstCodeErrors-JuanVuletich-2025Jul27-12h20m-jmv.001.cs.st----!

----QUIT----(27 July 2025 12:44:18) Cuis7.5-7384-32.image priorSource: 580255!