'From Cuis6.2 [latest update: #6156] on 29 December 2023 at 3:19:51 pm'!


----SNAPSHOT----(29 December 2023 15:19:51) Cuis6.2-32.image priorSource: 0!

----QUIT----(29 December 2023 15:20:05) Cuis6.3-6156-32.image priorSource: 73!

----STARTUP---- (29 December 2023 15:37:36) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.3-6156-32.image!


SourceFileVersionString!

SourceFileVersionString := 'Cuis6.3' .!

SourceFileVersionString!

----QUIT----(29 December 2023 15:38:04) Cuis6.3-6156-32.image priorSource: 151!

----STARTUP---- (30 January 2024 19:39:00) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.3-6156-32.image!


'From Cuis6.3 [latest update: #6156] on 1 January 2024 at 4:07:00 pm'!
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 1/1/2024 16:04:37' prior: 16970156!
 copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak project. 1997-2024.
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2024.'.! !
!Utilities class methodsFor: 'default desktop' stamp: 'jmv 1/1/2024 16:04:51' prior: 16996178!
 defaultTextEditorContents
	^ ('
', 
('Cuis Smalltalk

' centered blue pointSize: FontFamily defaultPointSize * 3),
('
"Yay, Juan.  You GO, guy!! ...a great example of malleable software (and a clever mind) at work."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Dan Ingalls
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I like it... It''s nice and clean and simple and pretty. Nice stuff!!"
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Alan Kay
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I think you have a very elegant design aesthetic."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('John Maloney
'italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
'

',
'Cuis is a modern, Open Source, multiplatform, Smalltalk-80 system.


',
'Cuis is:

' bold,
'    - Small
    - Clean
    - Appropriable
' blue,
'

Additionally, Cuis is:

' bold, 
'    - Open Source
    - Multiplatform
' blue,
'
 
Like other Smalltalk systems, Cuis is also:

' bold, 
'    - A complete development environment written in itself
    - A pure, dynamic Object Oriented language
' blue,
'

Cuis assumes very little on the underlying platform, and this lets it run out-of-the-box on Windows, MacOS, Linux, ChromeOS and WebBrowsers. Cuis shares the [OpenSmalltalk Virtual Machine] (http://www.opensmalltalk.org) with Squeak, Pharo and Newspeak.

What sets Cuis apart from the other members of the Squeak family is the focus on Smalltalk-80 and an active attitude towards system complexity:

Unbound complexity growth, together with development strategies focused only in the short term, are the worst long term enemies of all software systems. As systems grow older, they usually become more complex. New features are added as layers on top of whatever is below, sometimes without really understanding it, and almost always without modifying it. Complexity and size grow without control. Evolution slows down. Understanding the system becomes harder every day. Bugs are harder to fix. Codebases become huge for no clear reason. At some point, the system can''t evolve anymore and becomes "legacy code".

Complexity puts a limit to the level of understanding of the system a person might reach, and therefore limits the things that can be done with it. Dan Ingalls says all this in ["Design Principles Behind Smalltalk"] (http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html). Even if you have already done so, please go and read it again!!

Cuis Smalltalk is our attempt at this challenge. Furthermore, we believe we are doing something else that no other Smalltalk, commercial or open source, does. We attempt to give the true Smalltalk-80 experience, and keep Smalltalk-80 not as legacy software of historic significance, but as a live, evolving system. We feel we are the keepers of the Smalltalk-80 heritage, and enablers of the Dynabook experience.

As Cuis evolves, we keep on these values. Every update, be it a bug fix or a feature enhancement, is reviewed carefully to avoid adding unneeded complexity to the system. Every opportunity to remove unneeded complexity is followed. As we go, features are enhanced, and any reported bugs fixed. We also adopt selected enhancements from Squeak and Pharo, and share our work with the wider Smalltalk community.


' justified,
'License
' bold,
'
Cuis is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . Any contribution submitted for incorporation into or for distribution with Cuis shall be presumed subject to the same license.

Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982
Copyright (c) Apple Computer, Inc. 1985-1996
Copyright (c) Contributors to Squeak project. 1997-2024
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2024')! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6157-UpdateCopyrightNotice-JuanVuletich-2024Jan01-16h04m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6157] on 2 January 2024 at 7:01:13 am'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 1/2/2024 06:50:37' prior: 16864523!
         arcTanNonPrimitive
	"Answer the angle in radians."

	| theta delta sinTheta cosTheta minPossibleDelta |

	"Newton-Raphson"
	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].

	"first guess"
	theta := (self * Halfpi) / (self + 1.0).

	"iterate"
	[
		sinTheta := theta sin.
		cosTheta := theta cos.
		delta := (sinTheta * cosTheta) - (self * cosTheta * cosTheta).
		minPossibleDelta := theta ulp.
		delta abs >= minPossibleDelta ]
		whileTrue: [
			theta := theta - delta.
			"There is a risk of not converging if #sin and #cos are not good enough.
			Still, there's no point in trying to further reduce delta, meaning we won't find
			a better approximation of the result."
			delta abs = minPossibleDelta ifTrue: [
				^theta ]].
	^ theta! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6158-arcTanNonPrimitive-fix-JuanVuletich-2024Jan02-06h48m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6156] on 30 December 2023 at 4:51:21 pm'!
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 12/30/2023 16:45:54'!
  disableUsePrefsFile
	Preferences name: #useUserPrefsFile category: #system value: false.! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 12/30/2023 16:45:36'!
                             enableUsePrefsFile
	Preferences name: #useUserPrefsFile category: #system value: true.
	PreferenceSet saveUserPrefs.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/30/2023 16:39:59' prior: 16966160!
    readAndApplyUserPrefs
	"
	Smalltalk readAndApplyUserPrefs
	"
	(Preferences at: #useUserPrefsFile) ifTrue: [
		PreferenceSet readAndApplyUserPrefs ].! !
!Preference methodsFor: 'accessing' stamp: 'jmv 12/30/2023 16:40:36' prior: 16928262!
                  isSavedToDisk: aBoolean
	"True if this preference was modified by the user, or read from disk.
	If so, keep the User Preferences file updated."

	isSavedToDisk := aBoolean.
	isSavedToDisk ifTrue: [
		(Preferences at: #useUserPrefsFile) ifTrue: [
			PreferenceSet saveUserPrefs ]].! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 12/30/2023 16:43:01' prior: 16928706!
      prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(useUserPrefsFile true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 12/30/2023 16:50:57' prior: 16984359!
                              preferencesMenuOptions

	^`{
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Focus follows Mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Focus when Click'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.

			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Show ST-80 assignments'.
				#selector 			-> 		#enableShowAssignmentAsLeftArrow.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Show ANSI assignments'.
				#selector 			-> 		#disableShowAssignmentAsLeftArrow.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		60.
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		TrueTypeFontFamily.
				#selector 			-> 		#readAdditionalFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		70.
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		80.
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.




			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'Save Prefs in UserPrefs.txt'.
				#selector 			-> 		#enableUsePrefsFile.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Preferences are saved without need to save the Smalltalk Image.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'Save Prefs in the Image'.
				#selector 			-> 		#disableUsePrefsFile.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Preferences are lost unless the Smalltalk Image is saved.'
			} asDictionary.





			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		40.
				#label 			-> 		'All preferences...'.
				#object 			-> 		PreferenceSet.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`.! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 12/30/2023 16:51:05' prior: 16984867!
                 worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions,
		TheWorldMenu helpMenuOptions,
		TheWorldMenu changesMenuOptions,
		TheWorldMenu debugMenuOptions`.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences name: #useUserPrefsFile category: #system value: true.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6159-Preference-useUserPrefsFile-JuanVuletich-2023Dec30-16h39m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6159] on 2 January 2024 at 12:23:13 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 12:08:06'!
                            promptUser: currentNameOrNil includeNonASCII: showFontsNotIncludingASCIICharacters
	"
	FontFamily promptUser
	FontFamily promptUser: FontFamily defaultFamilyName
	"
	"Present a menu of available fonts, and if one is chosen, return it.
	Otherwise return nil."

	| menu answer |
	menu := MenuMorph entitled: 'Fonts'.
	menu defaultTarget: menu.
	menu addTitle: 'Installed Fonts'.
	FontFamily familyNames do: [ :fontName | | fontFamily item |
		fontFamily := FontFamily familyNamed: fontName.
		(fontFamily includesAscii or: [showFontsNotIncludingASCIICharacters]) ifTrue: [
			item := menu
				add: (fontName = currentNameOrNil) asMenuItemTextPrefix, fontName
				target: menu
				action: #modalSelection:
				argument: {#fontName. fontName}.
			fontFamily includesAscii ifTrue: [
				item fontFamily: fontFamily ]]].

	menu addTitle: 'Available to install '.
	(DirectoryEntry trueTypeFontsDirectory
		directories sorted: [ :a :b | a name < b name ]) do: [ :dir | | subDirs |
			subDirs := dir directories sorted: [ :a :b | a name < b name ].
			subDirs isEmpty
				ifTrue: [
					self addFontDir: dir to: menu current: currentNameOrNil ]
				ifFalse: [ | submenu anyAdded |
					submenu := MenuMorph new defaultTarget: menu.
					anyAdded := false.
					subDirs do: [ :subdir |
						anyAdded := anyAdded | (self addFontDir: subdir to: submenu current: currentNameOrNil) ].
					anyAdded ifTrue: [
						menu add: dir name, '... ' subMenu: submenu ]]].
	menu lastSubmorph class == MenuLineMorph ifTrue: [
		3 timesRepeat: [menu lastSubmorph delete ]].

	answer := menu invokeModal.
	answer ifNil: [ ^nil ].
	answer first = #fontDirectory
		ifTrue: [ TrueTypeFontFamily readAllTrueTypeFontsIn: answer third ].
	^FontFamily familyNamed: answer second! !
!LabelMorph methodsFor: 'printing' stamp: 'jmv 1/2/2024 12:00:47'!
       fontFamily: aFontFamily
	"Set the font my text will use. The emphasis remains unchanged."

	font := aFontFamily atPointSize: (font ifNotNil: [ font pointSize ] ifNil: [ FontFamily defaultPointSize ]).
	self font: font emphasis: emphasis! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 12:09:05' prior: 16867358!
                             promptUser
	"Present a menu of font families, answer selection.
	FontFamily promptUser
	"
	^self promptUser: FontFamily defaultFamilyName includeNonASCII: true! !
!FontFamily class methodsFor: 'ui' stamp: 'KLG 1/2/2024 12:08:48' prior: 16867365!
          promptUser: currentNameOrNil
	"
	FontFamily promptUser
	FontFamily promptUser: FontFamily defaultFamilyName
	"
	"Present a menu of available fonts, and if one is chosen, return it.
	Otherwise return nil."

	^self promptUser: currentNameOrNil includeNonASCII: true! !
!FontFamily class methodsFor: 'ui' stamp: 'KLG 1/2/2024 12:15:27' prior: 16867415!
  promptUserAlt
	"Present a menu of font families, answer selection.
	Alternative implementation: Show only installed fonts.
	FontFamily promptUserAlt
	"
	| fontMenu priorFontFamily |
	priorFontFamily := FontFamily defaultFamilyName.
	fontMenu := MenuMorph entitled: 'Installed Fonts'.
	FontFamily familyNames do: [ :fontName | | fontFamily item |
		item := fontMenu
			add: (priorFontFamily sameAs: fontName) asMenuItemTextPrefix, fontName
			target: fontMenu
			action: #modalSelection:
			argument: fontName.
		fontFamily := FontFamily familyNamed: fontName.
		fontFamily includesAscii ifTrue: [
			item fontFamily: fontFamily ]].
	^FontFamily familyNamed: fontMenu invokeModal.! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 12:10:17' prior: 16867434!
  promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	(self promptUser: FontFamily defaultFamilyName includeNonASCII: false) ifNotNil: [ :fontFamily |
		fontFamily includesAscii
			ifTrue: [PreferenceSet setDefaultFont: fontFamily familyName ]
			ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6160-NicerFontFamilyUI-GeraldKlix-2024Jan02-12h18m-KLG.001.cs.st----!

'From Cuis6.3 [latest update: #6160] on 2 January 2024 at 1:56:32 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'KLG 1/2/2024 13:54:22' prior: 16867449!
         promptUserForSize: currentSize fontFamily: fontFamily
	| menu |
	menu := MenuMorph entitled: 'Font Sizes'.
	menu defaultTarget: menu.
	fontFamily pointSizes do: [ :pt | | itemText sizeToUse |
		itemText := pt printString.
		sizeToUse := pt.
		menu
			add: (pt = currentSize) asMenuItemTextPrefix, itemText
			action: #modalSelection:
			argument: pt ::
				font: (fontFamily atPointSize: sizeToUse) ].
	^ menu invokeModal! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6161-FontSizeMenu-showActualSizes-GeraldKlix-2024Jan02-13h53m-KLG.001.cs.st----!

'From Cuis6.3 [latest update: #6161] on 2 January 2024 at 2:47:39 pm'!
!MenuItemMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:37:54' overrides: 16888617!
                font: aFont emphasis: emphasisCode

	super font: aFont emphasis: emphasisCode.
	contentString ifNotNil: [
		self contentsWithMarkers: contentString inverse: false ].! !
!LabelMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:40:03' prior: 16888653!
        emphasis: aNumber
	"Set the receiver's emphasis as indicated. aNumber is a bitmask with the following format:

	bit	attribute
	1	bold
	2	italic
	4	underlined
	8	struckThrough
	16	withUnderscoreGlyphs
	"

	"examples: 0 -> plain.  
	1 -> bold.  2 -> italic.  3 -> bold italic.  4 -> underlined  
	5 -> bold underlined.  6 -> italic underlined.   7 -> bold italic underlined   
	etc...

	Prefer AbstractFont method category: 'derivatives - emphasis' 
	to raw numbers:
	    self emphasis: AbstractFont boldItalic.
	etc."

	self font: font emphasis: aNumber.! !
!LabelMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:39:45' prior: 16888738!
    font: aFont
	"Set the font my text will use. The emphasis remains unchanged."

	self font: aFont emphasis: emphasis.! !
!LabelMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:41:15' prior: 50332194!
                         fontFamily: aFontFamily
	"Set the font my text will use. The emphasis remains unchanged."

	self
		font: (aFontFamily atPointSize: (font
			ifNotNil: [ font pointSize ]
			ifNil: [ FontFamily defaultPointSize ]))
		emphasis: emphasis.! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 1/2/2024 14:46:12' prior: 16893138!
                           contentsWithMarkers: aString inverse: invertMarkers
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString := nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString := aString.	"remember actual string"
	marker := ((marker = '<on>' or: [marker = '<yes>']) xor: invertMarkers)
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents: (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: 1@(self morphHeight +1- marker morphHeight // 2).
	marker lock.! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 1/2/2024 14:43:33' prior: 16893497!
          offImage
	"Return the form to be used for indicating an '<off>' marker"
	| e ps1 ps2 |
	ps1 := self fontToUse pointSize.
	ps2 := FontFamily defaultPointSize.
	e := (ps1 < ps2 ifTrue: [ ps1+ ps2 // 2 ] ifFalse: [ ps1 * 2 + (ps2 * 6) // 8 ]) asPoint.
	(OffImage isNil or: [ OffImage extent ~= e ]) ifTrue: [
		OffImage := Form extent: e depth: 32.
		OffImage getCanvas
			frameAndFillRectangle: OffImage boundingBox fillColor: `(Color gray: 0.9)`
				borderWidth: 2 borderColor: `Color black` ].
	^OffImage! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 1/2/2024 14:43:41' prior: 16893512!
               onImage
	"Return the form to be used for indicating an '<on>' marker"
	| e ps1 ps2 |
	ps1 := self fontToUse pointSize.
	ps2 := FontFamily defaultPointSize.
	e := (ps1 < ps2 ifTrue: [ ps1+ ps2 // 2 ] ifFalse: [ ps1 * 2 + (ps2 * 6) // 8 ]) asPoint.
	(OnImage isNil or: [ OnImage extent ~= e ]) ifTrue: [
		OnImage := Form extent: e depth: 32.
		OnImage getCanvas
			frameAndFillRectangle: OnImage boundingBox fillColor: `Color gray: 0.9`
				borderWidth: 2 borderColor: `Color black`;
			fillRectangle: (OnImage boundingBox insetBy: 3) color: `Color black` ].
	^OnImage! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6162-MenuTweaks-JuanVuletich-2024Jan02-14h37m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6162] on 2 January 2024 at 3:30:44 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 15:29:52' prior: 50332137!
                 promptUser: currentNameOrNil includeNonASCII: showFontsNotIncludingASCIICharacters
	"
	FontFamily promptUser
	FontFamily promptUser: FontFamily defaultFamilyName
	"
	"Present a menu of available fonts, and if one is chosen, return it.
	Otherwise return nil."

	| menu answer |
	menu := MenuMorph entitled: 'Fonts'.
	menu defaultTarget: menu.
	menu addTitle: 'Installed Fonts'.
	FontFamily familyNames do: [ :fontName | | fontFamily item |
		fontFamily := FontFamily familyNamed: fontName.
		(fontFamily includesAscii or: [showFontsNotIncludingASCIICharacters]) ifTrue: [
			item := menu
				add: (fontName = currentNameOrNil) asMenuItemTextPrefix, fontName
				target: menu
				action: #modalSelection:
				argument: {#fontName. fontName}.
			fontFamily includesAscii ifTrue: [
				item fontFamily: fontFamily ]]].

	menu addTitle: 'Available to install'.
	(DirectoryEntry trueTypeFontsDirectory
		directories sorted: [ :a :b | a name < b name ]) do: [ :dir | | subDirs |
			subDirs := dir directories sorted: [ :a :b | a name < b name ].
			subDirs isEmpty
				ifTrue: [
					self addFontDir: dir to: menu current: currentNameOrNil ]
				ifFalse: [ | submenu anyAdded |
					submenu := MenuMorph new defaultTarget: menu.
					anyAdded := false.
					subDirs do: [ :subdir |
						anyAdded := anyAdded | (self addFontDir: subdir to: submenu current: currentNameOrNil) ].
					anyAdded ifTrue: [
						menu add: dir name, '... ' subMenu: submenu ]]].
	"If there's nothing 'Available to install', remove the section title"
	(menu lastSubmorph is: #MenuItemMorph) ifFalse: [
		menu lastSubmorph delete ].

	answer := menu invokeModal.
	answer ifNil: [ ^nil ].
	answer first = #fontDirectory
		ifTrue: [ TrueTypeFontFamily readAllTrueTypeFontsIn: answer third ].
	^FontFamily familyNamed: answer second! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6163-Tweak-JuanVuletich-2024Jan02-15h26m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6163] on 17 January 2024 at 8:31:33 pm'!
!ContextPart methodsFor: 'instruction decoding' stamp: 'HAW 1/17/2024 20:30:55' prior: 16838024!
                        return: value from: aSender 
	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"

	| newTop |
	newTop := aSender sender.
	(aSender isDead or: [newTop isNil or: [newTop isDead]]) ifTrue: [
		^ self pc: nil; send: #cannotReturn: to: self with: {value} super: false].
	(self findNextUnwindContextUpTo: newTop) ifNotNil: [
		^ self send: #aboutToReturn:through: to: self with: {value. nil} super: false].
	self releaseTo: newTop.
	newTop ifNotNil: [newTop push: value].
	^ newTop! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6164-return_from_improvement-HernanWilkinson-2024Jan17-20h30m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6163] on 17 January 2024 at 8:56:28 pm'!
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 1/17/2024 20:42:01' prior: 16962679!
                  classNamed: className 
	"className is either a class name or a class name followed by ' class'.
	Answer the class or metaclass it names.
	Answer nil if no class by that name."
	"
	Smalltalk classNamed: #Point
	Smalltalk classNamed: 'Point'
	Smalltalk classNamed: 'Point class'
	Smalltalk classNamed: 'BogusClassName'
	Smalltalk classNamed: 'BogusClassName class'

	Smalltalk classNamed: #Display
	Smalltalk classNamed: 'Display'
	Smalltalk classNamed: 'Display class'
	"

	self at: className asSymbol ifPresent: [ :found |
		^ found isBehavior ifTrue: [ found ]].

	(className withoutSuffix: ' class') ifNotNil: [ :baseName |
		self at: baseName asSymbol ifPresent: [ :found |
			^ found isBehavior ifTrue: [ found class ]]].

	^ nil! !
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 1/17/2024 20:50:04' prior: 16962848!
  renameAndUpdateReferences: oldName as: newName
	"Dangerous. Simple search and replace could break stuff.
	Use only to generate change sets to later checked with care
	
OldMorph withAllSubclasses do: [ :c |
	n := c name.
	(n beginsWith: 'Old') ifTrue: [
		Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]]

OldBorderStyle withAllSubclasses do: [ :c |
	n := c name.
	(n beginsWith: 'Old') ifTrue: [
		Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]]

#(#OldKeyboardBuffer #OldLayoutCell #OldLayoutFrame #OldLayoutPolicy #OldLayoutProperties #OldMorphExtension #OldMouseClickState #OldProportionalLayout #OldTableLayout #OldTableLayoutProperties #OldTextAnchor #OldTextComposer #OldTextContainer #OldTextLine #OldTheWorldMenu #OldWorldState #OldWorldTest) do: [ :n |
	Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]
	"

	self renameClassNamed: oldName as: newName.
	(self allCallsOn: (self associationAt: newName)) do: [ :methodRef |
		methodRef updateReferencesTo: oldName toBe: newName ]! !
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 1/17/2024 20:50:21' prior: 16962902!
   renamedClass: aClass from: oldName 
	
	| newName |
	
	newName := aClass name.
	
	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: aClass category.
	self 
		logChange: 'Smalltalk renameClassNamed: #', oldName, ' as: #', newName
		preamble: 'classRenamed: #', oldName, ' as: #', newName, Utilities changeStampField! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:41:03' prior: 16962945!
                        browseEqEqSentToCharacterConstants
	"
	Smalltalk browseEqEqSentToCharacterConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isConstantCharacter or: [ node arguments first isConstantCharacter ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:41:08' prior: 16962965!
                              browseEqEqSentToSmallIntegerConstants
	"
	Smalltalk browseEqEqSentToSmallIntegerConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isConstantNumber or: [ node arguments first isConstantNumber ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:41:44' prior: 16963001!
                              browseUndeclaredReferences
	"
	Smalltalk browseUndeclaredReferences
	"
	| anythingToShow |
	self cleanOutUndeclared.
	anythingToShow := false.
	Undeclared keys do: [ :k |
		anythingToShow := true.
		self
			browseMessageList: (self allCallsOn: (Undeclared associationAt: k))
			name: 'References to Undeclared: ', k printString ].

	"undeclared not in Undeclared - "
	"This happened in Pharo. See http://lists.gforge.inria.fr/pipermail/pharo-project/2012-March/061270.html
	Maybe do something like this in Cuis too???
	lostUndeclared := self allSelect: [:m|
		m literals anySatisfy: [:l|
			l isVariableBinding
				and: [l key isSymbol ""avoid class-side methodClass literals""
				and: [(m methodClass bindingOf: l key) isNil
				and: [(Undeclared includesAssociation: l) not]]]]].
	"

	anythingToShow ifFalse: [
		 (PopUpMenu labels: ' OK ')
				startUpWithCaption: 'There are no Undeclared at all' ]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:42:21' prior: 16963033!
                        cleanCompactObsoleteClasses

	| cct |
	"No Compact Classes support in Spur"
	self isSpur ifTrue: [ ^ self ].

	cct := self compactClassesArray.
	cct do: [ :c |
		c ifNotNil: [
			c isObsolete ifTrue: [ 
				cct at: c indexIfCompact put: nil ]]]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:42:48' prior: 16963049!
          condenseChanges
	"Move all the changes onto a compacted sources file."
	"
	Smalltalk condenseChanges
	"

	| oldChanges classCount oldChangesLocalName oldChangesPathName |
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' forceWriteStreamDo: [ :f |
		f timeStamp.
		'Condensing Changes File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: self classNames size
			during: [ :barBlock |
				classCount := 0.
				self allClassesDo: [ :class | 
					barBlock value: (classCount := classCount + 1).
					class moveChangesTo: f.
					class putClassCommentToCondensedChangesFile: f.
					class class moveChangesTo: f ]].
		LastQuitLogPosition := f position ].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	oldChanges := SourceFiles at: 2.
	oldChangesPathName := oldChanges name.
	oldChangesLocalName := oldChanges localName.
	oldChanges close.
	(oldChangesPathName, '.old') asFileEntry delete.
	oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old'.
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' rename: oldChangesLocalName.
	
	SourceFiles
			at: 2 put: oldChangesPathName asFileEntry appendStream.

	self inform: 'Changes file has been rewritten!!

Check that all is well, and then save/quit.
 
Otherwise, remove new changes,
replace it with the former one, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:42:59' prior: 16963115!
                            condenseSources: newVersionString
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"

	| classCount oldChanges oldChangesLocalName oldChangesPathName newChangesPathName newSourcesName |
	SourceFileVersionString := newVersionString.

	"Write all sources with fileIndex 1"
	newSourcesName := self defaultSourcesName.
	newSourcesName asFileEntry writeStreamDo: [ :f |
		f timeStamp.
		'Condensing Sources File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: self classNames size
			during: [ :barBlock |
				classCount := 0.
				self allClassesDo: [ :class |
					barBlock value: (classCount := classCount + 1).
					class fileOutOn: f moveSource: true toFile: 1]]].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	"Make a new empty changes file"
	oldChanges := SourceFiles at: 2.
	oldChangesPathName := oldChanges name.
	oldChangesLocalName := oldChanges localName.
	self closeSourceFiles.
	oldChangesPathName ifNotNil: [
		(oldChangesPathName, '.old') asFileEntry delete.
	oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old' ].
	newChangesPathName := self defaultChangesName.
	newChangesPathName asFileEntry writeStreamDo: [ :stream |
		stream timeStamp ].
	LastQuitLogPosition := 0.

	self openSourceFiles.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:45:00' prior: 16963159!
                           macroBenchmark1    "Smalltalk macroBenchmark1"
	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."
	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |
	classes := self allClasses select: [:c | c name < 'B3'].
	badOnes := OrderedCollection new.
'Decompiling and recompiling...'
displayProgressAt: Sensor mousePoint
from: 0 to: (classes sum: [:c | c selectors size] ifEmpty: [0])
during: [:barBlock | n := 0.
	classes do:
		[:cls | 
		"Transcript cr; show: cls name."
		cls selectors do:
			[:selector | barBlock value: (n := n+1).
			oldMethod := cls compiledMethodAt: selector.
			oldCodeString := (cls decompilerClass new
								decompile: selector in: cls method: oldMethod)
							decompileString.
			methodNode := cls compilerClass new
						compile: oldCodeString
						in: cls notifying: nil ifFail: nil.
			newMethod := methodNode generate: #(0 0 0 0).
			oldCodeString = (cls decompilerClass new
								decompile: selector in: cls method: newMethod)
							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].
].
	^ badOnes size! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:45:06' prior: 16963237!
                         obsoleteBehaviors
	"
	Smalltalk obsoleteBehaviors inspect
	Find all obsolete behaviors including meta classes
	"
	| obs |
	obs := OrderedCollection new.
	self garbageCollect.
	self allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [obs add: cl]].
	^ obs asArray! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:45:21' prior: 16963249!
      obsoleteClasses   "Smalltalk obsoleteClasses inspect"
	"NOTE:  Also try inspecting comments below"
	| obs c |
	obs := OrderedCollection new.  
	self garbageCollect.
	Metaclass allInstancesDo:
		[:m | c := m soleInstance.
		(c notNil and: ['AnOb*' match: c name asPlainString])
			ifTrue: [obs add: c]].
	^ obs asArray

"Likely in a ClassDict or Pool...
(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray
"
"Obsolete class refs or super pointer in last lit of a method...
| n l found |
Smalltalk browseAllSelect:
	[:m | found := false.
	1 to: m numLiterals do:
		[:i | (((l := m literalAt: i) isMemberOf: Association)
				and: [(l value isKindOf: Behavior)
				and: ['AnOb*' match: l value name]])
			ifTrue: [found := true]].
	found]
"! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:49:14' prior: 16963320!
   removeEmptyMessageCategories
	"Smalltalk removeEmptyMessageCategories"
	self garbageCollect.
	(ClassOrganizer allInstances copyWith: SystemOrganization) do:
		[:org | org removeEmptyCategories]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:04' prior: 16963329!
                             testDecompiler
	"
	Smalltalk testDecompiler
	"
	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."
	| methodNode oldMethod newMethod badOnes oldCodeString n |
	badOnes := OrderedCollection new.
	'Decompiling all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n := 0.
			self allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n := n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldMethod := cls compiledMethodAt: selector.
					oldCodeString := (cls decompilerClass new
						decompile: selector
						in: cls
						method: oldMethod) decompileString.
					methodNode := cls compilerClass new
						compile: oldCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod := methodNode generate: #(0 0 0 0 ).
					oldCodeString =
						(cls decompilerClass new
							decompile: selector
							in: cls
							method: newMethod) decompileString ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: (MethodReference class: cls selector: selector) ]]]].
	self
		browseMessageList: badOnes
		name: 'Decompiler Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:15' prior: 16963379!
       testFormatter
	"Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.
	The formatting used will be classic monochrome."
	| newCodeString methodNode oldMethod newMethod badOnes n |
	badOnes := OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n := 0.
			self allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n := n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					newCodeString := cls compilerClass new
						format: (cls sourceCodeAt: selector)
						in: cls
						notifying: nil.
					methodNode := cls compilerClass new
						compile: newCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod := methodNode generate: #(0 0 0 0 ).
					oldMethod := cls compiledMethodAt: selector.
					oldMethod = newMethod ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	self
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:24' prior: 16963421!
                        testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes := OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n := 0.
			self allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n := n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString := (cls sourceCodeAt: selector) asPlainString.
					newCodeString := cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens := oldCodeString findTokens: Character separators.
					newTokens := newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	self
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:35' prior: 16963461!
            verifyChanges		"Smalltalk verifyChanges"
	"Recompile all methods in the changes file."
	self allBehaviorsDo: [:class | class recompileChanges].
! !
!SystemDictionary methodsFor: 'image, changes name' stamp: 'HAW 1/17/2024 20:32:40' prior: 16963609!
       userChangesFileName
	"
	Smalltalk userChangesFileName
	"
	^(FileIOAccessor default baseNameFor: self imageName pathAndLocalName second), 
		(Preferences at: #userChangesFileNameExtension)! !
!SystemDictionary methodsFor: 'memory space' stamp: 'HAW 1/17/2024 20:44:51' prior: 16963783!
   lowSpaceWatcher
	"Wait until the low space semaphore is signalled, then take appropriate actions."

	| p |
	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [
		self garbageCollect <= self lowSpaceThreshold ifTrue: [
			"free space must be above threshold before starting low space watcher"
			^ self primitiveBeep ]].

	LowSpaceSemaphore := Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"

	LowSpaceSemaphore wait.  "wait for a low space condition..."

	self primSignalAtBytesLeft: 0.  "disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess := nil.
	"Note: user now unprotected until the low space watcher is re-installed"

	p := (self specialObjectsArray at: 23) ifNil: [
		"In case the LowSpaceSemaphore is signaled not by the VM but by someone else."
		Processor preemptedProcess ].
	self specialObjectsArray at: 23 put: nil.
	p isTerminated ifFalse: [
		p suspend.
		Debugger openProcess: p context: p suspendedContext label: 'Space is low' ]! !
!SystemDictionary methodsFor: 'code authors' stamp: 'HAW 1/17/2024 20:35:40' prior: 16963956!
    allContributors
"
	Smalltalk allContributors
"
	| answer author |
	answer := Set new.
	self allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author := compiledMethod author.
			author notEmpty ifTrue: [
				answer add: author ]]].
	^answer! !
!SystemDictionary methodsFor: 'code authors' stamp: 'HAW 1/17/2024 20:43:06' prior: 16963967!
                     contributionsOf: aString
	"
	Smalltalk contributionsOf: 'JMV'
	"
	| author answer |
	answer := OrderedCollection new.
	self allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author := compiledMethod author.
			aString = author ifTrue: [
				answer add: {compiledMethod methodClass. compiledMethod selector}]]].
	^answer! !
!SystemDictionary methodsFor: 'code authors' stamp: 'HAW 1/17/2024 20:52:32' prior: 16964219!
      unknownContributors
	"Answer a collection of authorInitials for whom there is code in the system 
	(either in core or in loaded packages), but we don't knwo their full name.
	Smalltalk unknownContributors
	"

	| all ok |
	all := self allContributors asSet.
	ok := (self knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
	^(all difference: ok) asArray sort! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:43:19' prior: 16964278!
              extraVMMemory
	"Answer the current setting of the 'extraVMMemory' VM parameter. See the comment in extraVMMemory: for details."

	^ self vmParameterAt: 23
! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:43:24' prior: 16964286!
  extraVMMemory: extraBytesToReserve
	"Request that the given amount of extra memory be reserved for use by the virtual machine to leave extra C heap space available for things like plugins, network and file buffers, and so on. This request is stored when the image is saved and honored when the image is next started up. Answer the previous value of this parameter."

	extraBytesToReserve < 0
		ifTrue: [self error: 'VM memory reservation must be non-negative'].
	^ self vmParameterAt: 23 put: extraBytesToReserve
! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:43:47' prior: 16964305!
                            getCurrentWorkingDirectory
	"Do our best effort to answer the path from wich Cuis was started.

	Smalltalk getCurrentWorkingDirectory


On Linux, starting as
	juan@juandebian:/media/sf_SharedWithLinux/testPayload03/payload$      coglinux/bin/squeak        Cuis-Smalltalk-Dev-master/Cuis4.2-2367.image
we get:
	Smalltalk vmPath                       					'/media/sf_SharedWithLinux/testPayload03/payload/coglinux/lib/squeak/4.5-3370/'
	Smalltalk imagePath   							'/media/sf_SharedWithLinux/testPayload03/payload/Cuis-Smalltalk-Dev-master'
	Smalltalk primGetCurrentWorkingDirectoryUnix    '/media/sf_SharedWithLinux/testPayload03/payload'
	Smalltalk getCurrentWorkingDirectory 			'/media/sf_SharedWithLinux/testPayload03/payload'


On Windows 7, starting as
	C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload>        cogwin\squeak.exe            Cuis-Smalltalk-Dev-master/Cuis4.2-2367.image
we get:
	Smalltalk vmPath    										'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload\cogwin\'
	Smalltalk imagePath   									'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload\Cuis-Smalltalk-Dev-master'
	Smalltalk primGetCurrentWorkingDirectoryWindows       	'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload\Cuis-Smalltalk-Dev-master'
	Smalltalk getCurrentWorkingDirectory  					'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload'

	Easy on Unix. Harder on Windows, because #primGetCurrentWorkingDirectoryWindows insists on lying and answers the directory containing the image.
	"
	
	| fullImagePathName imageSpecCmdLineArgument |

	"Easy on Unix"
	 self primGetCurrentWorkingDirectoryUnix ifNotNil: [ :cwd |
		"It seems on Mac, when dropping image on VM, we get '/', that is not really meaningful"
		(cwd = '/' and: [ self platformName = 'Mac OS' ]) ifFalse: [
			^ cwd ]].

	"On Windows, extract shell path if image is in subtree"
	fullImagePathName := self imageName.
	imageSpecCmdLineArgument := self getSystemAttribute: 1.
	imageSpecCmdLineArgument ifNotNil: [
		(imageSpecCmdLineArgument size < fullImagePathName size and: [			"Not if they are equal, as if they are both fully qualified (absolute) paths"
			fullImagePathName asPathTokens endsWith: imageSpecCmdLineArgument asPathTokens]) ifTrue: [
				^ fullImagePathName copyFrom: 1 to: fullImagePathName size - imageSpecCmdLineArgument size - 1 ]].

	"If we don't know better, answer nil. If appropriate, senders do:
		Smalltalk getCurrentWorkingDirectory ifNil: [ Smalltalk imagePath ]
	to have, at least, some valid directory
	"
	^ nil! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:44:30' prior: 16964516!
                 isDevelopmentEnvironmentPresent
	"Or we can't open a Smalltalk debugger"

	^ self isHeadless not and: [self includesKey: #Debugger]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:52:51' prior: 16964756!
                          vmOptionsDo: aBlock
	"Repeatedly evaluate aBlock for each vm option specified by the commandline that started Cuis.
	aBlock has two arguments: the vm option itself and the index (position)
	
	Smalltalk vmOptionsDo: [ :option :i | {i. option} print ]
	"
	| i vmOption |
	i := -1.
	[vmOption := self getSystemAttribute: i.
	vmOption notNil ] whileTrue: [
		aBlock value: vmOption value: i.
		i := i-1 ]! !
!SystemDictionary methodsFor: 'printing' stamp: 'jmv 9/3/2012 18:04' prior: 16964817 overrides: 16829096!
  printOn: aStream
	self == Smalltalk
		ifTrue: [ aStream nextPutAll: 'Smalltalk' ]
		ifFalse: [ super printOn: aStream ]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:35:34' prior: 16964865!
         allBehaviorsDo: aBlock 
	"Evaluate the argument, aBlock, for each kind of Behavior in the system 
	(that is, Object and its subclasses).
	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous
	behaviors for which the following should be executed:

		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].

	but what follows is way faster than enumerating all objects."

	self do: [ :root |
		(root isBehavior and: [root superclass isNil]) ifTrue: [	"Grab ProtoObject and any other alike"
			root withAllSubclassesDo: [ :class |
				class isMeta ifFalse: [ "The metaclasses are rooted at Class; don't include them twice."
					aBlock
						value: class;
						value: class class ]]]]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:36:20' prior: 16965090!
               allMethodsSourceStringMatching: aString
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.
	Search the class comments also.
	Argument might include $*, that matches any subsequence.
	For example, try:
		ensure:*[*close*]
	"
	| list classCount adder |
	list := Set new.
	adder := [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self classNames size
		during: [ :barBlock |
			classCount := 0.
			self allClassesDo: [ :class |
				barBlock value: (classCount := classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						(aString match: (cl sourceCodeAt: sel)) ifTrue: [
							adder
								value: cl
								value: sel ]].

					(aString match: cl organization classComment) ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:01' prior: 16965124!
                            allMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	| list classCount adder |
	list := Set new.
	adder := [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self classNames size
		during: [ :barBlock |
			classCount := 0.
			self allClassesDo: [ :class |
				barBlock value: (classCount := classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						((cl sourceCodeAt: sel)
							findString: aString
							startingAt: 1
							caseSensitive: caseSensitive) > 0 ifTrue: [
							adder
								value: cl
								value: sel ]].
					(cl organization classComment
						findString: aString
						startingAt: 1
						caseSensitive: caseSensitive) > 0 ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:05' prior: 16965276!
                             allReferencesToLiteral: aLiteral
	| coll |
	coll := OrderedCollection new.
	self allBehaviorsDo: [ :eaClass |
		eaClass
			addMethodsTo: coll
			thatReferenceTo: aLiteral
			special: false
			byte: nil ].
	^ coll.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:14' prior: 16965308!
           allSentMessagesWithout: classesAndMessagesPair
	"Answer the set of selectors which are sent somewhere in the system, 
	computed in the absence of the supplied classes and messages."

	| sent absentClasses absentSelectors |
	sent := IdentitySet new: CompiledMethod instanceCount.
	absentClasses := classesAndMessagesPair first.
	absentSelectors := classesAndMessagesPair second.
	self classNames do: [ :cName | 
		((absentClasses includes: cName)
				ifTrue: [#()]
				ifFalse: [{(self at: cName). (self at: cName) class}]) do: [ :cl |
			 (absentSelectors isEmpty
					ifTrue: [cl selectors]
					ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: [ :sel |
				 "Include all sels, but not if sent by self"
				self allSymbolsIn: (cl compiledMethodAt: sel) literals do: [ :m |
					m == sel ifFalse: [sent add: m] ]]]].
		"The following may be sent without being in any literal frame"
		1 to: self specialSelectorSize do: [ :index | 
			sent add: (self specialSelectorAt: index)].
	self presumedSentMessages do: [ :sel | sent add: sel].
	^ sent! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:48' prior: 16965402!
   allUnusedClassesWithout: classesAndMessagesPair
	"Enumerates all classes in the system and returns a list of those that are apparently unused. A class is considered in use if it (a) has subclasses or (b) is referred to by some method or (c) has its name in use as a literal (but not in the same class) or: (d) some instance is a global."
	"
	Smalltalk unusedClasses
	"

	| unused cl |
	self garbageCollect.
	unused := self classNames asIdentitySet
				copyWithoutAll: (self allGlobalRefsWithout: classesAndMessagesPair).
				
	self do: [ :global |
		unused remove: global class name ifAbsent: nil].
	
	^ unused reject: [ :cName |
		cl := self at: cName.
		cl subclasses notEmpty
			"or: [ cl someInstance notNil ]"
			"or: [cl inheritsFrom: FileDirectory]"]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:46:14' prior: 16965549!
           poolUsers
	"Answer a dictionary of pool name -> classes that refer to it. Also includes any globally know dictionaries (such as Smalltalk, Undeclared etc) which although not strictly accurate is potentially useful information "
	"Smalltalk poolUsers"
	| poolUsers pool refs |
	poolUsers := Dictionary new.
	self keys
		do: [ :k |
			 (((pool := self at: k) is: #Dictionary)
					or: [pool isKindOf: SharedPool class])
				ifTrue: [refs := self allClasses
								select: [:c | c sharedPools identityIncludes: pool]
								thenCollect: [:c | c name].
					refs := refs asOrderedCollection.
					refs
						add: (self
								allCallsOn: (self associationAt: k)).
					poolUsers at: k put: refs]].
	^ poolUsers! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:35:27' prior: 16965603!
                            abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal := 0.  bCount := 0.
	self allBehaviorsDo: [: b | bTotal := bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		self allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount := bCount + 1).
			cl selectors do: [:selector |
				m := cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	self allBehaviorsDo: [:b | b zapOrganization].
	self closeSourceFiles.
	Preferences at: #warnIfNoChangesFile put: false.
	Preferences at: #warnIfNoSourcesFile put: false! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:48:51' prior: 16965693!
                         reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	self at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := self unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(self at: c) removeFromSystem]. 
		n := self removeAllUnSentMessages.
		unused := self unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	self garbageCollect.
	oldDicts := MethodDictionary allInstances.
	newDicts := Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts := newDicts := nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:49:00' prior: 16965760!
                        removeAllUnSentMessages
	"Smalltalk removeAllUnSentMessages"
	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 
	Smalltalk removeAllUnSentMessages > 0] whileTrue."
	"Remove all implementations of unsent messages."
	| sels n |
	sels := self allUnSentMessages.
	self presumedSentMessages
		do: [:sel | sels
				remove: sel
				ifAbsent: nil].
	sels isEmpty
		ifTrue: [^ 0].
	n := 0.
	self
		allBehaviorsDo: [:x | n := n + 1].
	'Removing ' , sels size printString , ' messages . . .'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: n
		during: [:barBlock | 
			n := 0.
			self
				allBehaviorsDo: [:class | 
					barBlock value: (n := n + 1).
					sels
						do: [:sel | class removeSelector: sel]]].
	^ sels size! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:49:24' prior: 16965786!
                            removeSelector: descriptor
	"Safely remove a selector from a class (or metaclass). If the class
	or the method doesn't exist anymore, never mind and answer nil.
	This method should be used instead of 'Class removeSelector: #method'
	to omit global class references."

	| class sel |
	class := self at: descriptor first ifAbsent: [^ nil].
	(descriptor size > 2 and: [descriptor second == #class])
		ifTrue:
			[class := class class.
			sel := descriptor third]
		ifFalse: [sel := descriptor second].
	^ class removeSelector: sel! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:49:55' prior: 16965805!
                  removedUnusedClassesAndMethods
	[
		#hereWeGo print.
		self unusedClasses do: [:c | 
			c print.
			(self at: c) removeFromSystem]. 
		self removeAllUnSentMessages > 0 or: [ self unusedClasses notEmpty ]] whileTrue.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:43:35' prior: 16966008!
  filenameForUpdatedImage: aBoolean
	"If aBoolean, include highest update number	"
	| fileName newName changesName systemVersion |
	systemVersion := SystemVersion current.
	fileName := String streamContents: [ :strm |
		strm nextPutAll: systemVersion versionString.
		aBoolean ifTrue: [
			strm
				nextPut: $-;
				print: systemVersion highestUpdate ].
		self isSpur
			ifTrue: [	
				self wordSize = 4 ifTrue: [
					strm nextPutAll: '-32' ]]
			ifFalse: [
				strm nextPutAll: '-v3' ]].
	newName := fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName := DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName := self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		self inform:
'There is already .changes file of the desired name,
', changesName, '
curiously already present, even though there is no
corresponding .image file.
Please remedy manually and then repeat your request.'.
		^nil  ].
	^newName! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:46:58' prior: 16966071!
                    printStuffToCleanOnImageSave
	"So far, to serve experiments.
	Some day, when this is empty, we'll be closer to bootstrap from sources."
	| n nonNilVars m classInstVars v|
	n := 0.
	""
	'--------' print.
	'Proceeses: ' print.
	(Processor processes
		sort: [ :a :b | a priority >= b priority ]) do: [ :p | p print ].
	'======' print.
	'Globals: ' print.
	self globals associationsDo: [ :g | " {g key. g value class }" g  print ].
	'======' print.
	'ClassVars (notNil):  ' print.
	n := 0.
	self hierachySortedAllClassesDo: [ :cls |
		"Cleared, but come again for lazy init during this report.
		therefore, not required for bootstrap from sources"
		({ Scanner } includes: cls) ifFalse: [
			nonNilVars := cls classPool select: [ :var | var notNil ].
			nonNilVars notEmpty ifTrue: [
				n := n + 1.
				{ cls. nonNilVars keys} print ]]].
	'======' print.
	'InstClassVars (notNil): ' print.
	m := 0.
	self hierachySortedAllClassesDo: [ :cls |
		classInstVars := Dictionary new.
		cls class allRegularInstVarNames do: [ :nam |
			v := cls instVarNamed: nam.
			v ifNotNil: [
				classInstVars at: nam put: v ]].
		classInstVars notEmpty ifTrue: [
			m := m + 1.
			{ cls class. classInstVars keys }  print ]].
	'======' print.
	
	{ n. m}  print! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:50:30' prior: 16966301!
  saveNumberedRelease
	"Save the image/changes using the next release version number."
	"
	Smalltalk saveNumberedRelease
	"
	| versionMajor versionMinor previousValue |
	versionMajor := 6.
	versionMinor := 2.
	SystemVersion newVersionMajor: versionMajor versionMinor: versionMinor.
	"While condensing sources, convert all variable assignment to ANSI Smalltalk form, i.e. :="
	previousValue := Preferences at: #fileOutANSIassignment.
	Preferences at: #fileOutANSIassignment put: true.
	self condenseSources: SystemVersion current versionString.
	Preferences at: #fileOutANSIassignment put: previousValue.
	self setDefaultGCParameters.

	(self filenameForUpdatedImage: false) ifNotNil: [ :newName |
		SystemVersion current beNumberedRelease.
		"Try to clear all user state, including all class vars, preferences, etc"
		self saveAndStayAs: newName clearAllClassState: true ].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:50:35' prior: 16966411!
                  setDefaultGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here persist in saved images, so we set them image save for release.
	See #setGCParameters"

	"Desired Eden size: "
	self vmParameterAt: 45 put: `16*1024*1024`.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:50:53' prior: 16966424!
                setGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here don't persist, so we set them on startup.
	See #setDefaultGCParameters"

	"Grow old memory in chunks of: "
	self vmParameterAt: 25 put: `32*1024*1024`.
	"Shrink heap when unused memory is at least: "
	self vmParameterAt: 24 put: `64*1024*1024`.

	self isSpur
		ifTrue: [
			"Note: (jmv, 9/2021) It seems modern Spur VMs ignore parameter 6. This all seems to be bogus."
			| proportion edenSize survivorSize averageObjectSize numObjects |
			proportion := 0.9. "tenure when 90% of pastSpace is full"
			edenSize := self vmParameterAt: 44.
			survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"
			averageObjectSize := 8 * self wordSize. "a good approximation"
			numObjects := (proportion * survivorSize / averageObjectSize) rounded.
			self vmParameterAt: 6 put: numObjects.  "tenure when more than this many objects survive the GC"
			"/Note: (jmv, 9/2021)"
			
			"Do a full GC when used memory grows by this factor. Fails on non-Spur VMs.
			Default is 0.333.
			2.0 means gull GC when heap size triples."
			self vmParameterAt: 55 put: 2.0.
			]
		ifFalse: [
			self vmParameterAt: 5 put: 4000.  "do an incremental GC after this many allocations"
			self vmParameterAt: 6 put: 2000.  "tenure when more than this many objects survive the GC"
			].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:51:46' prior: 16966496!
          snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
	"This is the main method for image save and / or quit.
	See senders."
	"WARNING: Current process will be killed. UI Process will be restarted"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic
	checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
	| activeProc |
	activeProc := Processor activeProcess.
[
	| isARealStartup guiRootObject guiRootObjectClass |
	save not & quit
		ifTrue: [ (SourceFiles at: 2) ifNotNil: [ :changes |
				ChangesInitialFileSize ifNotNil: [ changes truncate: ChangesInitialFileSize ]]]
		ifFalse: [ self logSnapshot: save andQuit: quit ].
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each |
			each isInWorld ifTrue: [ each delete.]].
		UISupervisor ui tearDownDesktop.
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	"Stuff needed to relaunch UI on startup"
	guiRootObjectClass := UISupervisor ui class.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	guiRootObject := clearAllStateFlag ifFalse: [ UISupervisor ui ].

	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [ activeProc terminate ].
	guiRootObject ifNotNil: [ guiRootObject releaseCachedState ].
	clearAllStateFlag ifTrue: [
		Processor processesDo: [ :p |
			(p name = 'Formerly: Morphic UI') ifTrue: [ p terminate ]]].
	MorphicCanvas allSubInstancesDo: [ :c |
		(c ownerProcess notNil and: [c ownerProcess isTerminated]) ifTrue: [
			c releaseEngine			]].

	"Clean Globals"
	self at: #Sensor put: nil.
	self closeSourceFiles.
	self at: #SourceFiles put: nil.
	self allClassesDo: [ :cls |
		cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [
		self allClassesDo: [ :cls |
			cls releaseClassState ]].
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [
		Transcript clear.
		"Enable this call to actually see the image clean report."
		false ifTrue: [self printStuffToCleanOnImageSave]].
	"Do image save & quit as apropriate"
	(Cursor cursorAt: #writeCursor) activateCursor.
	save
		ifTrue: [
			"The snapshot primitive answers false if it was just called to do the snapshot.
			But image startup is resumed by returning (again) from the primitive, but this time answering true."
			isARealStartup := embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup := false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].

	"If starting from absolute scratch, this would be a good time to recreate Global names"
	self at: #Sensor put: nil.
	self at: #SourceFiles put: (Array new: 2).
	self logStartupDebugAid: 'To #openSourceFiles'.
	self openSourceFiles.
	"Here, startup begins!! (isARealStartup might be nil)"
	self logStartupDebugAid: 'To #initClassCachedState'.
	self allClassesDo: [ :cls | cls initClassCachedState ].
	self logStartupDebugAid: 'To #doStartUp:'.
	self doStartUp: isARealStartup == true.
	self logStartupDebugAid: 'To #spawnNewMorphicProcessFor: ', guiRootObject printString.
	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject := guiRootObjectClass newWorld ]).
	self logStartupDebugAid: 'To #restoreLostChangesIfNecessary'.
	self restoreLostChangesIfNecessary.
	clearAllStateFlag ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #recreateDefaultDesktop'.
			guiRootObject recreateDefaultDesktop; restoreDisplay ]]
	ifFalse: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #restoreDisplay'.
			guiRootObject restoreDisplay ]].
	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
			self readAndApplyUserPrefs.
			self logStartupDebugAid: 'To #processCommandLineArguments'.
			self processCommandLineArguments.
			self logStartupDebugAid: 'To #launchApp'.
			AppLauncher launchApp ]].
	"Now it's time to raise an error"
	isARealStartup ifNil: [ self logStartupError: 'Failed to write image file (disk full?)' ]
]
	forkAt: Processor timingPriority - 1
	named: 'Startup process'.! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/17/2024 20:39:42' prior: 16966745!
                         assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile := SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	(Preferences at: #autoNumberUserChanges) ifTrue: [
		oldUserChanges := DirectoryEntry userChangesDirectory // self userChangesFileName.
		oldUserChanges exists ifTrue: [
			directory := oldUserChanges parent.
			oldUserChangesName := directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	DirectoryEntry userChangesDirectory // self userChangesFileName appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine.
		stream flush ].
	StartupStamp := nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/17/2024 20:44:40' prior: 16966975!
           logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString := aStringOrText asPlainString.
	aString firstNonSeparator = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile := SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			self forceChangesToDisk ]].
	Utilities logsUserChanges ifTrue: [
		DirectoryEntry userChangesDirectory // self userChangesFileName appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString.
			stream flush ]]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/17/2024 20:45:58' prior: 16967037!
     openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems.
	Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes entry msg lastQuitLogPosition snapshotChunk entryPathName |

	"Do not open source files if internalized (i.e. notNil)"
	sources := SourceFiles at: 1.
	sources ifNil: [
		entry := self defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry := self alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources := [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preferences at: #warnIfNoSourcesFile ])
		ifTrue: [
				msg := 'Cuis cannot locate the sources file named ' , entry pathName, '.', String newLineString,
					'Please check that the file is properly named and is in the same directory as this image.'.
			self logStartupError: msg.
		].

	"Do not open source files if internalized (i.e. notNil)"
	changes := SourceFiles at: 2.
	changes ifNil: [
		entry := self defaultChangesName asFileEntry.
		entryPathName := entry pathName.
		"Read the last snapshot chunk. Validate that the .changes file is appropriate for this image."
		entry exists
			ifTrue: [
				lastQuitLogPosition := self lastQuitLogPosition.
				lastQuitLogPosition > 0 ifTrue: [
					entry readStreamDo: [ :changesFile |
						changesFile position: lastQuitLogPosition.
						snapshotChunk := changesFile nextChunk ].
					((snapshotChunk beginsWith: self tagHeader) and: [
						snapshotChunk includesSubString: 'priorSource: ']) ifFalse: [
							(Preferences at: #warnIfNoChangesFile) ifTrue: [
								self logStartupError:
									'Incorrect changes file: ', entryPathName, String newLineString,
									'Missing code will be decompiled', String newLineString,
									'New source code will not be saved' ].
							entry := nil ]]]
			ifFalse: [
				(Preferences at: #warnIfNoChangesFile) ifTrue: [
					self logStartupError:
						'Could not find changes file: ', entryPathName, String newLineString,
						'Missing code will be decompiled', String newLineString,
						'New source code will not be saved' ].
				entry := nil ].
		entry ifNotNil: [
			changes := [ entry appendStream ]
				on: FileWriteError
				do: [
					self logStartupError:
						'Could not write to changes file: ', entryPathName, String newLineString,
						'Changes file will not be used.', String newLineString,
						'Missing code will be decompiled', String newLineString,
						'New source code will not be saved'.
					nil ]]].
	ChangesInitialFileSize := changes ifNotNil: [ changes position ].

	SourceFiles := Array with: sources with: changes.! !
!SystemDictionary methodsFor: 'special objects' stamp: 'HAW 1/17/2024 20:42:32' prior: 16967165!
                    compactClassesArray  "Smalltalk compactClassesArray"
	"Return the array of 31 classes whose instances may be
	represented compactly"
	^ self specialObjectsArray at: 29! !
!SystemDictionary methodsFor: 'ui' stamp: 'HAW 1/17/2024 20:39:47' prior: 16967468!
 beep
	"
	Smalltalk beep
	"
	(Preferences at: #soundsEnabled) ifTrue: [
		self
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:40:49' prior: 16967810!
                         browseClassCommentsWithString: aString
	"Smalltalk browseClassCommentsWithString: 'my instances' "
	"Launch a message list browser on all class comments containing aString as a substring."
	| caseSensitive suffix list |
	suffix := (caseSensitive := Sensor shiftPressed)
		ifTrue: [ ' (case-sensitive)' ]
		ifFalse: [ ' (use shift for case-sensitive)' ].
	list := Set new.
	self allClassesDo: [ :class |
		(class organization classComment
			findString: aString
			startingAt: 1
			caseSensitive: caseSensitive) > 0 ifTrue: [
			list add: (MethodReference class: class selector: #Comment) ]].
	^ self
		browseMessageList: list
		name: 'Class comments containing ', aString printString, suffix
		autoHighlight: aString
		allOccurrences: true.! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:40:57' prior: 16967836!
                              browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix := caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList := OrderedCollection new.
	self allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList notEmpty
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:13' prior: 16967860!
                  browseEqSmallConstant

    "Dan Ingalls' search for arithmetic use of ==
Answer whether the receiver contains the pattern <expression> == <constant>,
where constant is -1, 0, 1, or 2...
	Smalltalk browseEqSmallConstant
"

	self browseAllSelect: [:m | m scanForEqSmallConstant]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:18' prior: 16967893!
              browseLikelyUnneededRedefinitions

	"
	Spot unneeded method redefinitions: methods that are equal to what would be inherited if they weren't there
	Smalltalk browseLikelyUnneededRedefinitions
	Be careful with class side #initialize methods that set up instance class variables
	In general, class side #initialize methods can't be removed unless empty.
	"

	self browseAllSelect: [ :cm |
		(cm methodClass superclass ifNotNil: [ :sup | sup lookupSelector: cm selector]) = cm ]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:26' prior: 16968046!
       browseObsoleteReferences   "Smalltalk browseObsoleteReferences"
	| references |
	references := OrderedCollection new.
	(LookupKey allSubInstances select:
		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:
		['AnOb*' match: x value class name]]) 
		do: [:x | references addAll: (self allCallsOn: x)].
	self 
		browseMessageList: references 
		name: 'References to Obsolete Classes'! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:53' prior: 16968062!
           browseViewReferencesFromNonViews
	"
	Smalltalk browseViewReferencesFromNonViews
	"
	| aLiteral aCollection |

	aCollection := OrderedCollection new.

	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)"
"	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"
	PluggableMorph withAllSubclassesDo: [ :view |
"	MenuMorph withAllSubclassesDo: [ :view |"
		
		aLiteral := view name.
		
		"tweak to linclude refs to SysWindow subhierarchy or not"
		(view includesBehavior: SystemWindow) & false ifFalse: [
			self allBehaviorsDo: [ :class |
				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [
					class addMethodsTo: aCollection thatReferenceTo: aLiteral special: false byte: nil ]]]].
	
	self
		browseMessageList: aCollection asSet
		name: 'References to Views from non-Views'.! !
!SystemDictionary methodsFor: 'image format' stamp: 'HAW 1/17/2024 20:43:58' prior: 16969066!
                              imageFormatVersion
	"Answer an integer identifying the type of image in memory. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required). This invokes an optional primitive
	that may not be available on all virtual machines.
	Answer nil if unknown."

	"
	Smalltalk imageFormatVersion
	"

	<primitive: 'primitiveImageFormatVersion'>

	"Cog provides a VM parameter"
	^self vmParameterAt: 41! !
!SystemDictionary methodsFor: 'image format' stamp: 'HAW 1/17/2024 20:44:08' prior: 16969108!
         imageFormatVersionFromFileAsIs
	"Answer an integer identifying the type of image on file. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required). If the image file has a different
	endianness than the VM, the format version will appear byte-swapped."
	"
	Smalltalk imageFormatVersionFromFileAsIs
	"
	^ self imageName asFileEntry readStreamDo: [ :stream |
		(stream binary; next: 4)
			uint32At: 1
			bigEndian: self isBigEndian ]! !
!SystemDictionary methodsFor: 'startup' stamp: 'HAW 1/17/2024 20:47:13' prior: 16969414!
   processCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: aBoolean
	"
	A possible example (duplicated single quotes: '' should be double quotes, but not allowed in a Smalltalk comment):
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -h
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -v
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -q
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -e -d''0 zope''
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -r YAXO -rJSON -d ''Smalltalk startUpScriptArguments print'' xx YY 3492 -d'' 'here comes another' print'' -d ''{'The answer is: '. Smalltalk startUpScriptArguments first asNumber + Smalltalk startUpScriptArguments second asNumber} print'' 3 4 -- -d'' 'not this' print' ''

Squeak.exe Cuis4.2-2211x.image -r RequiredFeature1 -r RequiredFeature2 -d ''Transcript show: 'popo1'; newLine'' -d ''Transcript show: 'popo2'; newLine'' -s smalltalkScript.st param1ToScript param2ToSCript ''parametro 3 to script ->>>--// 3''
	"
	"You can use 'Smalltalk startUpScriptArguments' inside the startUp script:"


	| exceptionToIgnoreOrNil entry |
	exceptionToIgnoreOrNil := aBoolean ifFalse: [UnhandledError] ifTrue: [nil].
	optionString caseOf: {
		[ '-h' ] -> [
			self displayCommandLineUsageOn: StdIOWriteStream stdout.
			self quit ].

		[ '-v' ] -> [ 
			self displaySystemInformationStringOn: StdIOWriteStream stdout.
			self quit ].

		[ '-q' ] -> [ self quit ].

		[ '-r' ] -> [		"as in 		-rRequiredFeature2        or         -r RequiredFeature2"
			{ 'Feature require: '. optionArgument } print.
			[ Feature require: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		[ '-d' ] -> [		"as in 		-d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine''        (duplicated singleQuotes should read doubleQuote)"
			{ 'Compiler evaluate: '. optionArgument } print.
			[ Compiler evaluate: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		['-l' ] -> ["file in the file"
			{ 'File in: '. optionArgument} print.
			[(CodeFile newFromFile: optionArgument asFileEntry) fileIn] on: exceptionToIgnoreOrNil do: [:ex | ex return]].

		[ '-s' ] -> [		"as in 		-s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parameter to script script ->>>--// 3'' 			(duplicated singleQuotes should read doubleQuote)"
			{ 'Compiler evaluate contents of file named: '. optionArgument. ' arguments: '. self startUpScriptArguments } print.
			entry := optionArgument asFileEntry.
			entry exists ifTrue: [
				entry readStreamDo: [ :stream |
					[ Compiler evaluate: stream contentsOfEntireFile ] on: exceptionToIgnoreOrNil do: [:ex | ex return]]]].

		[ '-ud' ] -> [ DirectoryEntry setUserBaseDirectory: optionArgument asDirectoryEntry ].

		[ '-udIsBase' ] -> [ DirectoryEntry setUserBaseDirectoryAsCuisBase ].
	}
	otherwise: [].! !
!SystemDictionary methodsFor: 'startup' stamp: 'HAW 1/17/2024 20:50:59' prior: 16969521!
                setStartupStamp

	| dateAndTime |
	dateAndTime := DateAndTime now.
	StartupStamp := String streamContents: [ :stream |
		stream nextPutAll: '----STARTUP---- ('.
		dateAndTime date printOn: stream.
		stream space.
		dateAndTime time print24: true showSeconds: true on: stream.
		stream
			nextPutAll: ') as ';
			nextPutAll: self imageName ] 
! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'HAW 1/17/2024 20:43:13' prior: 16969696!
       doMixedArithmetic
	"If true, then primitives can handle the conversions:
	SmallInteger arithmeticOp: Float (Small or Boxed)
	SmallInteger compareOp: Float (Small or Boxed)
	Else, the primitive fail in case of mixed arithmetic, and conversion will be performed at image side.
	See doMixedArithmetic:
	
	Note:
		OpenSmalltalk VMs after March, 2019 can set the option and will honor it. The comparison operation behaves as if the Float was converted #asTrueFraction. This means that some rather big SmallIntegers in 64 bit systems, that can not be represented exactly as a Float will not be equal to any Float. Squeak adopted this critera. Cuis follows the more conventional, Smalltalk-80 tradition to always convert to Float if any operand is Float. Therefore Cuis needs to do 'Smalltalk doMixedArithmetic: false'.
		Previous VMs can not set the option, and will answer true when queried. But these VMs did the conversion to Float, and the requested operation in Floats. So, with these VMs, Cuis will also have the desired behavior."

	^ ((self vmParameterAt: 48) allMask: 64) not! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6165-Reference_self_andNot_Smalltalk_FromSystemDictionary-HernanWilkinson-2024Jan17-20h31m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6165] on 20 January 2024 at 12:19:48 pm'!
!ContextPart methodsFor: 'instruction decoding' stamp: 'jar 1/18/2024 17:52:20' prior: 50332490!
                     return: value from: aSender 
	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"

	| newTop |
	newTop := aSender sender.
	(aSender isDead or: [newTop isNil or: [newTop isDead]]) ifTrue: [
		^ self pc: nil; send: #cannotReturn: to: self with: {value} super: false].
	(self findNextUnwindContextUpTo: newTop) ifNotNil: [
		^ self send: #aboutToReturn:through: to: self with: {value. nil} super: false].
	self releaseTo: newTop.
	^ newTop push: value! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6166-return_from_enhancement-JaromirMatas-2024Jan20-12h18m-jar.001.cs.st----!

'From Cuis6.3 [latest update: #6165] on 22 January 2024 at 9:02:00 pm'!
!Dictionary class methodsFor: 'error descriptions' stamp: 'HAW 1/22/2024 21:00:58'!
                          keyNotFoundErrorDescriptionFor: key

	^ String streamContents: [ :strm |
			strm nextPutAll: 	'key: '.
			key printOn: strm.
			strm nextPutAll: ' not found' ]! !
!Dictionary methodsFor: 'private' stamp: 'HAW 1/22/2024 20:58:02' prior: 16848567!
          errorKeyNotFound: key

	self error: (self class keyNotFoundErrorDescriptionFor: key)! !

Dictionary removeSelector: #keyNotFoundErrorDescriptionFor:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6167-keyNotFoundErrorDescriptionAsClassMessage-HernanWilkinson-2024Jan20-13h01m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6167] on 23 January 2024 at 12:43:32 pm'!

TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethod category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:39:06'!
TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethodApplier category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:39:06'!
TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!ParseNode methodsFor: 'testing' stamp: 'RNG 12/31/2017 19:10:30'!
                   sendsMessageToSelf: aSelector

	^ false! !
!BlockNode methodsFor: 'testing' stamp: 'RNG 12/31/2017 19:11:55' overrides: 50334517!
                              sendsMessageToSelf: aSelector

	^ self statements anySatisfy: [ :statementNode | statementNode sendsMessageToSelf: aSelector ]! !
!BlockNode class methodsFor: 'instance creation' stamp: 'RNG 1/19/2018 21:06:55'!
            empty

	^ self statements: #() returns: false! !
!MethodNode methodsFor: 'testing' stamp: 'MEGL 7/30/2023 20:56:02' overrides: 50334517!
                       sendsMessageToSelf: aSelector

	^ self block sendsMessageToSelf: aSelector! !
!SelectorNode methodsFor: 'testing' stamp: 'HAW 3/14/2019 11:14:25'!
             isNamed: aSelectorName

	^ self key = aSelectorName! !
!VariableNode class methodsFor: 'instance creation' stamp: 'RNG 1/19/2018 20:50:48'!
                    named: aString 

	^ self new name: aString; yourself! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 3/14/2019 11:13:47' overrides: 50334517!
                sendsMessageToSelf: aSelector

	^ self receiver referencesSelf and: [ self selector isNamed: aSelector ]! !
!ReturnNode methodsFor: 'testing' stamp: 'MEGL 7/30/2023 20:56:22' overrides: 50334517!
                            sendsMessageToSelf: aSelector

	^expr sendsMessageToSelf: aSelector! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:13:45'!
      methodCategory: aMethod

	^aMethod methodClass organization categoryOfElement: aMethod selector! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:15:51'!
          removeMethod: aMethod

	aMethod methodClass removeSelector: aMethod selector.
 ! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 14:09:29'!
                            compileMethodInSuperclass: aMethod

	aMethod methodClass superclass
		compile: aMethod sourceCode
		classified: (self methodCategory: aMethod).! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'HAW 1/23/2024 12:40:28'!
                             pushUpMethods

	methods do: [ :methodToPushUp | 
		self 
			compileMethodInSuperclass: methodToPushUp;
			removeMethod: methodToPushUp ]! !
!PushUpMethod methodsFor: 'initialization' stamp: 'MEGL 8/21/2023 15:43:39' overrides: 16988943!
                   initializeFor: aMethods

	methods := aMethods.
	subclassesToRemoveMethodFrom := #().! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'MEGL 8/21/2023 15:44:19'!
                  for: aMethodToPushUp additionallyRemovingFrom: subclassesToRemoveMethodFrom pushingUp: dependantMethods
	
	dependantMethods add: aMethodToPushUp.

	self assertIsValidToPushUp: dependantMethods.
	self assertIsValidToRemove: subclassesToRemoveMethodFrom.
	
	^self new initializeFor: dependantMethods additionallyRemovingFrom: subclassesToRemoveMethodFrom.! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'MEGL 8/15/2023 23:52:22'!
        assert: aMethodToRemove isValidToRemoveFrom: subclassesToRemoveMethodFrom

	self assert: subclassesToRemoveMethodFrom areSiblingsOf: aMethodToRemove methodClass.
	self assert: aMethodToRemove isImplementedIn: subclassesToRemoveMethodFrom.
	self assert: aMethodToRemove isEquivalentlyImplementedIn: subclassesToRemoveMethodFrom.

! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'MEGL 8/21/2023 15:23:05'!
assertIsValidToPushUp: methods

	| instanceVariablesToPushUp methodsImplementedInSuperClass |
	
	instanceVariablesToPushUp := self selectInstanceVariablesToPushUpFrom: methods.
	
	instanceVariablesToPushUp ifNotEmpty: [ self refactoringWarning: (self accessingInstanceVariableWarningMessage: instanceVariablesToPushUp)].

	methodsImplementedInSuperClass := (methods 	select: [ 
		:method |  		self checkIfMethodIsImplementedInSuperClass: method. 
		]) collect: [:method | method selector].
		
	methodsImplementedInSuperClass ifNotEmpty: [ self refactoringWarning: (self methodWithDifferentImplementationInSuperClass: methodsImplementedInSuperClass)].
	
	
! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'MEGL 8/15/2023 23:52:58'!
                          assertIsValidToRemove: subclassesToRemoveMethodFrom

	subclassesToRemoveMethodFrom associationsDo: [:assoc | 
		self assert: assoc key isValidToRemoveFrom: assoc value].

! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'MEGL 8/16/2023 00:02:00'!
    methodWithDifferentImplementationInSuperClass: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The method(s): ';
			nextPutAll: methods asCommaStringAnd;
			nextPutAll: ' have an implementation not equivalent in the superclass and will be pushed up' ]! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'MEGL 8/21/2023 15:21:28'!
                  selectAccessedInstanceVariablesThatCanBePushedUpFrom: aMethodToPushUp

	| accessedInstanceVariables |

	accessedInstanceVariables := self selectAccessedInstanceVariables: aMethodToPushUp.

	accessedInstanceVariables do: [ :variable | PushUpInstanceVariable assertCanMove: variable from: aMethodToPushUp methodClass ].

	^accessedInstanceVariables! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'MEGL 8/21/2023 15:54:51'!
           selectInstanceVariablesToPushUpFrom: methods

	^ (methods collect: 
				[:method | self selectAccessedInstanceVariablesThatCanBePushedUpFrom: method ]
	    ) asArray flatten asSet 
! !
!PushUpMethod class methodsFor: 'implemented superclass' stamp: 'MEGL 8/14/2023 00:04:24'!
            checkIfMethodIsImplementedInSuperClass: aMethodToTransfer

		aMethodToTransfer methodClass superclass
		compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superClassMethod | ^(self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superClassMethod) not]
		ifAbsent: [^false]! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'MEGL 8/20/2023 00:36:04'!
                              assert: aMethod implementsEquivalentMethodIn: aSubclass

	^ aSubclass ~= aMethod methodClass and: [
		aSubclass
			compiledMethodAt: aMethod selector
			ifPresent: [ :subclassMethod | subclassMethod equivalentTo: aMethod ]
			ifAbsent: [ false ]]! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'MEGL 8/21/2023 16:20:37'!
               selectSiblingsWithEquivalentMethod: methods

	| withEquivalentMethod |
	
	withEquivalentMethod := Dictionary new.
	
	methods do: [:method | withEquivalentMethod add: method -> 
		(method methodClass superclass subclasses select:
			[ :aSubclass | self assert: method implementsEquivalentMethodIn: aSubclass ]
		)
	].

	^withEquivalentMethod reject: [:assoc | assoc value isEmpty ].
! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'MEGL 8/20/2023 20:52:27'!
        selectAllMessageSendsToSelfNotImplementedInSuperClassFrom: aMethodToTransfer

	| selectors |

	selectors := Set new.
	self selectDependantSelectorsFrom: aMethodToTransfer using: selectors.
	
	selectors remove: aMethodToTransfer selector.
	
	^selectors! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'MEGL 8/21/2023 16:21:04'!
           selectDependantSelectorsFrom: aMethod using: visitedSelectors

	| selectors |

	visitedSelectors add: aMethod selector.

	selectors := self selectorsSentToSelf: aMethod.

	(selectors difference: visitedSelectors) do: [:m | self selectDependantSelectorsFrom: (aMethod methodClass >> m) using: visitedSelectors]! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'MEGL 8/20/2023 18:41:44'!
                 selectorsSentToSelf: aMethod

	^ aMethod methodClass selectors select: [ :method | aMethod methodNode sendsMessageToSelf: method]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 16:00:10'!
                     askMethodsToPushUpFrom: aDependantMethods

	| answer |

	answer := PopUpMenu 
		withCaption: (self withDependantMethodsMessage: aDependantMethods) 
		chooseFrom: #('Only PushUp this method' 'PushUp this method and all the dependant methods').

	answer = 1 ifTrue: [ ^dependantMethods := Set new ].
	answer = 2 ifTrue: [ ^dependantMethods := aDependantMethods ].
	self endRequest ! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 15:59:38'!
                           selectDependantMethods
	|methods|

	methods := ((self refactoringClass selectAllMessageSendsToSelfNotImplementedInSuperClassFrom: methodToTransfer )
	                   collect:  [:method | methodToTransfer methodClass >> method ]) asSet.

	methods ifNotEmpty: [ self askMethodsToPushUpFrom: methods ].! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 13:57:32'!
        selectSiblingsWithEquivalentMethod
	| methods withEquivalentMethod |
	
	methods := Set withAll: dependantMethods.
	methods add: methodToTransfer.
	
	withEquivalentMethod := self refactoringClass selectSiblingsWithEquivalentMethod: methods.

	withEquivalentMethod ifNotEmpty: [ self askMethodsToRemoveFrom: withEquivalentMethod ].
! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/19/2023 16:39:15'!
            withDependantMethodsMessage: aDependantMethods

	^ String streamContents: [ :stream |
		stream
			nextPutAll: methodToTransfer selector;
			nextPutAll: ' has the following dependant method(s): ';
			nextPutAll: (aDependantMethods collect: [:method | method selector ] ) asCommaStringAnd;
			nextPutAll: '. How do you want to proceed?' ]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/20/2023 00:39:08'!
      withEquivalentMethodsMessage: withEquivalentMethod

	^ String streamContents: [ :stream |		
		withEquivalentMethod associationsDo: [:assoc |

			stream
				nextPutAll: assoc key selector;
				nextPutAll: ' has equivalent methods declared in ';
				nextPutAll: assoc value asCommaStringAnd;
				nextPutAll: ', ' 
		].

		stream
			nextPutAll: 'how do you want to proceed?' ].! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:13:54' prior: 16988955!
   methodCategory

	^self methodCategory: method.! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:16:07' prior: 16988966!
           removeMethod

	self removeMethod: method.
 ! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 15:46:55' prior: 16934012 overrides: 16988961!
                            moveMethod

	self 
		pushUpAccessedVariables;
		pushUpMethods.! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 15:56:46' prior: 16934025!
                             pushUpAccessedVariables

	|instanceVariablesToPushUp methodClass|
	
	instanceVariablesToPushUp := self class selectInstanceVariablesToPushUpFrom: methods.
	methodClass := methods anyOne methodClass.

	instanceVariablesToPushUp do: [:var | (PushUpInstanceVariable named: var from: methodClass) apply ]! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 15:46:14' prior: 16934036 overrides: 50334837!
                           removeMethod

	subclassesToRemoveMethodFrom associationsDo:
		[:assoc | assoc value do:
			[:class | class removeSelector: assoc key selector ]
		].! !
!PushUpMethod methodsFor: 'initialization' stamp: 'MEGL 8/21/2023 15:43:06' prior: 16934043!
           initializeFor: aMethods additionallyRemovingFrom: aSubclassesToRemoveMethodFrom

	methods := aMethods.
	subclassesToRemoveMethodFrom := aSubclassesToRemoveMethodFrom.! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'MEGL 8/19/2023 17:11:17' prior: 16934057!
                for: aMethodToPushUp

	^self for: aMethodToPushUp additionallyRemovingFrom: #() pushingUp: Set new.! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2023 17:19:38' prior: 16934083!
                       assert: subclassesToRemoveMethodFrom areSiblingsOf: aClassToPushUpMethodFrom

	| noSiblings |
	
	noSiblings := subclassesToRemoveMethodFrom reject: [ :aSubclass |
		aSubclass superclass = aClassToPushUpMethodFrom superclass ].
	
	noSiblings ifNotEmpty: [ self signalNoSiblings: noSiblings ].! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2023 17:29:39' prior: 16934095!
                       assert: aMethodToPushUp isEquivalentlyImplementedIn: subclassesToRemoveMethodFrom
	
	| notEquivalent |
	
	notEquivalent := subclassesToRemoveMethodFrom reject: [ :aSubclass |
		aSubclass >> aMethodToPushUp selector equivalentTo: aMethodToPushUp ].
	
	notEquivalent ifNotEmpty: [ self signalNotEquivalentMethodsFor: notEquivalent ].! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2023 17:10:49' prior: 16934109!
               assert: aMethodToPushUp isImplementedIn: subclassesToRemoveMethodFrom
	
	| subclassesNotImplementing |
	
	subclassesNotImplementing := subclassesToRemoveMethodFrom reject: [ :aSubclass | 
		aSubclass includesSelector: aMethodToPushUp selector ].
	
	subclassesNotImplementing ifNotEmpty: [
		self signalMethodCannotBeRemovedMethodFrom: subclassesNotImplementing ]
	! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'MEGL 8/21/2023 15:56:56' prior: 16934123!
                   accessingInstanceVariableWarningMessage: accessedInstanceVariables

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The instance variable(s) ';
			nextPutAll: accessedInstanceVariables asCommaStringAnd;
			nextPutAll: ' will be pushed up' ]! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 11/12/2019 11:38:58' prior: 16934160!
                              errorMessageForMethodCannotAccessInstanceVariable
	
	^ 'Can not push up a method that access an instance variable'! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:14:45' prior: 16934167!
            errorMessageForMethodCannotBeRemovedMethodFrom: subclassesNotImplementing

	^String streamContents: [ :stream |
		stream
			nextPutAll: 'Can not remove method because is not implemented in:';
			newLine.

		subclassesNotImplementing asCommaSeparated: [ :aClass | stream print: aClass ] on: stream ].
		! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:24:10' prior: 16934180!
                errorMessageForNoSiblings: noSiblings

	^String streamContents: [ :stream |
		stream
			nextPutAll: 'Can not remove method from classes that are not siblings:';
			newLine.

		noSiblings asCommaSeparated: [ :aClass | stream print: aClass ] on: stream ].
			! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:29:24' prior: 16934191!
                             errorMessageForNotEquivalentMethods: notEquivalent

	^String streamContents: [ :stream |
		stream
			nextPutAll: 'Can not remove not equivalent methods from';
			newLine.

		notEquivalent asCommaSeparated: [ :aClass | stream print: aClass ] on: stream ].
			! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'MSC 10/19/2019 23:29:03' prior: 16934202!
                           signalMethodCannotAccessInstanceVariable
	
	self refactoringError: self errorMessageForMethodCannotAccessInstanceVariable! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:11:17' prior: 16934209!
     signalMethodCannotBeRemovedMethodFrom: subclassesNotImplementing
	
	self refactoringError: (self errorMessageForMethodCannotBeRemovedMethodFrom: subclassesNotImplementing)! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:24:10' prior: 16934217!
                   signalNoSiblings: noSiblings 

	self refactoringError: (self errorMessageForNoSiblings: noSiblings)! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:29:39' prior: 16934223!
                           signalNotEquivalentMethodsFor: notEquivalent

	self refactoringError: (self errorMessageForNotEquivalentMethods: notEquivalent)! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'MEGL 7/12/2023 16:49:35' prior: 16934134!
                      selectAccessedInstanceVariables: aMethodToPushUp

	^aMethodToPushUp methodClass instVarNames
		select: [ :instVarName |  aMethodToPushUp accessesInstanceVariable: instVarName ]! !
!PushUpMethodApplier methodsFor: 'refactoring - creation' stamp: 'MEGL 8/21/2023 16:00:33' prior: 16934239 overrides: 16989036!
            createRefactoring

	^self refactoringClass for: methodToTransfer additionallyRemovingFrom: subclassesToRemoveMethodsFrom pushingUp: dependantMethods! !
!PushUpMethodApplier methodsFor: 'refactoring - creation' stamp: 'MSC 10/14/2019 19:36:48' prior: 16934246 overrides: 16989042!
        refactoringClass

	^PushUpMethod! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 16:00:22' prior: 16934251!
      askMethodsToRemoveFrom: withEquivalentMethod

	| answer |
	
	answer := PopUpMenu 
		withCaption: (self withEquivalentMethodsMessage: withEquivalentMethod) 
		chooseFrom: #('Only PushUp' 'PushUp and delete all equivalent methods').

	answer = 1 ifTrue: [ ^subclassesToRemoveMethodsFrom := Dictionary new ].
	answer = 2 ifTrue: [ ^subclassesToRemoveMethodsFrom := withEquivalentMethod ].
	self endRequest ! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/14/2023 22:49:08' prior: 16934279 overrides: 16989047!
                               requestRefactoringParameters

	self selectDependantMethods;
		selectSiblingsWithEquivalentMethod
		! !
!PushUpMethodApplier methodsFor: 'initialization' stamp: 'MEGL 7/30/2023 21:10:14' prior: 16934306 overrides: 16932297!
 initialize 

	subclassesToRemoveMethodsFrom := #().
	dependantMethods := #()! !

TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethod category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:39:06'!
TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethodApplier category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:39:06'!
TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6167] on 23 January 2024 at 3:42:59 pm'!
!PushUpMethod class methodsFor: 'warnings' stamp: 'HAW 1/23/2024 15:00:48'!
    methodWithDifferentImplementationInSuperclass: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The method(s): ';
			nextPutAll: methods asCommaStringAnd;
			nextPutAll: ' have an implementation not equivalent in the superclass and will be pushed up' ]! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'HAW 1/23/2024 15:00:54'!
                             warnIfDifferentImplementationInSuperclass: methods

	| methodsImplementedInSuperclass |
	
	methodsImplementedInSuperclass := methods 	
		select: [ :method |  		self checkIfMethodIsImplementedInSuperclass: method ]
		thenCollect: [ :method | method selector].
		
	methodsImplementedInSuperclass ifNotEmpty: [ 
		self refactoringWarning: (self methodWithDifferentImplementationInSuperclass: methodsImplementedInSuperclass)].
	
	
! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'HAW 1/23/2024 14:58:36'!
     warnIfReferencesInstanceVariables: methods

	| instanceVariablesToPushUp |
	
	instanceVariablesToPushUp := self selectInstanceVariablesToPushUpFrom: methods.
	
	instanceVariablesToPushUp ifNotEmpty: [ 
		self refactoringWarning: (self accessingInstanceVariableWarningMessage: instanceVariablesToPushUp)].

! !
!PushUpMethod class methodsFor: 'implemented superclass' stamp: 'HAW 1/23/2024 15:11:42'!
                checkIfMethodIsImplementedInSuperclass: aMethodToTransfer

	^aMethodToTransfer methodClass superclass compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superClassMethod | (self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superClassMethod) not]
		ifAbsent: [ false ]! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'HAW 1/23/2024 15:21:15'!
 equivalentMethodsOfSiblingsOfAll: methods

	| allEquivalentMethods |
	
	allEquivalentMethods := Dictionary new.
	
	methods do: [:method | | equivalentMethods |
		equivalentMethods := method methodClass superclass subclasses select: [ :aSubclass | self is: method equivalentIn: aSubclass ].
		equivalentMethods ifNotEmpty: [ allEquivalentMethods at: method put: equivalentMethods ]].

	^allEquivalentMethods ! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'HAW 1/23/2024 15:21:01'!
               is: aMethod equivalentIn: aSubclass

	^ aSubclass ~= aMethod methodClass and: [
		aSubclass
			compiledMethodAt: aMethod selector
			ifPresent: [ :subclassMethod | subclassMethod equivalentTo: aMethod ]
			ifAbsent: [ false ]]! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'HAW 1/23/2024 15:31:30' prior: 50334863 overrides: 50334837!
      removeMethod

	subclassesToRemoveMethodFrom keysAndValuesDo: [ :methodWithSelectorToRemove :classesToRemoveMethodFrom |
		classesToRemoveMethodFrom do: [ :aClassToRemoveMethodFrom | 
			aClassToRemoveMethodFrom removeSelector: methodWithSelectorToRemove selector ]].
	
	! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'HAW 1/23/2024 15:36:00' prior: 50334880!
         for: aMethodToPushUp

	^self for: aMethodToPushUp additionallyRemovingFrom: Dictionary new pushingUp: Set new.! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 1/23/2024 15:01:14' prior: 50334622!
            assertIsValidToPushUp: methods

	self warnIfReferencesInstanceVariables: methods.
	self warnIfDifferentImplementationInSuperclass: methods! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'HAW 1/23/2024 15:10:16' prior: 50334680!
            selectInstanceVariablesToPushUpFrom: methods

	^ (methods collect: [:method | self selectAccessedInstanceVariablesThatCanBePushedUpFrom: method ]) asArray flatten asSet 
! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'HAW 1/23/2024 15:22:52' prior: 50334739!
             selectDependantSelectorsFrom: aMethod using: visitedSelectors

	| selectors |

	visitedSelectors add: aMethod selector.

	selectors := self selectorsSentToSelf: aMethod.

	(selectors difference: visitedSelectors) do: [:selector | 
		self selectDependantSelectorsFrom: aMethod methodClass >> selector using: visitedSelectors]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 15:40:29' prior: 50335058 overrides: 16989047!
               requestRefactoringParameters

	self 
		selectDependantMethods;
		selectSiblingsWithEquivalentMethod
		! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 15:41:47' prior: 50334776!
 selectDependantMethods

	| methods |

	methods := ((self refactoringClass selectAllMessageSendsToSelfNotImplementedInSuperClassFrom: methodToTransfer )
	                   collect: [ :selector | methodToTransfer methodClass >> selector ]) asSet.

	methods ifNotEmpty: [ self askMethodsToPushUpFrom: methods ].! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 15:41:56' prior: 50334789!
                  selectSiblingsWithEquivalentMethod

	| methods withEquivalentMethod |
	
	methods := Set withAll: dependantMethods.
	methods add: methodToTransfer.
	
	withEquivalentMethod := self refactoringClass equivalentMethodsOfSiblingsOfAll: methods.

	withEquivalentMethod ifNotEmpty: [ self askMethodsToRemoveFrom: withEquivalentMethod ].
! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 12:58:14' prior: 50334803!
                              withDependantMethodsMessage: aDependantMethods

	^ String streamContents: [ :stream |
		stream
			nextPutAll: methodToTransfer selector;
			nextPutAll: ' has the following dependant method(s): ';
			newLine;
			nextPutAll: (aDependantMethods collect: [:method | method selector ] ) asCommaStringAnd;
			newLine;
			nextPutAll: 'How do you want to proceed?' ]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 12:54:23' prior: 50334817!
 withEquivalentMethodsMessage: withEquivalentMethod

	^ String streamContents: [ :stream |		
		withEquivalentMethod associationsDo: [:assoc |
			stream
				nextPutAll: assoc key selector;
				nextPutAll: ' has equivalent methods declared in ';
				nextPutAll: assoc value asCommaStringAnd;
				newLine.
		].
		stream nextPutAll: 'How do you want to proceed?' ].! !
!PushUpMethodApplier methodsFor: 'initialization' stamp: 'HAW 1/23/2024 12:48:06' prior: 50335065 overrides: 16932297!
                             initialize 

	subclassesToRemoveMethodsFrom := Dictionary new.
	dependantMethods := Set new.! !

PushUpMethodApplier removeSelector: #withEquivalentMethodMessage:!

!methodRemoval: PushUpMethodApplier #withEquivalentMethodMessage: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
withEquivalentMethodMessage: withEquivalentMethod

	^ String streamContents: [ :stream |
		stream
			nextPutAll: methodToTransfer selector;
			nextPutAll: ' has equivalent methods declared in '.
		withEquivalentMethod asCommaSeparated:  [:aClass| stream print: aClass] on: stream.
		stream
			newLine;
			nextPutAll: 'How do you want to proceed?' ]!

PushUpMethod class removeSelector: #assert:implementsEquivalentMethodIn:!

!methodRemoval: PushUpMethod class #assert:implementsEquivalentMethodIn: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
assert: aMethod implementsEquivalentMethodIn: aSubclass

	^ aSubclass ~= aMethod methodClass and: [
		aSubclass
			compiledMethodAt: aMethod selector
			ifPresent: [ :subclassMethod | subclassMethod equivalentTo: aMethod ]
			ifAbsent: [ false ]]!

PushUpMethod class removeSelector: #selectSiblingsWithEquivalentMethod:!

!methodRemoval: PushUpMethod class #selectSiblingsWithEquivalentMethod: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
selectSiblingsWithEquivalentMethod: methods

	| withEquivalentMethod |
	
	withEquivalentMethod := Dictionary new.
	
	methods do: [:method | withEquivalentMethod add: method -> 
		(method methodClass superclass subclasses select:
			[ :aSubclass | self assert: method implementsEquivalentMethodIn: aSubclass ]
		)
	].

	^withEquivalentMethod reject: [:assoc | assoc value isEmpty ].
!

PushUpMethod class removeSelector: #errorMessageForMethodCannotAccessInstanceVariable!

!methodRemoval: PushUpMethod class #errorMessageForMethodCannotAccessInstanceVariable stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
errorMessageForMethodCannotAccessInstanceVariable
	
	^ 'Can not push up a method that access an instance variable'!

PushUpMethod class removeSelector: #warnIfMethodAccessInstanceVariable:!

!methodRemoval: PushUpMethod class #warnIfMethodAccessInstanceVariable: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
warnIfMethodAccessInstanceVariable: aMethodToPushUp

	| accessedInstanceVariables |

	accessedInstanceVariables := self selectAccessedInstanceVariables: aMethodToPushUp.

	accessedInstanceVariables isEmpty ifTrue: [^self].
	
	accessedInstanceVariables do: [ :variable | PushUpInstanceVariable assertCanMove: variable from: aMethodToPushUp methodClass ].

	self refactoringWarning: (self accessingInstanceVariableWarningMessage: accessedInstanceVariables)!

PushUpMethod class removeSelector: #for:additionallyRemovingFrom:!

!methodRemoval: PushUpMethod class #for:additionallyRemovingFrom: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
for: aMethodToPushUp additionallyRemovingFrom: subclassesToRemoveMethodFrom

	self warnIfMethodAccessInstanceVariable: aMethodToPushUp.
	self assert: subclassesToRemoveMethodFrom areSiblingsOf: aMethodToPushUp methodClass.
	self assert: aMethodToPushUp isImplementedIn: subclassesToRemoveMethodFrom.
	self assert: aMethodToPushUp isEquivalentlyImplementedIn: subclassesToRemoveMethodFrom.
	self warnIfMethodIsImplementedInSuperClass: aMethodToPushUp.

	^self new initializeFor: aMethodToPushUp additionallyRemovingFrom: subclassesToRemoveMethodFrom.!

PushUpMethod class removeSelector: #methodWithDifferentImplementationInSuperClass:!

!methodRemoval: PushUpMethod class #methodWithDifferentImplementationInSuperClass: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
methodWithDifferentImplementationInSuperClass: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The method(s): ';
			nextPutAll: methods asCommaStringAnd;
			nextPutAll: ' have an implementation not equivalent in the superclass and will be pushed up' ]!

PushUpMethod class removeSelector: #signalMethodCannotAccessInstanceVariable!

!methodRemoval: PushUpMethod class #signalMethodCannotAccessInstanceVariable stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
signalMethodCannotAccessInstanceVariable
	
	self refactoringError: self errorMessageForMethodCannotAccessInstanceVariable!

PushUpMethod class removeSelector: #checkIfMethodIsImplementedInSuperClass:!

!methodRemoval: PushUpMethod class #checkIfMethodIsImplementedInSuperClass: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
checkIfMethodIsImplementedInSuperClass: aMethodToTransfer

		aMethodToTransfer methodClass superclass
		compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superClassMethod | ^(self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superClassMethod) not]
		ifAbsent: [^false]!

PushUpMethod removeSelector: #initializeFor:!

!methodRemoval: PushUpMethod #initializeFor: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
initializeFor: aMethods

	methods := aMethods.
	subclassesToRemoveMethodFrom := #().!

PushUpMethod removeSelector: #moveMethodAfterMovingAccessedVariables!

!methodRemoval: PushUpMethod #moveMethodAfterMovingAccessedVariables stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:39:06'!
moveMethodAfterMovingAccessedVariables

	method methodClass superclass
		compile: method sourceCode
		classified: self methodCategory!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6169] on 24 January 2024 at 8:01:30 pm'!
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/24/2024 19:58:35'!
                    logToUserChanges: aString preamble: preambleOrNil

	"This message is used by TDD-Guru, do not remove it without looking at it - Hernan"
	Utilities logsUserChanges ifTrue: [
		DirectoryEntry userChangesDirectory // self userChangesFileName appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString.
			stream flush ]]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/24/2024 19:57:41' prior: 50333968!
                               logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString := aStringOrText asPlainString.
	aString firstNonSeparator = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile := SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			self forceChangesToDisk ]].
	self logToUserChanges: aString preamble: preambleOrNil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6170-SpecificMessageToLogChangeToUserChanges-HernanWilkinson-2024Jan24-19h57m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6163] on 4 January 2024 at 1:05:03 pm'!
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 1/4/2024 13:04:10' prior: 16827682!
          browseVersions
	"Create and schedule a Versions Browser, showing all versions of the 
	currently selected message. Answer the browser or nil."
	| method class |
	model selectedMessageName isNil ifTrue: [
		^ VersionsBrowserWindow
			browseCommentOf: model selectedClass ].
	method := model currentCompiledMethod.
	class := method methodClass.
	^ VersionsBrowserWindow
		browseVersionsOf: method
		class: class
		meta: class isMeta
		category: (class organization categoryOfElement: method selector)
		selector: method selector! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6171-ClassCommentVersionsBrowser-fix-JuanVuletich-2024Jan04-13h04m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6164] on 4 January 2024 at 4:33:20 pm'!
!ClassBuilder methodsFor: 'class format' stamp: 'jmv 1/4/2024 15:17:52'!
               computeFormat: type instSize: newInstSize forSuper: newSuper
	"Compute the new format for making oldClass a subclass of newSuper.
	Return the format or nil if there is any problem."

	^ self computeFormat: type fullInstancesSize: (newInstSize + (newSuper ifNil: [0] ifNotNil: [newSuper instSize]))! !
!ProtoObject methodsFor: 'comparing' stamp: 'jmv 1/4/2024 16:19:39' prior: 16932359!
                              identityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	This method must not be overridden, except by immediate classes such as
	SmallInteger, Character and SmallFloat64.
	Primitive. Fails if the receiver is a SmallInteger. Essential.
	See Object documentation whatIsAPrimitive.

	Do not override."

	<primitive: 75>
	self primitiveFailed! !
!Behavior methodsFor: 'accessing' stamp: 'jmv 1/4/2024 15:32:35' prior: 16786925!
                       typeOfClass
	"Answer a symbol uniquely describing the type of the receiver. c.f. kindOfSubclass, instSpec"
	^(#(normal
		normal
		variable
		variable
		weak
		ephemeron
		nil
		immediate
		nil
		longs
		words				nil
		shorts				nil nil nil
		bytes				nil nil nil nil nil nil nil
		compiledMethod	nil nil nil nil nil nil nil)
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:26:02' prior: 16786978!
instSize
	"Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver.
	Class format is
		<5 bits inst spec><16 bits inst size>"

	^ format bitAnd: 16rFFFF! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:27:16' prior: 16787001!
           instSpec
	"Answer the instance specification part of the format that defines what kind of object
	 an instance of the receiver is."
	"The formats are
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)					(plus one odd bit, unused in 32-bits)
		12-15	= 16-bit indexable							(plus two odd bits, one unused in 32-bits)
		16-23	= 8-bit indexable							(plus three odd bits, one unused in 32-bits)
		24-31	= compiled methods (CompiledMethod)	(plus three odd bits, one unused in 32-bits)
	 Note that in the VM instances also have a 5 bit format field that relates to their class's format.
	 Formats 11, 13-15, 17-23 & 25-31 are unused in classes but used in instances to define the
	 number of elements missing up to the slot size.  For example, a 2-byte ByteString instance
	 has format 18 in 32-bits, since its size is one 32-bit slot - 2 bytes ((18 bitAnd: 3) = 2), and
	 22 in 64 bits, since its size is one 64-bit slot - 6 bytes ((22 bitAnd: 7) = 6)."

	^(format bitShift: -16) bitAnd: 16r1F! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:45' prior: 16787058!
                isBits
	"Answer whether the receiver contains just bits (not pointers).
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec >= 7! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:31' prior: 16787089!
   isBytes
	"Answer whether the receiver contains just bits (not pointers).
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec >= 16! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:35' prior: 16787126!
 isDoubleBytes
	"Answer whether the receiver's instances indexed 16-bit integer instance variables.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 12! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:18' prior: 16787156!
        isDoubleWords
	"Answer whether the receiver's instances indexed 64-bit integer instance variables.
	 The class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 9! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:10:32' prior: 16787254!
       isVariable
	"Answer whether the receiver has indexable variables.
	 Class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	^instSpec >= 2 and: [instSpec <= 4 or: [instSpec >= 9]]! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 16:08:47' prior: 16787304!
                               isWords
	"Answer whether the receiver's instances indexed 32-bit integer instance variables.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 10! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:24:23' prior: 16787335!
              shouldNotBeRedefined
	"Return true if the receiver should not be redefined.
	The assumption is that classes in Smalltalk specialObjects and 
	Behaviors should not be redefined"

	^(Smalltalk specialObjectsArray identityIncludes: self)
			or: [self isKindOf: self]! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'jmv 1/4/2024 16:08:12' prior: 16788482!
           byteSizeOfInstance
	"Answer the total memory size of an instance of the receiver."

	<primitive: 181 error: ec>
	self isVariable ifTrue:
		[^self byteSizeOfInstanceOfSize: 0].
	self primitiveFailed! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'jmv 1/4/2024 16:08:18' prior: 16788492!
             byteSizeOfInstanceOfSize: basicSize
	"Answer the total memory size of an instance of the receiver
	 with the given number of indexable instance variables."

	<primitive: 181 error: ec>
	self isVariable
		ifTrue: "If the primitive overflowed answer a close approximation"
			[(basicSize isInteger
			  and: [basicSize >= 16r1000000]) ifTrue:
				[^2 * (self byteSizeOfInstanceOfSize: basicSize + 1 // 2)
				   - (self byteSizeOfInstanceOfSize: 0)]]
		ifFalse:
			[basicSize = 0 ifTrue:
				[^self byteSizeOfInstance]].
	self primitiveFailed! !
!Behavior methodsFor: 'testing class hierarchy' stamp: 'jmv 1/4/2024 15:31:55' prior: 16788727!
kindOfSubclass
	"Answer a String that is the keyword that describes the receiver's kind of subclass,
	 either a regular subclass, a variableSubclass, a variableByteSubclass,
	 a variableWordSubclass, a weakSubclass, an ephemeronSubclass or an immediateSubclass.
	 c.f. typeOfClass & instSpec"
	^(#(' subclass: '
		' subclass: '
		' variableSubclass: '
		' variableSubclass: '
		' weakSubclass: '
		' ephemeronSubclass: '
		nil
		' immediateSubclass: '
		nil
		' variableDoubleWordSubclass: '
		' variableWordSubclass: '		nil
		' variableDoubleByteSubclass: '	nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil )
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']! !
!Behavior methodsFor: 'comparing' stamp: 'jmv 1/4/2024 16:08:35' prior: 16789595 overrides: 50335599!
identityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	 Behavior implements identityHash to allow the VM to use an object representation which
	 does not include a direct reference to an object's class in an object.  If the VM is using
	 this implementation then classes are held in a class table and instances contain the index
	 of their class in the table.  A class's class table index is its identityHash so that an instance
	 can be created without searching the table for a class's index.  The VM uses this primitive
	 to enter the class into the class table, assigning its identityHash with an as yet unused
	 class table index. If this primitive fails it means that the class table is full.
	 There are 22 bits of classTable index and 22 bits of identityHash per object.

	 Primitive. Essential. Do not override. See Object documentation whatIsAPrimitive."

	<primitive: 175>
	self primitiveFailed.! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:55:01' prior: 16815497!
                         immediateSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 
	"This is the standard initialization message for creating a new
	 immediate class as a subclass of an existing class (the receiver)."

	| answer |
	answer := ClassBuilder new
			superclass: self
			immediateSubclass: t
			instanceVariableNames: ''
			classVariableNames: d
			poolDictionaries: s
			category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:44:55' prior: 16815525!
      subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver)."

	| answer |
	answer := ClassBuilder new
		superclass: self
		subclass: t
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat.

	Smalltalk
		logChange: answer definition
		preamble: answer definitionPreamble.
	^answer 
	
! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:45:17' prior: 16815565!
        variableDoubleByteSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have indexable double-byte-sized (16 bits) nonpointer variables."
	
	| answer |
	answer := ClassBuilder new
		superclass: self
		variableDoubleByteSubclass: t
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer
! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:45:26' prior: 16815588!
    variableDoubleWordSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have indexable double-word-sized (64 bits) nonpointer variables."

	| answer |
	answer := ClassBuilder new
		superclass: self
		variableDoubleWordSubclass: t
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/4/2024 15:16:50' prior: 16816449!
needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass
	"Answer whether we need a new subclass to conform to the requested changes"
	| newFormat |
	"Compute the format of the new class"
	newFormat := 
		self computeFormat: type 
			instSize: instVars size 
			forSuper: newSuper .
	newFormat
		ifNil: [^ nil].

	"Check if we really need a new subclass"
	oldClass ifNil:[^true]. "yes, it's a new class"
	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"
	newFormat = oldClass format ifFalse:[^true]. "yes, it's a format change"
	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"

	^false
! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/4/2024 15:18:32' prior: 16816475!
 newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass
	"Create a new subclass of the given superclass with the given specification."
	| newFormat newClass |
	"Compute the format of the new class"
	newFormat := 
		self computeFormat: type 
			instSize: instVars size 
			forSuper: newSuper.

	newFormat
		ifNil: [^ nil].

	(oldClass == nil or:[oldClass isMeta not]) 
		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]
		ifFalse:[newClass := oldClass shallowCopy].

	newClass 
		superclass: newSuper
		methodDictionary: MethodDictionary new
		format: newFormat;
		setInstVarNames: instVars.

	oldClass ifNotNil:[
		newClass organization: oldClass organization.
		"Recompile the new class"
		oldClass hasMethods 
			ifTrue:[newClass compileAllFrom: oldClass].
		self recordClass: oldClass replacedBy: newClass.
	].

	(oldClass == nil or:[oldClass isObsolete not]) 
		ifTrue:[newSuper addSubclass: newClass]
		ifFalse:[newSuper addObsoleteSubclass: newClass].

	^newClass! !
!ClassBuilder methodsFor: 'class format' stamp: 'jmv 1/4/2024 16:09:36' prior: 16816620!
             computeFormat: type fullInstancesSize: newInstSize
	"Compute the new format for making oldClass a subclass of newSuper.
	 Answer the format or nil if there is any problem."

	| isVar isPointers isWeak bitsUnitSize |
	type == #compiledMethod ifTrue: [
		newInstSize > 0 ifTrue: [
			self error: 'A compiled method class cannot have named instance variables'.
			^nil].
		^CompiledMethod format].
	newInstSize > 65535 ifTrue: [
		self error: 'Class has too many instance variables (', newInstSize printString,')'.
		^nil].
	type == #normal ifTrue:[isVar := isWeak := false. isPointers := true].
	type == #bytes ifTrue:[isVar := true. bitsUnitSize := 1. isPointers := isWeak := false].
	type == #shorts ifTrue:[isVar := true. bitsUnitSize := 2. isPointers := isWeak := false].
	type == #words ifTrue:[isVar := true. bitsUnitSize := 4. isPointers := isWeak := false].
	type == #longs ifTrue:[isVar := true. bitsUnitSize := 8. isPointers := isWeak := false].
	type == #variable ifTrue:[isVar := isPointers := true. isWeak := false].
	type == #weak ifTrue:[isVar := isWeak := isPointers := true].
	type == #ephemeron ifTrue:[isVar := false. isWeak := isPointers := true].
	type == #immediate ifTrue:[isVar := isWeak := isPointers := false].
	isVar ifNil: [ self error: 'Unsupported class format type: ', type. ^ nil ].
	(isPointers not and: [newInstSize > 0]) ifTrue: [
		self error: 'A non-pointer class cannot have named instance variables'.
		^nil].
	^self format: newInstSize variable: isVar bitsUnitSize: bitsUnitSize pointers: isPointers weak: isWeak! !
!ClassBuilder methodsFor: 'class format' stamp: 'jmv 1/4/2024 16:13:22' prior: 16816720!
                     format: nInstVars variable: isVar bitsUnitSize: bitsUnitSize pointers: isPointers weak: isWeak

	"Compute the format for the given instance specfication.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character, SmallFloat64)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap, WideString)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable (ByteString)
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := isWeak
					ifTrue:
						[isVar
							ifTrue: [4]
							ifFalse: [5]]
					ifFalse:
						[isPointers
							ifTrue:
								[isVar
									ifTrue: [nInstVars > 0 ifTrue: [3] ifFalse: [2]]
									ifFalse: [nInstVars > 0 ifTrue: [1] ifFalse: [0]]]
							ifFalse:
								[isVar
									ifTrue: [bitsUnitSize caseOf: {
											[1] -> [16].
											[2] -> [12].
											[4] -> [10].
											[8] -> [9] }]
									ifFalse: [7]]].
	^(instSpec bitShift: 16) + nInstVars! !
!ClassBuilder methodsFor: 'private' stamp: 'jmv 1/4/2024 15:17:05' prior: 16817029!
                             privateNewSubclassOf: newSuper from: oldClass
	"Create a new meta and non-meta subclass of newSuper using oldClass as template"
	"WARNING: This method does not preserve the superclass/subclass invariant!!"
	| newSuperMeta oldMeta newMeta |
	oldClass ifNil:[^self privateNewSubclassOf: newSuper].
	newSuperMeta := newSuper ifNil:[Class] ifNotNil:[newSuper class].
	oldMeta := oldClass class.
	newMeta := oldMeta shallowCopy.
	newMeta 
		superclass: newSuperMeta
		methodDictionary: MethodDictionary new
		format: (self computeFormat: oldMeta typeOfClass 
					instSize: oldMeta instVarNames size 
					forSuper: newSuperMeta);
		setInstVarNames: oldMeta instVarNames;
		organization: oldMeta organization.
	"Recompile the meta class"
	oldMeta hasMethods 
		ifTrue:[newMeta compileAllFrom: oldMeta].
	"Record the meta class change"
	self recordClass: oldMeta replacedBy: newMeta.
	"And create a new instance"
	^newMeta adoptInstance: oldClass from: oldMeta! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 15:35:25' prior: 16817131!
               superclass: aClass
	ephemeronSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have ephemeron semantics, i.e. where the object will be queued for
	finalization when the key (first) inst var is not reachable other than through
	the other fields of ephemerons with unreachable keys."

	aClass isPointers
		ifFalse: [^ self error: 'cannot make a pointer subclass of a class with non-pointer fields'].
	aClass instSize + f substrings size < 2
		ifTrue: [^ self error: 'cannot make an ephemeron class with less than two named instance varaibles'].
	^self 
		name: t
		subclassOf: aClass
		type: #ephemeron
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 15:35:41' prior: 16817170!
                  superclass: aClass
	immediateSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a
	 new immediate class as a subclass of an existing class."

	aClass instSize > 0
		ifTrue: [^self error: 'cannot make an immediate subclass of a class with named fields'].
	aClass isVariable
		ifTrue: [^self error: 'cannot make an immediate subclass of a class with indexed instance variables'].
	aClass isPointers
		ifFalse: [^self error: 'cannot make an immediate subclass of a class without pointer fields'].

	^self 
		name: t
		subclassOf: aClass
		type: #immediate
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 16:13:46' prior: 16817254!
 superclass: aClass
	variableDoubleByteSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class in which the subclass is to 
	have indexable double-byte-sized (16 bit) nonpointer variables."

	(aClass instSize > 0)
		ifTrue: [^self error: 'cannot make a 16-bit word subclass of a class with named fields'].
	(aClass isVariable and: [aClass isPointers])
		ifTrue: [^self error: 'cannot make a 16-bit word subclass of a class with pointer fields'].
	(aClass isVariable and: [aClass isDoubleBytes not])
		ifTrue: [^self error: 'cannot make a 16-bit word subclass of a class with 8, 32 or 64 bit fields'].

	^self 
		name: t
		subclassOf: aClass
		type: #shorts
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 16:13:52' prior: 16817286!
              superclass: aClass
	variableDoubleWordSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class in which the subclass is to 
	have indexable double-word-sized (64 bit) nonpointer variables."

	(aClass instSize > 0)
		ifTrue: [^self error: 'cannot make a 64-bit word subclass of a class with named fields'].
	(aClass isVariable and: [aClass isPointers])
		ifTrue: [^self error: 'cannot make a 64-bit word subclass of a class with pointer fields'].
	(aClass isVariable and: [aClass isDoubleWords not])
		ifTrue: [^self error: 'cannot make a 64-bit word subclass of a class with 8, 16 or 32 bit fields'].

	^self 
		name: t
		subclassOf: aClass
		type: #longs
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 1/4/2024 15:57:44' prior: 16817485!
       update: oldClass to: newClass
	"Convert oldClass, all its instances and possibly its meta class into newClass,
	 instances of newClass and possibly its meta class. The process is surprisingly
	 simple in its implementation and surprisingly complex in its nuances and potentially
	 bad side effects.
	 We can rely on two assumptions (which are critical):
		#1: The method #updateInstancesFrom: will not create any lasting pointers to
			 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do
			 a become of the old vs. the new instances and therefore it will not create
			 pointers to *new* instances before the #become: which are *old* afterwards)
		#2: The non-preemptive execution of the critical piece of code guarantees that
			 nobody can get a hold by 'other means' (such as process interruption and
			 reflection) on the old instances.
	 Given the above two, we know that after #updateInstancesFrom: there are no pointers
	 to any old instances. After the forwarding become there will be no pointers to the old
	 class or meta class either.
	 Andreas Raab, 2/27/2003 23:42"
	| meta allInstances |
	meta := oldClass isMeta.
	"Note: Everything from here on will run without the ability to get interrupted
	to prevent any other process to create new instances of the old class."
	["Note: The following removal may look somewhat obscure and needs an explanation.
	  When we mutate the class hierarchy we create new classes for any existing subclass.
	  So it may look as if we don't have to remove the old class from its superclass. However,
	  at the top of the hierarchy (the first class we reshape) that superclass itself is not newly
	  created so therefore it will hold both the oldClass and newClass in its (obsolete or not)
	  subclasses. Since the #become: below will transparently replace the pointers to oldClass
	  with newClass the superclass would have newClass in its subclasses TWICE. With rather
	  unclear effects if we consider that we may convert the meta-class hierarchy itself (which
	  is derived from the non-meta class hierarchy).
	  Due to this problem ALL classes are removed from their superclass just prior to converting
	  them. Here, breaking the superclass/subclass invariant really doesn't matter since we will
	  effectively remove the oldClass (becomeForward:) just a few lines below."

		"Convert the instances of oldClass into instances of newClass.
		Note: #canUpdateFrom: has already been called. Instance mutation is safe wrt methods currently in execution."
		allInstances := oldClass allInstances.
		allInstances notEmpty ifTrue: [
			newClass updateInstances: allInstances asArray from: oldClass isMeta: meta ].

		oldClass superclass removeSubclass: oldClass.
		oldClass superclass removeObsoleteSubclass: oldClass.

		"make sure that the VM cache is clean"
		oldClass methodDict do: [:cm | cm flushCache].

		meta
			ifTrue: [
				oldClass becomeForward: newClass.
				oldClass updateMethodBindingsTo: oldClass binding]
			ifFalse: [
				{oldClass. oldClass class} elementsForwardIdentityTo: {newClass. newClass class}.
				oldClass updateMethodBindingsTo: oldClass binding.
				oldClass class updateMethodBindingsTo: oldClass class binding].

		"eem 5/31/2014 07:22 At this point there used to be a garbage collect whose purpose was
		 to ensure no old instances existed after the becomeForward:.  Without the GC it was possible
		 to resurrect old instances using e.g. allInstancesDo:.  This was because the becomeForward:
		 updated references from the old objects to new objects but didn't destroy the old objects.
		 But as of late 2013/early 2014 becomeForward: has been modified to free all the old objects."
	] valueUnpreemptively! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/4/2024 16:16:33' prior: 16810809!
          numericValue
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding."

	<primitive: 171>
	^self primitiveFailed! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/4/2024 15:12:44' prior: 16810868 overrides: 50335599!
       identityHash
	"Answer the receiver's character code."

	<primitive: 171>! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/4/2024 16:17:57' prior: 16811309!
                   numericValue: anInteger
	"Answer the Character whose value is anInteger."

	<primitive: 170>
	^self primitiveFailed! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 1/4/2024 15:38:13' prior: 16833463!
                 numLiterals
	"Answer the number of literals used by the receiver."

	^ self header bitAnd: 16r7FFF! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 1/4/2024 15:38:37' prior: 16833479!
  primitive
	"Answer the primitive index associated with the receiver.
	Zero indicates that this is not a primitive method."

	| initialPC |
	^(self header anyMask: 65536) "Is the hasPrimitive? flag set?"
		ifTrue: [(self at: (initialPC := self initialPC) + 1) + ((self at: initialPC + 2) bitShift: 8)]
		ifFalse: [0]! !
!CompiledMethod class methodsFor: 'instance creation' stamp: 'jmv 1/4/2024 15:37:18' prior: 16835757!
                           newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	 arguments. The remaining parts are not as yet determined."
	| method pc |
"15 | 63 | 32767"
	nArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	nTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 32767
		ifTrue: [^self error: 'Cannot compile -- too many literals'].

	method := self
				createMethod: numberOfBytes
				trailer: trailer
				header:    (nArgs bitShift: 24)
						+ (nTemps bitShift: 18)
						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])
						+ nLits
						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).
	primitiveIndex > 0 ifTrue: [
		pc := method initialPC.
		method
			at: pc + 0 put: method encoderClass callPrimitiveCode;
			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);
			at: pc + 2 put: (primitiveIndex bitShift: -8)].
	^method! !
!CompiledMethod class methodsFor: 'constants' stamp: 'jmv 1/4/2024 16:21:20' prior: 16836304!
               maxNumLiterals
	"The current header format and the VM's interpretation of it allows for a maximum of 32767 literals."

	^32767! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 1/4/2024 16:11:49' prior: 16963713!
 growMemoryByAtLeast: numBytes
	"Grow memory by at least the requested number of bytes.
	 Primitive.  Fail if no memory is available.  Essential.
	 N.B. In Spur, the heap is composed of segments. Growing memory adds a new
	 segment; it does not extend existing segments. Growth is by at least that
	 established by Smalltalk vmParameterAt: 25, which defaults to 16Mb."

	<primitive: 180>
	^(numBytes isInteger and: [numBytes > 0])
		ifTrue: [OutOfMemory signal]
		ifFalse: [self primitiveFailed]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 1/4/2024 16:21:43' prior: 16965196!
                   allObjectsDo: aBlock 
	"Evaluate the argument, aBlock, for each object in the system, excluding immediates
	 such as SmallInteger, Character and SmallFloat64."
	self allObjectsOrNil
		ifNotNil: [:allObjects| allObjects do: aBlock]
		ifNil:
			["Fall back on the old single object primitive code.  With closures, this needs
			  to use an end marker (lastObject) since activation of the block will create
			  new contexts and cause an infinite loop.  The lastObject must be created
			  before calling someObject, so that the VM can settle the enumeration (e.g.
			  by flushing new space) as a side effect of  someObject"
			| object lastObject |
			lastObject := Object new.
			object := self someObject.
			[lastObject == object or: [0 == object]] whileFalse: [
				| nextObject |
				nextObject := object nextObject.
				aBlock value: object.
				object := nextObject ]]! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 1/4/2024 16:11:15' prior: 50333477!
                        reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts := MethodDictionary allInstances.
	newDicts := Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts := newDicts := nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/4/2024 15:39:16' prior: 50333600!
     filenameForUpdatedImage: aBoolean
	"If aBoolean, include highest update number	"
	| fileName newName changesName systemVersion |
	systemVersion := SystemVersion current.
	fileName := String streamContents: [ :strm |
		strm nextPutAll: systemVersion versionString.
		aBoolean ifTrue: [
			strm
				nextPut: $-;
				print: systemVersion highestUpdate ].
		Smalltalk wordSize = 4 ifTrue: [
			strm nextPutAll: '-32' ]].
	newName := fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName := DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName := self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		self inform:
'There is already .changes file of the desired name,
', changesName, '
curiously already present, even though there is no
corresponding .image file.
Please remedy manually and then repeat your request.'.
		^nil  ].
	^newName! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/4/2024 16:26:42' prior: 50333726!
                            setGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here don't persist, so we set them on startup.
	See #setDefaultGCParameters"

	| proportion edenSize survivorSize averageObjectSize numObjects |

	"Grow old memory in chunks of: "
	Smalltalk vmParameterAt: 25 put: `32*1024*1024`.
	"Shrink heap when unused memory is at least: "
	Smalltalk vmParameterAt: 24 put: `64*1024*1024`.

	"Note: (jmv, 9/2021) It seems modern Spur VMs ignore parameter 6. This all seems to be bogus."
	proportion := 0.9. "tenure when 90% of pastSpace is full"
	edenSize := self vmParameterAt: 44.
	survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"
	averageObjectSize := 8 * self wordSize. "a good approximation"
	numObjects := (proportion * survivorSize / averageObjectSize) rounded.
	self vmParameterAt: 6 put: numObjects.  "tenure when more than this many objects survive the GC"
	"/Note: (jmv, 9/2021)"
	
	"Do a full GC when used memory grows by this factor.
	Default is 0.333.
	2.0 means gull GC when heap size triples."
	Smalltalk vmParameterAt: 55 put: 2.0.! !
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 1/4/2024 16:25:58' prior: 16967210!
                       recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).

	newArray at: 25 put: nil.	"Was an array of 256 Characters. nil in Spur."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "Was the #compactClassesArray. nil in Spur."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization"
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.

	newArray at: 36 put: nil. "was the prototype MethodContext"

	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Weak reference finalization"
	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray.! !
!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 1/4/2024 15:39:42' prior: 16968855!
              maxIdentityHash
	"Answer the maximum identityHash value supported by the VM.
	Usually the VM is able to answer. It seems that SqueakJS (as of October 5, 2020) isn't.
	On primitive failure, still give a correct answer."

	<primitive: 176>	
	^ 16r3FFFFF							"22 bits in Spur"! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 1/4/2024 16:29:03' prior: 16969790!
           vmParameterAt: parameterIndex
	"parameterIndex is a positive integer corresponding to one of the VM's internal parameter/metric registers. 
	Answer with the current value of that register.
	Answer nil if the VM doesn't provide the register, and the primitive fails.
	
	Also see #getVMParameters and #vmParameterAt:put: These 3 methods call the 
	same primitive, whose behavior depends on argument count:
		0 args:	return an Array of VM parameter values;
  		1 arg:	return the indicated VM parameter;
  		2 args:	set the VM indicated parameter.

	VM parameters are numbered as follows:
		1	size of old-space (0-based, read-only)
		2	size of new-space (read-only)
		3	size of heap (read-only)
		4	nil (was allocationCount (read-only))
		5	nil (was allocations between GCs (read-write)
		6	survivor count tenuring threshold (read-write)
		7	full GCs since startup (read-only)
		8	total milliseconds in full GCs since startup (read-only)
		9	scavenges since startup (read-only)
		10	scavenges since startup (read-only)
		11	tenures of surving objects since startup or reset (read-write)
		12-20 were specific to ikp's JITTER VM, now 12-15 are open for use
		16	total microseconds at idle since start-up (if non-zero)
		17	fraction of the code zone to use (Sista only; used to control code zone use to preserve sendAndBranchData on counter tripped callback)
		18	total milliseconds in compaction phase of full GC since start-up
		19	scavenge threshold, the effective size of eden.  When eden fills to the threshold a scavenge is scheduled.
		20	utc microseconds at VM start-up (actually at time initialization, which precedes image load).
		21	root/remembered table size (occupancy) (read-only)
		22	root table overflows since startup (read-only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored in image file header).
		24	memory threshold above which shrinking object memory (rw)
		25	memory headroom when growing object memory (rw)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (rw)
		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking
		28	number of times sweep loop iterated for current IGC/FGC (read-only)
		29	number of times make forward loop iterated for current IGC/FGC (read-only)
		30	number of times compact move loop iterated for current IGC/FGC (read-only)
		31	number of grow memory requests (read-only)
		32	number of shrink memory requests (read-only)
		33	number of root table entries used for current IGC/FGC (read-only)
		34	bytes allocated in total since start-up or reset (read-write)
		35	number of survivor objects after current IGC/FGC (read-only)
		36	millisecond clock when current IGC/FGC completed (read-only)
		37	number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)
		38	milliseconds taken by current IGC (read-only)
		39	Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)
		40	BytesPerOop for this image
		41	imageFormatVersion for the VM
		42	number of stack pages in use
		43	desired number of stack pages (stored in image file header, max 65535)
		44	size of eden, in bytes
		45	desired size of eden, in bytes (stored in image file header)
		46	machine code zone size, in bytes (Cog only; otherwise nil)
		47	desired machine code zone size (stored in image file header; Cog only; otherwise nil)
		48	various header flags.  
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	max size the image promises to grow the external semaphore table to (0 sets to default, which is 256 as of writing)
		50-51 nil; reserved for VM parameters that persist in the image (such as eden above)
		52	root/remembered table capacity
		53	number of segments
		54	total size of free old space
		55	ratio of growth and image size at or above which a GC will be performed post scavenge
		56	number of process switches since startup (read-only)
		57	number of ioProcessEvents calls since startup (read-only)
		58	number of ForceInterruptCheck calls since startup (read-only)
		59	number of check event calls since startup (read-only)
		60	number of stack page overflows since startup (read-only)
		61	number of stack page divorces since startup (read-only)
		62	compiled code compactions since startup (read-only; Cog only; otherwise nil)
		63	total milliseconds in compiled code compactions since startup (read-only; Cog only; otherwise nil)
		64	the number of methods that currently have jitted machine-code
		65	whether the VM supports a certain feature, MULTIPLE_BYTECODE_SETS is bit 0, IMMUTABILITY is bit 1
		66	the byte size of a stack page
		67	the max allowed size of old space (0 implies no limit except that of the underlying platform)
		68	the average number of live stack pages when scanned by GC (at scavenge/gc/become et al) (read-write)
		69	the maximum number of live stack pages when scanned by GC (at scavenge/gc/become et al) (read-write)
		70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
		71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
		72  total milliseconds in full GCs Mark phase since startup (read-only)
		73  total milliseconds in full GCs Sweep phase since startup (read-only, can be 0 depending on compactors)
		74  maximum pause time due to segment allocation"

	<primitive: 254>
	^nil! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 1/4/2024 16:30:34' prior: 16970002!
        vmParameterAt: parameterIndex put: newValue
	"parameterIndex is a positive integer corresponding to one of the VM's internal
	parameter/metric registers.  Store newValue (a positive integer) into that
	register and answer with the previous value that was stored there.
	Fail if newValue is out of range, if parameterIndex has no corresponding
	register, or if the corresponding register is read-only.

	As of mid 2017 the parameters which can be set are
		5	allocations between GCs (read-write; nil in Cog VMs)
		6	survivor count tenuring threshold (read-write)
		17	proportion of code zone available for use (Sista VMs only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc.
		24	memory threshold above whichto shrink object memory (read-write)
		25	memory headroom when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		34	bytes allocated in total since start-up or reset (read-write)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties of the Cog VM as an integer encoding an array of bit flags.
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: in if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	the size of the external semaphore table (read-write; Cog VMs only)
		55	ratio of growth and image size at or above which a GC will be performed post scavenge
		67	the maximum allowed size of old space in bytes, 0 implies no internal limit."

	<primitive: 254>
	self primitiveFailed! !
!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'jmv 1/4/2024 16:12:33' prior: 16801994!
       sizeCallPrimitive: primitiveIndex
	^self sizeOpcodeSelector: #genCallPrimitive: withArguments: {primitiveIndex}! !
!BytecodeEncoder methodsFor: 'method generation' stamp: 'jmv 1/4/2024 16:12:19' prior: 16802253!
            computeMethodHeaderForNumArgs: numArgs numTemps: numTemps numLits: numLits primitive: primitiveIndex
	numArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	numTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	numLits > 65535
		ifTrue: [^self error: 'Cannot compile -- too many literals'].
	^(CompiledMethod headerFlagForEncoder: self)
		+ (numArgs bitShift: 24)
		+ (numTemps bitShift: 18)
		"+ (largeBit bitShift: 17)" "largeBit gets filled in later"
		+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])
		+ numLits! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 1/4/2024 16:12:46' prior: 16854304!
   genCallPrimitive: primitiveIndex
	"139	11101111	iiiiiiii jjjjjjjj	Call Primitive #iiiiiiii + (jjjjjjjj * 256)"
	(primitiveIndex < 1 or: [primitiveIndex > 65535]) ifTrue: [
		self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 65535].
	stream
		nextPut: 139;
		nextPut: (primitiveIndex bitAnd: 255);
		nextPut: (primitiveIndex bitShift: -8)! !
!MethodNode methodsFor: 'code generation' stamp: 'jmv 1/4/2024 15:40:43' prior: 16901239!
                        generate: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits locals literals stack header method |
	self generate: trailer
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	self ensureClosureAnalysisDone.
	encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primitive > 0
					ifTrue: [encoder sizeCallPrimitive: primitive]
					ifFalse: [0])
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	locals := arguments, temporaries, (primErrNode ifNil: [#()] ifNotNil: [{primErrNode}]).
	encoder noteBlockExtent: block blockExtent hasLocals: locals.
	header := encoder computeMethodHeaderForNumArgs: arguments size
					numTemps: locals size
					numLits: (nLits := (literals := encoder allLiterals) size)
					primitive: primitive.
	method := aCompiledMethodClass
					createMethod: blkSize
					trailer: trailer
					header: header.
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primitive > 0 ifTrue:
		[encoder genCallPrimitive: primitive.
		 primErrNode ifNotNil:
			[primErrNode emitCodeForStore: stack encoder: encoder]].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 1/4/2024 16:32:05' prior: 16997246!
                 vmStatisticsReportOn: str
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	| params oldSpaceEnd youngSpaceEnd memorySize fullGCs fullGCTime fullGCCompactionTime incrGCs incrGCTime tenureCount upTime
	  upTime2 fullGCs2 fullGCTime2  incrGCs2 incrGCTime2 tenureCount2 freeSize youngSize used timeReporter idleMs idleMs2 codeCompactionTime codeCompactionsOrNil codeCompactionTime2 codeCompactions2 maxParams |
	"Pad to protect for a VM that does not answer the expected parameter array"
	maxParams := 63. "max position referenced in this method"
	params := Array streamContents: [ :strm |
				strm nextPutAll: Smalltalk getVMParameters.
				[strm position < maxParams] whileTrue: [strm nextPut: nil]].
	oldSpaceEnd			:= params at: 1.
	youngSpaceEnd		:= params at: 2.
	memorySize			:= params at: 3.
	fullGCs			:= params at: 7.
	fullGCTime			:= params at: 8.
	incrGCs			:= params at: 9.
	incrGCTime			:= params at: 10.
	tenureCount			:= params at: 11.
	fullGCCompactionTime	:= params at: 18.
	codeCompactionsOrNil	:= params at: 62.
	codeCompactionTime	:= params at: 63.
	
	upTime := (params at: 20) ~= 0 "utcMicrosecondClock at startup"
				ifTrue: [Time primUtcMicrosecondClock - (params at: 20) + 500 // 1000]
				ifFalse: [Time primMillisecondClock]. "Fall back on old microsecond clock; Good for 47.5 days"
	timeReporter := [:time| | seconds |
					seconds := time / 1000.
					seconds >= (60*60*24)
						ifTrue:
							[str print: seconds / 60 // 60 // 24; nextPut: $d; space;
								print: seconds / 60 // 60 \\ 24; nextPut: $h; space]
						ifFalse:
							[seconds >= (60*60) ifTrue:
								[str print: (seconds / 60 // 60); nextPut: $h; space]].
					str
						print: (seconds / 60 \\ 60) asInteger; nextPut: $m; space;
						print: (seconds \\ 60) asInteger; nextPut: $s].
	str	nextPutAll: 'uptime		'.
	timeReporter value: upTime.
	(idleMs := params at: 16) ~= 0 ifTrue:
		[str tab; nextPutAll: '(runtime '.
		 idleMs := idleMs // 1000.
		 timeReporter value: upTime - idleMs.
		 str nextPutAll: ', idletime '.
		 timeReporter value: idleMs.
		 str nextPut: $)].
	str newLine.

	str	nextPutAll: 'memory			';
		nextPutAll: (self formatVMParameter: memorySize); nextPutAll: ' bytes'; newLine.
	str	nextPutAll:	'	old		';
		nextPutAll: (self formatVMParameter: oldSpaceEnd); nextPutAll: ' bytes (';
		print: oldSpaceEnd / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	(youngSize := (params at: 19)  * 7 // 5) = 0 ifTrue: [params at: 44].
	 youngSize := youngSize roundUpTo: 1024.
	 str	nextPutAll: '	young		';
		nextPutAll: (self formatVMParameter: youngSize); nextPutAll: ' bytes (';
		print: youngSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
	youngSize := youngSpaceEnd. "used eden"
	freeSize := (params at: 54) + (params at: 44) - youngSize.
	used := youngSize + oldSpaceEnd - freeSize.
	str	nextPutAll: '	used		';
		nextPutAll: (self formatVMParameter: used); nextPutAll: ' bytes (';
		print: used / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
	str	nextPutAll: '	free		';
		nextPutAll: (self formatVMParameter: freeSize); nextPutAll: ' bytes (';
		print: freeSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	str	nextPutAll: 'GCs					';
		nextPutAll: (self formatVMParameter: (fullGCs + incrGCs)).
	fullGCs + incrGCs > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime / (fullGCs + incrGCs) fractionDigits: 1; 
			nextPutAll: ' ms between GCs'.
		 idleMs > 0 ifTrue:
			[str
				space;
				print: upTime - idleMs / (fullGCs + incrGCs) fractionDigits: 1; 
				nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime); nextPutAll: ' ms (';
		print: fullGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime)';
		nextPutAll: ', avg '; print: (fullGCTime / (fullGCs max: 1)) fractionDigits: 1; nextPutAll: ' ms'.
	fullGCCompactionTime ~= 0 ifTrue:
		[str	newLine; nextPutAll: '		marking			';
			nextPutAll: (self formatVMParameter: (fullGCTime - fullGCCompactionTime)); nextPutAll: ' ms (';
			print: (fullGCTime - fullGCCompactionTime) / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: (fullGCTime - fullGCCompactionTime / (fullGCs max: 1)) fractionDigits: 1;
			nextPutAll: ' ms,'; newLine;
			nextPutAll: '		compacting			';
			nextPutAll: (self formatVMParameter: fullGCCompactionTime); nextPutAll: ' ms (';
			print: fullGCCompactionTime / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: fullGCCompactionTime / (fullGCs max: 1) fractionDigits: 1;
			nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: '	scavenges				';
		nextPutAll: (self formatVMParameter: incrGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime); nextPutAll: ' ms (';
		print: incrGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime), avg '; print: incrGCTime / incrGCs fractionDigits: 1; nextPutAll: ' ms'; newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount).
	tenureCount = 0 ifFalse:
		[str nextPutAll: ' (avg '; print: tenureCount // (incrGCs max: 1); nextPutAll: ' tenures per scavenge)'].
	str	newLine.

	codeCompactionsOrNil ifNotNil:
		[str
			nextPutAll: '	code compactions				'.
		codeCompactionsOrNil = 0
			ifTrue: [str
				nextPutAll: codeCompactionsOrNil printString; newLine]
			ifFalse: [str
				nextPutAll: (self formatVMParameter: codeCompactionsOrNil); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime); nextPutAll: ' ms (';
				print: codeCompactionTime / (upTime - idleMs) * 100 fractionDigits: 3;
				nextPutAll: '% runtime), avg '; print: codeCompactionTime / codeCompactionsOrNil fractionDigits: 1; nextPutAll: ' ms'; newLine]].

LastStats ifNil: [LastStats := Array new: 9]
ifNotNil: [
	LastStats size < 9 ifTrue:
		[LastStats := LastStats, (Array new: 9 - LastStats size withAll: 0)].
	upTime2 := upTime - (LastStats at: 1).
	fullGCs2 := fullGCs - (LastStats at: 2).
	fullGCTime2 := fullGCTime - (LastStats at: 3).
	incrGCs2 := incrGCs - (LastStats at: 4).
	incrGCTime2 := incrGCTime - (LastStats at: 5).
	tenureCount2 := tenureCount - (LastStats at: 6).
	idleMs2 := idleMs - (LastStats at: 7).
	codeCompactionsOrNil ifNotNil:
		[codeCompactions2	:= codeCompactionsOrNil - (LastStats at: 8).
		 codeCompactionTime2	:= codeCompactionTime - (LastStats at: 9)].

	str	nextPutAll: 'GCs since last view					';
		nextPutAll: (self formatVMParameter: (fullGCs2 + incrGCs2)).
	fullGCs2 + incrGCs2 > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime2 // (fullGCs2 + incrGCs2); 
			nextPutAll: ' ms between GCs'.
			idleMs2 > 0 ifTrue:
				[str
					nextPutAll: ', ';
					print: upTime2 - idleMs2 // (fullGCs2 + incrGCs2);
					nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str	newLine.
	str	nextPutAll: '	uptime				'; print: (upTime2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, runtime ';		   print: (upTime2 - idleMs2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, idletime ';		   print: (idleMs2 / 1000.0) fractionDigits: 1; nextPutAll: ' s'; newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs2).
	fullGCs2 + fullGCTime2 > 0 ifTrue:
		[str	nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime2); nextPutAll: ' ms (';
			print: fullGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
			nextPutAll: '% runtime)'.
		 str	nextPutAll: ', avg '; print: fullGCTime2 / (fullGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: '	scavenges				';
		nextPutAll: (self formatVMParameter: incrGCs2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime2); nextPutAll: ' ms (';
		print: incrGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
		nextPutAll: '% runtime), avg '; print: incrGCTime2 / (incrGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'.
	str	newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount2).
	tenureCount2 = 0 ifFalse:
		[str nextPutAll: ' (avg '; print: tenureCount2 // (incrGCs2 max: 1); nextPutAll: ' tenures per scavenge)'].
	str	newLine.
	codeCompactionsOrNil ifNotNil:
		[str	nextPutAll: '	code compactions				';
			nextPutAll: (self formatVMParameter: codeCompactions2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime2); nextPutAll: ' ms (';
			print: codeCompactionTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 3;
			nextPutAll: '% runtime)'.
		 codeCompactions2 > 0 ifTrue:
			[str nextPutAll: ', avg '; print: codeCompactionTime2 / codeCompactions2 fractionDigits: 1; nextPutAll: ' ms'; newLine.]]
].
	LastStats := { upTime. fullGCs. fullGCTime. incrGCs. incrGCTime. tenureCount. idleMs. codeCompactionsOrNil. codeCompactionTime }.! !
!SpaceTally methodsFor: 'instance size' stamp: 'jmv 1/4/2024 15:20:50' prior: 16958043!
                   spaceForInstancesOf: aClass
	"Answer a pair of the number of bytes consumed by all instances of the
	 given class, including their object headers, and the number of instances."

	| instances total |
	instances := aClass allInstances.
	instances isEmpty ifTrue: [^#(0 0)].
	total := 0.
	aClass isVariable
		ifTrue:
			[instances do:
				[:i| total := total + (aClass byteSizeOfInstanceOfSize: i basicSize)]]
		ifFalse:
			[total := instances size * aClass byteSizeOfInstance].
	^{ total. instances size }! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 1/4/2024 15:20:08' prior: 16958151!
                   printSpaceAnalysis: threshold on: aStream
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.
	results := OrderedCollection new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace := cl spaceUsed.
				barBlock value: (n := n+1).
				Smalltalk garbageCollectMost.
				instCount := cl instanceCount.
				instSpace := 8 * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize := cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace := instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace := instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace := totalCodeSpace + codeSpace.
				totalInstCount := totalInstCount + instCount.
				totalInstSpace := totalInstSpace + instSpace]].
	totalPercent := 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent := s spaceForInstances*100.0/totalInstSpace.
		totalPercent := totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !

SpaceTally removeSelector: #spaceForInstancesOfSpur:!

!methodRemoval: SpaceTally #spaceForInstancesOfSpur: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
spaceForInstancesOfSpur: aClass
	"Answer a pair of the number of bytes consumed by all instances of the
	 given class, including their object headers, and the number of instances."

	| instances total |
	instances := aClass allInstances.
	instances isEmpty ifTrue: [^#(0 0)].
	total := 0.
	aClass isVariable
		ifTrue:
			[instances do:
				[:i| total := total + (aClass byteSizeOfInstanceOfSize: i basicSize)]]
		ifFalse:
			[total := instances size * aClass byteSizeOfInstance].
	^{ total. instances size }!

SpaceTally removeSelector: #spaceForInstancesOfPreSpur:!

!methodRemoval: SpaceTally #spaceForInstancesOfPreSpur: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
spaceForInstancesOfPreSpur: aClass
	"Answer a pair of the number of bytes consumed by all instances of the
	 given class, including their object headers, and the number of instances."

	| instCount isCompact instVarBytes bytesPerElement contentBytes headerBytes total |
	instCount := aClass instanceCount.
	instCount = 0 ifTrue: [^ 0].
	isCompact := aClass indexIfCompact > 0.
	instVarBytes := aClass instSize * 4.
	aClass isVariable
		ifTrue: [
			bytesPerElement := aClass isBytes ifTrue: [1] ifFalse: [4].
			total := 0.
			aClass allInstancesDo: [:inst |
				contentBytes := instVarBytes + (inst size * bytesPerElement).
				headerBytes :=
					contentBytes > 255
						ifTrue: [12]
						ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].
				total := total + headerBytes + contentBytes].
			^ {total. instCount}]
		ifFalse: [
			headerBytes :=
				instVarBytes > 255
					ifTrue: [12]
					ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].
			^ {instCount * (headerBytes + instVarBytes). instCount}].
!

MethodNode removeSelector: #generatePreSpur:using:!

!methodRemoval: MethodNode #generatePreSpur:using: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
generatePreSpur: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits literals stack method |
	self generate: trailer 
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	encoder supportsClosureOpcodes ifTrue:
		[self ensureClosureAnalysisDone.
		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	method := aCompiledMethodClass
				newBytes: blkSize
				trailerBytes: trailer 
				nArgs: arguments size
				nTemps: (encoder supportsClosureOpcodes
							ifTrue: [| locals |
									locals := arguments,
											  temporaries,
											  (primErrNode
												ifNil: [#()]
												ifNotNil: [{primErrNode}]).
									encoder
										noteBlockExtent: block blockExtent
										hasLocals: locals.
									locals size]
							ifFalse: [encoder maxTemp])
				nStack: 0
				nLits: (nLits := (literals := encoder allLiterals) size)
				primitive: primitive.
	nLits > 255 ifTrue:
		[^self error: 'Too many literals referenced'].
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method!

MethodNode removeSelector: #generateSpur:using:!

!methodRemoval: MethodNode #generateSpur:using: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
generateSpur: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits locals literals stack header method |
	self generate: trailer
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	self ensureClosureAnalysisDone.
	encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primitive > 0
					ifTrue: [encoder sizeCallPrimitive: primitive]
					ifFalse: [0])
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	locals := arguments, temporaries, (primErrNode ifNil: [#()] ifNotNil: [{primErrNode}]).
	encoder noteBlockExtent: block blockExtent hasLocals: locals.
	header := encoder computeMethodHeaderForNumArgs: arguments size
					numTemps: locals size
					numLits: (nLits := (literals := encoder allLiterals) size)
					primitive: primitive.
	method := aCompiledMethodClass
					createMethod: blkSize
					trailer: trailer
					header: header.
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primitive > 0 ifTrue:
		[encoder genCallPrimitive: primitive.
		 primErrNode ifNotNil:
			[primErrNode emitCodeForStore: stack encoder: encoder]].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method!

SystemDictionary removeSelector: #compactClassesArray!

!methodRemoval: SystemDictionary #compactClassesArray stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
compactClassesArray  "Smalltalk compactClassesArray"
	"Return the array of 31 classes whose instances may be
	represented compactly"
	^ self specialObjectsArray at: 29!

SystemDictionary removeSelector: #isSpur!

!methodRemoval: SystemDictionary #isSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
isSpur
	"Answer true if we are a Spur ObjectMemory.
	Spur introduces a new format of header for objects, new format for classes, etc.
	Smalltalk isSpur
	"

	^ self compactClassesArray isNil!

SystemDictionary removeSelector: #cleanCompactObsoleteClasses!

!methodRemoval: SystemDictionary #cleanCompactObsoleteClasses stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
cleanCompactObsoleteClasses

	| cct |
	"No Compact Classes support in Spur"
	self isSpur ifTrue: [ ^ self ].

	cct := self compactClassesArray.
	cct do: [ :c |
		c ifNotNil: [
			c isObsolete ifTrue: [ 
				cct at: c indexIfCompact put: nil ]]]!

SystemDictionary removeSelector: #compactClassesArrayIncludes:!

!methodRemoval: SystemDictionary #compactClassesArrayIncludes: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
compactClassesArrayIncludes: aClass
	"No compact classes in Spur, but usually some in non-Spur"
	^self compactClassesArray
		ifNil: [ false ]
		ifNotNil: [ :it | it identityIncludes: aClass ]!

CompiledMethod class removeSelector: #newPreSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:!

!methodRemoval: CompiledMethod class #newPreSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
newPreSpurBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	arguments. The remaining parts are not as yet determined."
	| largeBit primBits method |
	nTemps > 63 ifTrue:
		[^ self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 255 ifTrue:
		[^ self error: 'Cannot compile -- too many literals variables'].	
	largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].
	primBits := primitiveIndex <= 16r1FF
		ifTrue: [primitiveIndex]
		ifFalse: ["For now the high bit of primitive no. is in the 29th bit of header"
				primitiveIndex > 16r3FF ifTrue: [self error: 'prim num too large'].
				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19)].
	method := self newMethod: numberOfBytes + trailer size
		header: (nArgs bitShift: 24) +
				(nTemps bitShift: 18) +
				(largeBit bitShift: 17) +
				(nLits bitShift: 9) +
				primBits.
	1 to: trailer size do:  "Copy the source code trailer to the end"
		[:i | method at: method size - trailer size + i put: (trailer at: i)].
	^ method!

CompiledMethod class removeSelector: #newSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:!

!methodRemoval: CompiledMethod class #newSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
newSpurBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	 arguments. The remaining parts are not as yet determined."
	| method pc |
"15 | 63 | 32767"
	nArgs > 15 ifTrue:
		[^self error: 'Cannot compile -- too many arguments'].
	nTemps > 63 ifTrue:
		[^self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 32767 ifTrue:
		[^self error: 'Cannot compile -- too many literals'].

	method := self
				createMethod: numberOfBytes
				trailer: trailer
				header:    (nArgs bitShift: 24)
						+ (nTemps bitShift: 18)
						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])
						+ nLits
						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).
	primitiveIndex > 0 ifTrue:
		[pc := method initialPC.
		 method
			at: pc + 0 put: method encoderClass callPrimitiveCode;
			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);
			at: pc + 2 put: (primitiveIndex bitShift: -8)].
	^method!

Character class removeSelector: #definition!

!methodRemoval: Character class #definition stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Object immediateSubclass: #Character
	instanceVariableNames: ''value''
	classVariableNames: ''CharacterTable''
	poolDictionaries: ''''
	category: ''', self category, ''''
!

Character class removeSelector: #immediateNumericValue:!

!methodRemoval: Character class #immediateNumericValue: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
immediateNumericValue: anInteger
	"Answer the Character whose value is anInteger, if instances happen to be immediate (i.e. as in Spur)"

	<primitive: 170>
	^self primitiveFailed!

Character class removeSelector: #nonImmediateNumericValue:!

!methodRemoval: Character class #nonImmediateNumericValue: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
nonImmediateNumericValue: anInteger
	"Answer the Character whose value is anInteger, if instances happen to be regular (i.e. not in Spur)"


	CharacterTable ifNil: [
		CharacterTable := (0 to: 255) collect: [ :i | Character basicNew instVarAt: 1 put: i; yourself ]].
	^CharacterTable at: anInteger + 1!

Character removeSelector: #nonImmediateNumericValue!

!methodRemoval: Character #nonImmediateNumericValue stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
nonImmediateNumericValue
	"Answer the numeric value of the receiver, if instances happen to be regular (i.e. not in Spur)"

	^self instVarAt: 1!

Character removeSelector: #immediateNumericValue!

!methodRemoval: Character #immediateNumericValue stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
immediateNumericValue
	"Answer the numeric value of the receiver, if instances happen to be immediate (i.e. as in Spur)"

	<primitive: 171>
	^self primitiveFailed!

ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!

!methodRemoval: ClassBuilder #computeFormat:instSize:forSuper:ccIndex: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
computeFormat: type instSize: newInstSize forSuper: newSuper ccIndex: ccIndex
	"Compute the new format for making oldClass a subclass of newSuper.
	Return the format or nil if there is any problem."

	| instSize isVar isWords isPointers isWeak |

	"Spur uses this version"
	Smalltalk isSpur ifTrue: [
		^ self computeFormat: type fullInstancesSize: (newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize])) ].

	"This for preSpur images"
	type == #compiledMethod
		ifTrue:[^CompiledMethod format].
	instSize := newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize]).
	instSize > 254 ifTrue:[
		self error: 'Class has too many instance variables (', instSize printString,')'.
		^nil].
	type == #normal ifTrue:[isVar := isWeak := false. isWords := isPointers := true].
	type == #bytes ifTrue:[isVar := true. isWords := isPointers := isWeak := false].
	type == #words ifTrue:[isVar := isWords := true. isPointers := isWeak := false].
	type == #variable ifTrue:[isVar := isPointers := isWords := true. isWeak := false].
	type == #weak ifTrue:[isVar := isWeak := isWords := isPointers := true].
	isVar ifNil: [ self error: 'Unsupported class format type: ', type. ^ nil ].
	(isPointers not and:[instSize > 0]) ifTrue:[
		self error:'A non-pointer class cannot have instance variables'.
		^nil].
	^(self format: instSize 
		variable: isVar 
		words: isWords 
		pointers: isPointers 
		weak: isWeak) + (ccIndex bitShift: 11)!

ClassBuilder removeSelector: #format:variable:words:pointers:weak:!

!methodRemoval: ClassBuilder #format:variable:words:pointers:weak: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak

	"Only for preSpur!!"

	"Compute the format for the given instance specfication."
	| cClass instSpec sizeHiBits fmt |
"
	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.
	For now the format word is...
		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>
	But when we revise the image format, it should become...
		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>
"
	sizeHiBits := (nInstVars+1) // 64.
	cClass := 0.  "for now"
	instSpec := isWeak
		ifTrue:[4]
		ifFalse:[isPointers
				ifTrue: [isVar
						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]
						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]
				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].
	fmt := sizeHiBits.
	fmt := (fmt bitShift: 5) + cClass.
	fmt := (fmt bitShift: 4) + instSpec.
	fmt := (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"
	fmt := (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"
	^fmt!

Class removeSelector: #becomeCompactSimplyAt:!

!methodRemoval: Class #becomeCompactSimplyAt: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
becomeCompactSimplyAt: index
	"Make me compact, but don't update the instances.  For importing segments."
"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."
	| cct |

	Smalltalk isSpur ifTrue: [^ self error: 'No Compact Classes support in Spur'].
	self isWeak ifTrue:[^ self error: 'You must not make a weak class compact'].
	cct := Smalltalk compactClassesArray.
	(self indexIfCompact > 0 or: [cct includes: self])
		ifTrue: [^ self error: self name , 'is already compact'].
	(cct at: index) ifNotNil: [^ self error: 'compact table slot already in use'].
	"Install this class in the compact class table"
	cct at: index put: self.
	"Update instspec so future instances will be compact"
	format := format + (index bitShift: 11).
	"Caller must convert the instances"
!

Class removeSelector: #becomeCompact!

!methodRemoval: Class #becomeCompact stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
becomeCompact
	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."
	| cct index |

	Smalltalk isSpur ifTrue: [^ self error: 'No Compact Classes support in Spur'].
	self isWeak ifTrue:[^ self error: 'You must not make a weak class compact'].
	cct := Smalltalk compactClassesArray.
	(self indexIfCompact > 0 or: [cct includes: self])
		ifTrue: [^ self error: self name , 'is already compact'].
	index := cct indexOf: nil
		ifAbsent: [^ self error: 'compact class table is full'].
	"Install this class in the compact class table"
	cct at: index put: self.
	"Update instspec so future instances will be compact"
	format := format + (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Purge any old instances"
	Smalltalk garbageCollect.!

Class removeSelector: #becomeUncompact!

!methodRemoval: Class #becomeUncompact stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
becomeUncompact
	| cct index |
	cct := Smalltalk compactClassesArray.
	(index := self indexIfCompact) = 0
		ifTrue: [^ self].
	(cct includes: self)
		ifFalse: [^ self error:  'inconsistent state of compact classes'].
	"Update instspec so future instances will not be compact"
	format := format - (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Make sure there are no compact ones left around"
	Smalltalk garbageCollect.
	"Remove this class from the compact class table"
	cct at: index put: nil.
!

ClassDescription removeSelector: #updateInstancesFrom:!

!methodRemoval: ClassDescription #updateInstancesFrom: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
updateInstancesFrom: oldClass
	"Recreate any existing instances of the argument, oldClass, as instances of 
	 the receiver, which is a newly changed class. Permute variables as necessary,
	 and forward old instances to new instances.. Answer nil to defeat any clients
	 that expected the old behaviour of answering the array of old instances."
	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:
	jmv 1/29/2019: Detect the problem and prevent mutation if that is the case."
	| allInstances newMethod oldMethod selector |
	allInstances := oldClass allInstances.
	allInstances notEmpty ifTrue: [
		Processor 
			processesDo: [ :p | ]
			withStackFramestDo: [ :process :context |
				(context receiver isKindOf: oldClass) ifTrue: [
					selector := context method selector.
					oldMethod := oldClass lookupSelector: selector.
					newMethod := self lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: context receiver class name, ' has some instance running #', selector, '. This CompiledMethod would become invalid. Class reshaping aborted.' ]]]
			runningProcessSearchStart: nil.
		self updateInstances: allInstances asArray from: oldClass isMeta: self isMeta ].
	^nil

"This attempts to crash the VM by stepping off the end of an instance.
 As the doctor says, do not do this."
"	| crashingBlock class |
	class := Object subclass: #CrashTestDummy
		instanceVariableNames: 'instVar'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	class compile:'instVar: value instVar := value'.
	class compile:'crashingBlock ^[instVar]'.
	crashingBlock := (class new) instVar: 42; crashingBlock.
	Object subclass: #CrashTestDummy
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	crashingBlock value"!

Behavior removeSelector: #typeOfClassSpur!

!methodRemoval: Behavior #typeOfClassSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
typeOfClassSpur
	"Answer a symbol uniquely describing the type of the receiver. c.f. kindOfSubclass, instSpec"
	^(#(normal
		normal
		variable
		variable
		weak
		ephemeron
		nil
		immediate
		nil
		longs
		words				nil
		shorts				nil nil nil
		bytes				nil nil nil nil nil nil nil
		compiledMethod	nil nil nil nil nil nil nil)
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']!

Behavior removeSelector: #kindOfSubclassSpur!

!methodRemoval: Behavior #kindOfSubclassSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
kindOfSubclassSpur
	"Answer a String that is the keyword that describes the receiver's kind of subclass,
	 either a regular subclass, a variableSubclass, a variableByteSubclass,
	 a variableWordSubclass, a weakSubclass, an ephemeronSubclass or an immediateSubclass.
	 c.f. typeOfClass & instSpec"
	^(#(' subclass: '
		' subclass: '
		' variableSubclass: '
		' variableSubclass: '
		' weakSubclass: '
		' ephemeronSubclass: '
		nil
		' immediateSubclass: '
		nil
		' variableDoubleWordSubclass: '
		' variableWordSubclass: '		nil
		' variableDoubleByteSubclass: '	nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil )
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']!

Behavior removeSelector: #indexIfCompact!

!methodRemoval: Behavior #indexIfCompact stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
indexIfCompact
	"If these 5 bits are non-zero, then instances of this class
	will be compact.  It is crucial that there be an entry in
	Smalltalk compactClassesArray for any class so optimized.
	See the msgs becomeCompact and becomeUncompact."

	"Spur doesn't allow Compact Classes"
	Smalltalk isSpur ifTrue: [ ^ 0 ].

	^ (format bitShift: -11) bitAnd: 16r1F
"
Smalltalk compactClassesArray withIndexDo: 
	[:c :i | c == nil ifFalse:
		[c indexIfCompact = i ifFalse: [self halt]]]
"!

Behavior removeSelector: #primitiveIdentityHash!

!methodRemoval: Behavior #primitiveIdentityHash stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
primitiveIdentityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	 Behavior implements identityHash to allow the VM to use an object representation which
	 does not include a direct reference to an object's class in an object.  If the VM is using
	 this implementation then classes are held in a class table and instances contain the index
	 of their class in the table.  A class's class table index is its identityHash so that an instance
	 can be created without searching the table for a class's index.  The VM uses this primitive
	 to enter the class into the class table, assigning its identityHash with an as yet unused
	 class table index. If this primitive fails it means that the class table is full.  In Spur as of
	 2014 there are 22 bits of classTable index and 22 bits of identityHash per object.

	 Primitive. Essential. Do not override. See Object documentation whatIsAPrimitive."

	<primitive: 175>
	self primitiveFailed.!

Behavior removeSelector: #isVariableSpur!

!methodRemoval: Behavior #isVariableSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
isVariableSpur
	"Answer whether the receiver has indexable variables.
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	^instSpec >= 2 and: [instSpec <= 4 or: [instSpec >= 9]]!

Behavior removeSelector: #isVariablePreSpur!

!methodRemoval: Behavior #isVariablePreSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
isVariablePreSpur
	"Answer whether the receiver has indexable variables."

	^ self instSpec >= 2!

Behavior removeSelector: #typeOfClassPreSpur!

!methodRemoval: Behavior #typeOfClassPreSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
typeOfClassPreSpur
	"Answer a symbol uniquely describing the type of the receiver"
	self instSpec = CompiledMethod instSpec ifTrue:[^#compiledMethod]. "Very special!!"
	self isBytes ifTrue:[^#bytes].
	(self isWords and:[self isPointers not]) ifTrue:[^#words].
	self isWeak ifTrue:[^#weak].
	self isVariable ifTrue:[^#variable].
	^#normal.!

Behavior removeSelector: #kindOfSubclassPreSpur!

!methodRemoval: Behavior #kindOfSubclassPreSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
kindOfSubclassPreSpur
	"Answer a String that is the keyword that describes the receiver's kind 
	of subclass, either a regular subclass, a variableSubclass, a  
	variableByteSubclass, a variableWordSubclass, or a weakSubclass."
	self isWeak
		ifTrue: [^ ' weakSubclass: '].
	^ self isVariable
		ifTrue: [self isBits
				ifTrue: [self isBytes
						ifTrue: [ ' variableByteSubclass: ']
						ifFalse: [ ' variableWordSubclass: ']]
				ifFalse: [ ' variableSubclass: ']]
		ifFalse: [ ' subclass: ']!

SmallInteger class removeSelector: #definition!

!methodRemoval: SmallInteger class #definition stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Integer immediateSubclass: #SmallInteger
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''', self category, ''''!

SmallFloat64 class removeSelector: #definition!

!methodRemoval: SmallFloat64 class #definition stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:39:06'!
definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Float immediateSubclass: #SmallFloat64
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''', self category, ''''
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st----!

'From Cuis6.3 [latest update: #6164] on 4 January 2024 at 4:34:47 pm'!

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CharacterTable '
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st 1/30/2024 19:39:06'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CharacterTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character class removeSelector: #initialize!

!methodRemoval: Character class #initialize stamp: 'Install-6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st 1/30/2024 19:39:06'!
initialize
	"
	Character initialize
	"
	Character isImmediateClass ifTrue: [
		CharacterTable := nil ].!

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st 1/30/2024 19:39:06'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6164] on 4 January 2024 at 4:58:37 pm'!
!Object methodsFor: 'system primitives' stamp: 'jmv 9/25/2023 16:38:31' prior: 16915122!
                       primitiveChangeClassTo: anObject
	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.
	Note: The primitive will fail in most cases that you think might work. This is mostly because of because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for two of the reasons mentioned above. Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).
	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."

	<primitive: 115>
	self primitiveFailed! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 16:57:28' prior: 50335801!
                 isVariable
	"Answer whether the receiver has indexable variables.
	 Class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	(instSpec between: 2 and: 4) ifTrue: [ ^true ].
	^instSpec >= 9! !
!Character methodsFor: 'comparing' stamp: 'jmv 9/25/2023 16:46:30' prior: 50336482 overrides: 50335599!
                               identityHash
	"Answer the receiver's character code."
	<primitive: 171>
	^self primitiveFailed! !
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 9/25/2023 16:55:34' prior: 50336754!
                             recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	newArray at: 25 put: nil. "This is nil in Spur, which has immediate Characters."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "This is nil in Spur, no compact classes."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization.
	In Squeak these are: DoubleByteArray, WordArray, DoubleWordArray.
	Understand why."
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.
	newArray at: 36 put: nil. "was the prototype MethodContext"
	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray
	! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 9/25/2023 17:17:28' prior: 50336945!
                       vmParameterAt: parameterIndex
	"parameterIndex is a positive integer corresponding to one of the VM's internal parameter/metric registers. 
	Answer with the current value of that register.
	Answer nil if the VM doesn't provide the register, and the primitive fails.
	
	Also see #getVMParameters and #vmParameterAt:put: These 3 methods call the 
	same primitive, whose behavior depends on argument count:
		0 args:	return an Array of VM parameter values;
  		1 arg:	return the indicated VM parameter;
  		2 args:	set the VM indicated parameter.

	VM parameters are numbered as follows:
		1	byte size of old-space (read-only)
		2	byte size of young-space (read-only)
		3	byte size of object memory (read-only)
		4	nil (was allocationCount (read-only))
		5	nil (was allocations between GCs (read-write)
		6	survivor count tenuring threshold (read-write)
		7	full GCs since startup (read-only)
		8	total milliseconds in full GCs since startup (read-only)
		9	Scavenging GCs
		10	total milliseconds in scavenging GCs since startup (read-only) since startup (read-only)
		11	tenures of surving objects since startup/last write (read-write)
		12	event trace mask; if 1 << eventType is set in the mask then event received by primGetNextEvent: will be printed to stderr.
		13	VM ticker start microseconds (Croquet/QwaqVM only)
		14	VM ticker count (Croquet/QwaqVM only)
		15	VM ticker call count (Croquet/QwaqVM only)
		16	total microseconds at idle since start-up (if non-zero)
		17	fraction of the code zone to use (Sista only; used to control code zone use to preserve sendAndBranchData on counter tripped callback)
		18	total milliseconds in full GC compaction since startup (a portion of parameter 8)
		19	scavenge threshold, the effective size of eden.  When eden fills to the threshold a scavenge is scheduled.
		20	utc microseconds at VM start-up (actually at time initialization, which precedes image load).
		21	root/remembered table size (occupancy) (read-only)
		22	root table overflows since startup (read-only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored in image file header).
		24	memory threshold above which to shrink object memory (read-write)
		25	ammount to grow by when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking
		28	number of times sweep loop iterated for current IGC/FGC (read-only)
		29	number of times make forward loop iterated for current IGC/FGC (read-only)
		30	number of times compact move loop iterated for current IGC/FGC (read-only)
		31	number of grow memory requests (read-only)
		32	number of shrink memory requests (read-only)
		33	number of root table entries used for current IGC/FGC (read-only)
		34	bytes allocated in total since start-up or reset (read-write)
		35	number of survivor objects after current IGC/FGC (read-only)
		36	millisecond clock when current IGC/FGC completed (read-only)
		37	number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)
		38	milliseconds taken by current IGC (read-only)
		39	Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)
		40	BytesPerOop for this image
		41	imageFormatVersion for the VM
		42	number of stack pages in use (Cog Stack VM only, otherwise nil)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		44	size of eden, in bytes (Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		46	size of machine code zone, in bytes (stored in image file header; Cog JIT VM only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties stored in the image header (that instruct the VM) as an integer encoding an array of bit flags. 
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: in a Spur vm, if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	the size of the external semaphore table (read-write; Cog VMs only)
		50-51 reserved for VM parameters that persist in the image (such as eden above)
		52	root (remembered) table maximum size (read-only)
		53	the number of oldSpace segments (Spur only, otherwise nil)
		54	total size of free old space (Spur only, otherwise nil)
		55	ratio of growth and image size at or above which a GC will be performed post scavenge
		56	number of process switches since startup (read-only)
		57	number of ioProcessEvents calls since startup (read-only)
		58	number of forceInterruptCheck (Cog VMs) or quickCheckInterruptCalls (non-Cog VMs) calls since startup (read-only)
		59	number of check event calls since startup (read-only)
		60	number of stack page overflows since startup (read-only; Cog VMs only)
		61	number of stack page divorces since startup (read-only; Cog VMs only)
		62	number of machine code zone compactions since startup (read-only; Cog VMs only)
		63	milliseconds taken by machine code zone compactions since startup (read-only; Cog VMs only)
		64	current number of machine code methods (read-only; Cog VMs only)		
		65	In newer Cog VMs a set of flags describing VM features,
				if non-zero bit 0 implies multiple bytecode set support;
				if non-zero bit 1 implies read-only object support;
				if non-zero bit 2 implies the VM suffers from using an ITIMER heartbeat (if 0 it has a thread that provides the heartbeat)
			(read-only; Cog VMs only; nil in older Cog VMs, a boolean answering multiple bytecode support in not so old Cog VMs)
				if non-zero bit 3 implies the VM supports cross-platform BIT_IDENTICAL_FLOATING_POINT arithmetic
				if non-zero bit 4 implies the VM can catch exceptions in FFI calls and answer them as primitive failures
				if non-zero bit 5 implies the VM's suspend primitive backs up the process to before the wait if it was waiting on a condition variable
		66	the byte size of a stack page in the stack zone  (read-only; Cog VMs only)
		67	the maximum allowed size of old space in bytes, 0 implies no internal limit (Spur VMs only).
		68	the average number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		69	the maximum number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		70	the value of VM_PROXY_MAJOR (the interpreterProxy major version number)
		71	the value of VM_PROXY_MINOR (the interpreterProxy minor version number)
		72	total milliseconds in full GCs Mark phase since startup (read-only)
		73	total milliseconds in full GCs Sweep phase since startup (read-only, can be 0 depending on compactors)
		74	maximum pause time due to segment allocation
		75	whether arithmetic primitives will do mixed type arithmetic; if false they fail for different receiver and argument types
		76	the minimum unused headroom in all stack pages; Cog VMs only"

	<primitive: 254>
	(parameterIndex isInteger
	 and: [parameterIndex > 0]) ifTrue:
		[^nil].
	self primitiveFailed! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 9/25/2023 17:19:48' prior: 50337146!
      vmParameterAt: parameterIndex put: newValue
	"parameterIndex is a positive integer corresponding to one of the VM's internal
	parameter/metric registers.  Store newValue (a positive integer) into that
	register and answer with the previous value that was stored there.
	Fail if newValue is out of range, if parameterIndex has no corresponding
	register, or if the corresponding register is read-only.

	As of late 2020 the parameters which can be set are
		5	allocations between GCs (read-write; nil in Cog VMs)
		6	survivor count tenuring threshold (read-write)
		11	tenures of surving objects since startup/last write (read-write)
		12	event trace mask; if 1 << eventType is set in the mask then event received by primGetNextEvent: will be printed to stderr.
		17	proportion of code zone available for use (Sista VMs only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc.
		24	memory threshold above whichto shrink object memory (read-write)
		25	memory headroom when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		34	bytes allocated in total since start-up or reset (read-write)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties of the Cog VM as an integer encoding an array of bit flags.
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: in a Spur vm, if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	the size of the external semaphore table (read-write; Cog VMs only)
		55	ratio of growth and image size at or above which a GC will be performed post scavenge (Spur only, otherwise nil)
		67	the maximum allowed size of old space in bytes, 0 implies no internal limit (Spur only).
		68	the average number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		69	the maximum number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		74 maximum pause time due to segment allocation
		75 whether arithmetic primitives will do mixed type arithmetic; if false they fail for different receiver and argument types"

	<primitive: 254>
	self primitiveFailed! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 9/25/2023 16:02:21' prior: 50337664!
             printSpaceAnalysis: threshold on: aStream
	"Warning!!
	This is most likely wrong. It was written for 32 bit V3 images.
	Please take a look at #spaceForInstancesOf:
	Review both methods, and any other one that might be related.
	"
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.
	results := OrderedCollection new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace := cl spaceUsed.
				barBlock value: (n := n+1).
				Smalltalk garbageCollectMost.
				instCount := cl instanceCount.
				instSpace := 8 * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize := cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace := instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace := instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace := totalCodeSpace + codeSpace.
				totalInstCount := totalInstCount + instCount.
				totalInstSpace := totalInstSpace + instSpace]].
	totalPercent := 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent := s spaceForInstances*100.0/totalInstSpace.
		totalPercent := totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6174-SpurImageFormatOnly03-JuanVuletich-2024Jan04-16h34m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6167] on 6 January 2024 at 3:16:13 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 1/4/2024 21:28:30'!
                            isValidInFilenames
	"Can be part of a filename?
		$< isValidInFilenames
		$a isValidInFilenames
		$| isValidInFilenames
		$^ isValidInFilenames
		$: isValidInFilenames
	"
	self isNullCharacter ifTrue: [ ^false ].
	self isSeparator ifTrue: [ ^false ].
	^(#( $: $< $> $| $/ $\ $? $* $") statePointsTo: self) not.! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 1/6/2024 15:06:55'!
                              isValidInFilenames
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isValidInFilenames ].
	^true! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/4/2024 21:29:27' prior: 16813418!
    asFileName
	"Answer a String made up from the receiver that is an acceptable file name."

	^ self collect: [ :char |
		char isValidInFilenames
			ifFalse: [$#] 
			ifTrue: [char]].! !

CharacterSequence removeSelector: #indexOfAnyOf:!

!methodRemoval: CharacterSequence #indexOfAnyOf: stamp: 'Install-6175-String-refactor-JuanVuletich-2024Jan06-14h57m-jmv.004.cs.st 1/30/2024 19:39:06'!
indexOfAnyOf: aCharacterSet
	"returns the index of the first character in the given set, starting from 1."

	^ self indexOfAnyOf: aCharacterSet startingAt: 1 ifAbsent: 0!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6175-String-refactor-JuanVuletich-2024Jan06-14h57m-jmv.004.cs.st----!

'From Cuis6.3 [latest update: #6168] on 6 January 2024 at 3:54:22 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 1/4/2024 22:06:45'!
                          findFirstBasicAt: aBlock startingAt: firstIndex
	"Return the index of my first element for which aBlock evaluates as true.
	Start at firstIndex.
	Use #basicAt: for accessing elements, not #at:
	This means, for String, evaluate aBlock on each byte."

	| s index |
	s := self size.
	index := firstIndex.
	[
		index <= s ] whileTrue: [
			(aBlock value: (self basicAt: index)) ifTrue: [^index ].
			index := index + 1.
			].
	^ 0! !
!String methodsFor: 'accessing' stamp: 'jmv 1/6/2024 15:26:41'!
                  indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	aByteSetByteArray is a ByteArray of size 256 with a 1 for byte values considered to be included."

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aByteSetByteArray startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/6/2024 15:31:57'!
                          indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start."

	"Fast lane."
	| index |
	self isAscii ifTrue: [
		^ bytes indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock ].

	"If only ASCII bytes are included in the map..."
	(ByteArray indexOfByte: 1 inBytes: aByteSetByteArray startingAt: 128) = 0 ifTrue: [
		|startBI foundBI|
		startBI := self byteIndexAt: start.
		foundBI := bytes indexOfAnyIn: aByteSetByteArray startingAt: startBI ifAbsent: aBlock.
		^ self codePointIndexAt: foundBI ].

	index := start.
	self do: [ :codePoint |
		codePoint iso8859s15Code ifNotNil: [ :ii |
			(aByteSetByteArray at: ii + 1) > 0 ifTrue: [ ^index ]].
		index := index + 1].

	^aBlock value! !
!ByteArray methodsFor: 'accessing' stamp: 'jmv 1/6/2024 15:32:59'!
       indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	aByteSetByteArray is a ByteArray of size 256 with a 1 for byte values considered to be included."

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aByteSetByteArray startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]! !
!String methodsFor: 'converting' stamp: 'jmv 1/6/2024 15:37:39' prior: 16960260!
                unescapePercents
	"change each %XY substring to the character with ASCII value XY in hex.
	This is the opposite of #percentEscapingNonAscii: and #percentEscapingNonAsciiAndThoseIn:bytes:
	(String percentEscapingNonAscii: '' bytes) unescapePercents
	'%E2%8A%99' unescapePercents
	"

	| myBytes answerClass answerBytes c decodedByte pos oldPos specialCharsByteSet |
	myBytes := self asByteArray.
	specialCharsByteSet := `ByteArray new: 256 :: at: $+ asciiValue + 1 put: 1; at: $% asciiValue + 1 put: 1; yourself`.
	answerClass := String.
	answerBytes := ByteArray streamContents: [ :byteStream |
		oldPos := 1.

		[pos := myBytes indexOfAnyIn: specialCharsByteSet startingAt: oldPos ifAbsent: [ 0 ]. pos > 0 ]
		whileTrue: [
			byteStream nextPutAll: (myBytes copyFrom: oldPos to: pos - 1).
			c := self at: pos.
			c = $+ ifTrue: [byteStream nextPut: `$  asciiValue` ] ifFalse: [
				(c = $% and: [pos + 2 <= self size]) ifTrue: [
					decodedByte := (self at: pos+1) asUppercase digitValue * 16 +
						(self at: pos+2) asUppercase digitValue.
					pos := pos + 2.
					decodedByte > 255 ifTrue: [^self].	"not really an escaped string"
					decodedByte > 127 ifTrue: [ answerClass := UnicodeString ].
					byteStream nextPut: decodedByte ]
				ifFalse: [byteStream nextPut: c numericValue ]].
			oldPos := pos+1].
		byteStream nextPutAll: (myBytes copyFrom: oldPos to: self size).
	].
	^ answerClass fromUtf8Bytes: answerBytes! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:50:03' prior: 16960790!
                  isAscii: aStringOrByteArray
	"Return true if all bytes in argument are less than 128.
	This means it is a pure 7-bit ASCII.
	Valid both for instances of String (possibly with accented latin letters or other Character)
	and for utf-8 encoded ByteArrays.
	In these cases, the bytes represent the same ascii string both as String and as Utf8.
	See also #nextUtf8BytesAndCodePointInto:into:, #ascii and #nonAscii"

	| nonAsciiBytesSetBA |
	nonAsciiBytesSetBA := `(ByteArray new: 128), ((ByteArray new: 128) + 1)`.
	^ (ByteArray
		findFirstInBytes: aStringOrByteArray
		inSet: nonAsciiBytesSetBA
		startingAt: 1)
			= 0.! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:39:20' prior: 16960812!
string: aString lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| charSetLineEnders start end endWithoutDelimiters |
	charSetLineEnders := `ByteArray new: 256 :: at: Character cr asciiValue + 1 put: 1; at: Character lf asciiValue + 1 put: 1; yourself`.
	start := 1.
	[
		end := aString indexOfAnyIn: charSetLineEnders startingAt: start ifAbsent: [ 0 ].
		end = 0
			ifTrue: [
				"Last line was found. Evaluate and exit.
				Note. If last char in receiver is a line separator, there's an extra empty line"
				endWithoutDelimiters := end := aString size.
				aBlock value: start value: endWithoutDelimiters value: end.
				^aString ].

		"Account for CrLf sequence"
		endWithoutDelimiters := end - 1.
		(end < aString size
			and: [(aString basicAt: end + 1) = `Character lf asciiValue`
			and: [(aString basicAt: end) = `Character cr asciiValue` ]])
				ifTrue: [ end := end + 1].

		aBlock value: start value: endWithoutDelimiters value: end.
		start := end + 1 ] repeat! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:40:11' prior: 16960845!
                             string: aByteStringOrByteArray withLineEndings: newLineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"
	| cr lf charSetLineEnders inPos outPos outString lineEndPos newOutPos lineEndingSize |
	cr := Character cr.
	lf := Character lf.
	charSetLineEnders := `ByteArray new: 256 :: at: Character cr asciiValue + 1 put: 1; at: Character lf asciiValue + 1 put: 1; yourself`.
	(aByteStringOrByteArray is: #ByteArray)
		ifTrue: [
			cr := cr asciiValue.
			lf := lf asciiValue ].

	inPos := 1.
	outPos := 1.
	lineEndingSize := newLineEndingString size.
	"This could be extremely inefficient if lineEndingString size > 1"
	outString := aByteStringOrByteArray class new: aByteStringOrByteArray size * lineEndingSize.

	[
		lineEndPos := aByteStringOrByteArray indexOfAnyIn: charSetLineEnders startingAt: inPos ifAbsent: [0].
		lineEndPos ~= 0 ] whileTrue: [
			newOutPos := outPos + (lineEndPos - inPos).
			outString replaceFrom: outPos to: newOutPos - 1 with: aByteStringOrByteArray startingAt: inPos.
			1 to: lineEndingSize do: [ :i |
				outString at: newOutPos put: (newLineEndingString at: i).
				newOutPos := newOutPos + 1 ].
			outPos := newOutPos.
			((aByteStringOrByteArray at: lineEndPos) = cr and: [
					lineEndPos < aByteStringOrByteArray size and: [ (aByteStringOrByteArray at: lineEndPos+1) = lf ] ]) ifTrue: [
				"CRLF ending"
				inPos := lineEndPos + 2 ]
			ifFalse: [ 
				"CR or LF ending"
				inPos := lineEndPos + 1 ]].

	"no more line endings.  copy the rest"
	newOutPos := outPos + (aByteStringOrByteArray size - inPos).
	outString replaceFrom: outPos to: newOutPos with: aByteStringOrByteArray startingAt: inPos.

	^outString copyFrom: 1 to: newOutPos! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:47:19' prior: 16960896!
                         substringsIn: aByteStringOrByteArray
	"Answer an array of the substrings that compose the argument.
	If argument is an UTF-8 encoded ByteArray, answer is an array of same."

	| end beginning charSetNonSeparators charSetSeparators |
	charSetSeparators := `ByteArray new: 256 ::
		at: Character space asciiValue + 1 put: 1;
		at: Character tab asciiValue + 1 put: 1;
		at: Character lf asciiValue + 1 put: 1;
		at: Character cr asciiValue + 1 put: 1;
		at: Character newPage asciiValue + 1 put: 1;
		yourself`.
	charSetNonSeparators := `ByteArray new: 256 :: += 1;
		at: Character space asciiValue + 1 put: 0;
		at: Character tab asciiValue + 1 put: 0;
		at: Character lf asciiValue + 1 put: 0;
		at: Character cr asciiValue + 1 put: 0;
		at: Character newPage asciiValue + 1 put: 0;
		yourself`.
	end := 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning := aByteStringOrByteArray indexOfAnyIn: charSetNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end := aByteStringOrByteArray indexOfAnyIn: charSetSeparators startingAt: beginning ifAbsent: [ aByteStringOrByteArray size + 1 ].
			end := end - 1.
			result nextPut: (aByteStringOrByteArray copyFrom: beginning to: end).
		]
	].! !
!ByteArray class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:50:15' prior: 16801681!
        findFirstInBytes: aByteArrayOrByteString inSet: aByteSetByteArray startingAt: start
	| i stringSize |
	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>

	aByteSetByteArray size ~= 256 ifTrue: [ ^0 ].

	i := start.
	stringSize := aByteArrayOrByteString size.
	[ i <= stringSize and: [ (aByteSetByteArray at: (aByteArrayOrByteString basicAt: i) +1) = 0 ] ] whileTrue: [ 
		i := i + 1 ].

	i > stringSize ifTrue: [ ^0 ].
	^i! !

ByteArray removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!

!methodRemoval: ByteArray #indexOfAnyOf:startingAt:ifAbsent: stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]!

UnicodeString removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!

!methodRemoval: UnicodeString #indexOfAnyOf:startingAt:ifAbsent: stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start."

	"Fast lane."
	| index |
	self isAscii ifTrue: [
		^ bytes indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock ].
	aCharacterSet isAscii ifTrue: [ |startBI foundBI|
		startBI := self byteIndexAt: start.
		foundBI := bytes indexOfAnyOf: aCharacterSet startingAt: startBI ifAbsent: aBlock.
		^ self codePointIndexAt: foundBI ].

	index := start.
	self do: [ :codePoint |
		(aCharacterSet includes: codePoint) ifTrue: [ ^index ].
		index := index + 1].

	^aBlock value!

String class removeSelector: #basicCharSetNonSeparators!

!methodRemoval: String class #basicCharSetNonSeparators stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
basicCharSetNonSeparators
	"CR and LF--characters that terminate a line"
	| answer |
	answer := CharacterSet new.
	0 to: 255 do: [ :i | | char |
		char := Character numericValue: i.
		char isSeparator ifFalse: [
			answer add: char ]].
	^answer!

String class removeSelector: #charSetSeparators!

!methodRemoval: String class #charSetSeparators stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
charSetSeparators
	"CR and LF--characters that terminate a line"
	^`CharacterSet new addAll: Character separators; yourself`.!

String class removeSelector: #charSetLineEnders!

!methodRemoval: String class #charSetLineEnders stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
charSetLineEnders
	"CR and LF--characters that terminate a line"
	^`CharacterSet new
		add: Character cr;
		add: Character lf;
		yourself`.!

String class removeSelector: #charSetNonSeparators!

!methodRemoval: String class #charSetNonSeparators stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
charSetNonSeparators
	"CR and LF--characters that terminate a line"
	^`String basicCharSetNonSeparators`.!

String removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!

!methodRemoval: String #indexOfAnyOf:startingAt:ifAbsent: stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]!

Collection removeSelector: #asCharacterSet!

!methodRemoval: Collection #asCharacterSet stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
asCharacterSet
	"Answer a CharacterSet whose elements are the unique elements of the receiver.  The receiver should only contain characters"

	^self as: CharacterSet!

Smalltalk removeClassNamed: #CharacterSet!

!classRemoval: #CharacterSet stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:39:07'!
Collection subclass: #CharacterSet
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6169] on 8 January 2024 at 9:39:36 am'!
!Character class methodsFor: 'converting' stamp: 'jmv 1/7/2024 19:23:27'!
      utf8BytesAndCodePointForIso8859s1: byte into: bytesBlock into: codePointBlock
	"Latin-1"
	| codePoint |
	codePoint := byte.
	bytesBlock ifNotNil: [
		Character
			evaluateOnce: bytesBlock
			withUtf8BytesOfUnicodeCodePoint: codePoint ].
	codePointBlock ifNotNil: [
		codePointBlock value: codePoint ].
	^1! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/7/2024 19:09:14' prior: 16810759!
                        codePoint
	"Unicode codePoint is blah blah blah"
	"
	self assert: $A codePoint hex = '16r41'.
	self assert: $ codePoint hex = '16r20AC'.
	"
	<primitive: 171>
	^self primitiveFailed! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 08:44:44' prior: 16811258!
    codePoint: codePoint
	"
	Answer nil if the Unicode codePoint is not a valid ISO 8859-1 character
	
	self assert: (Character codePoint: 16r41) = $A.
	self assert: (Character codePoint: 16r20AC) = $.
	"
	^ codePoint < 256 ifTrue: [
		Character numericValue: codePoint ].! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/7/2024 19:30:48' prior: 16811672!
                   utf8BytesAndCodePointFor: byte1 byte2: byte2 byte3: byte3 byte4: byte4 into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in argument bytes.
	Evaluate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, consider the first byte an ISO-8859-1 Character, and answer 1.
	Skip codePoint U+FEFF (BOM, unneededly added by Win clipboard). Still, answer the number of bytes of the BOM sequence, to allow senders to update an index in an iteration.
	See senders."

	| codePoint |
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ 1 ].
	
	"At least 2 bytes"
	(byte2 notNil and: [ (byte2 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
		^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rE0) = 16rC0  ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^2 ].
	
	"At least 3 bytes"
	(byte3 notNil and: [ (byte3 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
		^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rF0) = 16rE0  ifTrue: [ "three bytes"
		codePoint :=  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ "BOM. Ignore it. Skip ti."
			^3 ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^3 ].

	"4 bytes"
	(byte4 notNil and: [ (byte4 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
		^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rF8) = 16rF0  ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint := ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		^ 4].

	"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
	^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock.! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 1/8/2024 09:20:21' prior: 16992461!
    numericValue
self flag: #unicodeNeedsImprovement.
"To be removed. make it the Latin-1 codePoint for the time being.
This doesn't make much sense."
	value < 256 ifTrue: [ ^value ].
	^255! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 1/7/2024 19:41:52' prior: 16992669!
         < aCodePointOrCharacter
"pensar"
	^self codePoint < aCodePointOrCharacter codePoint! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 1/8/2024 09:19:22' prior: 16992707 overrides: 16913626!
                           hash
	"Hash is reimplemented because = is implemented."

	^value hash! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:04:18' prior: 16992720!
                            asLowercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character numericValue: value) asLowercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:13:07' prior: 16992740!
                    asUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character numericValue: value) asUnaccented codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:04:26' prior: 16992752!
                  asUppercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character numericValue: value) asUppercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:20' prior: 16992471!
                    isAccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character numericValue: value) isAccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:14' prior: 16992564!
                           isUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character numericValue: value) isUnaccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:46' prior: 50339511!
                       isValidInFilenames
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character numericValue: value) isValidInFilenames ].
	^true! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:07' prior: 16992632!
            isVowel
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^ (Character numericValue: value) isVowel ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:27:04' prior: 16992770!
withDiacriticalMark: anUnicodeCodePoint
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (
			(Character numericValue: value) withDiacriticalMark: anUnicodeCodePoint)
				codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 1/8/2024 09:08:30' prior: 16992789 overrides: 16914834!
printOn: aStream 
	aStream nextPut: $$.
	aStream nextPut: self.
	value <= 32 ifTrue: [
		aStream nextPut: $".
		aStream nextPutAll: self hex.
		aStream nextPut: $" ].! !
!Date methodsFor: 'printing' stamp: 'jmv 1/7/2024 19:44:37' prior: 16842404!
         printOn: aStream format: formatArray 
	"Print a description of the receiver on aStream using the format 
	denoted the argument, formatArray: 
	
		#(item item item sep monthfmt yearfmt twoDigits) 
	
		items: 1=day 2=month 3=year will appear in the order given, 
	
		separated by sep which is eaither an ascii code or character. 
	
		monthFmt: 1=09 2=Sep 3=September 
	
		yearFmt: 1=1996 2=96 
	
		digits: (missing or)1=9 2=09. 
	
	See the examples in printOn: and mmddyy"
	| gregorian twoDigits element monthFormat |
	gregorian := self dayMonthYearDo: [ :d :m :y | {d. m. y} ].
	twoDigits := formatArray size > 6 and: [(formatArray at: 7) > 1].
	1 to: 3 do: 
		[ :i | 
			element := formatArray at: i.
			element = 1
				ifTrue: [twoDigits
						ifTrue: [aStream
								nextPutAll: (gregorian first printString
										padded: #left
										to: 2
										with: $0)]
						ifFalse: [gregorian first printOn: aStream]].
			element = 2
				ifTrue: [monthFormat := formatArray at: 5.
					monthFormat = 1
						ifTrue: [twoDigits
								ifTrue: [aStream
										nextPutAll: (gregorian middle printString
												padded: #left
												to: 2
												with: $0)]
								ifFalse: [gregorian middle printOn: aStream]].
					monthFormat = 2
						ifTrue: [aStream
								nextPutAll: ((Month nameOfMonth: gregorian middle)
										copyFrom: 1
										to: 3)].
					monthFormat = 3
						ifTrue: [aStream
								nextPutAll: (Month nameOfMonth: gregorian middle)]].
			element = 3
				ifTrue: [(formatArray at: 6)
							= 1
						ifTrue: [gregorian last printOn: aStream]
						ifFalse: [aStream
								nextPutAll: ((gregorian last \\ 100) printString
										padded: #left
										to: 2
										with: $0)]].
			i < 3
				ifTrue: [(formatArray at: 4)
							~= 0
						ifTrue: [
							aStream nextPut: ((formatArray at: 4) isNumber
								ifTrue: [ Character numericValue: (formatArray at: 4) ]
								ifFalse: [ (formatArray at: 4) ])
							]]]
! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 08:51:38' prior: 16959655 overrides: 16913367!
    at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	

			aCharacter class == UnicodeCodePoint ifTrue: [
				aCharacter codePoint > 255 ifTrue: [self error: 'String only store Latin-1 Characters'].
				^self at: index put: (Character numericValue: aCharacter codePoint) ].

			aCharacter numericValue > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 09:21:57' prior: 16959727 overrides: 16947063!
                  indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	"String can only hold ASCII + Latin1"
	aCharacter codePoint >255 ifTrue: [ ^ aBlock value ].
	ans := ByteArray indexOfByte: aCharacter codePoint inBytes: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!String methodsFor: 'enumerating' stamp: 'jmv 1/8/2024 08:46:40' prior: 16960316 overrides: 16814129!
                       collect: aBlock
	"Refer to the comment in Collection >> #collect:."
	| array resultClass |
	array := self collectInArray: aBlock.
	resultClass := String.
	array do: [ :element |
		element isCharacter ifFalse: [ ^array ].
		"String can only hold ISO-8859-1 (ASCII + Latin 1 Suplement)"
		element codePoint > 255 ifTrue: [
			resultClass := UnicodeString ]].
	^resultClass newFrom: array! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/8/2024 09:24:00' prior: 50339578!
    indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	The set can only contain ASCII + Latin1 codePoints, i.e. < 256."

	"Fast lane."
	| index |
	self isAscii ifTrue: [
		^ bytes indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock ].

	"If only ASCII bytes are included in the map..."
	(ByteArray indexOfByte: 1 inBytes: aByteSetByteArray startingAt: 128) = 0 ifTrue: [
		|startBI foundBI|
		startBI := self byteIndexAt: start.
		foundBI := bytes indexOfAnyIn: aByteSetByteArray startingAt: startBI ifAbsent: aBlock.
		^ self codePointIndexAt: foundBI ].

	index := start.
	self do: [ :codePoint |
		codePoint < 256 ifTrue: [
			(aByteSetByteArray at: codePoint + 1) > 0 ifTrue: [ ^index ]].
		index := index + 1].

	^aBlock value! !
!RWBinaryOrTextStream methodsFor: 'writing' stamp: 'jmv 1/7/2024 19:45:46' prior: 16934799 overrides: 17008880!
   nextPut: charOrByte

	super nextPut: 
		(charOrByte isCharacter
			ifTrue: [ charOrByte ]
			ifFalse: [ Character numericValue: charOrByte ])! !
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/7/2024 19:46:50' prior: 16853478!
                               asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Same for UnicodeCodePoint and Character.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].
	
	"Prefer Character over UnicodeCodePoint for literals, if ASCII only."
	"bueh......"
	(literalObject class == UnicodeCodePoint and: [ literalObject asciiValue notNil ]) ifTrue: [
		^ Character codePoint: literalObject codePoint ].

	^literalObject! !

UnicodeCodePoint removeSelector: #iso8859s15Code!

!methodRemoval: UnicodeCodePoint #iso8859s15Code stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
iso8859s15Code
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding.
	Any implementation of Character like object beyond ISO-8859-15 should answer nil.
	Senders, please consider that this method might answer nil.
	See #iso8859s15CodeForUnicodeCodePoint:"

	value < 128 ifTrue: [ ^value ]."Plain ASCII"
	self asCharacter ifNotNil: [ :ch | ^ch iso8859s15Code ].
	^nil!

UnicodeCodePoint removeSelector: #asCharacter!

!methodRemoval: UnicodeCodePoint #asCharacter stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
asCharacter
	"Might answer nil"
	^Character codePoint: value!

Character class removeSelector: #unicodeCodePoints!

!methodRemoval: Character class #unicodeCodePoints stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
unicodeCodePoints
	^`Character basicUnicodeCodePoints`!

Character class removeSelector: #basicUnicodeCodePoints!

!methodRemoval: Character class #basicUnicodeCodePoints stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
basicUnicodeCodePoints
	"Initialize the table of Unicode code points"
	| unicodeCodePoints |
	unicodeCodePoints := Array new: 256.
	0 to: 255 do: [ :code |
		unicodeCodePoints at: code + 1 put: code ].
	
	"The following codes are different in ISO 8859-15 from those in ISO 8859-1,
	so the character code is not equal to the Unicode code point"
	unicodeCodePoints at: 16rA4+1 put: 16r20AC.		"euro sign"
	unicodeCodePoints at: 16rA6+1 put: 16r160.		"latin capital letter S with caron"
	unicodeCodePoints at: 16rA8+1 put: 16r161.		"latin small letter s with caron"
	unicodeCodePoints at: 16rB4+1 put: 16r17D.		"latin capital letter Z with caron"
	unicodeCodePoints at: 16rB8+1 put: 16r17E.		"latin small letter z with caron"
	unicodeCodePoints at: 16rBC+1 put: 16r152.		"latin capital ligature OE"
	unicodeCodePoints at: 16rBD+1 put: 16r153.		"latin small ligature oe"
	unicodeCodePoints at: 16rBE+1 put: 16r178.		"latin capital letter Y with diaeresis"

	"Mathematical symbols (see Character>>#namedCharactersTable)"
	unicodeCodePoints at: 16r80+1 put: 16r221E.		"infinity"
	unicodeCodePoints at: 16r81+1 put: 16r2135.		"aleph"
	unicodeCodePoints at: 16r82+1 put: 16r2115.		"blackboard bold N"
	unicodeCodePoints at: 16r83+1 put: 16r2124.		"blackboard bold Z"
	unicodeCodePoints at: 16r84+1 put: 16r211A.		"blackboard bold Q"
	unicodeCodePoints at: 16r85+1 put: 16r211D.		"blackboard bold R"
	unicodeCodePoints at: 16r86+1 put: 16r2102.		"blackboard bold C"
	unicodeCodePoints at: 16r87+1 put: 16r2119.		"blackboard bold P"
	unicodeCodePoints at: 16r88+1 put: 16r03B1.		"alpha"
	unicodeCodePoints at: 16r89+1 put: 16r03B2.		"beta"
	unicodeCodePoints at: 16r8A+1 put: 16r03B3.		"gamma"
	unicodeCodePoints at: 16r8B+1 put: 16r03B4.		"delta"
	unicodeCodePoints at: 16r8C+1 put: 16r03B5.		"epsilon"
	unicodeCodePoints at: 16r8D+1 put: 16r03BB.		"lambda"
	unicodeCodePoints at: 16r8E+1 put: 16r03C0.		"pi"
	unicodeCodePoints at: 16r8F+1 put: 16r03B6.		"zeta"
	unicodeCodePoints at: 16r90+1 put: 16r2295.		"oplus"
	unicodeCodePoints at: 16r91+1 put: 16r2297.		"otimes"
	unicodeCodePoints at: 16r92+1 put: 16r2218.		"circ"
	unicodeCodePoints at: 16r93+1 put: 16r2293.		"prod"
	unicodeCodePoints at: 16r94+1 put: 16r2294.		"coprod"
	unicodeCodePoints at: 16r95+1 put: 16r22A5.		"perp"
	unicodeCodePoints at: 16r96+1 put: 16r0394.		"Delta"
	unicodeCodePoints at: 16r97+1 put: 16r0393.		"Gamma"
	unicodeCodePoints at: 16r98+1 put: 16r03C9.		"omega"
	unicodeCodePoints at: 16r99+1 put: 16r21A0.		"SURJECTIVE ARROW"
	unicodeCodePoints at: 16r9A+1 put: 16r21A3.		"INJECTIVE ARROW"
	unicodeCodePoints at: 16r9B+1 put: 16r2194.		"BIJECTIVE ARROW"
	unicodeCodePoints at: 16r9C+1 put: 16r21AA.		"INCLUSION ARROW"
	unicodeCodePoints at: 16r9D+1 put: 16r21A6.		"MAPPING ARROW"
	unicodeCodePoints at: 16r9E+1 put: 16r2202.		"partial differential"
	unicodeCodePoints at: 16r9F+1 put: 16r221A.		"sqrt"
	^unicodeCodePoints!

Character class removeSelector: #basicIrregularIso8859s15Codes!

!methodRemoval: Character class #basicIrregularIso8859s15Codes stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
basicIrregularIso8859s15Codes
	
	| unicodeCodePoints irregularIso8859s15Codes |
	unicodeCodePoints := Character unicodeCodePoints.
	irregularIso8859s15Codes := Dictionary new.
	0 to: 255 do: [ :iso |
		(unicodeCodePoints at: iso+1) = iso ifFalse: [
			irregularIso8859s15Codes at: (unicodeCodePoints at: iso+1) put: iso ]].
	^irregularIso8859s15Codes!

Character class removeSelector: #irregularIso8859s15Codes!

!methodRemoval: Character class #irregularIso8859s15Codes stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
irregularIso8859s15Codes
	^`Character basicIrregularIso8859s15Codes`!

Character class removeSelector: #utf8BytesAndCodePointForIso8859s15:into:into:!

!methodRemoval: Character class #utf8BytesAndCodePointForIso8859s15:into:into: stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
utf8BytesAndCodePointForIso8859s15: iso8859s15 into: bytesBlock into: codePointBlock
	| codePoint |
	codePoint := (Character numericValue: iso8859s15) codePoint.
	bytesBlock ifNotNil: [
		Character
			evaluateOnce: bytesBlock
			withUtf8BytesOfUnicodeCodePoint: codePoint ].
	codePointBlock ifNotNil: [
		codePointBlock value: codePoint ].
	^1!

Character class removeSelector: #iso8859s15CodeForUnicodeCodePoint:!

!methodRemoval: Character class #iso8859s15CodeForUnicodeCodePoint: stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
iso8859s15CodeForUnicodeCodePoint: codePoint
	"
	Answer nil if the Unicode codePoint is not a valid ISO 8859-15 character
	
	self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r41) = $A iso8859s15Code.
	self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r20AC) = $ iso8859s15Code.
	"

	"For most 8 bit Characters, ISO 8859-15 and Unicode Code Point are the same. Fast path."
	(codePoint < 256 and: [ (self unicodeCodePoints at: codePoint+1) = codePoint ])
		ifTrue: [ ^codePoint ].

	^ self irregularIso8859s15Codes at: codePoint ifAbsent: nil.!

Character removeSelector: #iso8859s15Code!

!methodRemoval: Character #iso8859s15Code stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
iso8859s15Code
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding.
	Any implementation of Character like object beyond ISO-8859-15 should answer nil.
	Senders, please consider that this method might answer nil.
	See #iso8859s15CodeForUnicodeCodePoint:"

	^ self numericValue!

Character removeSelector: #is:!

!methodRemoval: Character #is: stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
is: aSymbol
	^ aSymbol == #Character or: [ super is: aSymbol ]!

Character removeSelector: #asCharacter!

!methodRemoval: Character #asCharacter stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
asCharacter
	"Answer the receiver itself."
	^self!

Integer removeSelector: #asCharacter!

!methodRemoval: Integer #asCharacter stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:39:07'!
asCharacter
	"Answer the Character whose value is the receiver."

	^Character numericValue: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st----!

'From Cuis6.3 [latest update: #6170] on 8 January 2024 at 10:14:17 am'!
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:47' prior: 16811813!
          basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self numericValue: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		group size > 1
			ifTrue: [ | lowercaseChar uppercaseChar |
				uppercase := group first numericValue.
				lowercase := group second numericValue.
				lowercaseChar := self numericValue: lowercase.
				uppercaseChar := self numericValue: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third numericValue.
						unaccentedLowercase := group fourth numericValue.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifFalse: [ | lowercaseChar |
				lowercase := group first numericValue.
				lowercaseChar := self numericValue: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar ]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:52' prior: 16811969!
         lowercaseMappingTable
	^`Character basicLookupTables at: 1`.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:54' prior: 16811974!
    unaccentedTable
	^`Character basicLookupTables at: 3`.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:57' prior: 16811984!
          uppercaseMappingTable
	^`Character basicLookupTables at: 2`.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:18' prior: 16961081!
       tokenishTable
	"a table for testing tokenish (for fast numArgs)"
	^`String withAll: (
		((0 to: 255) collect: [ :c | (Character numericValue: c) ])
			collect: 	[ :c | c tokenish ifTrue: [c] ifFalse: [$~]]	)`.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6178-coda-JuanVuletich-2024Jan08-10h10m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 11:21:58 am'!
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:13:00' prior: 16810989!
                              isVowel
	"Answer whether the receiver is one of the vowels, AEIOU, in upper or 
	lower case, and with various diacritical marks."

self flag: #unicodeNeedsImprovement.
	^Character vowels includes: self! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 11:13:46' prior: 16811142!
               accentedLetters
	"Answer all letters with all possible accents (combining diacritical marks).
	Order of this array is:
		unaccented
		U+0300 	COMBINING GRAVE ACCENT
		U+0301 	COMBINING ACUTE ACCENT
		U+0302 	COMBINING CIRCUMFLEX ACCENT
		U+0303 	COMBINING TILDE
		U+0308 	COMBINING DIAERESIS
		U+030A 	COMBINING RING ABOVE
		U+030C 	COMBINING CARON
	Do not include letters that can't have any accent in ISO 8859-15
	Denote unsupported combinations (for example A with caron, or N with accute accent) by a $-"
self flag: #unicodeNeedsImprovement.
	^#(
		'A-'
		'a-'
		'E---'
		'e---'
		'I---'
		'i---'
		'O--'
		'o--'
		'U---'
		'u---'
		'N------'
		'n------'
		'S------'
		's------'
		'Y-----'
		'y-----'
		'Z------'
		'z------'
	).! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 11:14:27' prior: 16811211!
            uppercaseLowercaseAndUnaccentedLetters
	"Answer all uppercase and lowercase letters in standard collation order.
	For accented characters, include the non-accented ones.
	Note that $ is 'LATIN SMALL LETTER SHARP S' and ISO 8859-15 doesn't have an uppercase version."
self flag: #unicodeNeedsImprovement.
	^#(
		'Aa' 'Aa' 'Aa' 'Aa' 'Aa' 'Aa' 'Aa'
		'Bb' 'Cc' '' 'Dd'
			'Ee' 'Ee' 'Ee' 'Ee' 'Ee'
		'Ff' 'Gg' 'Hh'
			'Ii' 'Ii' 'Ii' 'Ii' 'Ii'
		'Jj' 'Kk' 'Ll' 'Mm' 'Nn' ''
			'Oo' 'Oo' 'Oo' 'Oo' 'Oo' 'Oo'
		'Pp' 'Qq' 'Rr'
			'Ss' 'Ss'
		'Tt'
			'Uu' 'Uu' 'Uu' 'Uu' 'Uu'
		'Vv' 'Ww' 'Xx'
			'Yy' 'Yy' 'Yy'
			'Zz' 'Zz' 
		'' '' '' '' '' ''
	).! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 11:15:30' prior: 16811319!
                separators
self flag: #unicodeNeedsImprovement.
	"Also see #isSeparator"
	^ #(32 "space"
		13 "cr"
		9 "tab"
		10 "line feed"
		12 "form feed")
		collect: [:v | Character numericValue: v]

	
! !

Character class removeSelector: #greekUppercaseLetters!

!methodRemoval: Character class #greekUppercaseLetters stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:39:07'!
greekUppercaseLetters
	"Answer the uppercase greek letters included in our font within the ASCII range.
	These are considered uppercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ ''!

Character class removeSelector: #lfCharacter!

!methodRemoval: Character class #lfCharacter stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:39:07'!
lfCharacter
	"Answer the Character representing a linefeed."
	"Deprecated. To be removed soon. Please use #lf"

	^self lf!

Character class removeSelector: #greekLowercaseLetters!

!methodRemoval: Character class #greekLowercaseLetters stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:39:07'!
greekLowercaseLetters
	"Answer the lowercase greek letters included in our font within the ASCII range.
	These are considered lowercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ ''!

Character class removeSelector: #crCharacter!

!methodRemoval: Character class #crCharacter stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:39:07'!
crCharacter
	"Answer the Character representing a carriage return."
	"Deprecated. To be removed soon. Please use #cr"

	^self cr!

Character class removeSelector: #blackboardLetters!

!methodRemoval: Character class #blackboardLetters stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:39:07'!
blackboardLetters
	"Answer the 'blackboard bold' or 'double struck' letters included in our font within the ASCII range.
	These are considered uppercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ ''!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 11:47:38 am'!
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:30:16' prior: 16810819!
 < aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	self == aCharacter ifTrue: [ ^false ].

	(self codePoint < 256 and: [ aCharacter codePoint < 256 ]) ifTrue: [
		^String does: self collateBefore: aCharacter ].
	
	^self codePoint < aCharacter codePoint.! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:38:34' prior: 16810829!
                          <= aCharacter 
	"Answer whether the receiver is less than or equal to the argument."

	^(self > aCharacter) not.! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:39:12' prior: 16810837 overrides: 16913610!
     = aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].

	"Just remove this method and use inherited version when we remove UnicodeCodePoint ?"
	aCodePointOrCharacter class == UnicodeCodePoint ifFalse: [ ^false ].

	aCodePointOrCharacter isCharacter ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:31:16' prior: 16810845!
                     > aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	self == aCharacter ifTrue: [ ^false ].

	(self codePoint < 256 and: [ aCharacter codePoint < 256 ]) ifTrue: [
		^String does: self collateAfter: aCharacter ].
	
	^self codePoint > aCharacter codePoint.! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:39:54' prior: 16810855!
                           >= aCharacter 
	"Answer whether the receiver is greater than or equal to the argument."

	^(self < aCharacter) not.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6180-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h24m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 11:58:37 am'!
!Collection methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:52:21'!
                 canHoldAnyCodePoint
	"Why not?"
	^true! !
!String methodsFor: 'converting' stamp: 'jmv 1/8/2024 11:54:45'!
                     thatCanHoldAnyCodePoint
	"See senders.
	Also see #asStreamResult"
	^ArrayOfCharactersAndCodePoints withAll: self! !
!String methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:53:48' overrides: 50340949!
                          canHoldAnyCodePoint
	"Nope.
	We can only hold Code Points less than 256.
	Needs something like UnicodeString for others. Even an Array is better than us."
	^false! !
!Text methodsFor: 'converting' stamp: 'jmv 1/8/2024 11:54:54'!
                           thatCanHoldAnyCodePoint
	"See senders.
	Also see #asStreamResult	"
	string := string thatCanHoldAnyCodePoint! !
!Text methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:52:30' overrides: 50340949!
canHoldAnyCodePoint
	"Ask our string"
	^string canHoldAnyCodePoint! !
!String methodsFor: 'copying' stamp: 'jmv 1/8/2024 11:51:02' prior: 16960080 overrides: 16947652!
                        copyWith: newElement
	newElement codePoint > 255 ifFalse: [
		^self asUnicodeString copyWith: newElement ].
	^super copyWith: newElement! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 11:58:03' prior: 17008880 overrides: 16959125!
           nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	(anObject isCharacter and: [anObject codePoint > 255 and: [collection canHoldAnyCodePoint not]]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position := position + 1.
			^collection at: position put: anObject].! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 11:55:05' prior: 17008895 overrides: 16959137!
                 nextPutAll: aCollection

	| newEnd |
	(aCollection canHoldAnyCodePoint and: [collection canHoldAnyCodePoint not]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd := position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position := newEnd.! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 11:55:08' prior: 17008912!
            nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(aString canHoldAnyCodePoint and: [collection canHoldAnyCodePoint not]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd := position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position := newEnd! !

Text removeSelector: #thatCanHoldCodePoints!

!methodRemoval: Text #thatCanHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:39:07'!
thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult	"
	string := string thatCanHoldCodePoints!

Text removeSelector: #canHoldCodePoints!

!methodRemoval: Text #canHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:39:07'!
canHoldCodePoints
	"Ask our string"
	^string canHoldCodePoints!

String removeSelector: #thatCanHoldCodePoints!

!methodRemoval: String #thatCanHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:39:07'!
thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult"
	^ArrayOfCharactersAndCodePoints withAll: self!

String removeSelector: #canHoldCodePoints!

!methodRemoval: String #canHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:39:07'!
canHoldCodePoints
	"Nope. Needs something like UnicodeString for that. Even an Array is better than us."
	^false!

Collection removeSelector: #canHoldCodePoints!

!methodRemoval: Collection #canHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:39:07'!
canHoldCodePoints
	"Why not?"
	^true!

UnicodeCodePoint removeSelector: #isUnicodeCodePoint!

!methodRemoval: UnicodeCodePoint #isUnicodeCodePoint stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:39:07'!
isUnicodeCodePoint
	^true!

Object removeSelector: #isUnicodeCodePoint!

!methodRemoval: Object #isUnicodeCodePoint stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:39:07'!
isUnicodeCodePoint
	"Overridden to return true in UnicodeCodePoint, natch"
	^ false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 12:12:17 pm'!
!String class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:08:14' prior: 16960480!
                       fromUtf8Bytes: aByteArray trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to the internal encoding: ISO Latin 9 (ISO 8859-15).
	Discard any code points that can not be represented."

	^String streamContents: [ :strm | | s byteIndex n |
		s := aByteArray size.
		byteIndex := 1.
		[  byteIndex <= s ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					codePoint < 256 ifTrue: [
						strm nextPut: (Character codePoint: codePoint) ]].
			byteIndex := byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6182-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h58m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 12:14:04 pm'!
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:13:35' prior: 50340009!
          codePoint: anInteger
	"Answer the Character whose value is anInteger.
	
	self assert: (Character codePoint: 16r41) = $A.
	self assert: (Character codePoint: 16r20AC) = $.
	"

	<primitive: 170>
	^self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6183-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h12m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 12:24:13 pm'!
!FileList methodsFor: 'private' stamp: 'jmv 1/8/2024 12:14:22' prior: 16862879!
                            readContentsHex: brevity
	"retrieve the contents from the external file unless it is too long.
	  Don't create a file here.  Check if exists."
	| size data hexData firstPartSize |
	firstPartSize := 1e3.
	directory // fileName readStreamDo: [ :stream |
		stream ifNil: [^ 'For some reason, this file cannot be read'].
		stream useBytes.
		((size := stream size)) > (10*firstPartSize) & brevity
			ifTrue: [ data := stream next: firstPartSize. brevityState := #briefHex ]
			ifFalse: [ data := stream next: size. brevityState := #fullHex ]].

	hexData := String streamContents: [ :s |
		0 to: data size-1 by: 16 do: [ :loc |
			loc printOn: s base: 16 length: 8 padded: true.
			s
				space;
				nextPut: $(.
			loc printOn: s base: 10 length: 10 padded: true.
			s
				nextPut: $);
				space;
				tab.
			loc+1 to: (loc+16 min: data size) do: [ :i | s nextPutAll: (Character codePoint: (data at: i)) hex; space ].
			s newLine ]].

	^ acceptedContentsCache := ((size > (10*firstPartSize)) & brevity
		ifTrue: ['File ''{1}'' is {2} bytes long.
You may use the ''get'' command to read the entire file.

Here are the first {3} characters...
------------------------------------------
{4}
------------------------------------------
... end of the first {3} characters.' format: {fileName. size. firstPartSize. hexData}]
		ifFalse: [hexData])! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:14:38' prior: 16811054!
                asUnaccented
	"
	$A asUnaccented
	$ asUnaccented
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented ]
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented  asLowercase]
	"
	^ Character
		codePoint: (self class unaccentedTable at: self numericValue + 1)! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:27' prior: 16811078!
            to: other
	"Answer with a collection in ascii order -- $a to: $z"
	^ (self numericValue to: other numericValue) collect:
				[:ascii | Character codePoint: ascii]! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:16:02' prior: 16811271!
                         digitValue: x 
	"Answer the Character whose digit value is x. For example,
	 answer $9 for x=9, $0 for x=0, $A for x=10, $Z for x=35."

	| n |
	n := x asInteger.
	^self codePoint: (n < 10 ifTrue: [n + 48] ifFalse: [n + 55])! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:16:43' prior: 50340806!
                            separators
self flag: #unicodeNeedsImprovement.
	"Also see #isSeparator"
	^ #(32 "space"
		13 "cr"
		9 "tab"
		10 "line feed"
		12 "form feed")
		collect: [ :v | Character codePoint: v]

	
! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:15:30' prior: 16811327!
                backspace
	"Answer the Character representing a backspace."

	^self codePoint: 8! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:15:58' prior: 16811347!
                             delete
	^ self codePoint: 127! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:06' prior: 16811352!
                end
	^ self codePoint: 4! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:12' prior: 16811356!
                     enter
	"Answer the Character representing enter."

	^self codePoint: 3! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:15' prior: 16811362!
       escape
	"Answer the ASCII ESC character"

	^self codePoint: 27! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:18' prior: 16811368!
               home
	^ self codePoint: 1! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:22' prior: 16811372!
                    insert
	^ self codePoint: 5! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:26' prior: 16811399!
                  newPage
	"Answer the Character representing a form feed."

	^self codePoint: 12! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:30' prior: 16811405!
                              null
	"Answer the null Character."

	^self codePoint: 0! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:33' prior: 16811410!
                      pageDown
	^ self codePoint: 12! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:36' prior: 16811415!
               pageUp
	^ self codePoint: 11! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:49' prior: 16811420!
                 shortUnderscore
	"Answer the Character representing very short (or invisible) underscore.
	Used to optionally mark subscript in code."

	^ Character codePoint: 127! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:20:40' prior: 16811429!
          smalltalkDownArrow
	"
	The use of code 31 for a down arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text.
	Cuis holds a down arrow glyph at this code. This is for possible future use.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkDownArrow
	"
	^ Character codePoint: 31! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:20:49' prior: 16811446!
                smalltalkLeftArrow
	"
	The use of code 28 for a left arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text files.

	Cuis holds a left arrow glyph at this code, that is only used to show $_ as a left arrow,
	when used for assignment of a Smalltalk variable.
	Note that it will be replaced by $_ when saving code files or exporting to OS clipboard.
	Browse senders to see how this works.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkLeftArrow
	"
	^ Character codePoint: 28! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:20:56' prior: 16811469!
        smalltalkRightArrow
	"
	The use of code 30 for a right arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text.
	Cuis holds a right arrow glyph at this code. This is for possible future use.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkRightArrow
	"
	^ Character codePoint: 30! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:21:08' prior: 16811486!
            smalltalkUpArrow
	"
	The use of code 29 for an up arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text files.

	Cuis holds an up arrow glyph at this code, that is only used to show $^ as an up arrow,
	when used for return from a Smalltalk method.
	Note that it will be replaced by $^ when saving code files or exporting to OS clipboard.
	Browse senders to see how this works.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkUpArrow
	"
	^ Character codePoint: 29! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:43' prior: 50340649!
      basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self codePoint: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		group size > 1
			ifTrue: [ | lowercaseChar uppercaseChar |
				uppercase := group first numericValue.
				lowercase := group second numericValue.
				lowercaseChar := self codePoint: lowercase.
				uppercaseChar := self codePoint: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third numericValue.
						unaccentedLowercase := group fourth numericValue.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifFalse: [ | lowercaseChar |
				lowercase := group first numericValue.
				lowercaseChar := self codePoint: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar ]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:48' prior: 50340706!
                     lowercaseMappingTable
	^`Character basicLookupTables at: 1`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:51' prior: 50340711!
     unaccentedTable
	^`Character basicLookupTables at: 3`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:53' prior: 50340716!
           uppercaseMappingTable
	^`Character basicLookupTables at: 2`! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:32' prior: 50340133!
      asLowercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character codePoint: value) asLowercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:37' prior: 50340142!
                       asUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character codePoint: value) asUnaccented codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:41' prior: 50340151!
                     asUppercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character codePoint: value) asUppercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:45' prior: 50340160!
                       isAccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character codePoint: value) isAccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:48' prior: 50340168!
                              isUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character codePoint: value) isUnaccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:51' prior: 50340176!
                          isValidInFilenames
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character codePoint: value) isValidInFilenames ].
	^true! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:54' prior: 50340184!
               isVowel
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^ (Character codePoint: value) isVowel ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:57' prior: 50340191!
   withDiacriticalMark: anUnicodeCodePoint
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (
			(Character codePoint: value) withDiacriticalMark: anUnicodeCodePoint)
				codePoint ].
	^self! !
!Date methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:18:04' prior: 50340210!
   printOn: aStream format: formatArray 
	"Print a description of the receiver on aStream using the format 
	denoted the argument, formatArray: 
	
		#(item item item sep monthfmt yearfmt twoDigits) 
	
		items: 1=day 2=month 3=year will appear in the order given, 
	
		separated by sep which is eaither an ascii code or character. 
	
		monthFmt: 1=09 2=Sep 3=September 
	
		yearFmt: 1=1996 2=96 
	
		digits: (missing or)1=9 2=09. 
	
	See the examples in printOn: and mmddyy"
	| gregorian twoDigits element monthFormat |
	gregorian := self dayMonthYearDo: [ :d :m :y | {d. m. y} ].
	twoDigits := formatArray size > 6 and: [(formatArray at: 7) > 1].
	1 to: 3 do: 
		[ :i | 
			element := formatArray at: i.
			element = 1
				ifTrue: [twoDigits
						ifTrue: [aStream
								nextPutAll: (gregorian first printString
										padded: #left
										to: 2
										with: $0)]
						ifFalse: [gregorian first printOn: aStream]].
			element = 2
				ifTrue: [monthFormat := formatArray at: 5.
					monthFormat = 1
						ifTrue: [twoDigits
								ifTrue: [aStream
										nextPutAll: (gregorian middle printString
												padded: #left
												to: 2
												with: $0)]
								ifFalse: [gregorian middle printOn: aStream]].
					monthFormat = 2
						ifTrue: [aStream
								nextPutAll: ((Month nameOfMonth: gregorian middle)
										copyFrom: 1
										to: 3)].
					monthFormat = 3
						ifTrue: [aStream
								nextPutAll: (Month nameOfMonth: gregorian middle)]].
			element = 3
				ifTrue: [(formatArray at: 6)
							= 1
						ifTrue: [gregorian last printOn: aStream]
						ifFalse: [aStream
								nextPutAll: ((gregorian last \\ 100) printString
										padded: #left
										to: 2
										with: $0)]].
			i < 3
				ifTrue: [(formatArray at: 4)
							~= 0
						ifTrue: [
							aStream nextPut: ((formatArray at: 4) isNumber
								ifTrue: [ Character codePoint: (formatArray at: 4) ]
								ifFalse: [ (formatArray at: 4) ])
							]]]
! !
!InputSensor methodsFor: 'private' stamp: 'jmv 1/8/2024 12:18:08' prior: 16882358!
                        characterForKeycode: keycode
	"Map the given keycode to a Smalltalk character object. Encoding:
		A keycode is 12 bits:   <4 modifer bits><8 bit ISO character>
		Modifier bits are:       <command><option><control><shift>"

	"NOTE: the command and option keys are specific to the Macintosh and may not have equivalents on other platforms."

	keycode ifNil: [ ^nil ].
	^ Character codePoint: (keycode bitAnd: 16rFF)! !
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 1/8/2024 12:19:44' prior: 16856124!
        fetchMoreEventsDiscardingMouseEvents: discardMouseEvents
	"Fetch more events from the VM"
	| eventBuffer type |

	"Reset input semaphore so clients can wait for the next events after this one."
	inputSemaphore isSignaled
		ifTrue: [
			hasInputSemaphore := true.
			inputSemaphore initSignals ].

	"DebuggingAid""
	dd := Time localMillisecondClock - lastEventPoll.
	"

	eventBuffer := Array new: 8.
	[
		self primGetNextEvent: eventBuffer.
		"DebuggingAid""
		eventBuffer first = 2 ifTrue: [
			k1 := eventBuffer third.
			u1 := eventBuffer sixth.
			pressType := eventBuffer fourth.
			typeS := 'unknown'.
			pressType = EventSensor eventKeyDown ifTrue: [
				typeS := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				typeS := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				typeS := #keystroke].
			dd >100 ifTrue: ['-' print. dd := 0 ].
			{ k1 < 256 ifTrue: [Character codePoint: k1] ifFalse: [ '[]']. UnicodeCodePoint codePoint: k1. k1. k1 hex. '-----'. 
				UnicodeCodePoint codePoint: u1. u1. u1 hex. '----'. pressType. typeS } print.
			].
		"
		type := eventBuffer at: 1.
		type = EventSensor eventTypeNone ]
			whileFalse: [
				self
					processSensorEvent: eventBuffer
					discardingMouseEvents: discardMouseEvents ].

	"Remember the last time that I checked for events."
	lastEventPoll := Time localMillisecondClock.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:18:15' prior: 16813527!
                 asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in char rest did |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [(char := in next) = $&
					ifTrue: [
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:18:20' prior: 16959643 overrides: 16913349!
                       at: index 
	"Primitive. Answer the Character stored in the field of the receiver
	indexed by the argument. Fail if the index argument is not an Integer or
	is out of bounds. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 63>
	^Character codePoint: (super at: index)! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:18:25' prior: 50340275 overrides: 16913367!
                         at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	

			aCharacter class == UnicodeCodePoint ifTrue: [
				aCharacter codePoint > 255 ifTrue: [self error: 'String only store Latin-1 Characters'].
				^self at: index put: (Character codePoint: aCharacter codePoint) ].

			aCharacter numericValue > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:15:04' prior: 16960553!
                           percentEscapingNonAsciiAndThoseIn: aCharacterMap bytes: aByteArray
	"Percent encode any byte not in the ASCII range.
	Also encode any in aCharacterMap.
	Replace them with %XX where XX are the hexadecimal digits.
	See https://en.wikipedia.org/wiki/URL_encoding
	
	String percentEscapingNonAscii: '' bytes
	"

	^String streamContents: [ :strm |
		aByteArray do: [ :byte | | c |
			(byte > 127 or: [
						aCharacterMap isNil or: [
							c := Character codePoint: byte.
							aCharacterMap includes: c ]])
				ifTrue: [
					strm nextPut: $%.
					strm nextPut: (byte // 16) asHexDigit.
					strm nextPut: (byte \\ 16) asHexDigit ]
				ifFalse: [ strm nextPut: c ]]].! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:18:29' prior: 16961073!
      lowercasingTable
	"a table for translating to lower case"
	^`String withAll: ((0 to: 255) collect: [ :c | (Character codePoint: c) asLowercase ])`
! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:18:32' prior: 50340721!
                tokenishTable
	"a table for testing tokenish (for fast numArgs)"
	^`String withAll: (
		((0 to: 255) collect: [ :c | (Character codePoint: c) ])
			collect: 	[ :c | c tokenish ifTrue: [c] ifFalse: [$~]]	)`.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:18:38' prior: 16961090!
                     uppercasingTable
	"a table for translating to upper case"
	^`String withAll: ((0 to: 255) collect: [ :c | (Character codePoint: c) asUppercase ])`
! !
!Base64MimeConverter class methodsFor: 'additional services' stamp: 'jmv 1/8/2024 12:15:13' prior: 16786605!
                            initializeTables

	FromCharTable := Array new: 256.	"nils"
	ToCharTable := Array new: 64.
	($A asciiValue to: $Z asciiValue) withIndexDo: [ :ascii :ind | 
		FromCharTable at: ascii+1 put: ind-1.
		ToCharTable at: ind put: (Character codePoint: ascii) ].
	($a asciiValue to: $z asciiValue) withIndexDo: [ :ascii :ind | 
		FromCharTable at: ascii+1 put: ind+25.
		ToCharTable at: ind+26 put: (Character codePoint: ascii) ].
	($0 asciiValue to: $9 asciiValue) withIndexDo: [ :ascii :ind | 
		FromCharTable at: ascii+1 put: ind+25+26.
		ToCharTable at: ind+26+26 put: (Character codePoint: ascii) ].
	FromCharTable at: $+ asciiValue + 1 put: 62.
	ToCharTable at: 63 put: $+.
	FromCharTable at: $/ asciiValue + 1 put: 63.
	ToCharTable at: 64 put: $/.
	! !
!RWBinaryOrTextStream methodsFor: 'writing' stamp: 'jmv 1/8/2024 12:18:41' prior: 50340364 overrides: 50340988!
 nextPut: charOrByte

	super nextPut: 
		(charOrByte isCharacter
			ifTrue: [ charOrByte ]
			ifFalse: [ Character codePoint: charOrByte ])! !
!Transcripter methodsFor: 'command line' stamp: 'jmv 1/8/2024 12:18:45' prior: 16988717!
                         request: prompt
	| startPos char contents return |
	return := Character codePoint: InputSensor returnKey.
	self
		newLine;
		show: prompt.
	startPos := position.
	[
		[ Sensor keyboardPressed ] whileFalse.
		(char := Sensor keyboard) = return ] whileFalse: [
			char = Character backspace
				ifTrue: [ readLimit := position := position - 1 max: startPos ]
				ifFalse: [ self nextPut: char ].
			self endEntry ].
	contents := self contents.
	^ contents
		copyFrom: startPos + 1
		to: contents size! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 1/8/2024 12:18:49' prior: 16841591!
                 readCharacter
    "PRIVATE -- Read a Character."

    ^ Character codePoint: (byteStream nextUint32BigEndian: true)! !
!Scanner class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 12:19:02' prior: 16945442 overrides: 16916096!
                   initialize
	"
	Scanner initialize.
	"
	self initTypeTable.
	self initializeDoitCharacter.! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 1/8/2024 12:18:55' prior: 16945458!
   initTypeTable
	| newTable |
	newTable := Array new: 127 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"
	newTable atAll: '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.
	1 to: 127 do: [:index |
		(Character codePoint: index) isLetter ifTrue: [
			newTable at: index put: #xLetter ]].
	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable at: self doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	newTable at: Character smalltalkLeftArrow numericValue put: #leftArrow.
	newTable at: Character smalltalkUpArrow numericValue put: #upArrow.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!TrieNode class methodsFor: 'constants' stamp: 'jmv 1/8/2024 12:19:08' prior: 16989808!
                        characterForLeaf
	"A special character to mean leaf node. Must have lower code than alphabetic chars,
	so in the trie 'car' comes before 'cars'"
	^Character codePoint: 0! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 1/8/2024 12:19:53' prior: 16861997!
                          primLookupEntryIn: fullPathAsUtf8Bytes index: index
	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:

	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>

	On MacOS and Windows,  the empty string enumerates the mounted volumes/drives.
	
	On Linux, it is equivalent to '.', and lists the contents of DirectoryEntry currentDirectory.

	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad.
	
	Warning: The 'name' field is an instance of String, but in reality it contains the bytes for its UTF-8 representation.
	For instance, if the real name is 'puo' we'll get  'puo', as
	(String withAll: ('puo' AsUtf8Bytes asArray collect: [ :n | Character codePoint: n ]))        =        'puo'
	Senders MUST do appropriate conversion.
	
	Consider calling #primFixedNameLookupEntryIn:index: instead.
	"

 	<primitive: 'primitiveDirectoryLookup' module: 'FilePlugin'>
	^ #badDirectoryPath

! !
!ByteStringReadAdaptor methodsFor: 'reading' stamp: 'jmv 1/8/2024 12:19:12' prior: 16801723 overrides: 16992397!
                            next
	"Stream bytes as Cuis / ISO 8859-15 Characters.
	Disregard the fact that stream contents are most likely UTF-8.
	This is valid only if contents are ASCII, or Cuis / ISO-8859-15 byte Characters."

	stream nextByte ifNotNil: [ :byte |
		^Character codePoint: byte ].
	^nil! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 1/8/2024 12:19:19' prior: 16908827!
                 displayBulletTextLeft: texLeft number: bulletNumber
	"texLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern := paragraphStyle listBulletPattern.
	bullet := pattern.
	(i := pattern indexOf: $%) > 0
		ifTrue: [ bullet := bulletNumber printString]
		ifFalse: [
			(i := pattern indexOf: $z) > 0
				ifTrue: [ bullet := String with: (Character codePoint: 96 + bulletNumber) ]
				ifFalse: [
					(i := pattern indexOf: $Z) > 0
						ifTrue: [ bullet := String with: (Character codePoint: 64 + bulletNumber) ]]].
	prefix := 0.
	i > 0 ifTrue: [
		c := pattern at: i.
		j := i.
		s := pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j := j + 1 ].
		j := j - 1.
		bulletSize := j-i+1.
		prefix := bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet := bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet := (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos := paragraphStyle firstIndent + texLeft + ((font widthOf: $9) * prefix)@destY.
	canvas
		drawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor! !
!TTFontTableDirEntry methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:15:19' prior: 16973688!
                          stringAt: stringOffset length: byteLength multiByte: aBoolean

	| string index stringLength |
	aBoolean ifFalse:[
		stringLength := byteLength.
		string := String new: stringLength.
		index := stringOffset.
		1 to: stringLength do:[:i|
			string at: i put: (Character codePoint: (fontData at: index + i - 1))].
		^string
	] ifTrue:[
		"UTF-16BE ???
		https://docs.microsoft.com/en-us/typography/opentype/spec/name#enc3
		This code appears to assume only lower byte is needed, most likely only ascii is supported here (jmv)"
		stringLength := byteLength // 2.
		string := String new: stringLength.
		index := stringOffset.
		1 to: stringLength do:[:i|
			string at: i put: (Character codePoint: (fontData at: index + 1)).
			index := index + 2].
		^string]! !

Character class removeSelector: #numericValue:!

!methodRemoval: Character class #numericValue: stamp: 'Install-6184-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h14m-jmv.001.cs.st 1/30/2024 19:39:07'!
numericValue: anInteger
	"Answer the Character whose value is anInteger."

	<primitive: 170>
	^self primitiveFailed!

Character class removeSelector: #asciiValue:!

!methodRemoval: Character class #asciiValue: stamp: 'Install-6184-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h14m-jmv.001.cs.st 1/30/2024 19:39:07'!
asciiValue: asciiValue
	"
	Answer the Character for the required asciiValue. Argument is a byte, i.e. in [0..255].
	values above 127, consider it an ISO 8859-15 code.
	
	self assert: (Character asciiValue: 16r41) = $A.
	self assert: (Character asciiValue: 16rA4) = $.
	"
	^ Character numericValue: asciiValue!

Scanner initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6184-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h14m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 1:19:40 pm'!
!SmallInteger methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:27:13' prior: 16951711!
                    printStringBase: b nDigits: n
	"Return a string representation of this number in base b with n digits (left padded with 0).
	Should be invoked with: 0 <= self < (b raisedToInteger: n)."
	
	| integer next result |
	result := String new: n.
	integer := self.
	n to: 1 by: -1 do: [:i |
		next := integer // b.
		result at: i put: (Character digitValue: (integer - (next * b))).
		integer := next].
	^result! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:29:22' prior: 16810749!
                      asciiValue
	"Answer the value of the receiver that represents its ANSI encoding.
	This is the same as ISO 8859-15 for the first 128 characters.
	Answer nil if out of range."

	| n |
	n := self codePoint.
	^ n < 128 ifTrue: [ n ].! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:35:36' prior: 16810767!
    digitValue
	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 
	otherwise. This is used to parse literal numbers of radix 2-36.
	$0 numericValue = 48
	$9 numericValue = 57
	$A numericValue = 65
	$Z numericValue = 90 
	$7 digitValue = 7 
	"

	| nv |
	nv := self codePoint.
	(nv between: 48 and: 57)
		ifTrue: [ ^ nv - 48 ].
	(nv between: 65 and: 90)
		ifTrue: [ ^ nv - 55 ].
	^ -1! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 12:35:49' prior: 16810863 overrides: 16913626!
        hash
	"Hash is reimplemented because = is implemented."

	^self codePoint hash! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:08' prior: 16810904!
                             isDigit
	"Answer whether the receiver is a digit."

	^ self codePoint between: 48 and: 57! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:17' prior: 16810916!
                  isLineSeparator
	"Answer whether the receiver is a line separator character:
	line feed, cr, or form feed."

	^ #(10 13 12) statePointsTo: self codePoint! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:20' prior: 16810928!
                  isNullCharacter
	"Answer whether the receiver is the NULL character."

	^ self codePoint = 0! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:25' prior: 16810934!
               isSeparator
	"Answer whether the receiver is one of the separator characters
	space, tab, lf, cr, or form feed."
	"Also see #separators"

	^ #(32 9 10 13 12) statePointsTo: self codePoint! !
!Character methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:37:00' prior: 16811009!
               hex
	self codePoint < 256 ifTrue: [
		^ String
			with: ('0123456789ABCDEF' at: self codePoint//16+1)
			with: ('0123456789ABCDEF' at: self codePoint\\16+1) ].
	^self codePoint printStringBase: 16 length: 6 padded: true! !
!Character methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:37:41' prior: 16811019 overrides: 16914834!
                           printOn: aStream 
	aStream nextPut: $$.
	aStream nextPut: self.
	self codePoint <= 32 ifTrue: [
		aStream nextPut: $".
		aStream nextPutAll: self hex.
		aStream nextPut: $" ].! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:28:18' prior: 16811037!
                         asLowercase
self flag: #unicodeNeedsImprovement.
	self codePoint > 255 ifTrue: [ ^self ].
	^ Character lowercaseMappingTable at: self codePoint + 1.! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:28:52' prior: 50341209!
                    asUnaccented
	"
	$A asUnaccented
	$ asUnaccented
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented ]
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented  asLowercase]
	"
self flag: #unicodeNeedsImprovement.
	self codePoint > 255 ifTrue: [ ^self ].
	^ Character
		codePoint: (self class unaccentedTable at: self codePoint + 1)! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:29:10' prior: 16811071!
 asUppercase
	"If the receiver is lowercase, answer its matching uppercase Character."
self flag: #unicodeNeedsImprovement.
	self codePoint > 255 ifTrue: [ ^self ].
	^ Character uppercaseMappingTable at: self codePoint + 1.! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:38:10' prior: 50341221!
          to: other
	"Answer with a collection in ascii order -- $a to: $z"
	^ (self codePoint to: other codePoint) collect: [ :cp |
		Character codePoint: cp ]! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 12:58:23' prior: 50340778!
  uppercaseLowercaseAndUnaccentedLetters
	"Answer all uppercase and lowercase letters in standard collation order.
	For accented characters, include the non-accented ones.
	Note that $ is 'LATIN SMALL LETTER SHARP S' and ISO 8859-15 doesn't have an uppercase version.
	Note: for $, 'Latin Small Letter Y with diaeresis' the uppercase version is not Latin 1"
self flag: #unicodeNeedsImprovement.
	^#(
		'Aa' 'Aa' 'Aa' 'Aa' 'Aa' 'Aa' 'Aa'
		'Bb' 'Cc' '' 'Dd'
			'Ee' 'Ee' 'Ee' 'Ee' 'Ee'
		'Ff' 'Gg' 'Hh'
			'Ii' 'Ii' 'Ii' 'Ii' 'Ii'
		'Jj' 'Kk' 'Ll' 'Mm' 'Nn' ''
			'Oo' 'Oo' 'Oo' 'Oo' 'Oo' 'Oo'
		'Pp' 'Qq' 'Rr'
			'Ss'
		'Tt'
			'Uu' 'Uu' 'Uu' 'Uu' 'Uu'
		'Vv' 'Ww' 'Xx'
			'Yy' 'Yy' ''
			'Zz'
		'' '' '' '' ''
	).! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:30:23' prior: 50341401!
                        basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self codePoint: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		group size > 1
			ifTrue: [ | lowercaseChar uppercaseChar |
				uppercase := group first codePoint.
				lowercase := group second codePoint.
				lowercaseChar := self codePoint: lowercase.
				uppercaseChar := self codePoint: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third codePoint.
						unaccentedLowercase := group fourth codePoint.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifFalse: [ | lowercaseChar |
				lowercase := group first codePoint.
				lowercaseChar := self codePoint: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar ]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:58:45' prior: 50341458!
    lowercaseMappingTable
	^`Character basicLookupTables at: 1`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:58:48' prior: 50341463!
     unaccentedTable
	^`Character basicLookupTables at: 3`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:58:51' prior: 50341468!
           uppercaseMappingTable
	^`Character basicLookupTables at: 2`! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 1/8/2024 12:38:20' prior: 16882037!
             kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char := nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char := self keyboard.
		Display fill: `5@5 extent: 400@50` fillColor: `Color white`.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char codePoint;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ].
			Time now printOn: s
			])
		displayAt: 10 @ 10 ].! !
!EventSensor methodsFor: 'initialization' stamp: 'jmv 1/8/2024 12:38:44' prior: 16856425 overrides: 16932297!
  initialize
	"Run the I/O process"
	mouseButtons := 0.
	mousePosition := `0@0`.
	self setInterruptKey: (interruptKey ifNil: [$. codePoint bitOr: 16r0800 ]). 	"cmd-."
	self flushAllButDandDEvents.
	inputSemaphore := Semaphore new.
	hasInputSemaphore := false.

	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	self installInterruptWatcher.
	self installEventTickler.
	self flushAllButDandDEvents.

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore := false.
	inputSemaphore initSignals! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:39:05' prior: 50341716 overrides: 16913367!
    at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	

			aCharacter class == UnicodeCodePoint ifTrue: [
				aCharacter codePoint > 255 ifTrue: [self error: 'String only store Latin-1 Characters'].
				^self at: index put: (Character codePoint: aCharacter codePoint) ].

			aCharacter codePoint > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String methodsFor: 'comparing' stamp: 'jmv 1/8/2024 13:02:09' prior: 16959888!
            crc16
	"Compute a 16 bit cyclic redundancy check."

	| crc |
	crc := 0.
	self do: [:c |
		crc := (crc bitShift: -8) bitXor: (
		 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241
			16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440
			16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40
			16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841
			16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40
			16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41
			16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641
			16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040
			16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240
			16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441
			16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41
			16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840
			16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41
			16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40
			16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640
			16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041
			16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240
			16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441
			16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41
			16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840
			16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41
			16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40
			16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640
			16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041
			16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241
			16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440
			16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40
			16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841
			16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40
			16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41
			16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641
			16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)
			 at: ((crc bitXor: c codePoint) bitAnd: 16rFF) + 1) ].
	^crc! !
!String class methodsFor: 'character collation' stamp: 'jmv 1/8/2024 13:04:20' prior: 16960643!
                           does: aCharacter caseInsensitiveCollateBefore: otherCharacter
	"
	String does: $a caseInsensitiveCollateBefore: $b
	String does: $a caseInsensitiveCollateBefore: $B
	String does: $A caseInsensitiveCollateBefore: $b
	"
	"Only for Latin-1"
	self flag: #unicodeNeedsImprovement.
	^ (self caseInsensitiveOrder at: aCharacter codePoint + 1) <
		(self caseInsensitiveOrder at: otherCharacter codePoint + 1)! !
!String class methodsFor: 'character collation' stamp: 'jmv 1/8/2024 13:04:06' prior: 16960657!
            does: aCharacter collateAfter: otherCharacter
	"Only for Latin-1"
	self flag: #unicodeNeedsImprovement.
	^ (self caseSensitiveOrder at: aCharacter codePoint + 1) >
		(self caseSensitiveOrder at: otherCharacter codePoint + 1)! !
!String class methodsFor: 'character collation' stamp: 'jmv 1/8/2024 13:03:55' prior: 16960666!
                            does: aCharacter collateBefore: otherCharacter
	"Only for Latin-1"
	self flag: #unicodeNeedsImprovement.
	^ (self caseSensitiveOrder at: aCharacter codePoint + 1) <
		(self caseSensitiveOrder at: otherCharacter codePoint + 1)! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:39:19' prior: 16960962!
  basicCaseInsensitiveOrder
	"Case insensitive compare sorts null, space, digits, letters, all the rest..."
	| newOrder order |
	newOrder := Array new: 256.
	order := -1.
	newOrder at: 0+1 put:  (order := order+1).
	32 to: 64 do: [ :c |
		newOrder at: c + 1 put: (order := order+1)].
	#(92 94 124 126 183 215 247) do: [ :c | "\^|~"
		newOrder at: c + 1 put: (order := order+1)].
	16r90 to: 16r9F do: [:c| "special math operators"
		newOrder at: c + 1 put: (order := order+1)].
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |
		order := order+1.
		newOrder at: upperAndLowercase first codePoint + 1 put: order.
		upperAndLowercase size > 1 ifTrue: [
			newOrder at: upperAndLowercase second codePoint + 1 put: order ]].
	1 to: newOrder size do: [ :i |
		(newOrder at: i) ifNil: [
			newOrder at: i put: (order := order+1)]].
	^newOrder asByteArray.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:59:55' prior: 16960993!
                   basicCaseSensitiveOrder
	"Case sensitive compare sorts null, space, digits, letters, all the rest..."
	| newOrder order lowercase |
	newOrder := Array new: 256.
	order := -1.
	newOrder at: 0+1 put:  (order := order+1).
	32 to: 64 do: [ :c |
		newOrder at: c + 1 put: (order := order+1)].
	#(92 94 124 126 183 215 247) do: [ :c | "\^|~"
		newOrder at: c + 1 put: (order := order+1)].
	16r90 to: 16r9F do: [:c| "special math operators"
		newOrder at: c + 1 put: (order := order+1)].
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |
		upperAndLowercase size > 1 ifTrue: [
			newOrder at: upperAndLowercase first codePoint + 1 put: (order := order+1) ]].
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |
		lowercase := upperAndLowercase size = 1
			ifTrue: [ upperAndLowercase first ]
			ifFalse: [ upperAndLowercase second ].
		newOrder at: lowercase codePoint + 1 put: (order := order+1) ].
	1 to: newOrder size do: [ :i |
		(newOrder at: i) ifNil: [
			newOrder at: i put: (order := order+1)]].
	order = 255 ifFalse: [self error: 'order problem'].
	^newOrder asByteArray.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:59:01' prior: 16961043!
                       caseInsensitiveOrder
	^`String basicCaseInsensitiveOrder`! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 13:00:08' prior: 16961048!
          caseSensitiveOrder
	^`String basicCaseSensitiveOrder`! !
!UnicodeString methodsFor: 'paragraph support' stamp: 'jmv 1/8/2024 13:05:35' prior: 16994021!
        encompassLine: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte left nullPosition right |
	argumentLeftByte := self byteIndexAt: aCodePointInterval first.
	argumentRightByte := self byteIndexAt: aCodePointInterval last.

	"Find byte position and code point position following last newLine before us."
	leftByte := (bytes lastIndexOf: `Character newLineCharacter codePoint` startingAt: argumentLeftByte - 1 ifAbsent: [0]) + 1.
	left := self codePointIndexAt: leftByte.

	"Find byte position and code point position for next newLine. Don't include it."
	right := count.
	rightCrByte := bytes indexOf: `Character newLineCharacter codePoint` startingAt: (argumentRightByte max: argumentLeftByte).
	rightCrByte = 0 ifFalse: [
		right := (self codePointIndexAt: rightCrByte)-1].

	"But stop before if any nulls. Don't include them!!"
	nullPosition := bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte).
	nullPosition = 0 ifFalse: [
		right := right min: ((self codePointIndexAt: nullPosition)-1) ].

	^left to: right! !
!UnicodeString methodsFor: 'paragraph support' stamp: 'jmv 1/8/2024 13:05:41' prior: 16994066!
            encompassParagraph: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte left nullPosition right |
	argumentLeftByte := self byteIndexAt: aCodePointInterval first.
	argumentRightByte := self byteIndexAt: aCodePointInterval last.

	"Find byte position and code point position following last newLine before us."
	leftByte := (bytes lastIndexOf: `Character newLineCharacter codePoint` startingAt: argumentLeftByte - 1 ifAbsent: [0]) + 1.
	left := self codePointIndexAt: leftByte.

	"Find byte position and code point position for next newLine. Include it."
	right := count.
	rightCrByte := bytes indexOf: `Character newLineCharacter codePoint` startingAt: (argumentRightByte max: argumentLeftByte).
	rightCrByte = 0 ifFalse: [
		right := self codePointIndexAt: rightCrByte].

	"But stop before if any nulls. Don't include them!!"
	nullPosition := bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte).
	nullPosition = 0 ifFalse: [
		right := right min: ((self codePointIndexAt: nullPosition)-1) ].

	^left to: right! !
!RWBinaryOrTextStream methodsFor: 'reading' stamp: 'jmv 1/8/2024 13:14:56' prior: 16934757 overrides: 16935157!
                          next

	| byte |
	^ isBinary 
			ifTrue: [byte := super next.
				 byte ifNil: [nil] ifNotNil: [byte codePoint]]
			ifFalse: [super next].
! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 1/8/2024 13:06:28' prior: 16991729 overrides: 17009239!
                           padToEndIfCantTruncate
	"Only makes sense for file streams with existing content.
	On file systems that don't support truncating this is needed.
	If truncating is supported, try that first"

	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."

	| pad |
	self atEnd ifTrue: [^ self].
	self truncate.
	self atEnd ifTrue: [^ self].
	pad := Character space codePoint.
	self nextPutAll: (ByteArray new: ((self size - self position) min: 20000) 
							withAll: pad)! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 1/8/2024 13:06:36' prior: 16841938!
                writeCharacter: aCharacter
	"PRIVATE -- Write a Character."

	byteStream nextUint32Put: aCharacter codePoint bigEndian: true! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 1/8/2024 13:07:26' prior: 16842001!
       writeStringOld: aString
	"PRIVATE -- Write the contents of a String."

	| length |
	aString size < 16384 
		ifTrue: [
			(length := aString size) < 192
				ifTrue: [byteStream nextPut: length]
				ifFalse: 
					[byteStream nextPut: (length // 256 + 192).
					byteStream nextPut: (length \\ 256)].
			aString do: [:char | byteStream nextPut: (char codePoint min: 255)]]
		ifFalse: [self writeByteArray: aString].	"takes more space"! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 1/8/2024 13:08:38' prior: 16945220!
               xIllegal
	"An illegal character was encountered"
	self notify: 'Illegal character (char code ' , hereChar printString, ' ', hereChar hex , ')' at: mark! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 1/8/2024 13:08:03' prior: 50341864!
     initTypeTable
	| newTable |
	newTable := Array new: 127 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"
	newTable atAll: '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.
	1 to: 127 do: [:index |
		(Character codePoint: index) isLetter ifTrue: [
			newTable at: index put: #xLetter ]].
	newTable atAll: ($0 codePoint to: $9 codePoint) put: #xDigit.
	newTable at: self doItCharacterValue put: #doIt.
	newTable at: $" codePoint put: #xDoubleQuote.
	newTable at: $# codePoint put: #xLitQuote.
	newTable at: $$ codePoint put: #xDollar.
	newTable at: $' codePoint put: #xSingleQuote.
	newTable at: $` codePoint put: #xBacktick.
	newTable at: $: codePoint put: #xColon.
	newTable at: $( codePoint put: #leftParenthesis.
	newTable at: $) codePoint put: #rightParenthesis.
	newTable at: $. codePoint put: #period.
	newTable at: $; codePoint put: #semicolon.
	newTable at: $[ codePoint put: #leftBracket.
	newTable at: $] codePoint put: #rightBracket.
	newTable at: ${ codePoint put: #leftBrace.
	newTable at: $} codePoint put: #rightBrace.
	newTable at: $^ codePoint put: #upArrow.
	newTable at: $_ codePoint put: #xUnderscore.
	newTable at: $| codePoint put: #verticalBar.
	newTable at: Character smalltalkLeftArrow codePoint put: #leftArrow.
	newTable at: Character smalltalkUpArrow codePoint put: #upArrow.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:38' prior: 16852923!
              basicInitialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c initializeShortcuts; initializeCmdShortcuts ]! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:43' prior: 16852949 overrides: 16916096!
             initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c basicInitialize ]! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:31' prior: 16852955!
  initializeCmdShortcuts
	"Initialize the (unshifted) command-key (or alt-key if not on Mac) shortcut table.
	If you want to add a new shortcut for an specific editor, for example SmalltalkEditor, you should
	define the message #smalltalkEditorCmdShortcutsSpec in a class of your category and it will
	be dynamically send"

	"NOTE: if you don't know what your keyboard generates, use Sensor test"

	"
	Editor initialize
	"

	cmdShortcuts := Array new: 256 withAll: #noop:.

	self putIntoCmdShortcuts: self allCmdShortcutsSpec
! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:15' prior: 16853014!
               putIntoCmdShortcuts: shortcutsSpec

	shortcutsSpec do: [ :ary | | i previous |
		i := ary first codePoint + 1.
		previous := cmdShortcuts at: i.
		previous = #noop:
			ifTrue: [
				cmdShortcuts at: i put: ary second ]
			ifFalse: [ 
				('Editor shortcut: ', ary first printString, ' already taken for: ', previous, 
				'. Override request for: ', ary second, '  ignored') print ]].! !
!CharacterScanner class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:10:22' prior: 16812649 overrides: 16916096!
                             initialize
	"
	CharacterScanner initialize
	"
	| stopConditions |
	stopConditions := Array new: 258.
	stopConditions atAllPut: nil.
	stopConditions at: Character space codePoint + 1 put: nil.
	stopConditions at: Character tab codePoint + 1 put: #tab.

	"This line makes lf be shown as a newLine"
	stopConditions at: Character lf codePoint + 1 put: #doNewLine.

	"This line makes cr be shown as a newLine"
	stopConditions at: Character cr codePoint + 1 put: #doNewLine.

	stopConditions at: CharacterScanner endOfRunCode put: #endOfRun.
	stopConditions at: CharacterScanner crossedXCode put: #crossedX.
	DefaultStopConditions := stopConditions.

	StopConditionsWithSpace := DefaultStopConditions copy.
	StopConditionsWithSpace at: Character space codePoint + 1 put: #space.

	StopConditionsWithPaddedSpace := DefaultStopConditions copy.
	StopConditionsWithPaddedSpace at: Character space codePoint + 1 put: #paddedSpace.
	
	! !

RemoteString removeSelector: #checkSum:!

!methodRemoval: RemoteString #checkSum: stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:39:07'!
checkSum: aString
	"Construct a checksum of the string.  A three byte number represented as Base64 characters."
	| sum shift bytes |
	sum := aString size.
	shift := 0.
	aString do: [:char |
		(shift := shift + 7) > 16 ifTrue: [shift := shift - 17].
			"shift by 7 to keep a change of adjacent chars from xoring to same value"
		sum := sum bitXor: (char numericValue bitShift: shift)
	].
	bytes := ByteArray new: 3.
	sum := sum + 16r10000000000.
	1 to: 3 do: [:ind | bytes at: ind put: (sum digitAt: ind)].
	^bytes base64Encoded!

String removeSelector: #unescapePercents!

!methodRemoval: String #unescapePercents stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:39:07'!
unescapePercents
	"change each %XY substring to the character with ASCII value XY in hex.
	This is the opposite of #percentEscapingNonAscii: and #percentEscapingNonAsciiAndThoseIn:bytes:
	(String percentEscapingNonAscii: '' bytes) unescapePercents
	'%E2%8A%99' unescapePercents
	"

	| myBytes answerClass answerBytes c decodedByte pos oldPos specialCharsByteSet |
	myBytes := self asByteArray.
	specialCharsByteSet := `ByteArray new: 256 :: at: $+ asciiValue + 1 put: 1; at: $% asciiValue + 1 put: 1; yourself`.
	answerClass := String.
	answerBytes := ByteArray streamContents: [ :byteStream |
		oldPos := 1.

		[pos := myBytes indexOfAnyIn: specialCharsByteSet startingAt: oldPos ifAbsent: [ 0 ]. pos > 0 ]
		whileTrue: [
			byteStream nextPutAll: (myBytes copyFrom: oldPos to: pos - 1).
			c := self at: pos.
			c = $+ ifTrue: [byteStream nextPut: `$  asciiValue` ] ifFalse: [
				(c = $% and: [pos + 2 <= self size]) ifTrue: [
					decodedByte := (self at: pos+1) asUppercase digitValue * 16 +
						(self at: pos+2) asUppercase digitValue.
					pos := pos + 2.
					decodedByte > 255 ifTrue: [^self].	"not really an escaped string"
					decodedByte > 127 ifTrue: [ answerClass := UnicodeString ].
					byteStream nextPut: decodedByte ]
				ifFalse: [byteStream nextPut: c numericValue ]].
			oldPos := pos+1].
		byteStream nextPutAll: (myBytes copyFrom: oldPos to: self size).
	].
	^ answerClass fromUtf8Bytes: answerBytes!

UnicodeCodePoint removeSelector: #numericValue!

!methodRemoval: UnicodeCodePoint #numericValue stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:39:07'!
numericValue
self flag: #unicodeNeedsImprovement.
"To be removed. make it the Latin-1 codePoint for the time being.
This doesn't make much sense."
	value < 256 ifTrue: [ ^value ].
	^255!

Character removeSelector: #numericValue!

!methodRemoval: Character #numericValue stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:39:07'!
numericValue
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding."

	<primitive: 171>
	^self primitiveFailed!

Editor initialize!

CharacterScanner initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st----!

'From Cuis6.3 [latest update: #6169] on 8 January 2024 at 4:38:38 pm'!
!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 16:36:44' overrides: 17008854!
                          next: n into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| max |
	max := (readLimit - position) min: n.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex+max-1
		with: collection
		startingAt: position+1.
	position := position + max.
	max = n
		ifTrue:[^aCollection]
		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 1/8/2024 16:38:06' prior: 16842319!
                      streamedRepresentationOf: anObject

	| file |
	file := (ReadWriteStream on: (ByteArray new: 5000)).
	(self on: file) nextPut: anObject.
	^file contents! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 1/8/2024 16:38:09' prior: 16842345 overrides: 16915887!
             unStream: aByteArray

	^(self on: ((ReadWriteStream with: aByteArray) reset)) next! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 1/8/2024 15:29:31' prior: 16955897 overrides: 16841449!
                             nextPut: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.
	You can see an analysis of which objects are written out by doing: 
	(SmartRefStream statsOfSubObjects: anObject)
	(SmartRefStream tallyOfSubObjects: anObject)
	(SmartRefStream subObjects: anObject ofClass: aClass)"

| info |
topCall
	ifNil: [
		topCall := anObject.
		'Please wait while objects are counted' 
			displayProgressAt: Sensor mousePoint
			from: 0 to: 10
			during: [ :barBlock | info := self instVarInfo: anObject].
		byteStream binary.
		'Writing an object file' displayProgressAt: Sensor mousePoint
			from: 0 to: objCount*4	"estimate"
			during: [ :barBlock |
				objCount := 0.
				progressBar := barBlock.
				self setStream: byteStream reading: false.
					"set basePos, but keep any class renames"
				super nextPut: ReferenceStream versionCode.
				super nextPut: info.
				super nextPut: anObject.		"<- the real writing"
				].
					"Note: the terminator, $!!, is not doubled inside object data"
		"references is an IDict of every object that got written"
		byteStream nextPut: $!! codePoint; nextPut: 10; nextPut: 10.
		byteStream padToEndIfCantTruncate.
		topCall := progressBar := nil]	"reset it"
	ifNotNil: [
		super nextPut: anObject.
		progressBar ifNotNil: [progressBar value: (objCount := objCount + 1)]].
! !

Smalltalk removeClassNamed: #RWBinaryOrTextStream!

!classRemoval: #RWBinaryOrTextStream stamp: 'Install-6186-RWBinaryOrTextStream-remove-JuanVuletich-2024Jan08-15h25m-jmv.004.cs.st 1/30/2024 19:39:07'!
ReadWriteStream subclass: #RWBinaryOrTextStream
	instanceVariableNames: 'isBinary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6186-RWBinaryOrTextStream-remove-JuanVuletich-2024Jan08-15h25m-jmv.004.cs.st----!

'From Cuis6.3 [latest update: #6179] on 8 January 2024 at 5:03:37 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 16:55:13' prior: 16810910!
       isLetter
	"Answer whether the receiver is a letter."
	"
	(Character codePoint: 16r22C7) isLetter
	(Character codePoint: 16r042F) isLetter
	(Character codePoint: 16r0431) isLetter
	"
	^self isLowercase or: [ self isUppercase ]! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 16:56:03' prior: 50342137!
          isLineSeparator
	"Answer whether the receiver is a line separator character:
	line feed, cr, or form feed."

	^ #(10 13 12 16r0085 16r2028 16r2029) statePointsTo: self codePoint! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 16:58:26' prior: 16810956!
                          isValidInBinarySelectors
	"Can be part of a binary selector?
		$< isValidInBinarySelectors
		$| isValidInBinarySelectors
		$^ isValidInBinarySelectors
		$: isValidInBinarySelectors
	(Character codePoint: 16r22C7) isValidInBinarySelectors
	(Character codePoint: 16r042F) isValidInBinarySelectors
	(Character codePoint: 16r0431) isValidInBinarySelectors
	(Character codePoint: 16r20D7) isValidInBinarySelectors
	"
	self isNullCharacter ifTrue: [ ^false ].
	^#(verticalBar upArrow xColon xBinary xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 17:01:44' prior: 16810969!
     isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self = $ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'fileman-testing' stamp: 'jmv 1/8/2024 16:54:29' prior: 16811121!
    isDriveLetter
	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' includes: self! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6187-Character-includeCodePointBehavior-JuanVuletich-2024Jan08-16h54m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6179] on 8 January 2024 at 5:22:17 pm'!
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 1/8/2024 17:18:05' prior: 50340120!
                    < aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	self == aCharacter ifTrue: [ ^false ].

	(self codePoint < 256 and: [ aCharacter codePoint < 256 ]) ifTrue: [
		^String does: self collateBefore: aCharacter ].
	
	^self codePoint < aCharacter codePoint.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6188-Tweak-JuanVuletich-2024Jan08-17h18m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6181] on 9 January 2024 at 10:20:48 am'!

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CompositionMapping DecompositionMapping UppercaseLettersTable LowercaseLettersTable CanonicalCombiningClasses NamedCharactersMap SymbolsLikeTable DiacriticalMarksTable '
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6189-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h01m-jmv.001.cs.st 1/30/2024 19:39:07'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!
!Character class methodsFor: 'class initialization' stamp: 'jmv 4/11/2023 12:34:44' overrides: 16916096!
                        initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	Character initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~= $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap! !
!Character class methodsFor: 'class initialization' stamp: 'len 5/19/2023 17:27:22'!
                      initializeNamedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."

	NamedCharactersMap := Dictionary new.
	"Superscripts:"
	4 to: 9 do: [:each| NamedCharactersMap at: '^', each printString put: (self codePoint: 16r2070 + each)].
	"Subscripts:"
	0 to: 9 do: [:each| NamedCharactersMap at: '_', each printString put: (self codePoint: 16r2080 + each)].
	'hklmnpst' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r2094 + i)].
	'iruv' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r1D61 + i)].
	"Combining characters:"
	#(
		(acute 16r0301) ('''' 16r0301) (bar 16r0304) (breve 16r0306) (check 16r030C)
		(grave 16r0300) ('`' 16r0300) (hat 16r0302) (not 16r0338) (overline 16r0305)
		(tilde 16r0303) ('~' 16r0303) ('"' 16r0308) (vec 16r20D7)
	) do: [:each| NamedCharactersMap at: each first put: (self codePoint: each second)].
	#(
		"Some more superscripts and subscripts:"
		('^0' $) ('^1' $) ('^2' $) ('^3' $) ('^i' $) ('^n' $) ('_j' $) ('^+' $) ('^-' $) ('_+' $) ('_-' $)
		"Arrows:"
		(left $) (right $) (up $) (down $) (leftright $) (updown $)
		(Left $) (Up $) (Right $) (Down $) (Leftright $) (Updown $)
		(gets $) (to $) (mapsto $) (mapsfrom $) (implies $) (impliedby $) (iff $)
		(from $) (iso $) (From $) (To $) (dfrom $) (dto $) "non-standard"
		"Greek alphabet:"
		(alpha $) (beta $) (gamma $) (delta $) (epsilon $) (zeta $) (eta $) (theta $) (iota $) (kappa $) (lambda $) (mu $) (nu $) (xi $) (omicron $) (pi $) (rho $) (sigmaf $) (sigma $) (tau $) (upsilon $) (phi $) (chi $) (psi $) (omega $) (thetasym $) (upsih $) (piv $)
		(Alpha $) (Beta $) (Gamma $) (Delta $) (Epsilon $) (Zeta $) (Eta $) (Theta $) (Iota $) (Kappa $) (Lambda $) (Mu $) (Nu $) (Xi $) (Omicron $) (Pi $) (Rho $) (Sigma $) (Tau $) (Upsilon $) (Phi $) (Chi $) (Psi $) (Omega $)
		"Blackboard bold:"
		(A $) (B $) (C $) (D $) (E $) (F $) (G $) (H $) (I $) (J $) (K $) (L $) (M $) (N $) (O $) (P $) (Q $) (R $) (S $) (T $) (U $) (V $) (W $) (X $) (Y $) (Z $)
		"Math symbols:"
		(oplus $) (otimes $) (ominus $) (odot $) (oslash $)
		(times $) (div $) (circ $) (bullet $) (cdot $) (pm $) (wr $)
		(perp $)		
		(cap $) (cup $) (sqcap $) (sqcup $) (wedge $) (vee $) (perp $) (parallel $)	
		(in $) (notin $) (exists $) (nexists $) (forall $) (emptyset $) (infty $) (aleph $) (ell $)
		(Im $) (Re $) (wp $)
		(sqrt $) (partial $) (deg $)
(leq $) (geq $) (neq $) (prec $) (succ $) (simeq $) (cong $) (equiv $) (approx $) (subset $) (supset $)
		(ldots $) (cdots $) (ddots $) (iddots $) (vdots $) "(prime $) (dprime $) (tprime $)"
		"Other:"
		(langle $) (rangle $) (lceil $) (rceil $) (lfloor $) (rfloor $) (ltimes $) (rtimes $) 
		(lowast $) (dag $) (ddag $) (emdash $) (endash $) (questiondown $) (exclamdown $)
		(euro $) (pounds $) (celsius $) (farenheit $)
		(registered $) (copyright $) (trademark $) (snowman $) (section $))
	do: [:each| NamedCharactersMap at: each first put: each second].
	
	"Some synonyms:"
	#((prod sqcap) (coprod sqcup) (stack sqcap) (augment sqcup) (and wedge) (or vee) (xor oplus))
	do: [:each| NamedCharactersMap at: each first put: (NamedCharactersMap at: each second)]! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 4/3/2023 14:40:54'!
                    zeroWidthSpace
	^self  codePoint: 16r200B! !
!Character class methodsFor: 'services' stamp: 'jmv 12/11/2022 19:05:09'!
         canonicalCompositionOf: numericCodePoint and: combiningCodePoint

	| dict |
	dict := CompositionMapping at: numericCodePoint
		ifAbsent: [^nil ].
	^dict at: combiningCodePoint ifAbsent: nil! !
!Character class methodsFor: 'services' stamp: 'jmv 12/11/2022 19:06:32'!
                     canonicalDecomposition: numericCodePoint on: aStream

	| decomposition |
	decomposition := DecompositionMapping at: numericCodePoint
		ifAbsent: [^aStream nextPutCodePoint: numericCodePoint].
	decomposition do: [ :each |
		self canonicalDecomposition: each on: aStream ]! !
!Character class methodsFor: 'services' stamp: 'jmv 12/11/2022 19:14:16'!
    combiningClass: numericCodePoint
	(self isDiacriticalMark: numericCodePoint) ifFalse: [ ^0 ].
	^CanonicalCombiningClasses at: numericCodePoint ifAbsent: [ 	0 ]! !
!Character class methodsFor: 'services' stamp: 'jmv 12/2/2022 14:15:14'!
                    isCombiningStarter: numericCodePoint
	^ (self combiningClass: numericCodePoint) = 0! !
!Character class methodsFor: 'services' stamp: 'jmv 12/2/2022 14:13:46'!
isDiacriticalMark: numericCodePoint
	"
	(Character isDiacriticalMark: 16r0041) 
	(Character codePoint: 16r0041) isDiacriticalMark
	(Character isDiacriticalMark: 16r20D7)
	(Character codePoint: 16r20D7) isDiacriticalMark
	"
	| i |
	i := numericCodePoint + 1.
	DiacriticalMarksTable bitSize < i ifTrue: [ ^false ].
	^ DiacriticalMarksTable bitBooleanAt: i.! !
!Character class methodsFor: 'constants' stamp: 'len 12/1/2022 12:23:44'!
                namedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name."

	^ NamedCharactersMap! !

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6189-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h01m-jmv.001.cs.st 1/30/2024 19:39:07'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6189-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h01m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6182] on 9 January 2024 at 10:37:27 am'!
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:34:51' prior: 16810924!
                      isLowercase
	"Answer whether the receiver is a letter."
	"
	(Character codePoint: 16r22C7) isLowercase
	(Character codePoint: 16r042F) isLowercase
	(Character codePoint: 16r0431) isLowercase
	"
	| i |
	i := self codePoint + 1.
	LowercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^LowercaseLettersTable bitBooleanAt: i.! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:35:17' prior: 16810943!
         isSymbolLike
	"
	(Character codePoint: 16r0041) isSymbolLike
	(Character codePoint: 16r002B) isSymbolLike
	(Character codePoint: 16r03F6) isSymbolLike
	(Character codePoint: 16r2140) isSymbolLike
	"
	| i |
	i := self codePoint + 1.
	SymbolsLikeTable bitSize < i ifTrue: [ ^false ].
	^ SymbolsLikeTable bitBooleanAt: i.! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:36:00' prior: 16810952!
             isUppercase
	"Answer whether the receiver is an uppercase letter."
	"
	(Character codePoint: 16r22C7) isUppercase
	(Character codePoint: 16r042F) isUppercase
	(Character codePoint: 16r0431) isUppercase
	"
	| i |
	i := self codePoint + 1.
	UppercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^UppercaseLettersTable bitBooleanAt: i.! !

UnicodeCodePoint removeSelector: #asUnicodeCodePoint!

!methodRemoval: UnicodeCodePoint #asUnicodeCodePoint stamp: 'Install-6190-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h31m-jmv.001.cs.st 1/30/2024 19:39:12'!
asUnicodeCodePoint
	^self!

Character removeSelector: #asUnicodeCodePoint!

!methodRemoval: Character #asUnicodeCodePoint stamp: 'Install-6190-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h31m-jmv.001.cs.st 1/30/2024 19:39:12'!
asUnicodeCodePoint
	^UnicodeCodePoint codePoint: self codePoint!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6190-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h31m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6183] on 9 January 2024 at 11:19:13 am'!
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:39:52' prior: 16810898!
             isDiacriticalMark
	"
	(Character codePoint: 16r0041) isDiacriticalMark
	(Character codePoint: 16r20D7) isDiacriticalMark
	"
	| i |
	i := self codePoint + 1.
	DiacriticalMarksTable bitSize < i ifTrue: [ ^false ].
	^ DiacriticalMarksTable bitBooleanAt: i.! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:43:56' prior: 50342151!
              isSeparator
	"Answer whether the receiver is one of the separator characters"
	"Also see #separators"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203"UnicodeCodePoint zeroWidthSpace")
			statePointsTo: self codePoint! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:14:11' prior: 50339498!
                     isValidInFilenames
	"Can be part of a filename?
		$< isValidInFilenames
		$a isValidInFilenames
		$| isValidInFilenames
		$^ isValidInFilenames
		$: isValidInFilenames
	"
self flag: #unicodeNeedsImprovement.
	self isNullCharacter ifTrue: [ ^false ].
	self isSeparator ifTrue: [ ^false ].
	^(#( $: $< $> $| $/ $\ $? $* $") statePointsTo: self) not.! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 10:44:23' prior: 50341241!
separators
	"Answer the separator characters"
	"Also see #isSeparator"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203"UnicodeCodePoint zeroWidthSpace")
			collect: [ :v | Character codePoint: v ]! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/9/2024 10:53:18' prior: 50343437!
           zeroWidthSpace
	^self codePoint: 16r200B! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 1/9/2024 10:45:34' prior: 16972610!
                             mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint = $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint = $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOfUnicodeCodePoint: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ UnicodeCodePoint zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOfUnicodeCodePoint: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph. upArrowGlyph. rightArrowGlyph. downArrowGlyph. carriageReturnGlyph}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6191-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-11h18m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6184] on 9 January 2024 at 12:08:51 pm'!
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/9/2024 11:23:12' prior: 50340372!
                  asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Same for UnicodeCodePoint and Character.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].
	
	"Prefer Character over UnicodeCodePoint for literals, if ASCII only."
	"bueh......"
	literalObject class == UnicodeCodePoint ifTrue: [
		^ Character codePoint: literalObject codePoint ].

	^literalObject! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6192-UseCharacter-NotUnicodeCodePoint-JuanVuletich-2024Jan09-12h07m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6184] on 9 January 2024 at 12:01:01 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:39:35' prior: 50343140!
               isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self = $ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:26:03' prior: 16811042 overrides: 16913675!
                     asString
	^self codePoint > 255
		ifTrue: [ UnicodeString with: self ]
		ifFalse: [ String with: self ].! !
!Character methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:27:54' prior: 16811086!
withDiacriticalMark: codePointOrCharacter
	"Answer the character resulting from adding a diacritical mark (accent) to a letter.
	If the result is unsupported in ISO 8859-15, answer the receiver.
	Supported diacritical marks are:
		U+0300 	COMBINING GRAVE ACCENT
		U+0301 	COMBINING ACUTE ACCENT
		U+0302 	COMBINING CIRCUMFLEX ACCENT
		U+0303 	COMBINING TILDE
		U+0308 	COMBINING DIAERESIS
		U+030A 	COMBINING RING ABOVE
		U+030C 	COMBINING CARON
		$a withDiacriticalMark: 16r301
		$N withDiacriticalMark: $~
		$Z withDiacriticalMark: $v
		
		invalid:
		$9 withDiacriticalMark:$v
		$A withDiacriticalMark: $v
		$ withDiacriticalMark: $v
		$A withDiacriticalMark: 1244
		"
	| answer i |
	i := ((codePointOrCharacter isNumber
			ifTrue: [#(16r300 16r301 16r302 16r303 16r308 16r30A 16r30C)]
			ifFalse: [#($` $' $^ $~ $" $ $v)]) indexOf: codePointOrCharacter
				) + 1.
	answer := (Character accentedLetters detect: [ :group | group first = self ] ifNone: [ ^self ]) at: i.
	^answer = $- ifFalse: [answer] ifTrue: [self]! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:33:11' prior: 50343212 overrides: 16916096!
       initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	Character initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~= $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap.! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:35:51' prior: 50343314!
      initializeNamedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."

	NamedCharactersMap := Dictionary new.
	"Superscripts:"
	4 to: 9 do: [:each| NamedCharactersMap at: '^', each printString put: (self codePoint: 16r2070 + each)].
	"Subscripts:"
	0 to: 9 do: [:each| NamedCharactersMap at: '_', each printString put: (self codePoint: 16r2080 + each)].
	'hklmnpst' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r2094 + i)].
	'iruv' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r1D61 + i)].
	"Combining characters:"
	#(
		(acute 16r0301) ('''' 16r0301) (bar 16r0304) (breve 16r0306) (check 16r030C)
		(grave 16r0300) ('`' 16r0300) (hat 16r0302) (not 16r0338) (overline 16r0305)
		(tilde 16r0303) ('~' 16r0303) ('"' 16r0308) (vec 16r20D7)
	) do: [:each| NamedCharactersMap at: each first put: (self codePoint: each second)].
	#(
		"Some more superscripts and subscripts:"
		('^0' $) ('^1' $) ('^2' $) ('^3' $) ('^i' $) ('^n' $) ('_j' $) ('^+' $) ('^-' $) ('_+' $) ('_-' $)
		"Arrows:"
		(left $) (right $) (up $) (down $) (leftright $) (updown $)
		(Left $) (Up $) (Right $) (Down $) (Leftright $) (Updown $)
		(gets $) (to $) (mapsto $) (mapsfrom $) (implies $) (impliedby $) (iff $)
		(from $) (iso $) (From $) (To $) (dfrom $) (dto $) "non-standard"
		"Greek alphabet:"
		(alpha $) (beta $) (gamma $) (delta $) (epsilon $) (zeta $) (eta $) (theta $) (iota $) (kappa $) (lambda $) (mu $) (nu $) (xi $) (omicron $) (pi $) (rho $) (sigmaf $) (sigma $) (tau $) (upsilon $) (phi $) (chi $) (psi $) (omega $) (thetasym $) (upsih $) (piv $)
		(Alpha $) (Beta $) (Gamma $) (Delta $) (Epsilon $) (Zeta $) (Eta $) (Theta $) (Iota $) (Kappa $) (Lambda $) (Mu $) (Nu $) (Xi $) (Omicron $) (Pi $) (Rho $) (Sigma $) (Tau $) (Upsilon $) (Phi $) (Chi $) (Psi $) (Omega $)
		"Blackboard bold:"
		(A $) (B $) (C $) (D $) (E $) (F $) (G $) (H $) (I $) (J $) (K $) (L $) (M $) (N $) (O $) (P $) (Q $) (R $) (S $) (T $) (U $) (V $) (W $) (X $) (Y $) (Z $)
		"Math symbols:"
		(oplus $) (otimes $) (ominus $) (odot $) (oslash $)
		(times $) (div $) (circ $) (bullet $) (cdot $) (pm $) (wr $)
		(perp $)		
		(cap $) (cup $) (sqcap $) (sqcup $) (wedge $) (vee $) (perp $) (parallel $)	
		(in $) (notin $) (exists $) (nexists $) (forall $) (emptyset $) (infty $) (aleph $) (ell $)
		(Im $) (Re $) (wp $)
		(sqrt $) (partial $) (deg $)
(leq $) (geq $) (neq $) (prec $) (succ $) (simeq $) (cong $) (equiv $) (approx $) (subset $) (supset $)
		(ldots $) (cdots $) (ddots $) (iddots $) (vdots $) "(prime $) (dprime $) (tprime $)"
		"Other:"
		(langle $) (rangle $) (lceil $) (rceil $) (lfloor $) (rfloor $) (ltimes $) (rtimes $) 
		(lowast $) (dag $) (ddag $) (emdash $) (endash $) (questiondown $) (exclamdown $)
		(euro $) (pounds $) (celsius $) (farenheit $)
		(registered $) (copyright $) (trademark $) (snowman $) (section $))
	do: [:each| NamedCharactersMap at: each first put: each second].
	
	"Some synonyms:"
	#((prod sqcap) (coprod sqcup) (stack sqcap) (augment sqcup) (and wedge) (or vee) (xor oplus))
	do: [:each| NamedCharactersMap at: each first put: (NamedCharactersMap at: each second)]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:39:40' prior: 16992610!
                           isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self = $ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:28:07' prior: 50341531!
  withDiacriticalMark: codePointOrCharacter
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (
			(Character codePoint: value) withDiacriticalMark: codePointOrCharacter)
				codePoint ].
	^self! !
!UnicodeCodePoint class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 11:51:27' prior: 16992830!
    codePoint: aNumber
	^Character codePoint: aNumber! !
!UnicodeCodePoint class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:33:04' prior: 16992835 overrides: 16916096!
            initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	UnicodeCodePoint initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~= $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap.! !
!UnicodeCodePoint class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:35:57' prior: 16992936!
                        initializeNamedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."

	NamedCharactersMap := Dictionary new.
	"Superscripts:"
	4 to: 9 do: [:each| NamedCharactersMap at: '^', each printString put: (self codePoint: 16r2070 + each)].
	"Subscripts:"
	0 to: 9 do: [:each| NamedCharactersMap at: '_', each printString put: (self codePoint: 16r2080 + each)].
	'hklmnpst' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r2094 + i)].
	'iruv' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r1D61 + i)].
	"Combining characters:"
	#(
		(acute 16r0301) ('''' 16r0301) (bar 16r0304) (breve 16r0306) (check 16r030C)
		(grave 16r0300) ('`' 16r0300) (hat 16r0302) (not 16r0338) (overline 16r0305)
		(tilde 16r0303) ('~' 16r0303) ('"' 16r0308) (vec 16r20D7)
	) do: [:each| NamedCharactersMap at: each first put: (self codePoint: each second)].
	#(
		"Some more superscripts and subscripts:"
		('^0' $) ('^1' $) ('^2' $) ('^3' $) ('^i' $) ('^n' $) ('_j' $) ('^+' $) ('^-' $) ('_+' $) ('_-' $)
		"Arrows:"
		(left $) (right $) (up $) (down $) (leftright $) (updown $)
		(Left $) (Up $) (Right $) (Down $) (Leftright $) (Updown $)
		(gets $) (to $) (mapsto $) (mapsfrom $) (implies $) (impliedby $) (iff $)
		(from $) (iso $) (From $) (To $) (dfrom $) (dto $) "non-standard"
		"Greek alphabet:"
		(alpha $) (beta $) (gamma $) (delta $) (epsilon $) (zeta $) (eta $) (theta $) (iota $) (kappa $) (lambda $) (mu $) (nu $) (xi $) (omicron $) (pi $) (rho $) (sigmaf $) (sigma $) (tau $) (upsilon $) (phi $) (chi $) (psi $) (omega $) (thetasym $) (upsih $) (piv $)
		(Alpha $) (Beta $) (Gamma $) (Delta $) (Epsilon $) (Zeta $) (Eta $) (Theta $) (Iota $) (Kappa $) (Lambda $) (Mu $) (Nu $) (Xi $) (Omicron $) (Pi $) (Rho $) (Sigma $) (Tau $) (Upsilon $) (Phi $) (Chi $) (Psi $) (Omega $)
		"Blackboard bold:"
		(A $) (B $) (C $) (D $) (E $) (F $) (G $) (H $) (I $) (J $) (K $) (L $) (M $) (N $) (O $) (P $) (Q $) (R $) (S $) (T $) (U $) (V $) (W $) (X $) (Y $) (Z $)
		"Math symbols:"
		(oplus $) (otimes $) (ominus $) (odot $) (oslash $)
		(times $) (div $) (circ $) (bullet $) (cdot $) (pm $) (wr $)
		(perp $)		
		(cap $) (cup $) (sqcap $) (sqcup $) (wedge $) (vee $) (perp $) (parallel $)	
		(in $) (notin $) (exists $) (nexists $) (forall $) (emptyset $) (infty $) (aleph $) (ell $)
		(Im $) (Re $) (wp $)
		(sqrt $) (partial $) (deg $)
(leq $) (geq $) (neq $) (prec $) (succ $) (simeq $) (cong $) (equiv $) (approx $) (subset $) (supset $)
		(ldots $) (cdots $) (ddots $) (iddots $) (vdots $) "(prime $) (dprime $) (tprime $)"
		"Other:"
		(langle $) (rangle $) (lceil $) (rceil $) (lfloor $) (rfloor $) (ltimes $) (rtimes $) 
		(lowast $) (dag $) (ddag $) (emdash $) (endash $) (questiondown $) (exclamdown $)
		(euro $) (pounds $) (celsius $) (farenheit $)
		(registered $) (copyright $) (trademark $) (snowman $) (section $))
	do: [:each| NamedCharactersMap at: each first put: each second].
	
	"Some synonyms:"
	#((prod sqcap) (coprod sqcup) (stack sqcap) (augment sqcup) (and wedge) (or vee) (xor oplus))
	do: [:each| NamedCharactersMap at: each first put: (NamedCharactersMap at: each second)]! !
!EventSensor methodsFor: 'test' stamp: 'jmv 1/9/2024 11:28:42' prior: 16856344!
   printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp unicodeCodePoint |
	type := evtBuf first.
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode := evtBuf third.
			unicodeCodePoint := evtBuf sixth.
			pressType := evtBuf fourth.
			modifiers := evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type := #keystroke].
			{type. 'macRoman:'. macRomanCode. macRomanCode hex.
				'unicodeCodePoint:'. unicodeCodePoint. unicodeCodePoint hex. Character codePoint: unicodeCodePoint} print.
			Transcript nextPutAll: ' modifiers: ', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript nextPutAll: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript nextPutAll: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript nextPutAll: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript nextPutAll: ' [shift]' ].
			''print.
			].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:39:46' prior: 50341668!
    asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in char rest did |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [(char := in next) = $&
					ifTrue: [
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 11:26:50' prior: 16993208 overrides: 16913349!
                at: codePointIndex
	"Answer the UnicodeCodePoint at code point index codePointIndex.
	(not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ Character codePoint: (bytes at: codePointIndex) ].
	byteIndex := self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^Character codePoint: codePoint ].
	^nil "Invalid UTF-8"! !
!UnicodeString methodsFor: 'enumerating' stamp: 'jmv 1/9/2024 11:24:34' prior: 16993947 overrides: 16947773!
  do: aBlock
	"Evaluate aBlock for all elements."

	| byteIndex stopByteIndex n |
	byteIndex := 1.
	stopByteIndex := bytes size.
	[ byteIndex <= stopByteIndex ] whileTrue: [
		n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (Character codePoint: codePoint) ].
		byteIndex := byteIndex + n ].! !
!UnicodeString methodsFor: 'enumerating' stamp: 'jmv 1/9/2024 11:24:30' prior: 16993961 overrides: 16947973!
                  from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n cpIndex |
	byteIndex := self byteIndexAt: startIndex.
	cpIndex := startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (Character codePoint: codePoint).
			cpIndex := cpIndex + 1 ].
		byteIndex := byteIndex + n ].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:26:32' prior: 16994351!
                      basicCanonicalComposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalComposition.
	(UnicodeString fromCodePoints: #(119128 119141)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119135 119151)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119128 119141 119151)) basicCanonicalComposition asCodePoints
	"
	| byteIndex stopByteIndex n combining cls |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls := Character combiningClass: codePoint.
				cls = 0 ifTrue: [
					self basicCompose: combining on: strm.
					combining := OrderedCollection new ].
				combining add: codePoint ].
			byteIndex := byteIndex + n ].
		self basicCompose: combining on: strm ].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:26:14' prior: 16994387!
                basicCanonicalDecomposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalDecomposition.
	(Character codePoint: 119135) asString basicCanonicalDecomposition asCodePoints
	(Character codePoint: 119137) asString basicCanonicalDecomposition asCodePoints
	"
	| byteIndex stopByteIndex n |
	byteIndex := 1.
	stopByteIndex := bytes size.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				Character canonicalDecomposition: codePoint on: strm ].
			byteIndex := byteIndex + n ]].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:24:46' prior: 16994413!
                          basicCanonicallyOrdered
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	(UnicodeString fromCodePoints: #(16r61  16r0300 16r0315 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0300 16r031B 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r031B 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r0300 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0300 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0315 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	"
	| byteIndex stopByteIndex n combining cls element |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls := Character combiningClass: codePoint.
				cls = 0
					ifTrue: [
						combining notEmpty ifTrue: [
							combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
							combining do: [ :e | strm nextPutCodePoint: e third ]].
						strm nextPutCodePoint: codePoint.
						combining := OrderedCollection new ]
					ifFalse: [
						element := { cls. combining size+1. codePoint }.
						combining add: element ]].
			byteIndex := byteIndex + n ].
		combining notEmpty ifTrue: [
			combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
			combining do: [ :e | strm nextPutCodePoint: e third ] ]].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:24:41' prior: 16994478!
        basicCompose: combiningCodePoints on: aStream
	| continue composition i base |
	combiningCodePoints notEmpty ifTrue: [
		continue := combiningCodePoints size > 1.
		[continue] whileTrue: [
			continue := false.
			base := combiningCodePoints first.
			i := 2.
			composition := nil.
			[composition isNil and: [i <= combiningCodePoints size ]] whileTrue: [
				composition := Character canonicalCompositionOf: base and: (combiningCodePoints at: i).
				composition ifNotNil: [
					combiningCodePoints at: 1 put: composition.
					combiningCodePoints removeAt: i.
					continue := combiningCodePoints size > 1 ].
				i := i + 1 ]].
		combiningCodePoints do: [ :e | aStream nextPutCodePoint: e ]].! !
!UniFileStream methodsFor: 'private' stamp: 'jmv 1/9/2024 11:23:45' prior: 16992088!
               nextCodePoint
	| answer |
	answer := nil.
	self nextUtf8BytesAndCodePointInto: nil into: [ :codePoint |
		answer := Character codePoint: codePoint ].

	"If we'd skipped BOM, try again. See comment at
	utf8BytesAndCodePointFor:byte2:byte3:byte4:into:into:
	Feel free to blame Microsoft for this nonsense."
	answer ifNil: [
		(self position = 3 and: [self atEnd not]) ifTrue: [
			answer := self nextCodePoint ]].

	^answer! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 1/9/2024 11:37:11' prior: 16945229!
                          xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore
		or: [type == #xDiacritical
		or: [ hereChar = $ ]]]]  						"Also see #isValidInIdentifiers"
	] whileTrue: [
			"open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
				ifTrue: [DoItCharacter "doit"]
				ifFalse: [source next]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~= $=]])
		ifTrue: [
			buffer nextPut: self step.
			"Allow any number of embedded colons in literal symbols"
			[(self typeTableAt: hereChar) == #xColon]
				whileTrue:
					[buffer nextPut: self step].
			#keyword]
		ifFalse: [
			#word].
	token := buffer contents.! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:35:09' prior: 16945411!
                 typeTable: aTypeTable at: aCharacterOrCodePoint

	"Prebuilt tables for the ASCII range"
	aCharacterOrCodePoint asciiValue ifNotNil: [ :ascii |
		^aTypeTable at: ascii ].

	"For CodePoints not in the ASCII range"
	aCharacterOrCodePoint isDiacriticalMark ifTrue: [ ^#xDiacritical ].
	aCharacterOrCodePoint isLetter ifTrue: [ ^#xLetter ].
	aCharacterOrCodePoint isSymbolLike ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint = $ ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint isSeparator ifTrue: [ ^#xDelimiter ].
	"Many should actually be #xIllegal"
	^#xLetter! !
!Scanner class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:34:21' prior: 50341858 overrides: 16916096!
                           initialize
	"
	Scanner initialize.
	"
	self initTypeTable.
	self initializeDoitCharacter! !
!Scanner class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:23:19' prior: 16945448!
  initializeDoitCharacter

	DoItCharacter := Character codePoint: self doItCharacterValue ! !
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/9/2024 11:23:12' prior: 50343790!
                    asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Same for UnicodeCodePoint and Character.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].
	
	"Prefer Character over UnicodeCodePoint for literals, if ASCII only."
	"bueh......"
	literalObject class == UnicodeCodePoint ifTrue: [
		^ Character codePoint: literalObject codePoint ].

	^literalObject! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 1/9/2024 11:22:20' prior: 16852593!
                            normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| character i replacement |
	"Convert strings like '\+161 ' () to unicode"
	aKeyboardEvent isSpace ifTrue: [ | string |
		string := self privateCurrentString.
		self pointIndex - 1 to: (self pointIndex - 7 max: 1) by: -1 do: [ :index |
		string at: index :: = $\ ifTrue: [ | key |
			key := string copyFrom: index + 1 to: self pointIndex - 1.
			key size > 2 and: [ key at: 1 :: = $+ ] ::
				ifTrue: [ | stream number value |
					stream := ReadStream on: key asUppercase from: 2 to: key size.
					[ number := Integer readFrom: stream  base: 16 ] on: Error do: [ ^ false ].
					value := Character codePoint: number.
					self
						selectFrom: index to: self pointIndex - 1;
						replaceSelectionWith: (UnicodeString with: value).
						^ false ] ] ] ].
	character := aKeyboardEvent keyCharacter.
	"Linux VMs don't automatically replace combining marks + space with ASCII,
	as Windows and Mac VMs do. It seems it is an app responsability to do that in Linux."
	character isDiacriticalMark ifTrue: [
		i := self pointIndex-1.
		(i > 0 and: [ (self privateCurrentString at: i) = $  ]) ifTrue: [
			replacement := character caseOf: {
				[ `Character codePoint: 16r300` ] -> [ '`' ].
				[ `Character codePoint: 16r301` ] -> [ '''' ].
				[ `Character codePoint: 16r302` ] -> [ '^' ].
				[ `Character codePoint: 16r303` ] -> [ '~' ].
				[ `Character codePoint: 16r308` ] -> [ '"' ].
			} otherwise: [].
			replacement notNil ifTrue: [
				self selectFrom: i to: i; replaceSelectionWith: replacement.
				^ false ]
			]
		].
	self addString: (UnicodeString with: character).
	^false! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 1/9/2024 11:22:04' prior: 16954936 overrides: 50344760!
        normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string := self privateCurrentString.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	self pointIndex - 1 to: (self pointIndex - 20 max: 1) by: -1 do: [:i|
		(string at: i) = $\ ifTrue: 
			[key := string copyFrom: i + 1 to: self pointIndex - 1.
			Character namedCharactersMap at: key ifPresent: [:value| self selectFrom: i to: self pointIndex - 1; replaceSelectionWith: (UnicodeString with: value)].
			^ super normalCharacter: aKeyboardEvent]].
	^ super normalCharacter: aKeyboardEvent! !
!KeyboardEvent methodsFor: 'keyboard' stamp: 'jmv 1/9/2024 11:21:46' prior: 16888338!
            keyCharacter
	"Answer the character corresponding this keystroke. This is defined only for keystroke events."
	| codePoint |
	codePoint := keyValue.
	self isArrowLeft ifTrue: [ codePoint := 16r2190 ].
	self isArrowUp ifTrue: [ codePoint := 16r2191 ].
	self isArrowRight ifTrue: [ codePoint := 16r2192 ].
	self isArrowDown ifTrue: [ codePoint := 16r2193 ].
	^ Character codePoint: codePoint.! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'jmv 1/9/2024 11:21:39' prior: 16952000!
          computeMessageEntriesFor: allSource in: contextClass and: specificModel  
	
	| id rangeType |

	canShowSelectorDocumentation := true.
	id := allSource copyFrom: currentRange start to: currentRange end.
	rangeType := currentRange rangeType.

	rangeType == #globalVar
		ifTrue: [ ^self computeMessageEntriesForClass: (Smalltalk at: id asSymbol) class ].
	rangeType == #self
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass ].
	rangeType == #super
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass superclass ].
	rangeType == #true 
		ifTrue: [ ^self computeMessageEntriesForClass: True ].
	rangeType == #false
		ifTrue: [ ^self computeMessageEntriesForClass: False ].
	rangeType == #nil
		ifTrue: [ ^self computeMessageEntriesForClass: UndefinedObject ].
	rangeType == #character
		ifTrue: [ ^self computeMessageEntriesForClass: Character ].
	rangeType == #number
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #string
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #symbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #stringSymbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #instVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofInstVarNamed: id ].
	rangeType == #methodArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #tempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #blockArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockArgNamed: id ].
	rangeType == #blockTempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockTempVarNamed: id ].
	rangeType == #workspaceVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (specificModel classOfWorkspaceVarNamed: id) ].
	rangeType == #thisContext
		ifTrue: [ ^self computeMessageEntriesForClass: (specificModel classOfThisContext) ]. 
	rangeType == #classVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #poolConstant
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	(rangeType beginsWith: #blockEnd)
		ifTrue: [ ^self computeMessageEntriesForClass: BlockClosure ].
	rangeType == #arrayEnd
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	(rangeType beginsWith: #rightBrace)
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #unary
		ifTrue: [ ^self computeEntriesOfUnaryMessageReturnNamed: id ].
	(rangeType beginsWith: #rightParenthesis)
		ifTrue: [ ^self computeMessageEntriesOfEnclosedExpressionReturn].
	rangeType == #cascadeSeparator
		ifTrue: [ ^self computeMessageEntriesOfCascadeReceiver]. 

	self computeMessageEntriesForUnknowClass 
	
	! !
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:31:52' prior: 16952602 overrides: 16916096!
          initialize
	"
	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...
	[ SmalltalkCompleter initialize ]timeToRun
	Selectors inspect
	"
	| maxSortValue allImplemented |
	
	EntriesLimit := 100.
	
	SystemChangeNotifier uniqueInstance
		removeActionsWithReceiver: self.	 "avoid double registration"

	SystemChangeNotifier uniqueInstance
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #methodAddedInProtocol send: #methodAdded:selector:inProtocol:class:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self.
	
	self protected: [
		allImplemented := Smalltalk allImplementedMessages.
		Selectors := Trie new.
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				Selectors at: sel ifAbsentPut: [ 0 ].
				method messages do: [ :sentMsg |
					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				self addSelector: sel method: method allImplemented: allImplemented]].
		""
	
		"The following might not be found in #messages. Give them maximum priority."
		maxSortValue := SmallInteger maxVal.
		"From MessageNode>>#initialize"
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |
				Selectors at: sel put: maxSortValue ].
	
		maxSortValue := SmallInteger maxVal-1.
		"From SystemDictionary >>#recreateSpecialObjectsArray"
		(1 to: Smalltalk specialSelectorSize) do:  [ :i | | sym |
			sym := Smalltalk specialSelectorAt: i.
			(Selectors includesKey: sym)
				ifTrue: [ Selectors at: sym put: maxSortValue ]]]! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 1/9/2024 11:21:10' prior: 50343644!
      mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint = $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint = $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOfUnicodeCodePoint: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOfUnicodeCodePoint: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph. upArrowGlyph. rightArrowGlyph. downArrowGlyph. carriageReturnGlyph}! !

Character initialize!

UnicodeCodePoint initialize!

Scanner initialize!

SmalltalkCompleter initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DebuggerMethodMap voidMapCache.
ChangeSet zapAllChangeSets.
Smalltalk garbageCollect.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6193-UseCharacter-NotUnicodeCodePoint-JuanVuletich-2024Jan09-11h58m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6186] on 9 January 2024 at 12:26:21 pm'!
!Object methodsFor: 'testing' stamp: 'jmv 1/9/2024 12:18:01' prior: 16915240!
   isCharacter
	"Overridden to return true in Character."
	^ false! !
!CodeProvider class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:18:14' prior: 16827052!
  normalizeCodeForCodeFiles: aTextOrString
	"Adapt edited code to be suitable or logging.
	Answer is a plain text.
	Additionally, if code was modified for better look and edition experience, normalize it.
	This may include reverting to ':=' for assignment, '^' for return, and any replacements of
	ASCII by Unicode symbols done by Shout.
	See also SHTextStylerST80 >> #privateConvert
	See also Clipboard >> #storeObject:"

	| answer |
	answer := aTextOrString asPlainString.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString, Character zeroWidthSpace asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkUpArrow asString` with: '^'.
	^answer! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 12:18:55' prior: 50343603!
        isSeparator
	"Answer whether the receiver is one of the separator characters"
	"Also see #separators"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203 "Character zeroWidthSpace")
			statePointsTo: self codePoint! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:19:02' prior: 50343628!
           separators
	"Answer the separator characters"
	"Also see #isSeparator"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203 "Character zeroWidthSpace")
			collect: [ :v | Character codePoint: v ]! !
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 1/9/2024 12:19:23' prior: 50341622!
         fetchMoreEventsDiscardingMouseEvents: discardMouseEvents
	"Fetch more events from the VM"
	| eventBuffer type |

	"Reset input semaphore so clients can wait for the next events after this one."
	inputSemaphore isSignaled
		ifTrue: [
			hasInputSemaphore := true.
			inputSemaphore initSignals ].

	"DebuggingAid""
	dd := Time localMillisecondClock - lastEventPoll.
	"

	eventBuffer := Array new: 8.
	[
		self primGetNextEvent: eventBuffer.
		"DebuggingAid""
		eventBuffer first = 2 ifTrue: [
			k1 := eventBuffer third.
			u1 := eventBuffer sixth.
			pressType := eventBuffer fourth.
			typeS := 'unknown'.
			pressType = EventSensor eventKeyDown ifTrue: [
				typeS := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				typeS := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				typeS := #keystroke].
			dd >100 ifTrue: ['-' print. dd := 0 ].
			{ k1 < 256 ifTrue: [Character codePoint: k1] ifFalse: [ '[]']. Character codePoint: k1. k1. k1 hex. '-----'. 
				Character codePoint: u1. u1. u1 hex. '----'. pressType. typeS } print.
			].
		"
		type := eventBuffer at: 1.
		type = EventSensor eventTypeNone ]
			whileFalse: [
				self
					processSensorEvent: eventBuffer
					discardingMouseEvents: discardMouseEvents ].

	"Remember the last time that I checked for events."
	lastEventPoll := Time localMillisecondClock.! !
!EventSensor methodsFor: 'test' stamp: 'jmv 1/9/2024 12:25:41' prior: 50344355!
           printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp codePoint |
	type := evtBuf first.
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode := evtBuf third.
			codePoint := evtBuf sixth.
			pressType := evtBuf fourth.
			modifiers := evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type := #keystroke].
			{type. 'macRoman:'. macRomanCode. macRomanCode hex.
				'Unicode CodePoint:'. codePoint. codePoint hex. Character codePoint: codePoint} print.
			Transcript nextPutAll: ' modifiers: ', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript nextPutAll: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript nextPutAll: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript nextPutAll: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript nextPutAll: ' [shift]' ].
			''print.
			].! !
!String methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:12:34' prior: 50342381 overrides: 16913367!
                              at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	
			aCharacter codePoint > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:20:43' prior: 50344455 overrides: 16913349!
          at: codePointIndex
	"Answer the Character with the CodePoint at code point index codePointIndex.
	(not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ Character codePoint: (bytes at: codePointIndex) ].
	byteIndex := self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^Character codePoint: codePoint ].
	^nil "Invalid UTF-8"! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:21:30' prior: 16993225 overrides: 16913367!
                        at: codePointIndex put: aCharacter
	"Store argument at position codePointIndex "

	| byteIndex currentByteCount argumentBytes newBytes |

	self boundsCheck: codePointIndex.
	byteIndex := self byteIndexAt: codePointIndex.
	currentByteCount := self encodedByteCountAt: byteIndex.

	"Fastest path if both old and new are ASCII"
	currentByteCount = 1 ifTrue: [
		aCharacter asciiValue ifNotNil: [ :newAscii |
			bytes at: 	byteIndex put: newAscii.
			^ aCharacter ]].

	argumentBytes := Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint.

	"Avoid creating new bytes object if both old and new require same number of bytes"
	argumentBytes size = currentByteCount ifTrue: [
		bytes replaceFrom: byteIndex to: byteIndex + currentByteCount - 1 with: argumentBytes startingAt: 1.
		strideIndex := nil.
		hash := nil.
		^ aCharacter ].

	"More expensive: needs a new bytes object of different size"
	newBytes := ByteArray new: bytes size - currentByteCount + argumentBytes size.
	newBytes
		replaceFrom: 1 to: byteIndex-1 with: bytes startingAt: 1;
		replaceFrom: byteIndex to: byteIndex + argumentBytes size - 1 with: argumentBytes startingAt: 1;
		replaceFrom: byteIndex + argumentBytes size to: newBytes size with: bytes startingAt: byteIndex + currentByteCount.

	self privateBytes: newBytes codePointCount: count.
	^ aCharacter.! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:22:32' prior: 16993333 overrides: 16947063!
                            indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes := Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint.
	startByteIndex := self byteIndexAt: start.
	foundByteIndex := String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer := self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!UnicodeString methodsFor: 'copying' stamp: 'jmv 1/9/2024 12:22:13' prior: 16993501 overrides: 16947652!
        copyWith: aCharacter

	^UnicodeString
		fromUtf8Bytes: bytes, (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint)
		codePointCount: self size + 1.! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:06' prior: 16993509!
         < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 1].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 1]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) = 1! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:12' prior: 16993539!
                    <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) <= 2].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) <= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) <= 2! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:17' prior: 16993604!
     > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 3].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 3]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) = 3! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:22' prior: 16993634!
                     >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) >= 2].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) >= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) >= 2! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 12:21:51' prior: 16994544 overrides: 16814949!
      canonicalDecomposition
	"
	https://unicode.org/reports/tr15/#Norm_Forms
	Answer a String in the NFD form 'Normalization Form Decomposed'.

	(Character codePoint: 16r1EBF) asString
	(Character codePoint: 16r1EBF) asString asUtf8Bytes
	(Character codePoint: 16r1EBF) asString basicCanonicalDecomposition asUtf8Bytes
	(Character codePoint: 16r1EBF) asString asCodePoints asArray collect: [ :e | e hex ]
	(Character codePoint: 16r1EBF) asString basicCanonicalDecomposition asCodePoints asArray collect: [ :e | e hex ]

	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]).
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) asUtf8Bytes.
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) basicCanonicalDecomposition asUtf8Bytes.
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) basicCanonicalDecomposition asCodePoints asArray collect: [ :e | e hex ]

	(Character codePoint: 119137) asString basicCanonicalDecomposition asCodePoints
	(Character codePoint: 119135) asString basicCanonicalDecomposition asCodePoints
	"
	^self basicCanonicalDecomposition basicCanonicallyOrdered! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:22:49' prior: 16994733 overrides: 16787780!
            new: n
	"Answer will contain n null Characters"

	^self fromUtf8Bytes: (ByteArray new: n) codePointCount: n! !
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/9/2024 12:23:23' prior: 50344736!
 asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].

	^literalObject! !
!SmalltalkEditor methodsFor: 'clipboard' stamp: 'jmv 1/9/2024 12:23:46' prior: 16952965 overrides: 16852199!
                   clipboardStringOrText
	| clipContents |
	clipContents := super clipboardStringOrText.
	self replaceUnicodeArrowsWithSmalltalkArrows ifTrue: [
		clipContents := clipContents copyReplaceAll: `(Character codePoint: 16r2190) asString` with: `(Character smalltalkLeftArrow ) asString`.
		clipContents := clipContents copyReplaceAll: `(Character codePoint: 16r2191) asString` with: `(Character smalltalkUpArrow ) asString`.
		].
	^clipContents.! !
!UnicodeReadAdaptor methodsFor: 'reading' stamp: 'jmv 1/9/2024 12:24:18' prior: 16993135 overrides: 16992401!
                        next: n
	"Read n Characters (i.e. n Unicode CodePoints), or until the end of the file.
	Answer them, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Answer is an instance of UnicodeString."

	| utf8 codePointCount |
	codePointCount := 0.
	utf8 := ByteArray streamContents: [ :utf8Stream |
		[ codePointCount = n or: [stream atEnd] ] whileFalse: [
			stream
				nextUtf8BytesAndCodePointInto: [ :byte1 :byte2 :byte3 :byte4 |
					utf8Stream nextPut: byte1.
					byte2 ifNotNil: [
						utf8Stream nextPut: byte2.
						byte3 ifNotNil: [
							utf8Stream nextPut: byte3.
							byte4 ifNotNil: [
								utf8Stream nextPut: byte4 ]]].
					codePointCount := codePointCount + 1]
				into: nil ]].
	^UnicodeString fromUtf8Bytes: utf8 codePointCount: codePointCount.! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:24:29' prior: 16821689!
                 storeObject: anObject
	"Set new contents on the clipboard. Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isString or: [ anObject is: #Text])
		ifTrue: [
			contents := anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents := anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present.
	Warning: This has not yet been adapted to UTF-8 Unicode"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id := self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat := self stringOrIdFor: contents.
	"See also SHTextStylerST80 >> #privateConvert
	See also CodeProvider class >> #normalizeCodeForCodeFiles:	"
	primitiveFormat := primitiveFormat copyReplaceAll: `Character smalltalkLeftArrow asString, Character zeroWidthSpace asString` with: ':='.
	primitiveFormat := primitiveFormat copyReplaceAll: Character smalltalkLeftArrow asString with: ':='.
	primitiveFormat := primitiveFormat copyReplaceAll: Character smalltalkUpArrow asString with: '^'.
	primitiveFormat := primitiveFormat asUtf8Bytes.
	self primitiveClipboardString: primitiveFormat! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 1/9/2024 12:24:36' prior: 16943612 overrides: 16943390!
   privateConvertAssignmentsOffset: delta
	"See also CodeProvider class >> #normalizeCodeForCodeFiles:	
	See also Clipboard >> #storeObject:"
	"Turn $_ into a left arrow"

	self
		replaceStringForRangesWithType: #assignment
		with: `Character smalltalkLeftArrow asString`
		offset: delta.
	(Preferences at: #showAssignmentAsLeftArrow)
		ifTrue: [
			"Turn := into a left arrow. Include a #zeroWidthSpace so as not to modify ranges, etc."
			self
				replaceStringForRangesWithType: #ansiAssignment
				with: `Character smalltalkLeftArrow asString, Character zeroWidthSpace asString`
				offset: delta.
			"Turn $^into up arrow"
			self
				replaceStringForRangesWithType: #return
				with: `Character smalltalkUpArrow asString`
				offset: delta ].! !

Character removeSelector: #=!

!methodRemoval: Character #= stamp: 'Install-6194-Remove-UnicodeCodePoint-JuanVuletich-2024Jan09-12h12m-jmv.001.cs.st 1/30/2024 19:39:23'!
= aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].

	"Just remove this method and use inherited version when we remove UnicodeCodePoint ?"
	aCodePointOrCharacter class == UnicodeCodePoint ifFalse: [ ^false ].

	aCodePointOrCharacter isCharacter ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint!

Smalltalk removeClassNamed: #UnicodeCodePoint!

!classRemoval: #UnicodeCodePoint stamp: 'Install-6194-Remove-UnicodeCodePoint-JuanVuletich-2024Jan09-12h12m-jmv.001.cs.st 1/30/2024 19:39:23'!
Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6194-Remove-UnicodeCodePoint-JuanVuletich-2024Jan09-12h12m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6187] on 9 January 2024 at 12:36:19 pm'!
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:26:50'!
       evaluate: aBlock withUtf16WordsOf: aCodePoint
	"See senders for typical usage"

	| highSurrogate lowSurrogate |
	(aCodePoint between: 16rD800 and: 16rDFFF) ifTrue: [
		self error: 'invalid CodePoint' ].

	aCodePoint <= 16rFFFF ifTrue: [
		^aBlock value: aCodePoint ].

	highSurrogate := (aCodePoint - 16r10000) >> 10 + 16rD800.
	lowSurrogate := ((aCodePoint - 16r10000) bitAnd: 1023) + 16rDC00.
	aBlock value: highSurrogate.
	aBlock value: lowSurrogate.! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:27:12'!
             evaluate: aBlock withUtf8BytesOf: aCodePoint
	"See senders for typical usage"

	| mask nBytes shift |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	aBlock value: (aCodePoint bitShift: shift) + mask.
	2 to: nBytes do: [ :i | 
		shift := shift + 6.
		aBlock value: ((aCodePoint bitShift: shift) bitAnd: 63) + 128 ]! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:30:39'!
                 evaluateOnce: aBlock withUtf8BytesOf: aCodePoint
	"Similar to #evaluate:withUtf8BytesOf:, but aBlock is evaluated just once, and must have 4 parameters."

	| mask nBytes shift byte1 byte2 byte3 byte4 |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint value: nil value: nil value: nil ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	byte1 := (aCodePoint bitShift: shift) + mask.
	nBytes >= 2 ifTrue: [
		shift := shift + 6.
		byte2 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
		nBytes >= 3 ifTrue: [
			shift := shift + 6.
			byte3 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
			nBytes = 4 ifTrue: [
				shift := shift + 6.
				byte4 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
				].
			].
		].
		^aBlock value: byte1 value: byte2 value: byte3 value: byte4.! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:29:28'!
            utf8BytesOf: aCodePoint

	^ ByteArray streamContents: [ :strm |
		Character
			evaluate: [ :byte |
				strm nextPut: byte ]
			withUtf8BytesOf: aCodePoint ]! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:28:42' prior: 50339987!
      utf8BytesAndCodePointForIso8859s1: byte into: bytesBlock into: codePointBlock
	"Latin-1"
	| codePoint |
	codePoint := byte.
	bytesBlock ifNotNil: [
		Character
			evaluateOnce: bytesBlock
			withUtf8BytesOf: codePoint ].
	codePointBlock ifNotNil: [
		codePointBlock value: codePoint ].
	^1! !
!String methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:27:25' prior: 16960131 overrides: 16813593!
                      asUtf8Bytes
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray with a valid UTF-8 sequence."

	| inStream nextChar codePoint |
	"Fast lane."
	self isAscii ifTrue: [ ^self asByteArray ].

	"Need to do UTF-8 encoding."
	^ByteArray streamContents: [ :outStream |
		inStream := self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar := inStream next.
			codePoint := nextChar codePoint.
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOf: codePoint ]]! !
!String methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:27:29' prior: 16960151 overrides: 16813597!
                    asUtf8BytesOrByteString
	"Similar to #asUtf8Bytes.
	May answer an instance of String as an optimization.
	See senders"

	| inStream nextChar codePoint |
	"Fast lane."
	self isAscii ifTrue: [ ^self ].

	"Need to do UTF-8 encoding."
	^ByteArray streamContents: [ :outStream |
		inStream := self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar := inStream next.
			codePoint := nextChar codePoint.
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOf: codePoint ]]! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:29:33' prior: 50345385 overrides: 16913367!
                           at: codePointIndex put: aCharacter
	"Store argument at position codePointIndex "

	| byteIndex currentByteCount argumentBytes newBytes |

	self boundsCheck: codePointIndex.
	byteIndex := self byteIndexAt: codePointIndex.
	currentByteCount := self encodedByteCountAt: byteIndex.

	"Fastest path if both old and new are ASCII"
	currentByteCount = 1 ifTrue: [
		aCharacter asciiValue ifNotNil: [ :newAscii |
			bytes at: 	byteIndex put: newAscii.
			^ aCharacter ]].

	argumentBytes := Character utf8BytesOf: aCharacter codePoint.

	"Avoid creating new bytes object if both old and new require same number of bytes"
	argumentBytes size = currentByteCount ifTrue: [
		bytes replaceFrom: byteIndex to: byteIndex + currentByteCount - 1 with: argumentBytes startingAt: 1.
		strideIndex := nil.
		hash := nil.
		^ aCharacter ].

	"More expensive: needs a new bytes object of different size"
	newBytes := ByteArray new: bytes size - currentByteCount + argumentBytes size.
	newBytes
		replaceFrom: 1 to: byteIndex-1 with: bytes startingAt: 1;
		replaceFrom: byteIndex to: byteIndex + argumentBytes size - 1 with: argumentBytes startingAt: 1;
		replaceFrom: byteIndex + argumentBytes size to: newBytes size with: bytes startingAt: byteIndex + currentByteCount.

	self privateBytes: newBytes codePointCount: count.
	^ aCharacter.! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:29:40' prior: 50345431 overrides: 16947063!
            indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes := Character utf8BytesOf: aCharacter codePoint.
	startByteIndex := self byteIndexAt: start.
	foundByteIndex := String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer := self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!UnicodeString methodsFor: 'copying' stamp: 'jmv 1/9/2024 12:29:36' prior: 50345450 overrides: 16947652!
                        copyWith: aCharacter

	^UnicodeString
		fromUtf8Bytes: bytes, (Character utf8BytesOf: aCharacter codePoint)
		codePointCount: self size + 1.! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:29:43' prior: 16994774 overrides: 16829606!
                       with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	UnicodeString with: $a
	UnicodeString with: $
	UnicodeString with: Character euro
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOf: aCharacter codePoint)
		codePointCount: 1.! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:29:48' prior: 16994786 overrides: 16829612!
                           with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter and otherCharacter.
	UnicodeString with: $a
	UnicodeString with: $ with: Character euro
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOf: aCharacter codePoint),
			(Character utf8BytesOf: otherCharacter codePoint)
		codePointCount: 2.! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:29:54' prior: 16994801 overrides: 16829620!
             with: aCharacter with: otherCharacter with: thirdCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter, otherCharacter and thirdCharacter.
	UnicodeString with: $a
	UnicodeString with: $ with: Character euro
	UnicodeString with: $ with: Character euro with: $
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOf: aCharacter codePoint),
			(Character utf8BytesOf: otherCharacter codePoint),
			(Character utf8BytesOf: thirdCharacter codePoint)
		codePointCount: 3.! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:26:57' prior: 16994862!
                       utf16BytesFromUtf8: utf8ByteArray bigEndian: bigEndian includeBOM: wantsBOM
	"Convert the given string from UTF-8 to UTF-16.
	Honor requested endianess. Include BOM if requested."

	^ByteArray streamContents: [ :strm | | s byteIndex n |
		wantsBOM ifTrue: [
			strm nextUint16Put: 16rFEFF bigEndian: bigEndian ].
		s := utf8ByteArray size.
		byteIndex := 1.
		[  byteIndex <= s ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: utf8ByteArray
				into: nil
				into: [ :codePoint |
					Character
						evaluate: [ :word | strm nextUint16Put: word bigEndian: bigEndian ]
						withUtf16WordsOf: codePoint  ].
			byteIndex := byteIndex + n ]].! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:27:01' prior: 16994886!
         utf16WordsFromUtf8: utf8ByteArray  includeBOM: wantsBOM
	"Convert the given string from UTF-8 to UTF-16.
	Include BOM if requested.
	https://en.wikipedia.org/wiki/UTF-16
	UnicodeString codePointsFromUtf8: #[36 226 130 172 240 144 144 183 240 164 173 162].
	(UnicodeString utf16WordsFromUtf8: #[36 226 130 172 240 144 144 183 240 164 173 162]
		includeBOM: false) asArray collect: [ :w | w hex ].
	(UnicodeString utf16WordsFromUtf8: #[36 226 130 172 240 144 144 183 240 164 173 162]
		includeBOM: true) asArray collect: [ :w | w hex ].
	Note: Answer is a ShortArray, which can only have even size. Add a trailing zero if needed."

	^ShortWordArray streamContents: [ :strm | | s byteIndex n |
		wantsBOM ifTrue: [
			strm nextPut: 16rFEFF ].
		s := utf8ByteArray size.
		byteIndex := 1.
		[  byteIndex <= s ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: utf8ByteArray
				into: nil
				into: [ :codePoint |
					Character
						evaluate: [ :word | strm nextPut: word ]
						withUtf16WordsOf: codePoint ].
			byteIndex := byteIndex + n ].
		strm position odd ifTrue: [ strm nextPut: 0 ]].! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:27:34' prior: 16994924!
         utf8FromCodePoints: aWordArray
	"Convert the given string from UTF-32 to UTF-8"

	^ByteArray streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			Character
				evaluate: [ :byte | strm nextPut: byte ]
				withUtf8BytesOf: codePoint ]]! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:28:13' prior: 16994945!
              utf8FromUtf16Bytes: utf16ByteArray bigEndianHint: bigEndianHintOrNil
	"Convert the given string from UTF-16 to UTF-8.
	Use BOM if present to detect endianess, or bigEndianHintOrNil ifnotNil.
	If no BOM and bigEndianHintOrNil is nil, assume little endian."

	| isBigEndian startIndex |
	isBigEndian := bigEndianHintOrNil ifNil: [false]. "best guess"
	startIndex := 1.
	(utf16ByteArray uint16At: 1 bigEndian: true) = 16rFEFF ifTrue: [
		isBigEndian := true.
		startIndex := 3 ].
	(utf16ByteArray uint16At: 1 bigEndian: false) = 16rFEFF  ifTrue: [
		isBigEndian := false.
		startIndex := 3 ].
	^ByteArray streamContents: [ :strm | | s byteIndex word |
		s := utf16ByteArray size.
		byteIndex := startIndex.
		[ byteIndex <= s ] whileTrue: [
			word := utf16ByteArray uint16At: byteIndex bigEndian: isBigEndian.
			(word between: 16rD800 and: 16rDFFF)
				ifFalse: [
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: word.
					byteIndex := byteIndex + 2 ]
				ifTrue: [ | highSurrogatePart lowSurrogatePart codePoint |
					(word between: 16rD800 and: 16rDBFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					highSurrogatePart := word - 16rD800.
					word := utf16ByteArray uint16At: byteIndex+2 bigEndian: isBigEndian.
					(word between: 16rDC00 and: 16rDFFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					lowSurrogatePart := word - 16rDC00.
					codePoint := highSurrogatePart << 10 + lowSurrogatePart + 16r10000.
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: codePoint.
					byteIndex := byteIndex + 4 ]]].! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:28:18' prior: 16994999!
                 utf8FromUtf16Words: utf16WordArray
	"Convert the given string from UTF-16 to UTF-8.
	Skip BOM if present."

	| startIndex |
	startIndex := 1.
	(utf16WordArray at: 1) = 16rFEFF ifTrue: [
		startIndex := 2 ].
	^ByteArray streamContents: [ :strm | | s wordIndex word |
		s := utf16WordArray size.
		wordIndex := startIndex.
		[ wordIndex <= s ] whileTrue: [
			word := utf16WordArray at: wordIndex.
			(word between: 16rD800 and: 16rDFFF)
				ifFalse: [
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: word.
					wordIndex := wordIndex + 1 ]
				ifTrue: [ | highSurrogatePart lowSurrogatePart codePoint |
					(word between: 16rD800 and: 16rDBFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					highSurrogatePart := word - 16rD800.
					word := utf16WordArray at: wordIndex+1.
					(word between: 16rDC00 and: 16rDFFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					lowSurrogatePart := word - 16rDC00.
					codePoint := highSurrogatePart << 10 + lowSurrogatePart + 16r10000.
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: codePoint.
					wordIndex := wordIndex + 2 ]]].! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 1/9/2024 12:27:45' prior: 16991691!
   nextPutCodePoint: aNumber
	"UTF-8 encoded"

	Character
		evaluate: [ :byte | self nextPutByte: byte ]
		withUtf8BytesOf: aNumber! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 1/9/2024 12:27:49' prior: 16996001!
                nextPutCodePoint: aNumber
	"UTF-8 encoded"

	| n |
	"Save in a temp because #nextPutByte: smashes the ivar."
	n := numberOfCodePointsWritten ifNotNil: [ numberOfCodePointsWritten + 1 ].
	Character
		evaluate: [ :byte | self nextPutByte: byte ]
		withUtf8BytesOf: aNumber.
	numberOfCodePointsWritten := n.! !
!TTFontDescription methodsFor: 'glyph properties' stamp: 'jmv 1/9/2024 12:28:46' prior: 16972464!
          widthOf: aCharacterOrCodePoint

	Character
		evaluateOnce: [ :byte1 :byte2OrNil :byte3OrNil :byte4OrNil |
			^self widthOfUtf8Byte1: byte1 b2: byte2OrNil b3: byte3OrNil b4: byte4OrNil ]
		withUtf8BytesOf: aCharacterOrCodePoint codePoint.! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 1/9/2024 12:28:01' prior: 50345022!
                        mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint = $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint = $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOf: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOf: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph. upArrowGlyph. rightArrowGlyph. downArrowGlyph. carriageReturnGlyph}! !

Character class removeSelector: #evaluateOnce:withUtf8BytesOfUnicodeCodePoint:!

!methodRemoval: Character class #evaluateOnce:withUtf8BytesOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:39:23'!
evaluateOnce: aBlock withUtf8BytesOfUnicodeCodePoint: aCodePoint
	"Similar to #evaluate:withUtf8BytesOfUnicodeCodePoint:, but aBlock is evaluated just once, and must have 4 parameters."

	| mask nBytes shift byte1 byte2 byte3 byte4 |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint value: nil value: nil value: nil ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	byte1 := (aCodePoint bitShift: shift) + mask.
	nBytes >= 2 ifTrue: [
		shift := shift + 6.
		byte2 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
		nBytes >= 3 ifTrue: [
			shift := shift + 6.
			byte3 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
			nBytes = 4 ifTrue: [
				shift := shift + 6.
				byte4 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
				].
			].
		].
		^aBlock value: byte1 value: byte2 value: byte3 value: byte4.!

Character class removeSelector: #evaluate:withUtf8BytesOfUnicodeCodePoint:!

!methodRemoval: Character class #evaluate:withUtf8BytesOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:39:23'!
evaluate: aBlock withUtf8BytesOfUnicodeCodePoint: aCodePoint
	"See senders for typical usage"

	| mask nBytes shift |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	aBlock value: (aCodePoint bitShift: shift) + mask.
	2 to: nBytes do: [ :i | 
		shift := shift + 6.
		aBlock value: ((aCodePoint bitShift: shift) bitAnd: 63) + 128 ]!

Character class removeSelector: #evaluate:withUtf16WordsOfUnicodeCodePoint:!

!methodRemoval: Character class #evaluate:withUtf16WordsOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:39:23'!
evaluate: aBlock withUtf16WordsOfUnicodeCodePoint: aCodePoint
	"See senders for typical usage"

	| highSurrogate lowSurrogate |
	(aCodePoint between: 16rD800 and: 16rDFFF) ifTrue: [
		self error: 'invalid CodePoint' ].

	aCodePoint <= 16rFFFF ifTrue: [
		^aBlock value: aCodePoint ].

	highSurrogate := (aCodePoint - 16r10000) >> 10 + 16rD800.
	lowSurrogate := ((aCodePoint - 16r10000) bitAnd: 1023) + 16rDC00.
	aBlock value: highSurrogate.
	aBlock value: lowSurrogate.!

Character class removeSelector: #utf8BytesOfUnicodeCodePoint:!

!methodRemoval: Character class #utf8BytesOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:39:23'!
utf8BytesOfUnicodeCodePoint: aCodePoint

	^ ByteArray streamContents: [ :strm |
		Character
			evaluate: [ :byte |
				strm nextPut: byte ]
			withUtf8BytesOfUnicodeCodePoint: aCodePoint ]!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
ChangeSet zapAllChangeSets.
Smalltalk garbageCollect.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6188] on 9 January 2024 at 3:56:35 pm'!
!Base64MimeConverter class methodsFor: 'additional services' stamp: 'jmv 1/9/2024 15:54:19' prior: 16786632!
             mimeDecodeToBytes: aStream 
	"Return a ReadWriteStream of the original ByteArray.  aStream has only 65 innocuous character values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."

	| me |
	aStream position: 0.
	me := self new mimeStream: aStream.
	me dataStream: (ReadWriteStream on: (ByteArray new: aStream size * 3 // 4)).
	me mimeDecodeToByteArray.
	me dataStream position: 0.
	^ me dataStream! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 1/9/2024 15:53:54' prior: 16927065!
       nextLine
	"Answer next line (may be empty), or nil if at end"

"	self atEnd ifTrue: [^nil].
	^self upTo: Character cr
"
	^self crLfNextLine! !

ReferenceStream class removeSelector: #on:!

!methodRemoval: ReferenceStream class #on: stamp: 'Install-6196-Cleanup-JuanVuletich-2024Jan09-15h53m-jmv.001.cs.st 1/30/2024 19:39:23'!
on: aStream
	"Open a new ReferenceStream on a place to put the raw data."

	aStream class == ReadWriteStream ifTrue: [
		self inform: 'Please consider using a RWBinaryOrTextStream 
instead of a ReadWriteStream'].

	^ super on: aStream
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6196-Cleanup-JuanVuletich-2024Jan09-15h53m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6196] on 29 January 2024 at 11:32:37 am'!
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 1/29/2024 11:28:11' prior: 50336609!
                  reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	self at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := self unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(self at: c) removeFromSystem]. 
		n := self removeAllUnSentMessages.
		unused := self unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	self garbageCollect.
	oldDicts := MethodDictionary allInstances.
	newDicts := Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts := newDicts := nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/29/2024 11:26:08' prior: 50336675!
filenameForUpdatedImage: aBoolean
	"If aBoolean, include highest update number	"
	| fileName newName changesName systemVersion |
	systemVersion := SystemVersion current.
	fileName := String streamContents: [ :strm |
		strm nextPutAll: systemVersion versionString.
		aBoolean ifTrue: [
			strm
				nextPut: $-;
				print: systemVersion highestUpdate ].
		self wordSize = 4 ifTrue: [
			strm nextPutAll: '-32' ]].
	newName := fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName := DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName := self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		self inform:
'There is already .changes file of the desired name,
', changesName, '
curiously already present, even though there is no
corresponding .image file.
Please remedy manually and then repeat your request.'.
		^nil  ].
	^newName! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/29/2024 11:28:17' prior: 50336713!
setGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here don't persist, so we set them on startup.
	See #setDefaultGCParameters"

	| proportion edenSize survivorSize averageObjectSize numObjects |

	"Grow old memory in chunks of: "
	self vmParameterAt: 25 put: `32*1024*1024`.
	"Shrink heap when unused memory is at least: "
	self vmParameterAt: 24 put: `64*1024*1024`.

	"Note: (jmv, 9/2021) It seems modern Spur VMs ignore parameter 6. This all seems to be bogus."
	proportion := 0.9. "tenure when 90% of pastSpace is full"
	edenSize := self vmParameterAt: 44.
	survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"
	averageObjectSize := 8 * self wordSize. "a good approximation"
	numObjects := (proportion * survivorSize / averageObjectSize) rounded.
	self vmParameterAt: 6 put: numObjects.  "tenure when more than this many objects survive the GC"
	"/Note: (jmv, 9/2021)"
	
	"Do a full GC when used memory grows by this factor.
	Default is 0.333.
	2.0 means gull GC when heap size triples."
	self vmParameterAt: 55 put: 2.0.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6197-DontRefSmalltalkInSystemDictionary-JuanVuletich-2024Jan29-11h22m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6197] on 29 January 2024 at 11:55:38 am'!
!ChangeRecord methodsFor: 'accessing' stamp: 'jmv 1/29/2024 11:51:02' prior: 16805919 overrides: 16805392!
fileOutOn: aFileStream
	"File the receiver out on the given file stream"

	| aString |
	type == #method
		ifTrue: [
			aFileStream newLine; nextPut: $!!.
			aString :=  class asString
							, (meta ifTrue: [' class methodsFor: ']
									ifFalse: [' methodsFor: '])
							, category asString printString.
			stamp ifNotNil: [
				aString := aString, ' stamp: ''', stamp, ''''].
			aFileStream nextChunkPut: aString.
			aFileStream newLine ].

	type == #preamble ifTrue: [ aFileStream nextPut: $!! ].

	type == #classComment
		ifTrue: [
			aFileStream nextPut: $!!.
			aFileStream nextChunkPut: class asString, ' commentStamp: ', stamp storeString.
			aFileStream newLine ].
		
	type == #classDefinition ifTrue: [
		aFileStream nextPut: $!!.
		aFileStream nextChunkPut: 
			'classDefinition: ', 
			(self isMetaClassChange ifTrue: [self changeClassName, ' class'] ifFalse: [self changeClassName]) printString,
			' category: ', self category printString.
		aFileStream newLine ].

	aFileStream nextChunkPut: self string.
	
	type == #method ifTrue: [ aFileStream nextChunkPut: ' '; newLine ].
	type == #classComment ifTrue: [ aFileStream newLine ].
	aFileStream newLine! !
!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 1/29/2024 11:49:34' prior: 16806043 overrides: 16805388!
                          fileIn
	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."
	| s |
	type == #method ifTrue: [
		self changeClass ifNotNil: [ :methodClass |
			methodClass
				compile: self text
				classified: category
				withStamp: stamp
				notifying: nil ]].
	self isDoIt ifTrue: [
		((s := self string) beginsWith: '----') ifFalse: [ Compiler evaluate: s ]].
	type == #classDefinition ifTrue: [ Compiler evaluate: self string ].
	type == #classComment ifTrue: [
		(Smalltalk at: class)
			comment: self text
			stamp: stamp ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6198-ChangeRecord-FileoutsFix-ClassNameWithoutHash-JuanVuletich-2024Jan29-11h54m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6189] on 10 January 2024 at 12:46:19 pm'!
!Float commentStamp: '<historical>' prior: 16864195!
                          A note About Floating Point numbers and Floating Point Arithmetic.

The following is not specific to Cuis or Smalltalk at all. This is about the properties of Float numbers in any computer implementation.

If you haven't done so already, read https://en.wikipedia.org/wiki/Floating-point_arithmetic

But if you find the Wikipedia article too detailed, or hard to read, then try http://fabiensanglard.net/floating_point_visually_explained/ (get past "How Floating Point are usually explained" and read "A different way to explain...").

Other great reads are:
	"Why don't my numbers add up?":
		http://floating-point-gui.de/
and
	"What Every Computer Scientist Should Know About Floating-Point Arithmetic":
		http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
and also maybe
	"Comparing floating point numbers"
		https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

Now that you read them, and we are on the same boat, some further comments (from jmv):

Floats are (conceptually) approximate real numbers. That's why trig and other transcendental functions always answer Floats. That's why it is ok to round the result of operations. That's why Float is considered more general than Fraction in ST-80 and most Smalltalks. So, when we have a Float value, we must not think about it as a Rational but as a Real (actually as some unknown Real that could hopefully be close to the Rational we can actually represent). Keep this in mind when dealing with Floats, and especially avoid comparing them for equality.

When doing mixed operations with Floats and Fractions, Cuis, as most other Smalltalks, converts all values to Floats. Some other systems, including Pharo Smalltalk, Scheme and Lisp have two rules: when the answer is a Number, they convert to Float. But when the answer is a boolean (#<, #=, #<=, etc.) they convert to Fraction. We think this is a mistake. There should never be implicit conversions from Float to Fraction. Fractions are to hold exact values, and people expect Fractions to be exact. On the other hand, Floats are to hold approximations (and people should be aware of that!!). But an implicit conversion from Float to Fraction would give a Fraction that should not be considered an exact value (the value comes from an inexact Float), but that knowledge is lost, as it is an instance of Fraction.

If you want exact arithmetic, usual mathematical properties (like transitivity of equality), can live in the limited world of Rational numbers, and can afford a slight performance penalty, use Fraction instead. Avoid trascendental functions and never convert to Float.

In any case, most numeric computation is done on Float numbers. There are good reasons for that. One is that in most cases we don't need an exact answer. And in many cases we can't really have it: the inputs to algorithms already have a limited precision, or they use transcendental functions. And even when exact arithmetic is possible, if we are doing sound synthesis, 24 bits of resolution is enough. For image processing and graphics, the result is never more than 16 bits per channel. So, these fields don't really need 64 bit Doubles. 32 bit Floats are enough. Other fields do need 64 bit Doubles, like physics simulations and geometry. Games usually prefer special, faster 32 bit Float operations in GPUs that have greater errors but are faster.

There are some things that can be done to increase the confidence you can have on Float results. One is to do an error propagation analysis on the code you are running. This is not easy, but it is done for any widely used numerical method. Then, you can know real bounds and/or estimates of the errors made. So, understanding your inputs and your algorithms (for example error propagation, condition number, numeric stability), and using Float number if appropriate, is the usual advice.

Perhaps you have heard about "interval arithmetic". It is a bit better than simple Float, but doesn't really fix the problems.

The ultimate solution is to do Monte Carlo analysis, with random perturbation of inputs. After the Monte Carlo run, it is needed to do statistical analysis of possible correlations between the distributions of the random noise added to imputs and the result of the algorithm.

Additional food for thought: http://www.cs.berkeley.edu/~wkahan/Mindless.pdf . According to this, doing Monte Carlo as described above attacks a slightly different problem. This might be yet another reason (besides performance) to try something like the next paragraph. I (jmv) came up with it, and I don't really know if it has been described and or tried before or not. Mhhh. Maybe a defensive publication is in order.

A possibility that could be a practical solution, being much cheaper than Monte Carlo, but better than interval arithmetic, is to represent each value by 2 Floats: an estimation of the real value (i.e. an estimation of the mean value of the distribution of the corresponding Monte Carlo result), and an estimation of the error (i.e. an estimation of the standard deviation of the corresponding Monte Carlo result). Or perhaps even 3 of them. In addition to the estimation of the real value and an estimation of the error, we could add a hard bound on the error. In many cases it will be useless, because the error can not really be bound. But in those cases where it is possible to bound it, applications could really know about the quality of computed values.

=======================================================================

My instances represent IEEE 754 floating-point double-precision numbers. They have about 16 decimal digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:
	
	8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12

Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point. It is actually possible to specify a radix for Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:

	3r20.2 --> 6.66666666666667
	8r20.2 --> 16.25

If you don't have access to the definition of IEEE754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...
	sign		1 bit
	exponent	11 bits with bias of 1023 (16r3FF), substracted to produce an actual exponent in the range -1022 .. +1023
				- 16r000:
					significand = 0: Float zero
					significand ~= 0: Denormal number (actual exponent is -1022, not -1023. No implicit leading '1' bit in mantissa)
				- 16r7FF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE 754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.

The single-precision format is...
	sign		1 bit
	exponent	8 bits with bias of 127 (16r7F, substracted to produce an actual exponent in the range -126 .. +127
				- 16r00:
					significand = 0: Float zero
					significand ~= 0: Denormal number (actual exponent is -126, not -127. No implicit leading '1' bit in mantissa)
				- 16rFF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	24 bits, but only 23 are stored
This format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.

You might also check https://en.wikipedia.org/wiki/IEEE_754_revision

Other great reads (covering broader but interesting issues):
https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
https://web.archive.org/web/20150909015114/http://www.ima.umn.edu/2010-2011/W1.10-14.11/activities/Leeser-Miriam/Leeser-GPU-IMA-Jan2011.pdf
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6199-Typo-JuanVuletich-2024Jan10-12h46m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6189] on 10 January 2024 at 2:27:55 pm'!
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 1/10/2024 14:27:47' prior: 50338838!
          recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active processor (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	newArray at: 25 put: nil. "This is nil in Spur, which has immediate Characters."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "This is nil in Spur, no compact classes."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization.
	In Squeak these are: DoubleByteArray, WordArray, DoubleWordArray.
	Understand why."
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.
	newArray at: 36 put: nil. "was the prototype MethodContext"
	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6200-Tweak-JuanVuletich-2024Jan10-12h46m-jmv.001.cs.st----!

'From Haver6.3 [latest update: #6163] on 4 January 2024 at 4:10:13 pm'!
!StringRequestMorph methodsFor: 'initialization' stamp: 'KLG 1/4/2024 16:06:50' prior: 16961191!
                       addTextPane
	"Add a text pane and two buttons."
	
	| textPane controlsContainer |
	textPane := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textPane emptyTextDisplayMessage: msg ].
	textPane
		hasUnacceptedEdits: true;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LayoutMorph newRow)
		addMorphUseAll: textPane;
		addMorph: 
			(PluggableButtonMorph model: textPane scroller action: #acceptContents ::
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			(PluggableButtonMorph model: self action: #cancel ::
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6201-StringRequestMorphWithButtons-GeraldKlix-2024Jan04-16h10m-KLG.001.cs.st----!

'From Cuis6.3 [latest update: #6201] on 30 January 2024 at 2:19:51 pm'!

LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #StringRequestMorph category: #'Morphic-Composite Widgets' stamp: 'Install-6202-StringRequestMorph-fix-JuanVuletich-2024Jan30-14h18m-jmv.001.cs.st 1/30/2024 19:39:24'!
LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 1/30/2024 14:18:40' prior: 50347238!
           addTextPane
	"Add a text pane and two buttons."
	
	| controlsContainer |
	textMorph := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textMorph emptyTextDisplayMessage: msg ].
	textMorph
		hasUnacceptedEdits: true;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LayoutMorph newRow)
		addMorphUseAll: textMorph;
		addMorph: 
			(PluggableButtonMorph model: textMorph scroller action: #acceptContents ::
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			(PluggableButtonMorph model: self action: #cancel ::
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !
!StringRequestMorph methodsFor: 'private' stamp: 'jmv 1/30/2024 14:18:27' prior: 16961310!
                textBox
	
	^textMorph! !

LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #StringRequestMorph category: #'Morphic-Composite Widgets' stamp: 'Install-6202-StringRequestMorph-fix-JuanVuletich-2024Jan30-14h18m-jmv.001.cs.st 1/30/2024 19:39:24'!
LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6202-StringRequestMorph-fix-JuanVuletich-2024Jan30-14h18m-jmv.001.cs.st----!

----QUIT----(30 January 2024 19:39:35) Cuis6.3-6202-32.image priorSource: 453!