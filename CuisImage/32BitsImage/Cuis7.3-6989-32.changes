'From Cuis7.2 [latest update: #6895] on 6 December 2024 at 11:05:36 am'!


----SNAPSHOT----(6 December 2024 11:05:36) Cuis7.2-32.image priorSource: 0!

Preferences at: #saveReleaseOptionsInWorldMenu put: true!

----QUIT----(6 December 2024 11:05:48) Cuis7.3-6895-32.image priorSource: 73!

----STARTUP---- (2 January 2025 10:24:00) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\Cuis7.3-6895-32.image!


'From Cuis7.3 [latest update: #6895] on 6 December 2024 at 4:45:00 pm'!
!MorphicCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:24:28'!
                     drawSquareCloseIcon
	"For Window control buttons"

	self subclassResponsibility.! !
!MorphicCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:36'!
drawSquareExpandIcon
	"For Window control buttons"

	self subclassResponsibility.! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 12/6/2024 16:33:50' overrides: 50331667!
  drawSquareCloseIcon
"make all colors be parameters!!!!!!!!!!"

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.996 g: 0.329 b: 0.329`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.996 g: 0.329 b: 0.329) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/20.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowSquareButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonClosePathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 12/6/2024 16:38:27' overrides: 50331672!
                    drawSquareExpandIcon

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.337 g: 0.604 b: 0.161`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.337 g: 0.604 b: 0.161) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/20.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowSquareButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonExpandPathData: size) ].! !
!AbstractVectorCanvas class methodsFor: 'literal path data' stamp: 'jmv 12/6/2024 16:33:29'!
        windowSquareButtonPathData: aSize
	| scale |
	(IconPathData at: #windowButtonSize ifAbsent: nil) = aSize ifTrue: [
		IconPathData at: #windowSquareButton ifPresent: [ :found | ^found ]].
	IconPathData at: #windowButtonSize put: aSize.
	scale := aSize / 22.0.
	^IconPathData at: #windowSquareButton put: (
		self scalePathData: `#[
			0.0 0 0
			1    0 20
			1    20 20
			1    20 0
			1    0 0
		] asFloat32Array` scale: scale)! !
!BitBltCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:25:24' overrides: 50331667!
                  drawSquareCloseIcon
	| icon |
	icon := self class windowButtonIcon: #squareCloseIcon size: currentMorph morphWidth.
	self pvtDrawButtonFaceForm: icon.! !
!BitBltCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:48' overrides: 50331672!
       drawSquareExpandIcon
	| icon |
	icon := self class windowButtonIcon: #squareExpandIcon size: currentMorph morphWidth.
	self pvtDrawButtonFaceForm: icon.! !
!HybridCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:24:35' overrides: 50331739!
     drawSquareCloseIcon
	vectorCanvas  drawSquareCloseIcon! !
!HybridCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:54' overrides: 50331747!
       drawSquareExpandIcon
	vectorCanvas  drawSquareExpandIcon! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6896-SquareWindowIcons-JuanVuletich-2024Dec06-16h44m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6896] on 6 December 2024 at 7:45:28 pm'!
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/6/2024 19:44:09' prior: 16910500!
             displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos tabBackColor |

	topLeft := textTopLeft.
	line := textLine.
	lineY := line top + textTopLeft y.
	rightMargin := line rightMargin + textTopLeft x.
	lastIndex := line first.
	tabCount := 0.
	leftInRun <= 0 ifTrue:
		[
			self setFont.
			self setStopConditions ].
	leftMargin := (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX := leftMargin.
	destY := lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: 
			[ :ps |
			ps = paragraphStyle ifFalse: 
				[
					foregroundColor := defaultColor.
					self setActualFont: ps font.
					ps color ifNotNil: [ :color | self textColor: color ].
					alignment := ps alignment.
					paragraphStyle := ps.
					spaceWidth := font widthOf: Character space.
					self setStopConditions.
					text ifNotNil: [ destY := lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun := leftInRun].
	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount := 0.
	string := text string asUnicodeString.

	self placeEmbeddedObject.
	[
		startIndex := lastIndex.
		lastPos := destX@destY.
	
		stopCondition := self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions.
		backgroundColor ifNotNil: [
			"If this is not a #tab, update block nesting information. It it is a #tab, use it to draw background."
			stopCondition = #tab
				ifFalse:
				[ | indexForThisColor |
					
					(text hasShoutBackgroundColorAt: startIndex) ifTrue: [
						indexForThisColor := blockNestingStartX findFirst: [ :pair | pair second = backgroundColor ].
						indexForThisColor > 0
							ifTrue: [
								blockNestingStartX := blockNestingStartX first: indexForThisColor.
								(blockNestingStartX at: indexForThisColor) at: 1 put: (((blockNestingStartX at: indexForThisColor) at: 1) min: lastPos x)]
							ifFalse: [blockNestingStartX add: { lastPos x. backgroundColor }]]]
				ifTrue:
				[
					| indexForThisX |
					indexForThisX := blockNestingStartX findLast: [ :pair | pair first <= destX ].
					indexForThisX > 0 ifTrue: [ tabBackColor := (blockNestingStartX at: indexForThisX) second ].
					tabBackColor ifNotNil: [
						canvas
							fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
							color: tabBackColor ]].
			canvas
				fillRectangle: (lastPos corner: (startIndex > line last ifFalse: [ destX ] ifTrue: [ rightMargin ]) @ (line bottom + textTopLeft y))
				color: backgroundColor ].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6897-RectangularBlockHighlightFix-JuanVuletich-2024Dec06-19h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6897] on 8 December 2024 at 10:35:01 am'!
!Parser methodsFor: 'primitives' stamp: 'eem 12/8/2024 10:30:17' prior: 16921396!
                            externalType: descriptorClass
	"Parse an return an external type"
	| xType |
	(here == #'.' and: [hereType == #period and: [tokenType == #period]]) ifTrue:
		[[here == #'.'] whileTrue: [self advance].
		 ^descriptorClass punctuatorNamed: #'...'].
	xType := descriptorClass atomicTypeNamed: here.
	xType ifNil: "Look up from class scope"
		[Symbol
			hasInterned: here
			ifTrue:[:sym| xType := descriptorClass structTypeNamed: sym]].
	xType ifNil:
		["Raise an error if user is there"
		self interactive ifTrue:[^nil].
		"otherwise go over it silently"
		xType := descriptorClass forceTypeNamed: here].
	self advance.
	^(self matchToken: #*)
		ifTrue:[xType asPointerType]
		ifFalse:[xType]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6898-CuisCore-EliotEmilioMiranda-2024Dec08-09h56m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6898] on 9 December 2024 at 11:05:58 am'!
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/9/2024 11:04:30' overrides: 16864656!
     cos
	"Answer the cosine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 150>
	^ super cos! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/9/2024 11:01:37' overrides: 16864656!
                       cos
	"Answer the cosine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 560>
	^ super cos! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6899-UseNew-cos-primitives-JuanVuletich-2024Dec09-10h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:04:11 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 10/29/2024 16:34:13'!
        with: otherCollection allSatisfy: twoArgConditionBlock  
	
	self with: otherCollection do: [ :left :right | (twoArgConditionBlock value: left value: right) ifFalse: [ ^false ]].
	^true! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 10/30/2024 08:11:29'!
                with: otherCollection anySatisfy: twoArgConditionBlock 
	
	self with: otherCollection do: [ :left :right | (twoArgConditionBlock value: left value: right) ifTrue: [ ^true ]].
	^false! !
!SequenceableCollection class methodsFor: 'stream creation' stamp: 'HAW 10/28/2024 13:41:05'!
        writeStream
	
	^WriteStream on: self new! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6900-SequenceableCollection-enh-HernanWilkinson-2024Dec09-13h03m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:05:57 pm'!
!WeakMessageSend methodsFor: 'private' stamp: 'HAW 10/30/2024 08:25:06' prior: 17007109!
                isAnyArgumentGarbage
	"Make sure that my arguments haven't gone away"
	
	^arguments notNil and: [ arguments with: shouldBeNil anySatisfy: [ :arg :flag | flag not and: [arg isNil]]].
	
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6901-tweak-HernanWilkinson-2024Dec09-13h04m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:07:59 pm'!
!Interval methodsFor: 'testing' stamp: 'HAW 11/2/2024 10:50:17'!
             intersectsRange: rightRange
 
	^(self includes: rightRange first) 
		or: [ (self includes: rightRange last)
		or: [ rightRange includes: self first ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6902-Interval-enh-HernanWilkinson-2024Dec09-13h05m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:09:02 pm'!
!FileSystemEntry methodsFor: 'comparing' stamp: 'HAW 10/29/2024 16:40:50' prior: 16863764 overrides: 16915345!
                          = aFileEntry
	| isCaseSensitive myDrive otherDrive theirs mine |

	self == aFileEntry ifTrue: [ ^ true ].
	self class == aFileEntry class ifFalse: [ ^false ].

	isCaseSensitive := self fileAccessor isCaseSensitive.

	"Check for drive nil or same."
	myDrive := self drive.
	otherDrive := aFileEntry drive.
	isCaseSensitive
		ifTrue: [ self drive = aFileEntry drive ifFalse: [ ^false ]]
		ifFalse: [
			myDrive isNil = otherDrive isNil ifFalse: [ ^false ].		"only one of them is nil"
			myDrive ifNotNil: [											"none is nil"
				(myDrive sameAs: otherDrive) ifFalse: [ ^false ]]].

	"Check for all path components same."
	mine := self pathComponents.
	theirs := aFileEntry pathComponents.

	isCaseSensitive ifTrue: [
		^mine = theirs ].

	mine size = theirs size ifFalse: [
		^false ].

	^mine 
		with: theirs 
		allSatisfy: [ :m :t | m sameAs: t ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6903-tweak-HernanWilkinson-2024Dec09-13h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:17:25 pm'!

ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #EquivalentNodesFinder category: #'Compiler-Support' stamp: 'Install-6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st 1/2/2025 10:24:01'!
ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 10:19:17'!
                   methodNodeForLookingEquivalentNodes

	^ self methodNodeWithoutImplicitSelfReturn movingTemporariesDeclarationToBlock! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 10/30/2024 09:30:26'!
                            methodNodeWithoutImplicitSelfReturn
	
	^self methodNode withoutImplicitSelfReturn ! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 10:12:37'!
                               sourceRangesOfNodesEquivalentTo: nodesToLookFor 
	
	^self sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: EquivalentNodesFinder noSelection! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 19:25:36'!
                    sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep
	
	^self methodNodeForLookingEquivalentNodes sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep ! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:02:23'!
      areNodesOf: leftNodes equivalentTo: rightNodes

	^leftNodes size = rightNodes size and: [ 
		leftNodes with: rightNodes allSatisfy: [ :leftNode :rightNode | leftNode equivalentTo: rightNode ]]! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 09:27:03'!
                         isImplicitSelfReturnIn: aMethodNode

	^false! !
!BlockNode methodsFor: 'initialization' stamp: 'HAW 10/30/2024 09:27:45'!
      removeImplicitSelfReturnWhenIn: aMethodNode 
	
	| potentiaImplicitSelfReturn |
	
	potentiaImplicitSelfReturn := statements lastIfEmpty: [ ^self ].
	(potentiaImplicitSelfReturn isImplicitSelfReturnIn: aMethodNode) ifTrue: [ statements removeLast ]
	! !
!BlockNode methodsFor: 'testing' stamp: 'HAW 10/31/2024 16:15:24'!
 declaresAnyVariable
	
	^temporariesDeclaration notNil and: [ temporariesDeclaration declaresAnyVariable]! !
!MethodNode methodsFor: 'converting' stamp: 'HAW 10/30/2024 09:22:34'!
             withoutImplicitSelfReturn
	
	block removeImplicitSelfReturnWhenIn: self.
	^self! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 10/29/2024 22:57:09'!
  calculateCompleteSourceRangesOf: nodes	
	
	| sourcesRanges firstNode lastNode interval |
	
	sourcesRanges := nodes collect: [:node | 	self completeSourceRanges at: node ifAbsent: [#()]].
	
	sourcesRanges size = 1 ifTrue: [ ^sourcesRanges first ].
	
	firstNode := sourcesRanges first.
	lastNode := sourcesRanges last.
	
	interval := SourceCodeInterval from: firstNode first first to: lastNode first last.
	
	^OrderedCollection with: interval

! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 11/2/2024 19:56:44'!
                        sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep
	
	| finder |
	
	finder := EquivalentNodesFinder for: nodesToLookFor in: self keepingSelection: aSelectionToKeep.
	self accept: finder.

	^finder equivalentNodesRanges! !
!MethodNode methodsFor: 'initialization' stamp: 'HAW 11/2/2024 10:13:43'!
                        movingTemporariesDeclarationToBlock
	
	block temporariesDeclaration: temporariesDeclaration.
	self temporariesDeclaration: TemporariesDeclarationNode empty.
	
	^self ! !
!TemporariesDeclarationNode methodsFor: 'initialization' stamp: 'HAW 10/31/2024 18:34:37'!
                           withOutDeclarations: aTemporariesDeclarationToRemove

	tempDeclarationNodes := tempDeclarationNodes reject: [ :aTempDeclarationNode | 
		aTemporariesDeclarationToRemove declaresVariable: aTempDeclarationNode variableNode ]! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/31/2024 20:45:33'!
    addEquivalentNodesOf: blockStatements 

	| start stop |
	
	start := 1.
	
	[ stop := start + nodesToLookForSize - 1.
	stop <= blockStatements size ] whileTrue: [ 
		start := self 
			nextStartAfterAddingEquivalentNodesOf: blockStatements 
			from: start 
			to: stop ].
		
	! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 19:57:35'!
                  addToEquivalentsIfOneStatementEquivalentTo: aNode

	(self hasOneNodeToLookForAndEquivalentTo: aNode)
		ifTrue: [ equivalentNodesRanges add: (self completeSourceRangeOf: aNode) ].! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 20:04:10'!
                 areNodesToLookForEquivalentTo: nodesToCompareWith
 
	| equivalent |
	
	equivalent := nodesToLookFor 
		with: nodesToCompareWith 
		allSatisfy: [:leftNode :rightNode | leftNode equivalentTo: rightNode ].
		
	^equivalent and: [ self shouldKeepSelection not or: [ self selectionToKeepIsEqualOrHasNoIntersectionWith: nodesToCompareWith ]]	! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/4/2024 18:42:07'!
                    completeSourceRangeOf: aNode

	| sourceRangeIndex completeSourceRanges completeRange trimmedRange |
	
	sourceRangeIndex := nodeVisitedCounter occurrencesOf: aNode.
	sourceRangeIndex = 0 ifTrue: [ sourceRangeIndex := 1 ].
	
	"It should always find the completeSourceRanges of aNode and a range at the sourceRangeIndex - Hernan"
	completeSourceRanges := methodNode completeSourceRanges at: aNode.
	completeRange := completeSourceRanges at: sourceRangeIndex.
	
	"See ExtractMethodFinderTest>>test27FindsInsideParentesis - Hernan"
	trimmedRange := nodesToLookForSize = 1 
		ifTrue: [ completeRange trimToMatchExpressionOn: methodNode sourceText ]
		ifFalse: [ completeRange ].
	
	^trimmedRange! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/31/2024 21:14:49'!
                 completeSourceRangesOfAll: aCollectionOfNodes

	| firstRange lastRange |
	
	firstRange := self completeSourceRangeOf: aCollectionOfNodes first.
	lastRange := self completeSourceRangeOf: aCollectionOfNodes last.
	
	^SourceCodeInterval from: firstRange first to: lastRange last! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/29/2024 16:26:31'!
               hasOneNodeToLookForAndEquivalentTo: aNode

	^ nodesToLookForSize = 1 and: [ nodesToLookFor first equivalentTo: aNode ]! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 19:57:54'!
             nextStartAfterAddingEquivalentNodesOf: blockStatements from: start to: stop 
	
	| nodesToCompareWith nextStart |
	
	nodesToCompareWith := blockStatements copyFrom: start to: stop.
	
	nextStart := (self areNodesToLookForEquivalentTo: nodesToCompareWith) 
		ifTrue: [ 
			equivalentNodesRanges add: (self completeSourceRangesOfAll: nodesToCompareWith).
			stop + 1 ]
		ifFalse: [ 
			start + 1].
		
	^nextStart! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 20:04:10'!
           selectionToKeepIsEqualOrHasNoIntersectionWith: nodesToCompareWith 

	 | equivalentNodesSourceRanges | 

	equivalentNodesSourceRanges := self completeSourceRangesOfAll: nodesToCompareWith.
		
	^(selectionToKeep = equivalentNodesSourceRanges or: [ (selectionToKeep intersectsRange: equivalentNodesSourceRanges) not ])! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 10:19:08'!
        shouldKeepSelection

	^selectionToKeep ~= self class noSelection ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 11/2/2024 20:12:04' overrides: 16920720!
                        visitBlockNode: blockNode

	| blockStatements |

	super visitBlockNode: blockNode.
	
	nodesToLookForSize > 1 ifTrue: [ 
		blockStatements := blockNode statements. 
		"I need to add temp declaration to statements becuase user could have selected the temp declaration
		See ExtractMethodFinderTest>>test22FindsTemporaryWhenSelectingDefinitionInInnerClosure - Hernan"
		blockNode declaresAnyVariable ifTrue: [ blockStatements addFirst: blockNode temporariesDeclaration ].
		self addEquivalentNodesOf: blockStatements ]
		! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:10' overrides: 16920728!
                  visitBraceNode: aBraceNode 
	
	nodeVisitedCounter add: aBraceNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aBraceNode.
	
	^super visitBraceNode: aBraceNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:22' overrides: 16920734!
                visitCascadeNode: aCascadeNode 

	self addToEquivalentsIfOneStatementEquivalentTo: aCascadeNode.

	 ^super visitCascadeNode: aCascadeNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:34' overrides: 16920741!
              visitInstanceVariableNode: anInstanceVariableNode 

	nodeVisitedCounter add: anInstanceVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: anInstanceVariableNode.

	^super visitInstanceVariableNode: anInstanceVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:43' overrides: 16920745!
            visitLiteralNode: aLiteralNode

	nodeVisitedCounter add: aLiteralNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralNode.

	^super visitLiteralNode: aLiteralNode! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:50' overrides: 16920749!
        visitLiteralVariableNode: aLiteralVariableNode 
	
	nodeVisitedCounter add: aLiteralVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralVariableNode.
	
	^super visitLiteralVariableNode: aLiteralVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/28/2024 15:46:23' overrides: 16920753!
                    visitMessageNode: aMessageNode

	self addToEquivalentsIfOneStatementEquivalentTo: aMessageNode.

	 ^super visitMessageNode: aMessageNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:59' overrides: 16920795!
               visitTempVariableNode: aTempVariableNode 
	
	nodeVisitedCounter add: aTempVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aTempVariableNode.
	
	^super visitTempVariableNode: aTempVariableNode ! !
!EquivalentNodesFinder methodsFor: 'initialization' stamp: 'HAW 11/2/2024 19:55:28'!
                     initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	nodesToLookFor := aNodesToLookFor.
	methodNode := aMethodNode.
	selectionToKeep := aSelectionToKeep.
	
	nodesToLookForSize := nodesToLookFor size.
	nodeVisitedCounter := IdentityBag new.
	equivalentNodesRanges := OrderedCollection new.
	! !
!EquivalentNodesFinder methodsFor: 'ranges' stamp: 'HAW 11/2/2024 19:58:52'!
              equivalentNodesRanges
	
	^equivalentNodesRanges! !
!EquivalentNodesFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 19:56:18'!
               for: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	^ self new initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep! !
!EquivalentNodesFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 10:17:37'!
                        noSelection
	
	^`0 to: 0`! !
!Behavior methodsFor: 'methods' stamp: 'HAW 10/30/2024 09:19:58'!
 methodNodeWithoutImplicitSelfReturnFor: aSourceCode

	^(self methodNodeFor: aSourceCode) withoutImplicitSelfReturn! !
!BraceNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:02:55' prior: 16797237!
                       hasEquivalentElementsTo: aBraceNode

	^self areNodesOf: elements equivalentTo: aBraceNode elements ! !
!CascadeNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:03:14' prior: 16802900!
    hasEquivalentMessagesWith: aCascadeNode

	^self areNodesOf: messages equivalentTo: aCascadeNode messages! !
!CodeNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:03:35' prior: 16823662!
  hasEquivalentArgumentsWith: aCodeNode

	^self areNodesOf: self arguments equivalentTo: aCodeNode arguments! !
!BlockNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:04:17' prior: 16795473!
                               hasEquivalentStatementsWith: aBlockNode

	^self areNodesOf: statements equivalentTo: aBlockNode statements! !
!MessageNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:05:44' prior: 16897480!
                             hasEquivalentArgumentsWith: aMessageNode

	^ self isCascade
		ifTrue: [ self areNodesOf: originalArguments equivalentTo: aMessageNode originalArguments ]
		ifFalse: [ self areNodesOf: arguments equivalentTo: aMessageNode arguments ]! !
!TemporariesDeclarationNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:06:50' prior: 16976434!
                declaresSameVariablesThan: aTemporariesDeclarationNode

	^self areNodesOf: tempDeclarationNodes equivalentTo: aTemporariesDeclarationNode temporaryDeclarationNodes ! !
!TemporariesDeclarationNode methodsFor: 'testing' stamp: 'HAW 10/31/2024 18:35:34' prior: 16976449!
                    declaresVariable: aVariableNode

	^ tempDeclarationNodes anySatisfy: [ :tempDeclaration | tempDeclaration declaresVariable: aVariableNode ]! !
!ParseNodeVisitor methodsFor: 'visiting' stamp: 'HAW 10/31/2024 19:39:57' prior: 16920808!
                      visitTemporaryDeclarationNode: aTemporaryDeclarationNode

	^aTemporaryDeclarationNode variableNode accept: self! !

MessageNode removeSelector: #compare:with:!

!methodRemoval: MessageNode #compare:with: stamp: 'Install-6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st 1/2/2025 10:24:01'!
compare: myArguments with: othersArguments

	myArguments size ~= othersArguments size ifTrue: [ ^ false ].

	myArguments with: othersArguments do: [ :myArgument :otherArgument |
		(myArgument equivalentTo: otherArgument) ifFalse: [ ^ false ] ].
	^ true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6904] on 9 December 2024 at 2:04:51 pm'!

Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract sizeToExtract findingStrategy nodesToExtract '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:24:01'!
Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract sizeToExtract findingStrategy nodesToExtract'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #NodesInRangeFinder
	instanceVariableNames: 'range sourceMethod sourceMethodNode statements sourceRangeIndexByNode firstNodeFound lastNodeRange sourceCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #NodesInRangeFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:24:01'!
Object subclass: #NodesInRangeFinder
	instanceVariableNames: 'range sourceMethod sourceMethodNode statements sourceRangeIndexByNode firstNodeFound lastNodeRange sourceCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom callingExpression sendCollaboration '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacement category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:24:01'!
Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom callingExpression sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:12:58'!
                           defineFindingStrategy
	
	| useStringEquality |
	
	"Sadly, finding the right ranges when extracting literal nodes is almost imposible becuase literal nodes can have many
	ranges. An alternative algorithm could be to create an 'expanded AST' without reused nodes and each node with its own
	source range. Nodes of that AST could be a polimorphic proxy of the real node, adding only the source range, something
	to try ...
	For the moment, if the selection to extract has only literal nodes, uses string comparison - Hernan"
	useStringEquality := nodesToExtract allSatisfy: [ :aNode | aNode isLiteralNode ].
	
	^useStringEquality 
		ifTrue: [ [ :aMethod | self findReplacementsUsingStringEqualityIn: aMethod ]]
		ifFalse: [ [ :aMethod | self findReplacementsUsingNodeEquivalenceIn: aMethod ]]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:09:42'!
                           findReplacementInHierarchy

	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/2/2024 20:15:03'!
                         findReplacementsUsingNodeEquivalenceIn: aMethod

	| rangesToExtract |
		
	rangesToExtract := sourceMethod compiledMethod = aMethod
		ifTrue: [  aMethod sourceRangesOfNodesEquivalentTo: nodesToExtract keepingSelection: intervalToExtract ]	
		ifFalse: [ aMethod sourceRangesOfNodesEquivalentTo: nodesToExtract ].
		
	rangesToExtract do: [ :sourceRangeToExtract | self addReplacementAt: sourceRangeToExtract in: aMethod ].! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/1/2024 15:58:34'!
             findReplacementsUsingStringEqualityIn: aMethod

	| sourceCode foundIntervalToExtract sourceCodeToExtractStart theSizeToExtract |
	
	sourceCode := aMethod sourceCode.
	theSizeToExtract := intervalToExtract size - 1.
	sourceCodeToExtractStart := 1.
	
	[ sourceCodeToExtractStart := sourceCode indexOfSubCollection: sourceCodeToExtract startingAt: sourceCodeToExtractStart.
	sourceCodeToExtractStart ~= 0 ] whileTrue: [ 
		foundIntervalToExtract := sourceCodeToExtractStart to: sourceCodeToExtractStart + theSizeToExtract.
		self addReplacementAt: foundIntervalToExtract in: aMethod.
		sourceCodeToExtractStart := foundIntervalToExtract last + 1 ] 
		
	 ! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/3/2024 17:36:58'!
     nodesToExtract

	^(NodesInRangeFinder in: sourceMethod for: intervalToExtract) value! !
!NodesInRangeFinder methodsFor: 'initialization' stamp: 'HAW 11/2/2024 20:33:48'!
                      initializeIn: aSourceMethod for: anIntervalToExtract 

	range := anIntervalToExtract.
	sourceMethod := aSourceMethod.
	! !
!NodesInRangeFinder methodsFor: 'evaluating' stamp: 'HAW 11/3/2024 23:48:20' overrides: 16915777!
   value
	
	| nodeAtLastPositionFound |

	"Because some nodes have many ranges, like the literal nodes, we count the time we pass by a node that is equivalent
	to the index in the source ranges collection. sourceRangeIndexByNode is used to count per node - Hernan"
	sourceMethodNode := sourceMethod methodNode.
	sourceCode := sourceMethod sourceCode.
	statements := OrderedCollection new.
	sourceRangeIndexByNode := IdentityBag new.
	firstNodeFound := false.

	sourceMethodNode nodesDo: [ :aNode | | nodeRange |
		sourceRangeIndexByNode add: aNode.
		nodeRange := self completeSourceRangeOf: aNode.
		nodeAtLastPositionFound := self ifInsideRangeAddToStatements: aNode locatedAt: nodeRange.
		nodeAtLastPositionFound ifTrue: [ ^statements ]].
			
	self error: 'nodes not found'
	! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:31:50'!
                            addToStatementsIf: aNode isAtStartingPositionWhenLocatedAt: nodeRange

	(self isFirstInRange: aNode locatedAt: nodeRange)
		ifTrue: [
			firstNodeFound := true.
			statements add: aNode.
			range last <= nodeRange last ifTrue: [ ^true ].
			lastNodeRange := nodeRange ].

	^false! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:35:32'!
             addToStatementsIf: aNode isInsideExtractionWhenLoacatedAt: nodeRange

	(self notSubNodeOfLastNode: nodeRange) ifTrue: [
		statements add: aNode.
		(self isAtEndPosition: nodeRange) ifTrue: [ ^true ].
		lastNodeRange := nodeRange.].
	
	^false! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 23:32:33'!
                   completeSourceRangeOf: aNode

	| nodeRange nodeRanges |
	
	"Some nodes do not have ranges at all like BlockNode - Hernan"
	nodeRanges := sourceMethodNode completeSourceRanges at: aNode ifAbsent: [ #() ].
	nodeRange := nodeRanges at: (sourceRangeIndexByNode occurrencesOf: aNode) ifAbsent: [ `0 to: 0` ].
	nodeRange := nodeRange asSourceCodeInterval trimToMatchExpressionOn: sourceCode.
	
	^nodeRange
		! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:31:50'!
                  ifInsideRangeAddToStatements: aNode locatedAt: nodeRange

	^ firstNodeFound
		ifTrue: [ self addToStatementsIf: aNode isInsideExtractionWhenLoacatedAt: nodeRange]
		ifFalse: [ self addToStatementsIf: aNode isAtStartingPositionWhenLocatedAt: nodeRange]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:35:32'!
         isAtEndPosition: nodeRange

	^ range last = nodeRange last! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 23:55:29'!
          isAtStartPosition: nodeRange

	^ range first <= nodeRange first! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:40:38'!
     isCascadeMessage: aNode insideRange: nodeRange

	^ aNode isCascadeNode and: [ range last + 2 = nodeRange last ]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:34:59'!
                     isFirstInRange: aNode locatedAt: nodeRange

	^(self isAtStartPosition: nodeRange) and: [ self isInsideRange: aNode locatedAt: nodeRange ]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:34:49'!
                           isInsideRange: aNode locatedAt: nodeRange

	^ range last >= nodeRange last or: [self isCascadeMessage: aNode insideRange: nodeRange]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:34:53'!
notSubNodeOfLastNode: nodeRange
	
	^lastNodeRange last < nodeRange first! !
!NodesInRangeFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 20:34:06'!
                         in: aSourceMethod for: anIntervalToExtract 

	^self new initializeIn: aSourceMethod for: anIntervalToExtract ! !
!ExtractMethodReplacement methodsFor: 'initialization' stamp: 'HAW 11/4/2024 00:17:27'!
                       initializeSendCollaboration

	sendCollaboration := 'self ', self newMessageString.
	self shouldBeEnclosedWithParens ifTrue: [ sendCollaboration := '(' , sendCollaboration , ')' ]
		! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 11/1/2024 16:21:07' prior: 16958184!
        trimNoParentesisStartingWith: initialChar endingWith: endingChar on: aSourceCode

	| startOffset endOffset |

	startOffset := self trimmedOffsetFor: initialChar.
	endOffset := self trimmedOffsetFor: endingChar.
	^(startOffset = 1 or: [ endOffset = 1])
		ifTrue: [ (self trimLeft: startOffset right: endOffset) trimToMatchExpressionOn: aSourceCode ]
		ifFalse: [ self ]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:18:06' prior: 16859277!
                createReplacementAt: foundIntervalToExtract in: aMethod
	
	^ExtractMethodReplacement 
		fromInterval: foundIntervalToExtract asSourceCodeInterval 
		of: aMethod asMethodReference 
		to: newMessage
		! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 18:47:14' prior: 16859287!
                         findReplacementsAt: aClass

	"I live this implementationt instead of 
	
	aClass methodsDo: findingStrategy
	
	for debugging porpouses. We can do Through with this one - Hernan"
	aClass methodsDo: [ :aMethod | findingStrategy value: aMethod ]
	! !
!ExtractMethodReplacementsFinder methodsFor: 'evaluating' stamp: 'HAW 11/4/2024 00:08:21' prior: 16859363 overrides: 16915777!
          value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	nodesToExtract := self nodesToExtract.
	replacements := OrderedCollection new.
	findingStrategy := self defineFindingStrategy.
	
	self findReplacementInHierarchy.! !
!ExtractMethodReplacement methodsFor: 'initialization' stamp: 'HAW 11/4/2024 00:16:58' prior: 16859106!
                            initializeFrom: anIntervalToExtract of: aMethodToExtractCodeFrom to: aNewMessage

	intervalToExtract := anIntervalToExtract.
	methodToExtractFrom := aMethodToExtractCodeFrom.
	newMessage := 	aNewMessage.
	self initializeSendCollaboration ! !
!ExtractMethodReplacement methodsFor: 'private - source code' stamp: 'HAW 11/4/2024 00:17:27' prior: 16859167!
                               updatedSourceCodeOfExistingMethod

	^ methodToExtractFrom sourceCode
		copyReplaceFrom: intervalToExtract first  
		to: intervalToExtract last 
		with: sendCollaboration! !
!ExtractMethodReplacement methodsFor: 'adjustment' stamp: 'HAW 11/4/2024 00:17:27' prior: 16859206!
               adjustmentForNextReplacement
	
	^sendCollaboration size - intervalToExtract size! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'private' stamp: 'HAW 11/2/2024 02:27:22' prior: 16958621!
                        initializeParseNodesMatchingSelectionInterval

	initialNodeAncestors := methodNode parseNodesPathAt: intervalToExtract first ifAbsent: [ self signalSourceCodeContainsAnInvalidExpressionError ].
	finalNodeAncestors := methodNode parseNodesPathAt: intervalToExtract last ifAbsent: [ self signalSourceCodeContainsAnInvalidExpressionError ].
	initialNode := initialNodeAncestors detect: [ :aNodeRange | aNodeRange key isCascadeNode ] ifNone: [ initialNodeAncestors first ].
	finalNode := finalNodeAncestors first! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'private' stamp: 'HAW 11/4/2024 00:30:46' prior: 16958638!
            intervalCoversCompleteAstNodes 

	^ (self trimmed: (SourceCodeInterval from: initialNode value first to: finalNode value last)) = intervalToExtract
		or: [ (initialNode value first to: (self trimmed: finalNode value) last) = intervalToExtract ]! !

ExtractMethodReplacement removeSelector: #initializeCallingExpression!

!methodRemoval: ExtractMethodReplacement #initializeCallingExpression stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:24:01'!
initializeCallingExpression

	callingExpression := 'self ', self newMessageString.
	self shouldBeEnclosedWithParens ifTrue: [ callingExpression := '(' , callingExpression , ')' ]
		!

ExtractMethodReplacementsFinder removeSelector: #findReplacementsIn:!

!methodRemoval: ExtractMethodReplacementsFinder #findReplacementsIn: stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:24:01'!
findReplacementsIn: aMethod

	| sourceCode foundIntervalToExtract sourceCodeToExtractStart |
	
	sourceCode := aMethod sourceCode.
	sourceCodeToExtractStart := 1.
	
	[ sourceCodeToExtractStart := sourceCode indexOfSubCollection: sourceCodeToExtract startingAt: sourceCodeToExtractStart.
	sourceCodeToExtractStart ~= 0 ] whileTrue: [ 
		foundIntervalToExtract := sourceCodeToExtractStart to: sourceCodeToExtractStart + sizeToExtract.
		self addReplacementAt: foundIntervalToExtract in: aMethod.
		sourceCodeToExtractStart := foundIntervalToExtract last + 1 ] 
		
	 !

Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract nodesToExtract findingStrategy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:24:01'!
Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract nodesToExtract findingStrategy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacement category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:24:01'!
Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6905] on 9 December 2024 at 3:08:13 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6906-Interval-recategorize-HernanWilkinson-2024Dec09-15h03m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6906] on 9 December 2024 at 5:42:11 pm'!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/9/2024 17:41:40' prior: 16965270!
                           getCurrentWorkingDirectory
	"Answer the path from which Cuis was started.
	Smalltalk getCurrentWorkingDirectory
	(Note: Windows VM used to give a bogus answer. This was fixed in 2024.)
	"

	(self primGetCurrentWorkingDirectoryUnix ifNil: [ self primGetCurrentWorkingDirectoryWindows ]) ifNotNil:
		[ :utf8BytesInAStringInstance | | answer |
			"It seems on Mac, when dropping image on VM, we get '/', that is not really meaningful"
			(utf8BytesInAStringInstance = '/' and: [ self platformName = 'Mac OS' ]) ifFalse: [
				
				"Primitive answers an instance of String containing the UTF-8 bytes. If not pure ASCII,
				contents are invalid!! Convert it ASAP into a reasonable ByteArray + UnicodeString."
				answer := utf8BytesInAStringInstance.
				(String isAscii: answer) ifFalse: [
					ByteArray adoptInstance: answer.
					answer := UnicodeString fromUtf8Bytes: answer ].
				
				^ answer ]].

	"If we don't know better, answer nil. If appropriate, senders do:
		Smalltalk getCurrentWorkingDirectory ifNil: [ Smalltalk imagePath ]
	to have, at least, some valid directory
	"
	^ nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6907-getCurrentWorkingDirectory-primitiveFixedOnWindows-JuanVuletich-2024Dec09-17h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6907] on 10 December 2024 at 1:36:04 pm'!

Dictionary removeSelector: #valueAtNewKey:put:atIndex:declareFrom:!

!methodRemoval: Dictionary #valueAtNewKey:put:atIndex:declareFrom: stamp: 'Install-6908-Cleanup-JuanVuletich-2024Dec10-13h35m-jmv.001.cs.st 1/2/2025 10:24:01'!
valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary 
	"Support for coordinating class variable and global declarations
	with variables that have been put in Undeclared so as to
	redirect all references to the undeclared variable."

	(aDictionary includesKey: aKey)
		ifTrue: 
			[self atNewIndex: index 
				put: ((aDictionary associationAt: aKey) value: anObject).
			aDictionary removeKey: aKey]
		ifFalse: 
			[self atNewIndex: index put: (Association key: aKey value: anObject)]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6908-Cleanup-JuanVuletich-2024Dec10-13h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6908] on 11 December 2024 at 10:54:30 am'!
!PluggableScrollPane methodsFor: 'access options' stamp: 'jmv 12/10/2024 17:36:50'!
               alwaysHideHorizontalScrollbar

	hideScrollBars := #alwaysHideHorizontal.
	self hHideScrollBar.! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/11/2024 10:43:12' prior: 16926795!
                               hIsScrollbarNeeded
	"Return whether the horz scrollbar is needed"

	self mightNeedHorizontalScrollBar ifFalse: [ ^false ].
	
	"Don't show it if we were told not to."
	hideScrollBars = #hide ifTrue: [ ^false ].
	
	hideScrollBars = #alwaysHideHorizontal  ifTrue: [ ^false ].

	^self hLeftoverScrollRange > 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6909-PluggableScrollPane-hideHorizontalScrollbar-JuanVuletich-2024Dec11-10h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6908] on 11 December 2024 at 11:12:08 am'!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:24:01'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!
!FileListWindow methodsFor: 'updating' stamp: 'jmv 12/11/2024 11:11:04' overrides: 16972685!
                         layoutSubmorphs
	super layoutSubmorphs.
	"We are acting as the model of fileListPane,
	and need it to update, as its items are custom built to available width."
	self changed: #fileList! !
!FileListWindow methodsFor: 'updating' stamp: 'jmv 12/11/2024 11:00:46' overrides: 16972660!
      update: aSymbol
	super update: aSymbol.
	aSymbol = #fileList ifTrue: [
		"We are acting as the model of fileListPane"
		self changed: #fileList ].! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:50:33'!
                     dateTimeStringFor: aFileEntry

	^(aFileEntry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			aFileEntry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:35:13'!
fileList
	"Answer the list of display strings for the files in the current volume."

	| list font maxDateWidth maxSizeWidth totalWidth |
	list := model fileList.
	totalWidth := fileListPane ifNotNil: [ :l | l viewableWidth ] ifNil: [200]. "Only during pane creation."
	font := Preferences at: #standardListFont.
	maxDateWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: (self dateTimeStringFor: fileEntry))].
	maxSizeWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: fileEntry fileSize printStringWithCommas)].
	^list collect:
		[ :fileEntry |
			self fileNameFormattedFor: fileEntry
				nameWidth: totalWidth - maxDateWidth - maxSizeWidth
				sizeWidth: maxSizeWidth ].! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:13:30'!
                   fileListIndex
	^model fileListIndex! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:13:38'!
    fileListIndex: i
	^model fileListIndex: i! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:06:59'!
                              fileNameFormattedFor: fileEntry nameWidth: nameWidth sizeWidth: sizeWidth

	| font dateTimeString nameString sizeString w columnSeparator columnSeparatorsWidth space spaceWidth c hairSpace hairSpaceWidth |
	font := Preferences at: #standardListFont.
	columnSeparator := '   '.
	columnSeparatorsWidth := (font widthOfString: columnSeparator) * 2.
	space := Character space asString.
	spaceWidth := font widthOfString: space.
	hairSpace := (Character codePoint: 16r200A) asString.
	hairSpaceWidth := font widthOfString: hairSpace.

	"Adjust file name string"
	nameString := fileEntry name.
	nameString := nameString.
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	"Truncate if too long"
	w > nameWidth ifTrue: [
		w := (font widthOfString: nameString, '...') + columnSeparatorsWidth.
		[ w > nameWidth and: [nameString notEmpty]] whileTrue: [
			nameString := nameString first: nameString size -1.
			w := (font widthOfString: nameString, '...') + columnSeparatorsWidth ].
		nameString := nameString, '...' ].
	"Pad with spaces and hairSpaces if too short"
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	w < (nameWidth-spaceWidth) ifTrue: [
		c := nameWidth-w // spaceWidth.
		c timesRepeat: [ nameString := nameString, space ]].
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	[ w < (nameWidth-hairSpaceWidth) ] whileTrue: [
		nameString := nameString, hairSpace.
		w := (font widthOfString: nameString) + columnSeparatorsWidth ].

	dateTimeString := self dateTimeStringFor: fileEntry.

	sizeString := fileEntry fileSize printStringWithCommas.
	"Pad with spaces and hairSpaces if too short"
	w := font widthOfString: sizeString.
	w < (sizeWidth-spaceWidth) ifTrue: [
		c := sizeWidth-w // spaceWidth.
		c timesRepeat: [ sizeString := space, sizeString ]].
	w := font widthOfString: sizeString.
	[ w < (sizeWidth-hairSpaceWidth) ] whileTrue: [
		sizeString := hairSpace, sizeString.
		w := font widthOfString: sizeString ].

	^nameString, columnSeparator, dateTimeString, columnSeparator, sizeString! !
!FileList methodsFor: 'file list' stamp: 'jmv 12/11/2024 10:32:14' prior: 16862394!
      fileList
	"Answer the list of files in the current volume."
	^list! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 12/11/2024 10:55:35' prior: 16863509!
                             morphicFileListPane

	^ fileListPane := (PluggableListMorph
		withModel: self
		listGetter: #fileList 
		indexGetter: #fileListIndex
		indexSetter: #fileListIndex: )
			menuNshortcutsKey: #fileListMenuSpec;
			alwaysHideHorizontalScrollbar.! !

FileList removeSelector: #fileNameFormattedFrom:namePad:sizePad:sizeWithCommasPad:!

!methodRemoval: FileList #fileNameFormattedFrom:namePad:sizePad:sizeWithCommasPad: stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:24:01'!
fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font := Preferences at: #standardListFont.
	spaceWidth := font widthOf: $ .
	nameStr := entry isDirectoryEntry
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd := namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr := nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr := (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits := entry fileSize printString size.
	sizeStr := entry fileSize printStringWithCommas.
	sizeDigitsAndCommas := sizeStr size.
	spacesToAdd := sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd := spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr := (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces := String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:24:01'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 2:05:26 pm'!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!
!FileList methodsFor: 'as yet unclassified' stamp: 'jmv 10/10/2024 11:34:24'!
  fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font := Preferences at: #standardListFont.
	spaceWidth := font widthOf: $ .
	nameStr := entry isDirectoryEntry
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd := namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr := nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr := (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits := entry fileSize printString size.
	sizeStr := entry fileSize printStringWithCommas.
	sizeDigitsAndCommas := sizeStr size.
	spacesToAdd := sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd := spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr := (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces := String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .! !
!FileList methodsFor: 'file list' stamp: 'jmv 11/21/2024 12:33:58' prior: 50333266!
              fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 6/4/2024 13:33:43' prior: 50333272!
    morphicFileListPane

	^(PluggableListMorph
		withModel: model 
		listGetter: #fileList 
		indexGetter: #fileListIndex
		indexSetter: #fileListIndex: )
			menuNshortcutsKey: #fileListMenuSpec.! !

FileListWindow removeSelector: #fileList!

!methodRemoval: FileListWindow #fileList stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
fileList
	"Answer the list of display strings for the files in the current volume."

	| list font maxDateWidth maxSizeWidth totalWidth |
	list := model fileList.
	totalWidth := fileListPane ifNotNil: [ :l | l viewableWidth ] ifNil: [200]. "Only during pane creation."
	font := Preferences at: #standardListFont.
	maxDateWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: (self dateTimeStringFor: fileEntry))].
	maxSizeWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: fileEntry fileSize printStringWithCommas)].
	^list collect:
		[ :fileEntry |
			self fileNameFormattedFor: fileEntry
				nameWidth: totalWidth - maxDateWidth - maxSizeWidth
				sizeWidth: maxSizeWidth ].!

FileListWindow removeSelector: #fileListIndex!

!methodRemoval: FileListWindow #fileListIndex stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
fileListIndex
	^model fileListIndex!

FileListWindow removeSelector: #fileListIndex:!

!methodRemoval: FileListWindow #fileListIndex: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
fileListIndex: i
	^model fileListIndex: i!

FileListWindow removeSelector: #update:!

!methodRemoval: FileListWindow #update: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
update: aSymbol
	super update: aSymbol.
	aSymbol = #fileList ifTrue: [
		"We are acting as the model of fileListPane"
		self changed: #fileList ].!

FileListWindow removeSelector: #layoutSubmorphs!

!methodRemoval: FileListWindow #layoutSubmorphs stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
layoutSubmorphs
	super layoutSubmorphs.
	"We are acting as the model of fileListPane,
	and need it to update, as its items are custom built to available width."
	self changed: #fileList!

FileListWindow removeSelector: #dateTimeStringFor:!

!methodRemoval: FileListWindow #dateTimeStringFor: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
dateTimeStringFor: aFileEntry

	^(aFileEntry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			aFileEntry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).!

FileListWindow removeSelector: #fileNameFormattedFor:nameWidth:sizeWidth:!

!methodRemoval: FileListWindow #fileNameFormattedFor:nameWidth:sizeWidth: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
fileNameFormattedFor: fileEntry nameWidth: nameWidth sizeWidth: sizeWidth

	| font dateTimeString nameString sizeString w columnSeparator columnSeparatorsWidth space spaceWidth c hairSpace hairSpaceWidth |
	font := Preferences at: #standardListFont.
	columnSeparator := '   '.
	columnSeparatorsWidth := (font widthOfString: columnSeparator) * 2.
	space := Character space asString.
	spaceWidth := font widthOfString: space.
	hairSpace := (Character codePoint: 16r200A) asString.
	hairSpaceWidth := font widthOfString: hairSpace.

	"Adjust file name string"
	nameString := fileEntry name.
	nameString := nameString.
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	"Truncate if too long"
	w > nameWidth ifTrue: [
		w := (font widthOfString: nameString, '...') + columnSeparatorsWidth.
		[ w > nameWidth and: [nameString notEmpty]] whileTrue: [
			nameString := nameString first: nameString size -1.
			w := (font widthOfString: nameString, '...') + columnSeparatorsWidth ].
		nameString := nameString, '...' ].
	"Pad with spaces and hairSpaces if too short"
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	w < (nameWidth-spaceWidth) ifTrue: [
		c := nameWidth-w // spaceWidth.
		c timesRepeat: [ nameString := nameString, space ]].
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	[ w < (nameWidth-hairSpaceWidth) ] whileTrue: [
		nameString := nameString, hairSpace.
		w := (font widthOfString: nameString) + columnSeparatorsWidth ].

	dateTimeString := self dateTimeStringFor: fileEntry.

	sizeString := fileEntry fileSize printStringWithCommas.
	"Pad with spaces and hairSpaces if too short"
	w := font widthOfString: sizeString.
	w < (sizeWidth-spaceWidth) ifTrue: [
		c := sizeWidth-w // spaceWidth.
		c timesRepeat: [ sizeString := space, sizeString ]].
	w := font widthOfString: sizeString.
	[ w < (sizeWidth-hairSpaceWidth) ] whileTrue: [
		sizeString := hairSpace, sizeString.
		w := font widthOfString: sizeString ].

	^nameString, columnSeparator, dateTimeString, columnSeparator, sizeString!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:24:01'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6911] on 12 December 2024 at 3:49:02 pm'!
!Rectangle methodsFor: 'transforming' stamp: 'jmv 12/12/2024 15:46:55'!
                             newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect := newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 3/25/2024 11:43:34' prior: 16937717!
                           newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect := newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 12/12/2024 15:47:53' prior: 17008207 overrides: 16890633!
    adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(Preferences at: #cheapWindowReframe) or: [millisecondSinceLast > 100]]) ifTrue: [
			owner displayBounds newRect2From: [ :f |
				self stopStepping.
				hand := nil.
				Cursor defaultCursor activateCursor.
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner extentInWorld ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6912-WindowResizeTweak-JuanVuletich-2024Dec12-15h38m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6912] on 15 December 2024 at 7:04:31 pm'!
!HierarchyBrowserWindow class methodsFor: 'GUI building' stamp: 'KLG 12/12/2024 16:04:08' prior: 16875757!
   onClass: aClass selector: aSymbol
	"Open a new full browser set to class.
	HierarchyBrowserWindow onClass: Morph selector: #submorphs
	HierarchyBrowserWindow onClass: Morph selector: nil
	"

	| newBrowser newBrowserWindow |
	newBrowser := HierarchyBrowser for: aClass selector: aSymbol.
	newBrowserWindow := self openNoSysCat: newBrowser label: newBrowser labelString.
	newBrowser assureSelectionsShow.
	^ newBrowserWindow! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6913-AnswerNewWindowInOnClassSelector-GeraldKlix-2024Dec15-19h03m-KLG.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 17 December 2024 at 9:26:21 am'!
!Object methodsFor: 'finalization' stamp: 'jmv 12/17/2024 09:12:41'!
    toFinalizeSend: aSelector to: aFinalizer
	"When I am finalized (e.g., garbage collected) send aSelector to the appropriate finalizer (the guy who knows how to do any needed cleanup).
	WARNING: The finalizer is not allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."
	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].
	^self finalizationRegistry add: self executor:
		(ObjectFinalizer new
			receiver: aFinalizer
			selector: aSelector)! !
!ObjectFinalizer methodsFor: 'initialization' stamp: 'jmv 12/13/2024 14:36:37'!
      receiver: aReceiver selector: aSelector
	receiver := aReceiver.
	selector := aSelector.
	arguments := #()! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6914-Finalization-Convenience-JuanVuletich-2024Dec17-09h24m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:22:43 pm'!
!WeakRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 12:05:32' prior: 17007232 overrides: 16827586!
  add: anObject
	"Add anObject to the receiver. Store the object as well as the associated executor."
	| executor |
	executor := anObject shallowCopy actAsExecutor.
	self protected:[
		valueDictionary at: anObject put: executor.
	].
	^anObject! !

UniFileStream removeSelector: #actAsExecutor!

!methodRemoval: UniFileStream #actAsExecutor stamp: 'Install-6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st 1/2/2025 10:24:01'!
actAsExecutor
	super actAsExecutor.
	name := nil.!

Object removeSelector: #executor!

!methodRemoval: Object #executor stamp: 'Install-6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st 1/2/2025 10:24:01'!
executor
	"Return an object which can act as executor for finalization of the receiver"
	^self shallowCopy actAsExecutor!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 9:23:17 am'!
!Dictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:05'!
                      associationClass

	^Association! !
!WeakKeyDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:24' overrides: 50333856!
                            associationClass

	^WeakKeyAssociation! !
!WeakValueDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:43' overrides: 50333856!
                   associationClass

	^WeakValueAssociation! !
!Dictionary methodsFor: 'accessing' stamp: 'JMM 12/2/2024 09:54:17' prior: 16847449 overrides: 16915102!
           at: key put: anObject
	"Set the value at key to be anObject. 
	If key is not found, create a new entry for key and set is value to anObject.
	If key is found, update the existing association.
	Answer anObject."

	| index assoc |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc
		ifNil: [ self atNewIndex: index put: (self associationClass key: key value: anObject) ]
		ifNotNil: [ assoc value: anObject ].
	^ anObject! !
!WeakKeyDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:08:53' prior: 17006854 overrides: 50333871!
                  at: key put: anObject 
	"Set the value at key to be anObject.  If key is not found, create a new
	entry for key and set is value to anObject. Answer anObject."
	
	key ifNil: [ ^anObject ].
	^super at: key put: anObject! !

WeakValueDictionary removeSelector: #at:put:!

!methodRemoval: WeakValueDictionary #at:put: stamp: 'Install-6916-Dictionary-Refactor-JohnMcIntosh-2024Dec12-09h22m-JMM.001.cs.st 1/2/2025 10:24:01'!
at: key put: anObject 
	"Set the value at key to be anObject.  If key is not found, create a new
	entry for key and set is value to anObject. Answer anObject."
	| index element |
	index := self findElementOrNil: key.
	element := array at: index.
	element
		ifNil: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]
		ifNotNil: [element value: anObject].
	^ anObject!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6916-Dictionary-Refactor-JohnMcIntosh-2024Dec12-09h22m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 8:58:48 am'!
!Class methodsFor: 'subclass creation' stamp: 'eem 8/25/2015 16:37'!
           ephemeronSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have ephemeron semantics, i.e. where the object will be queued for
	finalization when the key (first) inst var is not reachable other than through
	the other fields of ephemerons with unreachable keys."

	| answer |
	answer := ClassBuilder new
			superclass: self
			ephemeronSubclass: t
			instanceVariableNames: f
			classVariableNames: d
			poolDictionaries: s
			category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6917-Ephemeron-ClassCreationSupport-JohnMcIntosh-2024Dec12-08h57m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:16:10 pm'!

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st 1/2/2025 10:24:01'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronIdentityDictionary commentStamp: '<historical>' prior: 0!
                        I am an identity dictionary holding only weakly on my keys.
When one of my keys is garbage collected, the key->value association is removed from the dictionary.

Internally I use Ephemeron objects that know myself as their container.
Ephemeron are implemented as ephemerons and get mourned when their key is only known from itself.
On mourn, the association asks the container to remove itself.!

Association ephemeronSubclass: #Ephemeron
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #Ephemeron category: #'System-Finalization' stamp: 'Install-6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st 1/2/2025 10:24:01'!
Association ephemeronSubclass: #Ephemeron
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!Ephemeron commentStamp: '<historical>' prior: 0!
           An Ephemeron is an association known to the garbage collection system, allowing it to function as a pre-mortem finalizer.

An Ephemeron is intended for uses such as associating an object's dependents with an object without preventing garbage collection.

Consider a traditional implementation of dependents in non-Model classes.  There is a Dictionary in Object, DependentsFields, into which objects wishing to have dependents are entered as keys, with the value being the sequence of their dependents.  Since a key's dependents (if they are like views/morphs, etc in MVC) will refer directly back to the key (e.g. in their model inst var etc), the key remains srongly referenced; there is no way to use weak collections in DependentsFields to allow the cycle of an object and its dependents to be collected.  If DependentsFields were to use a WeakArray to hold the associations from objects to their dependents then those associations, and the dependencies they record, would simply be lost since the only reference to the associations is from DependentsFields.

Ephemeron differs from a normal association in that it is known to the garbage collector and it is involved in tracing.  First, note that an Ephemeron is a *strong* referrer.  The objects it refers to cannot be garbage collected.  It is not weak.  But it is able to discover when it is the *only* reference to an object.  To be accurate, an Ephemeron is notified by the collector when its key is only referenced from the transitive closure of references from ephemerons.  i.e. when an ephemeron is notified we know that there are no reference paths to the ephemeron's key other than through ephemerons; the ephemeron's key is not otherwise reachable from the roots.

Ephemerons are notified by the garage collector placing them in a queue and signalling a semaphore for each element in the queue.  An image level process (the extended finalization process) extracts them from the queue and sends mourn to each ephemeron (since their keys are effectively dead).  What an Ephemeron does in response to the notification is programmable (one can add subclasses of Ephemeron).  But the default behaviour is to send finalize to the key, and then to remove itself from the dictionary it is in, allowing it and the transitive closure of objects reachable from it, to be collected in a subsequent garbage collection.

Implementation: both in scavenging, and in scan-mark, if an ephemeron is encountered its key is examined.  If the key is reachable from the roots (has already been scavenged, or is already marked), then the ephemeron marked and treated as an ordinary object. If the key is not yet known to be reachable the ephemeron is held in an internal queue of maybe triggerable ephemerons, and its objects are not traced.

At the end of the initial scavenge or scan-mark phase, this queue of triggerable ephemerons is examined.  All ephemerons in the list whose key is reachable are traced, and removed from the list.  i.e. what has happened was that their key was found reachable form the roots after they were added in the list (the garbage collector traces the object graph in an arbitrary order, typically breadth first in the scavenger, depth-dirst in teh scan-mark).  This then leaves the list populated only with ephemerons whose keys are as yet untraced, and hence only referenced from the ephemerons in the triggerable ephemeron queue, which now becomes the triggered ephemeron queue.  All these ephemerons are placed in the finalization queue for processing in the image above, and all objects reachable from these ephemerons are traced (scavenged, marked).  This tracing phase may encounter new potentially triggerable ephemerons which will be added to the triggerable ephemeron queue (not likely in practice, but essential for sound semantics).  So the triggering phase continues until the system reaches a fixed point with an empty triggerable ephemeron queue.

Implications and advantages:
Because ephemerons do not allow their object to be collected, they can be, and are, used to implement pre-mortem finalization.  So e.g. a file can flush its buffers and then close its file descriptor before being collected (which may also imply that the system runs the garbage collector *before* snapshotting, not as part of the snapshot primitive).  Ephemerons are conceptually more simple than WeakKeyDictionary et al, since they are about reference paths, not merely the existence of strong references.  They accurately identify when an object is no longer reachable from the roots, no matter how many ephemerons are attached to a specific object for whatever purpose.  Note that the back reference from a dependent to an object renders a weak key dictionary useless in enabling an isolated cycle to be collected since the back reference is string, and keeps the reference from the weak key alive.

History: Ephemerons are like guardians.  They were invented by George Bosworth in the early '90's, to provide pre-mortem finalization and to solve the problem of DependentsFields retaining garbage.

Instance Variables
	container 	<Dictionary|Set> - the container in which the Ephemeron resides.
!
!EphemeronIdentityDictionary methodsFor: 'accessing' stamp: 'JMM 12/6/2024 10:37:01' overrides: 50333856!
        associationClass
	^Ephemeron! !
!EphemeronIdentityDictionary methodsFor: 'adding' stamp: 'JMM 12/12/2024 10:05:22' overrides: 16847595!
                        add: anAssociation
	
	"Installs a copy of the association in myself.
	I cannot add the association because they are not shareable between weak key dictionaries, it needs myself as container.
	Moreover, I can only contain Ephemerons, and not other kinds of Association."
	self at: anAssociation key put: anAssociation value.

	^ anAssociation! !
!EphemeronIdentityDictionary methodsFor: 'private' stamp: 'JMM 12/2/2024 14:47:36' overrides: 16950510!
                               atNewIndex: index put: anEphemeron

	anEphemeron container: self.
	^super atNewIndex: index put: anEphemeron! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'JMM 12/12/2024 10:02:44' overrides: 16847844!
       postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	array := array collect: [ :assoc |
		         assoc ifNotNil: [
			         assoc copy
				         container: self ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'JMM 12/2/2024 15:19:05'!
                 finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"
	
	self removeKey: anEphemeron key ifAbsent: [].
! !
!Ephemeron methodsFor: 'accessing' stamp: 'eem 10/1/2020 12:31'!
                             container
	"Answer the Dictionary containing the receiver, if any."
	^container! !
!Ephemeron methodsFor: 'accessing' stamp: 'eem 10/1/2020 12:33'!
            container: aDictionarySetOrNil
	"Set the Dictionary containing the receiver, or nil it."
	container := aDictionarySetOrNil! !
!Ephemeron methodsFor: 'testing' stamp: 'eem 9/1/2015 10:12'!
    isEphemeron
	^true! !
!Ephemeron methodsFor: 'mourning' stamp: 'JMM 12/9/2024 10:28:28'!
       mourn
	"Triggered ephemerons get sent mourn by EphemeronsFinalizationProcess class's finalizationProcess
	 (via mournLoopWith:) when the only reference(s) to an ephemeron's key is through
	 one or more ephemerons. i.e. the key is not reachable from the roots of the system,
	 only through ephemerons.  So ephemerons get sent mourn when their key would
	 otherwise have been garbage collected.  Respond to the information that the key
	 would have been garbage collected other than through ephemeron references by
	 sending finalize to the key."
	container finalizeEphemeron: self.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6917] on 12 December 2024 at 4:26:01 pm'!
!Object methodsFor: 'finalization' stamp: 'JMM 11/20/2024 17:29:59'!
                               mourn
	"Sent by the new Finalization mechanism.
	All weak objects (instances of weak classes) and Ephemerons may be mourned if they point to an object that needs to be collected.

	This default implementation does nothing. To override in specific subclasses."! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6919-Object-mourn-JohnMcIntosh-2024Dec12-16h24m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:43:01 pm'!

Object subclass: #EphemeronFinalizationProcess
	instanceVariableNames: ''
	classVariableNames: 'FinalizationSemaphore TheFinalizationProcess'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronFinalizationProcess category: #'System-Finalization' stamp: 'Install-6920-EphemeronFinalizationProcess-JohnMcIntosh-2024Dec12-12h16m-JMM.001.cs.st 1/2/2025 10:24:01'!
Object subclass: #EphemeronFinalizationProcess
	instanceVariableNames: ''
	classVariableNames: 'FinalizationSemaphore TheFinalizationProcess'
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronFinalizationProcess commentStamp: 'jmv 12/12/2024 12:21:40' prior: 0!
                            I represent the finalization process that waits for finalization of objects and sends the #mourn message to then. I am registered to the startup to stop/start myself on each start.!
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 12/6/2024 12:16:29'!
                             doWeakFinalizationWork
	"Process the weak registries, in the old finalization style.  Hopefully this will
	 eventually go away when all clients have adopted the new finalization scheme."
	FinalizationLock
		critical:
			[FinalizationDependents do:
				[ :weakDependent |
				weakDependent ifNotNil:
					[weakDependent finalizeValues]]]
		ifError:
			[:msg :rcvr | rcvr error: msg]! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'jmv 12/12/2024 12:25:03'!
 finalizationProcess
	"The finalization process arranges to send mourn to each element of the VM's finalization queue,
	 which is accessed via primitiveFetchMourner.  The VM signals FinalizationSemaphore whenever
	 the queue is non-empty.  This process loops, waiting on the semaphore, fetches the first element
	 of the queue and then spawns a process at a higher priority to actually send the mourn messages.
	 If an error occurs in the higher priority mourn loop process then this process will simply spawn
	 another process, hence ensuring that errors in finalization methods don't break finalization.

	 In addition this process also runs the old finalization scheme, supporting clients of the older,
	 WeakRegistry based scheme.  Hopefully this will go away when all clients have moved over."
	| throttle firstMourner |
	throttle := Semaphore new.
	[true] whileTrue:
		[FinalizationSemaphore wait; initSignals.
		 "Support the old scheme until things have changed over..."
		 self doWeakFinalizationWork.
		
		 [firstMourner := self primitiveFetchMourner.
		  firstMourner notNil] whileTrue:
			[[throttle signal.
			  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1  named: '[system] Ephemeron Mourn processing'.
			  throttle wait]]! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: '9/24/2024 06:44'!
                        runningFinalizationProcess
	"Answer the FinalizationProcessNewEra I am running, if any"
	^TheFinalizationProcess! !
!EphemeronFinalizationProcess class methodsFor: 'class initialization' stamp: 'jmv 12/12/2024 12:38:36' overrides: 16917943!
               initialize
	"
	SystemDictionary initialize.
	WeakArray restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.
	"

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.! !
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: 'JMM 12/12/2024 10:46:41'!
                     mournLoopWith: firstMourner
	"Send mourn to all the objects available in the mourn queue, starting
	 with firstMourner which the sender has already extracted for us.  If
	 an error occurs here, it will break this loop but the sender will spawn
	 another mournLoopWith: so that finalization is not broken by errors in
	 individual cases."
	| mourner |
	mourner := firstMourner.
	[mourner mourn.
	 (mourner := self primitiveFetchMourner) notNil] whileTrue! !
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: '9/24/2024 06:44'!
                        primitiveFetchMourner
	"Answer the next mourner in the VM's queue of objects to be finalized.
	 The queue contains weak arrays and ephemerons.  If the primitive is
	 not implemented, raise an error telling people to upgrade the VM.  If
	 implemented, the primitive fails if the queue is empty, with the error
	 code #'not found'. Primitive.  Essential."

	<primitive: 172 error: ec>
	ec ifNil: [^self error: 'The primitiveFetchMourner primitive is missing.\Please upgrade your virtual machine to one that has the primitive.' withCRs].
	^nil! !
!EphemeronFinalizationProcess class methodsFor: 'system startup' stamp: '9/24/2024 06:44' overrides: 16789354!
                 startUp: resuming
	resuming ifFalse: [ ^self ].
	self restartFinalizationProcess! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 12/11/2024 12:38:56'!
               doWeakFinalizationWork
	" Fork off the old weak array processing logic" 
	
	[WeakArray doWeakFinalizationWork] forkAt: Processor activePriority + 2 named: '[system] Ephemeron WeakArray processing'! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/27/2024 09:48:11'!
                           restartFinalizationProcess
	"kill any old process, just in case"
	TheFinalizationProcess
		ifNotNil: [TheFinalizationProcess terminate.
			TheFinalizationProcess := nil].

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.
	TheFinalizationProcess := [ self finalizationProcess ] newProcess.
	TheFinalizationProcess priority: Processor userInterruptPriority.
	TheFinalizationProcess name: '[system] Ephemeron finalization'.
	TheFinalizationProcess resume! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/20/2024 17:21:58'!
             stopFinalizationProcess
	"kill any old process, just in case"
	TheFinalizationProcess
		ifNotNil: [TheFinalizationProcess terminate.
			TheFinalizationProcess := nil].! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/20/2024 17:24:21'!
                        theFinalizationProcess
	^TheFinalizationProcess! !
!WeakArray class methodsFor: 'services' stamp: 'JMM 11/29/2024 14:30:48' prior: 17006624!
                   ensureFinalizationComplete

	Smalltalk garbageCollect.
	Processor activePriority >= self finalizationProcess priority ifTrue: [
		"Not needed if the default priorities are used. Just in case."
		Processor activeProcess priority: self finalizationProcess priority-1.
		Processor yield ].! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/29/2024 14:30:21' prior: 17006579!
finalizationProcess
	"nothing here, moved to EphemeronFinalizationProcess class"
	^EphemeronFinalizationProcess theFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'jmv 12/12/2024 12:39:21' prior: 17006597!
                        restartFinalizationProcess

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess
		ifNotNil: [ 
			FinalizationProcess terminate.
			FinalizationProcess := nil ].
	FinalizationSemaphore := nil.
	EphemeronFinalizationProcess restartFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/27/2024 09:22:05' prior: 17006560!
   runningFinalizationProcess
	"Answer the FinalizationProcess I am running, if any"
	^EphemeronFinalizationProcess theFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/27/2024 09:22:05' prior: 17006616!
                       stopFinalizationProcess
	"kill old process"
	EphemeronFinalizationProcess stopFinalizationProcess! !
!SystemDictionary class methodsFor: 'initialization' stamp: 'jmv 12/12/2024 12:36:48' prior: 16971714 overrides: 16917943!
initialize
	"
	SystemDictionary initialize
	"

	StartUpList := OrderedCollection new.
	"These get processed from the top down..."
	#(
		#Delay
		#DisplayScreen
		#Cursor
		#InputSensor
		#ProcessorScheduler 	"Starts low space watcher and bkground."
		#EphemeronFinalizationProcess)
			do: [ :clsName | 	
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToStartUpList: cls]].
			
	ShutDownList := OrderedCollection new.
	"These get processed from the bottom up..."
	#(
		#Delay
		#DisplayScreen
		#InputSensor
		#ProcessBrowser
		#CPUWatcher)
			do: [ :clsName | 
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToShutDownList: cls]]! !

WeakArray class removeSelector: #cleanupForEphemeronFinalizationProcess!

SystemDictionary initialize!

EphemeronFinalizationProcess initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	SystemDictionary initialize.
	WeakArray restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6920-EphemeronFinalizationProcess-JohnMcIntosh-2024Dec12-12h16m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:57:17 pm'!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore '
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:24:01'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore'
	poolDictionaries: ''
	category: 'Collections-Weak'!
!WeakArray class methodsFor: 'class initialization' stamp: 'jmv 12/12/2024 12:50:09' prior: 17006567 overrides: 16917943!
                            initialize
	"
	WeakArray initialize.
	"

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.! !

WeakArray class removeSelector: #startUp!

!methodRemoval: WeakArray class #startUp stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:24:01'!
startUp
	"Do it even if just continuing after image snapshot"
	self restartFinalizationProcess!

WeakArray class removeSelector: #restartFinalizationProcess!

!methodRemoval: WeakArray class #restartFinalizationProcess stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:24:01'!
restartFinalizationProcess

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess
		ifNotNil: [ 
			FinalizationProcess terminate.
			FinalizationProcess := nil ].
	FinalizationSemaphore := nil.
	EphemeronFinalizationProcess restartFinalizationProcess!

WeakArray class removeSelector: #pvtCreateTemporaryObjectIn:!

!methodRemoval: WeakArray class #pvtCreateTemporaryObjectIn: stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:24:01'!
pvtCreateTemporaryObjectIn: tempObject
	"We have to create the temporary object in a separate stack frame"
	tempObject at: 1 put: Object new!

WeakArray class removeSelector: #isFinalizationSupported!

!methodRemoval: WeakArray class #isFinalizationSupported stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:24:01'!
isFinalizationSupported
	"This method is only here for backwards compatibility, all closure VMs support finalization"
	
	^true!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock'
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:24:01'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock'
	poolDictionaries: ''
	category: 'Collections-Weak'!

WeakArray initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:18:56 pm'!

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st 1/2/2025 10:24:01'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronIdentityDictionary commentStamp: 'eem 10/1/2020 16:31' prior: 50333976!
         An EphemeronIdentityDictionary is an identity dictionary that uses ephemerons for its associations, and hence is able to arrange that its keys are finalizable.  See Ephemeron's class comment.

Instance Variables
	mutex:		<Mutex>

mutex
	- an access protect that prevents the receiver getting corrupted as finalization occurs while lower priority processes are adding and/or rremoving ephemerons.
!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:45:00' overrides: 16847372!
                       associationAt: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super associationAt: key ifAbsent: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:27:37' overrides: 16847399!
        at: key ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key ifAbsent: absentBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:25:34' overrides: 16847430!
                    at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key ifPresent: presentBlock ifAbsent: absentBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:25:23' overrides: 50333871!
    at: key put: anObject
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key put: anObject ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:30:42' overrides: 16847741!
    collect: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super collect: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:30:32' overrides: 16847755!
                do: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super do: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:49:11' overrides: 16847515!
                          keys
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keys ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:31:01' overrides: 16847760!
      keysAndValuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysAndValuesDo: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:26:43' overrides: 16847651!
keysAndValuesRemove: keyValueBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysAndValuesRemove: keyValueBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:31:25' overrides: 16847766!
          keysDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysDo: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:45:40' overrides: 16847851!
                   rehash
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super rehash ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:51:39' overrides: 16950658!
  removeAll
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super removeAll ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:26:30' overrides: 16847692!
                            removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super removeKey: key ifAbsent: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:32:05' overrides: 16847773!
                select: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super select: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:46:02' overrides: 16950444!
                   size
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super size ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:32:16' overrides: 16847786!
      valuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super valuesDo: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:52:37'!
                finalizeValues
	"legacy systems might invoke this as it's an api on the old WeakRegistry"
	Smalltalk garbageCollect! !
!EphemeronIdentityDictionary methodsFor: 'initialize-release' stamp: 'eem 10/1/2020 10:50' overrides: 16950576!
                         init: n
	mutex := Mutex new.
	super init: n! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'jmv 12/13/2024 11:15:20' prior: 50334198 overrides: 16847844!
                        postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	mutex critical:
	[
		array := array collect: 
		[ :assoc |
		         assoc ifNotNil:
				[
				        assoc copy container: self ] ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:15:43' prior: 50334208!
               finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical: [
		self removeKey: anEphemeron key ifAbsent: []].
! !

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st 1/2/2025 10:24:01'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:20:51 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6923-FinalizationRegistry-JohnMcIntosh-JuanVuletich-2024Dec13-12h18m-jmv.001.cs.st 1/2/2025 10:24:01'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry commentStamp: '<historical>' prior: 0!
               The default FinalizationRegistry holds objects that need finalization.

Objects added with the #add: message will simply be send #finalize before being collected.
For Objects added with the #add:executor: message, #finalize will be sent to the executor (an instance of ObjectFinalizer) instead.!
!FinalizationRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 10:12:24' overrides: 50334176!
                       add: anObject
	"Add an object to be finalized."

	self at: anObject put: nil.! !
!FinalizationRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 10:34:51'!
  add: anObject executor: anObjectFinalizer
	"Add an object to be finalized."

	self at: anObject put: anObjectFinalizer.! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:16:28' overrides: 50334894!
                              finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical: [

		self removeKey: anEphemeron key ifAbsent: [].

		"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
		Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value."
		(anEphemeron value ifNil: [ anEphemeron key ])
			finalize ].! !
!FinalizationRegistry class methodsFor: 'accessing' stamp: 'jmv 12/13/2024 11:37:31'!
          default
	^Default ifNil:[Default := self new]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6923-FinalizationRegistry-JohnMcIntosh-JuanVuletich-2024Dec13-12h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6924] on 16 December 2024 at 7:10:37 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st 1/2/2025 10:24:01'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry methodsFor: 'nil' stamp: 'JMM 12/13/2024 15:34:09' overrides: 50334877!
                            init: n
	super init: n.
	errorHandler := self.! !
!FinalizationRegistry methodsFor: 'accessing' stamp: 'JMM 12/13/2024 15:38:57'!
                              errorHandler: anErrorHandler 
	errorHandler := anErrorHandler! !
!FinalizationRegistry methodsFor: 'private - synchronization' stamp: 'jmv 12/16/2024 19:10:09'!
                               handleErrorsDuring: aBlock

	aBlock on: Error do:[:ex| ex return].! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'JMM 12/16/2024 08:49:42' prior: 50334974 overrides: 50334894!
   finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical:
	[
	
		self removeKey: anEphemeron key ifAbsent: [].
		errorHandler handleErrorsDuring:
		[ 
			
			"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
			Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value."
			
			(anEphemeron value ifNil: [ anEphemeron key ])
				finalize ]].! !
!ObjectFinalizer methodsFor: 'finalization' stamp: 'JMM 12/16/2024 18:29:01' prior: 16918530 overrides: 16916076!
                        finalize
	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO guarantee that the resource associated with the receiver hasn't been freed already, so take care that you don't run into trouble - this all may happen with interrupt priority."

	receiver perform: selector withArguments: arguments! !

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st 1/2/2025 10:24:01'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6925] on 16 December 2024 at 7:33:40 pm'!
!BlockClosure methodsFor: 'exceptions' stamp: 'jmv 12/16/2024 19:28:54'!
on: exception fork: handlerAction
	"Activate the receiver. In case of exception, fork a new process, which will handle an error.
	An original process will continue running as if receiver evaluation finished and answered nil,
	i.e., an expression like:

	[ self error: 'some error'] on: Error fork: [ :ex |  ex pass ]

	will always answer nil for original process, regardless of the forked block.

	The context stack , starting from context which sent this message to receiver and
	up to the top of the stack will be transferred to forked process, with handlerAction on top.
	(so when the forked process will be resuming, it will enter the handlerAction)
	 "

	^ self
		  on: exception
		  do: [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction valueWithPossibleArgument: ex ] ].

			  bottom := [ Processor activeProcess terminate ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction valueWithPossibleArgument: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ]! !
!FinalizationRegistry methodsFor: 'private - synchronization' stamp: 'jmv 12/16/2024 19:33:35' prior: 50335036!
    handleErrorsDuring: aBlock

	"The following code would silently swallow any errors during finalization.
	This was the behavior in Cuis WeakRegistry prior to December 2024.
	Such errors would likely remain unnoticed.
	At least, printing some warning to Transcript would be better."
	"aBlock on: Error do:[:ex| ex return]."

	"The following code will resume the finalization process, but would a debugger will open
	in a forked process, so finalization is not paused or stopped."
	aBlock on: Error fork: [ :e | e pass ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6925-ForkFinalizationErrors-DebuggingAid-JohnMcIntosh-JuanVuletich-2024Dec16-19h27m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6925] on 17 December 2024 at 10:39:08 am'!

"Change Set:		6926-CuisCore-AuthorName-2024Dec17-10h27m
Date:			17 December 2024
Author:			Juan Vuletich

<your descriptive text goes here>"
WeakRegistry default notEmpty ifTrue: [ self error: 'WeakRegistry default needs to be empty  to install further updates' ].!

Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakRegistry category: #'Collections-Weak' stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:24:01'!
Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Collections-Weak'!
!Object methodsFor: 'finalization' stamp: 'jmv 12/13/2024 12:04:39' prior: 16916070!
       finalizationRegistry
	"Answer the finalization registry associated with the receiver."
	^FinalizationRegistry default! !

WeakRegistry class removeSelector: #default!

!methodRemoval: WeakRegistry class #default stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:24:01'!
default
	^Default ifNil:[Default := self new]!

Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakRegistry category: #'Collections-Weak' stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:24:01'!
Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6926] on 18 December 2024 at 9:17:49 am'!
!FileList methodsFor: 'file list' stamp: 'eem 12/18/2024 09:15:55' prior: 50333448!
       fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | entry fileSize ifNil: [mx] ifNotNil: [:fs| mx max: fs]]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6927-FileList-fix-EliotEmilioMiranda-2024Dec18-09h15m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:23:02 pm'!
!SystemWindow methodsFor: 'open/close' stamp: 'eem 12/18/2024 11:22:52' prior: 16972922 overrides: 16923980!
                 openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect := self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse).
	 For strange circumstances such as tests provoking errors, only activate windows that are still in world
	 by the time the action is actually ready to evaluate. "
	UISupervisor whenUIinSafeState:
		[ self isInWorld ifTrue:
			[ self activate ] ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6928-AllowDeletingJustCreatedWindows-EliotEmilioMiranda-2024Dec18-20h22m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:18:48 pm'!
!DebuggerWindow class methodsFor: 'services' stamp: 'eem 12/18/2024 11:12:07'!
        closeAllDebuggersSuchThat: aBlock
	"DebuggerWindow closeAllDebuggers"

	UISupervisor ui ifNotNil:
		[ :world |
		world submorphsDo:
			[ :morph |
			((morph class == DebuggerWindow or: [morph class == PreDebugWindow ])
			 and: [aBlock value: morph])
				ifTrue: [morph delete ]]]! !
!DebuggerWindow class methodsFor: 'services' stamp: 'eem 12/18/2024 11:12:22' prior: 16845344!
     closeAllDebuggers
	"DebuggerWindow closeAllDebuggers"

	self closeAllDebuggersSuchThat: [:ign| true]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6929-closeDebuggersSuchThar-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6929] on 18 December 2024 at 8:29:42 pm'!
!Ephemeron methodsFor: 'mourning' stamp: 'eem 12/18/2024 11:54:12' prior: 50334232 overrides: 50334262!
     mourn
	"Triggered ephemerons get sent mourn by EphemeronsFinalizationProcess class's finalizationProcess
	 (via mournLoopWith:) when the only reference(s) to an ephemeron's key is through
	 one or more ephemerons. i.e. the key is not reachable from the roots of the system,
	 only through ephemerons.  So ephemerons get sent mourn when their key would
	 otherwise have been garbage collected.  Respond to the information that the key
	 would have been garbage collected other than through ephemeron references by
	 sending finalize to the key.

	 N.B. read #finalizeEphemeron: to understand why #finalize is not sent here."
	container finalizeEphemeron: self.! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'eem 12/18/2024 09:52:15' prior: 50334324!
                           finalizationProcess
	"The finalization process arranges to send mourn to each element of the VM's finalization queue,
	 which is accessed via primitiveFetchMourner.  The mourn queue contains Ephemerons whose
	 keys should be finalized. The VM signals FinalizationSemaphore whenever the queue is non-empty.
	 This process loops, waiting on the semaphore, fetches the first element of the queue and then
	 spawns a process at a higher priority to actually send the mourn messages. If an error occurs in
	 the higher priority mourn loop process then this process will simply spawn another process, hence
	 ensuring that errors in finalization methods don't break finalization.

	 In addition this process also runs the old finalization scheme, supporting clients of the older,
	 WeakRegistry based scheme.  This may go away if and when all clients have moved over."
	| throttle firstMourner |
	throttle := Semaphore new.
	[true] whileTrue:
		[FinalizationSemaphore wait; initSignals.
		 "Support the old scheme until things have changed over..."
		 self doWeakFinalizationWork.
		
		 [firstMourner := self primitiveFetchMourner.
		  firstMourner notNil] whileTrue:
			[[throttle signal.
			  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1  named: '[system] Ephemeron Mourning'.
			  throttle wait]]! !
!EphemeronFinalizationProcess class methodsFor: 'class initialization' stamp: 'eem 12/18/2024 11:08:48' prior: 50334375 overrides: 16917943!
        initialize
	"
	SystemDictionary initialize.
	EphemeronFinalizationProcess restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.
	"

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.! !

EphemeronFinalizationProcess initialize.
EphemeronFinalizationProcess restartFinalizationProcess!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6930-BetterCommentsAndProcessName-EliotEmilioMiranda-2024Dec18-20h29m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:18:11 pm'!
!Ephemeron commentStamp: 'eem 12/18/2024 10:26:19' prior: 50334006!
                 An Ephemeron is an association known to the garbage collection system, allowing it to function as a "pre-mortem" finalizer, as opposed to "post-mortem" finalization.

Weak array based finalization schemes work by having a WeakArray of objects whose collection will be observed by a weak array element being nilled, and a parallel array of corresponding copies of the collectable objects. The corresponding object copy is finalized some time after the weakly referenced object is collected. This is known as post-mortem finalization and suffers the problem that the copy is finalized, not the original object. This requires effort to synchronize the original and the copy while avoiding strong references to the original, preventing its collection.

Unlike the weak scheme, ephemerons notice when their key is only referenced through ephemerons, consequenctly they can send #finalize to their key before their key is collected but when it is found to be collectable. So this finalizes the actual object with no need to maintain a copy, and is known as pre-mortem finalization.

Details:

An Ephemeron is intended for uses such as associating an object's dependents with an object without preventing garbage collection.

Consider a traditional implementation of a property table (for example, dependents in MVC).  There is a Dictionary in ActiveModel, ActionMaps, into which objects wishing to have dependents are entered as keys, with the value being the sequence of their dependents.  Since a key's dependents (if they are like views/morphs, etc in MVC) will refer directly back to the key (e.g. in their model inst var etc), the key remains srongly referenced; there is no way to use weak collections in DependentsFields to allow the cycle of an object and its dependents to be collected.  If ActionMaps were to use a WeakArray to hold the associations from objects to their dependents then those associations, and the dependencies they record, would simply be lost since the only reference to the associations is from ActionMaps.

Ephemeron differs from a normal association in that it is known to the garbage collector and it is involved in tracing.  First, note that an Ephemeron is a *strong* referrer.  The objects it refers to cannot be garbage collected.  It is not weak.  But it is able to discover when it is the *only* reference to an object.  To be accurate, an Ephemeron is notified by the collector when its key is only referenced from the transitive closure of references from ephemerons.  i.e. when an ephemeron is notified we know that there are no reference paths to the ephemeron's key other than through ephemerons; the ephemeron's key is not otherwise reachable from the roots.

Ephemerons are notified by the garage collector placing them in a queue and signalling a semaphore for each element in the queue.  An image level process (the extended finalization process) extracts them from the queue and sends mourn to each ephemeron (since their keys are effectively dead).  What an Ephemeron does in response to the notification is programmable (one can add subclasses of Ephemeron).  But the default behaviour is to send #finalize to the key, and then to remove itself from the dictionary it is in, allowing it and the transitive closure of objects reachable from it, to be collected in a subsequent garbage collection.

Implementation:

Both in scavenging, and in mark-sweep, if an ephemeron is encountered its key is examined.  If the key is reachable from the roots (has already been scavenged, or is already marked), then the ephemeron marked and treated as an ordinary object. If the key is not yet known to be reachable the ephemeron is held in an internal set of maybe triggerable ephemerons, and its objects are not traced.

At the end of the initial scavenge or mark-sweep phase, this set of triggerable ephemerons is examined.  All ephemerons in the set whose key is reachable are traced, and removed from the set.  i.e. what has happened was that their key was found reachable from the roots after they were added in set list (the garbage collector traces the object graph in an arbitrary order, typically breadth first in scavenging, depth-first in mark-sweep).  The set is then populated only with ephemerons whose keys are as yet untraced, and hence only referenced from the ephemerons in the set..  All these ephemerons are added to the finalization queue for processing in the image above, and all objects reachable from these ephemerons are traced (scavenged or marked).  This tracing phase may encounter new potentially triggerable ephemerons which will be added to the set (not likely in practice, but essential for sound semantics).  So the triggering phase continues until the system reaches a fixed point with an empty triggerable ephemeron set.

Implications and advantages:

Because ephemerons do not allow their object to be collected, they can be, and are, used to implement pre-mortem finalization.  So e.g. a file can flush its buffers and then close its file descriptor before being collected (which may also imply that the system runs the garbage collector *before* snapshotting, not as part of the snapshot primitive).  Ephemerons are conceptually more simple than WeakKeyDictionary et al, since they are about reference paths, not merely the existence of strong references.  They accurately identify when an object is no longer reachable from the roots, no matter how many ephemerons are attached to a specific object for whatever purpose.  Note that the back reference from a dependent to an object renders a weak key dictionary useless in enabling an isolated cycle to be collected since the back reference is string, and keeps the reference from the weak key alive.

History:

Ephemerons are like guardians.  They were invented by George Bosworth in the early '90's, to provide pre-mortem finalization and to solve the problem of DependentsFields retaining garbage in MVC.

Instance Variables
	container 	<Dictionary|Set> - the container in which the Ephemeron resides.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6931-Ephemeron-classComment-EliotEmilioMiranda-2024Dec18-20h15m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:22:43 pm'!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:47:15' prior: 50334707 overrides: 16847372!
                              associationAt: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super associationAt: key ifAbsent: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:26:40' prior: 50334718 overrides: 16847399!
                            at: key ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key ifAbsent: absentBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:09' prior: 50334729 overrides: 16847430!
        at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key ifPresent: presentBlock ifAbsent: absentBlock ]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:26' prior: 50334741 overrides: 50333871!
                       at: key put: anObject
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key put: anObject]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:41' prior: 50334751 overrides: 16847741!
                        collect: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super collect: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:53' prior: 50334761 overrides: 16847755!
    do: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super do: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:30:09' prior: 50334771 overrides: 16847515!
              keys
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keys]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:30:50' prior: 50334780 overrides: 16847760!
                          keysAndValuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysAndValuesDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:31:05' prior: 50334790 overrides: 16847651!
                    keysAndValuesRemove: keyValueBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysAndValuesRemove: keyValueBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:31:51' prior: 50334801 overrides: 16847766!
                              keysDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:32:07' prior: 50334811 overrides: 16847851!
      rehash
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super rehash]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:32:49' prior: 50334820 overrides: 16950658!
                      removeAll
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super removeAll]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:39:36' prior: 50334830 overrides: 16847692!
                removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super removeKey: key ifAbsent: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:44:56' prior: 50334841 overrides: 16847773!
    select: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super select: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:46:26' prior: 50334860 overrides: 16847786!
      valuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super valuesDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'eem 12/18/2024 12:07:19' prior: 50334883 overrides: 16847844!
                    postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	mutex := Mutex new.
	mutex critical:
		[array := array collect: 
			[ :assoc |
			assoc ifNotNil:
				[assoc copy container: self ] ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'eem 12/18/2024 11:55:20' prior: 50334894!
                finalizeEphemeron: anEphemeron

	"Remove the ephemeron from myself.  Note that no finalization of the ephemeron's key is done.
	 Here we are using ephemerons to clean up property tables."

	mutex critical:
		[self removeKey: anEphemeron key ifAbsent: []]! !

EphemeronIdentityDictionary removeSelector: #size!

!methodRemoval: EphemeronIdentityDictionary #size stamp: 'Install-6932-EphemeronIdentityDictionary-fixes-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st 1/2/2025 10:24:01'!
size
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super size ].
	^ answer!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6932-EphemeronIdentityDictionary-fixes-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:25:45 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:24:01'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry methodsFor: 'finalization' stamp: 'eem 12/18/2024 12:02:18' prior: 50335042 overrides: 50335790!
      finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the phemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: [].
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron value ifNil: [anEphemeron key]) finalize! !

BlockClosure removeSelector: #on:fork:!

!methodRemoval: BlockClosure #on:fork: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:24:01'!
on: exception fork: handlerAction
	"Activate the receiver. In case of exception, fork a new process, which will handle an error.
	An original process will continue running as if receiver evaluation finished and answered nil,
	i.e., an expression like:

	[ self error: 'some error'] on: Error fork: [ :ex |  ex pass ]

	will always answer nil for original process, regardless of the forked block.

	The context stack , starting from context which sent this message to receiver and
	up to the top of the stack will be transferred to forked process, with handlerAction on top.
	(so when the forked process will be resuming, it will enter the handlerAction)
	 "

	^ self
		  on: exception
		  do: [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction valueWithPossibleArgument: ex ] ].

			  bottom := [ Processor activeProcess terminate ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction valueWithPossibleArgument: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ]!

FinalizationRegistry removeSelector: #handleErrorsDuring:!

!methodRemoval: FinalizationRegistry #handleErrorsDuring: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:24:01'!
handleErrorsDuring: aBlock

	"The following code would silently swallow any errors during finalization.
	This was the behavior in Cuis WeakRegistry prior to December 2024.
	Such errors would likely remain unnoticed.
	At least, printing some warning to Transcript would be better."
	"aBlock on: Error do:[:ex| ex return]."

	"The following code will resume the finalization process, but would a debugger will open
	in a forked process, so finalization is not paused or stopped."
	aBlock on: Error fork: [ :e | e pass ].!

FinalizationRegistry removeSelector: #errorHandler:!

!methodRemoval: FinalizationRegistry #errorHandler: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:24:01'!
errorHandler: anErrorHandler 
	errorHandler := anErrorHandler!

FinalizationRegistry removeSelector: #init:!

!methodRemoval: FinalizationRegistry #init: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:24:01'!
init: n
	super init: n.
	errorHandler := self.!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:24:01'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6933] on 19 December 2024 at 9:31:22 am'!
!ChangeSorterWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 12/19/2024 09:30:56' prior: 16810086!
          changeSetListMenuSpec
	"Spec for the menu and shortcut keys for the changesets list.
	See coment at Morph >> #getMenu
	"
	| answer |
	answer := #(
			#(0 		'Change Set' 						true)
			#(10 		'File out, start a new cs (o)' 			$o 	model 		fileOutAndRemove 				fileOutIcon)
			#(20 		'File out, keep current cs (k)' 			$k 	model 		fileOutAndKeep 				fileOutIcon)
			#(30 		'-----')
			#(40 		'Rename change set (R)' 				$R 	model 		rename 						saveAsIcon)
			#(50 		'Destroy change set (x)' 			 	$x 	model 		remove 						warningIcon)
	).
	model currentCanHavePreambleAndPostscript ifTrue: [
		model currentHasPreamble
			ifTrue: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Edit preamble (p)' 					$p 	model 		addPreamble 					textEditorIcon)
				#(80 	'Remove preamble' 					nil 	model 		removePreamble 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Add preamble (p)' 					$p 	model 		addPreamble 					listAddIcon) )].
		model currentHasPostscript
			ifTrue: [ answer  := answer, #(
				#(90 	'Edit postscript...' 					nil 	model 		editPostscript 					textEditorIcon)
				#(100 	'Remove postscript' 					nil 	model 		removePostscript 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(90 	'Add postscript...' 					nil 	model 		editPostscript 					listAddIcon) )].
	].

	answer  := answer, #(
		#(110 			'-----')
		#(120 			'Conflicts with other change sets' 		nil 	window		browseMethodConflicts 		emblemImportantIcon
			'Browse all methods that occur both in this change set and in at least one other change set.')
		#(130 			'-----')
		#(140 			'Trim history' 						nil 	model		trimHistory 					clockIcon
			'Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.
 NOTE: can cause confusion if later filed in over an earlier version of these changes.')
		#(150 			'View affected class categories' 		nil 	model 		viewAffectedClassCategories	packageIcon
			'Show class categories affected by any contained change')
	).
	model csIsForBase ifFalse: [ "Maybe disable a few: Copy them the same as above, but without selector."
		answer := answer, #(
			#(40 		'Rename change set (R)' 				$R 	model 		nil 								saveAsIcon)
			#(50 		'Destroy change set (x)' 		 		$x 	model 		nil 								warningIcon)
			#(140 		'Trim history' 						nil 	model		nil 								clockIcon)) ].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6934-twoHopefullyBetterMenuItemLabels-JuanVuletich-2024Dec19-09h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6933] on 19 December 2024 at 9:49:36 am'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PreferenceSet installMiscPreferences!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6935-installMiscPreferences-JuanVuletich-2024Dec19-09h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6935] on 19 December 2024 at 1:45:57 pm'!
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:42:07' prior: 16933901!
                       become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				| contextReceiver |
				contextReceiver := context receiver.
				(self == contextReceiver or: [ otherObject == contextReceiver ]) ifTrue: [
					| selector selfMethod otherObjectMethod |
					selector := context method selector.
					selfMethod := self class lookupSelector: selector.
					otherObjectMethod := otherObject class lookupSelector: selector.
					selfMethod = otherObjectMethod ifFalse: [
						| errorMessage |
						errorMessage := contextReceiver class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#become: aborted.' print.
							Error signal: errorMessage, ' #become: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsExchangeIdentityWith: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:41:42' prior: 16916752!
     becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:
	"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				self == context receiver ifTrue: [
					| selector oldMethod newMethod |
					selector := context method selector.
					oldMethod := self class lookupSelector: selector.
					newMethod := otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						| errorMessage |
						errorMessage := self class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#becomeForward: aborted.' print.
							Error signal: errorMessage, ' #becomeForward: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:41:53' prior: 16916790!
                      becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:copyHash:
	"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :proces :context |
				self == context receiver ifTrue: [
					| selector oldMethod newMethod |
					selector := context method selector.
					oldMethod := self class lookupSelector: selector.
					newMethod := otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						| errorMessage |
						errorMessage := self class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#becomeForward:copyHash: aborted.' print.
							Error signal: errorMessage, ' #becomeForward:copyHash: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self }
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:42:25' prior: 16827934!
                        collect: aBlock andFold: aTwoArgBlock ifEmpty: emptyBlockOrValue
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each  size] andFold: [:a :b | a + b] ifEmpty: nil
	#() collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	"

	| first answer |
	first := true.
	self do: [ :each |
		| eachValue |
		eachValue :=  aBlock value: each.
		first
			ifTrue: [
				first := false.
				answer := eachValue ]
			ifFalse: [
				answer := aTwoArgBlock
					value: answer
					value: eachValue ]].
	first ifTrue: [ answer := emptyBlockOrValue valueWithPossibleArgument: self ].
	^ answer! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:43:03' prior: 16828017!
                          detectMax: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the element for which aBlock evaluates to the highest magnitude.
	If collection empty, return nil.  This method might also be called elect:."

	| maxElement maxValue |
	self do: [ :each | 
		maxValue
			ifNil: ["first element"
				maxElement := each.
				maxValue := aBlock value: each]
				"Note that there is no way to get the first element that works 
				for all kinds of Collections.  Must test every one."
			ifNotNil: [
				| val |
				(val := aBlock value: each) > maxValue ifTrue: [
					maxElement := each.
					maxValue := val]]].
	^ maxElement! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:43:55' prior: 16828040!
                      detectMin: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the element for which aBlock evaluates to the lowest number.
	If collection empty, return nil."

	| minElement minValue |
	self do: [:each | 
		minValue
			ifNil: ["first element"
				minElement := each.
				minValue := aBlock value: each]
				"Note that there is no way to get the first element that works 
				for all kinds of Collections.  Must test every one."
			ifNotNil: [
				| val |
				(val := aBlock value: each) < minValue ifTrue: [
					minElement := each.
					minValue := val]]].
	^ minElement! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:44:32' prior: 16949353!
                         groupsOf: n atATimeDo: aBlock 
	"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.
	Allows use of a flattened 
	array for things that naturally group into groups of n.
	If aBlock has a single argument, pass it an array of n items,
	otherwise, pass the items as separate arguments.
	See also pairsDo:"
	| passArray |
	passArray := (aBlock numArgs = 1).
	n
		to: self size
		by: n
		do: [:index | 
			| args |
			args := (self copyFrom: index - n + 1 to: index) asArray.
			passArray ifTrue: [ aBlock value: args ]
				ifFalse: [ aBlock valueWithArguments: args ]].! !
!Array methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:44:46' prior: 16782585 overrides: 16827969!
                               collect: collectBlock thenSelect: selectBlock
	"Evaluate collectBlock with each my elements as the argument. Collect the 
	resulting values into a collection that is like me, but only those elements for which
	selectBlock evaluates to true. Answer the new collection.
	Overriden for performance."

	^ self species streamContents: [ :strm |
		1 to: self size do: [ :index |
			| newElement |
			newElement := collectBlock value: (self at: index).
			(selectBlock value: newElement)
				ifTrue: [ strm nextPut: newElement ]]]! !
!Array methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:45:00' prior: 16782604 overrides: 16828235!
          select: selectBlock thenCollect: collectBlock
	"Evaluate selectBlock with each my elements as the argument. For those who evaluate to true,
	collect the result of evaluating collectBlock on them into a collection that is like me.
	Answer the new collection.
	Overriden for performance."

	^ self species streamContents: [ :strm |
		1 to: self size do: [ :index |
			| each |
			each := self at: index.
			(selectBlock value: each) ifTrue: [
				strm nextPut: (collectBlock value: each) ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6936-MoveTempsToInnerBlocks-JuanVuletich-2024Dec19-13h34m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6935] on 19 December 2024 at 2:05:04 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:47:41' prior: 16812435!
                 findAnySubStr: delimiters startingAt: start
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min |
	min := self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		| ind |
		ind := delim isCharacter
			ifTrue: [self indexOfSubCollection: (String with: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
		min := min min: ind].
	^ min! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:01' prior: 16812663!
             skipAnySubStr: delimiters startingAt: start 
	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."
	| ii |
	ii := start-1.
	[(ii := ii + 1) <= self size] whileTrue: [ "look for char that does not match"
		| any |
		any := false.
		delimiters do: [ :delim |
			delim isCharacter
				ifTrue: [ (self at: ii) = delim ifTrue: [any := true]]
				ifFalse: ["a substring"
					delim size > (self size - ii + 1) ifFalse: [
						| ind this |
						ind := 0.
						this := true.
						delim do: [ :dd | 
							dd = (self at: ii+ind) ifFalse: [this := false].
							ind := ind + 1].
						this ifTrue: [ii := ii + delim size - 1.  any := true]]
							ifTrue: [any := false] "if the delim is too big, it can't match"]].
		any ifFalse: [^ ii]].
	^ self size + 1! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:31' prior: 16812718!
                    subStrings: separators 
	"Answer an array containing the substrings in the receiver separated 
	by any of the elements of separators.
	Answer will not include empty strings
	'Hello World' subStrings: ' '
	'1Hello12World1This1211Are31Words1' subStrings: '123'
	'1Hello12World1This1211Are31Words1' subStrings: #($1 $2 $3)
	"

	| delimiterCharacters |
	delimiterCharacters := separators asArray.
	^Array streamContents: [ :answer |
		| out |
		out := self species writeStream.
		self do: [ :char |
			(delimiterCharacters identityIncludes: char)
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					out isEmpty ifFalse: [
						answer nextPut: out contents.
						out := self species writeStream ]]].
		out isEmpty ifFalse: [
			answer nextPut: out contents ]].! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:42' prior: 16812745!
        substringsSeparatedBy: delimiterCharacter
	"Find substrings delimited by aCharacter.
	Answer may include empty strings
	'0063;LATIN SMALL LETTER C;Ll;0;L;;;;;N;;;0043;;0043' substringsSeparatedBy: $;
	"

	^Array streamContents: [ :answer |
		| out |
		out := self species writeStream.
		self do: [ :char |
			char = delimiterCharacter
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					answer nextPut: out contents.
					out := self species writeStream ]].
		answer nextPut: out contents.
		out := nil ].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:50:36' prior: 16813289!
   asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [
					| char |
					(char := in next) = $&
					ifTrue: [
						| rest did |
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $¡].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:11' prior: 16813625!
    keywords
	"Answer an array of the keywords that compose the receiver."
	| keywords |
	keywords := Array streamContents: [ :kwds |
		| kwd isAllValidInIdentifiers |
		kwd := self species writeStream.
		isAllValidInIdentifiers := true.
		1
			to: self size
			do: [ :i |
				| char |
				char := self at: i.
				kwd nextPut: char.
				char = $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers := true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers := false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:31' prior: 16813768!
                            withBlanksCondensed
	"Return a copy of the receiver with leading/trailing blanks removed
	 and consecutive white spaces condensed as a single space."

	| trimmed |
	trimmed := self withBlanksTrimmed.
	^self species streamContents: [ :stream |
		| lastWasBlank |
		lastWasBlank := false.
		trimmed do: [ :c |
			c isSeparator
				ifTrue: [ lastWasBlank ifFalse: [ stream space ]]
				ifFalse: [ stream nextPut: c ].
			lastWasBlank := c isSeparator ]].

	"
	' abc  d   ' withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' withBlanksCondensed
	"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:42' prior: 16813831!
                               withDoubleColonsUndoubled
	"Do the inverse of #withDoubleColonsDoubled"

	^self species streamContents: [ :stream |
		| lastWasDoubleColon |
		lastWasDoubleColon := false.
		self do: [ :c |
			c = $"
				ifTrue: [
					lastWasDoubleColon
						ifFalse: [
							stream nextPut: c.
							lastWasDoubleColon := true ]
						ifTrue: [
							lastWasDoubleColon := false]]
				ifFalse: [
					stream nextPut: c.
					lastWasDoubleColon := false ]]].! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 12/19/2024 13:52:05' prior: 16814513!
   correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results maxChoices |
	scoreMin := self size // 2 min: 3.
	maxChoices := 10.
	choices := oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results := OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				| score |
				(score := self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].
			results := choices ].
	^ results! !
!CharacterSequence methodsFor: 'formatting' stamp: 'jmv 12/19/2024 13:52:18' prior: 16814573!
                      format: aCollection
	"format the receiver with aCollection  
	 
	simplest example:
	'foo {1} bar' format: {Date today}.
	 
	complete example:
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}..
	"
	^self species streamContents: [ :out |
		| stream |
		stream := self readStream.
		[stream atEnd]
			whileFalse: [| currentChar | 
				currentChar := stream next.
				currentChar = ${
					ifTrue: [| expression | 
						expression := self getEnclosedExpressionFrom: stream.
						out nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
					ifFalse: [
						currentChar = $\
							ifTrue: [stream atEnd ifFalse: [out nextPut: stream next]]
							ifFalse: [out nextPut: currentChar]]]].! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 13:52:49' prior: 16814861 overrides: 16917720!
                        readFrom: inStream
	"Answer a new String that is determined by reading the stream, inStream.  Embedded
	double quotes become the quote Character."

	^self streamContents: [ :outStream |
		| done |
		"go to first quote"
		inStream skipTo: $'.
		done := false.
		[done or: [inStream atEnd]]
			whileFalse: 
				[ |char|
				char := inStream next.
				char = $'
					ifTrue: 
						[char := inStream next.
						char = $'
							ifTrue: [outStream nextPut: char]
							ifFalse: [done := true]]
					ifFalse: [outStream nextPut: char]]].! !
!Symbol methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:54:20' prior: 16962598!
                   numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs |
	(numArgs := self numArgs) >= n ifTrue: [ ^self ].	
	^ (self species streamContents: [ :strm |
		| offs |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs := 0 ] ifFalse: [offs := 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol! !
!UnicodeString methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:57:10' prior: 16995179 overrides: 16949345!
        from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex cpIndex |
	byteIndex := self byteIndexAt: startIndex.
	cpIndex := startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		| n |
		n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (Character codePoint: codePoint).
			cpIndex := cpIndex + 1 ].
		byteIndex := byteIndex + n ].! !
!UnicodeString methodsFor: 'private' stamp: 'jmv 12/19/2024 13:57:44' prior: 16995410!
                            computeCountAndIndexFull
	| strideIndexClass |
	count := 0.
	strideIndexClass := bytes size < 256
		ifTrue: [ ByteArray ]
		ifFalse: [ bytes size < 65536
			ifTrue: [ DoubleByteArray ]
			ifFalse: [ bytes size < 4294967296
				ifTrue: [ WordArray ]
				ifFalse: [DoubleWordArray ]]].
	strideIndex := strideIndexClass streamContents: [ :out |
		| byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 13:59:07' prior: 16995576!
               basicCanonicalComposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalComposition.
	(UnicodeString fromCodePoints: #(119128 119141)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119135 119151)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119128 119141 119151)) basicCanonicalComposition asCodePoints
	"
	| byteIndex stopByteIndex combining |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				(Character combiningClass: codePoint) = 0 ifTrue: [
					self basicCompose: combining on: strm.
					combining := OrderedCollection new ].
				combining add: codePoint ].
			byteIndex := byteIndex + n ].
		self basicCompose: combining on: strm ].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 13:59:22' prior: 16995612!
                          basicCanonicalDecomposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalDecomposition.
	(Character codePoint: 119135) asString basicCanonicalDecomposition asCodePoints
	(Character codePoint: 119137) asString basicCanonicalDecomposition asCodePoints
	"
	| byteIndex stopByteIndex |
	byteIndex := 1.
	stopByteIndex := bytes size.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				Character canonicalDecomposition: codePoint on: strm ].
			byteIndex := byteIndex + n ]].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 14:00:26' prior: 16995637!
                  basicCanonicallyOrdered
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	(UnicodeString fromCodePoints: #(16r61  16r0300 16r0315 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0300 16r031B 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r031B 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r0300 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0300 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0315 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	"
	| byteIndex stopByteIndex combining |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				| cls |
				cls := Character combiningClass: codePoint.
				cls = 0
					ifTrue: [
						combining notEmpty ifTrue: [
							combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
							combining do: [ :e | strm nextPutCodePoint: e third ]].
						strm nextPutCodePoint: codePoint.
						combining := OrderedCollection new ]
					ifFalse: [
						| element |
						element := { cls. combining size+1. codePoint }.
						combining add: element ]].
			byteIndex := byteIndex + n ].
		combining notEmpty ifTrue: [
			combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
			combining do: [ :e | strm nextPutCodePoint: e third ] ]].! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 14:02:07' prior: 16995863!
            fromBytesStream: aByteStream
	"Handle UTF-8 bytes, but convert invalid UTF-8 assuming it means ISO-8859-1.
	Argument can be, for example, a InflateStream."

	| utf8 codePointCount buffer readBytes leftover byteIndex |
	buffer := ByteArray new: 10000.
	leftover := nil.
	codePointCount := 0.
	utf8 := ByteArray streamContents: [ :utf8Stream |
		[aByteStream atEnd] whileFalse: [ 
			readBytes := aByteStream nextInto: buffer.
			leftover ifNotNil: [
				readBytes := leftover, readBytes.
				leftover := nil ].
			byteIndex := 1.
			[ byteIndex <= (aByteStream atEnd
						ifFalse: [readBytes size-3] "To be sure we don't break a possible partially read multibyte code point."
						ifTrue: [readBytes size])   						"But do taks _all_ the bytes if they are the last ones."
			] whileTrue: [
				| n |
				n := Character utf8BytesAndCodePointAt: byteIndex in: readBytes
					into: [ :byte1 :byte2 :byte3 :byte4 |
						utf8Stream nextPut: byte1.
						byte2 ifNotNil: [
							utf8Stream nextPut: byte2.
							byte3 ifNotNil: [
								utf8Stream nextPut: byte3.
								byte4 ifNotNil: [
									utf8Stream nextPut: byte4 ]]].
						codePointCount := codePointCount + 1]
					into: nil.
				byteIndex := byteIndex + n ].
			leftover := byteIndex > readBytes size ifFalse: [
				readBytes copyFrom: byteIndex to: readBytes size ].
		].
	].
	^self fromUtf8Bytes: utf8 codePointCount: codePointCount.! !
!UnicodeSymbol methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:54:35' prior: 16996633!
           numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs |
	(numArgs := self numArgs) >= n ifTrue: [ ^self ].	
	^ (self species streamContents: [ :strm |
		| offs |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs := 0 ] ifFalse: [offs := 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol.! !
!Text methodsFor: 'emphasis' stamp: 'jmv 12/19/2024 14:04:15' prior: 16979735!
       fontIfApplying: textAttributes default: defaultFont
	"Answer the font for characters as specified by the argument."

	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		| font |
		font := defaultFont ifNil: [FontFamily defaultFamilyAndPointSize].
		familyName notNil | pointSize notNil ifTrue: [
			| fn ps |
			fn := familyName ifNil: [ defaultFont familyName ].
			ps := pointSize ifNil: [ defaultFont pointSize ].
			(FontFamily familyName: fn pointSize: ps) ifNotNil: [ :f |
				font := f emphasized: defaultFont emphasis]].
		^font emphasized: (defaultFont emphasis bitOr: emphasis) ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6937-MoveTempsToInnerBlocks-JuanVuletich-2024Dec19-13h45m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6937] on 19 December 2024 at 3:56:36 pm'!
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: 'jmv 12/19/2024 15:54:10' prior: 16939242!
                          restoreFromFile: aFileEntry
"
 Note about importing String objects from Squeak: 
	
To make sure Strings can be moved from Squeak use 
           aString utf8Encoded 
to convert the strings to ByteArrays in Squeak before you export the object collection.

In Cuis you need to do then
           UnicodeString fromUtf8Bytes: aByteArray
to get them back.
"
	^aFileEntry readStreamDo: [ :stream |
		(self on: stream) next ].! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 15:50:09' prior: 16870499!
                          fromFileEntry: aFileEntry
	"Read a Form or ColorForm from the given file."

	^aFileEntry readStreamDo: [ :stream |
		self fromBinaryStream: stream binary ]! !
!ChangeList class methodsFor: 'public access' stamp: 'jmv 12/19/2024 15:54:48' prior: 16804880!
 browsePackageContents: aFileEntry
	"Opens a changeList on a fileStream"
	| changeList packageFile |
	packageFile := CodePackageFile onFileEntry: aFileEntry.
	changeList := aFileEntry readStreamDo: [ :stream |
		self new scanFile: stream from: 0 to: stream size ].
	"Add deletions of methods and classes that are in the CodePackage (i.e., active in the system)
	but are no longer in the CodePackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)
			text: 'method no longer in package: ', methodReference stringVersion ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new className: clsName)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aFileEntry name! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 12/19/2024 15:47:13' prior: 16861116!
   binaryContents
	^self readStreamDo: [ :stream |
		stream binary contents ].! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 12/19/2024 15:48:35' prior: 16861179!
                         textContents
	^self readStreamDo: [ :stream |
		stream contents ].! !
!FileEntry methodsFor: 'accessing-stream' stamp: 'jmv 12/19/2024 15:51:26' prior: 16861214!
                              readStreamDo: blockWithArg 
	"Raise FileDoesNotExistException if not found."
	| stream |
	stream := self readStream.
	^ [ blockWithArg value: stream ]
		ensure: [
			stream
				ifNotNil: [ :s | s close ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6938-readStreamDo-andSenders-Optimize-JuanVuletich-2024Dec19-15h47m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:29:46 pm'!
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 12/20/2024 16:13:32' prior: 16827162!
       methodInheritance
	"Create and schedule a method browser on the inheritance of implementors."

	| list aClassNonMeta isMeta aClass sel |
	aClass := model selectedClassOrMetaClass.
	sel := model selectedMessageName.
	aClass ifNil: [ ^ nil ].
	sel ifNil: [ ^ nil ].
	aClassNonMeta := aClass theNonMetaClass.
	isMeta := aClassNonMeta ~~ aClass.
	list := OrderedCollection new.
	aClass allSuperclasses reverseDo: [ :cl |
		(cl includesSelector: sel) ifTrue: [
			list addLast: (MethodReference class: cl selector: sel) ]].
	aClassNonMeta
		allSubclassesWithLevelDo: [ :cl :level |
			| theClassOrMeta |
			theClassOrMeta := isMeta
				ifTrue: [ cl class ]
				ifFalse: [ cl ].
			(theClassOrMeta includesSelector: sel) ifTrue: [
				list addLast: (MethodReference class: theClassOrMeta selector: sel) ]]
		startingLevel: 0.
	^ Smalltalk
		browseMessageList: list
		name: 'Implementors of ' , sel, ' in ', aClass name, ' and super / sub classes'.! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 12/20/2024 16:15:07' prior: 16932554!
           changePriority
	| rule |
	rule := (model class rulesFor: model selectedProcess) second.
	rule
		ifFalse: [self inform: 'Nope, won''t change priority of ' , model selectedProcess name.
			^ self].
	self request: 'New priority'
		initialAnswer: model selectedProcess priority printString
		verifying: [:aString| ([aString asNumber asInteger] on: Error do: []) isInteger]
		do: [ :aString |
			| newPriority |
			newPriority := aString asNumber asInteger.
			(newPriority between: 1 and: Processor highestPriority)
			ifTrue:
				[model class setProcess: model selectedProcess toPriority: newPriority.
				model updateProcessList]
			ifFalse: [self inform: 'Bad priority']]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/20/2024 16:16:27' prior: 16881190 overrides: 16923705!
     adjustExtent
	"And reposition submorphs"
	| w y |
	"make all items wide, so selection indicator is wide too"
	w := self desiredWidth.
	y := 0.
	self submorphsDo: [ :m | | h |
		h := m morphHeight.
		m position: 0@y extent: w@h.
		y := y + h ].
	self morphExtent: w@y! !
!MorphicCanvas methodsFor: 'morphic world' stamp: 'jmv 12/20/2024 16:17:49' prior: 16909896!
                     drawRoots: rootMorphs rootsDamage: rootsDamage backgroundDamage: backgroundDamage
	"Redraw the damaged areas.
	Draw each morph just once, merging rectanges to be repaired as needed."
	"Iterate from back to front."

	| allDamage newDamageFromMorphsBelow |
	"Don't need a copy just because nobody will use it afterwards"
	newDamageFromMorphsBelow := backgroundDamage.
	allDamage := Rectangle merging: newDamageFromMorphsBelow.
	rootMorphs size to: 1 by: -1 do: [ :i | | morph morphDamage |
		morph := rootMorphs at: i.
		morphDamage := rootsDamage at: i.
		morph displayFullBounds ifNotNil: [ :morphFullBounds |
			newDamageFromMorphsBelow do: [ :r | | intersection |
				intersection := r intersect: morphFullBounds.
				intersection hasPositiveExtent ifTrue: [
					morphDamage
						ifNil: [ morphDamage :=  intersection ]
						ifNotNil: [ morphDamage updateMerging: intersection ]]]].
		morphDamage ifNotNil: [
			self newClipRect: morphDamage.
			self fullDraw: morph.
			newDamageFromMorphsBelow add: morphDamage.
			allDamage
				ifNil: [ allDamage := morphDamage copy ]
				ifNotNil: [ allDamage updateMerging: morphDamage ]]].
	^allDamage! !
!MorphicCanvas methodsFor: 'morphic world' stamp: 'jmv 12/20/2024 16:18:28' prior: 16910119!
     updateAllDamage: allDamage roots: rootMorphs rootsDamage: rootsDamage backgroundDamage: backgroundDamage
	"Detect any morph whose damage would grow because of morphs beneath it.
	If one found, add the new larger damage to allDamage and exit.
	See sender."
	"Iterate from back to front."

	| newDamageFromMorphsBelow |
	newDamageFromMorphsBelow := backgroundDamage copy.
	rootMorphs size to: 1 by: -1 do: [ :i |
		| morph morphPreviousDamage morphDamage |
		morph := rootMorphs at: i.
		morphPreviousDamage := rootsDamage at: i.
		morphDamage := morphPreviousDamage copy.
		morph displayFullBounds ifNotNil: [ :morphFullBounds |
			newDamageFromMorphsBelow do: [ :r | | intersection |
				intersection := r intersect: morphFullBounds.
				intersection hasPositiveExtent ifTrue: [
					morphDamage
						ifNil: [ morphDamage :=  intersection ]
						ifNotNil: [ morphDamage updateMerging: intersection ]]]].
		morphDamage ifNotNil: [
			newDamageFromMorphsBelow add: morphDamage ].
		morphDamage = morphPreviousDamage ifFalse: [
			allDamage add: morphDamage.
			^true 	]].
	^false! !
!AbstractVectorCanvas class methodsFor: 'private' stamp: 'jmv 12/20/2024 16:19:33' prior: 16779308!
 scalePathData: aFloat32Array scale: scale
	"aFloatArray is a #pathSequence: argument. It encodes a sequence of path commands in a Float32Array.
	See #pathSequence:"

	^Float32Array streamContents: [ :scaledStrm | | unscaledStrm kind |
		unscaledStrm := aFloat32Array readStream.
		[ unscaledStrm atEnd ] whileFalse: [
			kind := unscaledStrm next.
			scaledStrm nextPut: kind.
			(kind asInteger *2 max: 2) timesRepeat: [
				scaledStrm nextPut: unscaledStrm next * scale ]]
		].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 12/19/2024 12:41:19' prior: 16999569!
              image: aForm multipliedBy: aColor at: aPoint
	"Multiply aForm and aColor, then blend over destination.
	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel

	(BitBltCanvas onForm: Display) image: ((Form dotOfSize: 50) asFormOfDepth: 32) multipliedBy: Color red at: 20@20. Display forceToScreen
	"
	aColor isTransparent ifFalse: [
		BitBltCanvas accessProtect critical: [ | f |
			f := BitBltCanvas buildAuxWith: aForm multipliedWith: aColor.
			self image: f at: aPoint sourceRect: aForm boundingBox ]]! !
!VectorEngineBoundsFinder methodsFor: 'primitive algorithms' stamp: 'jmv 12/20/2024 16:25:41' prior: 17001354!
                       arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	| dx dy trx try tcx tcy center angle d hops |
	dx := geometryTransformation externalizeDelta: rx@0.
	dy := geometryTransformation externalizeDelta: 0@ry.
	trx := dx r.
	try := dy r.
	hops := ((trx max: try) * sweepAngle abs / hop) truncated + 2.
	d := sweepAngle / hops.
	center := geometryTransformation externalizePosition: cx@cy.
	tcx := center x.
	tcy := center y.
	(trx = try and: [
		d * hops > 6.28]) ifTrue: [ 	"If a circle, not an ellipse, and a complete circle, or pretty close"
			spanLeft := spanLeft min: tcx - trx.
			spanRight := spanRight max: tcx + trx.
			spanTop := spanTop min: tcy - trx.
			spanBottom := spanBottom max: tcy + trx ]

		ifFalse: [						"Else go the more expensive way"
			angle := startAngle.
			hops := hops+1.
			hops timesRepeat: [
				| x xp y yp |
				xp := angle cos * trx.
				yp := angle sin * try.
				x := thetaCos * xp - (thetaSin * yp) + tcx.
				y := thetaSin * xp + (thetaCos * yp) + tcy.
				spanLeft := spanLeft min: x.
				spanRight := spanRight max: x.
				spanTop := spanTop min: y.
				spanBottom := spanBottom max: y.
				angle := angle + d. ]].! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 9/15/2021 14:47:40' prior: 17002101!
                             arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	| dx dy trx try tcx tcy center angle xp yp x y d hops |
	dx := geometryTransformation externalizeDelta: rx@0.
	dy := geometryTransformation externalizeDelta: 0@ry.
	trx := dx r.
	try := dy r.
	hops := ((trx max: try) * sweepAngle abs / hop) truncated + 2.
	d := hops asFloat.
	center := geometryTransformation externalizePosition: cx@cy.
	tcx := center x.
	tcy := center y.
	0 to: hops do: [ :h |
		angle := h / d * sweepAngle + startAngle.
		xp := angle cos * trx.
		yp := angle sin * try.
		x := thetaCos * xp - (thetaSin * yp) + tcx.
		y := thetaSin * xp + (thetaCos * yp) + tcy.
		spanLeft := spanLeft min: x.
		spanTop := spanTop min: y.
		spanRight := spanRight max: x.
		spanBottom := spanBottom max: y.
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y. ].! !
!VectorEngineWithPluginSubPixel methodsFor: 'hacky dashed strokes' stamp: 'jmv 12/19/2024 12:43:08' prior: 17004922!
                   dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineSubPixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
! !
!VectorEngineWithPluginWholePixel methodsFor: 'hacky dashed strokes' stamp: 'jmv 12/19/2024 12:43:13' prior: 17005116!
                         dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineWholePixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6939-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h13m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:50:15 pm'!
!PathLineToCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:44:34' prior: 16923435 overrides: 16923291!
                         buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	points := Array streamContents: [ :strm | | px py |
		[px := aStream nextNumber.
		py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: px@py ]]! !
!PathLineToHCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:44:43' prior: 16923468 overrides: 16923291!
                  buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	xs := Array streamContents: [ :strm | | px |
		[px := aStream nextNumber.
		px notNil ] whileTrue:
			[ strm nextPut: px ]]! !
!PathLineToVCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:45:11' prior: 16923500 overrides: 16923291!
                        buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	ys := Array streamContents: [ :strm | | py |
		[py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: py ]]! !
!PathMoveToCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:45:17' prior: 16923532 overrides: 16923291!
                         buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	points := Array streamContents: [ :strm | | px py |
		[px := aStream nextNumber.
		py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: px@py ]]! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 12/20/2024 16:37:37' prior: 16812270!
        scanCharactersFrom: startIndex to: stopIndex in: anUnicodeString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	lastIndex := startIndex.
	anUnicodeString from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		| nextDestX |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX := destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX := nextDestX.
			lastIndex := lastIndex + 1 ].
	lastIndex := stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!TTContourConstruction methodsFor: 'primitive format' stamp: 'jmv 12/20/2024 16:38:48' prior: 16973767!
                   addContourDataTo: stream tx: aGeometryTransformationOrNil
	| bezierCount firstPoint prevEndPoint |
	self isEmpty ifTrue: [
		^self ].

	"This bogus iteration could perhaps be avoided at the cost of extra memory."
	bezierCount := 0.
	self
		startPointDo: [ :firstBezierStart | ]
		quadraticBeziersDo: [ :controlPoint :endPoint | bezierCount := bezierCount + 1 ].
	stream nextPut: bezierCount.

	self
		startPointDo: [ :firstBezierStart |
			firstPoint := firstBezierStart.
			aGeometryTransformationOrNil notNil ifTrue: [
				firstPoint := aGeometryTransformationOrNil transform: firstPoint ].
			stream nextPut: firstPoint x; nextPut: firstPoint y.
			prevEndPoint := firstPoint ]
		quadraticBeziersDo: [ :controlPoint :endPoint |
			| cp ep cpr epr |
			cp := controlPoint.
			ep := endPoint.
			aGeometryTransformationOrNil notNil ifTrue: [
				cp := aGeometryTransformationOrNil transform: cp.
				ep := aGeometryTransformationOrNil transform: ep ].
			cpr := cp - prevEndPoint.
			epr := ep - prevEndPoint.
			"Make control point distict from start and end points for the benefit of VectorEnginePlugin"
			(cpr = `0.0@0.0` or: [ cpr = epr ]) ifTrue: [
				cpr := epr * 0.5 ].
			stream nextPut: epr x; nextPut: epr y.
			stream nextPut: cpr x; nextPut: cpr y.
			prevEndPoint := ep ].! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 12/19/2024 11:51:50' prior: 16918072 overrides: 16916986!
     stepAt: millisecondSinceLast

	"If there's anything in my monitor list, see if the strings have changed."
	| changes |
	changes := false.
	self monitorList keysAndValuesDo: [ :k :v |
		k ifNotNil: [ | string |
			k refresh.
			(string := k asString) ~= v ifTrue: [
				self monitorList at: k put: string. changes := true ]]].
	changes ifTrue: [ | sel |
		sel := currentSelection.
		self changed: #getList.
		self noteNewSelection: sel ]! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 12/19/2024 11:52:50' prior: 16842184!
             dayOfYear
	"This code was contributed by Dan Ingalls. It is equivalent to the terser
		^ jdn - (Year year: self year) start julianDayNumber + 1 but much quicker."

	^ self dayMonthYearDo:
		[ :d :m :y | | monthStart |
			monthStart := #(1 32 60 91 121 152 182 213 244 274 305 335) at: m.
			(m > 2 and: [ Year isLeapYear: y ])
				ifTrue: [ monthStart + d ]
				ifFalse: [ monthStart + d - 1 ]]! !
!Float methodsFor: 'converting' stamp: 'jmv 12/20/2024 16:41:27' prior: 16865214!
partValues: aThreeArgumentBlock ifInfinite: infinityBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits |
		| sign exponent mantissa |

		"Extract the sign"
		sign := signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infinityBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent := exponentBits - 16r3FF.
	
		exponentBits ~= 0
			ifTrue: [
				"Add back implicit leading 1 in fraction."
				mantissa := 16r0010000000000000 bitOr: mantissaBits ]
			ifFalse: [
				"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa."
				mantissa := mantissaBits.
				exponent := exponent + 1 ].

		"Evaluate the block"
		aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/19/2024 11:54:47' prior: 16865329!
            floatsAwayFrom: aFloat

	| count2 count1 |
	(self isNaN or: [ aFloat isNaN ]) ifTrue: [ ^ Float nan ].
	count2 := self partBits: [:s :e :m | (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	count1 := aFloat partBits: [:s :e :m | (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	^count2 - count1! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/20/2024 16:44:16' prior: 16865383!
                              nextAwayFromZero
	"Answer the Float with smallest magnitude but larger than ours, with the same sign
	Only for finite numbers."

	^ self partValues: [ :sign :myExponent :myMantissa |
		| exponent mantissa |
		myMantissa = 16r1FFFFFFFFFFFFF
			ifTrue: [
				mantissa := 16r10000000000000.
				exponent := myExponent +1 ]
			ifFalse: [
				mantissa := myMantissa+1.
				exponent := myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/20/2024 16:45:10' prior: 16865401!
           nextTowardsZero
	"Answer the Float with largest magnitude but smaller than ours, with the same sign.
	Only for finite, non zero numbers."

	^ self partValues: [ :sign :myExponent :myMantissa |
		| exponent mantissa |
		myMantissa isZero ifTrue: [ self error: 'Not for zero values' ].
		(myMantissa = 16r10000000000000 and: [myExponent > Float emin])
			ifTrue: [
				mantissa := 16r1FFFFFFFFFFFFF.
				exponent := myExponent -1 ]
			ifFalse: [
				mantissa := myMantissa-1.
				exponent := myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Fraction methodsFor: 'printing' stamp: 'jmv 12/20/2024 16:46:07' prior: 16871379 overrides: 16914567!
                      storeOn: aStream
	
	"If possible, store as a literal of the form 9999e-99
	If denominator's prime factors are just 2 and 5, then we can be printed as a literal
	of the form 999999e-99"
	"
	123e-12 storeString
	123e-12 printString
	123e-12000 storeString
	123e-12000 printString
	(3/4) storeString
	(3/4) printString
	(-3/4) storeString
	(-3/4) printString
	(1/3) storeString
	(1/3) printString
	"
	denominator
		ifMultipleOf2And5Do: [ :exponent2 :exponent5 |
			| e f |
			exponent2 > exponent5
				ifTrue: [
					e := exponent2.
					f := 5 raisedToInteger: e-exponent5 ]
				ifFalse: [
					e := exponent5.
					f := 2 bitShift: e-exponent2-1 ].
			numerator*f storeOn: aStream base: 10.
			aStream nextPut: $e; nextPut: $-.
			e storeOn: aStream base: 10 ]
		otherwise: [
			super storeOn: aStream ]
! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/20/2024 16:48:50' prior: 16891336!
     layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * self axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/20/2024 16:49:11' prior: 16891373!
                   layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * self axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!TextComposition methodsFor: 'editing' stamp: 'jmv 12/20/2024 16:31:46' prior: 16981562!
            clickAt: clickPoint
	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."
	| action startBlock t |
	action := false.
	startBlock := self characterBlockAtPoint: clickPoint.
	t := model actualContents.
	(t attributesAt: startBlock stringIndex) do: [ :att | 
		att mayActOnClick ifTrue: [ | target range boxes box |
				(target := model) ifNil: [ target := editor morph].
				range := t rangeOf: att startingAt: startBlock stringIndex.
				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 
							to: (self characterBlockForIndex: range last+1).
				box := boxes detect: [ :each | each containsPoint: clickPoint] ifNone: nil.
				box ifNotNil: [
					box := editor morph displayBounds.
					editor morph allOwnersDo: [ :m | box := box intersect: (m displayBounds) ].
					Utilities
						awaitMouseUpIn: box
						repeating: nil
						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action := true]].
				]]].
	^ action! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 12/20/2024 16:32:24' prior: 16862013!
            splitNameVersionExtensionFor: fileName
	" answer an array with the root name, version # and extension.
	See comment in senders for more details"

	self baseNameAndExtensionFor: fileName do: [ :b :extension |
		| baseName version i j |
		baseName := b.
		i := j := baseName findLast: [:c | c isDigit not].
		i = 0
			ifTrue: [version := 0]
			ifFalse: [
				(baseName at: i) = $.
					ifTrue: [
						version := (baseName copyFrom: i+1 to: baseName size) asNumber.
						j := j - 1]
					ifFalse: [version := 0].
				baseName := baseName copyFrom: 1 to: j ].
		^ Array with: baseName with: version with: extension ]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 12/19/2024 12:47:06' prior: 16823886!
 sortedExtensionMethodsDo: aBlock displayingProgress: aString
	"Include both class and instance methods we define, for classes we don't define."
	| externalClasses |
	externalClasses := self externalClasses.
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: externalClasses size
		during: [ :barBlock |
			externalClasses withIndexDo: [ :classOrMetaClass :i | | methods |
				barBlock value: i.
				methods := Array streamContents: [ :stream |
					(self extensionCategoriesForClass: classOrMetaClass) do: [ :cat |
						self methodsInCategory: cat ofClass: classOrMetaClass do: [ :m |
							stream nextPut: m ]]].
				methods sort: [ :a :b |
					a methodSymbol < b methodSymbol ].
				methods do: aBlock.
				]
			]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 12/19/2024 12:46:23' prior: 16824420!
named: aString createIfAbsent: neverAnswerNil registerIfNew: doRegisterIfJustCreated
	"Answer the instance with name aString.
	If there's no package named aString, answer nil or a new instance as requested.
	If a new instance is created, register it or not as requested.
	CodePackage named: 'Morphic' createIfAbsent: false registerIfNew: false
	CodePackage named: 'Morphic' createIfAbsent: true registerIfNew: false
	CodePackage named: 'XXXXXTest' createIfAbsent: true registerIfNew: true
	"

	| newInstance |
	^self installedPackages
		at: aString
		ifAbsent: [
			neverAnswerNil ifTrue: [ 
				newInstance := self new packageName: aString.
				doRegisterIfJustCreated ifTrue: [ self register: newInstance ].
				newInstance ]].! !
!FeatureRequirement methodsFor: 'requires' stamp: 'jmv 12/19/2024 12:47:11' prior: 16860502!
      findPackageFileAsReqOf: mainFeatureOrNil
	"Look in known places for packages providing required feature.
	Answer wether search was successful."
	| packageFileName |
	pathName ifNotNil: [
		pathName asFullFileEntry exists ifTrue: [ ^ true ]].
	packageFileName := self packageFileName.
	(mainFeatureOrNil ifNil: [ self ]) placesToLookForPackagesDo: [ :directory | | entry |
		entry := directory // packageFileName.
		entry exists ifTrue: [
			"Try this one. If success, keep it."
			self pathName: entry pathName.
			self checkRequirement ifTrue: [ ^true ].
			"Nope. Don't keep it."
			self pathName: nil ]].
	^ false! !
!Clipboard methodsFor: 'private' stamp: 'jmv 12/19/2024 12:47:24' prior: 16821332!
 extendedClipboardInterface
	"Answer a subinstance of ExtendedClipboardInterface, if present and operational.
	Clipboard default extendedClipboardInterface
	"
	Smalltalk at: #ExtendedClipboardInterface ifPresent: [ :clipboardInterface |
		| interface |
		interface := clipboardInterface current.
		interface isOperational ifTrue: [
			^ interface ]].
	"No operational extended clipboard."
	^nil! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 12/19/2024 12:47:33' prior: 16930271!
               installHaloPreferencesWith: anArray
	^ self sysPreferences 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each | | aColor |
			aColor := Color.
			each fourth do: [ :sel | aColor := aColor perform: sel].
			HaloSpec new 
				horizontalPlacement: each second
				verticalPlacement: each third 
				color: aColor
				iconSymbol: each fifth
				addHandleSelector: each first
				hoverHelp: each sixth])! !
!PreferenceSet class methodsFor: 'sys fonts' stamp: 'jmv 12/19/2024 12:47:47' prior: 16930381!
                        setDefaultFont: fontFamilyName spec: defaultFontsSpec

	defaultFontsSpec do: [ :triplet | | font |
		font := FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font := FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font := font emphasized: triplet third ].
		self sysPreferences at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceSet class methodsFor: 'services' stamp: 'jmv 12/19/2024 12:47:39' prior: 16930474!
                 readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [ | line parts |
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[ | pref value |
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first = $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefts.txt Error' print.
						error print.
						line print ].
				]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6940-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:58:56 pm'!
!WeakActionSequence methodsFor: 'evaluating' stamp: 'jmv 8/2/2016 16:38:32' prior: 17006443!
              valueStartingFrom: startIndex
	"Do the same as my parent, but make sure that all actions that do not 
	give errors are evaluated before resignaling the ones that gave errors 
	(giving the chance to clients to handle them)."

	| each answer |
	startIndex to: self size do: [:index |
		each := self at: index.
		[ answer := each value ]
			on: UnhandledError
			do: [:exc | 
				self valueStartingFrom: index + 1.
				exc pass]].
	^ answer! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/20/2024 16:53:35' prior: 16832933!
             selector: aSelector
	"Set a method's selector.  This is either the penultimate literal,
	 or, if the method has any properties or pragmas, the selector of
	 the MethodProperties stored in the penultimate literal."
	
	self 
		withPropertiesDo: [ :properties | properties selector: aSelector ] 
		ifSelector: [ :selector | | numberOfLiterals |
			(numberOfLiterals := self numLiterals) < 2 ifTrue: [self error: 'insufficient literals to hold selector'].
			self literalAt: numberOfLiterals - 1 put: aSelector]! !
!CompiledMethod methodsFor: 'printing' stamp: 'jmv 12/20/2024 16:54:39' prior: 16833428!
        symbolicLinesDo: aBlock
	"Evaluate aBlock with each of the lines in the symbolic output."

	| aStream pc |
	aStream := ReadWriteStream on: (String new: 64).
	self isQuick ifTrue:
		[self longPrintOn: aStream.
		 aBlock value: 0 value: aStream contents.
		 ^self].

	self primitive ~= 0 ifTrue:
		[self printPrimitiveOn: aStream.
		 aBlock value: 1 value: aStream contents.
		 aStream resetContents].

	pc := self initialPC.
	(InstructionPrinter on: self)
		indent: 0;
		printPC: false; "explorer provides pc anyway"
		printInstructionsOn: aStream
		do:	[:printer :scanner :stream| | line firstLine index |
			line := stream contents allButLast.
			firstLine := line lines first.
			firstLine size < line size ifTrue: [
				line := firstLine, '...'' (continues)'].
			(index := line indexOf: $>) > 0 ifTrue:
				[[(line at: index + 1) isSeparator] whileTrue: [index := index + 1].
				 line := ((line copyFrom: 1 to: index) copyReplaceAll: (String with: Character tab) with: (String new: 8 withAll: Character space)),
						(line copyFrom: index + 1 to: line size)].
			aBlock value: pc value: line.
			pc := scanner pc.
			stream resetContents]! !
!CompiledMethod class methodsFor: 'services' stamp: 'jmv 9/8/2023 17:26:55' prior: 16835350!
       remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true 	].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 						"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !
!RunArray methodsFor: 'enumerating' stamp: 'jmv 12/20/2024 16:57:27' prior: 16942665!
                 runsFrom: start to: stop do: aBlock
	"Evaluate aBlock with all existing runs in the range from start to stop"
	start > stop ifTrue:[^self].
	self at: start setRunOffsetAndValue: [ :firstRun :offset :firstValue|
		| run value index |
		run := firstRun.
		value := firstValue.
		index := start + (runs at: run) - offset.
		[aBlock value: value.
		index <= stop] whileTrue:[
			run := run + 1.
			value := values at: run.
			index := index + (runs at: run)]].
! !
!Set class methodsFor: 'initialization' stamp: 'jmv 12/20/2024 16:58:24' prior: 16950729!
                         quickRehashAllSets  "Set rehashAllSets"
	self withAllSubclassesDo:
		[:c |
			| insts |
			insts := c allInstances.
			(insts isEmpty or: [c = MethodDictionary]) ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock | 1 to: insts size do: [:x | barBlock value: x. (insts at: x) rehash]]]]! !
!Set class methodsFor: 'initialization' stamp: 'jmv 12/20/2024 16:58:13' prior: 16950744!
            rehashAllSets  "Set rehashAllSets"
	self withAllSubclassesDo:
		[:c |
			| insts |
			insts := c allInstances.
			insts isEmpty ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock |
				1 to: insts size do:
					[ :x | barBlock value: x.
					(insts at: x) rehash]]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6941-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h50m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 5:04:02 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 16928604!
                      untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:51' prior: 16928625!
   upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream | | element |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 16928685!
                           upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 16928867!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 16929037!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6942-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6942] on 20 December 2024 at 5:34:45 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/20/2024 17:33:07' prior: 50338168!
               untilAnySatisfying: aBlock
1 print.
	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 10/25/2021 11:18:50' prior: 50338177!
                           upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition element answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/20/2024 17:33:18' prior: 50338214!
                               upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
3 print.
	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:33:24' prior: 50338235!
   backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
4 print.
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:33:30' prior: 50338273!
nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
5 print.
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6943-FixNeverendingTestInCI-testUpToTerminator6TerminatedLongRecords-JuanVuletich-2024Dec20-17h33m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6895] on 22 December 2024 at 7:24:31 pm'!
!CompiledMethod commentStamp: 'eem 12/22/2024 19:23:15' prior: 16832642!
                  My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields. The pointer fields are used for literals and metadata, and the bytes are used for bytecodes and a variety of encoded informaton such as source code, source code position, etc.  The first part of a CompiledMethod object is pointers, the second part is bytes.  CompiledMethod inherits from ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is a ByteArray.

Instance variables: *indexed* (no named inst vars)

Class variables:
SmallFrame							- the number of stack slots in a small frame Context
LargeFrame							- the number of stack slots in a large frame Context
PrimaryBytecodeSetEncoderClass		- the encoder class that defines the primary instruction set
SecondaryBytecodeSetEncoderClass	- the encoder class that defines the secondary instruction set
	
TThe current format of a CompiledMethod is as follows:

	header (4 or 8 bytes, SmallInteger)
	literals (4 or 8 bytes each, Object, see "The last literal..." below)
	bytecodes  (variable, bytes)
	trailer (variable, bytes)

The header is a SmallInteger (which in the 32-bit system has 31 bits, and in the 64-bit system, 61 bits) in the following format:

	(index 0)		15 bits:	number of literals (#numLiterals)
	(index 15)		  1 bit:	jit without counters - reserved for methods that have been optimized by Sista
	(index 16)		  1 bit:	has primitive
	(index 17)		  1 bit:	whether a large frame size is needed (#frameSize => either SmallFrame or LargeFrame)
	(index 18)		  6 bits:	number of temporary variables (#numTemps)
	(index 24)		  4 bits:	number of arguments to the method (#numArgs)
	(index 28)		  2 bits:	reserved for an access modifier (00-unused, 01-private, 10-protected, 11-public), although accessors for bit 29 exist (see #flag).
	sign bit:			  1 bit:	selects the instruction set, >= 0 Primary, < 0 Secondary (#signFlag)

If the method has a primitive then the first bytecode of the method must be a callPrimitive: bytecode that encodes the primitive index.  This bytecode can encode a primitive index from 0 to 65535.

The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.

While there are disadvantages to this "flat" representation (it is impossible to add named instance variables to CompiledMethodor its subclasses, but it is possible indirectly; see AdditionalMethodState) it is effective for interpreters.  It means that both bytecodes and literals can be fetched directly from a single method object, and that only one object, the method, must be saved and restored on activation and return.  A more natural representation, in which there are searate instance variables for the bytecode, and (conveniently) the literals, requires either much more work on activation and return setting up references to the literals and bytecodes, or slower access to bytecodes and literals, indirecting on each access.

The last literal of a CompiledMethod is reserved for special use by the kernel and/or the virtual machine.  It must either be the methodClassAssociation, used to implement super sends, or nil, if the method is anonymous.

By convention, the penultimate literal is reserved for special use by the kernel. In CompiledMethod instances it must either be the method selector, or an instance of AdditionalMethodState which holds the selector and any pragmas or properties in the method.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6944-CompiledMethodComment-EliotMiranda-2024Dec22-19h23m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6942] on 23 December 2024 at 10:56:59 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 50338304!
                    untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 50338351!
   upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 50338372!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 50338410!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6945-6943-again-JuanVuletich-2024Dec23-10h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6945] on 23 December 2024 at 11:04:32 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/22/2022 21:13:39' prior: 50338584!
                           upToAny: aCollection 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
	| element prevPos |
	^self collectionSpecies streamContents: [ :strm |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6946-6943-tweak-JuanVuletich-2024Dec23-11h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6946] on 23 December 2024 at 11:11:28 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:18:25' prior: 50338575!
                  untilAnySatisfying: aBlock
	| c |
	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				c := self peek.
				(aBlock value: c) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/19/2022 11:57:58' prior: 50338605!
                 backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		prevCh := $$.
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/23/2022 17:47:39' prior: 50338643!
                          nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator ch done |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6947-Undo6942-JuanVuletich-2024Dec23-11h10m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6947] on 23 December 2024 at 3:20:03 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/23/2024 15:19:46' prior: 16964933!
  knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !
!Morph methodsFor: 'events-processing' stamp: 'JEC 12/23/2024 09:53:40' prior: 16905820!
         processDropMorph: aDropEvent
	"Handle a dropping morph."
	| aMorph |
	
	aDropEvent wasHandled ifTrue: [ ^self ]. "Do it just once, for one drop destination"
	
	aMorph := aDropEvent contents.
	aDropEvent wasHandled: true.
	aMorph justDroppedInto: self event: aDropEvent.
	self acceptDroppingMorph: aMorph event: aDropEvent.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6948-AddJoelAsKnownAuthor-JuanVuletich-2024Dec23-15h15m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6944] on 23 December 2024 at 10:24:59 am'!
!Morph methodsFor: 'events-processing' stamp: 'JEC 12/23/2024 09:53:40' prior: 50339034!
                           processDropMorph: aDropEvent
	"Handle a dropping morph."
	| aMorph |
	
	aDropEvent wasHandled ifTrue: [ ^self ]. "Do it just once, for one drop destination"
	
	aMorph := aDropEvent contents.
	aDropEvent wasHandled: true.
	aMorph justDroppedInto: self event: aDropEvent.
	self acceptDroppingMorph: aMorph event: aDropEvent.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6949-DropMethodOnNoCategoryFix-JoelEstebanCamera-2024Dec23-09h53m-JEC.001.cs.st----!

'From Cuis7.3 [latest update: #6949] on 24 December 2024 at 10:34:31 am'!
!CodeWindow methodsFor: 'misc' stamp: 'eem 12/24/2024 10:33:48' prior: 16827299!
                         getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs
	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"

	| strm array |
	strm := WriteStream on: (array := Array new: queryArgs size + 1).
	strm nextPut: nil.
	strm nextPutAll: queryArgs.

	model selectedMessageName
		ifNotNil:
			[:messageName|
			querySelector numArgs = 1 ifTrue:
				[Symbol
					hasInterned: messageName
					ifTrue:
						[:messageSymbol|
						^queryPerformer perform: querySelector with: messageSymbol]]]
		ifNil:
			[ | selector |
			selector := self request: 'Type selector:' initialAnswer: 'flag:'.
			^ selector isEmpty ifFalse: [
				(Symbol hasInterned: selector
					ifTrue: [ :aSymbol |
						array at: 1 put: aSymbol.
						queryPerformer perform: querySelector withArguments: array])
					ifFalse: [ self inform: 'no such selector']
			]
		].

	self selectMessageAndEvaluate: [:selector |
		array at: 1 put: selector.
		queryPerformer perform: querySelector withArguments: array
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6950-HaveMessageNamesFindSymbolReferences-EliotMiranda-2024Dec24-10h21m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 5:04:02 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 50338703!
          untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:51' prior: 50338314!
   upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream | | element |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 50338674!
                           upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 50338713!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 50338752!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6951-6942-AGAIN-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6951] on 27 December 2024 at 9:59:33 am'!
!CompiledMethod methodsFor: 'source code management' stamp: 'eem 12/27/2024 09:55:57' prior: 16834012!
                           messageSendsCount
	"Number of message sends in code.
	A measure of the complexity of code. Alternative to #linesOfCode"

	| count scanner |
	count := 0.
	scanner := InstructionStream on: self.
	scanner scanFor:
		[:x | | selectorOrSelf |
		(selectorOrSelf := scanner selectorToSendOrSelf) == scanner ifFalse:
			[count := count + 1].
		false	"keep scanning"].
	^count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6952-muchFaster-messageSendsCount-EliotEmilioMiranda-2024Dec27-09h55m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6952] on 27 December 2024 at 10:12:34 am'!
!Delay methodsFor: 'private' stamp: 'jmv 12/27/2024 10:11:02' prior: 16846848!
            setDelay: millisecondCount 
	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."

	delayDuration := millisecondCount asInteger! !
!Delay methodsFor: 'private' stamp: 'jmv 12/27/2024 10:11:39' prior: 16846856!
                           setDelay: millisecondCount forSemaphore: aSemaphore
	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."

	delayDuration := millisecondCount asInteger.
	delaySemaphore := aSemaphore.
	beingWaitedOn := false.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6953-delayDuration-mustBeAnInteger-JuanVuletich-2024Dec27-10h08m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6953] on 27 December 2024 at 10:58:19 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/27/2024 10:57:47' prior: 50338782!
            knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6954-AddWeslleymbergAsKnownContributor-JuanVuletich-2024Dec27-10h57m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6947] on 23 December 2024 at 6:47:53 pm'!
!EphemeronFinalizationProcess class methodsFor: 'system startup' stamp: 'wbsl 12/23/2024 18:10:14' prior: 50334424 overrides: 16789354!
   startUp: resuming
	"resuming ifFalse: [ ^self ]."
	"Must restart even if just continuing after a snapshot"
	self restartFinalizationProcess! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6955-EphemeronProcessRestart-afterSnapshot-WeslleymbergLisboa-2024Dec23-12h24m-wbsl.001.cs.st----!

'From Cuis7.3 [latest update: #6955] on 27 December 2024 at 11:28:57 am'!
!Morph methodsFor: 'geometry testing' stamp: 'RMV 12/27/2024 11:28:39' prior: 16906827!
                             clipsSubmorphsReally
	"Currently only one level of clipping is supported.
	This means that if a morph clipsSubmorphs, then no submorph in its tree can do it.
	This is a current limitation of VectorCanvas"

	self clipsSubmorphs ifFalse: [ ^false ].
	self allOwnersDo: [ :o | o clipsSubmorphs ifTrue: [ ^false ]].
	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6956-typoFix-R.MarkVolkmann-2024Dec27-11h28m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #6950] on 27 December 2024 at 8:51:10 am'!
!CodeWindow methodsFor: 'misc' stamp: 'len 5/20/2020 08:09:08' prior: 50339078!
                      getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs
	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"

	| strm array |
	strm := WriteStream on: (array := Array new: queryArgs size + 1).
	strm nextPut: nil.
	strm nextPutAll: queryArgs.

	model selectedMessageName ifNil: [ | selector |
		selector := self request: 'Type selector:' initialAnswer: 'flag:'.
		^ selector isEmpty ifFalse: [
			(Symbol hasInterned: selector
				ifTrue: [ :aSymbol |
					array at: 1 put: aSymbol.
					queryPerformer perform: querySelector withArguments: array])
				ifFalse: [ self inform: 'no such selector']
		]
	].

	self selectMessageAndEvaluate: [:selector |
		array at: 1 put: selector.
		queryPerformer perform: querySelector withArguments: array
	]! !
!CodeWindow methodsFor: 'misc' stamp: 'jmv 12/27/2024 08:50:01' prior: 16827332!
             selectMessageAndEvaluate: aBlock
	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"

	| selector method messages |
	(selector := model selectedMessageName) ifNil: [^ self].
	method := (model selectedClassOrMetaClass ifNil: [^ aBlock value: selector])
		compiledMethodAt: selector
		ifAbsent: nil.
	(method isNil or: [(messages := method messages) isEmpty])
		 ifTrue: [^ aBlock value: selector].
	(messages size = 1 and: [messages includes: selector])
		ifTrue:
			[^ aBlock value: selector].  "If only one item, there is no choice"

	Smalltalk
		showMenuOf: messages
		withFirstItem: selector
		ifChosenDo: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6957-Better-6950-WorkWithOrWithoutRealMethod-JuanVuletich-2024Dec27-08h36m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6957] on 30 December 2024 at 1:04:30 pm'!
!MethodSet methodsFor: 'testing' stamp: 'jmv 12/30/2024 13:04:04' prior: 16902849 overrides: 16826346!
                            isEditingMethod

	^selectedMessage notNil and: [ selectedMessage selector ~~ #Comment ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6958-isEditingMethod-fix-JuanVuletich-2024Dec30-13h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6957] on 30 December 2024 at 1:06:16 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'hlsf 12/30/2024 12:55:18'!
                       browseMethodsWithSourceString: aString in: aPackage
	" Browse all methods in aPackage whose source code contains aString as a substring."

	| matchingMethods |
	matchingMethods := Set new.
	aPackage classesDo: [ :aPackageClass |
		(aPackageClass organization classComment
			findString: aString
			startingAt: 1
			caseSensitive: false) > 0 ifTrue: [
				matchingMethods add: (MethodReference class: aPackageClass selector: #Comment) ]].
	aPackage methods do: [ :methodReference |
		(methodReference sourceCode 
			findString: aString
			startingAt: 1
			caseSensitive: false) > 0 ifTrue: [
				matchingMethods add: methodReference ]].
		
	^ self 
		browseMessageList: matchingMethods asArray sort
		name: 'Methods containing ' , aString printString, ' in package: ', aPackage packageName
		autoHighlight: aString
		allOccurrences: true.! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'hlsf 12/30/2024 12:57:55' prior: 16956254!
                findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |
	
	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self codeProvider selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6959-findWithScope-PackageScope-HilaireFernandes-2024Dec30-13h04m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #6959] on 30 December 2024 at 9:56:55 pm'!
!CodeProvider methodsFor: 'testing' stamp: 'jmv 12/30/2024 21:54:06'!
                  isEditingExistingMethod

	^self isEditingMethod! !
!Browser methodsFor: 'testing' stamp: 'jmv 12/30/2024 21:54:13' overrides: 50339811!
                        isEditingExistingMethod

	^editSelection = #editMessage! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/30/2024 21:56:51' prior: 50339737!
                               findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |
	
	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self codeProvider selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingExistingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6960-FindWithScope-fix-HernanWilkinson-2024Dec30-21h54m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6960] on 31 December 2024 at 7:01:56 pm'!
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 19:00:05' prior: 16799999!
                       classListMenuSpec
	"Spec for the menu and shortcut keys for the class list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Class List' 					false)
		#(10	'New Subclass' 				nil 	model 		makeNewSubclass 					classIcon 		'put a template into the code pane for defining of a subclass of this class')
		#(20	'Copy Class...' 				nil 	model 		copyClass 							copyIcon)
		#(30	'Delete (x)' 					$x 	model 		removeClass 						deleteIcon)
		#(40 	'-----')
		#(50	'Browse Hierarchy (h)' 		$h 	window 	browseHierarchy 					goTopIcon)
		#(60	'Full Browse (b)' 				$b 	window 	browseMethodFull 					editFindReplaceIcon)
		#(70	'Browse Protocol (p)' 			$p 	window 	browseFullProtocol 				spreadsheetIcon)
		#(80	'Browse Package' 			nil 	window 	browsePackage 					packageIcon)
		#(90 	'-----')
		#(100	'File Out' 					nil 	model 		fileOutClass 						fileOutIcon)
		#(110	'File Out (alphabetically)' 		nil 	model 		fileOutClassAlphabetically 			fileOutIcon)
		#(120	'Run Tests (t)' 				$t 	model 		runClassTests 						weatherFewCloudsIcon)
		#(130 	'-----')
		#(140	'Refactorings' 				nil 	nil 			1000 								listAddIcon)
		#(150 	'-----')
		#(160	'Show classes Hierarchically' 	nil model 		enableListClassesHierarchically 	goTopIcon)
		#(170	'Show classes Alphabetically' 	nil model 		enableListClassesAlphabetically 	sendReceiveIcon)
		#(180	'Show Definition' 				nil 	model 		editClass 							editFindReplaceIcon)
		#(190	'Show Comment' 			nil 	model 		editComment 						editFindReplaceIcon)
		#(200 	'-----')
		#(210	'Class References (N)' 		$N 	window 	browseClassRefs 					classIcon)
		#(220 	'-----')
		#(230	'More...' 					nil 	nil 			2000 								listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 							$r 	model 		recent)

		" 'refactorings' SubMenu"
		#(1010	'Rename Class... (R)' 			$R 	model 		renameClass 						saveAsIcon)
		#(1020	'Insert Superclass...' 			nil 	model 		insertSuperclass 					saveAsIcon)
		#(1030 	'-----')
		#(1040	'Add Inst Var...' 				nil 	model 		addInstVar 							listAddIcon)
		#(1050	'Rename Inst Var...' 			nil 	model 		renameInstVar 						saveAsIcon)
		#(1060	'Remove Inst Var...' 			nil 	model 		removeInstVar 						deleteIcon)
		#(1070	'Remove all Unreferenced Inst Var...' nil model 	removeAllUnreferencedInstVar 	deleteIcon)
		#(1080	'Push Up Inst Var...' 			nil 	model 		pushUpInstanceVariable 			goTopIcon)
		#(1090	'Push Down Inst Var...' 		nil 	model 		pushDownInstanceVariable 		goBottomIcon)
		#(1100 	'-----')
		#(1110	'Rename Global...' 			nil 	model 		renameGlobal 						saveAsIcon)

		" 'more' SubMenu"
		#(2010	'Unsent Methods' 			nil 	window 	browseUnusedMethods 			junkIcon 			'browse all methods defined by this class that have no senders')
		#(2020	'Unreferenced inst Vars' 		nil 	window 	showUnreferencedInstVars 		junkIcon 			'show a list of all instance variables that are not referenced in methods')
		#(2030	'Unreferenced class Vars' 		nil 	window 	showUnreferencedClassVars 		junkIcon 			'show a list of all class variables that are not referenced in methods')
		#(2040 	'-----')
		#(2050	'Sample instance' 			nil 	window 	makeSampleInstance 				instanceIcon 		'give me a sample instance of this class, if possible')
		#(2060	'Inspect instances' 			nil 	window 	inspectInstances 					inspectIcon 		'open an inspector on all the extant instances of this class')
		#(2070	'Inspect subinstances' 		nil 	window 	inspectSubInstances 				inspectIcon 		'open an inspector on all the extant instances of this class and of all of its subclasses')
		#(2080 	'-----')
		#(2090	'Create inst var accessors' 	nil 	model 		createInstVarAccessors 			sendReceiveIcon 	'compile instance-variable access methods for any instance variables that do not yet have them')
	)! !
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 18:52:17' prior: 16800118!
                    messageCatListMenuSpec
	"Spec for the menu and shortcut keys for the method categories list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message Categories' 			false)
		#(5		'Browse Package (p)' 				$p 	window 	browsePackage 						packageIcon)
		#(6		'-----')
		#(10	'File Out (o)' 						$o 	model 		fileOutMessageCategories 				fileOutIcon)
		#(20 	'-----')
		#(30	'Reorganize (r)' 					$r 	model 		editMessageCategories 				sendReceiveIcon)
		#(40	'Alphabetize (a)' 					$a 	model 		alphabetizeMessageCategories 		fontXGenericIcon)
		#(50	'Remove empty Categories (e)' 	$e 	model 		removeEmptyCategories 				listRemoveIcon)
		#(60	'Categorize all Uncategorized (c)' 	$c 	model 		categorizeAllUncategorizedMethods 	packageIcon)
		#(70	'New Category... (n)' 				$n 	model 		addCategory 							newIcon)
		#(80	'New extension Category... (N)' 	$N 	model 		addExtensionCategory 					listAddIcon)
		#(90 	'-----')
		#(100	'Refactorings' 					nil 	nil 			1000 									listAddIcon)
		#(110	'Rename... (R)' 					$R 	model 		renameCategory 						saveAsIcon)
		#(120	'Remove (x)' 					$x 	model 		removeMessageCategory 				deleteIcon)
		#(130 	'-----')
		#(140	'Run Tests (t)' 					$t 	model 		runMessageCategoryTests 			weatherFewCloudsIcon)

		" 'Refactorings' SubMenu"
		#(1010	'Push Up' 									nil 	model 	pushUpCategorySelectors 							goTopIcon)
		#(1020	'Add in Superclass as subclassResponsibility' 	nil	model 	addCategoryAsSubclassResponsibilitySelectors 	goTopIcon)
		#(1030	'Push Down to Subclasses' 					nil 	model 	pushDownCategorySelectorsToSubclasses 		goBottomIcon)
		#(1040	'Push Down to one Subclass' 					nil 	model 	pushDownCategorySelectorsToOneSubclass 		goBottomIcon)
	)! !
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 19:00:12' prior: 16800174!
                           messageListMenuSpec
	"Spec for the menu and shortcut keys for the messages list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message List' 						false)
		#(10	'Browse Full (b)' 							$b 	window 	browseMethodFull 							editFindReplaceIcon)
		#(20	'Browse Hierarchy (h)' 					$h 	window 	browseHierarchy 							goTopIcon)
		#(30	'Browse Method (O)' 						$O 	window 	openSingleMessageBrowser 				scriptIcon)
		#(35	'Browse Package (p)' 						$p 	window 	browsePackage 							packageIcon)
		#(40 	'-----')
		#(50	'File Out' 								nil 	model 		fileOutMessage 							fileOutIcon)
		#(60	'Run Test (t)' 							$t 	model 		runMethodTest 							weatherFewCloudsIcon)
		#(70	'Debug Test (r)' 							$r 	model 		debugMethodTest 							weatherFewCloudsIcon)
		#(80	'Inspect CompiledMethod' 				nil 	model 		inspectCompiledMethod 					exploreIcon)
		#(90 	'-----')
		#(100	'Refactorings' 							nil 	nil 			1000 										listAddIcon)
		#(110	'Senders of... (n)' 						nil 	window 	browseSendersOfMessages 				mailForwardIcon)
		#(120	'Implementors of... (m)' 					nil 	window 	browseImplementorsOfMessages 			developmentIcon)
		#(130	'Inheritance (i)' 							$i 	window 	methodInheritance 						goDownIcon)
		#(140	'Versions (v)' 							$v 	window 	browseVersions 							clockIcon)
		#(150 	'-----')
		#(160	'Remove Method (x)' 						$x 	model 		removeMessage 							deleteIcon)
		#(170	'Remove Method in Hierarchy' 			nil 	model 		removeMessageInHierarchy 				deleteIcon)
		#(180	'More...' 								nil 	nil 			2000 										listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 										$m 	window 	browseImplementors)
		#(992	nil 										$n 	window 	browseSenders)
		#(993	nil 										$c 	model 		copySelector)

		" 'refactorings' SubMenu"
		#(1010	'Rename... (R)' 							$R 	model 		renameSelector 							saveAsIcon)
		#(1020	'Change keyword Order...' 				nil 	model 		changeKeywordOrder 						sendReceiveIcon)
		#(1030	'Add Parameter... (A)' 					$A 	model 		addParameter 								listAddIcon)
		#(1040	'Remove Parameter... (S)' 				$S 	model 		removeParameter 							listRemoveIcon)
		#(1050 	'-----')
		#(1060	'Inline Method... (F)' 						$F 	model 		inlineMethod 								saveAsIcon)
		#(1070	'Move to Instance/Class Method' 			nil 	model 		moveToInstanceOrClassMethod 			changesIcon)
		#(1080	'Push Up' 								nil 	model 		pushUpSelector 							goTopIcon)
		#(1090	'Add in Superclass as subclassResponsibility' nil model 		addAsSubclassResponsibilitySelector 		goTopIcon)
		#(1100	'Push Down to Subclasses' 				nil 	model 		pushDownSelectorToSubclasses 			goBottomIcon)
		#(1110	'Push Down to One Subclass' 				nil 	model 		pushDownSelectorToOneSubclass 			goBottomIcon)

		" 'more' SubMenu"
		#(2010	'Local Senders of...' 						nil 	window 	browseLocalSendersOfMessages 			mailForwardIcon)
		#(2020	'Local Implementors of...' 					nil 	window 	browseLocalImplementorsOfMessages 	classIcon)
		#(2030 	'-----')
		#(2040	'Sample Instance' 						nil 	window 	makeSampleInstance 						instanceIcon)
		#(2050	'Inspect Instances' 						nil 	window 	inspectInstances 							inspectIcon)
		#(2060	'Inspect Subinstances' 					nil 	window 	inspectSubInstances 						inspectIcon)
		#(2070 	'-----')
		#(2080	'Change Category...' 						nil 	model 		changeCategory 							saveAsIcon)
		#(2090	'Select method Category (C)' 				$C 	model 		showHomeCategory 						editFindReplaceIcon)
		#(2100	'Change sets with this Method' 			nil 	window 	findMethodInChangeSets 					changesIcon)
		#(2110	'Revert to previous Version' 				nil 	model 		revertToPreviousVersion 					undoIcon)
	)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6961-MenuCaseConsistency-HernanWilkinson-2024Dec31-18h44m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6961] on 1 January 2025 at 10:28:41 am'!
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 1/1/2025 10:27:43' prior: 16971764!
                            copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak project. 1997-2025.
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2025.'.! !
!Utilities class methodsFor: 'default desktop' stamp: 'jmv 1/1/2025 10:28:19' prior: 16997398!
 defaultTextEditorContents
	^ ('
', 
('Cuis Smalltalk

' centered blue pointSize: FontFamily defaultPointSize * 3),
('
"Yay, Juan.  You GO, guy!! ...a great example of malleable software (and a clever mind) at work."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Dan Ingalls
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I like it... It''s nice and clean and simple and pretty. Nice stuff!!"
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Alan Kay
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I think you have a very elegant design aesthetic."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('John Maloney
'italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
'

',
'Cuis is a modern, Open Source, multiplatform, Smalltalk-80 system.


',
'Cuis is:

' bold,
'    - Small
    - Clean
    - Appropriable
' blue,
'

Additionally, Cuis is:

' bold, 
'    - Open Source
    - Multiplatform
' blue,
'
 
Like other Smalltalk systems, Cuis is also:

' bold, 
'    - A complete development environment written in itself
    - A pure, dynamic Object Oriented language
' blue,
'

Cuis assumes very little on the underlying platform, and this lets it run out-of-the-box on Windows, macOS, Linux, ChromeOS and WebBrowsers. Cuis shares the [OpenSmalltalk Virtual Machine] (http://www.opensmalltalk.org) with Squeak, Pharo and Newspeak.

What sets Cuis apart from the other members of the Squeak family is the focus on Smalltalk-80 and an active attitude towards system complexity:

Unbound complexity growth, together with development strategies focused only in the short term, are the worst long term enemies of all software systems. As systems grow older, they usually become more complex. New features are added as layers on top of whatever is below, sometimes without really understanding it, and almost always without modifying it. Complexity and size grow without control. Evolution slows down. Understanding the system becomes harder every day. Bugs are harder to fix. Codebases become huge for no clear reason. At some point, the system can''t evolve anymore and becomes "legacy code".

Complexity puts a limit to the level of understanding of the system a person might reach, and therefore limits the things that can be done with it. Dan Ingalls says all this in ["Design Principles Behind Smalltalk"] (http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html). Even if you have already done so, please go and read it again!!

Cuis Smalltalk is our attempt at this challenge. Furthermore, we believe we are doing something else that no other Smalltalk, commercial or open source, does. We attempt to give the true Smalltalk-80 experience, and keep Smalltalk-80 not as legacy software of historic significance, but as a live, evolving system. We feel we are the keepers of the Smalltalk-80 heritage, and enablers of the Dynabook experience.

As Cuis evolves, we keep on these values. Every update, be it a bug fix or a feature enhancement, is reviewed carefully to avoid adding unneeded complexity to the system. Every opportunity to remove unneeded complexity is followed. As we go, features are enhanced, and any reported bugs fixed. We also adopt selected enhancements from Squeak and Pharo, and share our work with the wider Smalltalk community.


' justified,
'License
' bold,
'
Cuis is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . Any contribution submitted for incorporation into or for distribution with Cuis shall be presumed subject to the same license.

Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982
Copyright (c) Apple Computer, Inc. 1985-1996
Copyright (c) Contributors to Squeak project. 1997-2025
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2025')! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6962-UpdateCopyrightNotice-JuanVuletich-2025Jan01-10h27m-jmv.001.cs.st----!

----QUIT----(2 January 2025 10:24:06) Cuis7.3-6962-32.image priorSource: 209!

----STARTUP---- (17 January 2025 10:30:57) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\Cuis7.3-6962-32.image!


'From Cuis7.3 [latest update: #6962] on 2 January 2025 at 4:01:10 pm'!

Random subclass: #XorShiftRandom
	instanceVariableNames: 'a b c mask last'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!classDefinition: #XorShiftRandom category: #'Kernel-Numbers' stamp: 'Install-6963-XorShiftRandom-JuanVuletich-2025Jan02-16h00m-jmv.001.cs.st 1/17/2025 10:30:57'!
Random subclass: #XorShiftRandom
	instanceVariableNames: 'a b c mask last'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!
!XorShiftRandom commentStamp: '<historical>' prior: 0!
  I implement XorShift pseudo random number generators invented by George Marsaglia.
See https://en.wikipedia.org/wiki/Xorshift . Paper at https://www.jstatsoft.org/article/view/v008i14/916
Most implementations hardcode the a, b, c parameters, and work either on 32 or 64 bit space.
This one allows chosing them. Still, a and c are right shifts and b is a left shift.!
!XorShiftRandom methodsFor: 'accessing' stamp: 'jmv 1/2/2025 14:51:42'!
         nextInteger
	last := last bitXor: (last bitShift: a).
	last := last bitXor: ((last bitShift: b) bitAnd: mask).
	last := last bitXor: (last bitShift: c).
	^last! !
!XorShiftRandom methodsFor: 'initialization' stamp: 'jmv 1/2/2025 14:58:45'!
                a: firstShift b: secondShift c: thirdShift bits: bitsSize

	(firstShift < 0 and: [ secondShift > 0 and: [ thirdShift < 0 ]]) ifFalse: [
		self error: 'Invalid XorShift parameters' ].

	a := firstShift.
	b := secondShift.
	c := thirdShift.
	mask := (2 raisedToInteger: bitsSize) - 1.
	last := 1 bitAnd: mask. "If any other value is used, ensure it is not larger than mask"! !
!XorShiftRandom methodsFor: 'initialization' stamp: 'jmv 1/2/2025 14:58:05' overrides: 16936573!
        seed: aNumber
	last := aNumber.
	mask ifNotNil: [ last := last bitAnd: mask ].! !
!XorShiftRandom methodsFor: 'private' stamp: 'jmv 1/2/2025 15:48:40' overrides: 16936565!
                    nextChunkBits
	^self nextInteger! !
!XorShiftRandom methodsFor: 'private' stamp: 'jmv 1/2/2025 15:49:55' overrides: 16936569!
  nextChunkSize
	^(mask + 1) log2! !
!XorShiftRandom class methodsFor: 'instance creation' stamp: 'jmv 1/2/2025 15:45:18'!
       a: firstShift b: secondShift c: thirdShift bits: bitsSize
	^self basicNew a: firstShift b: secondShift c: thirdShift bits: bitsSize! !
!XorShiftRandom class methodsFor: 'instance creation' stamp: 'jmv 1/2/2025 15:51:58' overrides: 16936587!
               seed: anInteger
	| answer |
	answer := self a: -2 b: 7 c: -3 bits: 22.
	answer seed: anInteger.
	^answer! !
!XorShiftRandom class methodsFor: 'visualizations' stamp: 'jmv 1/2/2025 15:01:01'!
 display22BitsBlackWhite
	"
	self display22BitsBlackWhite
	"
	| bits f generator h w |
	generator := XorShiftRandom a: -2 b: 7 c: -3 bits: 22.
	w := 2048.
	h := 2048.
	bits := ByteArray new: w*h // 8.
	f := Form extent: w@h depth: 1 bits: bits.
	bits atAllPut: 0.
	(2 raisedTo: 22)-1 timesRepeat: [
		bits bitAt: generator nextInteger put: 1.
		Random next > 0.9999 ifTrue: [
			f display. Display forceToScreen ]].
	f display. Display forceToScreen.! !
!XorShiftRandom class methodsFor: 'visualizations' stamp: 'jmv 1/2/2025 15:02:23'!
        display22BitsColor
	"
	self display22BitsColor
	"
	| bits f generator h w |
	generator := XorShiftRandom a: -2 b: 7 c: -3 bits: 22.
	w := 512.
	h := 512.
	bits := ByteArray new: w*h *16 // 8.
	f := Form extent: w@h depth: 16 bits: bits.
	f fillColor: Color black.
	(2 raisedTo: 22)-1 timesRepeat: [
		bits bitAt: generator nextInteger put: 1.
		Random next > 0.9999 ifTrue: [
			f display. Display forceToScreen ]].
	f display. Display forceToScreen.! !
!XorShiftRandom class methodsFor: 'parameter search' stamp: 'jmv 1/2/2025 15:07:58'!
     lookFor22BitCandidateParameters
	"XorShift pseudo Random Number Generator. See https://en.wikipedia.org/wiki/Xorshift
	IdentityHash is a 22 bit number. It is easy to find documented parameters for XorShift covering the whole 32 and 64 bit spaces.
	1. But we need to cover the 22 bit space. The following script lists a set of such parameters.
	Explore parameter space to find (a, b, c) parameters that generate all possible hashes (implying a period = hashMask).
	self lookFor22BitCandidateParameters
	"
	| generator value differentValues expectedDifferentValues |
	expectedDifferentValues := (2 raisedTo: 22) - 1.
	-9 to: -1 do: [ :a |
		1 to: 8 do: [ :b |
			-7 to: -1 do: [ :c |
				generator := XorShiftRandom a: a b: b c: c bits: 22.
				differentValues := Set new.
				[
					value := generator nextInteger.
					differentValues includes: value ]
				whileFalse: [
					differentValues add: value ].
				differentValues size = expectedDifferentValues ifTrue: [
					{a. b. c} print ]]]].! !
!XorShiftRandom class methodsFor: 'parameter search' stamp: 'jmv 1/2/2025 15:39:29'!
      pickBest22BitHashParameters
	"When using this RNG for generating hashes, the next problem we face is that generally we'll not be using the full hash.
	For smaller collections, only the rest of the division by the collection size is actually used.
	For each of the candidates found in #lookFor22BitCandidateParameters, try the rest of the division by 2^k (i.e. take AND with a smaller 'evaluatedMask' and see how many distinct hashes of this size can be generated.
	List those than yield at least half of the full k bits space.
	self pickBest22BitHashParameters
	"
	| candidates |
	candidates := {
		#(-9 5 -7).
		#(-9 5 -3).
		#(-7 7 -3).
		#(-5 3 -2).
		#(-3 7 -7).
		#(-3 7 -2).
		#(-2 3 -5).
		#(-2 7 -3).
	}.
	candidates do: [ :abc |
		| fractions |
		fractions := OrderedCollection new.
		1 to: 21 do: [ :usedMaskSize |
				| evaluatedMask generator hash hashes |
				evaluatedMask := (2 raisedTo: usedMaskSize) - 1.
				generator := XorShiftRandom a: abc first b: abc second c: abc third bits: 22.
				hashes := Set new.
				evaluatedMask timesRepeat: [
					hash := generator nextInteger bitAnd: evaluatedMask.
					hashes add: hash ].
				fractions add: (hashes size / evaluatedMask asFloat) ].
			(fractions min > 0.5 ) ifTrue: [
				{abc. fractions min. fractions average} print ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6963-XorShiftRandom-JuanVuletich-2025Jan02-16h00m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:22:57 pm'!
!WorldMorph methodsFor: 'canvas' stamp: 'jmv 1/3/2025 16:22:52' prior: 17008987!
    recordDamagedRect: damageRect for: aMorph

	damageRect hasPositiveExtent ifFalse: [ ^self ].

	damageRecorder ifNotNil: [
		damageRecorder recordInvalidRect: damageRect for: aMorph ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6964-recordDamageRect-tweak-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:40:41 pm'!
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:39:08' overrides: 16906216!
         extentChanged: oldExtent
	"Our extent changed.
	- Reposition adjusters
	- Resize our layoutMorph"

	| h thickness w cornerExtent wh ww pos halfThickness |
	thickness := self borderWidth.
	halfThickness := thickness * 0.5.
	cornerExtent := thickness * 5.
	ww := extent x.
	wh := extent y.
	w := ww - cornerExtent - cornerExtent.
	h := wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) position: cornerExtent@halfThickness extent: w@0.
	(adjusters at: #bottomAdjuster) position: cornerExtent@(wh-halfThickness) extent: w@0.
	(adjusters at: #leftAdjuster) position: halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #rightAdjuster) position: ww-halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #topLeftAdjuster) position: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) position: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) position: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) position: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos := borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			position: pos
			extent: extent - pos - borderWidth ].! !

SystemWindow removeSelector: #layoutSubmorphs!

!methodRemoval: SystemWindow #layoutSubmorphs stamp: 'Install-6965-SystemWindows-dontLayoutButAdjustOnExtentChange-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st 1/17/2025 10:30:57'!
layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww pos halfThickness |
	thickness := self borderWidth.
	halfThickness := thickness * 0.5.
	cornerExtent := thickness * 5.
	ww := extent x.
	wh := extent y.
	w := ww - cornerExtent - cornerExtent.
	h := wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) position: cornerExtent@halfThickness extent: w@0.
	(adjusters at: #bottomAdjuster) position: cornerExtent@(wh-halfThickness) extent: w@0.
	(adjusters at: #leftAdjuster) position: halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #rightAdjuster) position: ww-halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #topLeftAdjuster) position: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) position: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) position: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) position: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos := borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			position: pos
			extent: extent - pos - borderWidth ].

	self layoutNeeded: false.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6965-SystemWindows-dontLayoutButAdjustOnExtentChange-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:53:24 pm'!
!BoxMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:50:57' overrides: 16906216!
                             extentChanged: oldExtent
	"Our extent changed. oldExtent is provided in case it is useful."! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:49:14' overrides: 50340663!
         extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:42:25' overrides: 16907322!
                               layoutSubmorphsIfNeeded
	"Recompute the layout if necessary."

	self isLayoutNeeded ifTrue: [
		self layoutSubmorphs ].! !
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:42:37' prior: 16907322!
                         layoutSubmorphsIfNeeded
	"Recompute the layout if necessary.
	NOP by default"! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:51:11' prior: 16924804 overrides: 50340663!
                              extentChanged: oldExtent
	"Our extent changed."

	super extentChanged: oldExtent.
	icon ifNotNil: [
		magnifiedIcon := nil ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:51:49' prior: 16923048 overrides: 50340663!
                       extentChanged: oldExtent
	"Our extent changed."

	super extentChanged: oldExtent.
	self buildMagnifiedBackgroundImage.! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 1/3/2025 16:46:43' prior: 16892709!
                    updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			owningLayout layoutSubmorphs ].! !

Morph removeSelector: #extentChanged:!

!methodRemoval: Morph #extentChanged: stamp: 'Install-6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st 1/17/2025 10:30:57'!
extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.!

Morph removeSelector: #layoutSubmorphs!

!methodRemoval: Morph #layoutSubmorphs stamp: 'Install-6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st 1/17/2025 10:30:57'!
layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."
	"Only specific subclasses do layout. They redefine this method.
	Remember to call super, or set layoutNeeded ivar to false!!"

	self layoutNeeded: false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 5:01:41 pm'!
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:55:32' overrides: 16907368!
                 someSubmorphPositionOrExtentChanged
	"Some submorph changed at any nested level.
	Must layout submorphs again."

	super someSubmorphPositionOrExtentChanged.
	self layoutNeeded: true.! !
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:55:41' prior: 16907368!
                          someSubmorphPositionOrExtentChanged
	"Some submorph changed at any nested level."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 1/3/2025 17:00:00' prior: 16891319!
                        layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: [].
	
	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ].

	self layoutNeeded: false.! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:57:10' prior: 16874978 overrides: 16926593!
                      someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self updateScrollBarsBounds! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:57:29' prior: 16925354 overrides: 16926593!
      someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self updateScrollBarsBounds! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6967-OnlyLayoutMorphDoLayout-JuanVuletich-2025Jan03-16h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 5:11:13 pm'!
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 17:11:04' prior: 50340756!
     someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Some Morph classes need to adjust for that."! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:19' prior: 50340747 overrides: 50340809!
                       someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	self layoutNeeded: true.! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:24' prior: 16926593 overrides: 50340809!
   someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	scroller ifNotNil: [ | scrollerLocation doIt |
		doIt := false.
		scroller hasVariableExtent ifTrue: [
			theScrollerExtent = scroller extentInOwner ifFalse: [
				theScrollerExtent := scroller extentInOwner.
				doIt := true ]].
		scrollerLocation := scroller location.
		scrollerScale = scrollerLocation scale ifFalse: [
			scrollerScale := scrollerLocation scale.
			doIt := true ].
		scrollerRadians = scrollerLocation radians ifFalse: [
			scrollerRadians := scrollerLocation radians.
			doIt := true ].
		doIt ifTrue: [ self setScrollDeltas ]].! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:28' prior: 50340782 overrides: 50340825!
                   someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Scrollbars are likely affected."

	self updateScrollBarsBounds! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:33' prior: 50340792 overrides: 50340825!
                              someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Scrollbars are likely affected."

	self updateScrollBarsBounds! !
!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 1/3/2025 17:09:38' prior: 16882626 overrides: 50340809!
                             someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	textComposition ifNotNil: [ 
		textComposition composeAll.
		self fit.
		self selectionChanged ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6968-someSubmorphPositionOrExtentChanged-justOneLevel-JuanVuletich-2025Jan03-17h01m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6968] on 6 January 2025 at 3:21:23 pm'!
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:17:20'!
           coreMethodsDo: aBlock
	self classesDo: [ :cls |
		self coreMethodsOf: cls do: aBlock.
		self coreMethodsOf: cls class do: aBlock ].! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:32:58'!
                      extensionMethodsDo: aBlock
	"Include both class and instance methods we define, for classes we don't define."

	self externalClasses do: [ :classOrMetaClass |
		(self extensionCategoriesForClass: classOrMetaClass) do: [ :cat |
			self methodsInCategory: cat ofClass: classOrMetaClass do: [ :m |
				aBlock value: m ]]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:35:34'!
                           methodsDo: aBlock
	self coreMethodsDo: [ :methodRef |
		methodRef isValid ifTrue: [ aBlock value: methodRef ]].
	self extensionMethodsDo: [ :methodRef |
		methodRef isValid ifTrue: [ aBlock value: methodRef ]].! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:36:49'!
                        extensionMethodCount

	| sum |
	sum := 0.
	self extensionMethodsDo: [ :each |
		sum := sum + 1 ].
	^sum! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:25:16'!
   methodCount

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + 1 ].
	^sum! !
!CodePackageList methodsFor: 'accessing' stamp: 'jmv 1/6/2025 12:37:41' prior: 16824930!
              summary

	| count |
	selection ifNil: [ ^'' ].
	^ String streamContents: [ :strm |
		| methods  linesOfCode |
		strm
			nextPutAll: 'Package: ';
			nextPutAll: selection packageName;
			nextPutAll: ' -- ';
			nextPutAll: selection sourceSystem.
		strm nextPutAll: ' -- Number of system categories '.
		selection systemCategories size printOn: strm.
		strm nextPutAll: '.'.
		strm nextPutAll: ' -- Number of classes: '.
		count := 0.
		selection classesDo: [ :cls | count := count + 1 ].
		count printOn: strm.
		strm nextPutAll: '. Number of extension methods: '.
		selection extensionMethodCount printOn: strm.
		strm nextPutAll: '. Total number of methods: '.
		methods := selection methodCount.
		methods printOn: strm.
		strm nextPutAll: '. Total lines of code: '.
		linesOfCode := selection linesOfCode.
		linesOfCode printOn: strm.
		strm nextPutAll: ' ('.
		linesOfCode / (methods asFloat max: 1.0) printOn: strm fractionDigits: 2.
		strm nextPutAll: ' per method)'.
		strm nextPutAll: '. Total message sends: '.
		linesOfCode := selection messageSendsCount.
		linesOfCode printOn: strm ]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:20:46' prior: 16823841!
  coreMethods
	^Array streamContents: [ :strm |
		self coreMethodsDo: [ :methodRef |
			strm nextPut: methodRef ]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:34:04' prior: 16823862!
                         extensionMethods
	"Include both class and instance methods we define, for classes we don't define."
	^Array streamContents: [ :stream |
		self extensionMethodsDo: [ :methodRef |
			stream nextPut: methodRef ]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:39:48' prior: 16823876!
                        methods

	^Array streamContents: [ :strm |
		self extensionMethodsDo: [ :methodRef |
			methodRef isValid ifTrue: [ strm nextPut: methodRef ]].
		self coreMethodsDo: [ :methodRef |
			methodRef isValid ifTrue: [ strm nextPut: methodRef ]]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:29:01' prior: 16823881!
                          selectors

	^ Array streamContents: [ :strm |
		self methodsDo: [ :ea | strm nextPut: ea methodSymbol ]]! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 1/6/2025 12:27:34' prior: 16823992!
 includesAnyCode
	self classesDo: [ :cls |
		^true ].
	self methodsDo: [ :cls |
		^true ].
	^false! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:24:29' prior: 16824109!
                         linesOfCode
	"An approximate measure of lines of code.
	Does not includes comments, or excludes blank lines.
	See comment at CompiledMethod >> #linesOfCode"

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + each compiledMethod linesOfCode ].
	^sum! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:27:02' prior: 16824120!
                      messageSendsCount
	"See comment at CompiledMethod >> #messageSendsCount"

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + each compiledMethod messageSendsCount ].
	^sum! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 1/6/2025 12:36:13' prior: 16824447!
     register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	| any base |
	self installedPackages at: aCodePackage packageName put: aCodePackage.

	"Anything that now belongs in this package, was moved out of the base system!!"
	base := ChangeSet changeSetForBaseSystem.
	any := false.
	aCodePackage classesDo: [ :cls |
		any := true.
		base noteClassMoveToOtherPackage: cls ].
	aCodePackage extensionMethodsDo: [ :methodReference |
		methodReference isValid ifTrue: [
			any := true.
			base
				noteMethodMoveToOtherPackage: methodReference selector
				forClass: methodReference actualClass ]].
	any ifTrue: [
		aCodePackage hasUnsavedChanges: true ].

	self triggerEvent: #installedPackagesChanged! !

CodePackage removeSelector: #coreMethodsForClass:!

!methodRemoval: CodePackage #coreMethodsForClass: stamp: 'Install-6969-CodePackage-refactor-JuanVuletich-2025Jan06-15h18m-jmv.001.cs.st 1/17/2025 10:30:57'!
coreMethodsForClass: aClass
	^ (aClass selectors difference:
		((self foreignExtensionMethodsForClass: aClass) collect: [:r | r methodSymbol]))
			asArray collect: [:sel | self referenceForMethod: sel ofClass: aClass]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6969-CodePackage-refactor-JuanVuletich-2025Jan06-15h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6962] on 4 January 2025 at 9:03:45 am'!
!CodeWindow methodsFor: 'GUI building' stamp: 'RMV 1/4/2025 09:01:58' prior: 16826573!
 buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph := (TextModelMorph
		textProvider: model
		textGetter: #annotation) emptyTextDisplayMessage: 'Class or method annotation (not selected?)'.
	aTextMorph disableEditing.
	model when: #annotationChanged send: #refetch to: aTextMorph model.
	model when: #decorateButtons send: #decorateButtons to: self.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6970-DisableEditingInAnnotationsPane-MarkVolkmann-2025Jan04-09h01m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #6970] on 6 January 2025 at 6:54:34 pm'!
!FinalizationRegistry methodsFor: 'removing' stamp: 'jmv 1/6/2025 18:47:15' overrides: 16847673!
                  remove: anObject
	"Does NOT run finalization."
	self removeKey: anObject! !
!FinalizationRegistry methodsFor: 'removing' stamp: 'jmv 1/6/2025 18:47:19' overrides: 16847677!
                   remove: anObject ifAbsent: exceptionBlock
	"Does NOT run finalization."
	self removeKey: anObject ifAbsent: exceptionBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6971-FinalizationRegistry-remove-removeifAbsent-JuanVuletich-2025Jan06-18h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6970] on 6 January 2025 at 4:23:28 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/6/2025 16:23:07' prior: 50339316!
              knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jpb' 						'Josef Philip Bernhart')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6972-AddJosefAsKnownAuthor-JuanVuletich-2025Jan06-16h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6971] on 8 January 2025 at 5:42:23 pm'!

Ephemeron removeSelector: #container!

!methodRemoval: Ephemeron #container stamp: 'Install-6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st 1/17/2025 10:30:58'!
container
	"Answer the Dictionary containing the receiver, if any."
	^container!

Ephemeron removeSelector: #isEphemeron!

!methodRemoval: Ephemeron #isEphemeron stamp: 'Install-6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st 1/17/2025 10:30:58'!
isEphemeron
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6973] on 10 January 2025 at 10:02:05 am'!

Smalltalk renameClassNamed: #WeakSet as: #OldWeakSet!

!classRenamed: #WeakSet as: #OldWeakSet stamp: 'Install-6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st 1/17/2025 10:30:58'!
Smalltalk renameClassNamed: #WeakSet as: #OldWeakSet!

Smalltalk renameClassNamed: #WeakIdentitySet as: #OldWeakIdentitySet!

!classRenamed: #WeakIdentitySet as: #OldWeakIdentitySet stamp: 'Install-6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st 1/17/2025 10:30:58'!
Smalltalk renameClassNamed: #WeakIdentitySet as: #OldWeakIdentitySet!
!WorldMorph methodsFor: 'errors on draw' stamp: 'jmv 1/10/2025 10:01:18' prior: 17009171!
      removeAllKnownFailing
	drawingFailingMorphs do: [ :m | m redrawNeeded ].
	drawingFailingMorphs := OldWeakIdentitySet new.
! !
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 1/10/2025 10:01:18' prior: 17009314 overrides: 16832614!
                    initialize

	super initialize.
	activeHand := HandMorph new.
	damageRecorder := DamageRecorder new.
	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.
	lastAlarmTime := 0.
	deferredUIMessages := SharedQueue new.
	drawingFailingMorphs := OldWeakIdentitySet new.
	pause := 20.
	lastCycleTime := Time localMillisecondClock.
	lastCycleHadAnyEvent := false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6973] on 10 January 2025 at 10:03:16 am'!

Set removeSelector: #withArray:!

!methodRemoval: Set #withArray: stamp: 'Install-6975-cleanup-JuanVuletich-2025Jan10-10h02m-jmv.004.cs.st 1/17/2025 10:30:58'!
withArray: anArray
	"private -- for use only in copy"
	array := anArray!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6975-cleanup-JuanVuletich-2025Jan10-10h02m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6976] on 12 January 2025 at 9:41:18 am'!
!Set methodsFor: 'lookup' stamp: 'jmv 1/10/2025 10:48:11'!
         lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	^ array at: (self findElementOrNil: anObject).! !
!Dictionary methodsFor: 'testing' stamp: 'jmv 1/10/2025 10:48:44' overrides: 50341472!
              lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	self do: [:each | anObject = each ifTrue: [^each]].
	^nil! !
!Set methodsFor: 'lookup' stamp: 'jmv 1/10/2025 10:49:13' prior: 16950673 overrides: 16828650!
                           includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!OldWeakSet methodsFor: 'public' stamp: 'jmv 1/10/2025 10:49:49' prior: 17007377 overrides: 50341489!
 includes: anObject 
	^ (self lookup: anObject) ~~ flag! !

Dictionary removeSelector: #includes:!

!methodRemoval: Dictionary #includes: stamp: 'Install-6976-Refactor-JuanVuletich-2025Jan12-09h40m-jmv.004.cs.st 1/17/2025 10:30:58'!
includes: anObject 
	self do: [:each | anObject = each ifTrue: [^true]].
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6976-Refactor-JuanVuletich-2025Jan12-09h40m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6976] on 12 January 2025 at 9:46:33 am'!
!SymbolSet methodsFor: 'lookup' stamp: 'jmv 1/10/2025 11:35:59'!
               add: anObject
	"Include anObject as one of the receiver's elements, but only if
	not already present. Answer anObject."
	
	| hash |
	hash := anObject hash.
	(self basicLookup: anObject withHash: hash) ifNil: [
		self basicAdd: anObject withHash: hash ].
	^anObject! !
!SymbolSet methodsFor: 'lookup' stamp: 'jmv 1/10/2025 11:54:12'!
                   lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it."
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock value.
		self basicAdd: newObject withHash: newObject hash.
		newObject ].! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 1/10/2025 11:53:15' prior: 16962895!
  intern: aStringOrSymbol

	^self accessProtect critical:
		[
			Symbols lookup: aStringOrSymbol ifAbsentAddFrom:
				[
					| preferByteStringForAscii |
					aStringOrSymbol isSymbol
						ifTrue: [ aStringOrSymbol ]
						ifFalse: [
							preferByteStringForAscii := aStringOrSymbol.
							(aStringOrSymbol isUnicodeString and: [ aStringOrSymbol isAscii ])
								ifTrue: [preferByteStringForAscii := aStringOrSymbol asByteString].
							preferByteStringForAscii class symbolClassToUse basicFromString: preferByteStringForAscii ].
				]
			].! !
!SymbolSet methodsFor: 'private' stamp: 'jmv 1/10/2025 11:16:10' prior: 16963096!
        rehashSymbolClass: aClass
"quisiera eliminar"
	aClass allInstances do:
		[:symbol | self basicInternNew: symbol withHash: symbol hash]! !
!SymbolSet methodsFor: 'private - lookup' stamp: 'jmv 1/10/2025 11:16:05' prior: 16963139!
                           basicInternNew: aStringOrSymbol withHash: anInteger
"quisiera eliminar"
	| interned preferByteStringForAscii |
	interned := aStringOrSymbol isSymbol
		ifTrue: [ aStringOrSymbol ]
		ifFalse: [
			preferByteStringForAscii := aStringOrSymbol.
			(aStringOrSymbol isUnicodeString and: [ aStringOrSymbol isAscii ])
				ifTrue: [preferByteStringForAscii := aStringOrSymbol asByteString].
			preferByteStringForAscii class symbolClassToUse basicFromString: preferByteStringForAscii ].
	self basicAdd: interned withHash: anInteger.
	^interned! !

SymbolSet removeSelector: #basicIntern:withHash:!

!methodRemoval: SymbolSet #basicIntern:withHash: stamp: 'Install-6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st 1/17/2025 10:30:58'!
basicIntern: aString withHash: anInteger
	"Look up again due to possible race conditions"

	| answer |
	answer := self basicLookup: aString withHash: anInteger.
	answer notNil ifTrue: [^answer].
	^self basicInternNew: aString withHash: anInteger!

SymbolSet removeSelector: #intern:!

!methodRemoval: SymbolSet #intern: stamp: 'Install-6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st 1/17/2025 10:30:58'!
intern: aString

	| hash lookup |
	hash := aString hash.
	lookup := self basicLookup: aString withHash: hash.
	lookup notNil ifTrue: [^lookup].
	^self basicIntern: aString withHash: hash.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6977] on 15 January 2025 at 9:40:31 am'!

Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!

!classDefinition: #WeakSet category: #'Collections-Unordered' stamp: 'Install-6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st 1/17/2025 10:30:58'!
Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!
!WeakSet commentStamp: 'jmv 1/15/2025 09:20:40' prior: 0!
          An implementation of WeakSet that gives food performance for large instances.

It is implemented as a two level hash table. The outer level is a closed hash table, and is accessed using the higher bits of each element's hash value. At each position a Bucket is stored.

The lower bits of the hash are used to acess each Bucket. The buckets for an open hash table. Each bucket has a fixed size for direct access using the hash, and after it, a variable size area to store elements with duplicated (partial) hashes.

Currently, the Buckets use 8 positions for O(1) direct access using the lower 3 bits of the hash. The iterable part after it can grow as needed.

Buckets are WeakArrays.

The idea for small WeakArrays as buckets is from a previous SymbolSet by Andrés Valloud.
The idea of buckets having a direct access part, and an variable sized overflow part for (partial) hash collisions is from Juan Vuletich, specific for this class.

Note: An implementations using these ideas, could be good for Set et al.
Note: Perhaps a three level table, with a fixed size outer level, and where the mid level arrays grow as needed, could further improve performance for very large collections.!

WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!

!classDefinition: #WeakIdentitySet category: #'Collections-Unordered' stamp: 'Install-6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st 1/17/2025 10:30:58'!
WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!
!WeakIdentitySet commentStamp: 'jmv 1/13/2025 09:10:25' prior: 0!
   See class comment at WeakSet.

This subclass only differs from it in using #== and #identityHash instead of #= and #hash.!
!WeakSet methodsFor: 'accessing' stamp: 'jmv 1/13/2025 13:08:52'!
   estimatedSize
	"Actual size may be less: as our references to elements are weak, elements could vanish anytime."

	^estimatedSize! !
!WeakSet methodsFor: 'accessing' stamp: 'jmv 1/12/2025 18:05:02' overrides: 16827542!
     size

	^buckets inject: 0 into: [ :prev :bucket | bucket ifNil:[prev] ifNotNil: [(bucket count: [:s | s notNil]) + prev ]]! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/13/2025 13:11:00' overrides: 16827586!
   add: newObject
	"Include newObject as one of the receiver's elements, but only if
	not already present.
	Answer newObject (even if another, but equal, object is already included)."

	| hash |
	hash := self hashFor: newObject.
	(self basicLookup: newObject withHash: hash) ifNil: [
		self basicAdd: newObject withHash: hash ].
	^newObject! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:10:53' overrides: 16827595!
            add: newObject withOccurrences: anInteger
	^ self add: newObject! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:55:11' overrides: 16828650!
                             includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/11/2025 10:14:21'!
                            lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise.
	Note: The hash will be used several times, and it may be expensive. Ask for it just once."

	^self basicLookup: anObject withHash: (self hashFor: anObject)! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/11/2025 10:22:07'!
               lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it.
	Note: Do NOT add anObject to the Set!!"
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock value.
		self basicAdd: newObject withHash: (self hashFor: newObject).
		newObject ].! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:21:45' overrides: 16828730!
               occurrencesOf: anObject
	^ (self includes: anObject) ifTrue: [1] ifFalse: [0]! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 13:09:42' overrides: 16827898!
                       collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.  
	Collect the resulting values into a collection like the receiver. Answer  
	the new collection."

	| newSet |
	newSet := self species newWithRoomForMoreThan: self size.
	self do:
		[ :each |
			newSet add: (aBlock value: each)].
	^ newSet! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 16:59:24' overrides: 16828068!
                          do: aBlock

	buckets do:
		[:eachBucket |
			eachBucket ifNotNil:
				[
					eachBucket do:
						[:element |
							element notNil ifTrue:
								[aBlock value: element]]]]! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 13:09:14' overrides: 16828250!
                      union: aCollection
	"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all."

	^(self species newWithRoomForMoreThan: estimatedSize + aCollection estimatedSize)
		addAll: self;
		addAll: aCollection;
		yourself.! !
!WeakSet methodsFor: 'comparing' stamp: 'jmv 1/10/2025 10:17:35' overrides: 16827645!
                      emptyCollectionHash
	^ Set hash! !
!WeakSet methodsFor: 'copying' stamp: 'jmv 1/13/2025 13:03:50' overrides: 16915537!
         postCopy

	self rehash! !
!WeakSet methodsFor: 'objects from disk' stamp: 'jmv 1/13/2025 13:02:58' overrides: 16916389!
        comeFullyUpOnReload: smartRefStream
	"Symbols have new hashes in this image."

	self rehash.! !
!WeakSet methodsFor: 'initialization' stamp: 'jmv 1/13/2025 12:44:39'!
                         init: n
	"Initialize array to an array size of n"
	buckets := Array new: n.
	estimatedSize := 0.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 17:51:20'!
                            basicAdd: anObject withHash: hashValue
	"Add an object.
	Note: It is assumed that the argument is NOT already included. Check senders."

	| bucketIndex bucket indexInBucket bucketSize newBucket |

	"bucket creation is lazy"
	bucketIndex := self bucketIndexFor: hashValue.
	bucket := buckets at: bucketIndex.
	bucket ifNil: [ bucket := buckets at: bucketIndex put: (WeakArray new: self bucketDirectAccessSize)].

	"1. If our direct access spot in the hasheable area is free, just use it and we are done."
	indexInBucket := self indexInBucketFor: hashValue.
	(bucket at: indexInBucket) == nil ifTrue: [
		bucket at: indexInBucket put: anObject.
		estimatedSize := estimatedSize + 1.
		^self ].

	"2. If there is available room in the iterable part of the bucket, add our new element there."
	bucketSize := bucket size.
	self bucketIterablePartStart to: bucketSize do: [ :i |
		(bucket at: i) == nil ifTrue: [
			bucket at: i put: anObject.
			estimatedSize := estimatedSize + 1.
			^self ]].

	"There's no room in this bucket. It may be worth growing the collection.
	I (jmv) could not find a good heuristic on whether to grow the collection based on a single bucket.
	The adopted one was to limit average mean occupation over all buckets."
	estimatedSize > (buckets size * self bucketDesiredMeanOccupation) ifTrue: [
		self grow.
		"Now try again.
		Maybe the new element is added in the first part of the bucket,
		or in already available room in the second part. (1 and 2 above).
		Or maybe growing the bucket as below (3) is needed.
		What is sure is that this won't recurse more than once: buckets size was just doubled by #grow."
		^self basicAdd: anObject withHash: hashValue ].

	"3. We still need to grow the bucket. Grow it and add our new element."
	newBucket := WeakArray new: bucketSize + self bucketIterablePartGrow.
	newBucket replaceFrom: 1 to: bucketSize with: bucket startingAt: 1.
	newBucket at: bucketSize + 1 put: anObject.
	buckets at: bucketIndex put: newBucket.
	estimatedSize := estimatedSize + 1.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:56:03'!
                        basicLookup: anObject withHash: hashValue
	"Look for anObject. Assume hashValue is anObject hash, passed as argument to avoid possibly expensive repeated hash computation.
	Answer the element found, or nil if not found."

	| bucket indexInBucketForDirectAccess directAccessElelemt |
	bucket := buckets at: (self bucketIndexFor: hashValue).
	bucket ifNil: [ ^nil ].

	indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
	directAccessElelemt := bucket at: indexInBucketForDirectAccess.
	(self areEqual: directAccessElelemt and: anObject)
		ifTrue: [ ^directAccessElelemt ].

	(self basicLook: anObject inIterablePartOf: bucket)
		ifNotNil: [ :index | | found |
			"We found it at the iterable part of the bucket.
			Move to the the direct access slot if possible."
			found := bucket at: index.
			directAccessElelemt isNil ifTrue: 
				[
					bucket at: indexInBucketForDirectAccess put: found.
					bucket at: index put: nil].
			^found].

	^nil! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:38:32'!
                             bucketIndexFor: hashValue

	"The lowest few bits are used to index into each bucket.
	Don't use them for finding the bucket.
	See #indexInBucketFor:"
	^ ((hashValue bitShift: self bucketsHashShift)
			"Take only as much bits as we can use."
			bitAnd: buckets size-1)
				"And remember Smalltalk does 1-based indexing."
				+ 1! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 17:20:05'!
                     grow
	"Duplicate size of buckets. Keep old buckets.
	For each old bucket:
	- Duplicate it as a new bucket
	- Move elements that belong in the new bucket to it
	- If possible, move elements in the iterable area to the hasheable area. This is important for search performance.
	
	Note: An alternative implementation is simply
		self rehash: buckets size * 2
	But the current implementation is much faster, at the expense of additional memory consumption."

	| newBuckets oldBucketsSize maskForNewUsedHashBit anOldBucket aNewBucket elementHash diirectAccessIndexInBucket keepdOldBucket |
	estimatedSize := 0.
	oldBucketsSize := buckets size.
	maskForNewUsedHashBit := oldBucketsSize * self bucketDirectAccessSize. "We're directly accessing the full hash, including the lower bits."
	newBuckets := buckets grownTo: oldBucketsSize * 2.
	1 to: oldBucketsSize do:
		[ :indexToOldBucket |
			anOldBucket := buckets at: indexToOldBucket.
			anOldBucket ifNotNil:
				[
					keepdOldBucket := false.
					aNewBucket := nil.
					"Move elements in hasheable area to new bucket if appropriate."
					1 to: self bucketDirectAccessSize do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									((self hashFor: element) bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ keepdOldBucket := true ]
									ifFalse:
										[
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											aNewBucket at: indexInBucket put: (anOldBucket at: indexInBucket).
											anOldBucket at: indexInBucket put: nil ]]].
					"For elements is iterable area, try to move them to the hasheable area."
					self bucketIterablePartStart to: anOldBucket size do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									elementHash := self hashFor: element.
									diirectAccessIndexInBucket := self indexInBucketFor: elementHash.
									(elementHash bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ "Stays in old bucket. Try to move to hasheable part."
											keepdOldBucket := true.
											(anOldBucket at: diirectAccessIndexInBucket) ifNil:
												[
													anOldBucket at: diirectAccessIndexInBucket put: element.
													anOldBucket at: indexInBucket put: nil ]]
									ifFalse:
										[ "Moves to new bucket. Try to move to hasheable part, or move to iterable part."
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											(aNewBucket at: diirectAccessIndexInBucket) ifNil:
												[ aNewBucket at: diirectAccessIndexInBucket put: element ]
											ifNotNil:
												[ aNewBucket at: indexInBucket put: element ].
											anOldBucket at: indexInBucket put: nil ]]].
					keepdOldBucket ifFalse:
						[newBuckets at: indexToOldBucket put: nil ]]].
	buckets := newBuckets.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:38:55'!
             indexInBucketFor: hashValue
	"see also #bucketIndexFor:"

	^ (hashValue bitAnd: self bucketDirectAccessMask) + 1! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 11:55:48' overrides: 16934010!
                        rehash
	self rehash: buckets size! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 11:55:25'!
                           rehash: newBucketsSize
	| oldBuckets |
	oldBuckets := buckets.
	self init: newBucketsSize.
	oldBuckets do:
		[:eachBucket |
			eachBucket ifNotNil:
				[
					eachBucket do:
						[:element |
							element notNil
								ifTrue: [self add: element]]]]! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:43:19'!
           areEqual: a and: b
	"To make it easy to implement WeakIdentitySet as a subclass."

	^a = b! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:32:18'!
             basicLook: anObject inIterablePartOf: aBucket
	"To make it easy to implement WeakIdentitySet as a subclass."
	"Answer the index or nil if not found"

	self bucketIterablePartStart to: aBucket size do: [ :i |
		(aBucket at: i) = anObject ifTrue: [ ^i ]].
	^nil! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:08:56'!
    hashFor: anObject
	"To make it easy to implement WeakIdentitySet as a subclass."

	^anObject hash! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 14:53:46' overrides: 16827821!
      copyWithout: oldElement 
	"Answer a copy of the receiver that does not contain any elements equal
	to oldElement."

	^ self copy
		remove: oldElement ifAbsent: nil;
		yourself! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 14:53:40' overrides: 16828464!
                        remove: oldObject ifAbsent: aBlock

	| hashValue indexInBucketForDirectAccess |
	hashValue := self hashFor: oldObject.
	(buckets at: (self bucketIndexFor: hashValue)) ifNotNil:
		[ :bucket |
			indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
			(self areEqual: (bucket at: indexInBucketForDirectAccess) and: oldObject) ifTrue:
				[
					bucket at: indexInBucketForDirectAccess put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ].
			(self basicLook: oldObject inIterablePartOf: bucket)
				ifNotNil: [ :index |
					bucket at: index put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ]].
	^ aBlock value! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 12:38:32'!
            removeAll

	buckets atAllPut: nil.
	estimatedSize := 0.! !
!WeakSet methodsFor: 'testing' stamp: 'jmv 1/13/2025 12:29:57' overrides: 16827640!
                 = aSet

	self == aSet ifTrue: [^ true].	"Any object is equal to itself"
	(aSet is: #Set) ifFalse: [^ false].
	(aSet is: #Dictionary) ifTrue: [^ false].
	self size = aSet size ifFalse: [^ false].
	self do: [ :each | (aSet includes: each) ifFalse: [^ false]].
	^ true! !
!WeakSet methodsFor: 'testing' stamp: 'jmv 1/10/2025 10:10:13' overrides: 16828691!
                               is: aSymbol
	^aSymbol == #Set or: [ super is: aSymbol ]! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/14/2025 17:56:51'!
                            bucketDesiredMeanOccupation
	"How much of a bucket to use on average.
	Larger values, avoiding waste of memory on empty slots in buckets mean slower access due to hash conflicts forcing iteration on the iterable part of the unlucky buckets.
	Smaller values, avoiding iteration and faster access mean more wasted memory.
	Some experimentation sugges that using in average half of the buckets gives great performance, with some disregard for memory."

	^5! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:06'!
              bucketDirectAccessMask
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal #bucketDirectAccessSize-1.
	See also #bucketDirectAccessSize, #bucketIterablePartStart and #bucketsHashShift"

	^7! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:28:59'!
                bucketDirectAccessSize
	"The size of the initial part of each bucket, that is only used for elements with matching hash bits.
	See also #bucketDirectAccessMask, #bucketIterablePartStart and #bucketsHashShift"

	^8! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/14/2025 17:53:35'!
                              bucketIterablePartGrow
	"Number of slots to add at once to the iterable part of Buckets."

	^1! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:13'!
                     bucketIterablePartStart
	"The first index of the iterable area of each Bucket.
	Must equal #bucketDirectAccessSize+1
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketsHashShift"

	^9! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:22'!
        bucketsHashShift
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal (#bucketDirectAccessMask highBit negated)
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketIterablePartStart"

	^ -3! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 13:01:47' overrides: 16787783!
    new
	^ self newWithRoomForMoreThan: 32! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 12:53:56' overrides: 16828875!
                  newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self newWithRoomForMoreThan: aCollection size)
		addAll: aCollection;
		yourself! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 12:53:33'!
                           newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing
	WeakSet newWithRoomForMoreThan: 31
	WeakSet newWithRoomForMoreThan: 32
	"

	| answer |
	answer := self basicNew.
	answer init: (2 raisedToInteger: (nElements // answer bucketDesiredMeanOccupation) highBit -1).
	^answer! !
!WeakSet class methodsFor: 'experiments - tuning' stamp: 'jmv 1/15/2025 09:22:57'!
              experiment01
	"For measurements and tuning.
	Slow and memory hungry. Adjust a and m paramenters, play with this.
	A nice visualization of hash values is commented out. Play with it.
	self experiment01
	"
| a bits f h m n o pixelsMask s w ws |
n := 1000.
m := 10000.
a := Array new: n.
Transcript clear.
ws := WeakSet new.
Symbol allSymbols do: [ :sym | ws add: sym ].
ws inspect. a inspect.
Smalltalk garbageCollect.
Symbol rehash.
Smalltalk garbageCollect.
"---"
w := 2048.
h := 2048.
bits := ByteArray new: w*h // 8.
f := Form extent: w@h depth: 1 bits: bits.
bits atAllPut: 0.
pixelsMask := w*h-1.
"---"
[
	1 to: n do: [ :i |
		i \\ 10 = 0 ifTrue: [
			{'i: '. i. Time now} print ].
		o := Array new: m.
		a at: i put: o.
		1 to: m do: [ :i2 |
			s := Random next printString.
			o at: i2 put: s.
			ws add: s.
			"
			bits bitAt: (s hash bitAnd: pixelsMask)+1 put: 1.
			Random next > 10.9999 ifTrue: [
				f display. Display forceToScreen ]
			"
	 ]].
] timeToRun print.
ws size print.
ws instVarNamed: 'buckets' :: size print.
(ws instVarNamed: 'buckets') sum: [ :b | b ifNil: [0] ifNotNil: [b size ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 12 ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 15 ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b allSatisfy: [ :e | e isNil ]] ] :: print.
'-----' print.
8 to: 15 do: [ :xx |
	(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size = xx ]] :: print ].
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 15 ]] :: print.! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:43:13' overrides: 50342056!
                      areEqual: a and: b
	"To make it easy to implement WeakIdentitySet as a subclass."

	^a == b! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:32:27' overrides: 50342062!
                basicLook: anObject inIterablePartOf: aBucket
	"To make it easy to implement WeakIdentitySet as a subclass."
	"Answer the index or nil if not found"

	self bucketIterablePartStart to: aBucket size do: [ :i |
		(aBucket at: i) == anObject ifTrue: [ ^i ]].
	^nil! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:09:15' overrides: 50342073!
       hashFor: anObject
	"To make it easy to implement WeakIdentitySet as a subclass."

	^anObject identityHash! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6978] on 14 January 2025 at 1:07:30 pm'!
!WorldMorph methodsFor: 'errors on draw' stamp: 'jmv 1/13/2025 17:03:05' prior: 50341426!
                    removeAllKnownFailing
	drawingFailingMorphs do: [ :m | m redrawNeeded ].
	drawingFailingMorphs := WeakIdentitySet new.
! !
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 1/13/2025 17:02:57' prior: 50341434 overrides: 16832614!
                       initialize

	super initialize.
	activeHand := HandMorph new.
	damageRecorder := DamageRecorder new.
	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.
	lastAlarmTime := 0.
	deferredUIMessages := SharedQueue new.
	drawingFailingMorphs := WeakIdentitySet new.
	pause := 20.
	lastCycleTime := Time localMillisecondClock.
	lastCycleHadAnyEvent := false! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
WorldMorph allInstancesDo: [ :w | w removeAllKnownFailing ].
Smalltalk garbageCollect.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6979-UseNew-WeakIdentitySet-JuanVuletich-2025Jan14-13h04m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6978] on 14 January 2025 at 1:09:32 pm'!

Smalltalk removeClassNamed: #OldWeakIdentitySet!

!classRemoval: #OldWeakIdentitySet stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:58'!
OldWeakSet subclass: #OldWeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

Smalltalk removeClassNamed: #OldWeakSet!

!classRemoval: #OldWeakSet stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:58'!
Set subclass: #OldWeakSet
	instanceVariableNames: 'flag'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

Smalltalk removeClassNamed: #WeakSetInspector!

!classRemoval: #WeakSetInspector stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:58'!
SetInspector subclass: #WeakSetInspector
	instanceVariableNames: 'flagObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector'-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6981] on 14 January 2025 at 1:17:53 pm'!
!Symbol class methodsFor: 'class initialization' stamp: 'jmv 1/14/2025 13:13:34' prior: 16962889 overrides: 16917943!
                        initialize
	"Rebuild the hash table"
	"
	Symbol initialize.
	"
	self accessProtect critical:
		[ 	| allSymbols |
			allSymbols := self allSymbols.
			Symbols := WeakSet new.
			Symbols addAll: allSymbols ].! !
!Symbol class methodsFor: 'private' stamp: 'jmv 1/14/2025 13:17:28' prior: 16962935 overrides: 16934010!
     rehash
	"Rebuild the hash table"
	"
	Symbol rehash
	"

	
	self accessProtect critical: [
		Symbols rehash ].! !

Symbol initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6981-Use-WeakSet-ForSymbolTable-JuanVuletich-2025Jan14-13h17m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6981] on 15 January 2025 at 9:58:37 am'!
!Integer methodsFor: 'comparing' stamp: 'jmv 1/15/2025 09:56:58'!
                  hashMultiply
	self subclassResponsibility! !
!Integer methodsFor: 'comparing' stamp: 'jmv 1/15/2025 09:57:42' prior: 16886667 overrides: 16913818!
             hash
	"Hash is reimplemented because = is implemented.
	Siimply answering self as #hash has bad performance for the following:
	| s |
	s := (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	"Can only happen in 64 bits images...
	See Float>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
	self abs < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].

	"In 32 bit image it will always go this way"
	^self hashMultiply! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6982-CommentTweak-JuanVuletich-2025Jan15-09h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6962] on 12 January 2025 at 9:01:29 pm'!
!Random methodsFor: 'accessing' stamp: 'eem 1/12/2025 19:26:00'!
 next: numberOfElements
	| elements |
	elements := Array new: numberOfElements.
	1 to: numberOfElements do:
		[:i| elements at: i put: self next].
	^elements! !
!Character class methodsFor: 'instance creation' stamp: 'eem 2/5/2014 12:49'!
                  value: anInteger
	"Answer the Character whose value is anInteger."
	<primitive: 170>
	^self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6983-Random-next-and-Character-class-value-EliotEmilioMiranda-2025Jan12-19h26m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 11:52:32 am'!
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:37:45'!
          recreateObsoleteSubclassesCollection
	"
	Behavior recreateObsoleteSubclassesCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ObsoleteSubclasses keysAndValuesDo: [ :k :v |
		newOne at: k put: v ].
	ObsoleteSubclasses := newOne.! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:49' prior: 16789366!
       addObsoleteSubclass: aClass
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"
	| obs |
	ObsoleteSubclasses ifNil: [
		ObsoleteSubclasses := EphemeronIdentityDictionary new ].
	obs := ObsoleteSubclasses at: self ifAbsent:[WeakArray new].
	(obs includes: aClass) ifTrue:[^self].
	obs := obs copyWithout: nil.
	obs := obs copyWith: aClass.
	ObsoleteSubclasses at: self put: obs.
! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:46:50' prior: 16789383!
       obsoleteSubclasses
	"Return all the weakly remembered obsolete subclasses of the receiver.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^#() ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^#()].
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ ObsoleteSubclasses removeKey: self ifAbsent: nil ]
		ifFalse: [ ObsoleteSubclasses at: self put: obs].
	^obs! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:11' prior: 16789399!
                    removeAllObsoleteSubclasses
	"Remove all the obsolete subclasses of the receiver"
	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses removeKey: self ifAbsent: nil ]! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:47:11' prior: 16789409!
                         removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^ self ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^ self].
	(obs includes: aClass) ifFalse:[^self].
	obs := obs copyWithout: aClass.
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ObsoleteSubclasses removeKey: self ifAbsent: nil]
		ifFalse: [ObsoleteSubclasses at: self put: obs]! !
!ClassBuilder methodsFor: 'initialization' stamp: 'jmv 1/16/2025 11:40:05' prior: 16817262!
             doneCompiling: aClass
	"The receiver has finished modifying the class hierarchy.
	Do any necessary cleanup."
	aClass doneCompiling.! !

Behavior class removeSelector: #flushObsoleteSubclasses!

!methodRemoval: Behavior class #flushObsoleteSubclasses stamp: 'Install-6984-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st 1/17/2025 10:30:58'!
flushObsoleteSubclasses
	"Behavior flushObsoleteSubclasses"

	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses keys "need a copy" 
			do: [ :obs| obs ifNotNil:[ obs obsoleteSubclasses ]]. "remove themselves"
		ObsoleteSubclasses finalizeValues ]!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Behavior recreateObsoleteSubclassesCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6984-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 12:09:31 pm'!
!ActiveModel class methodsFor: 'initialization' stamp: 'jmv 1/16/2025 12:06:37'!
                               recreateActionMapsCollection
	"
	ActiveModel recreateActionMapsCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ActionMaps keysAndValuesDo: [ :k :v |
		newOne at: k put: v ].
	ActionMaps := newOne.! !
!ActiveModel class methodsFor: 'accessing' stamp: 'jmv 1/16/2025 12:06:43' prior: 16779373!
     actionMaps

	ActionMaps ifNil: [
		ActionMaps := EphemeronIdentityDictionary new ].
	^ActionMaps! !
!ActiveModel class methodsFor: 'initialization' stamp: 'jmv 1/16/2025 12:58:12' prior: 16779391!
                           flushEventSystem
	"ActiveModel flushEventSystem"
	self actionMaps keysAndValuesDo: [ :rcvr :evtDict | 
		rcvr ifNotNil:[
			"make sure we don't modify evtDict while enumerating"
			evtDict keys do: [ :evtName | | msgSet |
				msgSet := evtDict at: evtName ifAbsent: nil.
				msgSet ifNil: [ rcvr removeActionsForEvent: evtName]]]].! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
ActiveModel recreateActionMapsCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6985-ActionMaps-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h52m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6984] on 16 January 2025 at 1:06:58 pm'!
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 1/16/2025 13:04:20' prior: 16918067!
     monitorList
	^monitorList ifNil: [ monitorList := EphemeronIdentityDictionary new ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6986-ObjectExplorer-UseEphemeronDictionaries-JuanVuletich-2025Jan16-13h04m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6984] on 16 January 2025 at 1:06:58 pm'!
!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'jmv 1/16/2025 13:04:52' prior: 16844813!
      voidMapCache

	self protected: [ 
		MapCache := EphemeronIdentityDictionary new.
		MapCacheEntries := 16 ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DebuggerMethodMap initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6987-DebuggerMethodMap-UseEphemeronDictionaries-JuanVuletich-2025Jan16-13h04m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 2:53:34 pm'!
!UniFileStream class methodsFor: 'registry' stamp: 'jmv 1/16/2025 14:51:58'!
                        recreateRegistry
	"
	UniFileStream recreateRegistry
	"
	| newOne |
	newOne := FinalizationRegistry new.
	Registry do: [ :fileStream |
		newOne add: fileStream ].
	Registry := newOne.! !
!UniFileStream class methodsFor: 'registry' stamp: 'jmv 1/16/2025 14:52:21' prior: 16994237!
         registry
	
	^Registry ifNil: [ Registry := FinalizationRegistry new ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
UniFileStream recreateRegistry!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6988-FileRegistry-useFinalizationRegistry-notWeakRegistry-JuanVuletich-2025Jan16-14h45m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6988] on 16 January 2025 at 4:35:07 pm'!
!UniFileStream class methodsFor: 'cached state access' stamp: 'jmv 1/16/2025 16:34:16' prior: 16994352 overrides: 16789305!
  releaseClassCachedState

	Registry ifNotNil: [
		"Make the best effort to empty the registry.
		Only keep files that are still open have references from some object."
		Registry isEmpty ifFalse: [
			Smalltalk garbageCollectMost.
			Registry isEmpty ifFalse: [
				Smalltalk garbageCollect]].

		"No open files. Can nil the Registry."
		Registry isEmpty ifTrue: [
			Registry := nil ]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\32BitsImage\CoreUpdates\6989-FileRegistry-Cleanup-JuanVuletich-2025Jan16-16h31m-jmv.001.cs.st----!

----QUIT----(17 January 2025 10:31:01) Cuis7.3-6989-32.image priorSource: 278088!